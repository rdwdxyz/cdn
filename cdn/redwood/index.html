<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5fdb8b6dfb98e7b71631aff785d7c6c6e3271648dbb8f5467b9057ee627dc3c5b8700c6aa5ceca9c449216e2ae9cd0a51fb9750428ea3957e1eafa60edb29fab8e5fb3761faa288e1b89eff44f780472b8de630a7ed969563dd63142cd0ffd696abda169192462b3bc9375be50c1ff0d664d8cc9f9a1858740d2f038b51a82388c1bdc86e56a928456fcd414f5789a05e954f36cbffedee5a6a77bada740f367fe26bf349c0d7674e34ea10dcc8c94f89f860871418ab878411a2b5e88c4d231c1cc8e0c4e304434c165c70d055c1412153503ee5885def85e72bf7b38b7ab2ce6615a80c045fde949316fe9a13d92bae9bf507ea7022d90a2f40243b9a759c5b439c1aa46423ee9963eb3fe62c96bbb45a42593f03fe86cd7f6e16c79809fec3eaae3dbd174eaf5aa163b717b2b84dd7fd835f1899d30b28c8f18367aa449cf4d682dd69f784f0693dd314d662ca48ae1326c13a883fda0954b17dc79613a5ff7537aded0daf8b299917714f504fd10db7272b5d2bc76300fde232a981b268e3a7d105184122ed44c5544f0cd5952a4ae7f9c2e39e48bcbbbee2eaef5254ca67613f7f39c4170c7078895ce0fc947de6328466814b9c1aca48ab3b5dfbabca167e5b58b81c5ca8dcb132862299b9c57afed4e32366edd97151714c7b146a8f492ef1f22f367b131f7d2a57f64e779897f9b9f511d5fd0dbebd8d93c18f11aa0a098562a2b7a6bdc21ed9ac0e57ee9891128fafcd0357fcc9be3787f7a3593a4a4b3c3126ec875d91083a8a99fc0f40d08bf09a54685cbbdb68568b5c37b2dc89aacdbc072015192b390ed929eaa7f92a5173dd27ade9d15755edae1ddba30d92d7c8dc23de4b8d98403c9c9b6f2373d1b5b3254eb36b6da94f0172231c1dc96e9343a3be43ee43d25cf756e7bdb282228a316e948750f73feb94b9f7c1119ef44aecf9cc5a4d6917ec0587611d3b7e41b76385d5758b300da2edcefb1f26f2b03654aeaeadfab55f97a33c31784d67f3a3e2c7f292f47f177e6e1bf8cf360b932116fdd9c3640eaff862a4e4d6439981042b5ccaa1dc8ea6ba452cb8b16ba48b9669338f73ce1c781839374989f1e82232a0cfdbb30bb5393ba67cd6ab279dd36d453aae577d8c2896b66a91a4fc8589a2f9a879eb8529b22418178a133b5b64351bae9e772d8d03583e2312f1e59e842226f90bac18c6082ba1c29cdd4c1ef842c1b9a1a2bb6cfade7f969b1ce67d5e7bd1ac8d7d785945cc1fc6ad538cf02832b6db4ab62c1fe442c2ea9f40779d80fb663e35ae66a8e3e45ba4160580cdeb361d822a28e4d104fd48689ad2aa4064437dbbae83fd18dbbb20404e98a2a36d06ff445f18a7241d73f6e6135b197868b5ff5e1fddb8aa5f6395992a62aee3e434e4328d10a7cf0318605671c17772b327ec76ab5cc9e71347b7a83b6201230cc8cb1cb26f4f341b8d0ac8204407d7eb09787829df3ae41c652acdf6a65ddce89a2536dd995944f07b493192ab8633b3407f211d12536417ed2c909db4d2645a908780e897e6175756118dcee2e4cd6eea8da928ef9b262c7a67fd7673a703d8159d2e769c6f5a5d44752f56a3632a66501d4a03c8e303d15b01248fbd8d5a0f73a6add62e3cb05f9885761023eec660dc8d2565b6fb1509ce755755f97cdb70f7d3fef2cf81006cb5b80474076fb7b8a17962ae6eb2589f5b8d91ec632cbd50332bfc8af82d87deaec192970a09d15687b64d610f980c2ed0bcad422bfd22792bad057754851832855d856ca5e347594e28a2db89a71aa19232da66096958a1d9d9b1e383cb81dc839a05790267a2be13de6e3131ef126e1c9c25c260a4ceb93a511024a2970fca4dee033b98928b61455a1cdf60726fb396977de07dfd3bed5e858e0a0570d3b2af649c8fa7cc210c6f386f84d08b519d296edcd4fee59852e36a4f411da1da630ac075e3d807db65fc7fae0b139265aabeb2ce1542c19398e75a7e5a1e05e1b79c53f233520038840421071fbd50086c769435c086a6a2e6d9cd30d47eab01bc019919d45d439cb7c8979d0e33b74729e4138e58d7704642bfc75a60e6e008e0e82c2906fdab015f7872c03a23648e7b4d97c0c0a002354bf5aa328488832be308b02e65abb097d3bd118030f955f8494c9a5ec2f91505d3ceb1d9c0257789b24b9b1a34f767149b0387f40797fbc4fcf48f68e7005215194474a4e441aaf7573d0d74b0facf3f40e5d18ca309da37a73afa4c7308a471ce744015a9af9fcf1e90cc278371b845d69101db31a973127b5c024496737d0f0a59aa248fa2affe12baca1b91d44b873c41f53197e7e94036babe42e0783ac827dc1a5bfe2ae737dce51bac9b965000052887a22aaae75aa80df4384796b8ccc4fc49c62890ffe857b7d90c831c6e5e8827280e886f5f8ff097f069759d91c71d1cf12d541c2e2a49bd56760903f0fd2cffa444de3268aa9cdf030fcd384eb46c8fda1dad1e78b03b90c54ffcc22b569a091f141ce3e6b8df7cfced5908b752b6b506b289469a1aa3b3e15935eea0ffe1c705c0cbfaad692a013ce5609d0aed1b4c86cf6e2a9be630cbe57186203ed4b723480ec9ca6e2ee4d52162a2812e705b84b68b61546d0071c345351f145fcda1a59d4fff4c34144a5f1d109c94c1364ba85c83a34c950d1fc3b0a3213108f0ea9ac5f1b6effcd3d7a2c75226bf22874812c08eb302e334992014b44c4c41310e82d0bee58e4aeff08747aff73e9647ac2dcc19fd5ae51570e1125b14a31a9d64ee6a8aa281bb933e0e9f20e6e77d3701ec7480821bb3c8703f567480e74bd0c0e709956deaabdbd316b7a118db8dd802e394b319177af64a6199ff40ae0533b7e65b04e83e97fa49e84a66a9721aacca8eca2322d1b686896d25b17770ac4008514b52112041d5013287d2b9d7920668fbbf1b039fd21f9e7af7ffad8bedd349c7c214849637122fe54f7a3aa4528c5b6cd867b6d0137a1c57563d6eef8effb002da32431c1ce63ca2bbdc0479340b3df269dc3cf0c8d7c163cda83d4f15a02921d04a3ef39f4af989433cb98f8cd99f70ea25458686ffe280fcf5acccad082855b239ea6b998f68a59da3038badf0e3968b9363b21552a04ce6dff9ef7e6849dc317a9b45febb49c0060af8cd41824b37a8d001470c7f34800a8f9fdbe4c1f081da03325c9e4585c423bd936eecb1bb1346f0f761be677a914210301f61b4a78a04bca9901a33b045a7dfb63d729a7f58afb5c0053d2fdeaf4aaf1effb0dff8fdb9dfc54c843b86899dee5ffa86f0daf0b54a74f142f596555ab7a73ee667e9488002db93fd6dca0343e7202c0b4f6abe6696673e0789de06a5ce114d10fe505b9642dc512ee3844fa2d63c6c287ad0142404d2272849e311f7608e7fe4e60621197d12343115c26b9b66f54514b688a94d18252b30722bdcc543b9747dac99ec7f978ab2bf65c87396f2f7676d968d5ab2332695d2d07d436d178895f43c7d4f7d165055694838728166f7c5e7505b0c30db3a14ea96ed183c8854d052a66c972f4dcf0ae58efbf34dfb4a8fcee7ec1c066612e603220315fba3cb3b195656fbd5b963cf0de57e70127fe129184c0ac203475124bf2ad59188759d79262ce727d8bbeef158a2eeb48cbc034605bc773fbf4fe9563ded3f34410da372362ee24d0ab913b83c61d32f40937eb91ec5ebb8df270188f94b7cd80afcbe943cd131dfd464bb6aa4a5f221ce186e49137237ed00df08e3d4afa0e2fee68e76a838c04f588907e45e33950fd8f29d1b6afb07697508c1d0aa3d6408b2cc1aa4eea32871eaa76ab303f0baddd63607179d8e7bac9d216d669aeac561194fb4246fba10577a8bf9ae38e54a525ca43aa9306a68f0f87b620f0d814d2a57031e6a37fd79102fc7230661976b8f70381937f85259deb90b6142aad67485d74c5952e1c26f1a80e0fdfadcdea8496cd9020476b181f64867a4116410896572bf40162cb3094bdf17c7c5f1b0fc3fdae14d924fff93356766d0441e6d9146f0a79451dbbd9fb8f500c484016630ff5b6ca403f2573d09cb7098132f37cc9b0d3162bdc1a90468ee9d01e74cb16b3e9c984d5400490265f943dc40f12b76a93dffe183bc81941b69548fc30f96f7b5ed27c09b9cfaf7067849a8e09ae85349cbaca1f68eb68d73f74705fad1738e8ba465165a7ae79e1adbcbdf72aa12ded071ac3509ab933ddf19498091d90c46719edfa06f1f07bd8a160cbfb37e252c1027ff13f09342ee6343046315c0a9fe2ee13b7e37edb4ab3ba54d1f4a6865727ea0a79ca5cb89e9363536efbe25b2656cdf5840521d7f057c071c3080a525589a083d46f44916f8bac0776df0ea63cbc091b652f4a145a801ddbed9c8450fcddfe15ddafbd88434e60d969b670dcd2e3bdd2266e6b8d8e9c295c0b70e2ad9c38c9fe86fe1d62dad15d4f1807a4219df19fcd563341ace193e47e9d0f5db5c67af8d98361fbe11c7640a1d161ce3d8095d46beed9eea26627f5e53a2595d8852b2ad6a3510085272ba4c11c8b523cda73a9174726f2a3764e83a45edde51770bd5fd0fdd18654ba3c20ed5839d2252ab0da15e5372692d58c468add98a017924feb7765f0de65cf4f23e110d6355174bc3f774ecd5944e89423dabb9f7aecba799bf271b8541c16a0c443c6658ee3cf2fc66ddc4ea6a24f123e3dad1968b0a48f7e194b7312d0d4302b514f0bab82917dbefa5123481a8a7369d611541c106dba85761784431f4c9e4c8fe5258125ee5c04c2acaba35258f139fdb50cd88f7d4f913f9deeab6bb1e25e78dfacbb41958bc0545624cd36127dd7b36837e259a141b476106cdcdc2757939ba01b3d0d674ddb6f6ff4bee564adf254c94f97f8e0c039b2c198a4c1839adf97f74fbb02ea96a6b77c176e1807d4fec43a5ad56d5785d0e6224f5612ed970b22cf0cae2bdf24915404fdf194b5e2e3db2026bd0c4d63180327677ce7db7d64a3da3b767166848873dd9e9f41c21ce8b116c085946444d408bcbc85d3f5cc41d94c5bb497d32bfd20711a2ce618f19acc2e30901ea5db4c26b41c7d026fe1ad6a18d2ccc92d63147c1bfa4afe123c334b4e263014cdbe02e6344d1d0c338a1039203a2e5b1c84efb83d9657284764435a1a12ac25a15859a9050e7d1cde8bd1fc4bf24e3807f047ccaec4d9000224da9065e4a12aadd5e080bb7eadc4221776a815243144a7d8711bf5dce4f1f44433c144b790cb31aa1b58fb6e56f53232072e04a87da55d8b717f9dbf82c0420e913b91cce4dbeb445feb78a8b93de6427a584599408af445d1d977b1d36e05c8e48cf5b26b063bba104ce5b145de7e7575a1f507243acb70371f8b01767da07d803156773b991a1770100fa918f319c789109f530670354c9fbce1aee3b3ffa0d512a635e3415dd8ff2b91985f471ade220ac82118b303566209c45e2db21f51d7c8b327b790fcec8fda081f3583c28440df96e5ac9859ee453c98ff648f591912d4d2f1b3d412da48ab0620894ac6bab53126ec098211e2652bfa7b422284ea30c0a8568ea5866c0f7aaece0e8646d187101c743fda8bbb470e7ba352e1ac1c72b79409c53f559fc7bcae0daa4b1aff05620196b4b67a1174ed54ea4d7adf95ec754619a6731cb76640ae0b3ef0d94dcca34f48e3d7f0bd29821a3e3565b7e4ca3a1082c49f685ab2aded4f827aa0286a8247c293cd22ee45b2dbda7ac61bf514ab1f4c31e6db1e401d65ee835d4f30669609a7210ee5c205f4a9f1443981c66b0bdcd4f0062e589c6c93dd4f5a32b9c1c83598bdeae09d1e2431dabaf9c9f25529e6aaff5b6e9a97d922d0efab44e50d9bfd04590de6282e27375ca40074cc2e7067714374169102bf2e40735577e87c30fabd286fd3faa044c1243a685e3dc18b3a20ba53d26a8a3e44915e508e581b5e0f73169a5cc2b22105aa9e554f63b9412b1e7eb1ae3e0f5790d4a1ae7ce2e5d0c65bcd57678ad791769e6c50f51bbd8eff6a4170c4032666a812849f992e934f141c0af94a3ba6b73f06296c44ac73dd408767aac9415882120f3c7484b92ec016ff5a22a7209a98dc2c5c29c375148c0f91d05182f88309a589d8e568759cc731a8679703d210370c668c75bd15c34bf00ab56e0011a804ec5b1b964b5711d5bf8a0cf780827ad627715f6378cc1a16630f7e81fbbba5c2fe761eb61174bbb01c1e620404c9ba914d6aeed60b605e50788d2f08ab3c61d50a348e46622de96bdb123f8f05308654871893a2713a82c4a4d209140b681a62c93510c53c20ae195e7be18b561c7f14d7ad16c1066c11a5bbdca71285153f82fb56b55f2ad953c16f075981751420f37babb9eb07dc903a8c51406f1265419a6edb0e7e0e36a4e32041ea0b65ab43449e8f09a301ed7a87c78157f3945079d9ed3eca286b1398912c93fccbeddc19f30ccc8bfa121b63f83f950886040dc22cdde9ed6d8b1f2caad67db3119bfa2e0c248c9a78f72c0dffa5dc1b0a657a8ec7674bde49b103b31ca1f50c7d2e52c452e62a106187c0b8618a6e5032ccb7c16884bce4a94aa560f0609306d3cb2dea75f4435afc464cf37442b94c213f2286281ca666a0fff630ef36523683cb935a4d9ddb8e032ccffb06b50a8f04d8e833c97019b81b0b3bcdf7328ce46d5e60b9e837a82c5580195dcd1730710f4d2a9611e8dfab4c68128de5806fc2d988a3044dc1953926b1aa1896d1453edf2f376b4a32549075449244a4c06a997ae6c1c15902d7fcef780923b5ec6bbef7a6aa24e12330b20a4b0c8466591dd8af1f5b3e6b96b614d44f16f92d0bf65c6c0cef4069d61a92ca090094f871c84833358556f2483b3f30b32ea11cfcc9f16e8683959a7c9413d852f41cc458c0ee3c43d0119c19f189a0e90c5d69fd11c8696c97478d7a0ba57deefc7de75c5313065eca0fd85c6df3325ce9a06e79edd194a28ba0758d2ae4b36fee09e0faf9539c9e022e21417fbe5faab2532b309378065274f190cea17c1f7f85b8354fbd232ba5bb1d1e4b97f44fffb87dddfd03ae1677c7a1f7f66a2473f909b24f8d2f39a90d362c1bb9c0be60ddb50ae3f703f1e7f4bed208c78ff807d3dedaf85f4478da04faf6b3aaf838212a74c212db6eb92f8747b8aa49f6a80831487cdb4e7f3b09b675d4a897e9ab0fbdeac3da0e28f0cf08061b38a7b7a5829975b51f4e4f500f1e9ecfa1d1d2bd65502a0663259080c75b21a03bd823e29395fe4d74b3b2a4cd4e7531a247e0030e108e4f522eba827d9608b9d1a042c676173685ffa7937838d2fe4584e7a5dd42ef24f9d5bb091429f3ed91830c1d34f9f2cc9158cfdb51a888d1642d6b141ba1c4619fd2852d4052eba6cd8a45c06b15b2402f13921fedbe9722edb7856a1a36c00e997460583a5c4178c9ccdfb87f71b1ec04af9d181ecd2f6209ee8bfcd03e2cff155668ad943b59b47146685e7d97ce87d282d993fbc5229411c7d831794fc2e68c7f2990a8e029ee0e96dab2e14a4d8c70d7830459234ba6f64300cf3dde8c70aa140439013c3d614c6196f6ea07b1e07077c22a5ba0bf000261faa377b9df1d392ff7a7d45c64873bf513ecf2e35023ce2d11877529ff550b5cee8b6950f822874da0e0f77e8486cf45c4670809989dd776cd27711641cbb85799c2ecc25e3f609eeb99a425d2881f78f66c5dc6c507dc918c1d85cb6e57b20ae66785df1d08dc09dcbbc41bc5426a34a3021034980105eac27bb606c750cebe3b935f7c0ad356ad5795989a908f1ef67ba067d1b4f6ef4209d6e30e71b99534ff0e5e5bced7d036645e06f0ee813da25c89fa06257c0a02117ed9553898e321570e87f985e8e4198f28ef9c45ddec56b7e91240672c890132b935cc9c5e60dd8fa536d67a21dcdf789781067964b2472ac380a1f0ac371d8126729be8dd654126fd44a7e64b9fe048298314292be339868befb55935fc5e63b3fe6e51c0f672749b71b6cdaa2e58e012f5c0168a7992352bf5e2a7e942a49a59f4f4e30946312eb728d8bc0738196209fc50ecccaea937c3f3505fbfdc0b2077860c4ce4f0501396abcea6d4ef3688cbebad440b6eba4b039fc80ad9278745c7854e1aa6bc33bd7a64a97c86491b76434be43cfb699219fbd625b9114237b8643c1d1fb510a092a40ce93186bb1438199113c307d783281e8f94d850477c732f3e0cc1053b1ebfaf2841a3b5dd6f6faa6bfd55c1b58b71e9e52abb60857819d9667dced82bf3d9defa408ffe5c60f15a2467327ea4059e6fb5cd5f612af2ec44d336e3d7f641ebc5490986a0518117d2665adec06c82c907116fbdfc0a55f2f28ba7e3562d6e157c3b10d54427f4dd2fb2812a0769a7a3beedcdbc1d3c1fdfb45f6e79e248c93d3037156fbbe5506d2f782220ccd9a1f1b8fea94dec0e6e78c8bf2200c9fb6dd86fe21f46b8c0423fb7186097911acc1cd61c1162a1a9166d7259e392d88e9c81acee3c1d989b7c0b4cdd96e98b798a30ba944a4816300ccebbaf562edf6a287b90b9a16013d01ad04a4907e71a6bc12f98d53c566a278353561bdc5bd734e54f8c2f8f781f8a465201697b4f128cda7e8ee78a1eb83a178a3a2788a332eed4feea693527cf244f1c125718cbe244d78cfbe29812f8c611d98b95044b075817676aa66a743ecc8a951e959ee319af81e39964cf9c6354ae0ac51a6d2a22683bef9810bdd808cf820804e7f88db21b7d5c1185bc2944b5975137295a0892a5228b361daf7d24d7286da021e8d3a6356b772aa98ffaaf8e073d5a900e3c2dc5d53f965633e12f606b309772f9bd1be1d69e1a34f409be40cfec1be330b7e37c20f1be5069089eba0d883c16c05f894b61816097e50a3186e245d363d7187841a5e3b536a9c4315b32364ae6695c6bfa413127d34bc4874c2723548057809fb170b7b1c98b5e6565853009fdd8f35d6383cc1241116a5e2843dcf6be81d55bf453f1029b2a903a46f4ea57e6e6413677633e9d244658fb594ebeaab09e7aaa42f335e86e12e2f96ae1e15072aa28be22531addfbecd2a24b03cf888289539d3cf9d449d7bc16f7c193a58fcca7f025731785f93ab889208e5d19df46e617281191ca80ba9f486f3dc9d90a170c1d97deba195bbe47c4b5e213853b878976cb2ff5f31793d997cb05b04d8ec1c021707b22fedc9d3d17352fd08ed3278733a2a476e29a39603190fd089ae70c8274a5a1ea2090898b56d8672f533b4e64b267d79b4705f9acd4232f335ff573b35610943588c1ed0ecbede685d4a1b5c1d13f8713e4742072f23cc218bc32d2f75c63b36b9275fa0e56773a699cc485475526e6d1dfe166eb55fb155955987be7f459652045419a2a27bc8e66690f2762dc24868329283e4dcc426b10fd5829132c7c44b7c6f6e18c15753613d0fbb15831c547faf34c884ad1ddcf2a7d66102d1818bf821508b5783a9e3cdc33c92b1f1e808191410984c1e019a428d7e898be74f379cdaecc93228bb078c184bfff83789ab46e36b57db2f1ae0fa09d53828c46dad90d3c14dc999aba9ba3e0eea0187497275fe269e810c263ef978e746736da1180725506d0c051286be77b425865b8fb58444ec2a023daace3ad656f2637967f77c2374913711210e58f2a1305a4b2e063159fabc4023b5a7746e050c4a66340f2677ab8b3ea266f3703956288187797951bdba47df157c44868a4041e55ec846b73e0cfc6a78c5a244090cc7c5eb0396fafce2ceaee161d83836ec17e58b895b7ae5ebe0e6efb690f5e50d76f79b84975c7495e4fb3f9f11ed8b1c942682b0d8cbc3fe54ba4e7310c4b3b22592726ded3570040a25e6e2903f181de38e6e1dc9398163758db32aafb602fa249750bb15423e0bc5c3d5ae3f9a652367b4cf0430d44c45ef60099ede7c30e947a5cc7d3a2ea6505dfd81f54f1108742275bba128dff5ebba46c14567154b5a1ec10ef6be143adc41bc4a700c5018df31614db8ca823d97dbfcd41028a84eec256decea8c2ca8d69df62f89fda1d916f72b24f56fdce3b87e4d1088fa95d6df4474266b14eab54b0abc896778ac649bcee21d3d7e7f369519760518d116728630f208614befb6b8dc571ce681216b4dc70e32c03b5add75bf411838d073e9713e1e3ef3577ca0d1affe1e02175dff90fe7e3eaea345b5bcfeeb5adf4ebf4d78c47a8191e5341924a8048fcb92a007f418cf76c1c8bfab6c74f572c4f243f838693936bf8bfa9d1b2971ad9e2e6a76ebefafd419c2c489928065058e53dba13e5ce2709a57b82602c6559a665b3d566ae00bb264a1caec52b9bfbe6e0a6432d9e125416a60096e8ac82b7a9ebf05883b199aa741e6fd67898b059dac758218f9c889e6935325903985c7af7e6737c941b758842d0d149ebf541d930c2e685db61792476362cb8cf5df832cc3e15c57b7dfc42596fb3c49d9470e575b840f2ebae91739d51b62e042e904155855875949237a8a9f4df254c504fcf5da25084ff5afe9ea334f111e317b9308796025ed2b0bff7c0d57f1a6411872631d9df1a32556f7691519bf80045fb824028cb3e122c2e6cefdc3be7904f86aba4476c75e5628b68d89d0609decf901bef72a7f22056e26279a11e57bc847cd4bc428f13adffe140d6529fe761c52f0701c0738685f59ed9326530d53fbb1059750c44509f32c8382a603abae37f3fd0647ac900c889ab2b126e70000e0b167535ff8825c5db59d56095997b489505393debfe890803f18b5a75d0d69f899476ce3e80d53e2ad7a8ecafc41b881b9baa080c528b434baadf2fc9965210447187713b3e8123ea613c52d88df4e730ff9f4227bee314cd903f1c676c05ed2aaf1be2d06df2a58e9d0eab592d8ff2231321bc9b6ffcb51a3d20e83c4c53db698595e796becb3ac5a1f8b6496552f4e0dd04d87694566eab6b11e056478e4e99bcf41582330ee8ccf7c8662fd4d2f03fa14c484a23159b05d49d452ae4455201862e264dcafd62dd76b1667161ad4e1866aad36e5c3c8af14824dc2725a52ecf6b67b5d5fddca2bc90c0b8274a3014e26e671d5df5e7e41f2dc3fe32df2c50c2098bc927c4fc5238ca9cff39112a172746de5c5bfd80e122e5584e312ec998f465f466b492987e8495938723c97bb75b74fd9c226c9c4a6a2504d49d602ade5ed56c1e897f5a2c34585f199e9be3db32929984635f5b192d1c58e6383b6e3889650830cea09a05e6805b88f3944129649b7c90b138dce4ae2f025d31a25306af3453b88a54fb61fee6c18b50218761e839631ca1a0c9fb020fa86d93ed8ffa09eca6da2a081a1afedbf88c41839eb344be806942737b8ba35b55872e540a8e4485ee6a56d93f77db8751d2a125fe42bfd55ec5b6e375af2479de6d932b3a03853a0ecb7a104fa88a671688e33eb1c26f1b1439c47a81ed676ccec0ce55d94825b0f20b6958e7b1ade3d253268bdba7f6b171e59c10d643f703eb1701acdbedc8066f09361e4afec7e1b479a716938e13bc1cf2f2dd1a6f78e1f0899506fbade6ddd7ece2d9762560e4aed085f24e900fb433c3e2e495b1a9aea2f6920c3588b00606cd5ea15478cf236df5427386c1aed195edd339a1b70ad3f3be0eaabbf5e5c844198a749b1bea78342bb14bd4e949e7c4d0818efab4f0ff345c8d9168a00fedb14d4d3be46fa6d5a5b67413fdd6e0494933a02cdd7b0aca853331da67becb0b50b80492280967da4055fef46ae8186be8e3dba3a3d4772242f59cfcf4f09976d01162a05f84ccd48c3d8942e250a5b88522332234389c861472b51dc1a62e1ffd028a06be7009f1c4b8dfd165a02a4b298e2df8daf4fff75d9e295bccf5614ee26246be79a790393bfd1ba9ccdfbe36a140c6ade25d7bddfcc89bcc57610b4f8d4a81f339f75e38789bdff8953e2e653a4b5c7ccaea3eb4e8fe01cb5b8d51ea1972a5a0b7ded0fe59b6a3fcf448c10176984964db7ca0245d730afad609fd87f8207aa43bfb9d18d61196157c9ad6794cd8ac1437c0774b819bc8dba1c7affbef149f17b8b42e70d5167cd299593c2c709204f8d475f77b1d8b1dc9c621928460f46cff8f34aaa99b1008d815df047602be2888417c1795d13d8f1edcd1922c0dd51f676454a0a1778d4544a8ab39f83b85809b1df4f3d2bc0e2edbd89e5268cee76f0f49f71c9962ba8b8caf21ffa263780200c9050e57278201def79a440d895001906d450cd746224ccab791e7ee5dc3f3df7f92061ad6e0ec785b1bc0f37424b2e3f250cd32d2de80e20347da51903430cc3a8dbe335a004150271d5f932b2dc1737dc0a5b9eb20ee482ff189bef965df10fb5afa75b926a3f543e91b6fdadbb80b2ff5cdbb3ab606c2806e6c456b28da20e145d0d6d4c506840e8ba47b43cc2d2adf261af3ca8ead61b72df6daa6a441a592223afe5949174d3a9957db7fdcb73c384a9534532de3d0bfbf136487b4e87122d736dd07e164f5329d3f87beaa5dbef53d0528ee62c243331542dc91abed5df8e7433c695038986ceac73f118f161e3ab7432ce4db18e55ab574f217e12abc39fd89ebd4e6408f53691fbd84f80d84c7d42b2ec5c627984c0cb3fa436abf979a49c16dc92f1ab814b24b24cde2d6101baf99827492dad07f029581ac0d1666d7eb28115ab50c861bda23a4beadf55652a8a5fa86ad03339451af900d3463e4b0dec5ad8bac7973ba7da2402a8fe0b7641bd8778d82f0166bd1e97399f2b915f28d53c561caa4acbd0eeff8b3193691778e0b386448082aea32fc0177f8b9ce1ccad610f81d74b6388cc2c7611d44805245dfe15ca8ee478c8b8c4a49309ba4ba8f449b65cec60d96c5a41a64ea4b19ec384a8561d2cea53a5f784d6d5eb0a0c99853ecb16e809e1798ad5be1d9290b49ef58aa371121c774ef097af3ac797672d844aea930d1814edc0201a12533e7096bea6be09e56e843f2de1cfa01e26c5fc552591631b9216f5be3a487ab3cfce3850006d1b07aad0e902272d72ea54d7a6f1ecc66b4cb1271a3763f10efa1b753fc8cd65566b4d450345640a7c1fca9668c11c07a6be79e6fadc8b84c5b6e171663ae2cb256cec92db106629166b6264113ffd415b1b1c2630fcc0766cf9aed9d37521dabdf3de4ee8c70703fc8e842cdba4de5f1c896716b11e3372cb5c6ac3f0d47a788f3bbcd93f7149c2395c3851cb1bbd9ee56eebdf9d6de6175ef4e24031f4e56f135ecd96aab27cb1350397f7d18c6b2bbe63c0c4fd7befa1234e9dac290ced7a8e3a9a88406eb3cb7e23e6efc9ed4a5db93562ce97dfd0943718b19d631e19da7e3fc23d374e921fd1c204848acc35d3ab9a72a7067813d2e3743e6d7365229daed260ef162d10cfeb183fe0fc8675fd2f2147c09b0728ba7bf84f7bab707dd6b29f6c1c41df95a2ba4e830379904167b95bea94e4a3c53ca8cbf3fcfe9cdd6411d6c5071cd2b379b06a18c6746340954371f8aa89afd2893fb08905f28e99c9eb505e9f2017ce27c1da92575dfdcc20bb9095c6a22af99f1ff224ea270ecda08c527a22a1f352b6a4e66d56ebc03dd86dadc5908a9f527779a0b9fd8a9206d1bdbb35d43da607eebd803e74b6eec49d7ee7d777287c26ecb72336420765705898dfe532cf623de3925dbd1e7afd761dabffa2c096deb71daa308629de513d25e0975a33d7d11edb5a9a94da4002110a6f9fe8c1a1f84b85657e581b679bde2340dc347ae29f03a7cab2c3854c11e5bfff251c4eaac8ad6c65bca4f8f0722b9edfbcc110de404d48f404e020eff44ce4d9bcb333b72901be3a4e61c412e9f34dc79359385c7d329e52f2044e764817ca7df91c2833245b6ddddf3d347af70819001f49f43c22a7cd9464761107e166c59d63f792d8ff560a93f4bb95c83ff95c021ccb16498d42c61e27e0e6e5a763708be0effe9f9f57ac30d5184db1c792f3dd2bfae0ab0f3ae8d87bf19a5eb206ca51ea4f15cba5ac7c5d365271499efff3556e6793b86559704f39fc53048584f6980812c50a31e29a2a7809ef57276dd57a6393ada21699654d0f6e6418a467f06cb51ea844ad24e1fb41186c66011a8f092ebeaeb3590ed71559c92c750d69e451da79000cf8ce5a80afbae990bf07ab855d313e30f229f54870b5c0f84d4039213164e713f2ee8cb8713df32385233f0640caf2a6cfd740f2c44832e6c58baaec4a7dce0cea78e2f1315f2377891ae8e147ae1e31f6c68dd7306adbcc205eecc007c13a4e29d4e447dcaf99341f51eb188f882a4ef67a8da65525fa55cd3b218846c1348c622e320e865464a9687f00fc959066a5b0763ae56fef6f71372611c38f3c680b52de45e6094e0b4d3118758882867131ae1294ef7d30c864a9f873ac3f7956c4c0694370f409c56dbc09f74dedb22a89b74fd15b03e7207a39b1b09dad46770669b4dc852799fbd009ef4bf8f13d50eef54b5db5d1b4edbd6129261cbd7f26e01425e9b56603765118a8dd060da786b0dd8e6227e866e30a0d3207329427cb9b7bcfd16f703d1acc5e78190a9e5a3a1e6993ed0154cc99fde901f2b033203acec539fe953d01f6bf61b06ba5dcbeb42f7a4a302ff248b04a83df520f20f5494fd30ae09d2b1f3fd98121022cfbda8eaf76da99d8186b02d3cb65d11c6b3fcffae72ffe09d79da9f3da14b6187b93a10d55283768e61b2f6384173aeb46239822ab43e1fd58c4b4980377d26a5a20221b3906fe416d996c35ea8c040c8ef382f195dd520cf8f7984e43ad35d8f42ba17948dc801f8672b70829912f80492b44ecd604b8412ad88f57360a893d9382022b2584cc7a5f7ae7e5ee4207b86db9a3725e21b709dfaa69deb8a85b61298879d44e3e8765663153c8165932ea4fa524e63411690210a6f62fcc7b27ac3ebfa53eb77e7f53a4a4a507b60d875324258c53c8fca1583f26df0dfea8d5f48dce00f11dc80f83b93770f1a764398e5e02b8f722ca79e9c2be2fc48fedb23ff431bb46ee0e2465c490c27de625592e446115e24bb9ac68ffe56d7128013402d33fde6785296000825cbe3592d271fa8d61859641787c5cf0fbca2ff754420f34c9b3d6a1ddcfab8","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
