<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6fa9e0705f48a8d1936087afc3bf37cb8d0f15541a0a5058c55c157c3b4598557aba4cc804f40b786df8ef115c3468e2d3a957e1eab6f061f037a4adbf0bd9dd90298e64f0101b579311053f71e5427554f469ab2b6b963a218c51192323d3dbe18654cf29740526c1cd1dd7015e2543743b32b2ad3bea2de761dcbb45e2aa79efedf0c4e725fc14ca8931824070fb1b270c3a2620c64ebb72b1862dd3bab2721bb13cab75f4b0595294c6142011c80a96351f426d52cedc1d98508fdb530bf481247810d41a3e4a1d438e8bb96a91f09776cf8631c5436079f6758c876bae67e0586a7cf7e820baffe8ea3fb02fe8c09265cb6080ecdd276ad713e22c82017ecac58269576d34c82788a64a87ec1bed12949b9db4b467da69951e110907c9d7ee8e7429db1402441e9450be81ae0dd9994f621360d2784615b4378667f7a54daacc629ceef4627b039169d1924583d37884cea6d9a1d8f7be5faad687f0472bbe2db59b61442b58718723d7ebd154be0a1a93f1c033d4f5ca6a082df974857583ec45c0beb3aa7e9c7bc0d7464c437a92e352876b5e991b79d31414da1f3c4b64b8a0fcdaa3ce7eab6230a41529800c1846ad59be7075568985a1b1d92a1a4ff526aa6641a1ff3484fa94e9e7075059fa32f05eb50d7713a42e62e5c053decb99a301b5f5f2cc3a249bc3f1b5abf09317bb70103b4555570192b14a9ffae712e6531fc387c3aa9a044f4d330566f19898a8fc4e4a4392ca834c884ef7f1bce933711d8b7f365ef2f43876bf762af480e8e7f817426626ddaef0773479a40953239f0639d848e965ad2a6801b8b0c96a24060171bc164213b9f6f603d63826362a58f7fc2a150d306d7ae32808dc25f093a5c4e54beab973b750c5b241d878ce83c82ba304d5215cbb158c42143160f7bc1d14a5755bd8f74eafa178e24d6cfae193f2fc941cd9bf091f541ae6c86d667b2fc1e9f241ce133e3d888d49af67201435275ad3949dfed4863ac10ec6b79e9cd6cc10a6eb2efbd14f37cd4d7efcd3f0b1537888576e6d7539504a2e89d522ebb3def8a4dfee2d469fcd312f29a236e22c1d2aa416a974f71fc187d48a5fb66e8cc609091b66fd4870b1f0f6b0a0b5c68d42d321da465996d0bb77c139da12eb3a4b12eae9050c6098824a6b5d201811a8d000f4b4c9d787b28a7e0dfee891ff5cc8d804b3eebe96858c148b94e0587fcff1bc2f43be50df8266e37dd5e228b3383af396d8dd398af987fb8cac8f0085c28394e55033de0dbf5edae4f1c83dc650b106088196d724f41b7557675f568dd8557ac49524376d9e0b90675118b47b4be493fc8870f72f1c01ac10f3f3dab514fdacfc56a8e73f55b80232d58c5965dcbcf9b404388bbba82e08e0171e54903f791adaea86edfea40483f5277ac9982f4bda0c0b51efe12ccbce82e2cdb8a1224194852295e97a83b359865ee9678015f53a5d6fde342d70f75aeb1f2228c6548f080976abc0f708bd20b65a6680dac2ff8d675e71211d0f9854e7b51b3e8ec229554aa200855e7c8c5f1934ae1e26cd3df173595eb4da27fdb98f9097fc4a8c50cb3500e6466ab2c57751af8c8c857819e0b2b2d0938b3ead26e46b1846195f77220e9dd6ecf9bd0d9c2d0085184ab8e05f21e56ff01cf6a1aee276755daf8384b8d00bfca66aac3d559ae511227b6e8b1e6a732690904d5cf717da474342cd68bb592317ee847c7b05b565bdb52f2d1681ed016bdcc7f0b1b589f999b3be45624fec9bc9a236bbfe5e4b8abc78ea29bfebf5f2d0ec24bf607164d84b0625b2060beb89f3ffd0064cf42a21387e29f972a8e94112e7670b840ec1fae4647f3001c99b11b76461514d202320d9a738f9373cbed6ec3200bbf31ca5d7591f3977dd25a76da230e2190e69896f35f74d769d4c45d8024547b9e988988edcf58d45c749d2da393a21c017fb2c7a8bb1015edae1f66ab35e11bfcd51a8717426180221118b0a17baeeda363e4d5f6c1ff6011c144d6f29390497c7e02863982503a7ff63bb4b57171019b9c96acd327ccd32063ccc812b1fe30bb590276f17404a89d638a58e10da6a6587feb8d810cd4884b0bdd64bf8f67255d9560556e412ad6b410e724964ab40e5ee87a9fcbd1419fe2868cc92ac8f95cccb510e15ba65d6d3ad7e656c4c065a6d35f272876d50d4d7834b827086664bd2023d36ee00f27101552026ce832171c757cee7696ee66afcfd0895ea3f25151f41c322ded0aa774fe7943069242b30f4bedda79b31a00e19a1a2a3cc5ea51c251b5959306130618211d89f33faa3e1b1af223d4a646c4763cc7ca32692940bce61b57f365e2aad61694363c4f2c91e4259a10f9c988dd130307b281e911ce70d8657fe03a72045521dd210ee032a0caa29109ddc509026b2aabc5da2f1e5b15a9bbe1c3b1e6c1fc93cfb225b78221f41ac32d4420c61caaa6ea5a16dd46d45e154cd8904e73134f19940d0594dd95fb12914235e60d90e4e0c66e770cb73f864b667d970db3c9848bde9d8017ea2fa30cb798bcab7729254ccf10d6b437c3c7acc32d9fe9e26f07c11745b4395bd8ab86cda193507da99cf15ab9840b0883e8e958f2195844f953f594a38f2e6645f1c3fa113a2b61a7f0605ac9e2f209c8df95cb41eba011131e11914944462b80cab835ba417daac7f785a687344df580da2654127d0cfca4b9b397591579a92f6ea1704c0b453eaca48f1f5cab008bae517119d9af2c78364d7ab540e13e0ccd54e32468880dd757ccf4cfe6b2d25b2c79f11a4149c101840eba83b864095a1d24c2cb98bed38c25f6d261bbf280d7b0511ca360c30ff1e9343f91054df1a1828d42377deb2c356f46b43d6ff472b82595c94434b0a013b5998642cf45f29af209dafc1e5ca1fe93195557b5a2e8869170a53d019a54e5422888fd4dd3a433a45e9ae7844b002cb846cb3baf8bcbd8ddc770909ee627d5c71a36aa6f454f432fea71babecec7238be8b1a82ef0f5f9c98dd02e08e9b6cc6c27329a2ef0df63f0d42a0b205f65cc107abf33aad0f0655880131259607c1de94e20e4991e034f9e06e9e71693ab7be2e86c1044a28868176ae55dd022429a15dba10bda2309c7fe9d6d4ae84dc21e5d666f464a3fdb8dfb51e87868caded8354a7fa3751d5be4f2566c388ec37df2a438e93a87a4554a43f6de4bc2bc9cdcf19220323747ff394e89207df541b37a749d4158227715edd4355ccd8c8e19b54c68455da9743ac920788b85c54abe976fd71853af69ccdb756f165ae9bbdf0a98508f4d95cae71bd7c486814b396a65c4a12fbd6eeed009b16270c9ad6c0b7bee60dc7b978ae13d19ba143c460ee2c76bf99866f416acdc7fa385c111eea878dd0752ab84b93c33dde3d465c0ddc0a1bbe7ac863896ab9c25475a255e40cac2979d36aa46ca1e8346038e6a91b86b95082e01d568fcd1d553421fad9a63d71730e5d8dc839f5429ddeab52408dca005ee18531524a42e529f705ae93f343e854840e19d80cd64b1a456b13cb87c1fcda787aa390eda78bac0f5f19f6185d27025a71127a546b9b2ed7698a4dfe916615a1194e3ea010507f02cde98929f993d91a4265bea414069fd2bd68c92ec2cd0ecb7253f7615858ba8de901611f6941c306645c0627b1dc61c506c6f072c6ca47f62c7c106e94434675b45d3ca1e18638173375459340089f202e9ad7c815abb9325b8a99a07a46d7dab40991db0f733ccd053fc24bea59fa1bb58456038c9e2786fb4faec120f90cc826825d45bb054c4205be76bb61788a3b05282fb91bb72939bbdac0044459bc262f2cd9f7c9ae7623f27cd017cb8f69d37d2903b9cdeb3e49ab2e9ee41c080270344c8841b0e3d9bbb22e7323fe312bdf0a4e1171c28a4f6be7b2ed77a9b9687380b717451487c4f4fc1aab8704d587b57cde8779332b0b4e374e1e4d0a16c43779030f57cf1322ded4af8fa23f968929ba35b8d6dc3e20bb3b4b9317e329908bea14da941e3cfd83743cfcea861b3df07b370a1d298a897356b39e4cfb5ff054009a54c9d746206fae47486dfc957c21f6dddd5916c5c5478499608a0a11b0920bd8b2dd7162213d5da654805b51b4640c599831ee6ae3045bfaf6b8c863d512bab377e8061e27b02dbed987cd9352c1515a9c88cd2a4a5ce657b8a75027b4b06d39a38c57a6cea9f82d2669c44212704319bee78a91cdb5e19c7389b43c000636a0da8e9fdd29c5a3e626cf2ecd6fb8f4f2ce03d21e34468e20d741a2ad1402fa899422bbe6c600ea5c4f8f5f4a51ac205ac3b7b1fe7603fc020c60e4ad681780a6f0c89b6d85a9e3d38c240a2aebb2bc579d56043e00937fac2f2d4c7d1e480f30353711e68ef9ccf5f17cc79ccabd1a69c41b7038ddfdad609953353e36045ab31b2364677a31468790cff0868bf84bcb66fad251e5e5507de58fb6b9cce110329aa933ddd7f99150c3ada383315ee94b12127df710ab7e6c9000407665c543394e97333e712e3d8551b353529c99c065a701ca52266ec4bcd03500ff24d36f6e3bbf5fd7bbf708f88377e04c7815adb0b74e52726a840f9f05ded8f8ad936a0f8b8b1f98d6f68a7e2947b0e62d9ec2811ed45113983034cf70a808c4f29151906a27407573225247fe099ea4dead2aebe7e000592151372a5be837f3b716bb8e7aeeaa4b2cb5be4943ccedabdf83c78665b5c0669aa6b9282af7f118dbe17e6623fd9b3d9b007136d7af80f853a9357575d2f17dcfdc22fb884558a43bea2ab2883b8d3b6d106976e3ac51f504bc2a3d20a461d8fea769274a532095c2c1bee567d709f673bfa16174c70fe7b3a9ff393e4a756e7a0becb4dfc5d97a54a35d5402b610111fa808906e8ac02d276f3f28f5c2fb678b7d499bc23c5c8d4c450c0f9c78c1b4810d02ae4e06f19096de7b88a2c2b249d55802df9fd14319168e0ad840196ba744281d0db92d6cc2dc5d9286e27e07d99f864740ee0af7418a59e20e777617b303d0e546e7c66ec6b30ad80bd9d45062bd4dd92f0573b2756f1123e719170e53ada35bf43230315cf3a6643efa3138f171ae886510d18d21b8846294a4c1412a0e111c27dbe0b340f24ae5569e9b26c2ac03cdb918014d7805cd1c843bbbb1ff5b3d0391dff89fb30a00f16b6bf3242be25d0d947455443e09b45aab348b4ea5eed0ad70b6cb87565490b9222d7ad5a75a9f53b26413b611b91be665e4bef41622250359e5843c7be163d3d1c836cec0227049187c964ccd8fd5e6e5f0aab76325cf1d47acc0a36697026fbeb557a6c7d0b65d782c7a5e927b5e2bd18a5434ce9822f228c55a2ab783d047fd06fe44090aad302cdabcbbfd1fef2b69b4a3e8e3f40383963bc5e4d75ffa1e14240fea5a6fe7b2128d6bea66abc007bbdb105cadfcb3f1e9be2c092308032627a8dfc1e208d969df01ffb1609094be04406055837210b1f9354f135168a3d0948274dd67b6bf02f961ff229bc28ddf5960d20242cc0357a3fe1ec5a36751fe4118234df2652dc2796cf3fbeddc1776d1186a504b8928c482cd6b7e0d74b12fb43468245be6a3a30f2995557e5088d75f49b5c6ce87e6405ae5b4f04ed891c226120052feb68b7951a6dd2d6d576b3d34505b26641cefd5cd2fcb3db6de732a068c535815f26dd53aafc7b24fd67d0c2656f7b567183682ee1a8e55a981c9a52028de3623830973118d8d5b84dbe1ea24a631392c953fa20ce51e8292a40076eed31754c0e07f0ed46c5550807b4888605b0a077c70bb8e14b083742b340711b7d643265e36492ed6c8127339f40ab6284e1d8141b556524241bc1242affdcacf5081916c3538fb89823de6b06081a0fc997e4da5b159652e7f554e226083b75afb7442def8b5700b0c3f576cf6b910929117e737fccd6c5cf0bf83561104ee7c24e9c78500fe5ba639675e6493096188d52de2cb036632088a3b7a49cce5c674c914acf2c7ef42b1e608dd3c253feae2da2691df6722b788684da8743050f7172c5746435bcf7b89c32f789707bfc3b3feb6e6fe03c9782dfd48f38eac89a2fd1eae9f2bdf79f06db70c1b47e7a2ca8608fa14df70e9c16bc12543ea261e239f4bedb474f1853735ebcab691e04d4886e6350984724f3c53d2b304c6fc9ed7dc60419c2cc6de74b71d6d324ae7aee49a3d6021eb85aa73180b98b8efd499a76d902927ab640a2e14b501b5e04a9e2d456bda790dd354799ed2bdea2571d4b09bfe8b3d84549a61477762305b08360f62e03425f504e0d8828af86e1dfcaea54fc7b6b6064c7ef5722bbd57cefb41b32e06252c0fb4ff16dccd84e6a82e06fe65d6eae6a78cbf5e8ed63372b6b98a7f2471edc6bbd25a17479c093d1e0f7aa5895abed8cebeeca9b9f81184c57b42097019f1ce08c013841e13c530ec976a46ee52262f1b07c81f864d1ce7590344a6e8377d0478aea31e8981c43954d1716a331795c76342e65271bfba13bf5fe99ce2527bce65e48a5943a0eaea590057adb5b6abf370f77e79bdd7d1238a825cbeaa0c1de1a1da4b4c40ec21fcadb71927a92239fcee2e257c93fb1f7c3170dd08cf8472e9861c70646fe5c6a73d27f296f2b499a2064c74515fbf2a013a468d49b13bd1bf3bcb3a35e6ea277c993c14a1ff41d33914b04f032f9a977574ae6b37bbb0b52e5b4d1b22d0c740cb30eafaf445b45abf5a0af03ff21d413e92821bafa59f96d67c276f70f6881070bc6e73db151dc2aa6d2eec4f6a8904f4a7e82f7f2994df756391dd00ed9f2200f4698eeecc83878a66f79e0ab1dd7b761c23712a25c24d3fefe9a76d272f776b38df588f9627b25f6e08c8bdd9ce69c06a9ebd3fd6b7460abf596db329302d7e644a8ccdc4b065e157f31a91fe6d172ed338ed0770dbb32fd8df7003091c1f4c977cd5a2d01ad12bb1c1bcf4bebc7be27fbc22bde472afeb790d7ed792ec183236e3413176933efb72c1a1cb6196316d04d2924b32caa2cf2da3b278523750a22a537b483f1d8aa90b9b78475c2310f5b4cb43ce9e6e19aee3c12af15aa242a8af4b5aefb23cad19f6a6346cf2461126deeb2f9162ee4e7571d1fada9d1bf2dd248563fd2595e5f64c0309c27f53dabf0c0b235bf4cdf4b4cf4650e59b6f79a791494a28b56e143828fc084f318bd8a4affd608805f38ab59961a7d4dcd328ae1165c1084da47f51ab24c58cc2762fe3f0eecce7f59557b16fcdd74ff34ac7cca527f44ef5660eddad3f63c27fbeeca27db7a7a8f1cd4d4371d1099f3164d67ab9155afaf1abdc1392ff380b89d6a9e8eaf77e99631796f77b6b4a732b289cb0475944cdbd9b5613bd98ecf396ca6bb68c341ae889f01b36ccefd21f34175bb6816f045e3603d1344c95d569f030be124bf86d6dfd3c9e3bf6a8b6508bfb2e24981663fecb4958d39f9f5cc2408fb7140905fc70ead1b3008b3ee28d36559f37de8dc7b7b184f5b07fced59e14e7a8e94bf03f50b88155657fcf115f3847e3c75b5470589eee15c4814ef189399afdb7b67a6108c722e4a64cdc976907206176cc1c12ea3f97426791a4c48f31f8ec636fced6b6ee85ea7c4b630c667456f861182c4ddd150c6be522eb0e23522d1d2b70914642cea7c0e4264345f561b029e024ed80c328c31efd0468f92527bc9a75f07411b6ff2c36a8b34e053bd838c708bb2773dd48c55dba9c50f3f96d81ca1a9c85dea98ea082b86e9ef88119d7e978c20fe491809c9d1cf831231492caa0ef38165336915ff2f35dbb0c5ab7dde07036417140f60e8a14f587620547ad16a60ee4fc64049a5dfe47a3eb8ecb55811fd33260ef78298b4af7d062687fc78fbc00cc5c28e694ac7e84b073d04ecd2aa371b59996f0de3d266afb009e6c6f413fbcc5762a9b053b52fe3fde5b18443fa41578c1253ad6137feb01ea5cab4bcf3ee98e72ebf97376b0ca62128bd1b1208eb73a05d8d9e181cabfcf1a6bcddd817adbd82aaad7ac5d4689409f544b845525044b2b7a32985566af30495b256fdb2b0010d5b7473ed422f6f30d03660ae116c2351abf00df4b53af5bdb2422ab97b87c8a714937e64dcd4d9e7035497851153331bad33887add49990e75dec52dae6d488d4be08d2aa0d6be0fe1880b2f6e5c6e5cd6aa36b11181cfabc4d22b9f4986cecbb41f925745cd0f06afea9e7d8dc0f22852fdb2729d364ce83f09e6aafd07ee8ef94777198445679233789d0d09e53291c70218e5870bcf16ed4bc82099eddcd55571e12cd2f064e3c0cf36b58bd928fbb3a5415133cbea1b7c16e38059e75ea37726657cb476c6da031500418cc70c7818c0a0da037539bb3ed2133fc234b96ca41828b986a4efe550231e48b9ad8b2f03b9e5fd813bf2281d741148b859ccbb120314101cd775983dced09bc1f13b1e530bb6d356c5ae85e6d2d963d94cc02613031f88017d6546c9eac0d3c219d832374ea476382eb3fb99609a8af4df89befa34fc15ce4fdad5cd77313e3cc4ac5cfd22a5b454b977bd233b7944db1e9aee23c72737461ed815c4e9c7890b5eafbe42c5a51a23f830fe9eb44ab79071b679246568fa472ea1fbaa0d63a6f77d002710b32344ce5a56aab81445aefd35405df249e824c14cc899523cf4686e86bbbdd297fa3511178785eb6101d69667d3068d72abc0008c597369be37427616e7d1e98b564240aafbf5100bdfeaa8b356abf6c1390aa764e0a5a080ebd995071faa7030a0fd78b32f9a7d6c31cd3759808a8dd181619b19b7b4b9c59f36fbbe0a0e72f54b3b6e3d244f889dc5f27de1a4deb03d9f6c58f428f221cac1e494ed79e160f5ecf489cff4fb79482cc1008f3bd12f62475914f16faaa978438bc6d9d756b04fcad84ce017d038c9a3fc308b17da8fcbc7970dbac85f71192c9eaf349c179dba221f6a3d5fcb9c0dd8ff80871437cb6162cbabbabf069a0bd15156e8313f045548294fd972c10da192c91cdba0ceb5b064d5ff96299bdccbc0dfe8d5c2a25c5cc802f8c07fb663ad5646cf60d7e9ecd1dd531637de8b27a06b6b1c071421240c4f6bef386bb09e3c1849b4ab15f1730418d33a55c4db23cfd815dc8b5477076bc1afcc795ef8c0d48c30590b055da351e3cb0b847d882fc850732d1e5bf9b703c380a57cb77304fbdc872f1d44664e12deabfa953d7c7b704feba1aeb7d73e18fbf71e81bdb04c0d7af84ea6e68c1eb6bd691ce12370e60a6662a5b791b5c69a9b9209efa198ed1de9ab0138cf4625b14fb7c812d21330640822471c5e757a79c3797bd3fb77afa14f53ced56020d985127b83c26e304f266a553ebaada7dcdb9da3ea99eb5751a7486521b083bdaa47bb47eefab902ca2bd2030b6fa291e86ed3a19bbfdc1397a8c38ba27e62b0e57920da8b37e22e96e973a5c0459d6cd0c18dc83cc9a34cf41523d46ae759417187cd137aebe08d722aa63775584c7b9544f80df985f953e6cc5191fa6de9ac59a08e50a24f83b317f1737e03c73a1b41723d57c58866cb0d7f340bd464055fbfddda5d7b6cacd79e900cce0658e748c13d13d41d2b20cbcfcbf94c4dbb78ac01c46b895ca3e76e6fec83e28e00d24fc71c5408995d616fcfb05ff744a9d99fc7df3f413c3cc5752509aabe9f7720596d8620aae4c4ac606925e96dff76582d65d3dfe512158020521e73fb655a21ad1cd04d723b6ff8793046928b3cbe059edc96b4ffeebe5364b56f203d73f3267c4aa15f58082cc319a7d25229245f40aa7e9ea080ba7d60289a31e2a595e7a5ca9f1403d42651e95624f9d0dbfa314e94c7b21f1ed64d5c36cb9b8ebb900dbd3219ee5ef010aa38d0ce7bcf72d71cf898aa77a97bf1bc964c8663bbe55e6481fbdd588773582944d7f38d31d2feb9b1a7e1d07fcb680fc690170da4bd61513492089e887c2721d0cfe691dd158775465dd1e91a3051e1e3fa2212664b80cea23a8073825b1cd398e4795340dff7d186391b9220a83866a929579c42cf78f19de0da4fd7efd3f28d4ce751d758476ea85a2c8d094c76c795fee509e4bd8bc9aa7175be3da9b48ee2a57085beb557652d651e74b7ae380fcd51721bcf8231c583b1fb20cea7a548a4b4f960fe472c0460f5a9dae263aaaa94f0ebc4d9343f34d93031f61abf30b09d0f542c2c9007ea150758b733c3b8841466f205045b49ae85686eb4f1873362bd81619853b28d8f1acc4cb3ca3d06b7a43c534e5654140bb83d977b0b7ca95bc62ec5721f19669e566ae55754d5a52e05b00c888c4be11b2708b73a0717f475898fe4bc1930bca8a2d26e67964fab92dcdc1b9919e5246cf03ff897f60bce89bb7c0de8749f3cc599bfc9342aa48e8b213231a722e479a684147a9c0f1c670274bb2d601a67bddcc103bdba9b8106309e0cad02e0fbd88672f79b19be23917fd0f88676d2d3b1f00528fd5f728ce159a7df240650301ca38d912ee6dc0e4a7fa738545fea07ee65fdfc13e94c1fa10d3725d7051250391bc20aa749169894d9f065987ed2d0681ebc1bbb3aed4b0b32e87b9f029f6129432e3e4b3d8dcb925094801d6b2c4a7eb0f780387d3366efc4e4c577f830443f75f296bd515de466b5f77e32bfcf95d081f84e5162834c926f854c9fc1936fb1d4029614061e3da4ecd5df3388e04ed4f4c6b3391d93784252b80a258ead27f63ef3c26714fa226ad084004224e435502190571151e49fcb9614f7322f365c07e6518285f2930cbeefbc62c79581dec325bde1d638452f92f64aab4f623da4fd0d22570d5e3a819eaec6c825251fc68fdf4f3bda179677b3eae3ca4067dac5a85f8ca0bb5d4614a8b0e611510da7b92f5e48e52a473b6c1b42817bd7e12b0db9d3a38402f3eba57bc6d38be48e0f8e3d0dd12f30d8168d9345f6ee3bff6c8b1bfd18dff26d04e0ffe61469a3c463a37c77ce7947e1abbea8f4fd02f08acbf1e9bf913c8b66659957b23aa9eb7762e731729b9f734a39e6fed3785d723f67b476389c794d83b7af4600ed7e7b9f96bf782c400b0ffa611ed3a67538b61e229951a5a1dcd224ac8b028667f9eab83eec121eaede6da532f33f0736fc02f11e12aed0294024c5c6cf348d3775dcdfe88fdfa60acb032c8f5b1502fc222076aa9fad65a2a5ad1bd3a16259301bd3aecdd28c763b471f2fbd01da39c5b3c60c1e9e24e76beb99e6d49c3c7e3224b1608ca97c4a90ddc086748751f2f5e90c847b9c0edcc6d88ecc268c1f1a888eabc6679ae3409b661ff8d9de52dcb769385bc82ad1df7f58d16422d6b1ef00ef6ac43437b4e485285874a7e842fe2b736548866a458f842f7a7d3875608d968cbed7fd4be5f3f79bd6f88e26e901c9653ad1ec2f83f0b54013e6f28399a5b8effb65674b19d84d64ab175bc6681382082eb27ca51cde6738bc63a4b0b921b36166b6339220648af1aa6da3910d549976bb64bd8384923c73e0fa5b0fa051a73fd2011099aed29f28fcde8884f6edbf90057b412b0947d838c89cfd1544ea7799b158a43660ef71287074a41a6b530e13f0ef0dd79fad290d04b817e46ddf2425a5cca04c8635295bdd8d789c4ee86087ae6da1241bb5b022a780a1edc54f72bff8407809447fa03508eeabf654a3a69fa9fb0ca16d0cdee18d4e335fe2686a1ec940d3204395a0da357683a19a18bc823172dd42e9a4d40c3053f6c7711a19eb490526d484442e60b3f6ff51fde4e2ca7e8bca36efbf209ca3f0c33221993392d628d054350ec9f1b07e0ddcaa2e38357abf43c275f086060fec3518b213992b6b9ffd884b84921e60f3a517b4241b4d1abccb2c075b3abf0f4093c884d89682a6141af8230a7b2db7905ea9f0e523b62885000cdf656f92d2ade0046a5fa59842ac5b59475454bc116252e7f425ae0d4bdc6039ef710384e41d0d759df897cfef373c4385c5cd698e2d59ffc5578e0eed102f13c7237956280b178ac8d14f0b090a15b28162ff3edde0271f2b46841e4be2f402ccc6bcdb09395e75d9c3a282983869de2c4974c0a40bb0a424df170a078ae938f8063c2dc725665283b43102cfce47108a4c3364a9a9e4fd4ec28944f774a11a7daedc0be5af994a4f73b9bd1a218c4e770d4bcb0e380548c66773d2a5fe5df0a472749139e8142a45065719c0e19d416e743c85d59696e5e0688f584db713dc9063379b80a332abad1450ff24a443efdaf1aee4b305cbacfcb4fa9874d8630854067d3a29ab157265846a8f2f549308c30a3cff3d2ea7ad3e2001ad0f266484fc9e27143ac17629073e8b02eeedbb734e25f3c9d1995c215f7ff19222be652458107687f92e5b92b52c605e32ddcd75fb2eb8c5dd5e30d63c057d3e654b675100e3cbb98ff56a5ac9aea5ca3b80391367fcfb4cd12f4a5131f5fa65ba6e65164f0a5c153328c46c3be56f71d51b65e649511948362cbcd338733d33304d10b46e48daf012b139ea979ca566e08c48279e006a67693f14b90c2a21ffa4bdd2777b2ae80396813b92c40b4df9efc20789caa1d8c14cc1ec5bd8c9683fff364dbdfbb101c4676c46dda7607240a9fe731e2964a40eae9d21ec622c3d8ac85f3af1348c7aa110896aa7f0aa5934186e61091a874ccc11a0cd47cbf8c085cfb579e3ecb45631febe5bc26d40f5a2e26f61892b9d59cad19431a63e56600f57c59102e0cdfcf8015c7e92cb1d3c69868d571d755fa01dd9e966a11531097f728444a3b02071ee88de67c1aeb56eea0709fb42e0817447cc772542fcee6721a056b2bb21de3210b8a70cf9b8060b9674b323ae45544c8d7903e5a6724b6e9111b0e64e8a8e071ea7fdffce25d79e3f34299e4a55fdeb2c90bf596c835cd2d98f54444d5e876052c0fc1b11464bb6d6982724ed46a18ba96c487d204182019497a03424ebb236d5e3d28e1ddab51a0ec334c5f159759510811129f8fb5825d52eee4e2327257a096c2c179ae958ef8827414730a7996c56130395ee97d3d4fbcf26428bec60ee0ebcf2be4c112c7c0cc62dfe37ae7948d4e6cd734187197dfc64aa0c63702df28f057b4ccc8f7e5ed95ce9e79873ac221d53bdb15ad4ea5b42dfa786c53daf98569406c77ccaf7a38fbc871d5e823dc100501360ceb00c8fcfafa1017585c259754742de0c1533ed6941ec0bb193dec8b215fe9b00a1d4fa25c5ac44e642ab4b591e7f18b6f7f7b3983a48b6029c4d6fff401a9339bc8cfd46c06dc4ad4c6f1549d7669a323369c931c29b60f14ab14a951aabdee005cdcabe9ede98aed23fd1e433a171d8c82b5679dd64eff035cd47ce53c1e367436ea137e4ff7b9e582796c71c96d2e9e719d9541769638a22dbf862a86d1dc15ab9aeaf2a9f4cc53a1ce2a949d5d5e0e727168c7eb1e104060d2097c3cb14b55a1c4f550193146680f63ac68a2fc0bead9ed7484220d745d6ecb57bca0b35b2d16d04bab93820bd549ab00f36a544ddc2f2c68113e4d93a4881688cbb608cd0112f799ff0b003a122cb0f0aaaf893cac0a37e78c61ec80e2e362ec10f5686121dd7a9279f4dcf8a651006785887033c49642da65d6c25d953a2c447a9898873f8bb4b46d4fe8f8fcb1d429fd11c8aaee37ca20a2edfcbc3859faf1761dbdc5f6c7c89dbb6145e4d6c45a98021ef48cc8e320063441b55d1775b18963aa9a826fc403cc2bb1cf27fb7c196501adc3861e58d4fb40dfa19523abe800771907d2a5f7d2ebfd913014cfd3f640d19b5b2228d26cedeb258c2ead3bcd8e437a5faf94423e68d6396bd4f5ac3225ef99168fa6202795a4b1280ee2ed5152cdfe75fec0ca4bd0a7c8302308d6b0c6e6f9827684cfbb0d1886a1e2807875d0d28895abba5f6237d0964b2361937835d9b0b296d61b9ce031548b02829022464071cb2e32d2e715d141fcd8504a7994863a53c8276d29aca18daf2b5f36f808cd332abd6413dace5ece227e684f9a05368a8fe1490deda99aa0f75edfb9c15399067148920503bcb58e2b6a727ec70179d618fd492882ae0ba1c2231dbc9c68b91b414900dbd681f1d311b2d24905474893ce6c2c6aacc6c6eb882148b852e89def229bf317b6a1d015825d20f7fbdbebf60bc57ab0420eefcda982a6b5526247ce33ed8dd8d4f525e46918e04edaef5d6fb13275ebe3b9772b018d11443da6f96b93fce53b4d0084dda82be330582bc0a352bad63d6b111aec6b2476cfc9606f8fa2d78e8aa5fcd5226361e44923d26e1f5256b4289b54cb9efcd5ea04621b9d6a654fd4aef1945ef4231a8f77a50525ef5b1f59b3659fa23048eee744e99ce4992a0664446f7d2d9143db45d3fc997ace4692faad27e9fe92649cf477e9206f8f160cc2d8d1c6495a9e34af8a6340e2b67acb2f2b8bb364f2b130e513a31bcea4396b054ec7d47e072421aae69cb0e986c8d3a39d2214b3a575be00c2338d9642d6a43b63b088a61226836bc5748e38d03b257f266d022b22edb9f382de86796b6ac0a76563b6d633c3d1123b096f7102a2304a3b733f0bbaadfcac625753281e9af27fd6a8e7c180f492abf249afc746d5490fc6ec8903b4cacaa310878dcc11c1b1895fc6866d34123545d616690a1ff5f0aca6d5ab18fe8dbbcc2959c4b59b307d6de2f85a732b4780b134900299c887c593d66a072360250e994c846ec8f245beaa74555547de0f7fc170202e57708e5c97e28897d636a01825ed89f16e7e9f919d968dd712e919728d683b360c6e59092ef1606573f1a032ed9188fd051d91068c48d0b5771ec867260881a54f85bc495ced52e7e44a608e197d69a61e5519ceb139d649733641a8b7a90533c47487a2fd42eddfa2b5b22f94d38ae68b567085785d7fddd853f08d1495fad0078eb19ae422115495c55e7c0419b25151a65c62fa37a4c0a33fc5ffa2da59680d980b3c81472df6d055e81d536f878294a420d2fdbc8a9e23de2e7c103e0c2247a29228b2766642376f4172922b0cb8018de82eb9fffed553d3beccb1a0daf67e7e188e1b327a6ecbf0d1df8dba8bf6448a44edd514985ce99536371414fd6e22043ef5392a6e40d83736e561ae3eb613bca28d16d2ffe77786655ccb272a296578d7def5aa20dc970e2de454d5de09653b3424631d45809b015086ce461f3351dd640849de0c37a175da4fa245fb98f5b86ac3b107e21748fd56a0783de6f4fe4706db4cbb6bbbb8d1c05989fbbfa7544b7ab33d66980be556f20960d7aaf2140b87d0b2a7c6886a3b64c50f552678cbb36f8cd62f0a21eade7214133cf8b408996e5c3ed027a9bf63aaa405e4b1f73f758d7766a89cc155000333d8aa3cf52c2e4ab77413680b1a3df08bce3211861ec19f95017f633089d2a84d0bc180144f83ab116bb5b548e297cd8ab5b6be0357f36b0102e336d1947a15fb08bbd155c54a720c19617ca34f6d0eb3553a788b16c3b81bb9795c28364e405a8b93ae607f00f4ce39e9865433a06db97084adc33ecc501d5cf11695256eec8a18c38cb3d673fe13d5ecb808609fb07e5f1c1f1bafdcf63256bf081cc9f2be70ce6f942777c12532c6159f0a1d5e52090270146c8af020288ecc0533ab3bb96f2f48bc1d0ec7e409f7f4b62457b46b842cf6a23e4632d1f7422097a189b3ed98868bc7becd06d24133776db607d8d780f6d2ea1f061d0d767930b42769c577ded1a2da6f87d8f1d5b6845f0d03a4f068895359920b569275dbafe90537bc0d0f257a344677af0ab12cee6fba4c5c48da1ee280030f8d2e39e888bbaca6d062de9358b44d66c751864552ab0dd3b48aac6ac77bd93355062d26a344d4248e1da74045834c7ddc864b433c9d40223210bc0fb4e8a38a94a24004239f87e8db8232858076a38f2a3132d6bd4d7420890a219eb20063f2cbc39698776d2ee74b13cf2a2a036e4a291632a83b0240dcdae41289724b2509ea472c7151e1c18bd718b4e515f100d591d6ab437bdb978a92822108f1ea1907e458382c005cd767a75e3daa24d78f4ed5e14c967024d57318802a1a883c2da66d86d1b635700261dfe0ac12870395d7256e9f4396ab4125ce5e0a13672e25efc5067e9459e145e1cc099b990462eacaf204f9432a5c7c53280baae7fd8d6fe9a3069c3377220eca3e44d713493a946be519692262382e3ed4c53383148d034f64fceb6262dc177af71908caafaf6ab5539e2a7c857d8e1d903456c0210ed6222c9831d212eed25a6f6380d30d13a356ffd172ab29762653d970bf955d4548b6f26cf0b9e6a43e0c7a8a32552b87d7d4bbac7876878270c8d0d7fba4406164e6cfa184658d773d5e78b8acec47f85128b2eeee055f20640f1a4b728b5291933de2409497d76c6e09a6efa4668252546196d3c1ed50b69e373fbc8171bdfb842d482d747822583771ffbb3b6a9c400ee69c2b0588076c71981fa5d6047534ef39f5261e5664af6b7235f1735bd5cc7afdb52ccf52148c08f05378afd2f89ca411a13fe873472b330d7c79180c31cea77a7e501634f5230a24c199fceeaeeeb6931b78c0760987301a1a272dba306110dcbf67f9be37fb435c6d29ebbec9957b89379a53b18f584ceb243972dee800eb74d5c1bf419a118f479e35f40a36635b11591d188b7a0d93a38b1ae1829c1ac5cd58737147632abc523205c06f588d72bf42a7053e5d3bad2e21b98df4d24c09f58005e50a0236ba621e49f5ba2ae2da70e6bbeb2d5eec269bf33d292895ad3538951801221090d319f5fc9c6f9e60e258de8c2a199d11cb845d0ec1768091c9dc2d5421608203fedee2aae127ff838a43c3ca1f22b368e0d66ad06f1048d9cdfa41664b926058c773f300111d769c7e9a9eee5d6a4aed8acfb97825fcb04dd80f034f09d6674c261e8906fdb0878688c4c8049f690a47792c10551d0858206d607560ca1cfe53304dc178f0717666b5c6f3734dac632d88163d86a2cbee6e71fbcb1dc2d66f99cf56f4bcddf33957a11ff28d0eef7ae42d3cfd369c828e61dd1312840bb322e2433d6ee0b63d8f1f79e1c363cb8d152ca190e29482a6b0ec47a3a35e531b610b2aa68bd5c833c8067a6214f6f22f3415ff722f30ce50c8bc98559260c79da888f83a70dfca778d0014c62521fc9f508061dd16434d7f7728e685a0fa7b59c617234acda01b2f276706b663c041d12b0f3104d22ef6983cfb8d43ee09d2bdf8004a8d748b2631241fae0202a1479f6f3cd2dc659fa206ca140e19f938038375af6a0752561e0eaf5651b71a8908e1b6340cf590de301b20f0c544168800106a3264dbe3d0241455d4e2c7c1d7d4fb164a88db72b6d644a43c5cef166c61854918d5a99fdde2443973a9f8363f46991b53ebc165d207a163392881b65b80d12ef7bb8815e0b88afb83df6d6a74d6e3f67386833333494afa3173d139ff51a4649c29e53cdfd6333c6fd43536ae5281dc8010f3811a4e20c9ea468bce53f20e07e6be20a9a53dfe8775aa865e15519c1ce3cf0c05c3cafd87ced538e86eaf5de2c54a1ac6dbd93ed2aa0657260027be3ee6ed038ba3f2869a3fb98f3824d83d401862addb4f0bd287bce50b8a2a39880216ab8ab7777d8988dd8db8928be5270b75555ffe2a099d23e79023fd9b2d0af64af578fd0f93fc43e2eaa36c0da1c66d50f8ee09ad0f099b7dbfb4a4267beb10ebf18920ac2e67dd29e7aaf626b48e7ed6bbcad2cec96e5cc1df1edf4171f968e4c6298e59027fba90ea1271b900b040901388d8757262fd54eca916112dc67f66e221dfdc39cfcde35f0862ff8ff0df7434afb88b5d563d1b3242da25b251c2e18e4617448d7c2eec67f1fdf3c35f17440ed85cdf1cd7ac63f04079446ec945bc29819bfaa281e65db393f96999c7eeaaaf4119385cf1526acefc84e2870c3394ede43c07ac68db4021aae9dac1d3e8539e3e356f9573e807e9195d5b0ccce7c584e0728b4b94842f29adef803febaf1618342b90b4bf29ed1b0c824842ff57c214fcae3b666e910b73cd2db1658f0803faec9017e8e56a92a427f330cd2170be1c","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
