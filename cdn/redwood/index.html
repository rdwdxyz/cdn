<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"06b3444b9f8bbfb0054fd23f269fdebe4636a9dd58f53a34f88cab70b8214c08a99b420f87ab3ec59afcd496d9afbbf9675a2e893636e108e5346a901bb91d2fe9e1d2f0a990c4738d95516f22e94b7502f58d46866f59169bec25126ebd4d1d953c3bb2c2d4d7ebcf9a48ef37d20ec55c2455fc229f7e6182612cfd26aceb0d582153329e8ca6fe60c1d1895c198b29457827d269a991fc0a77ae916d78725921a39f6823f8114af7609991fa631088fe47b43f7c86f10d70e9d463623fb3ce91a89730e97877656305e0330ddb441eebc7bdcfdbbf26d825c83170b3cb45ca75e37fdaaf904e7b3ee0b0f6f706c03fda360fcc7d3379b5c07da1713737241be1228f1e710b75bf3fa527336ec28cf0f92f69cdd317701597a4117386577fdbe248cae47b1966a6ba4da3d9ae4a5d715ea7fa8c5d1e24a13f336c4f8d528c90bc854a1d37d1ad28f901003c5ec1976080a60bd0c9596629bde03a0f8d15ebb6b0563335fb669d603fc91deb56200a7f290f9e6e6a2165cf0c238b977c2dfbffee9743d58cfdcb43f2850d23d745f477293199148359812b8af5208071d817258e2b9a2e259c21010dc830073ce473699b2f271f8fcc47e7554a814be6884c0aa5555fb84b6cc1d9144e29979ee1b18034c2280310cdb94cb689c1e628fa054455f74c25f44c982153348d54b3cba80b0f3388cefaa2784609c9d74248b1b886cbf574cd99a9777b436430112e8fd71e3f758bc63dfa7aa287ac5059cdb53603d689d402f46e2ff2e7268b22cf1f792809b304488699c7eedefc4af4f8a92b6f0523bd6e69e2502b15a2fa9fd229ca8f798fdb9eb796fd3a3fcb840a8db148ac2e71344d23861adad2b706c39df2408f536b98d2fe6b14995d9cba8bc61551310a2afbf822cd515e29315fa58ea2fa81763dff889b9f8104c56e8fe91962e34e9973a869d69df75fd3d8c3bcf11e8f39f826698a32a99ccac1721370cedce17bdea4bbea13ade0a24c6da6720405351c287f1ecc7337cfed904dc0adf1dd5c61ca3c5130c3124826306c92d68fbf02fd81c92de7fc14e498df06e6c66e4cd3af1859ee2a53ffcffc1fdb12b7779689a2a5e55478437717654fe46af09a7ef648a8992191d4e72c051cbae90807355909e27b792da8475bdbd8fbd20009c0db0fec8b33ce16f1861e4202be1f1510fc1ca57ac6916fee1cb60df451466cc91a9f3409da30091126560f80880af7b179d283b83d9c454237efc8c227d7e6f19a41a1699216ca6450b1f539778825e96861e13a638669aea1866c8eb5a3cc111bf2e087f89126e3aa1815e7c0fd35a080465aaebd23cb304966c60afae14f9ded14f9f15029aef0ac249f48b5fc03c52b214e09d730f953956486b50057445db994bd546e43142181dd713ceac83294ae845352bc29be6c31a495364251f7cc881325dec62bc45a15467da6927c28d44cc8518bdfba0347287e4ebd9a530c716727a186457c22f16e072d5d965a013ff3777bf9f0ef55c3215df3c5987a5bc54d14ae4beb88b050ba591a5674835a67de93aac947ffa376e7cb656e740f3dcee5058d41c4aedf1ac7d7e80f88ab1f673928a3dd8d685c5609781d53793dd9e9fa0777b7f8b2d993d530d7048da38f153691f9954989b21c6b81fe3f7cb55d0d05b54adb1ed1c67dd467926ea2085cadc6b6f1b37b165166fa63c31a38a7dad1dcbd24a12d3aec77ccb0c98c3cbc54dc2c7703095a845963aaf79df21bcd928e05f980b7993a8bdd594a85463fef653f048361969598e9113d1dbbc407d0af62a087ddb2aa517771a1066c99c5b032a2a55d90287c92095bc9c2678b46657c9ce9da8c5127dfc2aabc25f0729cf18517d4793ad56fa89988381f23f82c16c54494e9b1d7698770a2933dfd14d2f63e3ae96de66b31d408ae6b273112645dd8ca00ba09d971b15d8b504d70c7f1ebaf656be52b07329e34d68f64ce3229be148fad3cd2a4a4ffac242427944001d1da0f5eb459dc704a4115108038b27423ee77c5b58d9e094c312ac902ea59fc22d1b00cc5ddf853a673a3f07502f8b131ae083c08e5c24e8144cc902fdad9ec650235bc47d1bf0e01ffd9e681b45d2df2df7a2a331b88c9d97704dceb0020a063a0e89860a624d9d495a6edbdadd5ee0c8b4847329e24c5e7afcf493600ba2718732f689baf0dbc5592722628829dd32c2298979e750f95b7044c7eff3a6e1e1845c2ebe16422d70c224bd6e63bb91edc24b70f4e86ca180674fd9320a46c03b0fa19c8429f8cd26775ac5f28113bba6d60e466248a613c65fd70c8f613c7ea1198dfa8d1e52589c6c06cf7e137e062c8622c04d58e95d5a6b9b9fc3611c62bd0659088ac2ccbb70774321fde9f827960b17162f2d27750dff6236bd64bdf01479fc45846a21b7447905c41d7a57cfe1fa38e2d24c680a9be3a6d829a27adae241033f19ec2ba50a19d0685483a262c9b2e243229ed02a5ef46a4d90a8d0536385475b080f03a9732f4a947b4f7a010daf674fd7d1cba1b91a39da844832157a6b14ba51951826a9087688d1c7c07f72d6f0f84a8c3566c8c55632b070170db41ef60b549878227d810b913b7bf0b76af2e1945060a8ea2c91302dc3ef3e89f99a672093566a42743a25208fb0872f355931377bb56935d6839cf08a8b5c5bb45f6641779124ffcb8045ad5051371275ad54d76ecfb8b94d799ad8cef2219068f04c73aed0423ffec335faa91375b35426d9724540d7820ff794db907be948101b73d56b12764126bd7eb39000d92e42470f0cd4d3bfe7badcc24550af484ad264f92ca93e22baecd21530746a7020535091142e285c0e2c1e16e9b81d804860e49f8947dd077633e8c8219494f56d25f55bac4ac35a0f261a0f187398c3cf09a2cb290c6b3a33c6eee24b6e70c27babfa5ee538dd107468351b83643304ab416a8bca966fe99c01d9a505400f09e82c1d4b812d5630fe80e86c801647ad841b77564537ea5003bfa44d5d02de70805bbdb6f4c77f20e8a968eca9e78b4b55ffeeead76aef70e42d027ec3d75418ffd1a69020deac9c43b3e7df53ecbaeda69b2947de1d92d42ef1bd4c8354b1a486d2c63d14b2e7cee737127daea92a4ce1184bf9122165caf0721039796cd6cd40b47db7348811383cf693ef62f4d15522ad468307a09a749b151b882819788be2c8ca05f4fa52e27e260628a164b0044f18ad4c95cfe82acac331db65d2e9d04013a95d40c941e3b47398b2c27739e99feb614e76f480131f173aca6d923bee54fe5e845fd7a2a190437294f6e8903abd84d0e96a0fa589297d1b36c8a44865c047f3603eed76cadf0eb797896b0808369a1d067d2c65aee63574effac19ef19fcab61fc31e5d366327e4996ea11f64dd3f490e18dde79d696ae7fffd031625ccc9d89469fa2845268012019b8568dcd89ecc132c62c88e347af06e001c08d029f3b5040437e72284137e5630ccf3a40b0c77d234341872dbcf8adc22a1a47f6517e7bfe78970126b41c8e8a84f6bf0c379af6e7739c9a2a5bb7ac72f8ce0d59aeccdba468eb6745f4726353d6001b3e257e73eb7813c9f9c8c7a49db348c50fa24797a0cdff4b08d89722127e478b8ef4ec33f97a7754b472436a9b41421735aa072630a2ad5814e39f1e6ee956e4849db0ce1ff49009701e2e8248c51c4aa99b429af045988155873ab1df2438107a27356573b3f876469a75bbfbe4299473bfe185bb02f81c2328705fbab9117d33400d22bbf6c448f25ee827a07d0dbf07e901771d10e7bff9b1bf896b138992210f991a639a3f790cd53125ab7d534f3a68dc0bd0cc188230a049c7ff57c52a4f5bca618d068c381e03fce7b42b4723b43d920b53c7baae5e28c23cae7d3a28f89ed91e46b895d44a4ba9806dd8da5429a216fb67f395bfef0bd6bf5b9d2503caba43414297a2e37295e263cac0e4830d680b5643e429900f0486bb5214f2f313a15de1eb00422b7dc2c85ddeaf657bd3106192d6b7887d143b33e08f53c40993c817dd5661364bee7bcbfc2c3556dee3da1c982ffc6900004f89435e38f7cdfa328f72f4f9c3b35bdfe77a3237a7a211e7c9264811a6e8eec500e09ad374090cec14305cf892ef97f630b775a029c861485a906ad6f2211b5d98b20217b4e7fedd64d5c288d4b3c4f123f4974cfc8d8932db6b4005730b6d50fe3bd26a46fe19a28614e5857a2942bc0b49470fb4408865283da43607b1b1c0825bd38197f585b95985159b9d4d454339f549d086f3d8d33a946f39a0dadcc17c043502aa8cf38e1af07a77964a39cd4e5d250445028be9d7282c097c67e5e651206a41fc6344e420192f71b25ad6e3f0345730696b3879d60ea882e5036ac72dbe531cfba7290579b080472ef90a803f929a2dceaef3dd624ecd0c3e2819c9c76e78d1f916c04a5d7031b8e5f1df3510cd2ca4de6657f78a590aa2f96c02aa8f0f0362ed04c86ecb57f3ea94cd49c8cff35e7090695386a7209c6407a6ab143d5a85dce6083982bd35a2310d725ded107569b552685730d54d299be5a38d9abbf5bd6fcda8df5c01eb76e73e3bb3c12ee4be1c96120baa7061ae8ad61b6c2e05e4c686561c7cccb1c354d4b2a5abcff461bb1196030b5fc2ebe360aad2c22e54620e395043a407f5ad46621932c5751780e0adbf4a625c73c625622dbbb297ef7cc9af94c871d1d5af8336fa8117ddde9378a52df88df2d37f500d2f20f646c2de9cb4c3c9bf9b482ac1c3b2e456f52dc98531e9226d57cd7fc1672a0122b615526fe8df465c272b89d0b456d3e7d146732ebdb4f81f804c531096f3f4f486a9335d55b0606498e0e98870302207be0256ab9307be6054c2c849731efecf6dc77bd00c82ff47e0e8d8406fc3cba30039e98fb686e93f4106289d86497ec3bf962d9a65e98a64882aa9f4c85fb69f9f25a5276b437d0c5c6239705750b47834e6d279a0bd0a678cd48e2dfd699fa6472510c3fc547f61878aa93ddd44d58efd7290244bb943c419f192e5de7217ff7a5b545cc722d0067c116cd057850c3ae2e2ec941b95c5d6e6a2e37368ed1808c7856b7fcbe0786af1d44923fa7ebd857474dd3f888e0d48c8f600e54b8dc694509a693d495b51eb2c51bdac798fe7182a275d2f1cd755dc53fd6b2b516183fc565f7342e3f119ca3eb753df6341939bd5083af8e439e8d956f898a7cb0a3d34c98ff20d4076c3a4f03540e9ea6025d3375b5eeeff2161f17cee7a9fa9563b2c8972f37229b845da82320c166e6b58d208302e2e9b95254c956f7cbb9c937c101c058a783cce6c6d152ec2f2a23a5d96e71311daefc5491a4b3174e1c0178352c92938be1be82210a3d40887915b6dc25f761179cb2ce005b8059992adb443ac4e34be6270c6c1f56f33d0a75ba7d3704fee158b4d385c105f913e0cad7b4c419c1e92020515b306ddfbdd5f9d582403782e3a586dc1876d277994f4a060044346f105814802f44958423a7d90ee6ccdbede15e358600df4e3ce2b6c0f7b050a3f675186b4947cd3a679d9977a20db5d690000458525c3b32ede4c8c5313b5f1a0d8b3c131a8d4fb7fadb5c7e03a138dbd60540d95f8ac95422da975a2eed3df5d8ae9784440582bff92ecf1df1698fb5b0654f71621b355869aa90adae1613121d7e5e67200032d76da72c32868904c65bc9017bf5084e05901cb8c93bad544944b89b6153d220d2e52bf1dd64d57f61790f6ef719e0e5e03643c226cb7d90144a01fe2fac7d6035a2f553f55c9c2b71d1938b2e07b02204b98aa52a727231c55aad7ac6a8ccecd2167c4bbaeb037a04581ba870a7546bb3168c67bac20fe0f91c5bcba9fc350b2adcf85fae70a96bb666fa942d4a46eb0cb9926f0ad411eee97d03767e8430b518ff1eab9a56a29f5a4d25f6be40de4aa57d60760cb9be8c80336d9bb84626eb46529d6b5a0a644df1d168825b6e39045af6dcb2d112d3d86e9772147df551eb4536283043166d1dd8b1f11a91bdb68eaa3cd89dea164daa7fba3536ec431857326c0bbcdb6e8ffae11c4e577123fc828462e9bd92719e3eb1a00d150848140af66f7fae9cb46c02e55759ff88db777646ba15abb207d5b68cf23c71100a094fa6b17bd5f4652c28b3a167b6b58033dd294b2d5bddbfbc2dd5c5944ad41fd21617921793414f1a420a9fd8cf0cd392939ce2f309ce5ad6c719698c8d8e03252c9982734f99477fdcd64f6af42127caff92053fe61fc5c8146fb4939a8044f7a35b98e6b340e2c29ca7ed4edc18af2a57e7624a8012c95c4aab3a318cd87a2b04ae1fdd9567832e8e73ecb391cdc8476d5ae98cef22cf1c04ec2559135286c613e80ba7ab20155ddd06dc031688fa0cc70271cc5d85aa68e6a9dfe0aa7d9b87b7d2e84e0c4674f6b02bb88d197ba75ae8c148cea77c07a6f45b7e7bf5f02bbcf7797ff127b4cc4a2a442cbfb3c660709f20f7963f644910161567bff62d84c7a2f1c2b9efa289e3b6d60210c0ab880c7fae72ce99c0cb699fd3de255d9fa4e4f9770053139507f98c2141666ce7ed4e9ea62c5f2b69a0dc1e4ed66bec061a95d4511c79e14eeafe9065ef39f140df776c9aba821bcc197e7787bf4f40640baf134b667f2326d538469fd9ef7de6728e9098ee5ab5b4d609b92bab21c9b1c36f796eecbcb6c1760c330a68e58e8c3c745efcf98d898878ed303c6e38515148513f957500ca0bacdcf27a2a2565de351deeff8516bb4653774232c3f4ef56a92f19679d29593901b2a551afb592003a33d475dd39a3bd3627d429044bc95c2a98aafc93254c521ff76738026e2b4cc9476074b886cea0d63eb45c816460b8518e56b613892c514a891e1ddffaadf2eaf9c01c9e01e159536b52a77dd6cfce8f11f840162b98b672ed9065169a271e6e897624bbcc0a7342065e959d468209ae378ef9eed24f47257fea97393b4812fffdff5e72b044447ac486bce8b4fbb417a4f285138fbfcefdb8d298041db62ae2c96bf6c2359b03dffca03ea97c7ea099ca609a22ffef36705fb3ca13fffc415dc48690da2d6d4d97dba9051a4d3691cfeff384934cb534f5a9d5220333b5efee88d2276956df0ca82220f2eac4a9dd2f8ef8bfdf79a385a8d4b8718a9c26263923abd3d1990af17cba40c005d77dcef761ae08ad388b4db44d5e76dfd9d92a29eca2561386e47c271674fe4228692ddcdcc1b09c1c3ea595725629b4e676897b6dc610ca62e92d42fd7bf86a725ab375e851ae20564a6dd73c3b707b07b2cdf95e92f32e2ea7cb8bf80372a64a4ad3652f9e059b0b14e71ffbe572b5c55a99947e4b33a8f268b9274255b9ce709f2e958f8b0aae1a81eae844766fe8efbbf7480dd4645e524c38dc723cc04e36420b2c6c4b1ff604de0df6a82861a539892375c92af63a333c349efa9c1a776454357869531c6deabe5d28b1af80547de45db5fb8962cd46255caa5a90d961769bc7dabdcf6d9d71b0809673d5145a23fece5663a1353f7685b41a68ec94432297224d216c90a13311c0be6582f838a60646054fb91b1845d01f34df500267d725fb131381ac36f6332b3dba5cad874428e864c431a0ca5b9d232102d091ae3fba6b3807b32d192ba9b952c14ef3df312d6f87e0ce6b5046e914c3fe5d2261cbb96c1067da70c399f42409a475e895f4d28e3252a63d98a567c3b65ec4ed9f150978116bc5d9142362646735f554cd45f98bc18595dc04883c114dac5f6d471286f1de18bf186b0ccccf4b7497b82302fc2d818b44181fe239b8e660bf5526f80780d4eb887569f10666990d3a6af5b7171162c8b20af34d705778979b4fe70af8d45b6c70f87e7027664fefc5698966fc87decb24334da3b18049f855857f9212ee0397bbad795953c950892352ea007bc95141fa6446163854b4cc4684bedfe767e728bbf46ebeccb1fb15b041b9e813897a8b0c4feb6fc88ea28bc878eac560cef9ceaaf98ff8cb61381d712d5c231f15e3ac8dac57e1adc5752f1c2704193613c42d082549fe74dee1e9aa0923bb1a7831ce12d9218f709f3a5f8d3b2c41add4184f24722557a0e11889edefcfea753037b8fee607498069129f9ffc3658ebd5108854a4901f6d4e6b361d366069f108c09d8956535312e9fa1cdf8bcc314dabaf74fc670e48ba42b65ee810ca9c11b1af34306d890f2ee5c3f348a5d34c1b4d252630c7ed13006a825c8f8a15a1e9b18227d127de4049c89d137153de56f90e573c2837bd6e19699225d3f1c903703e250ccc738f2fac110e3273ed264c48951f15d8af7b5d559fb1d8e99ab4e87be13f1c7a5a860775bdd651666c7eb3fc82319b09abc7c38cbf5fec5a2538d48c13c6f6a9c2747759fcc1b1204c04621b7ade27c4e7b071d1cc5f29a0fed94780a45c4021ee6480d2b3755a0f6e069052d87f4f4b16568003af7c27911c61e36572f999dcb73afad16267653902b97d479cbc1c3ddaa053f6e9356be1df97738cfb89928dfac60a9854bc13990d179e14c60917e527986304297813b4a2ab184a2218a6d49a528e0cf02456325f6add26982d12f87eb2e036595d07eac01ab9a9e3cc27b829393605dd971f7d85c2926b273bacdf3515e8bf3b2ce0a46368129b63c841e2224a4cc8a0fc6754db67b858bc99ef5d07cb8f28f866e273af84fe55c3c7eb7d72d33d7df3e162cb35ecd16529fc1379926ca813e0b9788d1e8808879ced05363335275d081ae93334bff1357a0f0e318c819efb701f9ec86a66615d58b22fda34f2dd28816ac67139140dfc5d0ea1dfbd5bd823654b69cc634640684e724ea6e49f264aca1cadb1e37fe9f85b0299bf2ef42d4aa6fa9649fccb13b8e275f85e6fe591f9a51692bc52fa3bbe83be9f5e2a51511750035ae10901baba3bfd0e0f49c44dad511a160c9aa34e7faa29b74000469e859f15430b068fd209bbb638728b9c846a97041e32c9f5e97a400eeeac3e77f266c8e36822d4d037accabb7cff6cbe5e8f0d51acdad36be8e0caa8399a33f0b111941e20bd816d8595e995fcd409e020bbebb7e2093e56fdf63bd6b9354595bd38dbcb63dc9dde9ac6b8573d3f817fe0bde31722039a79814cdb1728efb6a48e84cc285dcf92867e10bdf9860902ffd4c951360640ccb4ca6d11dc1b7ef1e6ffc540453a3c9cb7905edc08a97dd43169e0a46a3c0fcec3e9c3963737a15f04eec8c71f00f4cb5261b97c8787b7731d120ab677a88beb25cfe6a922fa53ea7677155a81f1b0c85bae4189ce525546a93d76924f0d1fde57c825ebb721f78bde9588dd550b66739f80b5c91abf3fc64153669ab2d26b777ce830d88cbfda5b9c4b5e815ddabba551d887a06ee9dc9d585130ae5f6958220169c0b13b11a4c2ac94d95e722fbfe6114b2803fed25503dd983896a7b066e4a8fbd1a5fb82833ec9caae61ffe128d53351ca41db0a386609da1e0e20687ad108eb9c3ee6f4897ae1d0ffc92029cbf73ba77354de80059ef8267971e819d294f3085828bb695f0bf78056c90379d69f1e422b45962375d2fe0426969ae4fcce8ce849f1f1d96b83800d6cbb50054c083bcec0d2a66c85a6ffc8048607850099b54839073b17870f4066caba302b3b3c33b41aadfd08daea290643e4bd83403545b74ff64916c83a2420a5477c999c57157544dfe4e5f67d45a450d578e1a3e2b901a3d3372acaad7d1776c31939fd6fe90b57844f6bb31b762779d7b3f1ae281416cb752cbc47087929499b2d143c0220c9fb9c9c80f9836f7a41717354a59dcac3ca391ad645a84e698cffcf5fb496b459147673d2844add7d6ff187d10824140350434ace849864f940296beac7c89c2349417c76c103c53142a4b3a084e776424716d7a2ca61cde8072a92e20b97536fccd01837cacd1fb980ae099c1638c4312d0e4a282348baeb3442ee830329d089ac514a123c4b9847479e3036fdefa00a0031da3ae0e72b19a0f3eb101b050e711c662bd5e94d2404552f70d988b361db37b104a069e29488ad965dc6160d8e786f134097168dae2d3be4c568744ddd7351e5b0e6bf3fe8a044407d0eaa0ddb3268bf017fc9432ed3354b7a66a89b0c2e2e5d0e01da5064d036f6c76314bca17d41dd2a312e8324d897a2661feb10d0ac72143d3d03cf0aefb74ab955dcde275ba588a3e6e2a47b073c16c3f9728440c71eeb3ec057b52c08fa6e5f876b2bac6dd5cef6c858d900ab0256d0fc4e09935bbc061557245695240f0c2c2e9f614cc82cb31dce8937fa7fbaf409c216351b7763f94640309f66c827e998e7d6104373fdd03edf333cb18cbe79752661fb6b431697303e410057bece0e59c090fef7784d48a55da9a403a3324717d59b03e9c2ab433d79f6cb90fb041500384474d0038e84ecf293c29ff0419d7d2cd8e172ca6539175f77a3e68e50ca8fb21b438b775299a5d68c8876b3ecdbce1026f19af20fe4d6f906b0125d61c976fb9c316774c900d2bbf790547f83a2ead85404c0bc7b238f1e3b44cb888569c20e9ed825cf4bc8dbb1ef21d5ac7b801240153e2e6f0eab5622490b34ebe6097cafebb98cb87caeeebd6b18c629b85ff88a67691337aa3cc2e64bdcae86760212f5d1f9a67f118c1fb56c923b0a6e16e08859cf53471ede8a750622df8c246ba784c0e8a739d60de66114f7f78c47f95c274b2eec3be9c89d085697fdf1a6f08494e0a7d4335772a70dd734e922829c39cfb88c7c583a65811378ce906e627d87ada9711b4af480e25a05e08c80d39496e657e5e055d3ed787d8f8ea29d09239aa970d31b2f59b465432377ae530db786eea12b14be0d8d4cbef59c0b0699f89bea194f619fbda98f5e15f0bec9cb92995e3ca43df6b65fea4f09ec251f8fd3d1afebaa9c1c698fa0613eef9151f6ff75808cb97908cdb4111abca75dd463248de577f8a60fd25b2c205a70aa91c3623f3dd2a66718299af36ee53e14df7c9f71a37a9e6d61529ebd879414ae9ac31f2a8a4a84e2db07caa575b3af0edb638a9b909baf136d3cd81ee3232c74aa42d881838f49436bd39c2bebdea45dbb49f803a3d528cd7f64de1400b5c5628b3d7f1f37c1b85f68d447eaa28302048202437a4310f359894c6d23609f39d014946855d3dfd72eeee4ecd29f477890708fd5f0060b79296388da0aff86bebc515cc394df0862251d53ab4259b9ea678165463f3e838933525aefedfd7824ff1ba91005113c69826d07550facc6607288e96f155edc67320c502cc2ad30b9ef68c0d65a0ec44f24e35fce3c71c247053353ef855bf4b3be5c3d9a73a78940128ce6bae1978754418c758f49ba6f819aec7cb2113fada57c332e85582c0e053560543725eb7b4094fdcc6dd880a18c8e92db41536c70983037feaf431244aefaa7820a2a81dfc36079400397dc44b0ffa85da9daaf745ff0a6290e4e9064d8a28caceea7857591aa3185e21e2468968e0b336a16e560a2a53daac7ec175e3112ef78909335148e2c215d73b28e4e20a6602501a1f3f88b495c9edb4362fae880f903bae7190b19f88b77a9edb7d54eb7f0cbd7cb58eb2cfc689da04aacd171564911f74b1368ab3dbef5890a19b76de86ab6f29db5117761a5c5d5f21df064f2196d409bf71cf6adf709de5b8b7a3d6980d824f107cb06aaad3518e8d35bae59e86f369ca114f14dfa0a0ac04ab452515df8252feefffb1370fff27d8536f74bd831c58ba25d645e76305381243be5c0358a113efdefca23001178564fc361ba074ef6730a034dc0d34a29537a56335b33e0b9fb0d9eb7e2122533e5c81714eb5148c19ef7f0d700b8d6d95229eaa220f4bec750a48f0f31c4e041f5f72944028d3edc24ce41658d7c5ba749959b456199e7492c82b0c55ea8df49a7a3b0127635185ed0f5715f8063548d865b0d52bd69a95a1ba682a316b7112ed3e0c667b0ddaa1b56784b84fb543eeba3c67490f7ebb9071f23a7a86f764ca4d410f41d62b616aabab799c1d15e3dd62fbae70e539c271edd1e3ac6474affc30473895253aa525397da91a77a287088813fb10b8fbacec93066271848527bebc62dbe6202464c36134e47132dec0e2ded362ca7b0f61eac13a3c97a156ec572a147112f29f2c18741468d7e31656ba5913ea76450d9d8957e5944fe7bcac5920db3497146b72fff04492dffd1bf8af6d86ab40f519b49dd1b394702fc896235e0c2b2537372087dd7abf8a0b06411dd1f0a8ed64a777717701cbc9e3c07e429f6b35f72e198087866c41f6bb3ca671764c1d73c7b6d5f77f0d0ae2bc16041bd6d39c93aa447c8c27203bd53186403091eeb3a3866ef5d838e5698dd67b4360c83d97936e2ef5cf67130bfd3ea5b60d6cda89ca5f02b42edcc23c77c3f505c29745975d0a3748da03d26c0c759395ebbfa4c8fadf5a0a6fc4d619105960c8c53a7e6f3be5adbfcb1d288bacd60e9ba440d657e1463db86c1322e5675c3390e8bdb0d79ae66f1cfd051a255a59a89090029c53312ab267ee3e5460f6e1562587d0c8325fb1bc9f15009584c29e5fcb798814102168e3f7984323e82da3df3edeecb601381ede140c989ed91a133f0d132eb9a37e7eab5e40366b3c624b66d15fe88dae29cd15742390c35e982688d1a07807eb1aee737db0dea8e1ae5268c941f93201f938f4c715d2032866fcad957da8da9930a2bbf98b490934a5daf873870634920d6487ff28e6bfefb666cd02ded5cea45c4a562af75e7466f4a91fd2035747d1507428e85802ed3b88511747a51e1521e81adf16522b5cfa65b2abbddc5526e0489b17b6ba6f618b00b65c83f6414ba9953f2348ea1f81186c905221ae827763315c205daf659682b43397f4786fbf1bdc8cb8edaeb809c78b122ad0184ecb1da858c213147626a4a75a576cd2b93a7128e16171f6ba4b903ccfee204032337fc09460d737f8ff18d3dda8a780ca3c6040af05fca4cea014a7ea6b9d827e7733108d4006e7d4f20e78e3a7e01a5c1953bad8718033d576afbcb6aef70375560114a4657096283f9dd992716b89785b9f6d9c61c278c69e6ac1d4e6130bba77fbf1a880b0c210a2896631881f6a2a1eeb3e93401ce1e10fbf3f8b9ac92bc65c2eb5eaafc622775ce4c290ffaaedb91d01baac10eb25285ebf1d8844ac813efc1fcf72fa3138bf644aa2fe439fb79015f843824f9be07b8a516b23128c04d53bddc712d5af54aea8650a7221bc9f396fa49f917d13edd824f6e0fadc763ef4046c70f0c48d302e79fa16dd4ba7a6475de82f16bce53762b5709536cf76b5b8c3650b5474ee42dcb86769a5aa8f2d4f9bad151f11fdb4941dbf7932aafa864a0bfe3048da8c3e30cdf09323881755fee1ec3de6d8f608de4f7f966a5badc3c7b1c2ca14bc936d7bd53a6e4a813a6f14ac1148b1fb6935b1b192d2d18ae87eec49ddecf146ba3b0a24f33858d1c3c9675a9d905e6e7a6fe6c64a634681dbaa80e69ffd061cc59755384f6c7864c8ca772372f5efcf7af7fdadc25602dd85507fad20a8a1988642aa01260c62866f723e1039b6793af8246b80dff9c0d928b7d5246114b8e621f4638477d213588caf588aa0613d24e4967bf488ab986f39ffc12d16208413b6ccda733b27f5e8a2b76c8f96640cdcda2357e3f1c98f65c33600f9d2ce642321a939643f95cca6b490c01224b2b8a827c984454977977bcfc2efd7fa06ebbfaa5f7c1d966b92f1db7275efeddd667f8ffaa08b5c416bd68af78e34be1e569ac6b7f6bee18b343134b351a9d862a25f9899c5f8d98001b99c73bf7ede04f3d456e6ffad903408133cb70b3350d15d13fee18590a002143dd2763ee888842a903144c2a9b416a040139ad4b294b45935aaf55a51ab47abc159c1c71f3b14437b376af8f3d23754f9df0b4d22510b8094b907ec970a04444420612cebc9290af438f6acdf67ac05a373b3a5b5583a31385b22483bb7e7320e8fd526e8793363f451831136c481f18e98840b63374455e62b8e40c40f54a2fde9a88463c8bee71ee247a422759af0db764e4905c2dddaf7932774ca697e4e1efefd07504b7c1b6abcdd42e13e9c5a0d9e0b1da0c732f56047eae0e562db9477887b279f5881149f9a2331700dea3faa661c4158124acad43c4cd33c6e5b51f0bf6ffe86ce90aed8dd6b452b1d1a07bfe973d9e944676e9c325a0e507cbc8f1059ca3d994e42c7a97904bf5f7eef3664ef8e18de6a1a0a683119709cb36b6b4c1bd42ab9c421a25f88b1d527e0d66792667eb3cce823123fa9ae7550cbf3fbb79d3d6681a24a740ec4f6413dc72f2dfafc85b29b297adf709ab07984b254392518af6a91159bfaa2d12f0998226a8ce928af99683c51ce78dc8db6b9851e195bce546b18a55f5bac9e78561fef4c707697df9d2c71aba218b9efb1a65d3a2d21819334beb6079eb8968b7ef0c7d62a56ed8cd2693d0631ce6c1d0c894a2d6eb6fdd5db326d2516a1134385a957f33257b2cd0e34423e974f4da917ae02448723728b9cf210264b6c2156ef2deec737cb2738a80d4c9583fa3ed10143055f5d0e307bd13fea87d0d2fffc5704e5e98b0f37fe30f1e1e4ad065350daf28102c2a748a202aa29ec0f233098d021334687b14d8c8ee67eb26d41ccb05ee902f515990ca7e299beafb234bc308fdd41060392e58a2aa098ee566deba840c332832336eb7a330851b5a438eb9372e8138412715e9a590f617486325459a8da8c2e66f5b227644da8ae7e938f9ecbf63bd758a82ac2f6e9adff0c756059e1d0e962690c6ea46657b61933365d78a0e0102bb6489656c047dff3e7e0ea81bef82681451db19949600c357bb0734a5360d979836b7cb91421c7f7922ac07cfd0f35b9b6da5dcd5e649107184a869a38acb99809f96461f046462eff0937f5b599f538110a1bbf716f7014ccb10f31f098d4a24813bf91ddd2b6b2d9abbb645a71862f06ba2b985af345d2220df7bf8d66facbf5bce574ffc8771fb304e0a5c4b655e457e0933c698446e4b82e6fa60efc04d3bc1eba66d7e13e2cca99f71152ded12f52ef3857fbfa689586b4cd5c8a384d4fec08bd6ceb4d53813f97534fa50968e85fdbfe5645a6835a73456f1b217f36f6c14bfe115ecf3dfbc30d02652caed816369ce0162585e80358749fe0514a4e1ba6773f54f7d81810ee9e782eb3a093874b8b578b0db926da7fa6a06b47f4d149efa2eed128fff761c6b3443954dea07ecf6c0821f1c41e4ff3e6bfc23894c4e2270927dc8366db1d5bb5a133f6a4abc4a6adc2b27fa8cd18eade12edde8ca39346b797f675e9edea4e8e0fa2ba1df4bbd94014f4c3e373d3871671a5a6e84cf2febaa47cc1c56569b784e43becb28e0679ff7b4c8981b08d5f177fea481b4320bfd954fe194f9de558c54ed0b1c36ef27ea09969b76bdeebd61b1e884dd83826d7808459a6238d2f70f74602e46996d14a4b5497a5afc279de7072c57b5fcd77bb3c5389ff9358ac17aaa5f4507053cd2b1ba85d060c686fc263afbfdda716b0d91fc50b580ac8b2a10bcf009205269c5b797e382b022a900cdb2b3c334e0c9c6e4bab400301bc1c851676ab631d413acbac5af569b9d3f5dd12fde7046528bb228e4f445604e72867d2a84971b0ae2bf8c4bebda8cdbeff8e330c613abe9aa73c5cc6aa7dcb6e7cba4ad780b6b3a0024952f9185bfdc6c064eff4d42dceb27fbdab30d0c7571196c36b1c2d3e6c050e65610ee839ad15515d6499b2ec7bc5892c044c38bc78604dacfb76598579c6880931b5c7c52a31a16809b890d509a151e04eb14cbe56d57dad6aa7b920698155990f2fed01f2ae84b016caece7c12f913a1178f1489fd5ade9d4c00d922953bea33d7c6e3627746dfb0f221b16f82ed0454896c327b8e83a856ba98f85ab690f8d19c2e905d8c6fab97ad84ee766b4875a355e6ca924331f7c4879cceb7d9b186578b64da7f7d900a352e38384ac33e6bdc5b185ec7fbc18076f678affccefb2c2b3d5d0125c17160559baff590397d111bfcd6190fcd043bc2a9e80496a9a5b7d12fa75f3f716226cd168c4ab817cb913d498621558a5ee89844b516713cc9db807faa1cb6d36035bb34b5ea9e7669e729a013c8c9efef43ac1ed7db265d076e0d6358ab47916c6bb4b844230f03080fbf26fec103348e143dd1f5a17b34ab73699e93c95537475f48e808c1671425a2be15f8d625972efdf0a0e7f010fe8f97f05c6f2bb8b2ef9285bdb5dc2fd67be713e1032ab2480aaac983f6bc936571178cb0449c5c70fe93cd6acb4251e3b674f569991ce0e2b7aafc9a88c24e4e8dd17c54b5a8a24497e8690722ec548a84eb68aada93738b2a35e7790b3ae10a9d16d45979ead3d9aab1c75ba1d1f463807daf1b9930949cf6f1595162dba80902d464a9e726700b3627485400f08d3bddfdfc45545bcb918681eb20a1e0877224951f1452662c7858e206ba9900380a08eab015df85894a0b88fbb6946d519ddeb33652f94c3f8bec9ea6fd49a8a19d4eb283f993c095698c64db13d00c9bf9194a9fae3ce833d1983a5edc2498ac28d43382c0e0a981f5f05f05e458931d2ff0ff7f32a97d1bce90dd91dec01af3ed1e8ac3d64be9b92f735e8795b03a927d3a02ef270fb85586e0ad218357103e10ff2f0712fe3eb083c6541440b13c3db3726ef224e1146d057e024034738f45be383f968ff82a3d32cfdff947fb0fcbe58abca475bdaa61d3c980ad8da177f6465da258cf6e53bd5d89317ce5ed964c4b9c5fbae92e758d76fb7b1498fc4730457be9bfc9bb69775d119c01c785916589231d4deca6d1c8c165007154020eb09ee98b151c0002a78dd8c4439526f6d6c3343702d719c48803da9e1d1b190ff6df05863e3b5025029dfd021cad498f76f0c61b54603afd6dcc1050493dbc04650a1b4f739bf40ddb4f43c2db747c871c769098dc333d7fbd7a8ebdeaad75c77c8062726c26d5373932e7d358320cda076b58800757e5f3e0c08b615410113025557340e84f7b54b7c5337a053616612a0d66e2f121c76e4a7f1cf0b79a5549b160a46d324b121c0408cec6cd77cdb6b27b92f18af400de88327c526adc93aeaf9ac73a66f5f011e44f90430277c966666d656f1367de1c05f7ff665c56796b557e0fd306963e8dc7ab1235f76eaf2524e3ea18d4d2aa2f487b3b73196e50839f024ade6581d0d231557b0a60993f1c1bab0d15dcd7969fccdb220d234291d568ec9b3d3ce624d2fbd505d80fa118746a7f37edf55e3b5aea606d2d9e9a284081fd4f06c6899ec38f43f06696cfc1baa8bceedb624a40f80e2743aafc676a4e5ec6328b9647d9b404f09e3a01fc8f9c8f556afa8687ac07a974cbfedbf591b19408e98a584576084830c450e1bbe132a3277fbb33bf05c8b6d82e26a0516659d266ca8880fcae516f2c30041ebe997c844062de86e88e8e7fe2a8bb01c0481c0739f6020fda6062e5e90ba64b9d49d3cca5cfec912ce569eaaca73376a3e63f99af1b3494d4fe2fb42068e0662d0af06580615184b9d13bd0df100a34b4b77318d864d6d2a2280c277385db5e6ae37486c4d441ab31db1203432d0da88365b30d76c2ecdc24a50ce6367a52485c016444d51a8026381740e2d083e4ebc3304914350710ef5e730d1ca09e5ed74b070c5d095acd515ad7910785326abb9b8699507aecf1f5a79fde43622422a02c2ed0a71d1d4433c9dca03436ec0f7d238ad841232bbc9deb5e0c16128ca90b963d4e9c02c0030f480a95fd2b53271132388a81897939fb5bb78cd3e05e14adbd0cb3aba03cdf31145632fa49696af5b110bbe783510ddfb29fb1e835d269ef739e881ad042c2044422db74ffc40a061698d50d3d725c68b4795fb5ef9919226d3d769281ef75b2cc02c1818734d39d7f0052aa0a16985b5091f112c8299b46c4e5f6a5650a901c17c8aba5bca729484c3ebe8f0a9aaa723b09bce47132a53e2d76aad81","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
