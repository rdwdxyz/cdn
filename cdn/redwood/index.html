<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ee14aafab9e4743a71794f3368ca982d016d0fc371903b847811b2e754675d32fe8e5e40caef7c948fa13b5c048d55c09742f1a2cf1de7b25cd2ee7831bc43a80e11a8b47a5453013808b2792e3ae33a3e229c65ba6584a770bf4b6b1030337b68ea9a9ba3d181cc0310cf8379d34a96e1d9f777143cd54d8341347ffb9dd6d321c3c93059cb26d4f6a0454365e6ac0895078623d6d6f0d29ea08f41a8039b3f936866b6ba0b78fd2f49ead4ab987c18cf9cfb64d4e15bdb329f6a1b52a69005c74cf95e2ac412c7646d5e2f5590205f9d9d12c72bd5e2f458afd53e915ce04b5be059decd50d8b45db8e83916f07ae36a2ff6e8798f677b7c47b8d62bd9772c08727235e81c4ad6948bd46e001aa234e888f925b05df76d3a101a185c5b7a8e13b8af888be236d7d152280bd0f84b0cb72aa6edf947e0b6337d5ae134885f1f9a830f262af6af6152557cbbdd3ebc459f0dcbee1062762ef6e86fe792e5b5b2f9488a818b6b23adcd1dcc4c66fe05c205d7aae7192aef3dd9fd9b2cb293ab20206b0fc62d12fa30bbf53314c46fc989529bbdbd43457f23f4ab02bb53b01735154dde5a4dc57e9a51e0a29f14ae477f34af18ccd5725d15e041403c1fb340ef176f02e89baf64310064ea2d69f9761e75a56d1f7a69aa7b37326600b7043b02814f849b4a0737c6b2b1b5e2af57627e6ffe56322227583bcd0a4150243105d97ee4ded41d8e3457b651ffbbdb54f09261c6292519546214914424a9ae97cf289e9cd27cb764578a1842864111d12e39a09ee376a857f19b4d262fe5b6afc7203e0e9d32b223aa5ef597ab6e03595d9f1b66f964d62246c056101c207c7b5e9acf537b2f129fbd4cf4be634fe3c7da1ce839b9a0d20e5f19f18bf2f903bdd968971af21a69d849ca7d3b52e6412b33f1a97cddf1d6f89556aab8f03118e87086d2e638ccfcefd69f41c0a346c01cb47faa904043105d7bf245fd0e52a37b187408369896db976ab30150e7285f0ea91e38a5e5da1dbf1295cead4ab8e15c470587cfee400d9a504340d638f8098e2995afcedd293f298911c8234670d9692a251bdf46706ebe10e6b2673e0563cb63e351d1d01911f3537e3e081350ce2a13cb9b2595ceb1306a065cdf063a530f8e8712522bf63551385c3d982696c354b10f7235299f60b1716960f8491909e410dd95e4a7c1b76f17688522ff8579c20d16e97913360bfb8701aef6c0a94bc642acf4cdfc82e3bee466c5b409f1cce3b906f20340f44a933c5b8814ae99f5824441ab7cd1ebe16f9e00e706c1cf8b3878d3f4eb301f3e9444ab72634bdc1a80d88ab1835a04d66116f8f02999202ea3d4642705cd6a897dba7d156d522934014566e064a7bfda838aaa52e4fd22910a82d3db1691bc5eb5408895b99329981a0a15172a6c9a114dcbc87ac42b7c049e740f926f9d43f1426590ddd66452293feff0e152be52a41e9257ebe1c369cdb7c11c46e0c9dda905ebf5ce667e908c710b555be05c7bd15694f8a6079d8464e375f0455a3e56de20359f0de7b857176fbb0a7451650865de80edd18e5bb3866ada11a8cfe460d7d28fffb1da4651d356c91ba2c9c0c19fe0455923d0688f8069cf4c490fe13c39d983a579f65a3b0742bdf4e682bc4cf446e9dca15198004b398f37aba5bc648f0429fe51b7190efca2efb2eb42e5ac13dc1c148f65134bde14412284d71851a759b16ffaaccc5853fc7c65f78b9a39442d13dc2b4af6edd76029c7e021027cb8fc0dad33c98080d5a290b2ba00bdc4fb1129fc3744498b9b67f69ebc9fd50de74104d68f31065817495f0d68eb65394983d8477d13574fc68b30c515d30e31a173890ce5094bfdfc220f1528985bd99b104e6527bdbbdb7bf411f22d8bc080d9658412407fe504fd141ad470785fe23a048323a33c0f5c0f7d6242d74d53e28900a4938f229a661f6f47f2433e8382c7fad1e134c2f7864ba96ce9ff546d4444880c7bf3e4364b79fa4b74a8fbcebf1dbea04d1a19d0f05ddbf88181a902468a86efd2ceae6eaaf9ae123c8173561dd3b76b01e07c4cc934010446aa320d8e48a8ca3ca0132a52689a81b187b2d86094ae9c1704c965305f4d7b93feb2f4fc6705881064e566fc0f54fda2e3d797ac21828f5d89598adac81ee0848fab3e235f7cd517cc80e74c586d137ccc323021d2fcadcba719f86924737bc20cbba034b32c9fd1c04d1a88cf10bcc4f32b1c3f367ea8e112d4c6884b9296135d52fa197eeffbaa1ec012b715908332ec81b69e278b28a47c6747b7506fc977be988c925c6def234d2a313df79573958573a6cc0d2fe417bffa108c124a8c0d6b1bd81366a07bd62c6cad83bc2db81df29de585cea81559cc94c618b83c35cb1169ef70bff45c1d51285660c084a428b893a80a4d425384169e02dbc7964365ee8d4f0582ad9dcc59fb82ccc1ab80dc646be45a9e391a5faa7809a7df06717e1ae7f57c888f9f76183e4fab2df1e6f22253bffec6da046574caa35a9ed3a170f8a17a360363e12b4e5bb0f3c8820da292cddeb61e04c24f980d78a8cd3e1f3e795a100aef134ed8c59b57cbab5ed34c658f4dac281c71031d9c45adb5a2370174e0ab00ccb707828efb5b1edd465cc867836e3d931bb05749e75663961da8b9e5b940fbd90b12d4ec9b9e522c90693966f58ef3554ce21cc0a88de3875fc6d115889c65eda926919f39eb93d872e015a2605c509b2a15c441322aa8570e9adb59d18da506dc1e62592c689565736627574fde62cd3b2eb4e020998ef2e7eb408ae55e25d3eaf4493662329fa8a0ac7ea63052ca7ddb0c0c65863feef60ebf6e68229f948f9b0d5cc5b388b5ba191bfb1f93e7660337a702e5e2182d6f5bd7e26eb131263dbecbcffd207191921ade17e524061656a25fae23e108ba5d5e5a6fa02ff0a6ca180325931592430d3803d6b6a577026d8a980d61f887f997571ae7e9e295ec2db54c4d2cc255235549120969c57c536b1ffea9b880837cb30b8c47ea00839d1b50b4f5b9088c5f6b5f2a9ae10f1060ab55a5ad9ae6b1ec6f0ea2931ec00af680576cdedb34f9f2130aa8f5e52797ab77096d5238a3436e59205f610410dddc693aaebb1fcc7015238501c9a5112b6b8669cc9bd0d3a696fe56180d79db0330b6eaf0e6b4dc388f0a3d4c1d032cc2d9dc7c88b17482327e331936eb856f69fadaa47ad64d874e61d7852418785ab4db1b8334da4961cb5b4676819d63ad5dbd637c5728e95a3758950f26f8eb113a9f3dcd4bb699357be4812a88700f77564ebb80891d89dbd8bc235d821f5ed20bf83e5e68a68e62987b9ef72df09524e4783ce280fd4aef00e6d69a0e373c87bbde2ebaf809ff942efbb2aa506a75c703d07476ec9f0525b25a5149b88beb31e17eb94c077c25d2b3d7a123ee3dcaeadbc1fb4f470ce5824dbf461422ab865f370e8a9cd6b7bda867fee4789eb19d277ca16e478a991982fd9176046b55e44e92d7f8b2300031303194c54908e114cff6b717c690d5c8db8f35c6d1841163dcfb1a6a8786b5f5d065b16522933ea3f06ee338e24a01bf4b83fa41d7dc49fe7a8a4769a5f7375048003cab50ea2abdd27546fc83a5396c263b924899add442f08ee751518477449caa307559b589eef01261c6e7d8a26c1f31164342ab3b4581dacd618c83d3da3b967dc2c6df70fe7ffbed5ebd4421a5eef69fba2815baec6be333312a3f80799772dcb70b408bec40ce2a872758279ffd3235af74f34dcb2ea77f25eb4eccb634d77984b16e8250f422f86a600ca293ee029369cd25cbf1cd704b0c6ab0f0f0ccbbaf2455ca5d98b79abadaf68f2aa7a4e7b55f9db55e140f601f2eb632280ba8ec480d68fa9021d2b44e652989a9a3ffaad62d9c3ff85dba475152f29b6038334014a31acfc5f4080ad96c2a17711b687134d6dfd5f07cc99f2f5242afa8d3d02d9e2ecedbe6675ba53eadf9e03bece379f12ebaa48083e2d4a9c061acbb187cb6bde700563482aef2f21d902867487e2b0362a06bf61901bcae08d4c34c71fa108e3fd797cb9fde804281c01e62e0532763dc3e328c153908c3832d79e49ccd3d9298021a914ac10c9174e239f16107d9ae6459a55eaf85e715632fbacbe4a05cf1396e1c5f68d443afdc4d2c5a781292cf43dff416cf26fd2da3f26fd911ba26f749106c84363b0820e24ec61c373f741823e42753b1c393be91324f4eeaf29829b196457e9c26de6cd6bd156895cd49243bcd7fd97534ce78a5028d0feb606a59d1b95c0e53899eca3f2df70feb1797ad7ba5f9ef4520df7d1d26bd73d1e5c3e97ea24414093d5cc688236a02e958509f8acc7ca51ee317bbff61378426d4599d7222283c569ad3b4635de6c7494bf1844210813b89c674865b5a1ad45ab1236760c2e7daaf209f6f439cec8c7fc9559d43d3a72cc73cef3397f82218eb0ce8fad48ab1f6e7cd5383f1fd17ce62db6557db286a2e339466921a78e38d7bf69183c6fe131682a933c1e0ad6247f94bf0e5f20af910cd3197e218e94abb64e029577b8005561d64e292ccb2978997cb2e753d4f92a0e09bfbe616476dd36abc4313550c32446c9575d4627fd4d7fdff0676139655dbd7e6ce4bb17c6ae28b0929be72a1d645ce24b071ed62140322007a0c55e1fd63c3c92a49a5131fa58be0095bc3347fd78bc95d28982da16db36a07c11e7b54ebdbcbf21c0dc2daaee6aac790a31dd5a48f9203c35df22d27e4759f257b7b771e53a788823436c3f19f260a8daaa3ef78533a0d60e4137434ca94ab3a1cc5d73a1e91fe6f352d3c49a5d859746b6c6a2427fc333e8c5402a93528774ed2a0ba4c6cce665abcf6eefb31eae47bd23768c0a6c58957ce121801c195ac668743c547dfd7ba0aae2e6fcc947b9100a86a4bd3bf57ad1f245282d213714067327bd06529abb0d3b29e4ccb1fb9b6b5738b2d5c039e7323a97baf120f2fd28eeb7c6a8c768970f2cf36c6bf1be4390b19ee5c77631cf54db7bc687aed0ab409c9b3b0c50701276dfb33b4ae0e1616e8162e27dcbad433873340e1288dedd4bfa1ce2d93bcc1b017b90b39b2e1b348a4eb63b8391298d1df0d8fd4408555102a821b28febeb224aa74e9e5f4149266d27c88ab05a1c72f0c491179b49671416a76fadcb14fa1ebeb6864a209292aede706205d5b87b237abe1606a9bfd853dff7eee929137daa6fb5c8c74abfcdd28e6edd2a5493bb3c493d6eaccb70a81734eb550a2d3c735b031429c2de0ed12a1b28805c43c6efdf898c35f8fd98c9b1ab0cafbe54c6dd59da1500fa09d1df8af5f43812777763920ccc9d9873a3fc9591b329f9192f39ddc9725a17cd918e25cb661c27a06e21762bc7bd94a187ce1dabeb495178b5884555748c025ca240831162b27ccbf49c8da02a0eed1babe2c049f0a131e757ce9045d227b936049a3a41058378e66c913440982a27bfec99070f962c76f896c40bd8635987955515bd92363d7c44befcc61c934997d0e3bb902e3d5e99667bb0cd4a7ce6cc59056d1c0ca22498e445c85c23e2385857be4775395be869fcd3325838055f3e8236b015c88dd8d56897a517048b5c9023247991c6777aa8a5f265d50b3c7f0cd71aa980de71e04317cf40ee64ba7224ec09ed5c8a61c4d4d3ab0aaf2b9124d68c88e20658a6788d230810ffe54aee78dd6ec7d6abb12562437e745a68829e5b067495b5ce9063a3139253bc108bcf8aa8e9d1c5e14a30a9a1417ba867b9af79eb4296c807870d15418588e8ee80b8b79e3a58dc37e267e5ca422410be152c20d7ca30ac5bddd42c942082a302fd0435a5ca340a0eab1c1f0d94ce7c0926c6f9ae6bb72fab70fb82c1eac8637ea8b8aeaaf94e04decc3b690e9de49ef0ddc076ce5b40296a726ef5b39dae79578a2772bc5ee5c8657fa3110e3256a422dc7a6f95015c7023ee6c15feaac9f23b3d9a957633092788ee5c28085eb863188caf354e70f9a71e6e190e80c5f939b034aa6ee87649cc55ebd97ec619d786f153e8f9d8c235787050e080fec33a6a94766864f659eaf2bb5a63a7a87886d3553c932e64ff38be46e8179b9537dd79f070e3904964c8a99a14de70c7a6599ffc71d4bda4d2e66254e370236f87416fb84e51db3c4352a396c4ee96bb5f60393a75aefc46ca2b403de26042b2c0bb7f50c5bd606baf20f751df3b0203c29720bc7456b723824269097f719ae03473db25ce8af968edf19ffe267302fd325954bd9a236a8b42804e52a61261f171f36fb1d975f1cb4b5937453c35a522a995bea44096bdaa3ac97084c04c8e62f3be7db63d556f547ca58ab31a0ddece6c6c149cbe486447272d3bf75482e04fdde30f7d62312f1ef1569e073391daab015a60921a0ff4933a4ad6b379c6bfce218327c7d3c24b8b716fdd212160bb745fb6e078476e0a2ade7e4d7d1b12d1f19d4a839291037db0f1f7879c1ce7f776305560d5a3180460663f4ffac58816063a28f578efa3f2c6351925c81f00b9ff8c6561bc6cd8c133239974c9d0aff08055c408202339e7ddf34039dac1d388d55c5d8f23c99399406b0c786e61dfc43738a8288cf7f40beca71ec6a84b098237804ba15f619f74e571b1c6e57990e2b89e7cff500f0aa2de869067f053687a25e95df9355ef1bd386c9194da51cbbea54a45296b26ca64ad72493ff9d16b132fe56a188f61ab38ce8b488013993eaaa0e3e3c46fbfd167af860c52c7a53ba1a1f5010a0124dec2d3ca5061e37c41dade35700b9e9ddae3d6448a243b6679dcc97acca0c4f3070f768f510162b66726b4acccf682901d8331c4e11a34f67528c3072a6ecb7b2bfd0f683519a90e739821acf43f1f05d2301c22c3e1ff0ed54baf03f0420178a3c5c6ca68ca79c339ae8a0ff0610ba89042eed5fbcbd05b3d6e75821aae1de768b48c0d4ad93664c748d0f7f6236fd1b8b5a217e82d56afded05d4d18a38e1ade00b82f1c4bfbc59e3e14018160fbd71a342b4ba70f07ac1865e2844691c74b7d2831513afdaafca414af9b91e2eb3141b5d40c4c17ea6aaec7b66f88ce417b05a5c2b775ecd20388281b52790d98c3cbc7c31ff99c8cbefeb6a08d2f4e19cfff8a921549a35e8cda93e47ade3c5851b3472a03324bdf33065dec6722698b901e527b849a4ee61daacd69f33cf765e364fa591d2114fd2c48b53d3095711ed8e5a8928be4855e7b8c80d62cd3d84e15b851a68550e94be50cef1547c2a3b6b394e65e8d1396b49e46ae00ac3945ed39971cc4e2455a7a325a315f7f3e85d0f2a43a5f6bb61cf6cc7dcf7070157a202756ddafa18dd7ad704d067c86f3db182e2bdad00c397056d20d0b90a0158b2342025b240e4186d05588bd9ab019cab267af78058030825d1119c4abbacea16e93ff824c0dad3ae9f0daae87110f7900ffcdb681d0ce29c02ac295200d43e28beeee10d8623e2fe654f636ce8c45c9448ad64b5837d0abaf2dbb1e0c14c0fbee930852598929f43ac3550470f5a6e37ee96330fb3bbc1de216264e6cb4b82b2b6f6d3531ed64c2d89715bc2b220ceaaf59c1fbfa852bd8604dbdd3ee5daeb160dfbc29c65fb3d9a2820890b9b8501e809e25e2d0fb8cfcfa710553e46414e463865483838dad3165157bfb400ceb4bad4a4c01a1992a9cd0d5ee577a574f08b590cff6ad8980c3426e86f672b5beeccc7091f12a2194710f61e91159c6748a9d73b9a23ca6be91927d910b1a61b9a42f0cee4e36b77e2bf00dbbf14613dc08eeb5f9e8c3ceabe9b90c9967ca36b5549abd1e86f69e1ccaafffa24384cba8266959cc70c8243f5b0935ad0a83eb6bfdc3953dc3222b92c42e627fd9297ff270b551bf54b26aac4fbee41de09cfbc0d5869810224c5113c5885732dc2fdf7d3a95ed1bb6e83b4416c08ee4e46d13c4ca62802e1eef0fc4d00b679fd81e97673b3b1b08df6063dffc4835716ea648a27488dfddff2a46e820444811e41ba8e08e46cb1f40a13ceb91885b1306fe6cf8d7fde0b221e7f40330190d8ea62d4e7ba16aaac1c34c2444ea6416eaf80ed6a9a38e7684c32bf224603b5d321a3519c6c97e73dacfa0c7bfcaeb7768f887e4d71c941aff830f8622dfccd4fb3355cf3be3053cd49e1a13bf5cdf6a6029ca88681b51bfc3a86e2d1344566e4719d2822163be884f758f923fd2b9655ca7d9cd30f04271e361b8e04fb781cd0ed534158847017cde28ce932244dbb408a58dee95aa2de824e8406bcd61d31181e91852f3b00062f6410ed2233780b488aa0032beeb9da5d915ec29b9f36b66ff98546dd70d240c22ae7aeb091a4985a4a7e355c16875f17e4020c0ac02b70d5c906d9575ccdd5df1d2f06b1fb66b95f2addd0cdb9883809206e3722253ee4be008d20d852d4f3e37743c2186c63b4004c18fef7727bb9d2c9a2d93284e03206ee82423a44ff75b4bf6dc74959c5f408ae39310b1d1e66d10da5bfaff5f57b8fb15ed8c4e179cab831795f0dfb507fcac634ae1b5d50bde62dd0280923f263f36a0e75870c0a99f5a7778b8440caff23e2f30cd72f651898a83ab0271515cfd1ca7f158042652498a92be5e60bbc28258190483731348ca135634305051fd16d2065a6d1bb6c9761fc3cb4b0eb2708223da687b9e8363af805b55604cfc9d7e98dc758edc6efd7579791e973c3c45e98c8cd32943e613665c4395622a808a5f57f46501d54d5b33acfa135448f64c28bf7573cdeea04a48da3f5b41a260e0265bb5cb0b0722f2ebd3a471b5387422135278e5cc52b667f04afc2d386d23575c58178a2915cdd7acad24ea14f6d882b659fa7e97eb4fc436ad399cdf6b44f4e5eaa56bd64ca60727a91ccd2c722e038ae47d63225b8cf0d59b3e44fb1c78c87fee28abc9748af7fb9ded6816d1e2bb875fc20f7f06711dd72c444d8291550b70f24dfa5a7d40c8ba2e38eb8f5a685aa7597f4fbf2e146d3e7cfa6b214b38e314fae1c5c06b43dcbfa0817d5d1fb633f31c8befa7ab33c1c9ea7e511badf4adcc5679708938e517844f4fbdc333967ebf14f7f5f936de72b281a07fc0d08d9e34f764d4e716c60136086597988eb10c884b8855ebbc445b68350cc3e3893c08752ff3a77a6073fc0a4269434db0ad943b351ad48c79b2d5aa40fa8918d4ec5550ff8081cbc8f8771ab4043d85a46b22a85e70aa1f198ea17be895f4fef5273df8df827befe8166cd85a53993c84881211789d73073219ae0c2743fc134957c83d50cdd9795fdf737429eb95a3a31daac8f828df162da903c9aa0523ddd6578e8451bab45440d33eaaebe5a47696cb45dfa883a390559e95f8c79cb3b306570c9aef04a706871178a980b81a1b9a03bf179614ca873ece691c08b717db5ce86207a6ba22da6a91da014d5196be5c9624faac4b0a2c31651002257388cb4e60476c24e26616188e7b55c4b88e1c286cd2584122bc5d5ec9a467bae248898b11ce635e52b995acf3828fc05d7bf839ee8011cee68d6536c096254314e5fe820468ca2b0f2842e1e21b522dc69aae51dbdd5ec9183afdc2a4ec1d26106a2adf34ac8e6153701bbd6c38aa2dc288a6b8dc48355f21f689b60730d17fd426dfaeb9b62222c13ac7087c9af99eb07350cc3265f980b3447e69ed52a5343e1fd2908cffd34172b056b016b503631f8c759304441c00bdb43e0abd2b0a561033702dfd7311d8e211d2da6b5be82c54e4f12b78577ad77f0e974345fdc219abecb7c00490b03b7ac32e33d1d346630ccf9380fe2a090f7235934be7eb35857495dcca337e08ad41f517ea178d6ed35ae44bb86386b8701816ca0a3a485cd9730717777b9729a9a13efd3c237fe62c6013772626bc2ddb87407ecb9de0fa9c16ae8338c956d752c4bae814d6215e49331a8d7f2157872aae102f6d738a4fc8eb4a47f0bc42cfd682a878324d747123df042ca613f887df45a25e4b8e63e2b54a8d7896c243523e6af59c8ecd02ba71dc862ace7bbc4306f088fc7109515b66ad58d9d13da6d3ca6095e98f5340c670a3c8c16d877610e56a2b4a0620bbaeaeb853cd6790e3c6f0e3359f9e588a69f99422d42cca4c23beaa201a47f2bf38be12ea23ff7086d0a7bdc5c88f49c92326e8cc63310381348b32fa84531eb811596c3ddf230c9df530edcb76c04d233c3bc302d5c179da51514f2fc2bc2042860cc999b278c96f32aad83bc473aee65107b3c3b113e9b4e88c7d3e01ceefbc8c4c9d4f2e23714e4df5b9a51a9c5a12ff0b61a5bc0d0e62c59f647d85fe143f52cb77c361f57d2998c097f594fcb0f0d45d9320c4f093fd09854b272625e30da74a9a6d0fe2d870295d0bd47a442258204988781438a05431accb28875eae41013646d3126cb32153385cb2c2bc769fad635f5d4a0f3d9180e398426a04a1b76d74649598ec5c8131793af57620aa1134aed373e191e138d5987919d5e50f210a9251cf7657ce4d4e73354c895c2fdeebc5d5aeed33ace80669a219e5f60ca79474b4437b83228c02b3f83a5b22a620545316b6960d757224093dba73283a3d467d9e40335067c1d1582865275648d3bdbf4a5f72f3f66776cc5670181675c33bd780567e3b58a5269a221c39d99cf4dd87312d5d047ad7e0299b677729bc4951ded543129d02dc083439c0d1a19033944e49ca7e915547da81e77eefeaafe104836a038d0b3ad0a653bb7ff6dff2238f4e75a95814678d76c38d2feee0c30680d45c91afa9b2d30edb1eeff390431a63b9d313834abc6978142b8f37d0d29c0718ff78ef5564f19b94b0dcdf3aca72cf85447efd10cb6e62ffb0dcb1caa7625deaa669c43a3f208dad584ce776f031597b9cf1997742bbd3375eb8056a4ffbe0a14a9a0bb4d9e495ee360cfc73d0b6fb32c02865baaa767212bd7046e201e387944377831907bd994db3649bef124a0ef9cccac909bf618e3cbb484e304554fcbfb09a0150224132d149daab01ac1ee34d48473d6f27abe0fb5ad368850df6b005a0c0cb05691a7575e88d62248a75ae11e9d3b94091b45e59457495f94d5491f589622513f3201f729e89abb8bdcd96d48857554ef3d09dcc444e9ed5c6ff1e75ca1fb2d7d9455aaecce4b16b7fb9630749320c6ea6bc11636ef96186cb0edd1a781625da72639949d4b541a0228696ae6fe2c448c4719ae2ea81208d53fc133fe9a1c9e58fa2abfd68325f4780d930b9c70575620d142ab43bf29e36bf33a6c000fd157559c5b411bbec945fc19f7c8fdd08a2a099e11c600f7690492309171ec473f3ad301f94e35015783735ae14c3e57293827014a4b9788aaab0ad01caf12c1eb31c8223136613b9860b89d89ea1bcdb318f96d882db7d38668eaf51fdd2496ee559b22dee4eec6fcde4a73fbd4eff915a85eb82f308447f34f2e4ce07bc724ade932e2093c7b7975302ac24d32045030b04874c452f39fddf16e22548d259ce55eb84c07525711e99003430c4a266f1dc54298898429a26c45218aa1d747099068e37055d1e5153daebc04f0a24800ff64985ad7e2485d777e5548dbfa84b81402ff70255a0f0f581b3fcf425b0b7a8af3186bdd928eed74455a0f9ffb7c34c98c839225290570cb1db587aa9cd6b32fe703692ad20bf572b314d3377ae04efa637b6f9f5df501842eaf509189d2711c0813a75798e30216e6ae33f9e09bc504985b53cb8f9aae31c47a1a6fb2d6c6e606f0e66db4698a844521b949ec3e2583c809ce01ed8cb16aa583dc8bacab0d27a073092bf44181f494b20990c888e03303f468f8281c101c0384cdf712360fb628684bf506877b1c93eb0c8dca7646e9be414150124566f9fb25989301e80bb11f281c37072e1039dcae04416edbf175ba64a280aea3eda94646e8392483d1aa845009ae83ea4c6f2d91e953d1895bd7eac418f6b41e57091688703649510e34adde94fc0ad794e30174fe5c6399871fd43882b385206a0af379138edf34e1c31ecc4cd9c9339fa00abf56693e611f1325e60707e26f70f2016de4b6c1cf18af67f00e5727e1bee746c71cccd03551961948d5ff8a7cfca366ded23f8cc989c3f2c07b292c8b65437dc257a0d6c0f42fd3bcbfa50c00803b71c07d02800b745c115dc5ef5b238fbd883806dced63567659f1314ec18cd04092a144becf8f0d2036f5368bfdf2f6606f44c7a9df5804f517c22b3bbc647c02522f32ed8d4409f3b29560d864fe4dd64f2ed37d6c6e813eee79d6339c491fd2f041ff2869c281cbba99bbc18a4374061a2aa20d6884ee28ad2269a5ec4ccbe874163855c7098dec34403c681c74bf849fc1eaf032a68ef50d96c5c365d173a23ef85c7c7246c2a51666b7fbf1a122dc1b5635d508466fa4dfee1b4c91cbee051aa6c2956e8ab3acef82ab5a8842a86e4d1412b40005fcb8c0732275a1a7f755b698d962f394ee4a44a9860717ddfe4807c89dac570270e2cd0805403fa31fd0dac7214a16c89bf83c5b4a7ad53d700afcea3369cba0c0bd90741041add1ce4c4dbc8dad7d5624efc0f702d2c75793f677c26134ee39147b3a2eaf34d4ffe22a6a105e0a390d533e261632d6f7d03b71713a73b553b8a23bea4447fedea74d83d9d2d586c97823a917ae7a7622fcf121063d60ece6394e628a0263f30de43ada2ddb6b2e3130fc28034d71cbb22110685452d7d21f0f987728c267cfb92455ff297fb3fec5ed19a51ba57ef6e19052a4cff5443f01e5de5cf27abb908851c3b6771f448ea71d209060c85287d43053ef832e74e9241fe6bdd74dd1aa33e0f189d60299cdae332e0357a611fc25d4bfba57b380531d2faf56224a014fd6fef3aefd8259ba6b50448e13c7c756750ed73e9b0a82e657b268c180bf5ca79e8d44c735b2f31c0a660e1e6bda2ba9cd61ced547d8ff4bc3823ae8efb89caeb850eefbe7d162ab50e87f3580a0af24d83fe317985be6ae12ce0b9e3eba2cecd965da0949514e310b89cc47a2b9c0430209883a137125a865e54fd854e94c9a6f44425a598364bf7418364a174f75c2aae047e93fff9d712b1a62c1bfdd7dda8a862f7ffe0deb89066e93b70cf9d9efe1802ec84b2d68e2054f671a52997af6e46d83e875f8709c1c5879c6569fc56a3bb0df68bcbd3b8a38ce9a4863f2acd6ade8a762053371299ad480cd4d603e91b1d76fb6f8b81b76cde6ae9267dc09153e0a3ac3d970dd3b5d3c190bc38362fc37b3648ec74d3997e8c92be0ee7d378ce35aafcbf99db20c0b761705a625e9e5c5557d6089043611b863f025eef88235cb90adbd3fc9cd800e8cee70e706a004398619db397e9ad802250e39b5116f12bd9d00b7bbf50146075e7bc4102e3936edca6d37bfc707de409222fccfaae787122d74bae1463331a91e88b0fbdf01686e9b7ab6f4601499ecc19d6a2a61c0174f4238cebe7a9b53e998cda18e80707fde39162a66f0c80d295d522f292432c9d58d87d0c65b337ead324ec485e21a374549e03c0f4b171bb7a4407c7aaaea51bcf1e4c4d2d40948585f881b1dd5138eae68332626d43d28744bc4f9e9a677914b2329af07b47a7d378f0e19cbd5e7634d97accd41aea23ec5c5cf45fbb370df310e5c2b101c9d148b942a70c2d2a77e65fb52ea766225f00b3bef2f8da5fbd730addd1b4a27c59c436cecf5f423e73e6c204b0ac1e47efe59e3d5b9d28df36943a0c428b6cca444b40379063d6efe31249cd56c4a5790055ddb4f6988b72e5ba8515bffd3db0d7d55b358b62c9d2d74fe229d1afb171605863ac11ba5ec9f22d6ef72972fbca004a30484d5a1f8e17ab8ce22cf4ac7b7979ea86baecf592a6307f5460e45857c07f0af0846bc46fa0f777f7e2c6678cdd31a7abfbae05ff72a705f810a5521962515ddb2f0db47096ea928286c0bd6a8390aeedeec0f920b20b1e0863e49e10f48ef546f9ce38528636b6557b5b5323becc8cd176268e7c2185968bf710221679568d7d2441f4f2cf3c82b395f938a395b8552dcd83ae2c1f1a85a373fc5409506d4903ce154f23d9afc8d74c94878c9ec46e149f8b78b88cc88ad82ea87286f9f3dff5a201a6f64fe2ab6ce4b8ab5ad50f5f974cb84d0e600e02e1e4bf87304438102e25c9f14e315f862930ca0fa5ce8a24a542db854ce5e78caae0b3deeba508b68f832bfb3506e5922735be2b06e811ead7f46bb1241e0cb091399107a8c9b51751ed67ad55c0679a7353eb7f5ded8bf3972a8e6f891072a77441ec784b91f3965d049540d9e95317de554fdccdc809aa41604fe66d5231877f0befd47101cdfeba573ed8178c9dc5f9cb25a32152570004e2ba4e17895b96fd0375540b6d6e86a52cfa4fc06314e68e6b4c5ade0001066c3c751c7536b076aa83132af7bb815892c4dc2691565478c50732db0a2355b5f4e4cd58bd99ba25166b3d2db7251c2bfaa52a336aad3b28314e50cd1d30bff88d200157e483aa301faab05834279ccb6813ef747eb78819aca987420cbf0099b8a27123087678ce9034dad0c1c049f6db39bfd8b44c12ef9f43bf9d8a5162d10cb3835ba459aeb39d8333601ab971587b9155548f58964865505f3f7548e69c483e6bf57d0969effeb65091dd4acc2d32dc3a7df1d845a1a8e6a8e0dde27dc6bed6c70e8bb42e57066d9a2a854f93c155d50f7b82d00c8b8d8977241aaf60923145140d9312725f52d69f9c247dcfa9c864e33ae66486fd94fc5361ebb4f6097cbda87f5565baf0fb170a7d5eba577f1e34ce0f0d83fcf85ada4a91e9989f5ae4de4a09301ddfe0d1d97842d8e7c8f6bfccaf369e5ff6a5420eb48a938891a5f207f7ea6216126dcbdcabf3328baaaf78167dda306d117da08fdddd0d322d2b7f4ff98308e904e9421539f5d0e9e30aa80895bde39b4b557305568b452e5d85bd52c3f0b6fab140a398eb52a8feff0bfc2eccee22792285c4398e4fb6f74679ed2d6d4ac7fa7163a6fa61f75870c58e2509d902623f9e2c543d003ca38b67ce87ade18cd6ab80345413a4d720b76e2890a0e41a96a843d204002594e939a7582e9f2d1c70347a84cf5b7d285c33313b20de00b422614042ce9cf","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
