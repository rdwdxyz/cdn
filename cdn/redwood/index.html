<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"845e826dacef6d4ac0df74de94c8b233f8e7a6f60056a4999ed94bf8a66e0aade37ff74191620321bc013f34538aa86e33f50d1ad9f2330653248a38663beabf3144952dcfec532e022d7b0b97affe2baefee2f99ff2475c255ee41cbff8a04438e8092e03264ff675aa79d74763ac38499c14195cfa2aa402d1d6ce5e5e96ada247f09f31c9aae13f59de4566f3b48cc7540faf4c0476af7c176513bda720f5ab408ff5a22bacb528d1256e0d5a659f96c1ab0e97beb69071e92c52577f105c14372271b0e06153eaec04ec29b43297be68d865f71abd41409b47f0f804d476df4132559ad807ca93a9ef0aee1be4c9a4fe6102f6d71be940c05799446a79eec844e8ee1ae366d04ff92928a45d7911cabe56f0cca4f01b6d46cf1ec9b9bfb2786f751ea513f9f0377504b7df486a80aa8db61cdce2f928e3c15dcb14a61b0836238f0a46302ece06ac7708797291bb912c7877020250056d2e972f76acdf3084d14dfe5b663c2a01731ddb2c19c91441a16f10c21b91e67666a27701a97cd3ec110efcb6bdf46f2222dd08fa2a9799d5faff207342642e53ecdbbf5f41ade5cd7c8a7d5b9bc2102bf7f976171b02f7ac37a9b9a564b2218b2efac9fbfc09d77a4c0811378d61a4e89944e4d79641026e98f29c6fa06335fa671f8d83fae6f3e2e27486bf9f919e2c8b191386f24d23f0d13d8b08ae7c82ad5a5503555b921bb804500e422841d0cb910645b61229dbc8045de0480bcd416b6d641393fed466b738f88420bebdc09b24d9609e500651cd53058f0a9561a4fcbc892c4a049bf576575501ff35cfbcbbef45cb54c0cd095c59f048b64e69602d76f19adbe0991258a9103c40b219a410309a3146ff55d8f0c1d8db05aa8197390c40b7ddac70d83788778a15177a3ffc27eda16611817c51ae91d14ac4ce236ba5c77d126371f00170daa96de40ac043f3768799448b12ebc54858fa322bbe83010e37453057b0c8c5c0c1991fc66ad9bea5c662f656f1bf9dfce9cfd720eed9d311321d02f7b6a79063114a52844d2b41928ca283d13f39ff2baebae362cc849a7db28ab531f156ef90abd0fddaad9ae103e6924898057388934a1774c4cb7cae1a30d60d0005ea6f5a82e9ea1a7b968c55a2e95c5b8f0f03d2fabc9841864db08ad269f34af514f57d8db4c172cc4b9c0b4bcf4de5053d1444a62c41ec9dc2689654b1a5a453e0343ff87a711ec95598e7767f4fe9272ac522d383595abef34139d40488e16e85449634e0a20de76eda0150a8e05f7bee6994ada502188127caaffcb56cc6606636eed81ef8775e07ae8fe8471a7b024f72ff46e55faab9665dd5b87861f17ba4ab4c3734affe57d49f6e0da8a666180a862507bfa4d270b87ae8cb3535a34777302749af5a19583ae8dc278b3ac0cea08c6e202f12318c5ca1ad16044fd93f01729bbdfe3e918cbe6f906cc7439aa03b32fc3bfc77ae40fbc8a481fdf7f0db9ea258ca5aa039c092c2169161afe04f2123564e80b7a77d72d6535402a2e53ff49dcd4fdffff6ea1cf5cc4b8f787bb8b2457864c12fa8ab82ab05b1a670cfcbecb7213b61443ba780a5fa076662b0aabe5c10ac596ff8799d209cb26f9126045b8e5d0e8bc745a5b423fa244260b3041f0aad50279ee47290def3e1e0d6bb3fcff004d32000a4a11076dbfe24afa8c6aa068aca4c0c5d20d8a3e599210b2870a6f524a020b98580efcda76710c601c70061b30bb2ee083e28c516f3d04db391efaa799956c82bc332b42b7547ab0f19bd84d70e5e09e5601b4e725c8b2560ee7fcd37f14bee33afa344e8e15a114ea34a253a0d916b37bfd8b46cf59dd946beef569b8c7ecf9f7fcf1c149098beaba9ea67498550ffd95704259706a74686da38164ef41395f0742266ee3cc2bf3d10e7769ee3c18a6ac9821ed7b4d9a209f898a41d04e93970bed7414859fb9f02fef6405b5ba6fd10c9c0634f00fbd8d5dcf35460972fd05ca1b4947b823b3c8e7373547639952924624852cd58b96c907b53b157e5aac595f1ff5db7788118c0c7446955d4ab44c1662c694e9556460c4f1654f6321ac4b5d1d74867c0eb705f0b7a950d106825712f9c32051b56428dc080281b16f8efd12ad46fe6a0ec06977a9125bc8e0fb1db27e2708cbea4600f6a6aae671c40ce92d8bae07e5f370aeb37046ba731ab4a69604a0e1edf657842bdd094f5c02d924b39fb8de294cb8b4c572d27ba6ba1a0b2e0931092bf5fbb28d57fc18f7f87277b2a93c06e81daf111d94271d0a424d15a0e20ad5e78cba60cb15a9104e5bc1c5cb23e3fb6882f087d7e8eff8d8ccb66206e437ffa52cb9d53c4f1c03b127b082120af1019fa36c32a1679c7b5af890a3f5094eeded541da7aba4634968b18074179730243ae07be03a1bae65acce41649ebd9422318b2d87a92e2f39f8dea733d38083e62e850a3c2eeecb07fc4366e914858ec5521cc0a8ff3f527048a54786a3aad29dc730a7a8d04400ca10bd1c2df0843a8d21fdcaae6a5ed401ecea8e9d188777f7960a83cabd3ef37dd74eff72b80e26f483065889624600503f3f395ca6a514275a6eb6d4ad00fa73219da75fa8b3039586f865cef4b2ea08229f74370499eeaa10959717dfb23146549146311386f706ebecb8f624e0abfa0906cf7a5463380b0ae21539735d31497afb3402000d80bb35cd8c934cdd6578bff8d367106779f3acf54374beaf81bb90e9a3681ac656f7210596944e0d1ba6a3cd890a5b81467ec7782a67dcdc54aad2ab51f2e0d8e4b01e8e2c8b25cbdfc9de3e97644521f8457ecdb5393e09eeb93822bf8470155f440d9cc35262a77ad262ac11acc12b8362879c49ece821a7c7e69c0039838dfbf2b1f328cf3788ecf04b4877668dee3d69994c11b89110a994748b5816c8fd41a94ab55c136b94b9b70c271ce520d6ad3183a5221a41625324818b8b0bb0a1bd364b33fbb6d73b363286b45dd1da8b010de20f4dbccb10dc5fe61de24dd9ac30e2bad42fc0e6547265bbeddf5827ced862d0500b0783134f8d9da41a132be088f4f4f461477077567205de5e3e2931b259fab491309c4703651a6bd9d32091f7e5fc11274f15fa4110bce004fe07b75d85a1100b20a67d81f61e58af2089f421218e119e472a56d50b92c612872c36540e0dc0ef6e515767ee50d325105ed515df5c72fbd6f319026ceaff653e9fb81e513a4bc29fe1c1ade416aee281b59bfca39f17642c3782c891e60712c2fe1518738a3195b04edda513c3fac9fca70436238c92a5583ecb3a0fb27ca5cc75d035a2d366b4371a106d5568a944edef263884adb2c0b39ffe0cfcdf4e72ce781c9708443d730a56a7947700778fc07ec1361dbb6b16d7a28492076d20d778adc57bd943adeb5040ee8ce350820dc5c44249633e54a7fb68869d0ff9ea6076491d64cfeb4c2454ead2d0ab9c15637e924064542b4e1e023cd04a87e470080358ecfca47afa1de3308afc101e3abf5e5f75b27532c3bc814e98fdf7718d925eca88ceff68de605a2af6edbd4d4a9e505d40de71c4a5fed18069ed65cf0d571e515238d7df244cc621ef7d0628db2e9f7df9a8878ec5d3e1b01a45f7ace803fadc91f619985fa902dcb50d4ea7fc88d3e56d9d85fcebdccbeafcd381d9302cf462d5ff12afb7e65384e3cb908781807a840a7e4142ad7fe71cb72a2670938c54265caaf6e622107db861280645cb9ca023b4495943f064b6a1bd8f6acc9826529883db7b688917377a76792a30c858e8ab35c1190678e920c8a1973c0eccb18c38de85048040442c434f6e1c39150ff236d30d9b34b497970c49e270403712cdae4748e9ef24c94f9635c2f4fb7c418cda415267139d3994310767243312d06f82ea17102f43d2ed0ed182f6ba153f61b15e938fa37d5e7c36f525dcac03281784c287b7f23deb2f6f99b699320e2a71b3ee09c0fb3cb61b12cd7fdcd838436c7cc1648d091a6b871b7808705446d5a12c37c79cca88bc98fc2023eda98db18da24aba7c8a5a2a523d60b82dbc411ff3879227335f6949ebcba8e410d655a0e9f8a1e187153d1ae6584520223ea51f5590908dcc08af0ae6e83ee2fa1583fdb2b2fb9e1ca1a3f489ff20b5e3b62fcd9b376d3d968e834e129bd01c3c3b3f6109c1c44b78a674df3fdaacb3f6316788c980e45811cdd807c06d68ff34bc72b50e9e6be06a44ef67c7d85dfd2d214cf45d6ec0174548dc0c454f1a88f69d1739abf32ca02c011bac9f2f27f3deb03cb382dad65ed5d6729f7d622abd6737479e7fe1b7afd0610de82343b4a7c4ff7095e242289b2ed7013a1de34c1bfcc6fe62f8b436301ae6ff34c9ed243214826c297b4271c9a4efb45b590b034d144ca4d7e8cdeb7f88500ab4b300a702a77b6da55d1cb0671802daf451a3cdfc05afe1118514b047c7bb4533514ed6992f887d3bcec86b5be77ada353c4a7dcbe1a3ed7154a901350072b2a358cf179ec4ab81a3618ccb06706972b52a53df3a7bef755fff895413732f35c8dadb688fa740a861aa9dcd5fd53cae32a4d21573f62c4deaffc6d3c0cc5502fb2f39d36f13daef144acf6172b28237de56593ad916550c59ab771a3f4c4183f74b77146bf1f8c8cf78b22122df2c71019a5bf0ccd7850cbbaf8ebe5bc8483f577dcd5b06aa5343f219125039c1f308686899e56fc88b2ffcc684d794d8f5566940ea8b35a684f3619182cffbd1584e6e5380f82a79f86084ad2f3ce3fe6edceb62e1d5b669a571f022c227377d8def8689d51f18f2b81b0c77f61d9c392f557618b6953037fb671f56acad35eff8ec219c2c920851b63169c4e0eae70067a9671e87527eb6e018ed77cbf6c6a4e7825d264d5ec9e0af068d53095cf3f0182bc064714a242ab69c8f5cc394682fadbb4c780ae482ee3cc64b06410967e507ddf59661d4783c1c564ce13946858cb4ae5e6b050f067a6bffa9757072202cc28df876cc16db81abec97954b5b4b7667997089465f90f65d95d1053c9686e6044614c4b007909c72be8a605b11cf7a7f57282515b83d8dc0ada3dc4b014bb3624ac37c06939db675f6a28dcff4845cb311b08948c2b4416299291cf6696ebf9f0e00fba03d6b19c31971c1102615fbd88fc60bbba27033b0149e6a2315a15800cc9008121db73656422a9e11a6a4442308f2aabd21e3be2c055bc060c3d29fb6be85495f64907accd6137782155365d045b2761e8ab938f4d42a2505129ba7c8036c3bdc0f5daae3aa6ebe4be49c5bcb4f3818d95217c976178e27ff68dfd513cf062381e1f95388e6ac1d067cb94ad48cfd981818826c204f2d2ae2740a41750f10f1509309913d8ec5f94e79a0dea4a4db23d89f27a8745fa4fb2b01fb5c58d36ef02c5637039bf11cec1cbb17e47484bb31f8b31c4e3ea0fe5096b039f1ce5f0fca7ae199fdae3f9a54dfbb5e8b6bd638ce5f3e29cfe23b37bc66bb1826016387a1fcb897cd6981c5a66e8e0aba66cbff2bed40114343fcf15b9f397366f1a010dafc41aa53f98173ab64f9acb2ff0be5b2fb37b2feecf99722e4017f57a94aa543bbca93696d96d3d45b887c695692a974b6210ad577f131fb3998c5cea5979da9e2255b53be0581f81e1dd701ffee9dbd9fd368b260f75c013fb5988aac264623b2581e202422175a353758aadfab8591d2b02115f4c440e8cef284939c0477c65d0b3ab57f8806024c02644a307d7377b905058bf9f37f924126a85320647a5bf67d4a6265b792bd3666bc6230f7a7d90f7bd6cca3319aa1deb5f4d2be1d560d3a01e325b2d36a37067e9d01e790368ffb3bd2ca166b5a1959e52cbccdd0b240c86997ce6b19fb24758e8089dbb72a072f32adb202fc983dbe97a5a087c54f017966598a03cb6521a74c10015d30d09a23dc92930ce66e08e034f5ea2ac560738d09d7b1995b4174790a59d496b26d3ae1e0757cae6cadb5c225824e8cdd77be8b9e11d8173a43083a5ef9128b1a312780fc9997e0dbe38717b734c861b4b0265a4f8f65c2b0d89b4293defc21ca060638ec49fd5c9ec2274f28cc94884a4980d0a1c80355a040d8e554848e151ad767d2e54f9d7d8e2a71fb92bd35959a6f5bf5eae620b21fb6e7edcb26856143e0d1434472ccc74ee46d885d634458d32d7922cb156bea327ecddd6dd992adeb907479ae329019317da57c42254a8f6c5d3445a3408d6ff45801b074f9fd233aad021a9df9294ff765efd2fb6193037d3db69becb149b57df0df091d82efcea5a53e468dcfdf444bfbad70b5cfdea1d5d46c8db4ff5257d3a7942ce731d9c2b77cc6d42e66314c88a550162aae6bf07158500bc905beb4fac806838a3d2f0df448fe687a797508a40978bd527e5c294db7793263f00a4e90f53de0fa262b7cbdcf0a406052455795879666b7c147af0337a7f96d06731a80a50dc06fecffe15ba00e454efecf78cf80a62336038b47adb7ef0f1aefc4785adcd0ba0d146cc7a3816fa0546df1c4c3c645c1516370f56d31613775b6b15552c0972595dbb2006d72bbe46584f5c3c21ad0f9fc1e6cf27af605cf6b228d937d0adbb939d2b2ca741d8e595cebc7ae638a681ccd0be8630cf23829bba2815fa99279f43e2624c9fc6940362ea5a604727d649b43b904fa56226c00848af0a5571f48ff0185ec2f76864f7503f36913e4c7d71fc21c68be69d74a027b9142669dc64a0bb7fe7613641f95addcf46ebabf99918f5831b04afb6fe1a033013e16bb20425a0349b9b3c91b3614b590bf27903cce2144198f4ffc120913af2c92f8b42e662266b2eeb44a0cc63bc0ce5e3620d314c68a00520eac549d0eb01a97797c679b6a9cb2bc76748ce9a3245c3d0049f332b73aa034a5b67f2eed840a8f7f35fef2a1e6a9008a49170a66626ab4fa8bf6fabe88519d4c2a0a81216cb49791330f19c79f967b5c5ecf467d8a241a0658561069c84f91a9aa709ef054b7d5eb2c79ef6eacd021aef4aac12a1b3951d7e5a8bf753d5eb5751b65ae7484b77c89a2481e14859d04f1f04438107c9df26f4079819e3c9b1817df348171401ce2431fb905fdf63fa06efa692c8d5e3bb6e6fd409af0160e2cff5b797a9582d78e2f05b88f1296d400919ca9399cdc0f2e7ec380711145fc0d0fe4f73a6aa75303c59d99e33779a8e2eed4533c294181900e044d066234246363e8d07f57a02bc791655518aba423836ea63f2b040f0832225887251eb5a4884bbf98d05095a08da193f131d2d307a4ee44426bc25e0a319ea494124a8f435dcdc601d7ee4c4876c8248b7922130f096c104584ffa23072ee918982ab0cebd829fabd1141e355cf0db42e039e39d1a7f998ad3f67190b3c2eb0eea2344498dd507c844ae924a3bfffaf86eb1be518d2f8a8fc407b785f1aea9314ea3873f0e8c84fd2dc9fe70312b018aa2afe52474598a0bb50705c7543a8e4d9236e124cd13ad910fa1a667631121514f8656902a5f973f525001e98639e18b52fabe1e9a75d362cc2d5a41a9ff17d8cac0e3dc7711a6912d6a450fcab5d0566d98b6573885964bfc93cb25dea29a6c46856c1f6bf5f83025b8ca8861ac645c6d97498009e221c45d971425d6db7e796fd1f0a82eb236e4bf45dfa8510d108570891493a9596d451b0e402ce7535043cecfa1229ccdc6cfffd278bfa83e3355a1cfa166a48bfbab1df569889d3586468076b991ae98e32acf9c1c3f80ad87699e4e349b26b15c9b20167064896c01f3d02aea6e2583d73f4536830a2864ca75fd81ac211175f353a2c041f9e15902f0b557daf34950084465ca44e592387b6784b535dbef64c50d1d24c6fe2e8fda3beb8b078a09831298ae427095b086062ed4faca9cd5439221c72b085d80c33a5174e2c2aba5fd1c6951672b95d4ce882b0c9e1b67a2e3e48a66ae46226b38647a76a58a29b9a157873818cf2c262904fc169dbadd14843b3a3c7edd49783ff4fabaff4ebca321307c19ce419bfa5218c6c212e91e8d601c4ea12729ebde8008caa6c7627027dcc57a39dff07d59575a664c8bde72d6ef915595a87cc499df5faf5373aa56dd3d7f11ade43ff0a60e7d4af458538d4516ea069e22127a30684c5705b93ee44679c8f63ce560cb1f88cc78c7dd0a191feb620de1d387226097c02406f6a1fadbb6d85e722564ae0de68be470e14d7ab200f938f8c20e0ee2217fd5500c371bd9c288f8f2d9f17deff02c43eaa4d24bc02ee9b56b88f0fcc01c2f1a1e1c3f4af12973d001ec15ce6a5bd81fcfb82bac9b4d1978c61b9291183e57615013dfd62ed44d53d6cf44619801cda9f917e772640628d59f1b9ee2ddff883b244f7f1ad8d1a1134d4c1503347dde52921535332a502c5a0ea67f1008f727f51b036aec23d2273a1c44268521e9af236c72553659733ff1a519f911fd70496532239b16e082c11072efbd36738230c0e5b725c88c4f304d6541fb7d880ff9b2bcd96c224dc65a3a37c00e817d3e070ee2849963706c66048fdbbcee102b743b501ae733f1b21fa595b33e1f05e655a1512bf0c46aedd55e89986fbf887990f99b854c90549314fc7ff0d7152287dd8735c1341016e958b0d9b0e8715f7ae6599f027b6d69357d6ce6b684198704131a540ae346b2e3b29ce66917a53b76a86bdb3a1afda34141e63672041445777b188d3bd12869ff8e5d4615dfc937c6233bfae004e95727aa4cb98cb87ea58dfc599e779437035b43657ee77e71bc911fb42265a6e6af5b01c8183ee138df3be834a621b8c82d288587e2f6ea70f1650d2db073ce9c027bc5d8e222ad04bc688a432e826eee62a46420d5bb4b2c3ab565a4a134fc0ebb92872489901dde5b362833a6c950eacca6565ea762ad92d03390f057ad5a7538a762185b69964bdef020a1c16da62f1876d3e4b279a44ffa5b20b8b272e8fc0cc6f9299bad04ed2d8615ce3fb45eb304c92c653a0bf00302514c5b0bf598bd3cd1487f587a4c01bb04073db2c5411e22ee402f1c754402eb0800b1d5d4ddc3119f58f4e649953d180b07f1f5a780e5e277245b79e0f6fad376545c9e3fac40ce082a7f31536cd3709050e62ebaf5937064461e53759645ad3973cd83c532b88a848be6a0f97428486a726c801d7187d4f4d2122dafcb099b8f8728843f86fdd2fe290949020023c47afe4603e2aeda8390330fe521581c7abb4369e726d9c30bc8367b5f49f43d225e9311e276d620c767c1b844a2f0dc05d0755cedac5982e267ecbdb87cb7062e9c3c975cbbd1a1765ef8b6a429a8d80ed4a821e79c321c743f61885dcee2e3abb1b6b7dcec67d5dfecbfdaf67900618313a4db70f0c525d86064485238ac7350223d31fc774c3250ce6ba6f560d8b50a7dc1f61379f7c1dce15f4c0272df04f6d244973b8e2e14a08bddc1b20b11805cefa6933965b97327cb6f67880744d65c445212e0b2c856700ec7d46c6eb5e1cc865dc0b0aa460da458501b495177b051a52b1848272f14b4a044aa436125fd70550623b1055486dcad7cca6aaa246a150e4963bcb9053b9a3cfeba32c410cbd93913ecdff14c3acd5cef5df8dc33686e664c0c63807480063635ca13d682089636064bd4192018882d78ae90d8c56f36f47b8d866e70187df95c88df83b49b5f901fdaad80166588cfd431b84b1809d04cc4b7f7be3b6ecbed5cb75a036cd5a423ebb077543f72a5f9b2948a161496f92bca041aa088ee4160b8ae78db734e6cb0dc21335d1f1865eed3b9c36e95e255de05625fdc911a0c98a71a454ac8b4600d06f42d6a99715bdc9077d110c52b1aceb7719ab279059a460d1837f52f950eb3b702d55aef4118dfc9d4067d0d284fe007ebbf0b10b38514fd39ff68c2ac1c6846609047722009d2598e55dd5f3d5eee70e4c9fe37ba3a85a77aca8630dbf8048eee72e77231940da961b934363131d23ec0be6e1edb812c48dd25941ea67daa0b9d959b1a9db74efa01fbce694cfbb3ba1b3bd3e8c361f78784270dd48a7defe209139b7f480a556f55c627083e7b036579cd9148d9b3683a2f035036c5fc0d71a6ece5903fbafa1e34c1cc28adbd98dfdf9d17119a543547e44a8aa3ae2d08bd87c95faf581b91dca131fd14deaf359d6e4c504c3598ea3e9aa39f293b730e91b7c50f5bdd2474db4aa8806c8634efa0ec973b65f1d54df9f49366a40d210822265cb4e31bf40fd7f6dc517a25351049fc442a619d60ca0aaa58069f5e664036d6a757bd13b9281cf2a23f5be9426a4665581d0bc9530c5dae51b492c80cc2baa177aab44169bc43dcf7ada9c87d999a35f1d5dce57058eb0320fdeb7336ed09136ba4eaf59d2d096d0df07b11682ac72f48ae65783c77163489c8519a6f2d25682a44dfbc90b30603c1fba1022d68a9d8537ae6a4b0305e7d73473c65cfa6947eccfcebd1f9ee3c63923a0bcb3b1b54eaa23d8ff9f29c2128ddb96cc7c6f030df31d0e707d3324df884af9f3c293b2ca2d409540f0cab34e5465a133a345f64aea043a4b441aa70a5f4e2d9a478f5d38ec98a86d2db67010193abc90cfbe790f980d89729ce684408376bc6b8775fd7e6a388185aa60cd6df2c4b14392c95d05fd7de91d9dbbb11741101f652c60fa273290c3b7833d6ab4314925c539bb5c2921ad63a9a629e7c9f032add40b445baa336b4d25a4085e83e1db66f8f8a4cd9dc4b0c5fa591dc05f2bad328799dc17d03c85ac8bb120618ae0e1a37a165b09cf3a082fe84e356fbf8c065ce4f30e4a383d79a5997fac6adbe78255f4af533c82be9be18cbb98fec8a5ebf0d4dcafd18bf043bdd7294e3cbf514278f45e24fde05a12424bb3f4fb066059d0b707360374aa96bb76115638f140d833b6a695dc3a1379319f0c053aa54beabf9a87d3583e1955f03218d999e3613d0d0fc2a9b6c2744d968497f9b64002c272925e4a76f39bfae7fd194b339dcb35e519adb9bb83467b395af5268df5c77aef69b623c27d17c8911975dda272c99bd62da5d7cf07f677604728d040b3f92f7f683be6efddd12ba8d4bd38d17c707de03ff3f0aaf08ce71157979314448e72d90d1b9350c7b12c5f9ac7e1b7618efd61bb1d1266e3b0e997bfc3c7530bc1c961e13488b07eac5062d8a392753359895145100b564984a0c3c4d6fac0ca27a18197fc4529b8d6dd39b7203f2786c79145265b85f895305b17a1d8bcdfa358cef74432638d6892aa1a443573b5dfaae9561f29af25657b8302ce8e8b388c095a7b5bd4b69fc78e45ee2e2444be1801dfd737e62b9c5ab367af788ad7e5dbe6ccc591ea5800753413384f06abbb1e1e34ff154341d7c82e11877671d04545792c21b2f1e053f45e03ff8f92cde99668bee826c8480e96027c1b987ba375510c358b9b40a88ec475107a974c4524575735fa3c424b1a130af322c82506e30f00fb91081720333a5dcc086276a94081c0dbfef08fff89b08b77de7fa0bd58716f52d4fb65cb82b6ad0204feeb65aabcfffa377e0a9d8d415691016b89989ca2f9618e7be63ecd1f496f2713166b5cc15c0632c1994a26c3ca0f65aa836d86920b4a9a804cedc462137a6a9914e9c854e6caf01648d229d75a30305d0b3700aa2c0467f358c6ae530342e3039ed0d70c56579c4f7dade0bd867d47a44d918e84053f7ebf841899448f19140c5ff1a4de1a2ef4d8df636c373a6d78ff45611dc4656f16ae575464539342c76353b0f286046e4c36de48e44baf57c83189fdf8520cda53dba31655ae4f1ac1b5eae9f2e663a458d81b013d4833b27b0645b6a87eb401c8c8bf0953f0e2d131ba5a0fbee820ed52d6e7e9305cc39445f5b16ecce61814159420d3e20af9e7f0fa9397e406db17c07fa554832c9fecdea0a9c91b9273f6a79b1f7084a3022b9976577a08736f0b8b60692ca28b5f11acc7552e9000491feaf1b313426d03e20bcce8f3427356686a8c18207ef7c087fddaae780684d23d795c0ffe4985359c8bead3bfbab7dcba3b5efb5d8c8b4b1b93ab896cf77689c2f124587c0c8629b84d00261f7504231cec16095ffa4d421b7895bed1d78b3c10f777018803d4937290b052c06e48f4051733c6bbf2ea01d37e19c636f9ddc5ab57f903c68a99ee86831194a24501dad1c9f02f83765ca076291f487991f6f253523aaaec2403830e4df9d3448c15218eab5482d192fb58fa7881531b2d25f92ade5c45d7d426587c7c3ecd89bb99b81e7ccb42d8b18bf4e2da4f42d6561f61bf0afbb46ec5a2f73f226b65e05c2851387d6723567bb7e91db5e1eca34808391bda4ddc39d706af3588c585381c2096adb136b44922caa2e62cad7db74dd770353218fe1d2914bd730689b84f13a4bf3e6d451940cfe4e74c569f2b9e1dc7f5792421b79c128f2b05ba446cbbf3b93323c485e0f320d6494ac977bd0454e76cdf1115451a8475720bf61d7771035c10e983baaf09ecfbb8975adb8d1d151d8a3be175a5b524579eb0c7a13d96cbdf0074ed0942871a46ac13a9606bda1fd8a4cdb38c1f43ff665497c0c9b9f660beafc5790f19cc2c5d2c3e89856cd39a5f35454518b6a3ab0d76f7408504e24bae3cc7fab778404670d7db4401ccb97cd2294e42419dffd62375eb801fba34a56579393689f9d9a22ad43073eb9101aab433d2128de748c933f75cdb41c05865136c55b651481f6f427d8731327cdf68c1b0e74af647f3eef750343d2f3a838cf4a543845e2ab8a589e44369afaf8f9f5bad570b06de370319cf41ca0896b38efda6dc19f3a5066d2aff5f7a103f5d969258d3f02e8a3ba18208addc39ca6cde5b00290f698830c4ff464ec3e6d52b25c0bef6ef20f73ac3b29a56c77880e8934534c81c4001662dc1ab4a8c95cbbe3d5787c540ee239746a8d9ab9fbb1ef668b10f4c6e90aff9b025ef1847f8df860de68ebc7cddcd8bac035765a50c5fdcdae22508ce77d7b2e6cbac520577773729a92cb3cdfae49f5387bd2975becf68f8f5d4d82c8c38cc213b7a479c57bcb66dced7f144759e140d2eb1de6a6d449c86b3fe8f236342910ed0230b40194e2f4a565aca85c9b762a93ca48cd890006639ab2fdbc9082c6d0e40a27617b666c0bda65cb7b1f58048556c75b1fee417b836e3e27218c69d34e43ba12aa6ac6c89094fbb9f81633a0a32e4c44fda60f8ec3ab497789e95b64b95266c840eae292d3b59a74debdd78946ed4e44128ba48600110072450347422f2d82e79b872a733d907ab2dcd4b213b01e486ec4258d02260521a22a72c579fb1c5638f9c093781953784014ccb6d7d25274962fb7a86566d1a2e2f128e712f4237c03aafb4fc59f9d0d5890881657ca537db261a72f59c4572accb6b70df05a0001966a96362b1b7458a65a3b8e746531621a5440848162df0feb798ee34da8f9e58d84ff5bc04de41664b815263728802bb5915fdff4caf4f8c49254bfbe179bac6155d99c5c68fed13bb31d98e6bda6289245fce57d09d7f6485ef64b751639d58d5883ebca3f88466ce27f39ab0ba4f3dc41af414b1099e803ccab217680ac5094dac16f7969e5c4e4bc8ec6c6cdba6dfcb1cbc8459b975ff2695c37b87b6b8713d9b4a422b660f3fdb8213abefde81e2a58c35fb91ab373c80ed2bfdda445bf16a6f2ccdccc140bf4cda1506afd4c5b4057b0775d82283b4046fdc72aef117176db7ba99e3f2c02302df9f2d3508ab32cf6c9b6aa61a0c88344b2444eb1d9163efa71d8e8dfa66eb04d351b168a53c065a7c8df331df3abcf732ae64d72a80e6037b0c82debb6b14baac2aaf79bd0eb6b9c2ec357c9e0b48399bd7d167019fd55b9c74c804fa52429259d9160d5de64889f20bb8576479cd770305650a5a2d25e86e35fd95b94056fd30e2e59a268b217ae737144a67a0dbdef3ef431877c51c6e7a93c67c3fe342d90ebf7cc0f45ebcc89fb0332eeec720a15e9724932d12a85f617d96cd9125508cfe312c0e3f81a343f954948a5441f705e927cde42e3d80c0b510e09ffabdab0a5ff5643b1c65b5349bbea0f5e31d093c27f72d37b39fddfd5225876801ec5199406d845724b09962859f7273f75a7b14438cd6e4aa508a99c6249b6459490d5a3d4f7884dcc3f018cc7603e3002e0fdee3eb16807796d54a7e1823fa9192341a3a895eda0f654ce5040e07acc85c8f49475047e897bec616f19623addfa78a9c8bcf17f0657aa63463a980a356a8c22cd7848298d4cd36f2eecf11770f955453fa0c8dcea7ab0dbeaf6ed18a415b06568c9ad476614c328c7cf1bba23bfa1ba44237980773dca6bcf0567c4004f078157dd58d94cae0b19e825be865c6a226713d9f95bb57f6940960231d6d59cb454b2194fbafe89578925d83a1ef6cbdb243fe562010e9806f43d82d8403f1cd0da9b2775b43d563e067e316e2a0ed1b3f2e42f16e9710759d32e773876a88c6665c02d1f3291c5e2840c614e0ba69e50963d052061e68c15f7fcdd07ab008390b390945659fce7f62d4860a45ee217e8f4e124c802f28b8397b9eab627ddd36f623d59b73c35f5d0bf830caf64df55b9dafbb9bd3db75d69ce8e9902dd7291ca49f8de795687dd2c0c5708407a95402c2ea783df4f06b4873c59a62fc3712cb157ae4fde5665f361d2c37cc0a4ca16d81aa256e9a1fbc9f058f581c0013216aa0716aaed65d3e660fce04998308944ea1d880f3bdf8b84b81acaac5805bfae8f333822ceb4b58e8f5eba7cf42b8e91958412ad5922cd34934aa74f7652a08ceaced89224e16a2fb3663f3abcd25a5999cd559f36ee492cb01ea1ee3024f65e70e3e29b1f087b0e4a0281e29ab632cab3b16650b3fc15fb0f02557bd195aecb61187317dec4f4b94fd3251e40277db9e2652e28ab9185fd5219491c06e9d39dd40f8493c741af48f07fb74e9460707efb45c842c380f162378ecf0e18d9fdfe1335160e3af6be0bf9c2eeb831b81109c74913efd25458b85f301004f40b423472fa2fa9729ebdbb2d4faae4c8c608a8ba4d6dd5af051d809a6fd3ecf105d6a5d4734c2458ea5e3a4290ebe70542f5ab6afe3b4bcd45150f79aee3d4bd6f4cc4ae17ce24a004fa00290f9c690821a72138baa3ae9a3005996150a93598cb11f9e18983ddcca3728cc07d532803497885a190946f496606cd24179df36cb65876b09d8eb08d1fcf824a43b52aadeabff13bcac1967ff9aea98755481f85d7892137aa6f4d348a2673e705c594b7a93cffd5955f13dc5a94b3d3243affae854b64da614a16a140f2b71392b32f8a254fe71a19c195bd10bc940a0bd54fac07ab84de1d720dc3804d4050c43f114db1d41a334d03761d2512c78fe0588c615c25d38da55852a5c059b430f1d11fbb7d889f743d6d1bd448b820d45660c35e40ed29a85d65a6eadffe35bd30aaee9a7d34d1a4607fcacbe4942e13e8cbfb3d36ada58fd08b6159badfb46e4afd675de0aceeda4789b12df74a688d868509b69edc1aaa59792fbc5a7f91e0b46905974787e17502543941c1b8fd3d5d7745a82d7517412ba6b9cbdc0323632a66a0310cf5f3bb8ae0bf1b8df8f1d0ad31b75b5581b0ade4c42d8d639aaca83ab907add73a3220e0d5880c9c96c3c98910889571750280286332b345c6524ad4005d3246efc164d46f1cbd015d46bb219b5c674218e1757d6c8b9816595f3d5735a04440b57bc8a9f797429d4b4b9369bcfc7fc6c82e1fed42d8388a6ed6fab3015bc38f74f386852396b801cd3c8326ec72c1b9a0b26d28f859e1ec89aced00005d08dfbc69c0ff29fe6774485d5932590fd28c8f2ef05bc0fb9efc12eea77b2e77980b9dc7be67b83034f17ee7f59fd4c45d23a1e7ef7f2719defa9f2a8e1c8d9eda4081d87ce5cb9fe4f55b4f393e88012dfacb5879a22ad2c26fc615231d20aee47fdafa68ac7f63291adefb610a70336f43fbbe14ae03551c212adfff7550c7ebeaf0844c7c84cf595d053e13276327218866d907d11048c31a772378a2d88645c5badd22ecb2693943e4c90cc1fe30f44fb333b06f0c4b2aadc16a48c092b11787e985ed7feb294ea5be379b33b7822385b2d2d425915a06266a02fe3f626346684f2e66cd5710c85cac9424720ec87fc6180f10805325b55e8139171d43fc7c993dc62abcde06001c9c938f1e7a8188441f9b2499791a792028050738491d9f3e2a086d3a816fdf0516ba5e07f8810347f31b4719ffe2f315deb946ddc5ace576a1e353474135f08b55a4ff935db1abaa88b3998fc30406f2513d10b122d742e603d99223848c7f73987977058ebe3a70171edbbba59aae3ad4294dd7fedebee45ccc9a9ab746f477301ab8079b810281f7b34094fdd3a53cbed098fa62984557a67ed7fa40c3a28567dcbb0c20fec03fd5de013498f15cf8e675271191b70696ca387d8d0bb79229d1a8abda51dee35350063663646d481d6a3d5e68558b08391fb7625d8d2460a9375dcc7e25f573234bd0f3e983fa3fbef4191a785261b2b46b88d10b0a4aac7f99d50eed1040cd2b7732c14bbf20034434d3cc2b42f861a648dcc0ac894139fb609caae0b989a47db823cbeb97b7a36af8e5be2a922c25951a87e0201d399e6f41855ad5d2d5be5e2237ef290ec4ba9c6bf00ecda7d8605195da811a23ca10519655e5b97b5c7e0cc0e4bb264423146d62b3267542f4894989ad58e65f1dd8aa30f8544498dae59a33ac7180a0fa83e64af9c6d13569138546e1fc96553282e087c6c24e6beb07107d36dc7f93d769e59f71eb1519a983c1d9896e79a3640abb49e45edead7648aaa152bc49c5c2adde493c1202f39f58eba541523e2b4c4e8a42a98bea0d9798948bb7e1dc61eb5a85d9b559054adf091025dcad48818df41388489ba825005c3cb98e751cb4b539caaf441dbe55c3d97c00d9435e99caf2c934a4a7d3e130c052b0a0da108a9ed9ebe66ccb3146b2cf84839f9e393596d2b2e25032dc5a5e7b87f04c01befc0246a01ffc0a6a44ab2d11806c0ade3baf9c816abfbe52146aa4ac1b6f0d83c1ef92dd072c409d083e992f449c91217bfa18af34c35388596d44fbe0caefd9f11c1c91ed88fff86cd2b806f214836babea3107f800ae4c7558c4bf89a60b2ac2e0cc14681c9f663119c36467a3a74a27031963eb168745474144ffa811f19e86d097c402330b55df033efde45eb630037bb6a49853b2d89b6a63a7a827b2d4ec75b72f497d8cc93db5084c71c062235f97662f7fedee9fb74477833a8798af3e643005b7c7f3f89d7135469de660226f5a21d412cb00f3dc03eef1c02f93f4491f986534772a2bf39a5f171dd3efc46bc271beb5e3f28d42088786925af465076b03a397280d2243b00c22a62d0ee94c2ce827bb609b1478b40f00c746477a4fa75af6f9aaffe3af8ded9c744fbc9d6c4d106969555884b4dbd20e11f5b17e919771689380e4b83ce92218ba6bf5504599b312cda0c18e8644a028fdbf9f8c055ef295c21e6239e24219044cee376ba10a3ed07f5e9bf493d302971c96d66e8b0d77e5a897430e38be69e14e9d26af66623da78f79175b6967d2ce05753a4bf36c36529a5fe7c56fde058b62a1d3494904816cf10f28900dc3087205182d21e2c785b045fb21cceed61aa778c1669ccca2b064fb0273dd4f6a1e38332bfa55a8220ef138fffa7b1a5469a6dc61c39de4ac7c81b337890349eb28d4114b5ba471e6a442f1f7968054d1d0c8057071f477dd29049886d66fb38ebc7c62bc5ae0a6e4872aa89c261c968cb37e048d395795401675642956da72f4a26dee094a3359c2fdb0a3eff7fe186d31f89312bfc97efe8e09883abf54614a133c1ddca1d6ce6a3d8072077ff08213a0c0d6f32d44b846d9a2e48ae79ca3913fa1a48ef51b795a18d285651dfda3dd10ad9085f30aeaa40d16b555399cfe58a9e8282218eccabf6813cedbbaeb720ac83fb527b68f4ee6d0d5ee032a39466160d41fed3038684c18c290d28d39e6f0034b3356647b6c82","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
