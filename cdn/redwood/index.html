<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"83fbb02f4ff6d85712b109ccbf249f1815358bd260b34d822e3607b9f580bd77140b5d53249d3ef9ff90c8ab82359e216f6a679ede761ec6d67c15bf3458d87670bbd37d9d475e1cf04d968ea5b6012205a7a5d6d0067e10a234a9ecd93ead5ff1b28f272b1db73313fcb2129bdd0ea549767b21fb3b407ca19417671f9e262e2a77f63dc50ef2d7574e1f9dc64492b4478042498996726cc2847d7040dff2d5fa730a92a23b02e3b070c5f4b9cd84b6e203863203ccfca19987fb46282f0a30144558765268d352c1cf63e5033a64790542a1c832b99045da875d8103eb4ca9c5998e54cd728ec2b4a9adaa841ed9203be6ca56cda620b56c8d2d2f1c87c15d7dc8f405263646204cc4d4016d1ce9d2954de22de492e2c0ece5761ec88d0e8883044cbc2e4347dbea5278947c833fb0783982ce8b93bae7de25f0a16ffe7daa5cd6c4b3e3d6f7e3b9b7f1f45e66b0bfe08d6ebe80d00bf2ee50bcaa4e875db489b3a1f5f9ff95c7228082b413b4aa9067b10396e17ebe9f02209c27a52eb7b34054f93efa620cac2c73c3d19f5fccc40796ecf5948822e5d9c9b5cf8b81c64f2d8cfef7f8e9005b40cfb26631c36d588a530af26261997d6e8df603cfad914264e07b986a35e0df46189e35b3d6ceb1d89a55aa81d42fb2852e090122ce68be8e2522d3022dba59b4a74f5b46f278d214571c77ed601226e1d0f159324a2ae676c06b1ff0ba0ddc710a553fa5167ffba1fa1f4d42a9b027411903280100b30d0d0d970b4df2b0a4a3caa7e2e88f7985afdf406552a6a5623ac1d7867f14f258fbf31ba2269e821045181c131071803a507bbb7a9e86b0b07180866a8e5e63c782fd02be2260f42a3bb44b620cc6baa5e1fb9e807988c3f97ea650d1d1b856ff8fef7c8ff7b05f906ea896e26adceeaee01bd6c5aedb5392922fd6d74cd31cd20c71b2462eff5946c406e98324f5a03201df09d67e2e8d461710d00871f9c9171e30b40974829d8216a7be0ad43c9d9680c2c34a44f8d38f44f7b8a6924870a7b34c878a42aa0762ad46aef1980845920d17cc0d45cd9edefda0685b72fd52de853e7707492388d7c70787902cd05fabfb81dec1332efc310844d8c1abaf562929b6b04c3965b421cf453fe67b2b7cc3031c0b583d01a3cae14f8cba68b6ae3eebc5e015f2a92b5a8b50f78b70fee6819d51d357ba2bcf067e024201a847b3fcf43c76d30b83d7fe3c9d2bbca49d4d3a2a19dc49b77e72789cbbaf053342ab51d6f845288d21ecdadb374da0ff170ae52e66e3377e9571bd7f0e9b0b7f39c844aa58a189acb62f01ac2c423315c15707c4e45a8bbdf6c1e8f42020d2b49c1bc8488844ab97fb848e3c38482f93043b5a3930679d708d36852fa9b95eebf753dd2f84ef2552e25933154b2890eae7067af1e0dfc1aebf5fc5ffd2a01702789368ddb88f7ab1594d348a6d68cece6e06648b4c502b18893468b8fdcf3ef47bd144096d22f62ae574b8c7da681ef4697de48a777f8caa668d9924ae1c22f3ab2b608adf578287caf8da521771b19b322e20c455663b54692c22ea62a3386da108e6504f29e92dc1d6993708006e0c8be6d1e12ce9b90cc4f002b71e33bd6e55d596e72f25ef2c27b1b7b1d14765929ce5f4dec2ddd749131ad5ca4a05f8888cbd141a246ebe9190f966c1f2124990b19ddc1a6dbc5185d137a691be1a3a23e42778f95f004d81db955fead889f8df3dab0480582d13f0f9d2ecc6f1ffa77ecdbce8e3c6fbf07f791fc0aa063248514327cd572b54253af87736dbcfe12d27d28764033cd47c854ccdc039ea5861f24b63e22f4c8c016215f21e755ec5373592e1854e1cd9f6fccf7134a755acba819c13f365820b9ed97f65499768ac59cd1c7625ace6302fdde06fcb45e039af7ed0701cfa8318af01377889b995bf6973330d562c240cac3a10e91e422b328cb0c46bb1e789150ca03188b978848826805fd443ce52a1e53b76b9354ffefe2df0bda2aa67af55bb34273a434b11dbc94fc00ca83467f68f0cdc82551047feb43acb7fb1748bd13ef9902df718f1750a6b517de4ae3aeca3205683438242ca80e0079c9f5d1222693a83475c3be61b5edc5b6f213d1a2773093ac5cf514cd23e838b271f399082a06bb70fead939df8fffbd64e29d1bde367bbc63fea842fa8a6e9e725c24f014e65c042d224bc71025639f12d643b71c2ef5b51f2ad21c9d9c463f52af4fc9ca4fd571ebaf4f64f0fdf4984e7525d2c7dc9c2d277e49ef44e67bc0f582feb06b4175f30390d7af0420f3c4f53e35d1018a1e08b6e28814bcd02714d65a328561ae98f9eb0e21a494f1ae78805ccc8cdb50d0666a38eb74f827202ccbb4394929db159aaf781b708e6b5e474a596a342f72f20ea033b85e72320b8720012f5bfa9fc7171729f5be4a03687edcbf901eb0a3c1644619cddb690d4427e8754c5138f8fe5a4b51cc79fb454442f54f658f4fe7fe9e41c3e15c119cd1973a1e11891f107c99bc18bb9d557b40e562c301c5d12610f00b8f95b5213f18f66b901da6ab875d6fd414855392a2af56b3b0a121a635bff89ea05dd5f96c3de15906be4e49f3b30a548895118b1301624b7fd5f8098bdb96d444efad694552207336999b87f3e381f86a96564feb57255844b94888d9c1b2558a7e0ae8add00804ae0ab8001bd82b30edfd01d53c526b16a90bb397bef339efb153375c6296a9790fa2b45a640ce14a5c9ef3cfb557e1ae44baa94e3eeb78936e6dc71ce456f72c0b1bdd5ab3b9159c4838e6c987e98ae15900dd7c7b43961c5d785d45c3f29cd2d0188cb17440c5fc2050026bd8d52ce85ee8af029cde5348539f62537353dcaa09b47ce25e793415a3d12ae742a16c533c431eb27ce4ad886a48719543d6b18906b6ce16c34e628af468b20ae6e7f8055097a987f7401961aa8cbd072138a738cd6bd0c68f350448024ffbebd34b8fdf2a26445fed1bb92d8f78e72d1969a5be18354779d336238fb724f1c2cc1ef6fb4202988cc09940daeff49a9e08960fe9c0f10a124987c3e758e424378b7fe2b267d44bbe589464bd063a1c2408e88de020a5560c7a0746a706a88d6b721029efa02bfe95e32d316941f11f5dac4a9b8796f2122beb401f385c8f29b66030de51b0e7ccde54519a43cf9bb21bcf04348b9dd5a4f15087e13675034ca32d1299772ab5e578144b0345ff9f62ca840f1e5a1767a3e36d8d1cc9e5d3e2f463bb5e7c108486d7a3ff61cc1467f3f6802374c9f1877627c042b8e9e8432f461a38874eb39d3fae377418368f3f431e651fdb8e06f96dee1a338832734a96b652bc85346b744854a24f49a5ae5fc2e75078be3d1af543d46d9711babcef5c86687f3d9b8be413e6b952bfff63de0491e4e5bf6c3886b0f3ab3265393772df4fd677e9491e03d6d2070293b297ad647054e8ecfea8658fc7b2f4dfc1ea707590c638b0e99b98efed3c1c4c3842301f2daa007069d0c68df7df925f190a4fab11be60731ae04333cd715ff6f7b2ff35f5d371a9c0a5f74661cd512a13c57f6361e3f12ea7defe4d18ce11722598651f81ee5b832d6df2772802dd2e6a80e06eeb84c3a0852f2e83567278ce507c6d828047d56d961b5203916aadc953470bc764a7a15b865c73a83046124cd23009236e7ece3119dbe1f779c6b79cfae42ccedb8ea1c325e27f823f4a406c9b1dcb54b8106a4852230d0a3277dde67cf45d4633431f84dd293521fb573d64904871ccf03390d4840742e4ad29e47d98c3f7c74d6d5f92bed2b5cf8762863929b77e7ffcd83610bbad415549a2410ac4a54e7797f6569f19805e3a9e33746a8860718b7aabe597371034ca19bab69869674f66789dedc0912f97cb43554bcd71f85b4a8efd6dedcf6ffd9296a1e23df24680260fca0b3b993d33793c38148af084dfc0337145c7d7ab73b59a0d9fc6a675c390a71384964a00670d0ad8db2f960d8f7acc0629f532f50844066be7a833c579ed0a0fd5d0a56f6ec379dae5edff7330d76b42853ad893b6b0c48e342e5c5dbfd772c1d14db785e8f0310d84e001abdb0958eb18772cc65fdeeebde8abba08f51dbe9728a0d8474afc1bdcd996f061f0caa0d588dd24632d9254125f83ae03f108a9f3b56ed62b7db0bba82d2d2158a9398efdec6fe7939c43e3cc0925d20a31b7e53292f3cf4af879f5e17f76c7e8165de4904e096e411905d4b96c5bcf78a7edda800c76ee8f2ab41e4f27e2cac37048b0073b52fea20988851c95c0ea7bd90a30d710a6ab005e51f882be6c5b49bd02af18a209e53d5bcaa014bbb0bf15ea80047a97bdeef6bc27dbd9598fff113418fe5ce371de614191dc3ea0561981e496b082fc80dd23458255368d10365b2ea6615c6a3840d38daa92ae29fff4f670903e3d83edbdfa324ed075d989cc7ab16956ffd3955f371d879e3b8587b30283a2938bfbdb89c8f901c203f55fac4f895bcbb730cadc62de1ba452cf17e782c967fa8d5ab51a7824440d77ba8c5ad18c17bed5a3dddae99d0aa11aa88b0ea1924464fd5c0c68519fd7352af912152a774b52ca2a31626153f3b5dab7a21f42908249de76cfc4fd7e82f76a6b802dfef7dff97b0f27235daf16fadceb74ada8c53126d8c12c5548f0eefcb80a3b8939ceec292d7362487d260d1770a98262328bb3b7e8826275be58cd83722352a28b4f986ee66725fad8927cb6de1b63f4d28b9090b14ee9731c7a5a7d1a34189f995ac43d804a43b861cd88a19f6c457a120c2e9e222a795a24e7c816f28af63cd3bbec564826370f676cedf142d9be97bb9f756ef5fae303ce9b47fd3681a811ff7032bb8f401f25eec48248f82a36ed57b8e9fceac4937150e1f7a8a812c5f28257042aabc4ff44aa732d8747ffbbc7d350a38f64ba1bdd6d630073292a9b87349600ee6d46313903ab2166017a33372a8eb2bde437333df131eff03d004c5cad0612a2026c687ee830e62586c77f162e5ae17619d69ef892d96dc4c502e162fe5ef9c9a2c2aa2d1fc2b4dcceee5b7d1d42ae81716d91078180351ef74c489572dcd1fcc58eb90725d414ede01da1eac240c77eb217efaabca3b4aa37cf9dee193c8bf1e425321312dcef4d014017d70dd17db6451db828b1d0bc60ab823375bc7118f1b63c0ac686b7bb2f867ede746efae0bc5edb0a7247b489265da3f15059c33542731a942952c4fb5fa1ec9f61d67ae9d199810237a0970a645660c4c3e2706beddfa64a2db313aaac496faa45095e99b300cc9b18dbd276e160cf5f27957f838aee48c78191443d709bcd92adb67fb7665ba4945e4096b598b757a75a1ce52ec7464a428f048e4ebf2a77e9f0e12788a6ffb7cb77ed0495a73206a0455827c3103889d36bba014fca45b442409ed7473bdce5d20fe399cdddd8e73b84fae810ecc07e4e82c86cd082f6119f6379bd95341a63a9fe2ed9c4759ed1d236943e1b850577077d96318d2f24611b75987cfad1d1b3b1203b4a19e6fefcf0c3e33523ad89cc9dd5b439e25d4124b756dd192067fb54d002a7fc1111adfe7d1a9e60d43c20aeb89b96928d9dc5aa5833a63588c8b9796ac05b676793b8b0d52e76f9865f4e76405eb7825af20c55a9339998c64428987a6d9740de0549cab465ab7929466e3b7c8d994a2faa86ad072815ac9897680d3cea718f523be826a9a78c2a5e2f2180bb7952f76614d5cc12b574fa2cbc35c14f8173e9b57ce36e1595c6e2cf7192acfa5f436a0d1d17e9a01ec25c49cd35888555239135bfcb9455ae752a10e48b608bf6d7d2341b2b3efb8c8ddb650283af6a85b493a0f95dae0e4b97782248d308fb46094aa2a91ab3fe8a53046c7eacf069c602e676bb3798e01e9994971cbb3c6c7103c8497ab7f4a668e30a4c759a6740ea97675aebefe03dcbff2618b0b54503147a538d1aa89153a3d2c0e683e6291fed28f301950d72d15a3c9503a4df2bfab566c3faaa63810ee2c546d8cf58ef7acd4c1d863f2af5d56037fde6dcdd58282fb2416390c0872dd01d07e93d3cbef7004966b00a6e609136cd06d48455fa1a172ee4ab868f4258140ca5819146a134ba3edc48c279a9924001b2a73c227dfbbe0d4fee058ee1e5ebdb1ccd94d34f68421fd14b07017f01e55678c276fe1a28f0e0c5793f14d6ddf691953880e26b1c3b6018258f046013e2df6ddba155d660e282c6a3d7a6626436147a9ba3ecb6465a3e27581c394c1077cf209f1e41652f1f5e5e4c5f84d945481cabb88ac428e1c6a6bb7f53a6c5af73d5d3aa3497b3c30e212cbe5528d0e29d30ad43416911b4ba0fb46501e8be704bb76fa1fd29a7dd352e3e12e162c167e7a1185789975cca3520ea03e94559fe108096609b23ce4d9603db5e01b5a4492fe0fe2b7cbb54b094dada8a61513974174cacede2ba7089b23351da292e671bb5279c49c2abacfbf9ff927a244b43dd4c2d45af0f7ff9ee6e98fb774c08d0c1e374498a1fd6f8a5a2afe8ee572b5b7864762e7af03f6528c753f6d50f11821fcd97f4f7a52a80d248487c04ea86534e49fed9cd5713e5986affdccc85d114c8799fa39f47746b1a97360315bf910c8bebea0014ff8a01c7b92963dfda423b9da9beb27678d03ccca592964da85ea97d0aea96d10b13d2cc2fada9fce9dc2a176d2b08494f35d33280a1fbb68829842810229fddf700ff88f30e60a0802b138c9789f58c05917aa13a9ae9988bac80aecf5e1fabf34f4a4dd906c37e6aaaf476478e5ea4ea2341f1a98dc656a917b49b42775f9c53f8313961906d9dc9862ade832a14ca3e40ef5d403c9a179bb5863f59d01dfb2ce7dc376b3556c16c050cba78fe12d7bc291d32a9c54b37d6686b7e80a0315e405863a18b62d09f448a9ec1836e276e0d19caefa0a9c720bcd445e2312ca93c98c387b6dbb2e023134bed1ee953ee9b83e4b49e0e741f2cde3a7d087cfbc7cefd7d60599600e4865cfbb9164d58983c78ad55cf578e7b765796fbaeaf074380019b6da2e4024630dcbb582acc49f1b5d54f2f46bb1f9093d5e55d425bf9286beaa087e8240a7d429bd44cda2dde75e05923688d0ca9e1eb5bd0f7f74271bfc16cfbc390e0eab0e21d5102a7f8b101453597ed1c9063ce7ddeeaf9febad9c7f1332de76b85f91bee0bea25ba95b4a75f40b6b6d07c6ce744b13012fcb2de743ff1272d80576eede870141af50da914fe12d2a0fc2a3e8a71dbab2fe23f95a0d643adae981f78a24b03b68a3cf201a8a10a09e2e7062f46f8e814d1a575f63ac02cf3887f479ba7acf65443f79a594a2ffb30d23c5a0604aac215944c763c3863daf44a0d3d6bc4aa5ad9ec5bfb5f02653fb22dc59a180e3c5ac8e2a507e72859dd1cddeb9eaf463d29e687f6bed08c60cb1d6104d41f6a8b17c4c7666ab7b120b524449292fd02b18e2ddbc6268f6ff3373e536ef7e788c3ffbc76f69c78a212e9f0355d8c76c0c41b4b687f4c90746f5abc1a5982e8ecd12ce79742f0b2dcbac0d24627a08851369098a14a610ed712d3b5e4084528d6b986e0e9daf329d06fc84d39c422a09cb7bed7fd9a55d95be4a79f8406434aec3e14f357dff838cf5946befca948a24da06b9cf9562f64429e529e256ee65bf5909e195098dc8b4fa3e2979e06a2c35c49de765a01e2003025b393787cfd3bb74dae4d5c4265e59aa3a7513e815eaf8edf54cf1b95fd645154038e88c1d03e83b5c5773e3aa29684ce408a25e3650b947e83d439d28f12388f1a6268bb179aeb602f8dc24cf23c05f3ef5090360774369ceb1116d1c61203de15337a7c6807b58abb35900c05f5624d42fcabd1a9bdc59cfceea45398b4229c7bef8a35c473b13bc6dd0d6e5a99fc2447c2b2e37f83545278cd66e51f97282137d06f0717e67fe8aee7733388e1391e074c105aeee38e8e733e92bff24f58292ddc80ad9737d7c0a543dfc0400307a9aa611d0674d28ac1edab4211e730f4c1529e530a1b59f7a5459333aeef7d9924e2a9c503fb72b336565c7fca9411f4021d8b5b522e5718c8407dfa58892cafb1cab2975afa0d8548eb7c7d330f7b79e0368a651e34a72bef57a1720ff3b893005f212484317c5dd8f0140e9a58886f1c76ba0e174c67882be9a48132b7af2fa9e8d0367aa7fa813596ae1342b0bfd856dc549f69e2e5f9a3be7ae16c78d8008a7b2948507f16715ff001c2edbdbdf98322bb79f18b5387026156afe7859ac353fd8d894f022c9ed8edb45d5c74259736fce05332ac48ed416a693702eaaa8ffacf319e5b1697db5cdff2861975932a27eafd7b1bd4fb1ae3abd82583c92b99da78601ccc5b49aed499d1d9bf399e291f038bdbce4d3c1f53ad788ac1e56ad24ece8c139adefb63c06a189089e156425bba426899d491383c6c8680189e1a069dd8f6c8398af218aabe12c729276b1b054a4b7de1660a1b23265d5026f27192b13cd0ce50c50f43db8386a6e77b8abcf0d21f7ec16eea23d6a72552b8316ce1b7163929f0a613c8dba7754bcb184afa94f0b4192efc32dc31cc42e92b1ebb758cd82dc463f06b4abd384a3daf0d7e7785ece1affd3432307eb6152180530a6b334afeeb34042c8ab6657392030369ed0d9c5ef8855f95b5451c0d6abee195b10a05f5031a9f852d0b45d1f7cdd243eac21f25efb5c3969ddd8196bd4ddc263aa5124ec65875a0bafd82b4657a32e4dfd596175480c138744c061ed0ee00283a2b5b004fdfd7b51f13b8c9759d22490287162aecbd3f5b7616100b09d560084831b2aa0c6e148173470b6e8c799a14c87b3effc151e6a9dc12f4f1b176b3090164c7daebe98a85722bfb8aba759626b6b38ce63016534f54bf5b7263cd20d8e8f367de17ebf0cdef4abee0ff42c136a5cabb2fa2056e8520c46a940aaaf36affe7e77d859eb0261e3ef72fbc6941f480fd0a850ee4ddb4ef81f43e32f6a17b36851d33a96b2642dff52b257011f013ec5ed282060f37024f5c4604084f26e17946a0e539124237e9c6364727896b94d1de1d5065439c22a351c1474f69e8b7ed4d2f2a8ec64555a584b44c795029b712e9a92d3e189b0644850988ca83aed46b684dd4a6faa79fdc14c90e89a3b038b535515050ada150e2b19c8c85b2cd04c51220b60edbdad92d5d639d7888be29933e5b7dc271eb1ad0dde2aa65eab605e66e14b76673554dedb2e7fb4a6031f5d4765c1574d31e8523ffe4e02dbbf34add66c90c0596f4b3f185189c202e4b2e6ecbb50734a01bf45a15bb71727eabc464375b5a43ad88eab44633c3f4e2865e8101d7a11bf25601a24364759392a92c503c3416681139b31b277e113766abf42c4bb1ba8430332a95c0ba024ac78c43a94e384263a01a0a2868969dcc26ff24952d3d46b9bae2bfaa920e69bd986a3be367d51cd2bba7ad56fca3115f50264cb687bc2ccc0af6e572381ab380a3c2cac87a83a98d5adea751cbcaeeea030f0e6e1482028de7b2362d6166276c75fb8b618df0e183925153e1a93c7c39f6d1240bfdd0c53d5fcf289569740e34d7ff8cc050db18167dd1ee8d7a78ff39e6d48f375820f133d412d79b33d919a0e4a4dbeef96ddb48ae4b1b76dfe2ee1951c84f86921c1ae77d4b39d2af2b9ef79c424288f0cf09f7a232bef78512f56cd4c83c840890aca9966c932229941d3eae6884b7a54e4f88e2a43caffa157cbeac25d29b588cb63c7b8cf39be86838521194351c8c6d7b8a2313be928428452ea0f9805dd1177c5fa545fd42283465b921c7e99ceddecabd692bf592842abd1d7c7650c906d95485a05025f860500b0d07a591fd039e1842602ea350d1c06a1f777c440d1f5087b988092833356d39317fd42fa9c41cc40e849a2d27777e4c70620e8c5b3b8a10b89eb05d8ee91cea9234124dccc31684a72d5a83de1679f8e22efe1bd019c565ce42e01f382cbca56ed04ada38bc3d33342bb91f8c27b0ecc7fe42d7c338e577bee1510e346c555c250e81a47e9c7c289cc74a330a92db5845163e08d81164532a43e731f4a75e502cd5c16c261e289656e727e086695dc6c1a683f9bfff68f31e9198a7c0661eaa179cea07d936e353db976a3e3469bbfb2831a6f9ecbf99d397ba4bb2c1b6619d8b3a218d35d8db4bab4d77ae722c94d5e819854c40d81918dbad0a3e3bcffa77518cf05cac0677bb3c2943b508413629235bb8189f4baddf8339a2444dd32a5fc7aa92a44fc1405acd293d049d91d3ab8fff46d81bf619e04aa891ef319c7f55f91643262c49af600fa2b928e65ae700d6c2fbb756cce9772efe660c4727089ca7937e439df9dfe1502692de593774748e668a324bbecda682ac2dbcb9b522ce1d56fd3cfa6d1914b58a7a3c71c7adeb09d9acc70ac9b05a4cb76cce4dbda90c006cad1818b471cae2698b710101fb7302fc8ab793ed67a0b376e5f4ccb3e485c04d775de3329feab4cf359538d11197a2089991c2a23aef5369bef47352e3c944a186b563269de30679462f1bd9c46fa121ceec917b36583b135ad59271bc90728613a473eb5226ce9f1971e3ab3273ad4226bb9284e9eb06e47e22ae2823fd7d8b55684247c27b16ed8847963144f999fcd0010944126f82ea1f8d30178241758d8d7bd1739e9fcb5f070dd131b7f9e589ad7292f3a172f8fcc85d7ae3b25fc6cccc15ffefbc1d2a074ab8e6f3574dfbcc27985339ee891edad7520c59dbf5d833d3c58c21a5f4b114b27b82d023dad462e81b9fe9954b7457760bd07226e598ee4527d51cec4eb85c4f979f737a46f8de9fabb1853d37cb13f0d290617eae151c499b0692522c68e8cd009fc41cb040f7aa9bbef8ef8206d35098ff56fb662b6c521837038b941652b1e9273b45a3e926cc44b05974637f3fccb05115edaa838098573c68d391a6615e1c7d3411dc048cc65dc4a63d73127e4208426e162d09c8da636748e3b42cea43d7b092205d7fc901d8c8e6afc59b22d7b41bfc898b21eca3d60c0044986dd1b8f1cef79ff7ddad8beabf22a9dc306c5f88f6fa886687be77f4c1fb3a9ec9910352f2acfc01f9d9373544c4634adfc718ca3fe7e3335aad43cb0b480f761ff5d4afaeb893b89f1cf593e6513e1c302d9c1a2b0aa7847c674521a0e73a2974a15b0e841ed0272b5a5434de79d0705c55cb798fabb7e6713b29d24582fe09155cdb7c4e8b77a2351ba2fae69aa931d60e5a2d4683662e30842794f52951843e61c30a367b8c8ce7d98ca3f95b0de9200d9e35cf102efda624aea0fc6c9ad26cc558471ddaead06dc4cf0df73eb096a1197eb0dc7bf813f2a901b96d87a2a8908e6658cb74453999a49608585eeb996e38d63b0cfc4119efc0cf9c63c20b4ae4802eb0fab2d7fa1c39183d15540353c8c96ef5ddd28d13e57403718148602998bf42898b52a2cd407fc4265ae24e8aa3b07ec65a489a002d31dbe106741f23ba0eaef323f8a0c7a4894b7d0b17463b1fed451338c3681c568cb9a3f5d84c553bca70486f54c31c9ce84025cd6f362a1675201466af4cac453e49efa6f12f6ca1bad887b5353a16185c8d4cf13c2d6d1be0c50631a7169d938ed986001861d120586e3d5e986914d70fda63f4fc4ea1212fd64f18b9393c2c59497613e079554061f3022cbd27f35e72cbad513b3011da15539fe91970c6f6929739f35effc35b60d955b1f2dbb2338950aefc825e261942b42aeed3f1a907da5af2f9794ec96e1ce854c55458923f7cef18c02414c7881f540341b8ab9d862b07ca1846f842a034f1d03dbf32d7b9f290ee204526f42e70da0ac0cb91f3bf36d34e9ac401b2302b448fb7936a7c7e7bf2e4ce0ba2b6e4afbe11decf434030bcb459d81018fe50d5e3630e11d30983ba4ac994831fc78598cfa990669cbb282aa982a12e8a111de72232a7fd6b85894fa33e60872e9f376572ba80cc707c0939a08c4470299a48196f6f00c6dffb2c4795730f050f4f63b3d0ec1b5e1a07b3f28de736443cae06959ba8ea172fec95b0f896eaa7096f607257decde7dd5e769c85006884c7819a109074b7e321179443d09ee2df7efe9105304c86a9296201b998d4bfb622fdfb5dc9b5b7c107258ff63fa828ecf33582b1a069e5c7230b869b85618c825664855d650f70f8a1197800760a2dd71e68b95d4ea58af76cc715d520007df207cbc58db1f5122035b5fdf584ecef4af23997ccf2615803d3d260e4fa995bf2b6f6ca290cfe6532271daafc281b069e6f3b50b8c56cea8f095c43a3407b523c248b37bef41cc2067fd31f1f09769fed70ebb4a3e3b973dfed3913e9ff2f0a4350f70edcaa38bcb2f07fd8e707e2bbe6c39a91aa93c72aae44d4ced2fd91cce035510e81975140ff1992ddf0f9b84b8586260924bc2544f628b8ba7fb309187026b98008fe8a85358d6bcf1c7565f389f06d813ea503c53bcacde55167e0946d9810a1805cc6ea553ddb96caeb7355c78c451feaf70288abb59548583aefa26a4cf954d44ff405e438c612d264da9bab7bd6fc57b95d7985f91d45649611af38b33c8856bfefd833eb1436b756c42612b92fa3f366cc3eb3eb67ce7656db181c43cbc486a9a446aaa3056401ddd164b92ab122c6267858367b7f549e8bb023023287d9b4c725d3138c419ed3b378bf2b869f169b6788620886c6d8a421c2c6d3a803fe279139c4631d8d3b464d8353691388b3af02574498e727a1e0c99363abced1b4b02db3288a77b3618f6d29760ab767f0503b290e26fb6c6f7f562c5df2021a687c6c4f59821e0c147cc2bdae9e295194f102fab9ee810fe39c78c09281fd8110d3be4b624b9dcc586ac67327afe865c95ecb4ec44da923c9b85fbb76b5dc03af90d57f527cebb8ac837294482890716f670948aaa4027ab6c87902fc344188566fd15a1d7f030dfe48d27dff18e9d03c23386b8490733f4f50f57416a7cc18eccb49a980fb1dc569fdd6103b606215ea4b1576d17a9beb92e21b5099a51eecd8ed1c4c61822020f37d1c0692ab84daa29ed6156a647286ed6f7c787866cd962466cba9a1ccfef33b63f9517d4d81bf1f0dbc3e785592b3db4941222fb77939bf1e5fdb3aea940ba4e6afc8b85f5fae8f101dc18f5f65d2e8a890649937c0f95f6d9af0a97b794efbdc634f284655847e3b26a07e019c26878aeaa147a75fc05ae6b2605e939ee58d56fac92559a8356145751a927858a0e61237baf65fc8f34ee43292c0862e86e70437c010108fc4411cad3f93a42545f309e49b68b00bd627ac147996bbfb5a17246c816206be3455bcac626488f5d57d96a3ab5f84acf7fd304edf130fb5813b900a906a6b338eca12c402666a94c584cbcb522e4d1029c68d4099c2c4d3cd00655d4bb8e115271acf5f2a538591a39cd8b6b655c0d767a6088c0df07a00500c8bd3468855c72dd3be2d1770a6c7705a3263260059153d0e671972d10e37ce1dec52524c337b87ee7666b5810da6ea80112382742a47f8f3f136573b66060d4e2f2096e026a79bf5ec69fe7b3f597b781d4eaf273b1da21a3abb2d840b397cf7a24d9b07d7f951750197dd082602e540ab8c7d90be9444a8780a98181d1f40b7305791cf60a9581b7e62ae9fe91623aaad31787db4f4870e5bec3f93911f0197a0f75f7ab14aaf28f4f8fae9676946b24ef1b5b08438e418a7bf012598432518571c6c80b8e8a453a3631ccdc20df559fe921e806f1e52121bebe1a3083215394e983ce0a35d8398f138e22a5d082a86dea98054eccb6491e4995656c768d33a5e6d71b032f19655aa9a5330aa081279ce4024160c8c38a2c083de67203c8edee817fab2d639c4aa80dca38ef46ee8f86341b3c61b0c43f6db49affb1b3763ddfe6e7d856514abfe1255fb3cff76511faf60a69f7e4ad2c669d71fbb22e1350865b414bdca569ff9a43e1d2798a0c9bb16ccac879601be852d965f0ccce527d3e8f4780007f951f972b120fb8e4d5cb0d9f6fd2f8e5ef7969f25076ea2c6d18080e587425f714e738f77e2abfc7e7e111480d3094a9aeacd805e1d23b2f86ccc084da6c6d3a6162b518d02315fa06602491f88153f414b7e3672ab63dad1ad6e5fdc662a9df8d951ea7632b1535b5b8dba4fd3b63c1552d70b87e1cd7bd9dadc343800187280c5b57aa6878f33bba2698535089bc3dbbcb1f1044344e35d8712e520926fa68a962cebd7941b826a648c73a5e1bca8502e77de2afaacf714005812e3b8cc0d8fc03e420f98a39be8df89ebf1ae307d71a9866430328c2f1e801cae464a2c37bc2e748a5db0be948ecc3faa6c1c0c593a072f0ae0fcdd1dd1a45f374b6879b5ba1055938ee444b200c300fb56824e57d799ece6f78f4e2b484fcd315b4f469cc84f109c5c5912020a44e621f89b71d161a86be14019e434aa199e3a2f4912edefabf74bb084572b70de60ddfbfd46e161ccc4140fc95342729f47a42d491ca4d61d291a8b1765eda0bef3731b435fb35fa8ed1b6c85241bd0f422fc0a52bbb6616ca7c8f4480b811c696d58952fcd1439fe645751df45d3f6080fc89ddb09ba873aad529c6a6ec677736762158ddcac4a4068fb1ff8fd8597e19d3d164f8f4b6824f38315d962ef65b5cb80bbeb07f9cea8d0e07bf797fe3259674e2471963aa58c5344a73ee814888408d309554f50d3f15f1912e46a03772d11329c4f34ab2dd8a3bcad11b62890777bcb18788eb9acc65387545bb0ebbab75e107a5ffa9c41922a4305a6401f1507477d2fbfbd12c57b0404076daafda7bb66effef9b20cb6270810aff36c48088e840b040dc9dace720aa4a302ebd1f58683de91bec2ba40c8c31368a9f0b01b42e726fbed26404f88618d2a3ef88e7132bb5a876f763b6ce2a260e104c84a47f3fce629d68295569dff1ef81bca0fb0c117745cb69bb6083c7c83d1f1092086bcc3025bfa4cc1b69d5d2d6a23344c59e5a7d7de9a8ec56b770b0c9d8bb3082ae0436e38df92cd90eff6065c957bf6cb103411ec36e29451dfa6ecd4da0ad16dc767643273a31d19b8f5fec7d02a4d33f8cd99c9328e8045b2eb0fbef200fe99ce7d746682df50353cb4953b201433656a85131356c7c47df1b538f0b91a6e092b2196fcfa9922e423b887bbc6b63ae2e7fc48acb5a06d50e906d9be676ef37571bae933c24f9600a85bda099926cd831f732e672a47ecc594197f3875a5c81bd01a07d9ebed6d73950cb0845056c2e2af926e94c0de453712b2de60db76a4b2c8f4f2b9062351558de7fa29ba7b2195c23d1921950e048f342535ba3c2458db47046abcf32152943811939383d347a18a2ca42653c071307e6fef08d90f3f3a1b81fac56738c0e5f96a63ad15ec86d1caf7a686de3caac4cb49433560720cf1f0cc04cce88c8663ae991713e3599715639c195f43f1ce0c213b6eabd7eb5127424cecf1a68342f7e9bc2fd607f6a610c0dd9804ec7c8078c40125d6185a613d517cca9fcf59a462d09f7bded5f7ff10849abf693fc3cbcdae7e3c9510cc629fb716051f56351988356afb5a75343dc3bffb22b4b5281d61cc433bb3b0e2101f8a4f1ae4526adcda222cbf4794776dc83758be4dd125cddfa2ac5febb147e2809d585747adac2e22a4ad0b0a3723db404277d96a1fd75bfe7d3b71788f6e10a83458ebe193429823d22943b091a3b5619cdad76c87f0a6f71903b06b05ada65a99a8b4722b78d959bdba9e76d3ba118bd58aa9f3e82b0e378f887defb5f3215a4d7e01ba02d32eed1683d0f3efd65b531429f59bc7aa4f8a3da80e7eae842474ccec8f2f796b3bf9cb975dacf5cd300a0e323fb9e8c8f6f1136c9356a8d75a25706d1609eeaa883e255b35e1a2225177dbaa3444f481e1511267871c466b499de78c39e521b1604ee6e3ac09e2a8fa9971e2b932dda19c02af84cbddbddc8731d589cf9b233450806de478ed3f247e43987dd8c2f0a559256e3255de2e1c0c2847a9f9171c01e3358158143d5ac589e64b4eacc424bd90a4d1f73ed0bdbd120d5b1a78868c13f9f96c54f82fead598148a5be6b9523cf6a55dfeff257bb6cb14537eefee1fbcacb60285b52b5c41b1c96205e0e34e2dd397eee46316858e700bd19efac898f485e63911f8a7b5fac67dc938c9d45b22e25111217da0b28e0e2b895cba6ad7009d85a9ea86795cb23858bb652d79889034506501851a5ef584edd0468ab55e4eec9e07998085b2449610f5d97e11025fd6a4653e452a1f99cf012ca12b40d79c149ec021493652790c4fc43204eea58ff0af603ed902f025cdc629d2a1cb4cca2417e78754a362a2bbf42fe1c10a2dd2af70b1591e94a4f76ca4456be923aeb1b5e8e00afa447128d0b1d803f23371ea739f17d68fb9be0b63d4ff58e10d6a98cfca72cce8671347f1250e59f6c33672685bc9f7f36181ef2114acc36f07de3d6d8df0a471e768f680d5c7641836450ebfaaaea57715217f6c47213355a8012b055a41115f2777708321732606a3396fbd558e1c013c9d2601ed4e6b48494c4f812c12a1e1d0a6c1b79017fd78437e375ad3e7d149310c183d6cd7f5f5541eb6d12c34ebabe7c68aaabaed60f14c46567e5368bef8473cb116ead3803eaee273a2b08951a7c573b116558ba89ef1a189fdfac8a46e44fe5232fc3762097c17f87efff502a8bab2722a21d631e994719476e5c638a3baaf633b6fae52e9984762599ac394c9bf39678dba6230249bc8e3103854e10a104f93275e59c8b146797083fe76336398cb1071637515967f06d06861d5daf7fffaf59ec6df6ca6fe9b2150309999e202f9583b421d0f8f5a48352ca94d04493e7cce44d21d0b893376336d5d724f22bf4eda7ded920a8687ca3182d39036bdb97db37c195c02e594966ea40b340087715df4293e3722eb5073ca4a120b9f086f6c0e8cc67f092cda1ec554a1c3a4a94e520e286257e1c1fbad61afb443808f34e7f75274b6857de34e5d25e8b2a164aee50937ebf16cee0296e28c79a663c370247486e38c1b4a437dd9ebe4ba5d17564c02fd59d61e33ed5dcba6f11b5de1e73dbf020dd31edba06c90087edb24ce7f781b4f34476480c050baef26ee47b1233fb6e95b4452072af33a472009e4af6e52cfede46bfda3b29462d1e23a24c8b6893cf3040358270bfea95da2958133407769ead16dbdf2e1ed36b840381a5bde052a2de5f22a9c729755b938e2dc8792aedad214f596fd7901cea777fe89effcc71877703196f90cc202af91be948ca3fc0535738d668e680078ea9874c29277110b34e59817c4f957197871fd9374a21a485d9b155b5d48987e2195cc29149a43a8f7316b33128a81eb8c065bfe9e278e8ea1edbdd017d3b555f614ef35c5178588a241789fac8fc4b91315d3a978008405c2c7a1dfddb3e6ac1ab5c6ce36bc9a80cdf4c8942ad0790bee95da0110af282241bef95f0070ffd1b000d33ac488fa9ff142c3a8c3599a24744900c1a1b1c291c0b673ec9ece0372760297dc3973d703b8a4bccd91b0caa8f7a31e7ee9dcabab926c331133972e670b9ae932404fdf8c3de297528becc161467358c1614243355f1821d4902861eb986c7ee6166e5500b8f1a4eb50e82be2887becd152d8c9b79ae6759c27f40a64af3e81a96bef0cec59d4903145b639da38188f5f04ee73020485023a01834fa672ddbed6a43d78e176f3361a94e0f8680c1b17b5d753322de9c4ea5fbbf83eb5b0da873dc52c2fad1c3c6774ba57184251fe72b4f02db885a0bb5af319488658265514b1534b1a075e17f8d7f26f1e06c802601d9fce129d1906efff52af917e00e63d262e9ec5f13b3f1a1cba63650514d9ec5da63eb952ff98657d66d6b275bf656aad6fd9a58e7cf84c4e6e761bcda288616d5410745e8dd1d6987d58830021f8e5e22af24cb370acd8f842602ce27aaa9955c914adca73012807e26d72b945ba6440c4a0ae1e6dbdd91d83c3c0805b913e8de04ca05e5449d0434b5c1fb8ed4f25dacb0275","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
