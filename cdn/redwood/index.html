<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"0c84135f8200e4bc500061375cc12db716d1f46a4150f77dda6a6812f51c40e2600c645181e2572d04f7ac111ebf3aaa04951338c73a2a23bd5d4be53611a29e418bfd4827de53fcf90bd943744acd9d5d3d4f68a09e089d6084bd5bb1f3ebba29cc166d3eb356c520de267464e7e81a1330b4f8000963d943aebe8523d655079b8e1d29c7a7eeec91346114d0daf12d17791891d8f005c6f55379db68602a15ca525bd56ec08ef371310d5457d0d7b1e4f05192bddad9719a8d3d88b65261548b5f584dbe76047eeb867743b95af49f5f9dc8eb41519edfa066ce7ec18ef8a946b482b598504a977b189f626fe9b604cdc6dab6419feebc08a4ae798d4e70e9f0ebf6810e182860cd0a294476cd93bc940e558809167b021df81258f056c19fc6090911e98e70f03832a417b5c5b9962c029fd76177a105173ae02a70bd084bde426bde5950b71fb62d67e8111fb034239de6e8ed4741f724ee0f7f393ecdc3d3df125ebb4e935f79fd0933726ca3277d401b2a794b6a2ff0002266b75a5d41d82c129aa382e3071c5a203f6c0d2ad209cc803ad2f4b93a1d78548ef19bfae3ef409359252f0932a109ce95c9ccc138bbeb68c3bc4920ad515a31c23385dec208062a1e4af24d54a3881d9db21f90b7b7ea9cdd6a4d88034038f48ee0007da9e63ec30ebc6a466ba8a8f283ff18f211b3140c9f792ec0c44236fd48c238b6443238aa924a059f0194137bdb6cd6cb383bbc441b53dea0aa2972621f6a91bfba768d42c3f70ee0bcfc5426d399c8bc6728035c377a7dedd4a46f4c89970d049fd1829595eb00573a1f134e1a23e0ea5c87a352f84ecccd8b043de99613fb1ca9da9e069608a02453b8a10bbb220cc5242e6986afb352f0071fa013fe40a38f3f51b78919908b475068ae9add18ab6bc84a09a0a75a52e8cb012c400b70ce2c1d2a3dfca97619c5cb1a9ebfd32ff25fcfefcc13c4037ccd6c8bd2dd494d7f5b17fc8d53211c5ad02118d185e77bddc8024b9ccc045b66cb280ffcdd4c371d46cd81aa61b03a9c244ccc889ffeca525e8f2e3deac141567675eb0dfa6cb227f54ca2cd755471c497567c584eae787c47c3e35560f394066651ed5f6c912ed01cb88112949838fcb3ed16984b53f0ef382571c300dbee0ee35a8c8e3c05e55399575cef66305ee0ca7bd776842652c9f978ed6c47cac56143c1471a76c10a91563bb214dd4b21f139ee77f9bf536b4f49a4cb5c1bcd7efdcb377f04257da5d2b0cf5e6c1234d7ea35bf47c1d2db3cce4363e32e01ec7358b8445cb59630d4825b14f8e1f34bda7cbf7267f7e2876a8a4231bd1c2ed4b56a1132678f5196782f82efcb36634e8245cbad89d3a3e421f1b20dfe575d42f8234fe8e80cdead7fc62b09a89721efa5806fb43af6b05c2fe5d15bd6c75b19735653b134c4cffdd540267fd82a5ba562b6d1adb817d0a5fd91d433c5f9473f037bd4d5f421eae21dc34d27b7cd0322c90726d55b3def7a1644c1067e75abe282da38d9b490600ef5d0387b63b6d6d9b029b1d1d66844be9c8a9ce075d3f46d7046ffe5707ff7cc915011d9f57714ef7a13cec77946a4040056e39408eb80963303fc41fc4be8cbd3b4b7c2eb231343bdc7d886e2d07aa5a97bafef9840a80581dc06ea85fdd9c57ccee54029631cca633436966de57fda9778b3594cdaaea21ee11a107e8738038efdf66f715d2f27db6d0e2ef3ff32c882c4a8c6a528e321e01bec57b68ffe834b11b565d0225afd3b0dab0b33c18d675af978391f5c7dee619ae4d5351d5e880e39188a0329f49257192aafd0e4f1e1f72074e174b8b2e537b19c8a93fa3d068b8b3bf9549e9b93f5abf7577985a82c980f24b040928b615500c532a5f17b8d2ec529107dc74ab3081b9c1722c502926291da56b3480157aba8634ef9323f0e35ff299db3297d7f7b8dd8dffd2cdeb3bfe78d898f16479259543fd977443f7edf190dd37aff559d215e77a11e5cbbbec688adc19ac15892e50ec7fd9489aeef0bae59d045e1e930bc98b3fe7b1d62a8c7639dfc8ab218f1fa068c05525d42de189d90e0a267683a9611798fe87c9de74a5e814ce14cea5b50a5ae74083fabf6531c5ec14bb8e786927ea7b389e2c6ea9102adec79ef1c8e12dcd86d7d1b28120f8e01f3212ed86c0f30eaba97a0fdd84df588e294eccb23243d8d631cdc25d23432e4144fc5b0b6bc6ec0a3dbc73cb37493d1895fea1c502e7a3cb60d50651ede5ab3c5edd428f2ee080a37a8a17c0d7844afb1e720060692e95558dc30992e5a8ad49d405205e0a3f163ddb9d5445254c8ff3e284ddbbe84bd2fd1e1c2246bd4e5c5041a19892dc9d229718712f3c498cbdde7207dddcc44f51b5ac141b265b7faa431495188d0f2ed754a5115275beafdd95ded0979920e9efc1e67c777072849d7fbe239534551d9608fc1e26a939c1cd4db2f0fffc866d5e27717cbdba7f43e5d400cc1dfbb42b2d58e3e2c292665a984e2fd9e3e30d8f906f8b11783133ef88894bd15a248d97d03a5ea6c08e79690bf0b9850291deeea6b437cef17258c7e4ba6ee337edea42435d8f44827d1d9eb35ce1418fb43e2534d2a200fcfca28dddfd73dfb5e906db930b99fb71278aa1f60a0f2a25334fb1af91557fb760f9bcef0c8eefc323c5aced8880991cd2a8e0dd2c75af554987d817863ec2a5e9b4aa285dadc75d7a291ea64e25fda13f8d1655c51e89a7c9687f0c6ef7b07e274ebaec7e8bb52a115e9afabd5e672bb290b18bb457da15cd8091653225d2facdf5cf45bf2b48d1c2e79ec8fa26b1ae416b8458717f8799f272e630f9c58dfbcbb93be411442396a16aa5a1f0595441f9f94bfdcc169a96b5b9eac9184e94fe1050ee919b0123b7a07cf477b9efb1423c2747cbb1e6cb12f7ad94afd37c1614bb91034d6d41d79b502798f1226fb882404ff611b3de7f9f85beccde2ab526ca5a1af2d06fdbc2fc57afc177e2415c4c414902d238af29872af4646115f1b5ded938904be722110d0e85c6a599f47d1f3fb770fb2ecc550eac49ac4d20c8a5c43d17894db04c6d722937b226f4410dfbce97727e0dd5658efa5ce6b4dc53607f85ac1fac83f8f113c09c2230d3cde770145a2531949f1ea4af8dbc65ad3b44f368698c1eda38f89d598f42c0b1534c1e919c5a71525cdfbe85dff31dbe0193b42e01f52ffab08125f064c0237b117a484b963fd955dc28a00d882af198154ca6007e6ff037b86e41e2721f7e2f6061e8cae831d0817a65248a33acbc8943186d63f1819471658531f6648d0aaaa1daccd3a3495520c387dbb54ac1ec8eac9ab908713f6957467e97fde49f7d932fceffc699c9a462d9f14590aac6343bc92659308649a09962035f38b8427bfaa40552a190a6f7b30df08c588bcaf2018104a94f3127e7cc69b192d850085e7ac0cca637467fc47bc72801204ed95132722555e146fdee418385742a877a3ac55ad47abe9c45aa02faee71c23476388b9eaa75b57a1c2c78fa14b242b90623b436e474aa71f99add629963bf56eec848b536949704a709d5d8f4efff7e7a4644af7a965a684e64de6a1655fa38a4280b595c179510baa456d0df807c2b1fc996bf51a49e76f0f0f44e6f66f9c64f683702925394ec0ad50853237ea779847fb8395ac48d1f88a86eedfea11fc90beb77aa083e0c04e1484b1c3493d8ebeab3ad1c89572f38d0bea8168e25215a7f4cd0e7b7a7e6708d7a5a25ce520b038790254b0e969f4ce55630d6696c7d633bf54010eb37e24786a9a53811b7728ef7e8ac987364be0c3c7da5f48637a9fd2f7d5e817619f88f1c96ebbcfa96ee4c4f974d734a928502cd1caf550f48b0f1f1fc740dc0cb172b1111c037f5a641a429939e8359cc1d4bd87b0a057c0994b52e53562bb6b2101fc882af867694dda94f29d03be1d1f6e805fa956adb79580532eeb7326e194ee43407bc9390c43c976b0b9d58d44a43933c3b44a8a76c401d8be67f937ddd9eaa877b8bc11dfc6359bf9f73dff63e19270e10dd9f0c047a54440846a1cda39f7de88129125f0b3dd81db22621d83189118c7e021361358ed2aaf94f766c8d700850fe9a2a1f881e07a46e50a01f2263711726310f7977a9a9c5145aa018aeb11ae05ec3fa8e667e1955f44b3c78e567b0eacb138ad733d883e1102fab1f9aea904e2523966373267f6483ed19595cf8015279168b79471901ce3e430cb7c1bcb5e99cb05232311f4b8c995eaa5aab1bd2a35795e89d6b95c83024c4e52e6741a1776e92b230741c49c975ebd6e9b2116a0ee9ebb234617a82691f95267e3a304f65734aaab1a554f56a574343e2ec23ccb85e9abafc2fd90dc007c75cdcafb8969b18502bb0f45db74ebf16094ec064e5cbf9ee96686b43127b385e6a443f85fa711b38475011479d6f7b4f4d52c8595787f5cb0691e6a931677232849097df9110bdc7971547763cf83b53634c4cf23b2ac39254fc278b567d18fb7a82724664134e03dbe4c3d7fe52f568aeeb0cb81afe38716fd1beea3e204d2daf03d605486e70aa623acf0e06e8043a4a163e1e14c2fae8cc5e7eac3b8e135736e08570cff352e5bf83bcc47a4411e7ac7bf4477555f7e5261f7f1e7f6ae9b7a6a0aca07d10c077b00611e5c1de474a8c69bf31b6109597cce9c3fd4cdc368965c5de31bfcd3c2456f727726e3d39cc4690af3d921998a9ba2784336fc4419583602144c1141c2b8133a90ec2252bd897a5a81c10ee99f23fa3f692cddb0432c262c62bd13fe20ff7416a0de94abddd82d5126e46dd77574e9c62b086f3076b11d98299e6b5c2d8a5cf4be809b2968386b3a7a6d616ba267794a5b98dc13f2ffdf2362b2a9d3a8eb30401c64a131ec98b09aff5e17ee24dcffd216b380f1b7a4f34c82945cffcb952367c66a90a877b19c8924f1036ac87f8de519a9a184deaf2be41585394d02ad31639e3a9630c3da1995650a684b0bf991583468adedf321bc75ca16e6935fe9afd90cbd655d0d161474bf55091a4b97c9ad1c526073b82bee85ed0ea5b6c74f0dde126a9f04770f482a3b932070ae77a7f96c6570c0020ea2316cdf3e79d721da087744a9a9084cacdf0e3e03421ccbcd06bd619118cbfc4a8e4a67c8d1b60e50219694331eb64e968c8e2be98a11b2e928c352f95f420e51d6f6ed3f0fddb95e51a2ec735fa26d2bbbc14bb13b83d9081befb2b8ba23ca56f188d4f1c39c45a1d367f96bff12e5552c9e7d5de53715af565d13e98c6c6199e1744f8edf12707d490a546e8770f3622c23e8dff0baf23e83517a7a8f735da9df8122383b4e4bcadc7374b0e7fe4d52a8e971039fc12fecb7368d5bf227b1d3be5811f983e5d2b028bbbdb35840d0df4cc32fe31e0587781cab0d8c939d67827d5ef568c199a662892cec9757e4c3f7ed37dab33b76c7a2c780e570389ec526aa507c6b8ba366eb00bed26a8175b98928856d46f8269636c2e0bec241ff9618188d99fe8a986192147e2fce9650c9db1b6b4eb39ec7e72caef15599783ba761d8e7fda18b28261af3d277d11b6157e4b2da3b3de27de468f6fd42047616d649fee701dbecf091be0fe6a384577f5bcaa890102aa7a1bba2a959dd3eedc63bad38dc9e7722b71ac0d2f2f44890e0859de0773f6435979cc7fbc4926222550a9ec5ca73cb031b89e1d3a7395d826c50e91b57852c30e433e1bef037235fef1fcdb28353952b7a82335e94fc5fc88bd098e810dc873d36e4ffa24d33edb30a65f5a72d3f91d710b1b598943f6094375c51620930115066084d4c800ddf8888367323827d10f495c108bd27fd20e792c94d1ea9b7f5e28b833c73f078466adad80826e934ad7a0c3205fba7accac3c30acad6f42b9a3980bac0fd9eede366f6dacf7bcfff78f9a2b06238a8b641f232dc992b4a3c93af9b47c1d86ffeb2573946e9435d036469b4bb91f94cbc87be4fc9783152d36395c516d051337d301158d7be711591caab097fe93dccd2edb92e74f2e01a75090f189a1ee2d7b7715990ea9cb4901a6c3cd2da66ddc1a33c664fb6a9846092ecad30de5ae0d28cb48717835ef9892d4cfa5e9ebe83e359ed605feaea4c5ff67a3acb8553238baf27cf65156e3a2cbb56d973e013e9bed6515f0e9d6a26bbc9f1dc2eaf1196af5148d413a7f718e8b23e54ebcfb9fcb580f516e21ed1bc0a0e9622c560a24884f2f18c59c1560f845f54a9880543dc135929ead82d2921b56e168a2b142474ad7017a50a55ac413b4bf4c4f65e79a99d2dac863d47abb517ea7c121fdb4c8eaf3f718c3606634ef6c379316270b810bcfab5b20356c204f38051ec87a36cc3031b568ab708aeeeb3e9f94bf346814e448cd10824dfc86f3e883b9d4a8db814d6c86681857173c8153edec3c58eb0d7cdb74e854b51c76cbe802775ac3a0a470223d27ac81752dc65173979973e2488aa4c6e926ae015eb392eba2efc756b1087e2a2d7124292a1f692b5794f7175e7aa7c0fb1abfacbaa6bb2fd195b0d8c14c8ae200268539ea1b25cc06aabc41cb4acb2e93eeb80d00c63ed18dcd0050328727e22120f3b6395ddc2bbf8573926fb0589c1f00c666c7b16077d516b7404099b1b5aebcc9d88fc74bf2ca08b32c2a8b85b59f043445a11820163c1eca41db2e9c0af65e83905d337bad851c2465cd9df2a98bf0d3d7233478f43da7e379a9bf0dff21da94c7747ec3d282d9e7648bb3ac4e9d1396c6ffc69c18b71d69bbc0f5bea016ee736ba02ef902f6c4a26e434926ec96bebd5ed34ab3db82668154c17e6dd91a59756f2c1c359e48f375ecb96dadf119ac6439f8622b287237d2c0d0055deed4500467830c1c086a8e7ba03e8bebd6f1180962f44b530a7519fc276062973d0dbeecd91c845d29b2d92bebda42b7676251df5692110da83eacbdfeb380eff871e8ef7fd3639a73143b7b952f8732524bd47914fd91a3bc4dae7c9ef6552446f831d75605a992e811f4ebcebf295a9f4b7fb41c110fc1d4bd4931c61a297823cba2c8d1f3437406331b96019a31c731a6db3b9a731074fdad43a716ea692d53255636fe7c71bfed921f2f3c4f9725a860eba3a0a0de7fbc8be4d0d8d51b2bd23c8b7ab4bfdb3d0d7f67e3414212fff258b7b2ac1ac2d3dd6e1667f636b02daef00736f917cd4e922ca0aa17302ada16c27fe9b0eaab30a7619e9260ecddc97612af97dbd544f4da83c46c7b0dd4b110fed460e2fe1411d2a5020fcbd1610dddf715efc052864c4bdb1b2578fc4e2aabf04c996544bf550f07ec86bd0f3e537f86234b21603d6f03c903a1789980c7ca7ae7c8893d77daae73bc7e828a993725bfa5f0815e86ccc1017279c4dc392927109cff11b24aec7c4a87e090c32779a12bbdfc84511174c52d19947822b25cb54a001638e9b4267148e6f7bddd53e1b222ed23b13b2a2b59656f2438a9562bd32c0738998dbdda53048848ec12a09978e6bdcc55723ebbb21eeaf1f8910353e8a9e26f24f856f92fca29708db4321fafaf0327b8846cbcf4bb7317915f7748ade75e85df5fbf5b0274635550566fac1b73b4eff4ef36656aafc370a7c0070593e2cc187fe672b92ac1837ff73d737b79dff70210d67065f029e3773bd0e01e882f84611069b423239c1e678f3f6125a480a1506a819883fb26eb81ebcd123b189d9b5b4f99bc58b987488457938468d65cebd067d87c7e38f019acc0037eff9bd59d5423ade4b8c3e6078a976316d541d6a69a6a36765effe8a8faba9c546579bd9f49f6ccaf3dd09d3704c3af32cbee91c9e8c4a7163fcc93510f96447397fc91f2d973eacef2b04a78a08a8de3db746271106919ce6cd63bfbdcf0f76e58785427e82d487410d88e9076b322ec71295bd8225774bb85808b5f25afe32635488392c83e2df105ccc8903e824c3ebc180fb40ecb4a2ce6646769367ffc2df278841ce8a56707289c54e0301168b26ebf066c604cf9e1d9d4c4d1298dc26cff03cd342bbb57709acbfd445d7ae2aa70a8ad703f12f95e33bb658c5eabad58b34295c49f15379a37c5c1625de6b7c9658c209a20cb0ec0469d69e1b06b6aa7bc60066a514e396a8886f278148e6e3cb327017a5201dc3038e39f71df5bd67c11a01eaf36929806f423b624c7989fff69892c058e8206f963243fde5be73ec37e07f75bce9f8f1ae61c30838baeee4080edc5d3204497bce94b35e601840a0e5c7ede2c9810e3b2f54c291ce9da7ed2baa6e0ac7b2a1b97dda80f869b237fdefa02971afd2fa3ac2c290461ad84347cad6b296f3d311c3d5a39f2f4d26680425d490e6ffc79e6a29b69a23e2d6f4ace818d4db123c890104a1a55425649a297a23c1f3d6d81990c8913669f20741aff4131a4f25b73ed98008cc90176437856f6bac633db458e094379db3423e997d53a54f568131768d8e755d600100705d5beda0f3e84f2007bb4f2995ada2d628f55f0d4e359f580fa87e9ba3e6448d490ab7ea5210104c557be1b7d3c359a2fdaf0d1209482b513651f6bbc6b3b576756886c9c090c349815aa7edc14ae50daf0aa08fb005d70e2bb7964e77e17fcd3270a724a06ba8be191c382d1a99a13715d92852f9fd4362a6be37569c14a3a162ba57d5cb5a9cc628fef531028447b96ed31797edb848a13216b18c1dbc64485327d74d294c786752ce8951b8147d3e12d11961b0f7641af89287a99ba2379c0baaf90b1e00ad23f738333ff280a9680ed43d955667958bc7419e37d32708f3cc752ad231e0c83385982a0c51f9db15a45d253a97cc0cbc1b7804a34131b177ce3ebc78e02a73e14a657a022bf8bc797d33aa7ab12d73b87bb1c71fe7fb80033d23c79b9de52a9d1588868ceb34d4b3a40d505565585b4dc8cde4e41aef2c77c69851a062272b4ca87cbb25a98bb71cb93005d38276adb29803dbaf64407b255c60e494bd5e1d7ae60904f9180482c83f740a606a2931be1b1bf54b23e94c33728e6c2d083db040e9a69a79369b3047a5214f753ed8928d017bedfe589a1c1179d666f901e6b435b5e7e00fcd2425b084cec2dcd197a640a719f8eb8a97192d1fa9b4780221b1c990cebd13df8f4a18b80ce637f135a2307ea31ec4e6288b40c4114d9701883dd41dd39571f7ff948ff4644653ed35893b180333f370b473841a6b7e6dbca4995334a71fa1f3d91d2d4a7ac0949e7e0bf9d93d96007cd701ab00da006dd0ba97704923dc337c41d5925fec0cc69b52b7048017ffb511fc34af07f26f1d7a683adc326da9df44d8a9dd783d3c10b5f86604298a92e8c2898ae501e3423a360194f8bb4b36bab15a547a923fb5efb8625699d712f9e87e9c1e3f5d23f234cdf89abd74f02877691037a678022978bb44072e5f23ffa1f8183c9c65c25b8bf988db49eca598a2a96183e2444fb70bddff5b6d43a0958e0c8c442aa6e102fc28d5eae83b8c23ed5a95b390ff4037cf25066ae08d9b8a87155c44fadb9c5979322d1d0440d2eff2a16f23d747a63f9a3e57bdab548e58e99e041db6c9e7f2e6a6a58e4d0ca5bfa58cc5ff320371cf1ecee89092bdc614444466d02fedb4e4772fd46451aebccbf74335a9b8f55780797da6ccce955831a1e7d6bfb2e9b5b7806939803eef83cc3f43047c0b5a61e447067b76625a077ed79451c3c50ee3588faef9e7bdddd4f3b3f7f1d5ef01f1dd8edee9326316018c91dff97d5e6d8d3486058ed208a9c02774af25f8bfbb583ab7b8e15e6663c53ce8a40d75835f493b9cb221ed5b9dd45913b341c7326af8f4cd5f80a9cf8a6ce9b0447bd0a2a18abacfee8d2fd355cb9edff01b62c21cf22283b52d7971717ea3b04ba8704db1a768eedf091e452f924f25684fe16560c34de0a74386e587445ceded9ed107dbc17d0bdcd7c541260c90b38439744bd8825c51cd1765664742e1bcf46ee2af622169d6b2db757000923617e95d0a0f8120b0e5d861ecf048e0bbc88cd0796389e7ebc69ab66ff225f0797d5dcba4d46437a63dcb017a4582dd348aef57d13d033b0e7e9e092bb8a2dc84c60233adcb1f6468f143fa84b5d32ac13ee8716bc7c07e9e954198b8b9a39f17a5bcd0372b8a58956e45194f72a2e79929f05e3ac7382fc6cb9bbc3ba974bcd023ab9ac938017c13f3d4bc6d30eba3ec33ecca5dffc47e007181faebdcd520ba37a7aba6a73af17b0077775e8253e182711df7769b14c493b89bfafa722398411af60f7f9fd3fd88e6b971c5d4f23c694646698518acbebeb86e3db976c0b41dcce4f7223faa732a0cc47f57c19fcc029b8cd18d704f668faad161a667ebcbb13b74febce03e72d05f94d16b26fd64a174ef61f7b7fc7d6505eae88637f28fa3a29791469a23821769591c102c859b3eda66f1723c53b5cb5e0437c7257ae7daebab0b9accab9fe713482a0e2c11401a26a6d6f30f001a53e7987375e6d0676cdebda334de59d0f5e0f62504f462a82686233d0b79eaeae0d26938b2e87e5920ca91115f570909feec5be631ae4e12905fad768277540e379987b839ae2e0617747e0a69f7ecdda0f82e0a89b7f7c8471938760d8a5723603b67f87d5b1e2a96e1922ff8e48bf243c81b0d9a92e44569657beb72f1bcb1f3f03ab22436ce07266f9b1f44405610dfa06a791b41187a9d3f31a1c3954d2c996cbb024c397514463b4c615e7e4fd89ebf2c7779817329720462585bb42b8f4d68a6a9fe2b011e63f8cfcf1a385f1c1ef9433012013351580c87bad5db16b49611f03b3ac1fb9c1014aaeb9b8b4dcde6f2bbe8df53188ebaa5f58487e25700f0f13764dca9b90f0500a4ba71d67d6866bf102d7dccf3f87b027910287d7dcad9a39e6d05bd5249e01c1f49b049da8b796e356884000beb8bb4947f8fe52638a45f79f4f7ab427e0ed063261125bba3695d57a3a99923bece05cb6d7d6f6232442d65e2be64c81df30d8651962c4a36152e1dd37b0ff3d00794ce2d2473cfa0aa3cfc450f1bcacf4b53859d0ee831e69fff32cd384bff4347d6039fccc5ec7ccfcd4a4b9a591d66157d92be8412d9b5a2ebfbcd6d5368a3b5ae555207d576307fb0b407cbd0d70e11895605b8a22da36a4a5b189930b2cb4cd933e1b8014659d81339ab9614d6beaf10284a040068e28cdbc950ef4d4d12ae36d34317af9ed821394c8ea403a40f95798eea3eb7d01ae070404874f5809a0f4d37452a4e0aeef754f0467911efa827542cf24d1f740e42631b901323cb7c9bc1324392fd07201b3ff5e1c2e19c234d91b7766cde29c18e2f40057cf53a3c8afd2434e6bf22a336df4de5c491a140a653f9bd1222ce9ff25a663ccdefb7ebe0c6e7614ae8616ad7ece92b56a639d2eeff1b9bdfbf7f56576fbbee44d5af8e0c3348b435a1c8683a7a81919e5a2a9979d37162235a65fa4ae89af231eda1e2ec1afc21e7292435a2f3eb6cf6e913c90ec3df4c9f09b28dd3bdf61ad577a5797b50ddea25fbfc42b36b44bbf1c3373d6c6ad2aaf4d1c0e49c7d0702d275b84a508acbb5ecc9193f0a4b284f8eec9e24e287eb3171b1c30663d6681a90d3f766c119f63a64c987018e3a60122aa4f99dac40f280100430b7088f1d1cd66dff5e5dfea51036133bd745b8ca1dee9f536e4b695577006acacbf9592e65466ec436e1c92526fbfce5c9a6a15af89a8ff8528102ef274056b8631c5877a910e26fb0a2dac0dadd08040f46675cb2fbb4750dbd17c94eb8bf9c6821e332a38b3610b996c183645339197fbd620bc626846deed2939ddacc430c90305a1c6654a4b6822731738e71d6acd9c9b3f4ff70289a146e6a0149a9b1360c4c1feb66cf0fe0a8b995ab22741bcfc1d3257fc8460fd1d13b06a1297c88d664d680265386aee12c490a89da5f354919af27830126e6e2968647542f18f40c1eed711e6abf2c5cee399d00bd84571a9c198dc6e3b1e3c619121ab515b6a842fbe9b0cc3d8d7599a5c206b45f2bd39a23f3c2ad70036e8655d9ac278bd2ff40cbfe4c1e7729e7ae44312cc101de8b32d2952bf638399e87caae538c65ae48e33d792469e25d937e6c597451d85fca67aa049a1b876f7a1c6f31d401a6e5a32409db227a10032e3d62692d51ffb0f435f4bd7334349b7d50f49a2247e0558abb3d5d79f73f91335b790ba2653e3da75528d391e37fa8b6ea5d5befde12fb55dfb22020b0e7ce64770f84ec9093d2b116a2fbc12adf0af96f2967ff0f7b4326634ee31125f966844b3bd894c16f9d33680f61db699d723f9c57d8445e23c41b72ae045a6a72d324b3273ef295a5f8029e77361b1780c878bd9262b04036db73f3aa0d2e224c0b7e4ccb6f6c1c6e769e7031008906bc6b38d3a2a01f973247d278b5c2316deeccd4d9c193735bcaf33568444ef8233725c2724f9afed8f94ba5e756497493048473dc7506660feddd95014271c3d6df66f4b269f71360d09aec78afe0bb5c309ca374e303d4a8b27be78f9ccba8d9081f4abf7a6a580e793d08877ca76f1bef0a61eade2c045c5a4d1ac6f51cec2c9eea481a8dc2197181090b789e26c633a931d40469e0a19c50f61dc27a55f0833499b0604ec495f322a5f5c78ee6432b039498d863863f9c9118330d49c31b7c851f6d999055d5005b72da41db1fc10ebdb015ab510005e077fa67510882f4cc5cc28af7ff115f04d257bd772aeb0f005afdca828da7be7d824213db03c53d3efcfa094262c4a62f4a4bb19357a62754065d119221618f9c92b4d4271f5d2bd9e7360a5adb857014180529ac99ebe0b0818e2a3218ab29c520a511b4a6f6d5f7c7baa2fd91cb99574fa8d27902a00317ae6a2bc64648cb46a677c2709c43c83ec801abf038a4f744cea50d3ec825e5eacecaac9da695ff8e5f58931904d1102dd0e232c67e15e26d2886f3b271364a9325b3ea9a522543a51756841a1cf35447d986cb91d21f6e7bdc52e8937723c0627d1641b31f892e31399a44b5cd3e75ac4a0d635f2e6e9779094f71cbd114e1a38ea35404f85c61a591cfd9b16bcc0d3791d38caea1d745e07376cafe258fed3d4ba79ad81433389c0e6024683295653eadbeeabec8bb59281b7236b6c688f9bd631cbaba0604a39ca7419459518e11a432a1cfc8f650daed41f5fd0e8cb5c6fd0c4f2eafb3a7733c71a1f7b8bec4f30a05036b53f01805794b68cc840faa44dd607cca7428be890ea0f299241e4e87f750492345e5b7d05a4d30f73bde0f25b6added5e2e746bd628b225877ab63c984074ede31a977d7705de1914de9f0b839aa571117714ee6eb0be3c67b5a8eb4990dfd2ac0973477eee52e5f3573419ee2c58bf48b2afcc11b8fb8d9bc26184acc6cfd1db097b8555ee1af30d983a4841b635870cc20ed613836e471dae26f8635e4cd143f20ae46e25fa35cb5555848bdb25f9c03d6198093a494af506ca26ad68d113db3fddda2906c9a1c9c736a3090cbb1bdd715fddd086c741b3bc378fdd3c5d5dd585e577f168c7d285b0bd251a62b3ce6cc3397236865e75ac6de6c39fe8305fafb451c46819e83e4ac0624429396f2f679694c96c84db6c2cfaa16d9d64f6304f56e5846b3d5c6ab9923a86faac62967935d93962a40ea14450cc774b06ebd071f1ab2db076901eb14623d473ec186344c2325460eb80b0a8bc01e70d8efe9d1243a8bb4510ba325c2b085a276c3bd56310b8c6650c473439b8865df87ddf5fe651a4e1597af1b3fcbf3dc78114e5608d6219030b21fd607d2cb7eb879475cd2e445b3a071dc47636860c703e57f8e359139c796db11c43b18da44770673bd38fce7a4b78a7f77efeb508868b78d5a5c9af2f441e1c959e8d722b708d52957a685b12eab90058975515aaa22dda4aceaba12113a725942bf3259d4644e88ff9dde387501fe18689310904a60c648aa265b5ea011d265fed26cd6e8a8ceab8a9b9abc4726a851b333942a897f922533b0eb290b33888c1e7492c11d9e983525b4eedb4ab5f249367cab0a06657243b87daadb4f41e11ca7ba9c04545475833c73e5aab09d608e43a428443861975e3c406fe898d3d5c000abf37b8c45927d1db0805342b31b0e9377a34b7345dfc39f6b4f0fcf9798c83a82913fc27198add9345a138f0ecf6d23c354568e17bc77b212d88798488bd6e6c8cbf58d3f276e926dd983ef9c1881fdd96384a593b622ee6fc5afb02b57b8738feae72044656220e2f087a5482301c737ca0aa5dc8ea7f33470dcb4b7c31d5d41509e915d131a8efe1d978ab2907aa63c39ee87a16d524a3d48df9d428a364870f0dd2eeb00b4b46be04a5dfca4b2df57febe25823c80bd37ad9cee8012b48f73f6a49e6464c3bb47b66cc68f8c144d7c85f4536286844145eebdecbc2d06a817e2b4dd4577c18d26c0d0fed7ecfbe7018b15fc0f4c08ed2612316cb200a879c68e39cb4669e58a0058c32976f5fbc5f098f71f26117bc6bc7a905662fa166d6d15987ce3e3d7eec869aecbcb8656c047fd803a1193cf434de77c111c5446df741f57eb6fa7cb8079d4e78a1f923b0fd7e20953abf31623621de0b001d14a6b7341c9fa55ed8d5bf4a42b00ab568c3cbf3b116e5cdb41c06f494d0dfe513af4dedb903cd839498014ad49687bcdb5b1ec5b4d5124cf3f413666a084bf8f9c111add89071c1e4c09bacf3d522d579547bb9f9bc1e161296a1b50c7ce6a92cf5ef079f08e516afd47b6cc1ff37c412caa2bf9d8afcead80b73bb24aff01d7732e058374aa0886331ae91c556a4b46e05a0a319de54b6efaf9e2ec32d6247dfb90fe9e25385ce81ddabf5f88a1ed5f1849e70724a1449787ea0ceb980861ed68dabc671c766a876d4e009d1b73672747a141d5d2b22464b0e0a0d53b575a4f7c9c2c39faf28263d0df6c275fea093c979ab7ba7115dd4b5a21a16ea2b673396be18600ce15880164180724dfc387aa2f49367ebffcafe16eb182db573e2adfc67dde5f60174445bf7815ad0576739e5d469524f9672bd00ca9266e00a611164b8e1d2069e1e1110e129cbf2706a390576b0c749cbc074980c73ee8c8e112d072e888ab4de0c0cacb983112b499e561846c","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
