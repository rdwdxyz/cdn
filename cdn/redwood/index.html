<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"0f0ce5db5e255a465b13a89df5f29123ff838cea6e2db0bd3d8d409e54d27d648990a2418cc7f204be2d36e08fe9aac31ff67e7b14b5228d14d80b846e9ff05c0c1466be74ac7dac87bde8634e043696fc99b51556dc935156f9331df5b5bb6f631ba43c8b5620ca89e1a9bd975103cfa8fd6737ebfbe6e063cac16751a2905f57ed8069cbdb7105dfd4ce82ca0a63c7f5129008077ab7545a25db7a8167eeb7c8012f8820be478002b35e35698cb8c70beceaf4135ec4b03aaa935906cc48f377cb253db8b8ce2b909cbb8310d98ffc52141015c03d9402ff9673947e4c8449e75a7a2e280c14add86772ffc7bf4d927b3cca4caaf704d75677608d9afbf4b8f69cf187df747b21735eef46a38b9f87aaab444178b3ca7e8534837e3c805c74ceb8a41bd489296e42cd990ed2e4a1e05c6812050e4e2d27cdf1a250bd107b57258bbe2d4b3063595da213d93b817c4dc4c589a3d80dabaf6d74f75c36f2214ec539486cd242f4ff9e1a8846d593f7ba5b101f3ae1dc950648d1353dd452b09ee62aa92abfcaea04da7baae4c35215e34ab9580067b42618aa3997d085db97ece5c621f3070a14864b91bc7eb4d13ffc523d0843ba0f7b4a06b14c85951b181f5ef1f0314697e102a141a32ee7df9822366b916126ccaa34dbbdffd3ef3d64e66a6cbd1b8e99bfff99c2fcb092071b260817132d79177a2ab3bee83b6439525a457b9a090e6b66171921f599448d8529e6843c27a78bbe933efe4fe089a68a9491808572ab454babf1f0e8bf4e7b698952db073360811fe894934df7664c5a928c9244539b8b847cce6284379528c325142c1885e213a42ba44d06d4e3b46dfe178d767fb96763514dbc89c70c6f08b3555d6793317741c3e0e01c0ce81718ace36e7f3147c0554cc08f6427270e234ca5305e4aced9e5f8d5e1ec5143c45c62ae46adeb49f0aabad392aae697bc3bcb6ab646ac70c08614d42366adad467e029a210770ec7fc872b3c7ab9b9bacff029edc685e7afaa634a8524d17ca4a87aec56ccb33de6d0a18d9d5d5e41722d3fc9ff0a21acbb3e3fa48d119dbf76c6431df34ecd86417bc96d2f8a923bf3ea3369520758006f8ef000639a84b0c1b03e4b233ba84fb21342e007933dab5d7f71dc1d0227055782ecde978b02bfc0dc84a4a8278e508328bbb02058511a1dff37cae94eca8279861c5da5e77a119dcd4ff5f16974847265dd0f6a07b74680fbb50f089e277ef21f639fdf1051db844ac7092edda0675050e362c98b935cc2dc11813c8a6e5a8ad24e107eb0419ec04305de6499e5a448dcb7b4c06cc014a28f8a82a3a6df2c2c70b7e1e779bb7cfece09a50e5ef1b67e35f58cd5af98fb67430160b1b9f7c67070d66cd9969a883ff4e4e350f0fefbc135ab0ced851a2a1742455ea5ffcd3282bd939548f440f61936fcfcb80bfbb9df5e403fed0ead5ed598d7c56c7396f60937ffa979477f3d5180f7ade097be0e03e64faf7c7c6937a11a440d91167161b1f47cd48ec7570ab956c10830f409140d6b1b9bb7246437421cb6e211b02675b5ebae600479fe231573e67cd6262ce3f3d5619326e48c4cc0aad4320e07bb01926f72df4f736b64493eff53e8e5230153b27c60b4e3a15726003d0f089d71841f97965de8359ef21bbec18edd2626dc454f52136960f0697f950f5cb5336af157a552aaf941dbfe7a4f0ede2e3a17747c379dbb23fbe290e27728e42e8663074e9826cd9ee66eee670f2cc311efe8af168d1366e0768e081c4253f9d580e019cf060d8fcf03dc69cf825045c44bfd7955a6b7b2a244bffb931025c30e34ccb5dab024ac59b69d92ffb03c8cfcaa18800bbb1716538b02861cea0739034d40f21630c7ef69244aa68d220a3be9efe7f151e810e33df846c92967db7970cae2769532e4c18ce3af32f849530d55cdd86fb0bf48c05a252fbcdd715d9972ffd80f74afd01daf90fa3b7a0bec328d84db72e75ffb6fede16b1c2a9b7fe07591891783a23dd515ed8160f75033fad497cac26d51349d5db1f7e7c086e5530cea87a488d65704659135fcc8f7a834d7e0cad498eea50f1108c918f3533b615f13088ae3c22f98d3ac532ac6407ed30a80901534318799982b3e8e1d787d8760210d6f0ea6e301528252f9444e90e9dc76cf7be7a13d22971079f6fa238c1baeccd03f908a922a8f77e2b0e35d7f8b2ab18fddaeeff071060283fdd6686f4f153c11fe45cffd50c03fd2e3ddd5a98f7b4f00f672f0447c6f516a2469bbf5e935822749d76cbb339c7ce67c226db791d9be252d1fbe2f98b2eed7e3434b572f9dfd34b045d04501bda55306b3f4a1563e44df2ae0fc019f3f53d8857113d4f0850896f315a4c49e07046b71784290ea0b45596690f16dc342933e55866fb1085d0dba2165aef24914f1217ba7263adca91ca24e145c79dcc92acffc302590e67eb653c6edf48c795f8f8c1862088a941e7465230c3f502bc502809ed29aa482824907de8393945f312b3c5d2152d58df61cbf33f5147799e0a61882d04cebdfb8f11a0cf06b4078578d90b2e00c71ffc2d246358689086070761cf22d0f827f07359244e9ab90a824d1e8ccb7c585be1718a6a95fe8fc4d58a355e5c9092132ec84bd2eb72f45556ed3eb1fe9e9f32a4d0c27f5432480ee885297404f9d7ef6150e3b1b175be23361058e1e4e9169d6eadee0bb641065585e639c94f3ab338e6a5560dd757a91abe4b1a8551b37f1c6f6d0e392079188eed388524502246264dc7a3dab242d42726a236da901c7782b378305c9ee7fe1f4b4c950d4e72478dc77a4451ffc161be840bb6c703c16236d47c7ea3c92f8e0c2a79a5d03df67ba130a9222309b91552352891161e72bbe4ae8beeb74c8cfb3ab0bcac751b1de69dc7dcd46eec5b55e2e3df970ab92dea50beb6a04e569e4d9c91124ba41da7dd5871e2eb0d05354fa2958831b8ef51812ce1096829522006e7275eafc1a8f282540d410ed14bde759c34775e801a5fc2ffa90ded551410c850d529eac46b6c02ed063b6a372469a8b828277901b8a48c8954d626c89d83cbf8d9c5d040942b4b6e15ddca7fbf6bf7476c60b93e03b699cc651139a849c1b0c61b2e5555acfd1750e51fa4fab3bf870d7225d3b95836d62cf44531846f13837112e7fdf9d6db86ffb25fddb47d13001e1a0accb0b8a4c4cb0e87a41b3e44751f259c9964c9e88cc63eaa16da2f2f373a2c7b5d5288943b4150f8e60ab1a840bbd36925c139fa6f6ced2027635e867636cb84c56afe14a652beb2cf186c571330b1fb4f1b728d6beffee9386ddb58e37e93432ac5e7a0f7b2a163eb76d2deaca55fa51827b594ce20596357c5b286ace941b9a09beb08c3b478e25f0e17f280ee41df57d8cc71a32b9aeb139c322ca75330ae6ee62fbdd5f468af10ded058e6bba72b2511827271b7339b4e210c4fe23de803c012356c2ffc77b58c1666fa07d9fe78fd855ee02477e9593a30b4e491da139a2816c9edd5ac0819477d14fd27dbc792e158e312340800056eacf1aeab8d4569102f0ab0a07f7764c7ffa386eacaf028e43d7f0a4e3681c357a92415c34c22eca2155aea38319eb09ca63c661824d6c7adbe4d9b816fc3548e820cec9e39dd32ab6f318e1d001f31bbf700dc5adfa70d00270c8434d24fc992272ff203bf4c98fd7839e137a772f945bcde7fdc4aeed9fc08ef86ae22a2f9fd01160950785b585123285afafc4a433c9b429fb94f22688acf87afe9c829db3071c4c3962232c9e1e229d18f12dd8d534f07147881ec23636648d6f3bd733080f573abe7e4093eb715d236518888fc0c1d8de4de5222a8f2afe523d376490215543186af3d55cf006cf18eb9da2a1d16562c53b26f4a61163c3289c3f7d998d8de12a99ce6343daf870f1af6523512bf55698718fcd4b5035f71a0667eeb893f7d52f1e77c12a57aae942325753d6b83ffa4f9482283bb83d7c6507bd3669c4c910e6d4cc7e03491fff0b74c73cb72801fdb25b266dc555847c8e63013f58c12ae1657b20b58e43ad4d530e97becf1498a9f8232e6e56ba8cae3b09bf39e4c10567093c36aa343dc19f04fd7e82304125ed484960a790fbaa16a45635467281ca113f03589bff0cfd7d4edc2798845e0ce39df5baf0f3bee70c476e5b655798c912afc6671d3f6412e1d361f56eb83b258a2fa140eb83c40681acdad5c2c3b3564cf2c4bb3a975bd1561abbf68923932f888d5ba60dd58a762863471fa1a9a07f3d994852247a02ad0b34e6d2a93a204b21db7e03382b1cbeb28f8a67129c04457a252d52d0f4df5ed16d2f9ad0651586bf7257721ccdae197e305c2c39bd3f86fcb59910ecc1702bf59d79e05d5e9cab9a43c495b7039f827ac6701d6616557e180c0c50b9fbe823dd252d744304a8db332f69a7cd1b085ac71fd57120918c98461d2ab60697579063c4bfddb6ff149dc74f5dd38a1d0f4c87213520c2a17eab7aec69d0ef30363e7d7cbb89d9ba18f84809ad4b19d46c11c40637680a87dc6228f0f08a7f916855a3f6fd84f64fe6d76a4b0ce14fecf51964b0772bdeb5a7ca31b9625895b078d2f40e609287adc8d411fd709ec2c088a38468c75d54fa6b71e120abcd1e64f663f58e3d8b71001bef7c36c079163172375e42f9a2876e0c1cbf45b2d2044b00f6d3907148b83185a86a988c3be5ead415f2a722e4d86b7d687fca6a65d276f25ab2fa735377549236f9c8a62158598518e03fa1830c197169d063cb9859efebfd43913ffa2a93b1199db9fef7ff005b9b04a1a59ca42c6f1096ab0628e9a0dbf5f151510c12ac7058f82e1468478f08add8640b2eab7fea33b2dc4ed70b01a48fb5e6515e4a5d39e1166cbdc3d9158eb6b053c17af5e2c4881899ae7af7d158406b0f7348a205a186ffc6620190c14f7a04c72b2002517539b1ffb8e1a83040fa25d1dc041773a48153d8f91029bcff1edf40fa231b833db781135979939a6a6062124b362db09306664bb19fd1563f8f5c00699bcbb45a0491f751533deb590bdf3b62ab805eec095fc9e2dd672b725a393b0d94892814f30bd38dff062c39dffbe614fa0f29466d262163520e712f358febc898dfe4bfa4cf51f6f92b22575021c2dd2c8b2f90e9c4c2bc64850d283a360fa856a0f97ec17a489fbafc8ed549b18418b465dd7e833b60f54786270f82844136eb95c74a31fc7b9902838cdbe97d8327b290c0c1feead40931adfeee56e85165183e88ddf1e34b8e2f3ef024666991dcdccf2fe1640022721e6c0eaf2e2410bce3f7792762e500b357b712b29095cbb6f0eb6549aa382d8112d8e6d6707ce5d1792d9a8ed887210ac0b4c9cdf7b77272e00f38f1d6dde0913c023178015e9416082e707431708a0c45de8a066c944a62de54a7c4d1829b1b23986f8af546e655dc17223de981bb406162c8c359d0c36fca0def2b0e68f3d8c0803c2790e440ecfc03dd129fe1cd15e7dd4c8ecb8ee80dad291430dca636aa6108262195f398f47c26f89ae606a9ac7862658bddd91ff8c6be2efa15e63d69cb9c8a12beeb291cc39da72a8969667ff55c2e3112719722d01dfefbefa39a9ed50726afdebd5d6b1dd376b9e61e1d06d8257c9526df69cabfbadd97243660308f2fe18d1096105ea4cba19530beaff55c63282021d7f3b60d603d18c64e0d11a9f98d752f3bd40aef2bcebb8f13ec952e0abbd67c948c7bce654416c3a633e5467aac5b19f654093d91afa2e1a2e4b8d7d9bec14b467ea33fc35ed823551f85cb204ee2f0f145d3513a614c8244552d02e1b7edd4a7955992244f8b44e5f0d56fa0608365150bc3c2c2cfedaeeb74239982e3d4b9abe3935177ed8dc4fe8cf06e2683fd05e65afe0ddaa8201b6cd81ed8ea920ce53b123de79977d9cc3e843e225e6f0ef0299e1fface1a944f40ce2641b46894b03f018956bb1b0fc51c0628edd7c95dc4691f079c5a91a172f91a55f1c549aeac2c973371f3dad4ad474f76d0aeb582f6b8aa392b386e147b34d340851538432c0e896af66eac368ae83ee08b4440b1a196d14ac01bbf9c0446e75cce7ee1b60eef183d1300ec2f7c24d344922304f667e349a2b4156776a7a8a7e81ab6b437767c1b10616b29a67c2a553e5ce2f37a0f6960d1ac60f59cf7e056a72a0e4421f642a1a349696a519e7c982c8ee5cd1fcca9542f791f7790f217be898ff7612d10fd074156b2637f53cc5256727249aa92685b193fd93abd22819da4d4e55c2a5f9522b04ed84e81cbead91866e518e5f94918bf590959ce8b0cbcf1d16d82cac7982bb04e2c34874ea763945f047dafdc0c9e58bad1702ddd1d271b5b569150fe5329af01a86057b58d1ffceaabf0581f8151c0a553d2c187768e846426126af8f8214edbceacd9395b596191103cee8709ed4cd49e03a23a57e1b579fb4e2502e157cfe2c0b2fcde448aaf3416e0448824f72cc5177e891c0a32d110a9e6e2abc19528fd84c88cd0b9d516f9ebcfd3601d2df379df6bb294957c79c60ee47f515251a095e6ac0e8b0a36d2f07c634890b541a6920536280f044a4835293bc6d429bc64fee1437d76b7d9d0c51f5495a88679ce77492ed6b558a0103d3ec03f59e161d0b49820709fb0b6508cfb9163f50ae01050c80310af156980da3f69c36c8f5531dc0a0e0c1c4f0e7b70b33e5ddafa9f9514988a6d43956ba3662b7906b6234f134ec452c4c7ba4f07ff81d787e32c7dc02a8345e74b814db0f242a12513381ad9a89e12ad8255d83a55054b3d2693760128a4ed31e246778019a0ef905c5af7791aff41b7ace214ff89c6fa24081c3b94b031b4394a3c4bd6689d8a7d9b46fd8794a460a226f8d142380f45ca8c4ff069b6c7d0728c19c8fff2b154c4dd636263b4c4e3a015d06da896020fc83bb72e1bff3ce3a27b27b01e374104744bbb05c62f9f38b9988ee0ec751e4b887baa7f8ebebeee6f1208b126b38e06ce26af087feb5db105f6d90cbfca1ab2b4238b79f6626658ff69d37619eab236e5a2c715064fb5dc00c18a40b997b7db499aa28e847a0f0f7b7f1ed9a47194b1152e23793b6a4ff9f2c431aee569ca01f050ab358bba4ef56ffa0722923492d77e9028de4061d37991a2cf1c4f44ad4d213fac29ec88fe30ef424347782f3387954932b5fe3333fc7d1fc0de9b25ca5bc8b0a44ff56a32d969511da068362d08aafc5880f034ab0fee1291d8250bfc7a1fc3046cbac34d1f0b2adc52609cf056e3554eae43753486cbc91b3e8b897b6c5c7455ef61c8869ca8612e90967cb4e71f8612bb9447b6d77c82728ffa74a265c31ff64f2807bb0fac0bddadf66a19d00fde3b974ae5fe058bebfeaeb4c6ca4b1d1fe19615b4c8e7d8975ab81b54307e478d6ee532dfe0a6041596feaf402b91c15c11aa442ba7a6006c72e84033c4a1dd48dee365e393b2214d0610d24aeacb7ad16d4183a755ddbdf0994094913522d26989493800b697378595fa211a4f06559877122291af224f84ba34e2c00805551fcbd3ee800306cab188bb7279bb48f70b36f17b1606aa18753dcb7168e79c6a57ff15c29a3e9e2d834acb2cfc3cde2ff38487543bfbd03b21835a48cae3521976c0f6758dcd4054e70f2a31bf7137727e011d39e35364e259912c8a7418ea406d3b018b839556496ad1debfc9c5b8859fffe4991b6fa0422119d4bb849c0a8fffa74294cff86537fdd30270b6b6b7d4b68f0380a4da385dc96dec4a65c5b0bc3814b872e46d496de394eb1c022e6d4c1ee1cd75b1b7a41bcc5322df326a05b3603a2ec35bc4a51b84110c80cb616c36fc2b8fcba04814f688f9e7f1e6fb25f7c964c2859d0df5d24b669dee13d13a2f5eecc23bb18b1a779e5f5120106924dc47bd3d04d9b3382feab2e755a407e11e1eed11753fe3455b7607d65fb8978f3339c3bae3bf0b075d850c757aa1ab77ca1262712398a943ab3efa1f1334aba9b2db02aede0f75adb158b0f596646ed14d96bf3bc8ded7d782fb2825db0865970f82f4bf32da07404a8870a57565ac20e15d406f281f634dc1d6880240e9efe09dcbddd51e8b1862a7a827b495250a64d592e5a631a79a4911688f7549c5cd87d6cb63d7e4955c1b614f45d868aa920ef18da38ccd7f9d44dc49a9c70e00af01f3531a797e1b150867b575ca003f86cda956f8e9a375a709f15999a208dfb8041ac7922cb7c0339c01ed92cf9e6c3ff456bf041342d8b9f0fdf9fc79216711d0530be2b17f90acaedd59b4a0e656aa27f01d213633ec558dd7f3a038897a1323f0b291736cfb6f31a75d3d5e83fff89e85f94aa54fc56892152e7138e44647641a8315436e48f654daa40f710d03046307103668ee0ba1b32028d7b6d493d71a01b808b8ec5505f1a7e3e00748a83c16e80f02dd8d4d2fe13ca9b33ed2691bf5c8ac255635fdf460f8944f62b0a6522405c43defc64d524ff6afdb0efa452942bdd148e9c7c4afd6d3debc242846fe09e0da6ba8c2b1c1b432270f03563596066d4a2abe423f1773385fb0ccd467eca475f1ec980ae5320c181293315f64c48e308e5db76f55510befe74d36e6c7d13cc348e6293d8ec45edb82aebd4fe0f8dc78740085377c6662e39d11db3e7849cf9fad68ee0168f3299589370bb9ecc32860347762de7742233235eac7b48c83b50b0dc2c61cf07b42b26f987e364de9b6ef408112aec875443a4087a5e981724d1bc24977bd76d7cd5b936f0de6a9bdcd72cda4e5ce078768e0a782b50ff411e5ee5f7eda2ed6045949143a6d32a93bdf0079cb133d86d9d0caad4d18ab45b8d3c86a8ca45540e9d271e5095676b46a7ff694996ec787797d59f2e48c2b3b6a79e97df588ec3c72feff58f2839fbf91215f2ce84b67610990889f7c3d2d956376ff7ad6f699fc75e88d8cfc1618b9a2970324af42efc5fa195ce99b0fe1be2ccb53d3dfa0fe5d8627f758df1be78bcda13df5371ee24bd94f3c8a9e29c80d49b34ef3af54d50d60a25128a189411d7f19b8889525ed618bc8b2a70e7b05f2c0f6a1dc465f98bd2ac8b6969ca19c9a86be5ab20ad5b7c364ad7e7a848f94adb48cd374445341982abbd3b469c095db39a1399e7c88531c279432da17e37b2d2449d6fb9f6b97f0e9d953a4797e75934200f8d0b04402dbff91a5c32c5b76768a49952a9b0f78adf114f66c2651f01ed8c8793bac537861ebdcd2ddafd2143c823e036c39533a122f516228994218b9774e6d26edd9441e95f848e8cce7c47a31fa2340b57745123d8b94ad9d667310e2e4911ac3de1c30ec0dd8da69b6d8c1075db4ac9f89cd156a0805fa20109f0d098872515dcee7c61ad7a10d61b1e5d386996e54f6279ff2ed3a88d67129015e7771ce784ceeba7b07717c3b6b82e822316e7a6eddf8e7d73c2a51a4517cd02303918ea6758abcf195673627e04bd642584621887807541108a68de5587c6c96467977b8a94ee73f7e3d3335aaaee780f0db668300e73bbf3c1b815d37c977348e3982be6fc2ebc48ba30b7764711f469544cfc3d7b21958cfa0f9f42ceb46b30fe0f2e0b296858da99860437b4a6fa7978b7957349b1c9771f3c7344710912acf33175a0a5810d0a38564f55d8811bb301a99ea1132ec196c42c6999bd6535e1fc85b1edade75101e44e5aca1b89bb0e9c2508cf49e1f0c1523f436be48db3c432e811e7965b795a117c4779f2fdb7c4dc1a9f25a913a709886010108b3cc9acd8a813c86cbc7282ad60378c07bc06b8f86c769d06548be9bafc5477ba05888a21e688bc4076cffa4b439c709994ddc3d216eb18753822a6606a440611d3161f39d0de86f2a2fb0cf6a41781e29283e80e716bd8e59e95163906d9d29cf2e8c845634b587f7be0e47a909281384b97075577d9d2d72f3288ac8b5046f2339e60ea2476339012a5d8b9055369ca495365051372f3fc2a25342bebe8a154917d6ac4e6dc2211b35f0b9ccbd08c89af5757a2dee120f77b858f3bb556a678f6883fec0aa4b650d3f23816739b36dc0f76f38d183ac968e152185e1ff88f0f4d94dd12f046e4d32d2840c56280ac5e6f15897a7c48f5a7b1eed285aaa9d0e4e8c2347c5842fc720a20fcd702cb74b600c6907ebb0e83e4b41ff644307093c16e88d17283be2f88e2501df399241aeab7e5dc9dbb6723a13a862b5782bc4328e5549efb20e38c026acc5fbedd1ce594ed072d9e53452a887767cba6b41f36b43810a36a5e45e758eb5f17bbe9785c40c94b849da39b23e26c348b79997c20aa769586e449fa154d75e39330c801ef4de989bb282779e83ba80295a6a908b188c7153bde92538a04a6ffde263bf62579506b3e6d9b1b699d7053a0365531faae174bb1b1917c5d6d998149b004d372096b640d341a21303a89fb24c80b7b563379acd96b4e260c0b479bd1e1328f21f6317640f08304e212b3af7e1ef1079033602762f2c2c5ee00d20029e6861c2145a272b30af1f47357cee08be372bd342b77aa19fcb2822a5a02ab14ed56d8c0eb2db12ffdbcb68da4a482d1b4d153ddb4182176bf92c371811211f0d6248a743b13bb7705f7fdb76fc27cea33b2b8d54f9c253fe4491ad2e2745259df1e6c97ac3c556040e45b962b15660f88020a3eeca573f7ae2a08007e676bd733e41ff72a6f04e1893edb63e21a24fbb0bd107b8d6f5bc01a294bed190643a87155705898d37dd0c35f8f7a801897b71494cedb777f767ff6b20550305f7f5c5c4e77d768c892eb4521f373ea8790661112c08f3d5392bf76ec1e3b3db9901e5013b08cdb4867da44ecd11cdcf6a13557e2d8fc9376a26017189b6c4f2d41b63bf73836df414c1736db303a897961c5017e07f9204ce892b8349b5176225f9c1a77a15a0d88fbb97a80216c676b86fdebb0ac23342bb6478b54a9fbc0bac9bf04213440e091ee8db441f9c0ad6c2a7f94a503e229b11dd039d620bee2d18c9185c8938e9145f93d0a6b63899a3ad450f8aac27dd563ba94923fa6d2e7a2974e002a638f102d68affc473284ffa85578c78ade58202bef50c3b3b6231f112f56ef5697bda963cf9186f31630c9ee55d5cf4295b144025e94d34b5741fe1be2a2bb4c919522d35cba09d27ddb571446dc1ee2d6c33a6b608ae4d922d6e7b009f1f98c3f299c216975c73daa0c6b63fb482d505f10598bf9be285817cf5b702a7299ff6bec0f15c88484ac51f8c7b45e776db81245a37e563765d71fa77ea655d8e6d2b52ec9371a85b13054d1c4d1afa8cf7f2a30bfce90ed00fa28e87587f0eac2ee174aa90de361f9e4dcbcb82d1741e41ba7979e5faca1849dd4589c9e8e0ad7a7a76e6d6fbde9a13c1ee2f5b075aecf5d3b6ac35d449c6698c40348d95e4e61a2e6cbfd5d0e0cee2067a845eec34825655c9e68c4325a1f1de77dcb38c07b37d66377ef02bb8d3714e169d342c434ab19cf95a3c47c962927a9ae940e3fc9d21d7171587b972d4e6984bf8a0ba678f97c52fe7d053217e19bd1535f8522cdcec72d687c1ccb3327f6a257d39e681260d34042ff852352c5bb3cf5f7325d9ad8abe49f90b1c103aa2305b05b905b893dbeac55b738e6874d3d10b55505809cedf5724df6a9f23ded347bec341e7c9fa6446fbbd26b0b5aa27926f9a365aab7a57737fb7f10f7485f6f233d2ae50d4a5cec1d82f70cc3aaf6928472e974a12cd6069adc006c11907b74dc9030e59acb2eed8210300ea295e451f59d577c2f211e92266ff98a5249cacbb71fe6a8ad5568a31a64c7f5a47b34669393f29b00f13bbe15229c6e7cc2d0abd041e4b6416d957628910c9f16774271dd1fbe3b5e029bbb5dcf4fefbaac91f4b4f2176381f7174e449fa7b67661c90309d7a8c06ffe0ab08b8a316d34bf1a358bfcd04e737f8191d7faa62c83bad5bb5211c8837f26b791fb160cf406f12637933b7cbe0029680824074affd15ef57e4fd7be7437587fb63f0438f30ee41e3a0f1474c09eea2b0720630e3b7afc2054d916c04a948ce7092ae6d0943f43f317ebc058a88a3e5571987112019ff8470a8450b4b886df0342725836dfaa62a212e641f596188bde16bb2223d64b2e2c267795064b7e7c6b3c2188aaba9d4b9b42f570aeff278b817f8fcce6571c8ac0fbd2b74597935e649fb462c21f9f36222b0e6ca930a55bdf99251d9cbd7542d801827bf971dbc85b43e4388e5fdabc58c17b31704db8a2bdcf5ff7fe65bdf94acf5be1562fbafb2a90a30c8ce6729791dca0c3853529fa58de0dc061b0421274c3910974f917c66537316fde7da551d7793fa12cac09582c9a722abeaa7a97abc86df463c0580c29061d5297b1715b3a4c79baeb133cdba57665db6d1001a03f2086218f7672b2da9db475905aa72d72876efd8e2a03a1b71605a58e6efef7f6539f7ed24533b21923b3d6b9bfbcd9390bf2c7c09c02cb505b288d165740e5886d1d833580fcca9318e3c65064a9163d37ea62d042a6b01a64e4b47dfd2dc127b3050c7c9c1a65ddf4226528a698f0b45bdd66f74d692bd7316e8f4e47719cf941487985c7e5b887b3f546fc0101c150084e3e4115d73d0c25e08f150e85b8d54a1a01b48f6810c705f5d89c92479a9a9997a837f9879addad264de4c0369d52eeb41c31dd9a12eb4b46a725524109754937f3b1300bafee6e69f47b281311733f5a9751c60442829c90dd75d4b67b9a041b99aeccd6d0304371375245d3ceb2fd40cb70070f12046d147cb72865770205d98037087da4c9da617ed26b3c19dac4bc32b8342c9442132656760ad29cdf4d0d97ea64cfd8b9823cc97286d667c9be79b26d4e5cc28eb0ac4b8d05d2d0df199d126416625a8afa7041b97729dea159a4a841c4403279f97c42821cbbc9884aab8a7c8c6b3dec6e7876a2bff1a3de203577c664adc487ee9b48b79559a1596c8a07a5c166d1b65fd8dc2c45306c5d2f4e52c65e457bc9212b6494589a06b9f0f59dd7934fdb17d642b039d548e531059e19debc8fe36758f92633731ac2c07cdec91a26a89e7c3d1788999cc34c984b6d4eb1b047a452891545da28017d8aef97d1c91f9798d56da1c4cc70a21521e3b64ca696d8dc6ac8904dbeed8e607b21a4d48ceb76016967571d213c6db0e9c8e2530359104fb8ebaba51bbd9618c1aa48c860eec94c35bf767fca9695b1fa5d2bc2bd2fd639d1147333e070edc12d22d0986f9bbc9cefb4420ac3eeaa6aabbc785a96d9d0a74fd409248a20372a207a1c06fb1dbefd0541620c53742e425e05a54af522b31509eb203bdc3678ec4e3c1646d039151a703100ad4a3e84549d23360f07726b7fb3e068d2b9e5e4cecfa9558711393086440d0261f2fc62fda797b94bafc913d8fcc34f0f0ac593ad25fc75f4b989221f4a4a01e5524454dc380a019ea21263fc52a847b4d8c1b910c3aefaccb3890e26ef2d74f3292594e6ea82c444e4afa9977eb74c25533b6c3cbd52bb1375cbfdf3f82dc2aef70f649d790550ce78f278f9ab821c910e83e894e620a932f089de4105b05c15cfa544dab6925c1a7f9e79b6d2fa435a416d8ae03b8301110bdbc894e3fa7bf8df9f1ded1e448fb87373158fec64563a5d77111ca8b15a9448927f00eab483c71f5206890025f283958c7ea8b607f959d6c4085739f88f84dfabb5725ec5b9a3c26778326849debccedeeec8cd07ea4a7636b7fb2200934101583cd1e006e18fbfe90e732e8a61495b8157cfe968244cc1d9a0f1565d6d479efdf6e15569ef61173099c6dffcff1cb1f706672d36d1161f46dbc56df546ab6062a0c3b455959dc2171409b0ea1a0ae0633e658ff28e57ad389c4916661d90de879d0b01247936d52df777a84a4623062a91b695eb9785e3264be6c365c601530a178e8fd93cf0b485a5446145a753a6b9a43fa44ed109b1c4a10b063c8323cc555f554119345e8f6f7e8fe7a4ad99ca1988640d43d091d9181352274de1736755e6e46272b10c4e6d518baf2902c258f6f89d983fc8443edf41eb91b15621d2406684648c8b7c47a135b3825a0cd0e4bbe017f97dbfa9e730a12b987a50293f82a9e43bdc11566095babb172969cbd6d0b0894ddc9f9171ba706d9db3aec4c907a19482e9f3e7ade11eabef5568ed39d6d79e9c39bc8ed4e6267c30614ab1db578bd5c77706a1301e6ae65665031f499c77ad5f076302c6b10fae2afc3ed40447764946d505b09d316a9fde438f9737d6de8b378d0fe57ec502b70139085398a85b65038921a3a4cade259fb40927fc8dae9543ec88edf9d9a1bf40a0ab243314cbd899acbfb1a828aedf91fde834044ed51fa10467007245cd288e85f38df6a764fd277c5999893f4b8ae09139ad6b9f0a85320db5e899163e21e84415b0008587ccb0a3d5770985941ce722b5dbbbbbf82091948576270b24ea1f4f5e485be249f00b51d865755c922810312a44e480eadc67e1f783cd1160d63903f725017ba071445655552ca5c813ae5e9d7cc0255e0a8dea9bff079310c861442094feac7452a101aea7ec986b9dab9790b548dd412bad1bc08fc42df2e7fab2f73febdb92939191e0b274de7436a20e2d8c8ce45f06ce2c89b54084f9c2d65f61d906e1a6c0a6081549907f2785975b02e3b21f7be51730a6ba2811d60355cca98a358f467937bd650f4b4cca82d45de780225c3776b96187c518e74dfc38ce66a170c7f7562bfa4d459fd55288b500149478cda8771faf5fb32327e2c4b85a362ed6635f8599590bb6124084b4bcecf64320712ad863b6d3d96b07a4770040235d87daeae209130beb7dc7cfe06873bd23403400deb7dfefd50e424e0591aa824866a89954db1a3d7e1924c0c476afe290db26eed1655154a5b4f195f7eaeda920acf1020648bad681a3d76bb1c0d248c1472689cb04ab1fdd04194c1b5ab1965688f76ac0198df6d781caaa23210fa0b8581ad5e6c19d585c2ccdbbab5d4ee36353f4a369a339bd9a4619f7aa9c3cd29417b9b0b13ab489cf3f67686bdce3e1de20ef7d77d79dc784692b3a3d7b54c609374f2c0d791682981242a46f23dbd9f934f2f70d6fcad42bd60cfc77b3d84cbe73fc8593cfa49f6d18ce46bce4ebfcb6e91b7b045416530803f327e1f23ef99f33e7f10b58445493602c1152235e5b78ced707fef1e5c70cce34fab0dcc55d6d5b58a7b8b3d5ae2ba29f13dd6a33cd30be811ca5a55992332655c7f760997352ff8a90b34311539c932c768ef90ff849499f76ae62461a57e5d086df29b8ca90033fff329be9e31e1847b45f44b7dab8ef45f7e1948bf8d327991a849cab0efa332de7054b14ae536dc41e4629927289be1869f780c70acf47aa929f6c71cc957d1964afd0f0df0ed5d4b5f07f187c8dc3a869136b4b805164e7033fee2fa1bba4d8b47542c70e6ffcf2373224229e2e1cdb265aa5147c081bfe2bb884ad233466fc324c223afeea1a5d153d2966c94f79e9955229248a33c93120e625c3f2217054ee7852423659310d60e63e62130b105d774d9c5a191ce00e7773b7e59136809408e6c495143073cf4b954dc0b147d7ed43e491e8da50f79b501c9dee91baca9c275bdef9d56d4f02e847d04293bed1eb0957824e460969a8fa39245ca6aa8412fb000e855398b6c0a260335ba191289a539db10c00f725b748821b96f069b9d13e019012aca64ef7c7a9be1b175faed332762aad8dbb4e4302b8b1b99b8b554d3a8e5cc5157b1bdb4189e853a40e0e5af245f64dfa181ccd6b5df9506b02794dcd5c6f5c7597f1396a5540de6bd0de004872717f972b125466b0d141666abf3049bb1a1f3afd80c6a06a68445513ba80449bcf5d93e977e1f1be896243a8a28643effe2cdbe9d996ce9161341c89d3440cbfb517ab4f63197416bcda13bdce7f08550b7c04e85997b94dabf066bd13c2603170f20046d5bfaecd819b0a66e2f5d1f19e7c6e51dba08676fc803e1a4be41ee494757fa73146d04dd4bb5b82e2ca30b83589f0592b2e06c8b9ac289e617349cdbbfb2587a2c8cb4aedadf46976eb2f243728947e818b782aa1ba4545e04a20592f892c36cae914c8c0ccc8a47dba5faba558d03237b4cbfd8447ed582a019aa4c02f4b430d1d674dcec887e8833c5e53107a1ec94ff6d3171a8db251d7039ccd703472ac652fffcaf29959eb32a14907521374ad7dd2a88995b029e991af197ad39a9fac46f0327d5f88aea8a9f8e07103dd31b882dc14a1443a2b3374a4e83966cc9c97b865f87a06ce04bc284b58c12471c61e5eda80c354ddd3255f56a268b2270f0db7c499178d97403c4d557a039a25586611596a600bbb2ce12fc38666a9d3892c16344162d12c1e0859c8989cd52e5a727297df625bc846d23c390e0a40feb4ec1a3b660fd91b55d1fc985d079e1d4701bdec51ea7df53a6b21cce9adbd9485221582700b2e9e0c0035607bf9c1b90470c383c34a16b9ba43f2253f2aabac3f1e1606deaca5fc35df1bc1ef4a0c031a0e5dc7efb6a1def26fdf90dd61d2919b9270520c975ed8277c84c3fe1e60e5be9285ccd81c34fa2511e3421f821fde656352c3f54278b3ae5313c4d8c1f8b4910c9ade867dd498672c3a1570810d8f81b6386d9ec7b07d6bb62d657461ef1ffba1dc591861611ac0e3dbc55a478fa232a7371e4668c874a6f44ddf4047425da5280d297cd3c18797166118c75baab69a3c309356d0881ba223789333eb1180b9f58cc9db9d37dfe81d9156348f0d577d1e54ff450f59ad239312aee0b985a2e399c1b131c34d7881c449371c63cf692e94fa246e4df01a5896916fc0b0af62749436bfb6e1d2895cca2ad844ebb439bc0cd4c262523a718f710598bc0f61f67b13a53c9826fb3d72aee6dcb6cf3fea2f4872069619ea07664396a30beb7804c2ebcbf313c0b7c2b2009d35f59e82e7bdc044ba9a505abbc3002176f1f76ef5e904ad8af31984456fa44557f628240c8f572427edc8918d4e0bc93fe6aff4177816a9a3724add997e98e89bb478d882088d94abcebd1790c355bf1d73ae427703afe41733a108510b70c346e17b08f01ab167f3e926bf76b9de5c6462eb6c9be35d0234e23bc1bbcf3e106f54fe67321022736680eed7f4b28267698ef2399be407d7bb6403f42a4d13896cd50bff9252256d57205b7c07317e44fcd2cf71628a3ec647489ef74263217f3a631386f16e317d4504d6d2b4859b6417ff935414d0d0407c3d95d130514820c4d5d3fa25cfddbdd2c02d82ae9e0b4e8665f3aa3a61beec1366a33657c67f319e241f90fa0bdb2b807a74ff5aea66c3983267e9b6dd4009809d71bfb259e57ec71652b10a58f1d30c047c22b2d1f92b28c284b9813c82a5c8b64db043c9697575828722429dd63ca48d5e7a0f233459d33261dbeb17131d85c9c115061288380d35bcfb6c10682184750441a9b6024da93a304a59b1d331860cbde04c41a57e5c39e6f081a1d58354f7b4beb26f61cd1023b0935985c1cf4a61bc0b01bae00373c5814a89e41ee2215a8da48954efffe30f641097596c1d633c0797b831b59c8a888fb389c2c45fc34bd310e20baacb6f07bf14c43797f9aaed079845b0a2aa04c3d559166fd9d2673e06f90440e54669bc3412fa6375c817d2879fb64ca1113603c5fb81393c5669d9bf373b9fc18aa0d1d6dab611dc468d7ad7ba5645729a96871ba038aa592e2ba19063f79bbda08942ced005416892e909824dc7da04676158911573b81d4c271798a71da9bb07f8cbaf3cb2b6566d706d677c97dca9929ddd9bc94a784924efb60a353c591995233ce9fea51e2a4767c7329248082a30b30ad64e12326a504ccf3118eaa47d600537fb0228d9f0bc68b7e94c2abf8c90091ce80c834922b7f3636e50bd523f4b8856504654d80a5e97b2ece730f5e891cedd5e5844f82a40526c418cca09e79f34e7d4794fe8fd8bdadda87159339c68f41367f196557b3d05906ad3c5c29bb2381fdb","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
