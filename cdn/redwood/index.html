<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"8bdd3ddf58f6db26cfc2c915745229cd7fd7457b448868f2aa7cc747086150edf30deb7488d8151d34043654d25606668b25cea111ca7d8a3c52ede2b04c5436b7290a3d9d4d3adec3b9168f156bc1f4b237be1752d436a77199c10656ce380a74c209190f7a2e3abb789304f6ba7a1b29b7ff214b6051913f8596dc40a2ecd531dd9157977a3fbb90988bf488daa1c1c4b01a86926ee968965bac08b31b666194564efaee994be516a256b3523f84056ddc3fd20095866e95a1088d363827827a52899f6bf4bd9dc91bd460cd0a63bf33cf6bb31cfe22f6ef76895906f2766b6ec4ff512f4fef307d9c2d1ea51bbd53869e84f5cd9b2a2b0dfc9ae7443bf6ed9d6875745624af98db54b8e8f3a8d51dd3d4b726e421c19840ac27103008fa3edfafd45b6c65754123bf50a8eb30818434cbf2bbad5b0eee73534f3e0dba01e335e0ee481699028bd19dfec9363dc312549e8f2ce8a8e0e0c04f44af5ed1fe5dc4a20ff1714a9074fe694cfd5e3995eceadf4ed762721f8bff5170c4fcf1ef5ef9566dc80416b2220f5d035d3195a990851a5def706724501014c390cbcae6cfbf434de7845db82890a38b8ddd07128d867beee7264b64f3390912cab968bb0cc0de4460bc72a5c87b9308a429013868bbe80e2604a032acd9dce2f80567960cc872c7d0bc6414e1c5df579035ab31a187afef2ac9279275176c2c18311259bb9d9d56426cbf887c5bc1e4086b4268dba797e698c1b7b07a32f74b7a6752be3215ab4f210cc1d2a1da07824f932d5b8c6e7b63e452d5ed7c78499bb72878c2dcf602472039337de705ae3e427b8ca5fa66747614b228f1c384d0c33cc4214c04898bcf586bf0427b153cef3ca26e92ea2f25a459b0856132b95c10a7301281e9b8a33b5bfb016f3cac3fe5323e099aaf1dc8b906e3eaff188c46a80d38cf129b95090c30b238994414bee73bb7e7fd687f74cc81a1b93a2ddf61f711b91fdae0ee09b15aad6f01c393e0c13d8f2e5cf2a53e5c4cadc74a36715598e9eda6244428e20c66f32ef93d2a1366e742ef00d9d557ebfd6eb9f5b5a5a57575fefdc00bd795f8aceeda5f2ddb20cc6a5fce2caf112ce03eca0524171e2353886766b5d77156d6fc3b75bec9f2e819d1837809b3648bf454bc1e9e0a458c4ffe26bbdb4d9c0aaf69f325816542b32b5ed5b911b2bcc6038d67ac812743472662b3ebe79b671b686b539ba4e2a10778108c8383548a39acc2213629f85d68a76c76fd5b03bf7a533cb41bdf9e6df19ebb59c31ab75df9344c8cd9defccbf4d0bf9cbecbbffb7698dc18a25d46141e0f4f1c417a5c4fcf211326804e0c008f0714c1e2da1b571cdf0805a5f3f8c17cb97b7af2e3472ffb04ab0a32a264ce5027a9e0f193e4418a8379a2042d2e40d3d0684c9518194a6d9451865c23195206832c03f70b90473bebe5852ac41e5b352a9387499576edf885656a936077e2b45f85d93fb8f3559dfdfc43ee025c2e7f23c90fb25bf0a4070ebf272b8c1ed6e241bd825c0e93a4a9c9345a55145b490926143f2c52da1398499984d8f7e26bb019d0058fc67f52418eb0c62c7f6c357d8380101e3791fcef0f45fefdd162acb5db6377219104cc7605a3806621e83790c25283555953c08604d8e2e6e9c635e12899c729a5870a36333f71450fd2becde30ae39a569f8420aa10e203e9add7a0f4952650d9a8fb619e1218eb9a92b2a80827b49cc0d1a584642a468883d26d92ba831e2b882586950dc97c7ba8ed1dd10bf3c611f566a7d7c7969a36a514aae2c7c135df9d9ca90db7c94e43a6755a0be28cde21671e6440e722888627391fb2813af30ac44f84cbaa7e35c314493af455631d9435dd8a7284091a711e9c2b0a4b4c2c974a1ad47e9b13382eb868667fbc5b66a30a9b983df8645fe71ffd9eb8e6acf9685f15d600602ef5165d2bceddda73d753c99e3ac4d6013a15284c0338ca86b5134f6160e1897448fa7afeacc74e409652fa32ea76d5a17b4cd2cf0a1b35f148fe0c18d876be726e5b59d8733a7ca2aa5df86be5200711a88443d72df1efad06d6802fe002c86029820bf4ae0ed3be20139249cf1a99dbc645ec848ea0b85ea497641883744778699ddca356e930d20b5928886aaddea00af38390637e9230568d2659b47bdd84dcecc39adcaf570a13ee37a73ef7d2cd3893cbedb9d5b74b5bafe768083ad00ae697df88c03df3ebfa7ebbe5d5f1fbc228ff6738e7fadde0d478806038b69715ace99e00726f0dfcc0fb47e178fa7791d2b00b1356fce14c4fd2e43c9dd084233aafa617d3d3b131cf5ca337e282ac74eb1a631af9dc2825db6c8dec48abd0551f6ca3fce5678b6c76377211a5398a81cbbeaa20ad2169ab05242eeac4822b1bfb86d44a7be40920d7991e54bf9464fb70c8e810279fdbd9c1967c967d9ea59eca7be9955d05c4b6ae1cd47dbfe11ea5f388a7d1b411c95d40eb3bc30ce6cb5a9a55752deea0cec174f62bbca98183a334fbac1d0a98f7f3557b41a2293980080ea0fefd9f8be3d851d50304870af76f2cd68908dcf48ae2653c4bbc96989e67e9c1ef274f7cf34b46389a19bc85899baedc29b8711dc64999fe567c979eeef81693f5f4ab4f90902ceea961eee1e2d7fe9bf02b633fb964d19d187ee810e12e02a9e9241a32b007ea27d9f5148895f12c5aab460aa7a26df06880e4acfddfc98db7be6aa1bf77f09c825a4f045b0e404a2216d2a4b39ee40f3ce775d8dcb6c41bdb8511239f52b4ea69209c6a4a8cde8a871fcef00156130702d800c7e2df22e4de742d260fa365f113baaa69ca4ad7eb5a81d37396ee79864e2f54b7a83c30fffc755f4e43ab45e398179769add0c8f50111c31fe82d75cba1c522f1feb8f8af8d92f8ec4b5bb2a4e1147004e76d172b95895d4dfbca8666e535cf06491bb9ecf68120dad27cd5b34eddb08610981c83b762b641ee7fdb32be52423d4ff4f9388c4fbabaf6437257c38e5a58c8c40c54c6fb37c01632acc6db7af9aa930f1c956422c865f50625daf2d1e30dde7540a3bf9ceb13f086a2eedbca64aa024cccdae62d2e18c49368a138dedd768a979050c97667ef2ff42e7a08ac2e88ef7fb016a5dc9ca0caaf84bd23ead40c0e60ede2195f6a27ba2d4306e963909ae3c558f32fb97e59f278dd407d6e8ef23fdb20e126c8b876ff76fa76e5fad13e21ba8c5cde7bba80e1284cbcb274e32ddc01bf27f42109f1a664b11511c4eca1722ab4e869951cea4c5935b057b8503fe04ccb0bcfe9d74ab029b176a18083e53648b713d993a5c9be0522ddfbaefa4ff4bf569183f41aac7730aae6c862da140641a0574bd061186cea929e9f3b7ece22904fc472a8628d04623fa5a199b7959f665a96a0bd711ea254c56295ec8aeb9f1acb56ec01c6dd12c4f5d2a3d8e3ac558c0a7e1d7e1c54ee1b5947c006dc73e3e82404e404708e67ccef3e9d539f7108e5a5372b014dd4b7cc77fd6aa1bf6b67168766c59d5d9362aaeb87a67f2398f16d93f78bc3b06bde6254bca23470ccbb0f6378fd7e8458800b9ea301a6e31274ec1a8c33c8ec94818c088058fac6f351ea45912f92d4ec4f9bdcd5aa26e8e86773690c27402e9e5f8c1081fdda35f7a5e1a1e3da767d571e74c8b72be2dad7d89709040f4fd79995dc3b07b18f9b9c37a35204d914b75906f7a7faa263fa13ebe6dc900902cdb14cbb92bd5ae7b05988f8a900ca6103cd4a208a9eb61cb789d2c252bbba3d3efab2b2776cd7fd389eb201a5e1dba69b84bf8cc3eb659cc8449b8b08724d0cad7af49fc731c2296c40a143122374a87bc3128d5e4896a47887692067f2c56f297003706ba414adeb8529eb36d96b1b41bc94416589f1c14c18def27049f5eec4e3ebe7e1a886dee38e84ddd67e0fee4e7ea3204c202c1396b9c7b7f715f8a6d578e33520d5b8922b7fceeefe33b5aeac8454a6b34ec870081e0cac42c997771ddbc41d000081ee93064a6184192154daaf8b231c1f67648fc9a726c532dd6e9563d378717ec055b0042607efd3ab26e5f2f2cd1e5074fbf3cf409559d49db918ffb47c2a1cb3f06c05eadb53909f8a7515b77b04035746a54f992c35cf3b10771a2a4fb52c92cef97fa00bd8ba0628159e66871070d47c9dcdefccb625d9fbbf2d1d147477e714c25d47fec4f54a9f7506074f8c03abf21115ec95d35149c4369d873745b98d8aab99763143b30f793f10fc2ec278d2b76acc23cee533de865dd081163abd28a25b142a5e1509bb38e7f384fe0f310096fcd74c83a77a7772667463b433539d09882a1a2d2828892b99b6bf48f9ab59e009dc0dde5317c6e24629be10ed21d7ed0b64e0a5cfdecccf5aa917a0f829f73c99ea2649d5ce5368dd437a0bb84c3341daee7ade5c45c0b948a95c2deee97a15b40fff44e4ed020c7edec542430fe0c47776a21bbc48c065102e2f6516905a61ce48ee466aba2432737756604b6461e8fffefcb60adcaf042e776cb7f91499e4ed486d134f2200379e9a7cbb52564906c14672d0bf600283f4af2cdcfef242f81c9dc289162f088b1bc6dbd7554eb9a8bdff5e03eae68ca2621c1867395fc43e7079e821cc473045dd664730aa1a11013aec59bd813d6ed63301fcda7a28fc623bc47325554da62506e9f082edc37a6e154ef978aca31a7900c8625a0fcdf206bd1dca4206ade2b031a7ebfab5c33c81264c89dd2149ebadcb028c968cb5d228a9a1c4761071da5c2085cf6e586d8e22fe1a2d7fbff8f82ade025824fe9b6c132770777b581436d3b8ede937d02eab0da8ed054731adac435585ade70b7e6a65443ce405837481ff709ed5af842fd0b4d2fa2c09ea5a8b2bd27c8dc8c83848bf5891536d19403ed8522e0a37c433cf8ab98d88e7d4389089f28f0108654360f1eb9be15871919f27efba802b9ed75d8e61bb460add48bd1d1eb4280d02850d7f96ec48af2fe26dc3f605eb9274d3a5ee6d164b49844c6984bbc53e066aa4886865bb48bf35e8937981565cbcf0b0d9dae81515ab466e6779548c5b9b9191bd770138a9e8ace95bb7d83e873b46d56e7586876f23ace64f53f5ebb0aad6ea8d723e57bee25419e4f6b289f52629182140a6c617ca56b9dcb2baacb5adbff2f3f79e23d8d5f43468b305d277feb5d97b8cba588cfed12423aab3b8f684d463d1802299490320175d402cdfcd90b3055dea54d309465f276e3b890dfa3f1e7b789913f39afdfc453e4f1eca61bb3c21f69157390dbf41b3a7600c5e4bb798b560b75f8a6476aae10f79f65c80bdece1810e2d0da039e51f13bf44cebaa9db6d5b287060d81cdf4f3ae90f48c88e26e9ce245255856cf13629a32c68faa144dffad09741a45faf131dd22033d4caa9633dcc4ddfe09584a84b26b95ca920926733747dfd744365c72020493e6ca37d2349b4c44360eb6854875a11620d487764a2039f8de36a4395f3d59130debe0b367299b0f1a9ee5d5428db19677410d89f61c6a45f6de489d7c36f714001ed42ebccfc2b8090437bb954ffe3a012c23f7efebc84a464b07889f9cc74b2de216ca8480a3397dbbf78f33b134b6c3cbda597acf033db53ea1a7db77e24439960fe012f2ef70d8331164d398859c304f9f67c0bd399219d9f9fa95c8ec08c9c2fd7573dc8ad94b8423a8f322e2ce5155d552c61a52dfd2a5622aecfcd2d5b14f090659dfdfb5182817bd8f0acfd9da254c640dbdec9ca2c473119780da0265dbfecea00c13717e8b7f62e8fbf47b81de3d81e85125958d1d76007bda3406eeb7c04f763134f4ab3d0105c87d2cc226c23445cc1362d473d161e29931597b375f8db88dbd225454d5b6a0d0e257d40d71deea5bd690c94fa893e86ebd13e8e64709ee270e4e4633e31f37586daada1066de3b63572870d43097406b4570885681b346fdd5f7d723716ca75b96afc63e4290ec1d5f7e9e8d4760c471c78173a24c07147e447a17bdde92998cd381063fcae571cb23b5f2a99581510411464bbc3f7dc391ff4c0e73a3ecc05e99d94a441b64b03c5d1fe8519f3de96baecc3538e2d9cca7353227a6da6cab9fa2130721b9f8b23e9937b80bf2225b5035074e2f27b06f1088540fe61f1f3b54f55b07109cd0980cf0876890c034832fec05850fc6c7bf62889df1c05f5809ab93962f8f4793950d4c3cdc1821255df3ba7743aa7814d4df626aac668e0f5cfd192850c4b830a15ac475cc53885b364fc22faab8861f0fce0446d3b44a217828c54590b185c9ffb4ab99943d30c7f67812263fb46ebfc2764659f7ad17a42bdd020e3e90712b627709ce82fb4b2003f6c133407316b761939959a5ccf312cf31ec717aeb620768ac91944cdd37ae49c52c4cbdc3962e4a193cf57a74dfa7d0ff7b69a36f574fd4184dd4d02f125d65980b6b934c79a8045d040924c352c94c4c6e3b041c3646ac121ff8d1e2a4d8c0b73e19bd3cb8eb74181527ddfef501df9ee67a1711e84a6615ce91b65ed2e8a21a7150cec15b7692088d208107f9cf80a3c337d2fadaab8f46cc6c76a5c821d8aa967e0c965d5b0279da6e7d1a20cb914ce97917064a58269ebd714d1d29ede7121de593c1ac17be73d13f38d459efedbc5785d2727ef2609cdb3e3d4784efc17e69844461f3fccb3bc8af8eb271bbe58b6f0d9fe3df5ef88293e6f330090eb366ea014559c3627551608f04df51f9685ca5629fdae035e11a18da891d43be6ed940dcd198ae880dc1a0d34923bb6261efca4c0b43aa74eb43a9dc9cbe232f5c3536093e62b619856ebe06e7a846e25d74547deacc02dda7c3cb376f9fd27b3301d2a5866fea5f04fe2113c226448aa2677fd74a03a8093acb4f4becf29f387f0013f6e413bec8cb4eef55dc3734855b511ba8c91e0c6fc45ad35a85413c401a398fcb7a0a8416678f1ed0c884f3912fedf5032b3eb400634ffbd1ac0f1e8a164f208abf56b68e1cc26274783c24e1921ffc40c1d2b17566f7a62d15f15a25150617d678d946547c8eeb1cbc0d0f5a4c60890dd70f0bf95e55de573129e77e44f57e0a29bf295d9cc3f169953d6ab66318c37ef1021cb9cb64c8909478b42290f6a4d88b00a6882607032acc1e899a32cd9b07c7a6d286459af37079d0d7ef3c6c3c4f7bacb9948d9414f7ad5abef0be6280bbc28762e4b6f489d12b3feae2fd128d4499db880f4f2415f1a2e77192647a0c7142e6232f15647bfa2e2f3657e578bb8e72cb8d8cfa68356366484c0a6bf1ec32434d99e9022628058bdb89cd96d0f8d337f6be38077be1607044c5a059396b68746014d5ea89efe9ec3716b363e2a14016998bc5f22197536bc71969cd484df44170a6bc28973edbf9236c58bc76624625f49e2bf64c7696638c47d1caff67bb815879d898023eb3af496832bf44e9002c692eddb46b0d903101796e80de8767ad19abf64e062275b8594d77a7f14fcfe7498df63508b62817a072440b7d0acf7d48aef0a2dca30f97413d84634311083b3acee812cb0c2e773efcf7fdaed4cbd51bf2407ccf9280afd6b8353442ab7906b81b24ec4d4156bc9cc99455f84a1887e4b365cbea13cf8c7a432a3aba0fbe8e26a897dff0dac0a7dcf4abda185c273da9ac7533edc9601ce3b2226127b2ce5d5cc159d85a5e907437f5d9ccc2d253c0efc373e9328cb02752ecc4a5d4be1be3b3cf07acdce6bb9db3e709cd983936cbd50cdb13cedb9a944e18250de63b8e3e11a9f6a88ed7ce68d2fadfdf2b5ced960d0c01c81c44f6351d4bf4bc594a20b2eeb5b309ef85b4ad7afddb4ee6e7edcc883628f3d51d911c4a3db7291e6aa645d71fbde8d1398fe6b7b67997916d08b618785c03086a015bfe66c0a93798343944f33e76e91205a3dfca2e3ddb423e4742acd1fbe050556f41dd2f14aa8f401fcc5fe549ad404a154e2d2b56458104acf72324c48b457adde7a66f922854f4d9e4323cd16135553dd09f94e336971316bf1e0a9ed3aafa9cd533f88166397e60403497021c4ee484e41652ac27468db06c97cdcbbf356f68e464ffe8a4c5c2437e56eaefdc8de6ad6653df78a843b895b97dbfab4c71868df0207cc273256a16cb3b0f18ed6fda99309cb737bf10e0e172ff6d95c8519a5bf35149d71995c7cef31e0c4bfb785eb497558aa54924eb9050b2c35f5426b9609ce7f762838af683661b236ac5746b3124eed2bead2ed89a222b47a98b792e7249d1594ad34b984ea340f8fafd160edbe5f36e1654eb26f87e41dfaa6f2c2238a001aa8e4f9b2207e6291c4b0d1ffd0d3c04045f833c2780d7af9e552f879a90622b47639ad8a5d35cdbb0c8356894ef4e08dc52fe1e9f1a5b100bf792ca5b2f3f4ff3224eea55f6e48e48a4dc79efd322f3d08187175acabbf023c17930eb576a820a6f08af520753a7dd65d933022464598aa488b48c7546849cb75cb91a2f95eabf5d6f7b99512aefd2de19c9a242aaecce432bb3d426f3c9baca83ce63f86dc70744c51851da903edf45e75622dea4f9cc42de1e213a6ea5702ebc1d22bf892449d6560f9ca80269e151ebcfb27640be7a6d2a7b932c288f6951d037a524dd57f853ff5e038f289fb1a97211e9eb843e785dd1c79572b35fb55add2b389bfcda6a72a925245505eb65cc637f3a154b944ef7f8844745b08f274155ce72a1242dc931f051e938aa9d0b8491b699135ddb459f29542d0dc952c1a1fe8d2eacfddcc374bb8cbc08b4b33a224e6cd5d3896dce34dfe38c3fcd6fc90ad87a06c226c03b2b9af9cf4c1bc7e94febe8f19bc47d48ef4e428440d274985aa0ad098af38deb523e24ea6f001e53fa7af92b5c59018eced27322ea9d89a70efd057a2eb245457c3918ced1ef1d9e1102f7ce3e7dc1e8fd672a26c540dce8f6688068341aaba609fcd4b1fae80bf593af71b627a0be5ae44f9f562cf216d5ae1ed1acdb5f5a17a165d51d5a65bc7d96cd2f49d3f45e34005f74b68c9538a8dafe3db6224fd01e8e81a716f53d6f7dd1d033142880f4e0dee55424f37d3b5c20a92b3440677529700e034bff38d0aa59bf19b0c44285a1be14904207d82d311761d35d6230c52f9ace1233a633a72b6ee31bcd8e52aa12efc48a9c8a5ced7aa63f5a505021b0c81877e1bb3613bd77f6a7c3b96f055589a545dfa4d82b4c9dad761eaec8b5021c8326701e5ab9288066262c19155840023a051325c314f3dbf3bf0deaf2cc3eb49fc79fa5a1ef882cd55283844bce957a9e81ed2f6b0475893536ee88a328d6e322a0ecd5af73573cb44ec19860c3979a0421143148ed6bcd7529a59b5395b5f575eacd289220089a76e9ca76ff93891a36092bcc8cf6096c98a131f7c1b64d680d407fda0811f377ad2c0642cc84535c3fed9440146a550a00c1d8446ed3fbc0b5b9fa10271cad3501df0fd70f80320b878e2e92e97c23651a5acc97d3318ecd99a628bbf2afa70c6bc0c0e884774da0f2b184030458cb3e6143a5c13323a1ba734b7f743d841f7627303ea70103809aadff6a009eb7cd65196cc51d45317ba9e9d7da6aaa697e19df846bef268f7c4c691a6b902b99a630dfc1ab4b332e159a860e52debef52b62389fe925f90ae25bf9d2e2ba78b0840d927ff8dff3684264142c9ad58d883133a27a19383cf397b23706b9fbced1c9b6c20658d20c6d1f60446b3ee7b0cc4ee8384c366794744c929a2af22104595dc927018e7570de0e165e94e3763ca2af4c0af63a026e9baa03fcd10b718ffc050e9b70ebc6856e23235e48b34a1c1b55a480eac2d2d2019f8d3214c89717ea69eefbead7cf9b6f6539f223f1476c94d97cdef77e0ba76bf5cb1f0f51de8f5a5d2bfab3736273321ff64683f63afff341558bc8e718cce8bd910244d6ccc78ddded6f3a4e7fa53a6313826a75618c91466de32ae3348845602b56b9024b0714d6f7ec63b8ac7e90724eac08d08825f8638ba2f906a63ba36f67589ff273d52564242e7ff62f11614de703110f83466289a0efafb45068b005fff3859e6cd7040aa8b6c2382fdfad85a362290ce2d706375faa7aee23adca9ba2ecf7eafeba65ad9d5877c9a9f2b89f9b0f65bf0203dad6748f684de456dfe7bef0292385123652cabd891e11fcb4d409eadb885b3f012e5f35caa091f84468e6501201647e64e6ba44c2bb5fd0598861eab495b51d74fb8e350811dd0269b952d4095280e5d81b7645d1e27b32ea2f328f45bda52c9b37c5e996c3c98b5fa9dc0a43f45876ce9b2aeb45ec009a0ae32a55f70b9d83c33915bcc7063ebae25e15951bfccc6233e0aec97ad85f0d081804277a192f5b1053c7156651be55f82c2a195ab0dfbf7b92a1b7262dc8f43ed98c58b6be21f0ff92f4e99a16077008b77fd6aa3dcd3e2d047eb00a40af4d7b8f45e7214a4aebd116e34e8245c02a3f7ca9bae1bd7ed15618baa4887082a3342650d6324f48e4f3dfc34f4dc3194425805f5e33c09e06fbb2b096cdfdd957570206a32afa8d9a33b300e648b393f3ef5566fc09a064cc82bc55aba842996906799516c23cd4dcd6e1715c969c951cd7b69ef3786a3068f1ef034e063b0752bec925ccf3e6983377e7f0ab594b28f040aad713a806a9c6a4d0b2bc6d2a774f62a56e1969edf0dbeb54e7e40fc3f4254d63d573f811c79e36b6cd1d1362442f22a70ce973a8dc1300a9249aefd028e0391c846a2a4b6057872d299cc4a552e3ae4e469ecc807a1a4d4930baec333f8d944f3527a3438b8b630c9ea616a5af71cf2fabf365e5c154c5b5092dd2025166eb99a736316e859a24b6165558aad51fbd410dc0a84edafd85d6888bccf2422de738545e8151e0b91222cd6a9031abd474be9d8c1e5431b8a2e7df15af06c75cdf65f648da0ca857eab939c061474b11515e57b72ba759c81d7120a93c6711997dcd28e4876610e82e2288db65d8c72699bfba2a908cb95c8ce4a209f2cc7c71fea8059a8da0db1504aa95ef00040031e261b69115c27ffe9eb4f3c6dcfef2230a2c12f567ca12057e46679d2f4beedf37538b810a089fb01a37ae791332e02f536f4888ee417c64613ee4be97d3a619303edd51f2ee4320587ea27de7267d8982f83df4600f6a221097fb745865a3b2b03f24b58ef8d1e2a6f57d0782fa2d91873389270ed8c3b42684cb0e1e8b1e43d447763074b91fee4e58b632f9cfdfb16d18fe8b5df1ab9bd3a89e5ccfe05db5145d5284ca6834ed09d126ec10a1440a3073a7789e3bcc913906bdd07ee5b157570afd777e941e3fedad9e58a2c70036d1fd6fe89b9ec1542c047141e1a5ce91545deef62109bcad0a0153ffe92047912f3ec3dcf82ba5397bfdd64586c3b16da18dcffb2909448a287e40092424efe4c68d030ec3894442f2623a2d31255a3f0e62136097b6ddeee602814c03777084fb3d9ec2f6b120ef4e70c4a392bcd82dc7b68144b16d808a92f9c33d45dc034f3e6088fa3a37b26dac709de679d8a7d50dc4be2bb1ac0411050e97c3d91deb30255a6b3fc77a1d4d957ea198af24489243c32584491be44d90045dacbc4155f3d7f79e402c0c03e889f2e6aba869681c3093c1bfe11682b6f034cd06fe29d301ef30ac3da593e0eadde6de938dc1f6dd28c6266c8912269d5bb14b5336168be73c4b10408c49763c91e64cb8c41d85df67ecb74d34182581be880d837041b92d8fb0bad66efe70996ebb9ae99d6c73caf5e3ec0b88c5aee25dd2288f753651e3f5119ba5809f359feca9bb860084ebd38e1c349cc9c00ddd427859c4ccb35e9c755cb1b12e7fed07b2a12f2a5abe46407ca3f1b7584382c82f7f77c24b52a464b59a4ce5349b50ce70068efd47ed0e276075559f08d5369f5481cacbbef5b60ff8ff1b7a340dae9e577b56a6860445edbd26465b653af9bdb4caabc093134a5df66d4176f1297bd9a027a7a8d158dfba479966a95a3481aa121602115ba278c2284cc8ab5d38dd01ca172987ebccc0528609db51c2434c944ed6ac38cc5e87d25043e0004f58f4d8a85feeb6c199cb1353dbedfcfb5acf26e8cadfdce484edc7823664ce68bbf9f218ae4fc5f97788a4d14e02d8bf0eb26ae3f43f54720fc477acc6591a9081660317094d913ab1d2bf221f12c0cafc2a4c26411ea8f3ee65266cc1fdce65b0e746b7059a8991bd43977f8c8e901151db460169d30ecc6ac2479595293e1d090a9a867fe2adc3a5c5e98f51df8f78e206940f5a5ed717b346db500b42f851da6ea8ebe00dcb010e876dfa3adffadeac9ca67a007dcf8750f69c2924c5d6f7aaf8af2896008d954ecd8bf62dc07a3b52942d42a34f469863404d2f3475de3ea1d936a5580a0250478beedf0caacd272a620ceff1359f892d78195bbfc10adb27ab3c683620dfb61f0e67e3123384b583757903636c6e089f72206c74a172af2b62bb059d92be5c1bb7960b63e71f86dd0c0a78ce15cbb8bb4161e2ebec2661474bf4d224c148f74459166a5f7a34b44babbcf2497940780f347b1f3304cbb64c25ace51018a48e5c86ace227458d8c06598d68870c4046ccc1e2a4ceaeca888ed3ff06fac7a3cafae4b3959c14a30c885d8fd9905898caae452a1a8b092d36620edfc9efebe5e932844afaba11185c9d72d6bc65d25b5554ec33a972c8f1ea4fc66ddef356bf2fa66056843b2b14d08ac24643282f58efc370902526c3dca44516c61317640aa29046cc5cd1258894ee851dbafeed51bcc3bfa51ec8d244168b8d69e2d746816365fe040f7eaf14db9489b3f8384bb7fe02b7a039f0d92eda49b57bad14271298f6af30d8e50ab260e8c18607289dfc7ce4d997dbc75a49fead8df34d893148e0eaab270fb058c8ba5cf76c0e821c0c4a749f072ab63561bdd2187e4630e96a2787a4753764a2db2c864fd69b9d1487b85bbc206f04dead00f7023dd89642af0f86ee30564b6d0c52c5f6b4fd7e6c474fce181f2baaf6f125ab970746ce3d23b819b3cf91c294982d2f67dd2e5f51c2271cd4908510c3ac600e71dd27d0b8942abf86fc8af4157403c6eb8a456954f69fc0790c2ff6c45e47e7f535d120505a906fee7f0397d38a9a189d79a121979ad5bc8ae434fdea4c634342bc7be5525e3c541da16fe1501b5f5e672f30e83ef3777673b8a878566305f274558b33cd1ec86b210872191d1ea227f1c4d44aec21058ac422b1c261245b8e31f1d8aae7f277f70c701a490b862d4eb46659e64b0ed7a3a09c2cb910d0d7bc818e262f946c1be3ef83f99600018b5d999d2bcd4cd38577b4e1f8820ba072e5f50f9f655062b906d9c667f8f2e5f7c5f908036a0bdae5801043b49aadaf6e86aef3ec992844983e0dcaf6e44a0dfb913e23e627744d4aef8afe3d6e333d082218df05c5440aa166b3cb9f427b1c13e2db922c1fad18e79d01527c8e37edd415ec4a32a0b5b57196865c56e8fbd577ffcb32b7de6550552cd91d6a97609ea06ea674ac320228493f194a1886f7e0de42f9e478da6533960afb1615418721443e88c4017570e34536e0d179a29c934f66ec4ca435b76e88b27c7afbd8377c7b703fe7dcce760efa347dd073ae90eb2946ad8265c84987065f67eecf805727cff7b44a4168088f64895d85a54b451ba441d2ddb5ea08e70c1e3a40368d48805bf2b33092388d92850944e6235ce2f5f1628ce235737c6b98110f000313779d4f9a2067fcf123759c6897b703c6f1af22770859d885700e9e85229217345ee825b65c7ca727affb43ae6934e7d8807eea09ead73db0294ad7db659e2f0bd4fb3acb27628fbbe48adfc8dbdbdad492f02653712f7dad7b288314fd0459ee9228c2e868c764c8ebc9998ab374ddfa8678410f02e5c778fe9909fd235fa13c41e8b1019b43269474a821bafb097eb706726d701e5d063e7201b2bf575e312b10cab02df02fddc44cb5461f548d290db6cd243be3f04720e6133c2f88b61d56875bb5f9d9680cd7cc73a11fd946a99384c5baf9729837b5a2eb9e594b5d52faedea2a88a24251e4897002c02c667cb6c17b16b09ba9617b41e18aab35796c1fc302c66a09ac816b3048bcf9fcf984de0ed6536c8d4fb8309bd1518362e23db61c38ac241e6b83b65618eb175a9836642baaf9ad37ebc300c31d34fc62e00e39708484ca4da590531e0806e35ecf170aaebddf2c35042c814c50be7dcdab31ddd5c0d20fdb6410533572196a53243893050d42917d83c9cfdce35a4b14a91334d46e077b1e6cb76ded5ea2f0b9bc9a517d0db1bd9aa9d98738cb1aca3a3dbcb8693e67082e90c94424661f81d3f2f38533992b4aa48e5a1efbb6b192e12522629991bc1ce6a9902ee4b51334ba83d4f58f286cbd1966216928caeebb078ecdd3e6d2b438843aae0981b1a487a9aa540bac4ce8e9f139a1a34dbbce99549d1498c6ef04e10ce424519b65593a832f874157cd049ffaf05678defb77836c3171f5f56a5b31a99454ecda46a07f2b25e44407f140d3d5c7c643ab6a78e02dc2922a8e3d47b8b9d0b94d764da1d9666bc6e5e74267abbceb986a865e8020fdb1248688bd1f04a622d473ae25bc2a5f4f1b3070cd4cafc0764018ad20b13e6339217b7b82d423a4b5995ca35086f843812f0cb13c6bea08e1057787ed03fbf15f65f9f97bb2fa4e9608be5c7e390bf7596c208d0c9e99834135d61f95d11b2f2c5b3c2cca8bd1f50301686772475c6b4ed90bff8b947dd10486318aaa6c8eafb487dc127b58bf20263ab6ce65654f007cbea41e6e19535dc0a8f62cba584949b217e97c49e21554265700f824ddd068cc20589fb16e405203be1620019fa5342cc1af8b56f8c09bd30f08cdff3d9fd86a3d144e3b6beeec461a54459bd5544ffd0e3c06ed833ed6d45ebeeec67347e3b8182d812de2ebc3ba44001d731df99ace1a484a3b76144a7423906d6586be39f6b9c8ec5c78f5aee5780e76dcd8a84afdcee892f861bbd745b2c14e829141820abcfa5db88d740e722d631c1f6fef90393864ef337ea74cde9fe04660fe949aacae8a7c7db648285772a5cff2264127cc4579f4a8e8dda8c230d2f43b7bd5fdf4bb23f81da53fbfb1dc8d8727317910a05bf61a1d11aab34ae1b16f3ce97f2f2f8b7d509d5a006a9c8e95c7c361224a191bf3d0c040a16fa448c60d6d8d1010b844ecbac7cbade5f4064a96f18154a1c20ff8eac2c8bef6e82e94712f96137005083a588e626c25497ad3f8d7c91324c98a4355c87aa713bc9cdfc8f4d44cdd4df7171fc36bf45f10d59397ff2ba881bc3b5889701d155702d30aab7fd79b1a4792d43ffce773d55af055db2c11d49946f01a8697c2d1ace39b37c7c507d3fe3624e249a02d429bbe813c9dbcfe3cc82fbfec700e629e33093c65744eba77b11b71d83bb41ba3976e659989e60149bd28c8566d548a5c60fdc5a96d4f7b51b24f59324197910c7c2db64441a20f10f195cdbe5a3a047675cfb7704de652c18b839e125cc3ed5c730eb380b0b36f4a680cc82bf48434218632d6bdbacda1f69cba400d204715b0782e19987160f3b2f6caf6bf3e8ec23768e2f37a5bb8e3b62f6f436b58ca12a49c3fae55a70c2b3ad1c843e00177ddb65aa8d21dc0b8c9884b83e49a16e369b32726588f4f90d7276245edb79500aa082f4832ec8aec11cb156b4cee4e82158b303c03eb220ec161ccddc0abcb689951458815165f8bd2df298b2e2020045dfa0697ba67a91065cdf8e40e6f791ce44e2fe9c69d2d63b7616bcec2eb19c47e0a4bae97446257189ebef06abfdbc038ea034f9be502712a85eaa78410f5eb6bf9bca65a1b3ab61ad6d170b4d797a53cb115ae777e4cad83355f34842d74d28d9eefa2fad89ebec0492da5a3c695c3c8c8c035a04650239760375d630c9fba5eb1c300a4298508b20b1d59bf88e48c504cc44b6b50c2081e840d8d48f3e053a0e0fc1072010b7555fc656578ae138440b98139aae2a5b8cbbb72023c1d51cbdc39ab1a6db2ec0b9e57caf9e979c82ba74a193cb0f2b4c1cf255d31f17d8aa1bc7c6fc99123f72e915e7e007c2240164a6b17830cd051bbeb9066ef33c4d98f84a053feaba873c2e140ed74933ff37eb3d42ded60a0310e89b4365aa377b1e51596debdb4326c7ae371d654b60ef34d4a9cbf4b40b2614f819a234394f67cf5f72e396e541e33934bd918443ae576f56cad3a6fcb56d887e5c203dc596dc45eab7ccd75b0752e0f4548c0c4e1de6758442d9b95d7c80043043b33c3af07920d6881392f22ed4d5e3d9f9d3a4877921d56642f2fad81e2b2b4b392e7b975e569cb489a495693324b93d4da0313d4175d08bfd9e409f10cefb61ca9e710fded475f7cee169e0ba829883750d0df93aa9fa7d63a9537127b134ca23e29b0d5f272d0036f105980e481b9bb081a30bd0e50e1eb605113497b5bf7cc701f9aa98b8c62949ec081140b140bd0c1cbed7999c000667e20b374852e8073da6e8c84ea52fa4a4ae12ea15811b297f21520d292bc140e5a08906f255e9b378b1a1dda143cde09b716a1a6b2fa71d7bfa377fe73deca09c70361a70833fa221dad6ff4b5923478cc153b12757cbfbd1d1429eea65282504e26d6d3794a9c8bd5e46fec26a7003aec090c918afff11587344b7895d6b2e6a3fba507c97fa570f79889c84d5a01164c1434f3747bfa7b41bdae2a055167645358518eda898cb40c6ac6e29d7dd871dcff358a8958c6cd105e66af253827f4a4cddb933b635af4c96e78f7acd7229b2b61bd4e6d6ad66a74dd794b56d10e349f6f3e785d4be0bf21523ffc8ba83d229c1b52d0281eb7b7825e179af1d87e7a86044bbb3294480eb69362c3af4cdb74a73b7186d91f92b0488ab1ab7addf442139dca7a929160a66c6678ce8913316bb88aaf4557a8db8caa45ac2160f38ce01c92f486d72dc0f1e049d7a8c9fe170a77533aeae0797ea2ad7c90eb4a097daf15a97e22fcb6a55c765615dd1e199bf86648dbaf42476bd02a996baa735c4abd767406725bc93f2fcb7b4d6b7448526ebd61c8efaf231031e86702607e32af1eac5889ef91b34b1d43b8298273e39566ef0f69083baadac5eeb09599d1bf723258a9c7ae1b79b794bf7139ab3e71fe4d417bc650fdc6c3d57db3f9715a61d6c3828de0abdb106ced02418bbeb097bc68b26d58c563d9906c66035e01a46fa33cf160534749eca5261f6e19429499196470f297b57a55b5bf400489f946bb3a96547a68dccc98ccddf6288c4dd57b1516291dc515144533c2f23911e53418aa448b7ba20812b266b35860dacf0c6dd4e3cb42d82dfff0caf25598a6f5924cb8493d9fc148547eaef317ec5f1e0d75892f4564c71933743850c21b29572205c0ffa76847e72d27c8b372185b6b8b49a61018b4ace6568262c5ebfd7ff471ee96647c5cca9656c597beb89231e0bb961fd9d8aa0a3a2e18162ab59379336e83f060961d384706b102337ce9d252034257be2d3362601dd7c5c85f6e9e8c0291cf731e0faab4b7f8100738fb385d3ad5279b6ff321cbe5397e3a7109768c47a572fd01a5ea7095d5d490cddc345715c0c343ec5e97ecb662d298416cf0b54a420cfe9968c4215bde1d7f7e360914a8805cc12647a901ad2371bba71af48751bfff774b98f2efe0afa27c6821918221a1cc20939d22bbc459b0e27e201209039e40f0e6ba5eedce17bd23f256acbf276961bd01d729db2d01cda6e62c65e99a68afb038ec937c45a1d061a701879f740cc12ae95f32288a84597d0abb9a09468858cfaf4853ad665c5bb8e54a116aaa5d0e63eed6bccb25b899b11721ef5d1bc87bcc9bb3e191697e2f7075abb51096e861273e19304ea30a0dc2be56ce9c71ac684244671d3d4f557b56c05b558729b8fc705069e432738be5ae4490eb3756bc61cb0362d62a4a6f7195075e077c69b158d6d795399807ce713b12827c12c5f25189530f92460e3c2a7b99075e133ae8487dc2a3b67a55454de5969f35b1ca0b95e99e8498c1c565850317c","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
