<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c0b15c510ccf9fd57729656d5a4091dca496fefb1e483f80b09b7e76f4d88aa651bbdfad341fd18ddf5982fa7633e9d326d1cc05e0f8d95303151101d8708fd698d1ef981437161c8134e7e4d0fcf12a3295db44757a420ef2d6f00ca83b67902a6da8bd23be75015a4aa44cde93d8f6f23e89fe69e14c276c939f8421da7bd59868e2a63d00471665581e40c865ef87c6773eb38f4b03c61f8de0c82cac6e00c81708dbd692b82866d439712e3d8719682365b4225ffc16b2c012e2c3bf574c3b03b9c9d0580abce2a3f810e53989c4b6d8f820147cc93da148dfabb91d0a37362a530ad23340156632cd2277100fe0341c7ad52f900a0b1507bad376f2fa9b67fa5d6a630a8c0f2f38382221e4b50f1dfbee4ca8209442823f652bc32e669d37b65774cdf51f972ebe46237f8f2ebd630ab925503d43879be469660d906ac8976d02037cc77d42ebb4d68f34dbcafbd420b0f76386dc347c226707109c47f33fcfadb455a8aba38ee27e1c53be8ffd82cbde1f1aac269f190949dd39181cb4a6b914e326b734d671b866e51c8ea247fb2de4c361c140407361d941ca2ebef363556b6ced207503bdb52ad7dc2ea886dfbc31ac3ab8e16d4218786bb09602a53bbb33fb61610b66327a9557f44a3547da02f3667d5035f9c0b971af590d6a4ad80768acf547e0109da0e2db1c8945e9bd9fa2b7a0e6c0fb63f006357f5cceb7e5013cd2c35ebc710dacc255c49d99f65ce0d1aca09b3c71316f2f0d04c2d5745a11f43c61c4a2408fe6f4bbe564b0008e3d7a6184ca76c6eb414ad158dbf798f9c931d8544af64dba7fd89a507798fa94c8f8db117efd2198c0f62bbca43cb3f597a9ebf9da0facbd7778782bbe19fe698b19e586a71912700d937a238428513cc4f5fe9398b479b04e825930a8eae7e19292d08c1600ce4efca9cc232fafcab9599a8a978ed259954220826df3a1231b16bbfcd392adacae9afaebd40ed1b0cbbd3e74afdda5f4f1fd63329c8edeb32c460edabf564635ad1abf3b07293c9822fc04a7bffa66349e7ede4dcf4f05ea9df4c652d67a38acf1bbfa9fd1c7581fd8021d08a1bc120c6979b307edb7d9cc9a038b7f743ddfa0785dd8135bea9b7b685c6e45d3018b58668eb9aee3fd58053cc9de5c992722f793ad6b3d5cedfa42042fe58a6cf20ff903622693cfae1094d89db84d8a64b6eab32b17a1ad96ac8fc97a0acb4533b70177c06c9aec0e948a47ae80f07ee2b05e3841122a86bcb0682c159a8ee1d09013a4459e1dcd6c0d6bda76f552bb0bf8d7491865ed05cac0c8d3142ff93097b9f622cc5b120c3c43f092109409cdba3e31ac4ce7c8a3eec2c6cada9c8b88a5844acdd21c41d25672ece517d5c5a0d782ae50616ada0bf60120e0e85a1968582e67a54d796ff65aedaf39db59c0614eaa2d7247ac19bb99c052b2f815154cf463b039551feea3e88c00dc4be821d0ea48da9020a863dc24bdab83ae15ffc37f513cc4b63953871fe88b2564e01a0f3edee60fbcff691ea38387a6c9fe606bed9bed8dde602e81e6790fdd5e8ff0ffaab6ae23c63e932d770d429d81cec6b37feed16d493c90f2b0f3cea6c3659bb46a92f48ee07fa1b17d4a293586225393ef1a8c5607947ce60640e1337200b149bbb10cdac63d9f18e1874809816d11cc619f42783a77958e75443f5e67a3cea064165fae43b0fdcd2e142108fa90bd63840a5176cce1c65b639acb026462755ab68ebb726fb4dea0054285082d1ebada7db3a6a80137c7d0066b3cccab847e2681b621115b0f49494a454880c78eae64ec56914a7e4f76bc44936c4069ccf7ca4a7d47cf2ef981f0325bd1a823a14710e600e71942287907038b19c50dcb74c3e6503e378cf18d004ccbfd44c4116d04ecb021526be3e0469d27b5a8046a5c0c28a8b8830089f8b44e6278cc27f902490b467148470124ba4b34a7fe77597cbb6e97405a77634a615dc0f5d307ce07887da24d651bca97964c3e85e72d5064e53ec51ba716d42c0f2412375d5d91d648285b98c8596317e0c34781acec03577ce6e2be34c1e6a88c2f3aafe9b6ec532e644cf674a10d78b04826a48f3bfee804abc6c733b8b88c51f7495791b7cd22596798e0b89bda9468aa656fd100ae1388ae703f0ef76e724aa005d0e48364aae931e2c4c9b9d279fbf9b7177ccc60dbddc47e4cb95c8d209f1b759d288283adddf10f84dd375e35a7b37ba56f043734f948bcbf46492006f06edefe4a2f0f5ab76e944aa26c2ef74d9b420152326d4b8b17ef7a463ce5548183f85d62d9b3f031e4f5b84bba1ff9cbe7db4c42d5c29e111a73fc8ff7eeb77a29584d8f7852e803f377dd1a51372aa259563265380d0562bc06bfd3028369aa98ee8f47967694af80dca2a55f2f5606c49d6828d44f50f2e47d3eb33dd0c2d33fc93522ad6ac92103db906a893328c3a4dd0a72d36854cf7977f6d633b0d965ee37fc18df061cb74752b0fb9c12581928a4af10beae4f3d83c90bf1860461c6bfbeefbf63b31639e3c51be8269b8e9d80e581f30260366c28cbd00ed8cdf1fe216354040f204d27106b32a2922f86ffb1b9e92828b1f8a91eb1a15b96e2806964f9c694e01d7f51e70238bd22f458bfbb23f121e64d0d25dae13947bf804a0e5cec0fa14330fc8a755e25cfc1d3c92bad64334ab97e466d3bcc68cc4e1691e5c6d1d3a6da2e3004e4031cf51ae75be42bff90db327d31d6a0f5df391b0cb30d958de35cf3a14b11d58ceba12892e08038404b1e4fd8baaba4c3d12e331a9056c4e327a4e2800de04d1928ea201ce3db7fdf19496ed2897defafd6a41d03f76a475b28ae683addedcb34cb89504fa13d9b527d5d2444861743c53fc371f7deab0bb51292c5d495053c70efa73a60d3002ccc11180a745085008d026daefb2462c8564f776b9d2f5e861ceebebc1d243df3a27c438f4011e23b92b4df8db8a1da8ac166bd673e7b583e4da9adea215b0cbe61a5a55ec2b5f2549869b33b14cf51461293c745e7e34e29379b6252071cd7de4d25e6c56e592506fda07a85a54be38a8eb405118ebe6cc4e76eafb77232361ff8ea8721235c369f8d7a5c173e88703eb8522311f03e813053d8367e77ceafc9ff33b59122322b705d7aca8c6510360f25246c6057b6652487b350185d8b7b577c69c7447808ed621cfc4315f86ab9a03c3efd1be6f0fb6fa7f273580bcdfebc2b070bcdc37033d2bd94566e9c6a8ffa1dc480aab3e96b3fac88293e6bca58c4aae34628bc9ff9eb957ac3438c76c1f3257b3f62db0bdaa88f2b84d0ec95f72ca21ee2fd13c1141cac6da89c9651f5494c64dced84a091195abc92803551540ec7ae0f5599dd2e25b2c0523c4599dfb3973d1ea7a54ccdd277886aba4459ae2ce48eb23f7b07d1ab5114847c9a2a1712095eb19f0f4c68d2ed3ed2421809acc6155961cde88e678a1babf388cf93eaecdb40d2fda8a68a7b1b8a9a784cadef9e17982ccd1a0aba67a10b02af44d6c5c51c395d5851998c7ba4b8b16bc717d5beaa568a4d57be51395c5cee8719e00cbe44d06322baf2bd0f2b0bd1d2fd79654617372996b9b146ff5328bc5a155e223db9b90297cf1a5269079f2f7e451849fd7248968fa28b3c962e50d37087b9d10b7f23780aeadf3f16558163baa1520bb051f17a8f0fbb85812b8314a67e9c22d4595c7f44e255ddb33d559ab948f4cf1596fe09a38b79cf37c1c7f577e7a19fefa714432996d606eca8e6f3bd4defe9e47ae1b4c6dca4a76ef58d483b96f30f9359de37f591bfa5d62eb40e2fb23636e3f22c19bfccb63b7adeb4a3987653692bf797e1fc02e09e5464be83e700750b1c9cc248b8e4dc1470e1028c808166b5281d7bb8dfee5b7f1a8e1443659fb1b1531176ee4e497fe4cf207e8ce062d8a8b98c3e5d0a1f5c5a37ed868e94263bd8a3ebb6c331d8c265507385b983663b13a5f9607404edb70b42d0856cfeccf33577219fc1b72a658a5e00a251884729c67f3671c82ad16e3933851d3ae0e01822b4a74ef897de6369141799ad865f0e99cc7cb18acbae70c546213d558b40ec77236de5886235372daf7144bc0990dce09dcd11e044f7977cbceae4e96c2a1df233ef91eb52413bc0c637b7e963c0caabef37d3fee5c8c4ec82b9912a34a5d1cfec2ef3cb97a04bb4a9c84b6da35c2899552910ca1cdfa4811d0e3565323633999e572451ba87855b64cd3997a0dd0e8b54f4572873f0539e7dc8c9cc28077aeea6bf44900a20b286d761e55977a74ac9c8ee26cf3763a4a1494d43922ca61ec3438d2cf01600cb411b3885e3d860e29fd7f163c4129ed4cb9c37544add108dea53ae65a4543731df7ddfaa2b84f25de5f2b4688c88864197fbde96a31201ca6477ff515fecbdf6e3e07e42b7c13850d1f249c2d743b35b37c892931e7f9b6aea7b4474770e2cfd5cb302ade2bcdbeabedd04ab2f7657554fc22097344817e6bddab3e4191006c7b5cac5b0e860b157a95dd7a7e7e11c8cd04c7ca219be0da88d61d13690afac593f11ff720d2134e45c66f9fb0dddad83d292985b77ea064e07352a77b1099990c243ee4a6df1ac5d388414be3786a1c10e2b71e3a1cbb4b1f01fecd69791f97df2a9affdfd9c191e3819c49472dc5e9cefa06b5205408873c1875cf68e158e235b2deb99976632c0beefd34c362c4b2f14f161d052c89c11dd2590c3666431e9446e87314f28b00ac1e5e868851a71219dd965653717647a0c0028530887b85028703b091b2c81788446b42834614988766153d59aa342a781e5744553622a76a1ac04d47d8ec6f8dad899280c1cc4b0b1e42304ff5a7ea8a620d54bebd3ded759a0f2e52b7ce2567adf850dbaaf1e384ba0f60b00bae5a754705860587c361f261bd86ea1c985c815e8a383c3a2c1955795de41d81488d6412343d2c32f33191617d246e8761e30c298371558fadfcdf193f69dcaf37351225e4e3f9aedb65b077fda3e7a829e3525f68d9b0d6c839ff895da34938e36ce466a029d66529ee846add359166820f236c2193610bd3a9e160dd99974659908723f8937331f954e4d38c89d4e74484fb185278d86395560e9e944f4c8be775be8e47fec516738d5ea07054a29eda491eb2a5c9bddaf753fb475a6f1b1a1c08289a9536df33ee491da2bd187e2357b47114a27d4b34094a364717597ba61e4e9ee52e04614e64f28429fac15401c2547cda6de076b79db9f38210a28c7890e70c1babd03dedc20dc8d55202f4ea49da0258756171e48e8c4f4ec8ad907085d9dedbd5bd02edb9f7240e1d8d85c7b77b56b9e21a04ce9f26937608748d1be05d5b32ef4ce8dd451a60b328c83b736b77e5e1da3818fbe03130f9e14aebb97506c49f820153280cc740067fd1477efab6fa2ed72c30a2da56a3dee0d7c6d3f69a83fb3461b39d02ef9bad9f076142837d60f28a07e46145c511ddd7ab9f4e274044828c760dc68a08d74c11e3978a58b06111117ba79e50d2fca7621d7333e23a7a6adede559797131f9043e859d3b71586d61a7bf00e0b0d3a3c5096662f33594658fcd9914cc9e919da055d21c6d0f5c15b01775b6e04fa80123bd78f738b74fa85beecd22720f5c5c08493d154751214fde30757e0808c6c35148f51d7da03fefe01a548bbe6d259d9e59b98d0975fb36dfe385ffd98644c768bcaf16a900f07a0041f95d05828d6acd666582db2ff8276c20b174978158c9b6b76df1b18cfff4438ae54ff7883948b8206768a9be6b58f0af5b2ada5776d1a540d42d4862511d4824323bb4ecae772871481256ef9768aede78af094761cd0febc2d0cea843a4945e8331efb68f6f6b0c77bb94a8a1a1e988470e82a701aa1dd38744e14a4cd89217184ff818a1f29e2aa29f153d88fd3382576e8ce5af3abc4fa4ecd9cbedc540705ddf6ae7acfd9482e53a693eab0c6ac43485d8496b0ec1802d739d3732453f5094672ae2568f4556ec17c031c7697a9cd94f5a911f066ec0376823e53037eec4f1c9f0747d4401563bbdc2f8e0b7c1c89d3d30793985a2017a289f41576bfcfe69735813d344ea520e8d3c765447b8da6372971355763e8ec36b84dfad8999230a61d44835d24008086abc0d6c46d636fb0caa85db20a77c836305f58430fb59456aaa22b3c51c7369474a9f51ea2415ea4fee712fc3b938b64a1256a3cf91fd3adf414eeb40cd7c8b3bd6de31c7e05df21ecf09d5cfcd8d82d7e30dd109ee5622ba957800b293cadf6f767d4fd81877a12a55e8eb4dbadcede15feec0330f74cc1770dc7b9844de7d566b9f3ae51867425268edcd326df4c5e14c3c9aaa94ee4e90fd53f400bdd4830d270803b413c0629555f0013a0ff1c0c02efb53914e9e94141ecce50185ff097eaff115f8f5ab93f93bf608eb3467d05672c38a9446a70e332a295979c3259564f67226887351891e01c611dd9b4d4d2de01b0bfe570f7d8ff60b160df90c662e94a2c24e097fa921fe08373d824d6bbcf18a4d186af8a42e6e262bbadd60b90d94f05b8c6e715efac9894eeb5a04d65f09a38ec6fa43529f76b9c5e07ca83307f74d916cdbdc24272f52ae87ec0bf620b73ce3435a54457ba53c3e04fdb7c9790256162a6e89af5e870dd79ff0d76ad945f6780fd32aa61ad209410a34106e57bd749252b07430a406f07c36f6702f6f94a43f100be616650922b0f783fd8398a202022edd60d8419fd89969fcd09cceab2b0b0557da2509b0f35f11cbd8fe1b79e87e695542ab64f8d58f3920ca4cd8a24d4a015024e8dfbf3ef3022467fc049c3d61ca76689943517b75d1ec3319a58942a018ebfbc1da959218b192c81377cd470b1f7b13ef104c68282651d4cb1f18ea370a2be88efc6125e97306a3dd0025b954f80de4da05c39e345164bc66d0ebff6ab9ebea4c568693cb15b62717b6092be564e4e1b12acea8c66ccd29f5941a24110d21176a3f65abee92e467ce4a2b6ab4c954200aa70cb6a6a1d115f0fa59317a0005753e0ca450f0ce212b78c078815da7e88689432157bc976ac374d686f08a44f0e9aff76f2dbf06ae598cdcafe47dbbdc51f8fb43377f3d7a8223a8c6beda4365072f750bda868d6dac7ffd753e8492e2463b688b2852ccdd3fe55e4e131093866fba419b4a08311159fb664d37c2f8d5f310106489d7a7275b37ab4cd2022ddc735c49f279d6b9eabb411bcdb71c1f2a5377021372a456a4ee82dc85673086dac8deed338c478040ddd22e5f84972a3643362514e82051c75703e147450b402530d364fe827fda5928c35ea933a9f61f971000336e91a4789b17d22af8b7655a37ee13a79d4fd37ba523058433e95676d88a65d72b58844238e784e48aa5dd0c5b535275f2b9adac49c3283c152965bc49fc351fd0807c1a07b50a414fbe0d95db0f9050b0e8c7f9920b6e0b10840fe11e559968812066efe7d183b754ec2743ac88dbf35ae57eaa1bc29b4d663f54cb11374234898f47b098f0892eca6c38c21735d3facf51d070500b535ddfb489c7daa9090f04f83dd1571c9ceeb6877e3df5ccfe625389d3339c844a41609af0f158d2091899e0f104d1d7fb8902a61283a0aee15d59d81af788d6f8efc03bdd676a1ff1e804d22cc9e628b6e5d1b0ceba0938dd1187cba0cef81e465d2f65c48360f9dfa0a653ac2c798278daa4d6102069bf903cb3fccaadf8c18646cac17125c12fd23a039727b03c5604aefba1fc83d213f0e719b192785886ae88e75993f50fb3d67f89b7bfeda3acf71aa9fe8be986fc9f7505290657d05ef2137da2853176c0e4704311b56932c872bb66159fa5efa6e67213f06cb8721653ad97ae242cee6c017679c2e994eab993a9675dd230829321fc1d29ea6e9c0a601708650327e1f48e064639f76ef969636890c1b8a4887bde2ec54902020ded43c3a884f42482633b96219b3fcb4d38e7600fc28558cbe11f57b75b27a674cd603c3fc9642669f082e6c92622abc6694c357a371b49bc5b2559757e29f4a0896838e7e79cf45847e89076aedfa7ca6a63d5f52c82b50480c8f72f8e0f81cd4cbb5885897edaa774dcdfb9364668f2dcc338077367e394d09ce5b17faa5393277a57777e06fe1a60c7eba54128e89c31440f127aaf9cc444ce82fd0b316b0ee4cedf68a64ff8aac9934a5ba0f4562bc2db288f6517d4ae0cad2a40d0f04e134c459d80e7bb4c6971b4ce02b3403ff6fd270409ee958f452eecedf02ea292855a1271aab0564798482c83d1ed90374ad29f74747e7632e8224cbb911452bf4198fde34ee90ff5efd593c82bd367a1df3e91980327ef0759e558675ad6d0d1e09b5af1d8bfd04b65aa5622a1cd9ade9ccc89c0da3cf7ac4c9fe0807891e67bab26ed8e7dfff77eeb1751c7b4c3821f6dd9310139b33e8aaabfe59049c5913b6cb16a52067d0f58e89d8ae57882f10c127a603df501e17126f3a5c7e8a5132832c74b5543cb9cc7601408e0d8129e861a7768f22dddd636d1e9c895a0cd1c3c9e9d4be79b407e792476772bf39d611c34d241b8e21a2840b8455ed3b3d24a428f85fc087c9308ebda77fb7bb47a52c278a06526c13f077825d5453710fd33eb827d28586b0e73722b228cb398a9fef7cc9574d2b6e6afac402d17b0098aa02bdaaef8b59874f6109409c9b8210dfbdec2d46ffd5b94416126600df03da658f8602a1a92ae0b1a5e8f7d4e49d8d8d2aec64f2bf9e33f86205164b3859cb62ab0d140b07f76cbc209b862b81c902eb560b414b8984a99de2a106c56b814bbb37c0d077063791c8fea2e3964f5fecd9523e9b9cf16be4a3636d2111da9c4614d0d218b5965bd97ff9625dc9083f7e184b3836002b70a99d5212de960d1cc704c6ba901774c4553631fee7c9a28a54d3cac0146bcd1a06741fd4cf9d522a6d0bad1c2dedbd24a2ff2546980cb5ffb1fbeff9939f0d8f544cf2d99eb0a789eaa4a625fb32cf92ada40c0ba0f1148f6fecec87dddcd7e935ec01d700eb74874e72a5637f86ebd0967c17af4b6fef41ae6b74c4b58bfcca8d49b4276b50fed823aadb968e355d96f50f20aa73a44f25d67f566062e49cce06f3363a7c47112b5619ea263e8538e5b974fc2c6a60fac6a4436be56d5d1228ba2945843e97cd997d37d644402a49be73e179e3fda45f174b6116dabe11aa8644e9ca763bdb747c9210067239098ed03779ee9de2e2382769acb9f2470f1c915bfcc53519c41839624185f6293bf7f421d423f9eada5d7113ab274c8b0188c7f44b5c865a9d09194f77092fb91b2d3833f13a83f3f6a51987a691a3a99a817e8fd4479dcc13645f37281f4f604ac032e47498d2a97c054f14b18e86a7f29f770256f1151e689e60df73d132ad40bdba636afebbc5180af8568ac30c4b729392dcb99b95ec8062e9784000851436f91ffa3568571a0e2369778708ddbcd4a42c07a9a423e6e63a4b750e0fd93213d9ea9accfc8fff23e8cbc13e8bc997c0a6a78871eed3a7c068f08be2e93643825a53d0a11688452661dc561a9fb8965ee413f084276e743da4498e184723d2ecbc5609248ac08951625be2e9af53685466441dea6573f4b2a064e9a4cbf76d9369c62b9b55249fbb06f93dcdc9d6d3d8b4a238aadac962cc6d40b08e479dd952f35215b19c369e94efda0bc1a06844679cf2f1938e2e8b3b4f9ca2ac82345a9477faefa2f8869bb9fa229e8c6cbd915ebef23cac9af894f38a8b20b004d39be4fa4edad17f7c9f8295a33f0982bbe596a9fe53e782db2c316e43c4227ce7253d674b725267141700fb66f25998809675256864b41e0c4f3fd18de4b99bb8cff0ea3b885dfc144d95de59940742630a593202797479f3809c3f8bc1853d04089841bb703f70362430fc7fb594df0c897c7c016d71751b24861062690b29d790083beb6f68985aeccfb5fb44df84bd184c316e853f0621021a8de7d0b78f6ea6519af7c27c0b1def12e9b568f00945a0f5e5d083a3b92e42c52b27c810ff51f5c69317670e79346b0e67e4993bebaaa45279c9b913fb39c8872a59df5341fb80b454091d5a80e0c0455d5bc41ecfcc5acf34b92e9c6fdba0d902da1b1f00f772a4db9eb2da9e8207d75be2cc98b2dbc15d522066fd1aeca715fc883f250f564e9ac5ef2a5e3038d63ddc1117f18707b02311d25c44936c61a22c25a72316df0f0d510e913e30573690eadebde96a217b424406db5cdf9031af5cce7369b934a12f399bd63080317bbf7044a357f47c0572b3907ce8cf3e06d7f11d3df2bd1a9d6d44394bd810dc8323d7ffe1017115665d09d20770ae81d20272db3e88ba0d09990eea89112c1b4aa778bc9af503aea3fd55d2fd5947305850f355563239278277e65c23f8d57bd8123a425376dad4fcf11781f29db10d85c2eb62583393068c0d34410e67a7b65b4e42b1b156e0638dafefbc9555ea93df703ae00bc955e341fa8e8c2e2d11b7b618b371d97b8a6216eb5069add6723792c5cb7d85c5f5ba1bf1e840c1cf13b6a3750167e0021a89e2d73831e07503b283157176c740c0485426a1f3d691a880e3872e5ce72fda1358896cac46763f75888d273fa52f559716d4c5040f47955587f7be5ac6cb6591004d1fe216669e3931150af6186974495b585f04dd25f065077a2d694452f1dd01d4308561e046296c7a3fc4c4db631eca598ab8a09a80930ca9bf1cd3c4f963607ea664178fc054ce27374ad177789ea39e88be46d4e5055464ab8dd561e92a7ecdfcb42983426ec144dabde205f48462489a49ddc0389c3ca35753e5433ab99a5158869d2e61629e786c8401103462196b726e2ba37a9a3f82041eace47af4b88ddf61e5cd956c21115e6c1a68f9a8eb7420528fe388a0e82eba4ec689686d8583721604578ca6b6241918bcaa85b3905b82ee95bdb6b259c98832017685b129aaab211351fb484c9098c328fb29bb0234a2fcfc8db77180f6d906ff67813c651529f238a7bbe7478be698e0047d55687e01001a47f258adc6cbc5188b994031708272226f71d9038eb436ca6e40d7e615a43255fc02d8b8f0e8fbde3ba399eb9eaa2627ddb4ae4265c7a22a138fb2eb49c6ab7a722de19ba1f6eb4dd1718d94d3589d623e07db98bd62dbbbb5c3af55f3e2684343806aafe2e24d2e692b19084a4f8b694628c85004c8a4be2c964d665c8676ffc648b124ad32157906759b2a95e6445c97c0713963f18e5ba0a4c6900e620927ba8832271bad0e3ebdc9720b209ac521f1406ed7b6584ac596e2960744b05d967686101fc18d600a12047d5fcdad9dafadb4ab01f338f8ce08a24742b9e96dd79a3000fc912c1b9e903a340a259faf66adcfb29490f5fc9a0c52bc9375312a3ddac06cb88bfee0d9c6ae27595303fce5f42d2f1847cb86131afa536ff495fef3bc1d3fd11c08aabe3b1747d84f4b4e8f19997218bab7821992ad909aaef79ccbf07c591ef8827c2a56b0b6f2409433924fc31aaf076316a1848a8cac692f800029db75b5feaded60d3450c1c06a3dbea92e3a1814fb2f4e5c4fed89e3329149af8ab580e3156ba1c3032b973d40845770cac2099a35f96e9d0c1a155ca4d792a7aa9715bb0c9cb2b4d6e8f8f707e8f393d19debb7dd44aac7242670a3758f81f7e272e580917527368b041c605b8b03934165165faee87754366dce75444c6c250c3096f4b21d1170e22744fbacb758a3ecb0fdc85700d86de81e1972e1c34cbfbcb41a91f542ff7a0f8893ff52790e1787f49dc75d3fcb00403577d409b5e87d65d1bb69f78533d59a5c970ed55f9bf384709eb9b08ff1dc99be4acddb932974fa1de5e3654747f523e13d6a29b8458f33f2c0fc9c96d0acb778a6ed7a91c958335ff4b897aef09c610dec2503f583fae2fa0437350320c4cd0b779f2a4adc421358404dd457e88710d2c519fa6bbcf993e683b12753ac0b95017193d66e65ec5339d9357f88f87dd1be583f93646ed75dcf1a9e08c2a5d2907c90e2e33ab05bec478efabfbfc332140796ca0446081d5b69ed3bb2d960173f31b4860ae0d17c08e13364f466ec0a308f03ddd7fc6f880737eeee94df17622a690f701e759cfe1637cf8874f2d8f93fec3d00aea7f50adcb1694fa305ea8401ecc0079cec1094cc2ff450ba7cef4b1e2307a39a04cc2d0ccb47d2d97d29f3ab2db5c2278540052d53b33f1042f682adc38b9c6547d36e703b58834738dd9cff402c9d5c7e64ec4f5c9d6caab5549ff20ef19f53924b94fa77bb05b48f8024201cdf780eaf0342ca05636db1373f5ed5bba11055e4c578694bd7a0139e0e16ecda66f9fefcff8cbb795d110449b6adce721ccfdd64e54ab9034d2196361bcee0749f62c470b8ced88d73830113c9fbb44e81f1bb42d633f324543b7a448c499adfc66c71b40abb77ab37ea6d74dfc24b50b8a20b14c7f9a4c22e9807336a61a2faa09a0fbbfa4669dc9ae4ca9a76f50305aa8399f714c69da5dcad5372ecbd3eaa99fabeba47b480586ff8d703633cc614975c369c976746aecec26af5c064d06cbccfdf3762b2eb81d4cf6ad0a3ef7f45eab031e5740a4656876534d42d472657dbd38f34bbc56e544ef2952f941657a8dfe5041982216c5db93d820dfa1a389ecec0a768ae5d1d01dcfe7d368ceb01369d714443dbd5e4afb21072c770094e3ecb0940837b7a9d69f4b64de2cb2292173c81da64cfd23586c8d851ac43e13c8c66273f382036a62e194ac54aeefab0fe0b7a238a194cf88b02d673d84fa138326a34f63c1caef61324bfe010aa199f5e4001d4f07626ac3ed8f6796455c353178995249cc21a7245f8134515c9de673400142e7c68bdb866f421b3900d3e33d00d3477e1593dac8e35d0e1bef56791207aeb04af56c5b05a076ccd8864ffa1917ff431f931e04fb576dafaa348abc7e8c3536a68028e0d3027dfa9460adffe15eb9d8e627234b09cc5ccc180929e48e0caf386afd1b96c865324a53db1477c9f4f27139bb7983f7755182323659feba8dea2adeb5165d97e0b112e7dd0dcd1e91d21db167a20e97ea37de08087515dce391270e06428047fe406a1306b6dec90776b2808f82585997d66d50b5fe3e302fb97daf5fc8835e44f561d9f91630b942af1a8c0c9b09350eee542e2eb33e770bf2aafa30bd530ca058791354ed8577f763c8ac033837d94e7f3cc91fb71a2584b633b46e10c7acc4c3d77f92e99cee6e1f7b452c5f3d3baa5f4ff35622e5ace8517765c61e647960592eaa7d477062371e1c452371786691347ad753e0f9e6c06acd75b9d13a13e8269ca918bd9836fc063843ec27a44221998b3d6ac12aba17885324b17744319705b8cbe0ac0ebe4633fcd2f329c42e8748b71e791c03f59a57ddadfb226800caadbaffd6482e53ac6d8a41bf94a7d2dc6f21b496af68bb1b578a989831a7e0231a7277c0485a49420ea0da27e45f9ec50ee014254f879232cc1a5c4e0f1c74d7d5c50288d0afefb7d8341e0a957f0da529447df3198c873994ecdc24217c4ca12e4df071c80dd070c1df1022131a9097163f213b295e642e0fa31ddee5eda26668a0f90d39f4ee0ee3a8c799be46e5be8d62bd815ee72f5d69fabe1723f6b1441076ae9486b474667448c7414553c9ab9d8589f8192db86c43353e3c5563fa7ecc249e87e43829d03aac2e1a76a0e5dfbfc32f2860bd28d625d45de46b87d686fae8fa1d2f51b00e9d3c332e76968942a6c320fd18a3471d89223d2dfa00c4a378f47cfaa8fc71282ccf554073ab988292475cf17d31b973b38a0129acbc6af41df5bf623735981058a005af242e46c873c22a72c8cabd7cc114fd26fef896ab48432786cbd89329730337d29d33a07ae3b90ea3b76e8ca919cb93a2fa26a6a0c3bbfa624a98b08216d25b6af183f81a5eb9e6c1b4bed541054063efb75bcfd08e8ebafe7a2cece0dc20bbcd57931b29f14108b7da63ed8e9a2c7f14d75b639d626eb3ce52830de4c2a204e4229df3cb5aa282954dc9bd3b67e4b558cbf4e9b87b79a5cba4f5dc1ae4fef831b1924a1960f273f21f2c69e6bcc5ef8a62c85d154a3ec0600f84132ecbdcf5a4dc5761eea7d4afa71dd3bc3dac7b2fb4d87c84c10a8aa454a1ccce40338d708422786ccd05fac8be8a8e8ed2acf7340b2edadaf0195afd8c9453af26add4bd7a9ac2acad3c757628d4061cc0150a42e80e54e7bd86baa9801f34f1faa09c958a64dc35029a36bf114276b48836166bb087b278e861f5eaac4c87e4a5ac2a37c47212251939d30453334723e68068274a7b45628bc9a6da37e8f67243dcad36e6cb476b633c08cd07bf6ff26400b13ce595ded4dc88018ecea5a3bcb7d8aa95a2ecc36a9191018da329bf52d323e974670bdd9f2d3a6c21e3f55054af1edbfe39218278f8c1c173e28b4c3318196e094599e4c9adcb5b879f925cf3fa25f0a78a4e839a295c42e1044cd71857c098261a4e57ad81a155285fedb8c8763331ee982c31853349a35554259fff4cab5833679dd256bd8b40164f1fa77b84f27781b25c5b763f15342a2696f9afe1529cfc507fc17f0ce25ddaeb8724d0bf5a0061079b46a500475af6e008062edb33ef3a745866a3745ba6c8a8ee03ecc3fe8d97c15078c64c95a0dc4e2931749ffcf80368e8bb2d9e8b4d0d4a229266c0801186d447ad76330af2d5d54853cf31cf81e6289e7a08e59250473caf7896b9423d30d2fb0134bdd9d2089850ffdc306ac0583103b27e9422a642b1a0aa79103c2a73bc8ec083d3ca7b41895999829fca0a29cc7a9db0bd5653bb7ab5e550c00cbfea49e426e1213d9b8e33e3a690740d4edf39bfafc6a0bd923a048b97afcef3d54b42b4144fc15e75cf921b1cba98df22965463a00beb503ef490c86c923f75d7e986bf8d4f5868003521e7b4aa934f6c3410f83976c8f916da5adec1d9f7e136a597e69d568f407623f1f7c8d9e6e70ed0243c35c4dcf1f19863b5226bde84ce0453b4d8c1b5317df6a485fc9869fb288f04e18ec2b563e503d8e7b935571d94cc6e1ff73e373f950944a99a4b9af86f8dd03e83fb01c59fc6a992ce88328c2a1446236e9f5f236beb6319fbaf35da7ad36d2f63f3627927ae7991b488d3dd312d0a114ee430dbd1534e512243cbf70b106248badc36739994dd5bbfdddd7344b7712221d9adc3dfe715f3412fb8bb6822f1d55fe2e03b317bfd794d7dbd0d6a6e23074d7867b83e7ec536640673b65108a7219dcb13e0f7572c8a909cbd00ddd3c40daa81f7e9e759241fbafe86f4148c089f77c6016bfa492ff1ad9766fc4af21970d93bc9741c5ecce1ed17ded163e493e9bbcae239a7d6f21e1ebd99cfee051df48d6d0747145feb3c49ce8c8f1c590b2d0326d7b9f9a3005ebf021c9d56c1b75ac5902db6de3db189f038d85e36cba21745f3a5be545ec4b4c7615acdbd5e95c3742f70e1e5b449d894defbd2867e2eb67806cb364a56adf2a7264c2e071f3510e2cb38f64a36aa536b6486ffd09ff445e496d6a220728d6a0313644e0be55ba9344cae080d1ebaa9da2c9ead1caedd38308109b4a1d5a8da660f2b2bfaffb1dc6bd5f3069f75fe88ce3a8f410165cfa5a47cfa92c9e61375a45a8bbd01183df152100955532f4b3ba0676721f831678d6d867bd9aaedb6acb6f8c41cb02698dcb20d93ebfa93b971d1ad3e25377157a67fbb0aed94472012b5b28102a2e75abc9882d0f3a8ea465dfce1bae3daf4f52eb4db7c00b77e4758d7d3b9db4cd7c6a6d552867b8c97c37483c8f6c5e2698f9e57784aaa762705737e14776f09c0e149a81377cd50370fda46dc3c6a01901c8cc1a093082e88c56226f989fb393ab815be39cc6e70adb672fd8d5941df088072c9a448f3570795c5e41276c58683a62d5ab5cc40203f6716c9618c79586074eca22dfe6db3dec0c77a2f62074aceaa61d8a6b7e7f41ffb76b8e2c27d24281e082b140d375a279a5d7118e7cbf01c96f7e21483655ea90ec2e22b8c0114940f93cc83a48eb6c258e38b8376bdff699290664926ea031d076996005d176fab29c7def0c518d3246f5e8ba774f56a41ed4557a893a9ddb02a5154e056173efc00fd7ebebc1b3aad64327b999c271eb0e49803b45dcf753d27e310b63de040c5821463f5a75277727cc278b8dbcc784799302f71b95cb59f92c7b19dee0031a417049b6af74fdfbad410c20f6f975952d196c135baf10fed44a548562eda541e9feddc1fb739100f1501490d8328bf03f5e67b5fcfe1828af28112c27a1461bf0ed2ac3f15229c0f569da36008c3f8483aba22488c0b26836399cde3d3a072758985f9e5cfb32bb69d1f1e9a8c91701f753dfbde7f00a124acbf07d09d170b30f49db2e654ed4b3efff37409306007d9200abe7d950a099094b4b9bf6f6de3abea308da1cf7bcca505b932bdd6304e706c218f6b3017c460a4724608e567f5cbbe04930d62cfcffd645af4d6de15d0e2348add00814294aee45d296876c7e9cc0eb01cd2a7f45b52e2c1e993ae6343f26ea0e0a28366bacd0b7a5e7073a27a0023b848d39d0cfad2f5abd31e9f25279740a729f923573d191733818562dcaf501858b051e7319bdae69f725d39e4a8df091e7b389e59fbebefa0692623cc0ba220398e986920189795fa89be37db9173fad99e0f9c08ad24b88be44e142f97dec2eb4952237c7fa2e0cd73bfdb3892b72648292f5b97ac2e0827c8d7f7765ae8036d0f4ece0c51cb488e06058cd66dab7240f411bc692560a694903d285eb0c26244b0bed9cd322c8dadadfd9be0310666540f4096cb6b607e439669c79d6382a61625eebc06c3a7ff7f37913863d4f611a09a5b23ed23fc5a8595bae47568f95f413b45ea4aecd9ce6e15d8f496f4c120ddbc1206cbd2c29a54bac8cece2f27f00f70c617c99c32374be22b8a6951906506f163c474b1ca0991dfbfeeaa907a9b7dd2f88a0831169042d10adfc05650953f4ba4a3118b1498d18f8fcf0221eb3742d0553c20785f645e10ddadc833e2425058e7e347ad2fed1851c8d9cace21ba36fa53d2424e22d6958e35bb50a121e994ffc175ad8db28be82d0d1d5afbce11cbc472c74bb97fa0b03e3364097d26f79e8e185b5ca2f62cf523f12c37552d67b87177252ee45cbf0c9929927880a457c151d2c221b4eb1f848f69ecd8458e33d112675e3b924dc347d1273b0b29a21eebcb8d5bfe4126d366ae5b7297f80fdbed648e59f79ecdbb23aad4796fdfc267b642d0a10978f495f1ff7bbf79cccb8a8e884a301b9b6ed3b0bc6378766fc943cd24424b4691da44def0f9cafc5645821c1564b767dab678398df18fca2b97adee76ca10f4673bc9052445c46978afc9917f8693e2e2abed3216f10e7f9202d64aa76d0f16d793fe18e2679318fd997d620ad7665756f4fd9cddbea6ec22d562a63dcb213321bb2ab9ae64664cad15ed51d949cc9434b66b8b9f7ec5c4be2756d58c7b08c8cec6c12e01dd915307174b81b15db799e9bdcbb36dc1be27ab8b36fd52cbf7073087286a341dee37a708ecdeb4fb79ff11208b37d78144d03bc6c0c70b471033be6e10f07cf3fab4650bbf178601571bb47986618e59a69a3cce594485666b40aec464fc064ed1d280cba23c1e85c01f0ac55e968ed7b653bfbee6a07f96c95de42e92a396fb058e2734b61d5397341da1b3ab68e72ecb911ef5fcd19df4b778c7bfc9a1284b91419f9f92b12f870d6b9b02608383c3fda064c7c2a7ff82cf642cae5015383ddac01814e8f7fc0e319f756f7d7ed65c238cde3af0a7ba760dffc51f5be1d547a96c13c8598e773f0f152dc2a12b5377e5e4c10a2ca900eab5569c2cdaffa9d9a084d041e263b3ae540889c614f0da07ce7aefb3563644da4e72a615f1fc44619006c0a51f9e4766b8ee566a531bd658245830ae8b43f0ffa0888627b5e3279b061939020b6c07b34e2efe51387a41dbafb0cee1ab1450e32ec05","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
