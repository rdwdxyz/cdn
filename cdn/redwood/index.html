<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"3b3e84f7aeec1c2959f1b637e32d0dd3e1fb11e573acdd69c8df4b965a459c8cd95e3a1de0bee15087fa3178020bbf5c8743bb913322e80c72554b364ba41a33e615077a5a95df0b6d7e7074e40417a25173708a467e1c5f90607bdd63cbbccff9d767fc24c6a2de431bcd67cf7017b6f98531c9ead63a41983ae67c73aa5fede59d5b2d29f15ffb1be67f6471dae7398c2af09964358149fd1863348e5e18d797577adc017541058b52e0bb4321d5ad0c6be457f829b8708e89568d18a986759a129c7acc2445a96d4ee3cc9470f8efa8c0078be83e1be835b7382b2eb56d67310a890a45a749b6b177e11c09e3055e917c16f77b2254af8461fa0a5b8eea9475dd7a9cb6620d98125257f67252a095b2651efebafd5ab441044a9a258d5db1fefcca93b8ac8781ac03dcec6a709d610ad0b190ec1d11d01ea53e4b419e23dbaba9fc2ae8c5217fa5e9112c20d791e66df9cbda35a2ff2c4b5f4aafc3c1a8bff9b60e9b01d518f83f14fa8a7eda84e6171d75b423bec272405d227098c947179dc97d1f9ba71d65407a6e63f380556ca72e5e04f59344671132f1c4c0a03c0448412ab0a9bcf02e6086f7dcd8ac7f6b0bdb7fb05f137bea9d313f12891457e04ae384741987a172a1cc965bf19c2df5afd7cc2dad4c6ce58eba478f4e78b382face37f474f152c19132d13d3317919f8c805c49b08c1aaec47ea1d374db2fb1ede7d8a8e9a12d079ab3d1b447efe4164fff5321720cae3c8badaf61fa4d1dafaaa273b5b3725f46c61f9184e841b1702b7ae0080652398b7cbd90e8c4c608f04b82399501c06852ff4373d68e9b5b7d4d466e381a8f1326b8a280a2e3809cdc7063f988d0f160aa9a830716d9141282e88e69a29a97b5409552cd7dd3d98c9df7c6e06424b981fc5ea483dc5eaa7d88719baa4ab9a13c627db90a4a2046d29bccd15f86ff87ceddbdb071b13b29133817b13b605cb04b11951312b01932609c1d66572bb596cde395901ae4963c1d1ec8cf4487485c3ef5593d5d47de47ef395c689b1d08017450870a37c26876abb1bbba72f0687e37220ff9232a1db8d6ae41d7d87ee1874fd0998a589516888dd2eec2508c3cb6b5ae90edc23e4077cf58f591933e8a88d27919ee45d7f21844856366d8d418f3a81e2b6eef03bba75bd7c6ba854121208a6ab60144bffe5e4798de7c1c4df09a8ee9f14084e30cd24fc32bb282c6bbe612ceb1cb81fa3421caf2285d91824203709e65f9cb6f91fe0a23356c20f6cf3aa9c54d0aa9012c77935e425db38353eeb31bcee621f107945b64fa9e437205cd72944ffab2bd3ab3fc1b83e3c9b18b40ed7631b078e32d84659477d8176c208892c0966fe75682645e79c9546b92d84097d668a7ed539d1164ef3fe96e964d46ef3472055949411e22d2d9ef3e6a460028fb6d2ee6a6b585765ccc62bd13c94d61fe120fbf19c8310d98e4a88628de5be03a5c931e0a8f1be31f59a251338332798aee188ffaa806f4347c8eeecf9bb4a92845c4ecf3c7e8cf95a9b2ef456bacd8759430bbb72174e6c2d4bce338c0db774fe55f7d2266bf1f678d7328bf520cc3fbd78fba0c25bccaadfbef7a624aad052ed4e370c1d7c16c820da8e00e03c8575f4f94432e8d0afd9f5aa5244be217a8260a25dfbbde7faa37a627c0515914d37f0d4f5475cfb742c170368e9503754706ec24911dc14bcc9022517c7aa02aae8d9a26e34ff34fb7700932996c901e4aca2efc01b430a98171ce2eb4c087d3a2e43f97e77ffb9c80c1c6f6f15bb57dd01aeedcb5edfaf678be537df5af872246d045dc6ee3f7b0e51ca27f251196bec8c17a69fb4d29e1cf86b225838484d6fd96221362bd6684bd1dad4678b3e60971407a9c9933736d4c1240c14439865d76552ae251b2aab68f780670620279206d7c932375bb7f8d110fca0ba76369263b4b9d4296973cb6f0c59f3e0e0fda5bf67ac7a495b97758e80856f1ba9c3bbdc0cdf9c73162f2daf420598fd89ba9b7c7987026fde8f0c172749033cde56d4d77da40e150d5257cabef711bdf4ea631fa187b15e71e47b7078ec3c9006002d7fb44d43cc8a501a689ee33de9109c41b6d800864cf930e8ac0295b2f30699628de8041e3603c291f314333277dbf862ad39c824115a22a47d36af34c2bdb9b52fd18275b142c0d62a5faf8d71f1b259e1ca161ed44e569b38371903b165ecd6eaf90a308aa92cb123c7a0d7b42767d981bfa41db069383ac91c5c83c9c434aaf6932d8912178509946a5dfa5bb46f296217350de7f9b92f357b29ad6da6d0ab1bc666ff03592efb9e9565222bf82a0ce2d0bbc1a1ae0dd65f6e88950b824f754c546798a52719b3a5c85c4c494564617e7f4c4c5884ce323c6bb0c1daf310559e906cb6d06a9f11f72520e06ee636c72175fcefcf3280267c164f133cf31a776f1737cd79d6280735e4c5467253e920ca8fb93a6b8165a94a98344484b99eb2de124010313885dc3ac640c8f44b6208478d09e780f5a9f3af4535d1852e3290c99a56c20a0ad56a1415ff94ee9e7b9a984dc26b7d845d88a629bf2435242b9e01900feb6e2aeb6302f04d7c4b42e5d154d941f53945d51a132983d38164b1689efe44af250f02b6c6af504317e9e70cfe4ee8ad54ca9294adc63d61845947f0258b019bfafefcf6553d263dfadcb063c4b626f36c0781976ba644fc4669729750493241d5cfbb1636611287ba2d97485913d2f94979dae7d4be914415775c7911f6e3a3a43394163645e71043ac207471aebaca65b3598b896089ec962d9761dbc5a1dcc5ee8e497decc4e85dd297d8bead2ae2ba75b74305566c5a3e16826737dffe9a5caff36fc166eccaf7ce6c7cec65a1e84156d55a16b13b3f4e97e42def2cd1232a948860f54e01f3c0c30de5b428e5cdcea14800f17e51df0852336d024a1b559bf1ec86a646f595d050b95e407d46200b6f8e7850e0ef4c2b835eea8468da846126a68ca334c5335c06069ae29784a87285d675ffe77e33004c5af9c5bee1c94fb4f815caa2c0bb5bcfed03090b60f49b2b51da57d2e1696c7ab3ffae9a4f9de65d0c9a51bb52f8306b5e7d64a394ca229d5f20691d83c56e03ed45ef61ee743f6a27dfb8d84b88ba9e70971643f659e9a8d34298767257f2a91c2a104366f2678d801046df115f7ef240814e585ee6336672a2194d1b6055ddc49d2eb4dc14720b9d75bc33be4dc4e980897d97b282de28a44fddef0cc263a68157a5215fc10019b3330510798910ae9a9be5b6fffd92d4225da2fe6950c1b211fe2ee286a3aa4c669774443586a059cd00933544655521edcf5e80a2bbeeea0fdf2e14ecc4caff355400ee30cfb700b86b3879cd44567d555abcdd0bc3dbec7e5098d02e9f8828d8576425b61c917ba8f59f3edec6872bfed10aa1aa8f90429aea816ece8b8f080b7bae5f525ebe0fe3fd0a8845e37af627fb9b9559b71d762ff345c63b0b97af387d7f2b015677a863a1a9de231108c67ae3f5153a6e0e37dc026f3cfdc565694fe8cb43e20949a42af843ff942f48e41a40539beb12ae7079b74b9afd2f208ebc2630213cb90d2314bd07b5c5d27c426c796a63c6312d22b6843c9ae0b7890e6e6b1903ec7b37cd055e878561aea674d57d5f590c88018e33c51a4c5da16cd873569a6f9c67d94f4f2b7f1e760ad6672c16ea2e8a0ac53596dc960b29fc6d15d7bad6bf5b473657fffa291222b48d919f46c62686e1c90bf40d907398981dca059da38b0b5f52fbe665c3c21101a317b0c9ceed59125bf75ae0b8589b3ff1865b66ac94b0273908db2e6652a63dd0089281899b0edc0ab4feb05e4a28f8a8cb08247140717bdc33b42da97f71d9893ae7ee3ed5a13e01a724c7de3c52aafcd75a02e1520204a93415f233aa808c2e3d8938a81ca521aa8d347569c9fab88a341132b472d1c3d30f295c4f2b09a6b98185a6e84f192e1b3c56e5d3f188b58cbbae4c7ce535544e603e40b2faa53e1fe1e4ce88921d22d00e0cfb21994b4cb6036b06f55f4fe9ab2cb3cbdc51aef450e67c4352e05e043ef3fed47785b7bd878f8ec83b1c81c1a141a341fe7e3ebc10931671f3298c572530acd7d36c73a074cce7700f300704b1ef7efbe28ee3c309daf4f80b281039483ede4e6474c3cf8581992019c2c379961b0a94055af59b7eaf2d3d935b8fa50cc953f45e60e4298b80f9c4157c256fb58959d4998d3570ffb4d5a8e7b0b3c4b2199d1b67a520cefe807f0a9b7cdc4288e20902f3bf3e6f8099e815159a9fbd7fba59c336c61b566d65e97c1939df86933b9477f9d43ba7884d00c1e4cb7e382e781a0d2c304a2ca6d8b9ac73cba74c1e80250ba0e9b5d673b3bbc18183550ef92608222562647600a0634320a17ea36d94a18e121ccbce1201f4482a3973d3c1ef0d9fd82239a12416a32c69e18abd55c93b669dace4251d169c8a3d01006a94ed283447d10315d125db60c0a0a1a82cbca7cc5a8480b76f1427cf361dc7f9b86df82e8de2078f8b7bbd8cacc9ab11e3686d3d0a8dd688e67a49dfd6853b0a6f012f4f0aa8ba4ef9f694e73c099adc5ee2fbbf2de52a132281554458ef23ab1bcc9b201201997c9486c718e4bdc051538eeb7bd4679aa982a4a20fd7c2a7ee8b80752cbc89a020b2b0face44030041625dd4d3df19bab8205f853099c3d09ed87ccc65d5fa35dfb36780a4c2ca5bf311409550d5978cf7330c2de8425b1c0706b0e078e6f8c22c52499952c09f79247191a5a590787e0cbac7a7e50b91969269f5a13eaac4f0aabf166d5e88a629902f40f5278a8a6a99665629167dd1831ccc846df29b241404431397ce3b7da092421aa276b1b1af22f7ecba7ed36159ada74286ee0155ebabe98ed6c3f38b834cc51b9f3f977652ce810fd35d739a46102c41f712f40165b515292c61687baf88122de17921ee07352b7cf1fbe03d6c9e5b1c42c903ab243a90ae90d5ed5512db8a9c52959f13109e9ff354ce7dc1986dec996afdef59463605383e2fa85a0b3bd956046f56db1a0e17d127129d4513775ab79f1bdbd5e0ae07aeb32c25f76e91ab00d55e2852ca8b6c5f0ac5f7fa987d74254a1d41528de9126a597db1a752e9a8b4518ea0ce519c09a9e8dd7a23be4bce7df14089960b3f8ecabe180759585d9dca801d9583a8e6f54847c98cd60603aeeb3b1c8668e6d1d416b29cb3bf3528c088d9738907d5317d50d2f4c972ac3b884111f0c623c45231498457fb5bffd83ddb71f682fbce2f2d8f3f2bae764fd0f65146739e2552f3a7a8ed6a6cd26550ed20e517f53006302ce93d45f9fd35f2cd6f7a5f985be5222a6983fa4fca74e38557718fb290c15d7839f07be019bafec4283efda0271f75f07321e59625ba784df458e93980c79c0ecbf3ac3f8041d5f0aee7b43780b8acc687d7f461b064463a60ec129e96f8d9f314d77c9c76b77f9e0c7b6535462bcdec8c3ae708d93483dd4b3b0b6db48b7e614cd1423f38926a743a406ab85c16fee7b8213c749fa2d777754ea01d5a88c354a04fd2c0f86f9ff2a371c4fd15044fb7529bf3a188dc4ed251b99c6c65e3f37a92aeb97d940132d08969034da6360c6cb205ca94a51b477fe1ae68d10ba932ea61fa101252fc9f518b20f23a8a3770b86037a39c40f835b0e1cc6f93af4bc20607cbc0d18ca1c34c3daaf646757e81f94fef39a21fa24affae4cbfe551a73a4e5c912e5913be5823490f0036aacf9484d13ad1948142ec13cfe66b1f891ad6043b7a43a106c5359ed72c90e41aa193397fc523a68501277faa68cd0422ce9bc1607f7c9faec0de9948a70bb6c217e7ba52bf4305519ae610a2def9c25d2fc4a8e9daabe3cb76b670b45cfd83ccfc43594a916767dbdeb81b0bbd803110f5abe8b69ec408f7f655c26336e9233bcf7d33b1bbaa12e4bb51eba2f70585fa795e6406c6d4d7bdc52026d7195275d109172c3f3587274c82005431392715036c4cf694342b8f6a0b70259c8e1aa727a70477baca327560f1ff3fc01f6db228cb85853e80d37557f9b39ae38c0fa9140214c9035b23b9b36865721c249000c4ddedbb2c9adcaa54c34d6cbfc4b6cc16fc7dbf131928b0d6406b749dfc918ed3276e066a5374ced988af12b8985e29a98ba2ffcf2a830304520266b35fc9fccf7f6f76eb2b8819e589adac0e4805522af380c7a8ec5e9c92fe2e36ad3e1488f5937de89ae4147e076f6551290dea8374b6909837a67dae089e07d357f08fd6d4549ab05924e07b9ef9cc9a30d01c5d793ce6ee04f4ca5143504658ad0511b7c340f7bf8b5b1b5400fb4a77db8e7bb5029c4bf333b415ee4679035da2b1b9bf4da8bec517edad7d498113bebcbdc91125733f2393fd4b4de8b9576109d93fef417b284ec1414da6051573860334979d55ca35e03b3210a0ff000a1e2c8a3ab66541393e1edc0907b52c6d75a31fee7a1c402fe37c99e9a2e3ae3fcb87dbe1faabe091a23a767763a7daad135166682343965886f6520d9676446dcb9fbf7abd9243ff4336899be7ce7b67b1ed9586b8e43b048130e5994a7201875fa4f2f2cbeb1aef222fc252aa9d2a68d4b26fbb9791252b8d1598ea582f0008b7100ee8d37055044bf703e8ed6261e8ccd9323ac924ac2a7ac89b039f7cd554901aba67c3c05b1ce898702acc2a1a4026a4efe3efdf599e238ea513854de9d46a4f40f98760b9362654007a9ee348a3d51e18b4f64a59349964b1da8bd05e26091a3144c4a9c43c008fe267f8a2b20028aa04113501c41adb5532cb883e4f376e70dddc6c1485267cf65586a71e70915831b084225f2b81ec2391da60778da304a45abfe066f798ca5e8dd53a27e55359210ccc0287c1389b8429d39741610807fd721502b7bb0fa9278a0d63d9552affc1d67c80b1a8554be45e177439a1f1b913ce55612d7b0e4fb64f0be6bbdf510a128287de504f0023e05da54f2c83cd312dc9fdc3d9b36c72432222b38cc20aff974839773ece6c73442643e0259f3cc27aed8c075763259cee17901e0b176757064735163fa91472308704a7fdd3c613f096e24a3c3ae2d0d42267c54f7fb5f2efc0c25a45eb9e9a7a3469f6994044e28d73bbc460a2f1d822cd82c96847655526e55fec9e627556518a227f482fb545c2fabaa083b6c9cd4e16aa384cbe3f65b3eec937e50f11fb528a4bcf1f7e2dbf7c9ae9c808172e17b34c456cc25b563382664c6fd7cf4ee1f879432869741b3bedd5be11b2205f1bf8c117fd8f00c257238ffa6bef82237c8e91416bff5658d94295fce6f07d75b95f88f65c19e35bae96028c49cf06193c5fa0aa3b47d9c0b03b7acd9e509fd795cdab763507e173bd98f7082b3a80ce4c1996dced0e38a58d45168452b59769f667a2652b41c3668da6b3a63564655a93a9ed0382bb55842f00f7918ee23fc4ca11b9634cbb3606b8b229632cf8b7e2773bea0dcde150520a09fc930224c6d242486656e78a101afc08a2c1eee51f2379a36e9d2e700ec27378d4503bf062da1fc2ac219d9c47c4aad7b19fe4e40338ac155a90bcf8814f7e2811ef46554d7603a09428e1f764f92ba7bcaa69cd0e24572ad7e488660c0303fed73a08777a09faa072aa13df5748118af5866c8739c68e82eea4acae630aabee776a5df9b159ba3c4eabf0348fe829e2f729bbc967bab3fe87ee3a0f4b8b22b6c2e25e74d6bee1c15578ebc98350141fb23ae6a98d4f2905903cc9d1d43dac3dd7d463bcc3645da87eb64f4d99c7e9e94a8d7c0914169de310285bebdb6cb9b5c45ec6118cea8dcbbf311c7cba8e0ec01b09fbfffa369d50e1a15e031596ef0ad5b96f433f65010003b81676c2780bfd28b99376a9e00a61d8ba30b721ce46ca8f0f9f8eca3877a1046d7755ce2bb37fee5ce78059b3c9d09a930914994a2917d91e368abd309f3ed2c74c007077ec27a464be5dec2ef2e346d7387588829d329fcd7b45bdbd8422fc33077941cdbe4b48c2d7978efac5332f4f1d171d6dc936db93c24ebbc9b03a56fcb9306883764c92eaa3f77859852f9e61ceb071e5e81f7acc9e4d25b6aa198cae819287ece3fede8ec9655487f050c79e82b5ffc8a17afb3ea83fec6c85910997575c5f200cb2df7874868b99ee691c2b63b7b402315880f5e4937e47ce00c5743be6fb1564fba4537ca28b20a79eba62c05f0ea4bfa8b4d50f1370d332f0da307f3637bed8af84ea2953d75845f9f265008d707cb5639017a5c10dbcae72283978c479fb978745eeeea48760d8e9cabc8e013d2ec32bdffab4b6a38a7c5447885cfcf6c40963efbfa5028ba2e65d0717f892ba0f5d53e2ac8f39c1167690fe8db05b085895bea429585b007da405017dc788c4d57a6c0a6458a1e3af0a4b246691c7ed0ba1559eb849211fcf8dca8ed858147d18c5f299e51e213cc168ef950db4b6895405b98a98a9dee671a7ab19b54c570480e34267e666a28039cbdb0f1657e424f335a0f34e386caa4c74c8e53197934fffc79e6bbef49ee595f7a0bd6a4db6a5eb14638445b79ffffe69eff3ce21e3dd7546d3b8a841fffd49c0619feeb0677849f84b9c4eceed34da68d512ed0dd67d9ac508effdeaf5086419fbfe47597119ace2e2a499a94546f8bbf2186a8f083fae702a4ff61aa714616042b9aba9f2ca19d00dfb954227a3652dc9da18ec84516161f39d1d46842c29fa6aceed9f067b95df891009ee80d0425e1b732e76b771b20027ffeb83d86b056a051067e64365dacf10e27cbd87819bd8ac7a2f1ba1114956c4c9a49eccb3fa0ddd8debd4958f51e04aed5b913046a0c13cbfe3db05205c385039d85818d5dddad6c42e24e9efddd4cce8830ee368256b56d82a9b30a4a59eacd5488a346ac03e7f37a08a3edf0b558609efca9b9c3510b4cc66e5086e36de99286ddf66f3b3af823cdb1300a7ad059c8e0efe6a826fe934deabb2f45a2ce93a4f1333f27b5de5b598b2d0aa94debae7f32b514131e617bd47317d7e8de77971d72a8bc650a255a29343485368b28b036f1aaf96783f4926dbd851de6f0caf50197a58d5356cb859c6e6e4f8492047e6ca624e2f2ea746f6e81bba9e184102cf92b72c3f73ffe52a3b01af8e1395b3d4302b18d8bac128962592c2566bc98ef5326eac5debd47afe39da453272a9723bd160c92018ffd59c7b40cce4c6f8d3a8850ebc15607f8f8b77a3dc65fc47180539978baff52a4fe1a5de554a5e406468fc8b658ce4e96aacda3436b8d052a539e4c4da05c97e2b6876aab077f782ba3189c5d38e2bab96f18914b2898b4d5bb46e0b44d7ade585303cfb3c10a52471e171103adaa1f7928ec1f8f4ab1970cdbfdf55e6f0945be91dd84ceb51a1c83746870d3082d0efb8ee7f98c9c07cdfbe0f6897d4c71a8b3e7af038d6669b23bdfeb199dac1a4cbd58fbab9e3285f83dea5673c146287d92f5790485a1b8894a09607bae9dfec3501c7fb658170e7ed1000b476b478884640b42324bc273bcd563648121a6ea7fb0bfb1184d57f2ae248f4c0eaa4c4da215dc8cd19bf1ab154d3eb2aebe0605600dda2afd43c81fd2705e3aec7dabac3cbaf254393d6de83d2a89975be42d451086468d750e589af5596eb883f7ef48d6639128a01fd111899408da42a8781203b3e82f1f0f8bf94cf26681a3b6051a8653ef48d94d37cddf93757ffc22e75c15fab6ef1726676b7788ca3b4de1d17f610d38a3f160980f0c33653a4775c897bf40572eff5bc7db8ba3299bb555bb67c15a881dc2a017b0064b03b0566badef135309a1f8161b983ca1b5481101a72503510aaf76601cf879bbdaf52360deb7368d5068240fae6fcaf9a33e9317f3f4e1948d70c17c6a25898301fc03afec1f5343d3dcc481ad646191b152a4f5732034cf72597e8872362004042f819002d9d6bf5f0b7b3b5d7be910b4077d038d79bbca71699548b23dd70dd8081d26aa099ac523aac03818fec014dcccbab6d4473b19ff212f33745f27f2c2838e5c96aaed2f7c8310b87d5219cbeb962d1b066c60c24d2b407b0aded1a4091db4424e4102887442f465b67a915f1cd8e36bb5ec6ccf250f05570ac5b5e8184f008d751d80d8699b2ff6ad1a764f1dc260263dbf33f9fcee71be3e91b0d48ea70bb64c9837664360993f04a2228fb44812fd9fc53bac5ce377ccd8b6c14942520243ab4f38d8e2210e3e15bd97afefb72dc2f19195704ca653e0ff38a73189c309a227ec6845d424ea738323bd1a31d1f27f0a01f083e86cbd573d1956e47bfa022ba062f58c75dc8f0fe3acd0c9399252d5b52b3807c39e04d3c8be2bcdd84017df7b287c6f3e3ef9137f67af6fb2aae987aba2f20f6d65b00dd42a4983f507ccb8f4155b31fadfbc6e64c0289190c8a4182827695055ed8324113b31e1d3fee76839c3a7667ebdf126ed470ae2d0fe15bd93ca889f08252bcad8e01bf34fc31ef95a41942f6f9164bdb5264c33fe2466fba1e17535cc34081489df718c0aa612af1c10747d88155a47efeb53c0a63dddc50f7adea9beb6988de4e26f5813c87bbab1d4a81918c191151f7d9adac407cddb2fedd7083e71ebe1df8ba34755107c7ddfaa7efd6e18b157ae7903236f8e4399441836c68e2e812224aeb69057372c0f96025394f5c06b05502b7ed78c47467f1ac9a1da21165ff84aa230ced9b2ed1bbb11f99de4d0381c612bf69a839def0fc1c52bce969e6480e8acb5ecfbbcb77e5448e6bb4fb476a2c560107cddf195111bdd7eb48ac0f3f2988b7babc179c19b473960b6a1817edd11965cb274f6ce7366f497525043be04279ba885bd2610499af4efdfdaa84f9a94b0b05ee74b5762028a45507861f7f0a70ab03202a35e223f72961e3d45500b0c38ff3ae00e2ef2505e5683bad3a16351998a699f9c53ed8bae837674f3fcb7eeca8d256bf009b6ddcf631d431c7fe8433ccde4482f4a06c74291108d429a1b9131a53c24d0e42e19b5737a5fbc6182e70aa8ef5c6100e01ae07e870fbfd625a654f2b5cbdd802f5fec837c87ccbc6933158180ef9aa8bfac694342656a243bade1261b5b99f3765c227f5843201ea146a02c9a6aaa1cdcf46da78fd9387dce88d2ad68317aef4f6ed0750dc352fb766f7dd53b589657a338b0dae87061b2bdd58ba26d079140adc5ab6e53f1db09094690899a7c83079a0e134fbe3f84f9d8bac0f2055c8d54a73f27c4e0173699b6c51cd45327f7b88248d759d7ef863c08d086903efc0bea2f4a882b5a07f0e5bc16c2aca44ce00c5f03a8ebef03acb0c9f2bb552ecda51274a529b65a2d2163331c970a935c665aa20034290ccd7400a87813545fba9cb2263f5d3a0cbb18886523f1970e124e808eaa082e4335f0db49bf0e84513a4a7a29a89732b76497ff5528e57d758a6656803e2e302282e505f95b2f73c3f473454b34c21fd5eae6d74c2f64d9b46bf525118809d2112b0a65c50a960aaa51481439b504914a8b78c093f576bf1488ce0a687460560cdb0843553660b3decb37e810189410a9bd28f3144137a1ca2c7b9495fc744fe00ffb60835d1150641d1373fd2c49f98c740eb6f38b453f6a669e55ab769e82380d2b8d935012178dd8ce732ec27697ca63a420efc2b157454f09498d63bfbcba52f028b1c36faee0f6e676543faa12d513f7658003b1c7df1f134be21db6e2acea41ef374645881e27be3a733a3c875eb2c7b63b1eedfb99ceb03bd6293e305dcf42e1869cf2b3f9abfd54205d103a1c36eee1f7157d0cfb1bd1c07ad7b734620ef240623be2d5d69d19ddb66a7989489d9b6add818f9cf5a8257070d60258f6523ded5f64053f505e98a336ab15d50c3f8ce6e85491fcf52d5999b102cd809d6f9eef728fe6bfd15cb95f8ec45f12cf1ac9ea6f2de392205b374f54cd068014b5b7c1d8cdbf9d9a61ac00102369ca90b0c5e4ddd18cba76433b9bb1e371af7017b235d7d297427ba8d291573805eebd03a1119eeb6f0103de635adb83e5265920c2419ea747a9e95e1da22d23a3a34202aa16f1d402d3ab7f2d5a0520b75fec4339cc81ee81e5a52a30512a18a868bd71647d6c5b541035a7efde7752568b79c44dfc9da18b931d706219c37b6f4d20c20451e6d6ada3ef32f5baa5e2388bf47a11113b83d1412536ccf83ca8f64326ac8e1ff5ec6ea320967128016ea0f38be0e91d6a99683be4b9e81e593f9b3b47d16fd8660483ae36d1c9aff2b5bbf7af38fdf5f87d559105a1c124c85f078fa0e79d0a8fee2c54c573256990204d2850649064c5bfea9249b203272c5cbc6a1b17b5d67db00ebc261bff75dc1d7753b5f32297d6bd5a445350f05b14135e1a004ecdbcd726cf009e5ac44147a5e9c6872ac69e5d33a82692d2ed59c41996ab306cd1e6f8ecb1820c3387c2ceecb294f613585eca97500eba2127b4b9b0c07bfcfa844eaf94141c39bff10b2c4d202e82e645131bca8ced94da72e30980bab7406738c2dc4214fe899ecd9266a6216fafeb5de8fb9c774231998b8623100fa3cff4ee234a1eb6013857a7c0cc266759391c6fc476000a8c266176dcdd9c2c5bf78dab884643e3108cef455087e84343c64e323e6401c2ba3781667a01c1f245df25303f20fc67af34f9417b994e00be1be14e0ea1ae115a1adc45604f80ec1b7b5139e9782d8899b026596225dbbdda88531c7e96febac4c7fb3357dec52e71192d0455690369a38541ccabcef35bc12d234da201e2e7e3cbc56adbe8f72a18f4cb006edc6457a63db6767cfad98c850afaf934c4d85b0ba1332996d86b3e84f6fbfa74f5e62211f2d83e525b2b9deffb6510871926798ceab791d265a2894d9359c0fafbb138ec55be161fca159b8493bdfced0492020837cf088133a7ad3c609db2fb3fcdd428085250c14dbe0e723280a38058cb5fc9442c8a467888a194bece2cdabfa0aecd170a92d0ca38b7d70abf17e9a5263a97ba3af201052b03425c09b065358b92d672251cfdca350a8680e461ed0ee1278227b446bfe18a2061fba1f3697d3fc242e6bee8891b0eb26d2df4152020e892973bb4ee960687ed2bf5dcd021163e57946cd026f5347b42f777eb4ff3b4f5aa50b5366be9fa29f53190f7e8cb95b32d7bb0a2c70b77bf69e861fcc699378cb2e0a9cc80ad55bd55c2911c5d8335f08df8d73145cd5f20634552b37b49f372a4ff7c29fae8417251355042096f6cbe571f9c8037d67ccc32f5be5dd224088b181d34d0396d77a3dfc22beb50fc95f707f65aa0685fff08780d51dd2baa1d8c5f505d28e83dc0c77eb514308c4671d009aa591fbf84e8eda69db0c4e77b09bf42ddc7d8a526551862eab0cc59407a20d321ba93f3c7476ba70a5a8b8bcd97d8d021bce9c0d42829c121fc02163696891b8aa2767098bf7ac3610b296a73b9606b7bfb110022d4e3b425b6dc2c53531811d15bbfc39f3c3af4f17c89af05845b1e3c8fc4dd3117bf1ff4c446283b3ee646e54f1ec0ec9528c73035ba0ea86d9c0bdb81f075645047d0326029b68a2fe7d38bf0a8b2d6d8e634524566bb56f954e88b22ed9cceafe48e432f0d0b1521b0dbf170f60026f3cd061234285c83afe6d20c7669ce0caba9d340207d6ff443e884dccce0bc4d8c26adcf088788a5adeef79b5847f51beb723a321cdeda2341f1a2c77d16a0667c794e150b77858d4cf3bb5559f323d16007fa437780da37da97cc524b962c5e21a29dac2c951930c5aa70e5f4c50cbc810bd88bade064c3e124a70dd64d0c51c6dd4323fc3dc9a3c4e2f5ae84f6f4202d1c41851793e7b121d908ffc5c966196f675cce4c7a31c96b78a387f3be25fdbdc2ac5c04acd5ce33d78d088b8bc7945177b7160fdb888cde58541532597ada17eba7700e789c6be9cdc7ff180188f33736b2d8d6ace56a8b5a493c516088f8f7403a1081e144929358b7be3678bf492d4bb1de11443d9401b26ce4525e891c513c7dda834687c71d3227a7ebdb4fe5b2d83f1e22317bef3fb35880f02d73c4eee29d71777a55cd425542f31640d6666cc78ab200a65236bf1c2d067d12b002b014076bf72a6253bf1b021418d0458708174daa5f35f1fa7cfaa84f34e44af7e5687e4c097e30cf3d0eda830efc8682b80cad3cbe9b9489fd74229bbfdc9c1b88606a924809691bbe3190816e0f6894b43bd64c4fcbe64f55d20236cf2f82e3601b9cc24c13eeec2d4f7bd4afb58e7fcc16721661a373e2ee6cb7dcc363a5a8fd5959a19bc85210d495d50c71bd0ab4ac035c5f5389e8ab7e001d62239452131ccce3f7f3d545c28a68bcb452f78326bb43e3fbea171f1514e1e3d3cf8400ad6c29d8641f76191340962879ca8c3da3f5807a0fd8bd8771e73221578f87ce96fac48daedaf0e2b75ddb184d8fa76ac558c2f562fcfa1a0a48d8e4d287366cf1a0ad99d0739e85ded40cc87457f0020199c5ee3eefb7fa28cb3fddd3c5b22de3c005c0c121f33317f2cf13a34dca319e647978118de858005e36bd2f94ae0bf4dd1fbb07ea6801b740d852a14cb2bd1cbcc32fe2470a5c65389c26e53f8c1cc9c68413127387a9c3c923cbfe9c84424ac4a731f03c3d499d9b294e62884fc490a1ae991686815022aa680df1929fabdb1d55abad59f15bf4cdec6abb0347ad57a58a9b0b9787af299d4d721d8771062fa8668ba16becc3b0fd5a74fa9bd78d36250f8827b0aed9a84295c9588424e620cb6462d3454aaa6e470be236df6e860a118543b6c73998730e69b8de2aef71dab75ef58bcb66951b6b518f9283a84f6d2208fcc45dac3e2e0eb3dc48025369368047d73962b6ce105447ea3e8318bcad6c621554184af162b6d22697448cd9404fc8e4f624dc37bb9fe6da85560036a912b947271782a7caad65e0557a0aa315249ef307361d6d3cfe7d3e6ca4205863d415335e6b3f69c773d3fd22ca0c0496178a738b90355b3957f011c94ba97af4888aa4c26668834e8a1b34bf6b831b2d15f0883074eda183bfd264510c9663bc569a8c28f811675d47471130ad42543e88753352009ac89e3b8b2fc4ef8261b25b3c557e85be71f666c18dcd2c520a72ed4fa56a622790f05d2d8144be690003a0c8036f05a573a4946e315a390e3c7525cf15d18699ca6bbd720781e37c85fc7764428a6134b1c156b38bcaaf91eeb9c37cfa8a4fc94483f6ca066eb28e7bf0e4bdec36d88ddf8398675e336211351161c9b3db1358b4e139135c570899987793d40a41ca3cb7e5f079d9e6a44829cb57d18e8b37975663b8aef29314476e7fe87a406074d8964f56ea4fe169eff54f9add8bfb3d1d84ef663e9619e5142239a2f5e6dce2e69bf0a6fa19e3db1d88184bd52cfb7f4c105c39444ef37c0bf1cf425610e7a31c0155985b5a77780153b439314c526b3e24ab937640c4c7cd82057625792005bff0066ddd3709acdb5fb04b2c6c15e6d1608bd24fb89e3a43d1f18dde361e9901ba74f8adfea664c6a3738ab175a24f4b12e9a0676f64e4885215cdc82724aa6deabe95f48d94ae66cf1541c681596ace1db56a88f679577c32614cf99b8b04fddab91a6151234f0bc38ee919b6b7f30564fce209238ad755db1fa333a2298c0697864f573e51d74a15ee6ac182d664a620dfa781ca105326476eb138ce9a1397c2511e59c0cec030b88db71c5a788bc35623ed4b45e8c596ea55f0b35d40fc9262b37c619ff0f1ddf9b01a536fdf6a516664a513a84d1686e119c944e40c5626ed1788a206caf6ea6c70828c37c75f4c0e7c784363f8a4ef591aa91fab6deaa5765d4afd8fd10b18e3c81c4dcb2577e6b43beffef40b6ccd4c2d8ef833cb09b65d4445bcbf34e44bed0ffba66c28c8909e1158bc50f00a48ff53bc5428d4be485f1f2ed90e5a632b27166298afc993afaceffc02fe6084087f80f8c8eb767a822a25c51b99c985b352737b189e9ecfd17fc744afe82e49aa99baf70f7e8a8c2ef616057f758559afab61bb856290a1ffcce7ce125f8b666dc3f074d4eeb1d685f65bdcc7b7afae36e76fce7b4fc90f14d3af10b7cf7c8ef82b2c63de8a01ed3358f638882cbc02ed1550000fdbfd7f3fb2f4ca7b37df435f272b3e0f9b2e19c7ec8ab29396ddbb2f1a75d56dcddbbb549f40f597d1a11d728b55b6039b60c6b23b582674195fa495408efe9f54d3cd1eb91a7ec41dcf7699afacd1f5f638191a705895d43963e73dc91db1d8e4033dca7b48b4f458b7fa2303d16510000d9ee71f7d0d6c2e0748468656e3044d299fad04e11c702a6eb1655b2bafa18b70ec7703111df9d293ad1744dbedc4456ee74c98bb59ce1a23b7c8288872817df51e551e9de33879162ba192270a0aa0e8d8c001e2697b315d52d5981b82da5ae6ea5d7ab1e5dcc791acf7229c0cb41b7b277de0ae52adc2daa8a860e005c0942e01c696336985366c660db34bd54657ff0dbe67d163fc494d5b045a7cd07010471366ac942745480404e9eb87e489068b2177b7a6d016415e21e329bdaf07ea7164dc48ca86956ccfe80fbdbb26f2ac9281c009c02fd25872ac4d91f183f5ef237bdfd6bdeb8daba0193ba0ee6f080fa7109f66444751e0b62f8cf6358b5ec28897fbed25132239e6366cac0c3bbb0ee900a8798ec605c56a0fae7ac6f25204f7fec77518ecbbd0f94f39a2e6172093fc783583a04763b4d804c25a6ca20c8af4700cd5c4feaa41eb29941c2aaa4d74439e1851b0cc159e9c2f3abdf201f4d6f75ad62bd933dde96043bf78d13411b3517b8166fecadbe09c88c32465e5863d50b682d286bfede23061711bb16912c10afc4a76c73a14b46108ec6db9eaf0c4165069af514f68d4027e0b664719637feb2ee59c703c6746d553b130f1ef1afa275c4ca942b46f40067c5b0b24066f2a7053fac1df5c30e2b3729d0fe0103ab8338a58aab6d23ff1f9c5bf4c96bdd45d4f10b21d09a7f26410f2e042a36b7012998f5aa370c51924b6bb20b38ce55c24aeec740e78473a13fc299fb8917a1b8144060e3d32b7e5475223602859bf5ee0c1b5b94770d1f7893ca0ece0aa04e8c9dec99890439d896e25d49f09246cb0e999c6349833626173c36e776179d4f6aa3b2b6cbfc401b3627e2c4c1f1e72f7a7055dc5207de44a167edc3e7093ebf009e6db20291f98829340c2c69099fa56c4c9c3af217e907ecaf4701582052b95a095b985b7890e17b9cdba6d6c38ad58ba3abc3db74a88d8ba1a3ace6b857057cdc355f3fbfeb5a91f5ff75a39755eca399ee2995697e511abc6dc70cf2c3732ef18e4169569c0b7e4724ff61a9257e62e15bf2c930953348e5b2e5ef48b1427501b74cc477503ddc5b59839b36801e0f9953c0173658268daec74879e608f37623d06a035074a75b3751053831b621eeaff7d401c499f3a773777da6039978c97bfbf7224bd94ffb9f133307138f8d65a4c65eb162482aec7d4ea32a93923a3b60d883eb7e80e7a29768a6d24d4de509afbd623eb9af927251d398f5644557169d7ae5701c0e2b22db05d49e4e35a96ab0371ce8344a00ed51caa6aa36ce1c7284e11a64113bb0bcfa45f5806fc96b655c7127a93bdd1806b5bd1fe91adae08d2d57e3402a513ae770d1b305d7cdc2272a60be1f10dabff0d702d32dfebe7b01f5c553fb1426d1661b0e0c5c9a61c81e7f7af1b69ae7eea2464e753e1496d0b2e1060aba89f408d49b4e6023c0e681437c0d37e9603bd4412ee6ebf5a61f681d648e65e9bd862658f0550ff39a5649e95cee517357043a191ab58db9e5e245c7c8d114f1e2f33ea9ab7f9f80294a71bc25c8a03eea78ed6168d7b898dce8063099c7c8ad9f8251322e19aa38e2cb0c57ee9be8d42681ac735d5d304d21c40bbcb12973b127e8ccee27c947cdd5f9042ddc72fb2d69b9411d3e612d17f301c732022d30a84df373623eb58c3ed5132d03b2ed8495db379bddfb0a528fca410fd9d4199305025ea79f9944f2c427a96dec1c23915997658b9b6","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
