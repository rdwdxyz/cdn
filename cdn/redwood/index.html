<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"8307307eceff9778dbf5cf634e3f04289f15e5112ecd46bcf45d2bc9439e73987a2d093b2bc11ffc59729af041c6758d351cca102eb352580cfc2f6d7cfa86daf1536a45ac7e5bfc9bca3b7ee9adb2beb4a23aff282c799b9e415ef8083bdbd96c02140d860cf890f3993bf1ca915b21027b1e507c3944d0cc13bb9396c1d4c798135bf334dc372521cddc54c0d89d8e4166937dc965b12bd5c275010d928d8e07c8029b66b3858cbf699947bfbea48376bdd918b1449d9c2269a067a4a41895af51a249a5397670449bd22e367b99b4d81c0376eeaa6dca0d2072f2af37b468b9c0a3bcef976df1d5152248a8cda45cbca86b80f9801871f8ee0399a4992455475995a8c0be48554b8cdf1de351073c4e978b260dbe8aa933d375ed49af439cfe9d1ac0567a83b5c857694be203c7b43bf0f7893347dfdf6a9e5eafb2fa9c8e0c2ab0b7f319d59ab919989612fcbd176fc955f5799b9c0c69163251d3847e1d10381d6e82f57456ea8e48b54f596d51361dc8db50f4a3d4c2ce882f56480104a8d85e52510b82eb215da9d6f45e68ad4dfb7450e339aa45be948993a28b5f3435849a86c2f7e502e19770642ac1a3bb1210cd6f5edccf626dea1c1a785e7618ec10bf303ec378a1d0c236b01ad5af27f08b5d1b54a1fec4fd95a8d63076706b12f4877c2617ced94a7b471a793a6d6307eda0f1b32b2cf79237542f55cd426064b1c86dda16851bfde58ba979ef4fe8aef89c212ec44f8c137d2db1ee3befdd465ff252535e9b1e38ba9617e019e10b048af626fdbb4abb35faf37049d0284cf3da7224bf44c247f7b39a878a10c5bc4a73f6f687705c1d05448eda5a67f19afdc2ae95e707e6d12a42f45b0a384ff01851bbc7fa7069518350242a24b5065eafae257f5dd436759193825971d1ec91260a0ccda495aada24b804299087d969e0bfb21c45a96bdb6b9dabd46b883a3b523a6f1aa3b88dc24a7eb09f8e665eabe874db27bcb2d10d92ef5aefeb97fcc42cf0ea235720368f587a2c0b25ad3fb2cd51314b9b158b7cd7c03914e92e18e1d5ba1c95e6027e5772fae1d193161999cf14bf3e3d05b41c45fcb0b3de45fdb3ce5ac222011c241b0da27ee9b1738c02aa6c9b92d14659ed646b0f71ba986f13dfa9fefc1c752e4b9614d6d6032bb92daef8fdfc5a305e904940e0a44db29637446d6946189a29cca9cef99e41187ac14cd5b39b71f9c2838e8aee79d328415acfde8f2e04a3f38c1bbf1b726e21e2652a92ae130b702318f7f88e984aa3babe96cc538b469dde377f3b8384519c2dec74d15c790d55bf9c4d3430bf5548582615b1fc9065da768b029b7ea947e345c61fe75dcd53ed88d92262a71ff337acd132819ada3636a2811cacb9e1e3ca23aa3fd1d97d245843ea72475db8ed6c6c0f3b59dfb3fd9905c66ce1772c2afedaf19449ce64071d77accde3cb004a46e987c2733efee4eca5df454828f9ef162fd3d436d8d1c225edebbb79a72bdbf734b4a44b1c75c805475336476671079c313a033d7889cb25d2fcdd236c7ed34ea0e8df95e02e2b48a0635385f92ff131ce87919663e47af7aad1f59ab21cfec257dbaad3a09ae3f6db5c2950183cab51d5af84c16a0561c0bff61b5f2ff3b6b8816a22786db97885680a160ca57a4116cbb1ab83d0bb61f8ac11bcb634473e0675b157ca7b790ce4a11cd84a02039a55d1f4630dfd772bb75fd7a2546011c01f2e8980fe9fc4848f90232a1d7424442815dd732599503997599bac80485990cca57db282360db0055960292ce935badfb5620413192e7115c420121d67aea04fbb4c14d2dcb84759b444e1c966542dfc2d96f81986f7720f3bf5d95ce29f57de62e80f4e7c0ad3ba1d8c8fb912da7988d9509cffad90dfbf89f9d5a0ac09f48b62fec833b36726894bf71ed0232d337d75fa13b349387f55beb7ddc3f01d6f1b5426a41b1c04a95cf37d0cbe40a97cf6dd1a73aa8039202f1c3f110435222d273ebe97fe9fd5249065703450a93b60461434a3a91d7df296ba85144a6580e8586993147f4a12a93802e88312df74d2dff74032a7fef5c065b0d2361f3998fc931e9c722e755c0613634e07c04e8add8e8e540b22a58d62fa4afd130a0f2a8b2885f1cba4f5e38cfd4c837241ddbdc3b0e0064f343a17c70d218b007f36b25401955d1272b71a121fbbe82cb36d89583b10ad87fc49d0ef12c1851d519b17659cb987c37d68a26ef3a2520de8e62a7e9aa299af7bdb12b7af80e0b918932b5f972cfedb86c501acba9ba882cfe7e7208577c76cabf782f70466471f67e57970fbf75e44a8d2a72a2027e1c80ac439cd1c1611f40af11d1c842a250ba0ac1e2cced02af0ddd7132658454aedd65bf3d73dcf642b8280dd2b27e55b226f9a9b5b8f760a6d9637460eaef56fb8c515ae384680f5f7d4c3cc025bbd2d4fed079e1e1662794f877109c21bab4bda4e62e374a15a1904c3e47f7c3013a6f12a59978a508cb0cbf91efe1ca26cca4e23d0471686045ad98b5981e45cbe40c29b422179bc711905b2dcae811500a8934b990f601ba25ced261849639cff4b05e49ee0e20009d46787a83e69f2db41526a50a66f42828b2e2af95838e57a361823b22a8bef54aec35cd7838b9238e042185a8f0177ab75f7340eaad006ac1c6d498805dc44de0b565e66cfaa0d7d3482a4fb188ee2f2dbd0eab160b7ab69bca95fa3132743dae35ead04aef33b6e7b6efb6af3ad4571ef1433cf1c8682f415d48f46f59763833e60e079dd7f3b8bbe27f875a8f36b789a4086cb02d38ce9eaa3c270396b818644af735b7eb99eb249d9cf652df8916a9c869eeada64f86a08f8887a4f6cd7d815219677ead0769e2d2fb41f55a4c4a05833272804934ceed1d1bc950c3a146c6e7486af0bc17e5b1ecdca8795ac80ed36ea1071ecda8d5dc1853c9bc5d5d999f2ecc800728b375a94f97de1e530e8fb6dfebba75f43d2f9bb4e31c76378490ed0e386af1b744aedc45ca2eb2a66ad5e86dabe530ee27c8a02795dc43a5fd3e572f0a74d00a67e83caf00260111a16bd5df4c458fe9eeaf93dd113050f10101730163cf47d4d10c4eee00d4ec7881b70e67bec10f7cf033ee5e86ec2cb593cadb9420d0ae7f6c527a587f7c387e05becbd376534e35a42f5abb80b82b7374360dc1d4050f0460769eb6618cc1d884f8a3da556dbbfffcecfbccd7029c0f87783f282998363b96c34c1b0ed15bb248bc54ab135a2601a2b07b22827429484438754178c1b68c679c23b9dba2fdb4ed8fc3b0d1f289921c3ab2f2d4f13bc8084bb94b6a23dbaef5cfa820ae2d82d2c5c2d5d90906e6c155a9e76c4c6afd46f13c455c21e2a1280fc80a40ac967e034656b73d8c72c7c8dc579905c228bdb5c824ee8844866f78f220ed48c9ad494ce2e84c1d3ca540fb50d3f5fe3e30d666c29ce73c468cd045333fc3fe5a8118166918d0b37343dd171b1d6c2ff9318bca2d41184a3ade9c3d399c546953831b28fe17387d26c4c81546880aa6722c53fc91eb1c16166236a7701c3b76773dc70572c8539a746a7e6168e3974c65e0f1dc9a224c84e9a23639e828afe2ae9c623fd464a1c7edf3e07e0c5b4d1a5c10415043e5ad4d921f72e4fcc6bbba83806f682b6765595e572457900ce315c834897a3621bf71ce3b6e64fd93284e813ecb7c7f1bd09ac9e6d26da68321e110a2c9c2fb2c5786f7b38e045ea4b9d40de2c92b287aa11fb82cd46dbc938d741438d0227e6fdc72a87ff53caaf93c24f290330e45461f531dda3a517984827edb2b5047d6e57a76ca56c17169d0e459afc8d7b6972b650277063c58b11055acbf1f510f198f2d1549bff4743442e945495cd27f20ba39e6198f64c7c79b8d180eb92a681755d0a263d6d26129f1a19685efb9602a1801dd38b7bba8a12730e0382c677d0a06cb045695587110d61c18e4831d714e9df8c01b112b8a397f50f2fd8e29b380126b16465fa950938691722d8b336d9fa07d05c2bca0bd1cde9d4c4c3e613499c506dd8b95d94fd7b63e30120a3aa34368351a49915389c4ed04d9ee8bd4561258d87f158d4b88b839b67cf18358e1b4b233a72cb52079fde6c3b84302889844afb5bd9130c3aadd3b1f6680e845796ed549038978fe412430dff37f761d825016b06be8be0a223a37507a2f03ca69b9fd2bd7e3ecd9b37b3397a6879ecfc9594542f2e734b8bcb286d1d4e111cbb979fe5fabb1177c0a100af9fe95214c02571457a5109feac9c084919c2e23d8ff1bb062aebf79c93a523c5b61c8da8d557d16e655069205663a30c3f5fd968cc7571da6987062ec8d79a4ab261c3117fc7a8e8c95de37f525e0bf91d6a201bdaaba656340a69c5ae56a78cdef0f6fe7ced940988d57d2709fd57750703f9b3b9e2fabfdb53699bb689b33a9bdc55cdd3096abc8b50a50d8b91f858ad9cfcdded51e92cda72c233de0615d479170a2c5fef79308e1a67bb53a402a39420452192d7253f35b1e42eb02e545a1407b80aadf246085f5f331dea9c2fcf9337a4cd97e1da7bde73ec5f769b1684838f692b495330d2c7f21d16ebfffc7a21ee0e1745cd2c477d05b2ba46455af6e09e45e1c4b50faf2dbfcefbfd82c097f87b3e5803f35756c871dd52324710935dbbf1a234e18bb5066e2925f3d8dc3c528a45c8418ea8cbd192856d331832cf95f4c23b297c6c5a2835ada49bebd8c5c0685766c66c338572be88de5c596138b951789e0c07221c97b937f23c28fa1a2cf5e474a52d10bbcaba38838f5331571de275c6f5fe02dd56ba706f7f96391208f57018ba1e17373d7f7f216baa97f123aef6aa083f8c5c4bc81a052a32e9ceda48a25b66503443c0de33e234d6fece2c9a6dcc87bc351cde6aaa374135bda7b53131500f302bd0b64babf714c4ef4463e515c79787fa438ee55acd5fd74a5354ef5d8c6b6df5e3b5384d560b933f94eb3813839c88e2fd040f621385b60d8d24d85366b12c013db2db8074be4337f8d73560979dcad1ed0c0be509ddfe4f93ec8efc14274171626108a9de31135f056279a8e9cd0b4869d2332123df61ca31c55efbbf6c26556fcea5fd86e228e6164e62a6b59c5c28775d92a7131456102c2a2133d821de594293d65e0bd58fae1c98ff6e73a225b4ca6bec762c949ec7741540533ea3ae1e415e50d8365d250b68daa3dbb748edddca36d3189f857b4616cf8e803bfb5a0a9e5e099d21891de92043d04ac69173bdde0dc10435642b0abf7e4a19742770db9148e48569c5f82bd98a74b033c6a524e50ed3ff1a07bca9501d6469abbdcd812ac62979f340883f53d3ac26baacacfce349f168b7faa0d52ea0409a1c5ef5ee64e0beee252bf5a24c10072e0ddcf98580c994400a5b64ff77aacac99a05b8d4cf4c837ed2d90830181b10c394b411e674153c8c9a766f3e8f441ea412e3b4dbb511f79543496e36cb11d0c24ac79031fc75a3527910cad9e64dd0f1b498b61de80d1ad35121f01728407668d8c48a7d316726adfd21c758140704a559698b80548aa9034ea24da357b067896d47a112b97a7680970d21a0e67f346ca70cfea2c2f12b51e1b909bcf83b26e4790a8648101af19503db772d5fbd8910d7c3d5e45c97adda0f8db7bc5a21d476a08abfc49190d1f0073dc35e0b3bf5d9651aca5e9ebf994356b9f0ff14a04b4010c9cf118cb437fffc2600e06b97ad7585bb1988ff023160619c7b866ab80631b9e5fd2631a950a35703c5b2fc33704fbbe62565079d3b0848d9a7005106af967355639644bfa11efbe5fe3c79afd59d4a946b1b37b193413d936c25f9ed3536f26f5d1de263ebb9aec07a059f4ed64ca019bd1bf5e730656f2034e760b7de7753689a3cb21f54c41efcad76bd1996f8f1e385fa28dd6811fe0468e801a072739b6afcaf48639df19111f57ffbb5c415fb15954c7896d42d326f07cedbe19f92c72dff7712bc03495c033c082f112daf5bf3f578c145fe8cf4b8c48fde30e0ca68a17be6bcaa4f745523eeb63ef09776d6d4d2b25f22507b10b48e91d08fe687dfa618926988c9c10fdbb3111be320d0dca3ab4de284c9c86706fb40e26853cb6aaed1019a4533c891e969514c9cde033bb8cf8c4ec3d9c5a48197face035dd850a64460e905de7957d3a5506071e41d4bbdde8bad4684f0b0dcd4f8653670fb659bd2fe07a1f8df7d0469ba22b63da377fd5ccbe9f084cbfbdac59b3305ab226210617cedf58e4faff25d07ce236c0c099382fd523b9456d4b65f68b13c0e3437b51b6ffd34a0eaea9a455e5baeb585c5c488ed374918093ecfad50ccecb3aea0a3535d4e0677bded6f8e80e6fd6f57cba5fa6f2b104d1e76123095dcc691413daee41538dfafe241cbe8d2a7d9b6a5798326deb900041cc6e3b9baa3b06cda37a588c78cae6ff8fdb8d4aa664161ee597c2057a7351c04382f565d76b9db00465dcca29110466c486385707b054f7594dd9a9b3918d61ad91fb43b94dbbe05eac34038c48e7bce77bf7f594256fb4a3c1f09241274ede5963dd2e26e4a4ab68209627cf0a3777372fd6802d4dcd14bf8d0710bf488b7ccaad9b461a8b93851db82168e2d955427e6ae7f6721f144a39aa3aef4baabf39e68a71cf19ad3ee82904d3d19a020e56eadadddb592269f07c6dbf149df42ed6b23f33419aa10477e33dac4a7681656dcbafe750c67e8ffc13664e14044230cbd9a840f15995cac0581a29d37d657330dd0b45efa85a3a7e6d483ea8c015601484c856d24b06647880dfb8126e23d0564bfd501da2e613f0c2b4f4038e3198880bf29ab8e4ff16cb23d47f5ad34b8df309c6149d5910ec9638a28d04d7368b12b980e6b621ce3990e2f1667197678059a61e6913ac57062591350ab9188a6082ec1e89a5825be9fe847c45ac620e2e635265a43477801e78bc2718a4638cffa250f5422829dd840e470a8620575c1bf4038c6346c332de5b33cd9932a9ef2a7be8944127ec26dbcad3925249317b84223c5d63f4ff0c6b748fc82ab1276ca7cdeb25b546a7eda306e8003688221c9bb5d98de78e679d23cd4f0177241ece6ad1b04291028a4819e638b7b163788af09d0d49793efd791fed826e7ce02f1f458fadeaab05bdfe4b24bfaf0e27d15c71074c2b93a3199c14e6f6b95a31eb6cdf887ff7c6ef4dc033dc92f18466285872b4c6b746402600f0bc0f06d01a0bba290e92e61c8cf215034b37ccb66a76bd8b11e0d856709b6f25d4637efba85db9972a31759c82cd5446572a4352ae1b4b3b23bae22370d8c76162663358aa27dea8bfaad3a9d55c85ec01d07dcb2855f3415b2a1cf10248ae1a381c57502965c527d01739f283306fd2f5e7135f2acd5e1d591aa5bef1e75e6020bc17bebaafa67d40bd1300e618c6d24823c35f62640f2e996aa76b653b3e1961cda4d46a1082ac6985e7fc21d3658131049b1fda2ee7fd64331f53700dc59256b5f9293990b55c134d2093116827e6b02fd2f04bd0d42198b0c3578b00a04615c09a56db23af26fea9fb156b9be8915cf85b68f9f013cfa125fb180082e3ba6030ea536356c8205173377b0cb43e1ae2ed636e4b652be37983cff2835b249815eb5adbe5f9bc3b31c268e56edf016506495649a85939f804220a881e9e5f5d64823a64976a62682efbda3d6b12f811f4878a40a1c21ae0cd25657ce63c92a555add296b58b17ecf04ded8a5efdb702e7c9e77ebf085144943b3cc5cf957a410ee12d15efb8b1b5f51d1a8e2231cb905e9d7ceb93049b5c1a1d9fb5d1d294d4e4ddd17d37853485fff2c7750cd38c2c5b780ecb31e50f57988e45636ddf3b290725130acf877f2f8a00cbb9ad5074f480e6f1b6111569aee9e8d044e98ccbd2ade07db22f4921b7dc04f9b3505ccd0fbfe10978cbd21781e9ba2915645dba8e86ef608243fafcd09dc1f6670eaefcdb4110dd209424a76766638770d5e0ae3ee3f141f73ea9ae926c2dd08a3f4717585181f96b38ef5da3eac5ea3e70a9c8a185a9f6ddd8f9a2b09bf165951178d7630f3df531ce5ff3ce83499f5b318a2f594180103b27d1035e1efe4b333129d5fcc53f335f8ddd54923a249c91c86c77fadf270bf1a7774306bc3d8058b8dd1dbe90cb83b68a4d15d37f12bc8d7618d3a00448418e82458a351b75b2bb1a9cac7d11d1e2b71d03a207753207a1a2350bb73fad10a5d076ec7b3176959bd6e33d1d0c25cb5c46a302fb9ac900325dcc358e10b6c87f7b1038392ca300da46ea6e6c91028538df3f9969785b11d8de785fb9f1a6dfad821e2c4afdba305b2d111ab3cbb152907f656c5ac817714c0a66b7df3fe123653baf1e387c20d184a4d797d806de6e6d83b4845a9370bc6c785b6ed0c9be9f0e742da474883083591a9e4b91a34f1fbe0feb45d3ae2b57c8376db5d30ba3198aa8aa8661c727b7318741f221b1fc65b1d7f50587793ba540ab790d5e254875b2ffac4b7ff781d41dcd2cd846cd0da2a7b34b08af789da52c2694a8b7de1ed03c6ec9f8afda50ab8bb9e2f95c31de4c01ce9ee244e07a9cf5965b36511561fe84307a855349a1cd9b8eff54a0b9373cfc1c1c7ccfb440441c9d00e782d8905168f4fa213d3cbc06c85e484a1dfc84b207a5a670b0ea1472f0e14cdafd0897d6ce2f24262fddb9037d8f2a5a24a4206dd00c68c0f85a3923f23b34eac5b21fd7a59ed2c3f4a59ac41fada03ff4404088ed876a9b56505338a4e6ada6cd15b6943d2c3ea3d98dfa90903be370270b513e276a50ab498f3b9fd89e2e82da9e05832bbbcbc7d895410d33f980f51833bf17a8559d78ae48b1deda784fc1b86a537f2f91de89721ea596f25a57da39aa06073f472b1f504446ab89eceaebe9e4d06fa5e1b4883dbec3eb11ffdf84f3ddbf4c6b0cdb935206f5badb7bcc037a10bdf539daa0d2a373c26e9c29c8d964253f1f14e74a2887017fbe87a84183b6615b3d4bffe103862d98165dc0d15a0157e2fe423a1b3d2f4d031d9c4b8a71d149924b4e67ae927dff213baae3a565009dbb808f4af0fa7843d3b35dc04ccac7c5a0b27935d877e221edcd1520adb2aea56c0d0d134483e5d0af4c4a739e81fecd7f80f7a26c47bb827ae9887c4b69051d7eb99538ad5ed66f0a45beaf0f99e3683cf2970b9ec01926f90feadf41776a18dd33f5f352cff7b4fc2c10b69d06312b448d9051a3c41df644bdd7d8ef97db415b1620915a4fffcd71ba18714aa48ff6c7fa0e0dc434acd32d84a5e843bff46adc8d1a62d2e9678363731b772a3ddf9c38feedc2811d3b3ef1114099cbc2c24ff0888d6e4eae57fffc4874464537e6788f986944edefbca23509c8a8178dfc445046d0badf22843e9391b3df80106917ddbc755bea086fbb7f7259dcf0e9e38b3b5d747ca1eebd2fb2f4ee71abb79518874ff2a0ea2132a37fb60dfc10b837d38904954c5de5f9acf9a36da2fdb5c77aee461ab771502ed71ac1b9acaeca45a8cee3a0140b8be9e4e3605edb5bf7020efa2af00eac924e601b0b3c349950733fc27c3bff900ce0e9874f6edea33f256c8781d81c1c322ccfd6e1f1187344a4259572cc7c111d0afd387a486c90ac98480b3cbd99c2556cfde0685d3cad7d6c64f0e0322c0dd9682815368fdb6916cbde8fdb0ca1df9a80e73fa338ec427690d4c10bf8a06156ade70dcdca70bd56e990e6818abe70207eb141243434a0b8a5e40ec73b5fde4b1155c9be1f13d68c9a3f1365f488181dcd0cc3aff59ba68c512b60bcc185ab050451a14d3b036b80751dd91aea73bb78d9d8128e4116840f7e945f1a082da2d885c762e9286fd1dd0a53bddaf1a6ee5ea20c99348a18d7b91075ffc3c32ff708695c173e7509ff0ca181b797ef0eaca2e8751f822dedad7d613b6a51ac4fad48f4dd16cd1765be15b94a501b54ff96891a400d3589f7e03ae7c8b55e24e924a9a3fc58516f09b91b940d15bb0c4234dfa4ecadb582dba36e360e13722213129f9d08bc05cbf8809075c7de7b412a3f91f39b1e8421d5a4dd0936b74070dd626ad76c32f6bea14027a30a82cc978d3aba609a0c5dd932f769d13e46c30cd5cbd514d92c723eab1d074ab0fd939cc676424b42eb7646320d7907a35f802dabf1868fc0b871c072c8c77449845c04e9c6e3c956d897ab11b6aba264898f3c617da81f4788af760174171d484f5e8aee4e569b61a727a9662a1e1dd0a24e5cdb5b7723979dd8ca39a699be7d329f0080d4b0634791a1c2ebd3db82006dcd74ad7960d2430c4572f2e132c07e7934886a69369106c85b78caeb911811083d105eb52f6bb03ae32be3c13f189efdd32ad0bab8e389a14582b8e1bdc7aa632ca5db36241c4e3e92b1d2a642a899da05138471a21732842b5875cc9b5787f6c1481b53b743b1f1032115b5aa8b220bb69f08836c3d71ca6172881eb7827af8bec7c1059fffff30036bce37015c38412f350bffc3157464331fb3df21198fbb19b32bf5b7648a57e042289e8d0c9fd37acf11efdcaf53c01505a22eede317ca6935bfba40b2e71e504760eb950fbafd4b3f88ae5bf6d5168153e8f3e4ad8b5c16842b74bcf0d49fd3c4995a33d3378a477546290a6f192ead9ce9a15eb87a1f44992cec710854637e551bb3d5b72aa42e311acbe27015f2a0dd109ccae112b6caa3af1e7dd601e9280729d48dc1901ff2f8d3bebda409c3f92f389b7c6f3a0e182fe309d77b29e0bdd68541ae596f92491636bd1c0aaedfb136d4966062ad0889d7da74224c8cc7e9be4bab0676ef28ca4c047d49503d85854b8417d42f8067c34c1228a2907efa54915a35f7ddeaa5d88cebf0c36a03d843a33a444ebfc840db367f9c84f87401ce998855e62857900f791d18e793ec8bad242dd758d5e0b9b7183ac0c98fdbde72e0c390a6de0488f31e5a8e8a4fe69bd8fe6692ce2ae9b92b0918b280c0f2088f204c59c339cc50eb4271a6383f2209e2e3905c9c9bd72d7c3489a84437d60f3d125a8ad526ca91a1aa2e7356f65b1f6c978108de0c58f9669373285b13a6da83a45096caab94b26b59d47e5757a8318aaa8c1ad8c140e1cda41c87b8d8dae2a2cfe84d784effe2125a3704303105f923316f97ad65f1c2719ea46dfe784c3841406dbbb8318419d75e8b51e55256c565bd9173e9dcb4452cf2cb8c919baa8e8246f0b0bff2e5ed67beadbd0a8ea32a060f1a77011262d514c7dadb4dda887e29bcc203f4cc6ba091e7fe983137430f76daae9cc03d82d47546a78b78ef4f5295cf26abada6911a638339bf9a65870e74d4e296bd9008fdf56f41ea5088c599364b0df87b41dd600c0d7e5af76461304635289f308496534bcda447b35d94f4728b9a345ca1353ee2920c060f3b9733db24fe7707095553408e64bf723daa1c9df92d17ede62005b266d637084b860f97b2874a6e753c39d268494dfbf912c1d4d5524530b949293cd578be86118ad97d27a36066a8ca1a324f6e9fb25b47d1b45141081e7bdd29d01c4170e59fbfdb03d6658987741b8a149eda5f1d81d9aa6436eef09c5ef47f66fc57f53ddab6e4a64bd03b89ed66e88650cb07cb69fd422289eec77119aa59ff5aa386bed9e3a62b1d4ee8712aa47ea95480d26f976e7769e65e1906efed0088b9cbf174b53b3e09e8ea75fb45d184b9443e8ec4045e634e211e487d7ccdba2b85b0e2e4ca7a03a943d9305ff9af69726c48515dc2aedba23df08e2bc694eb70b03b65289551fd10948dc5df2bfc42554a2b97ee53e7dc0d1bfb276f6b569cc3d789b82f6417fabb817357228cdb531e5e52066050f993b9afd227883012f28eec97a46e30fab085aaf4caeeea042a0241f79fb0fbb5e6e8a334f31be5b92bfb0e95a716a1d400fdd3408e5b38490d683769cbd6c2f0172fb4ba8ef52a6711e056176af6a748da09006507122de0903de49c43d295b976794409d66936e8fbb328b61e8fee16fc0348bbb4fc91fba2db5894fed00c7e5e2bcfaaa88b65103ab9e6815d147e3a5c6b4533d5d62151c36c9c59c91c0d92fc967a12287f3a4f88551010680f44892d692c80a71601be2357a277eb4142f3930b6516ac207b95e1cd0222f1312e43f69a77a3560c50934eb03fe914555709f760793c4f4af413850c98fe0bdf6325f0734ec7433374ac8bbd6e4dffd6c0a93209671fe3fb6dc8f05acb305bda5966f2a3d85d1ee9855f6faecb894e4623d84a45f163ba6cf96cb707ae59af7950fa340ead632948fdeff3b2cd99b63522da11c6bbda251482693f4445b2f7cbbf12f1bcc0b8717e334753a6c845a6982e92de8741b4652b3760a27afb0410cdde3a025b3512d4a51d0fc469c20ef029cd5ca85dc458764459b51b64bdc516289849ee501eca6d19339d13bdc83375a1c1dc95477649af0e726ddde815bd9204d36f31a641ce87543fa2fb2a408f99cd20efde217d74ecfe48f18f50adf3acca2ffa219f0cfa9b23849801563e45aa187e55488c10e3a688d2bfa9f56ce0b46904c1987342ccf3aee68f81941dc06819e1e7af78a8e0183ce2c04bccec1b5f7d5edba6fcb841114ab30617e7a064a09015010acabb039b8f7c15ca1b86f97f44a6a7747f4e2050723826d8d8bd14ef4b219acd48b1f533b1fbd4c3a51153f313618ec0149b7012948f6fe540559f14296e563654a01cae70c4b354df899ffca2d934f4ecb299f35cf5d49255304e02dc94c9e1b9aac0a1bbc197fc807c3af5e4d78d3360941eab7b720c5bbc78dc39c9c681c33e63b7671ddbf347790aa5a7ed17efce2c8b6d789355d51f5197c274639e8b96a176dded73e945f062cad504119cf1432795bdbe183149f804ba83cfc73d2e131adafa7507be8f9a0e4dc6203c1ecc41760ec61418ba13f51d08a493de8c2270bf802832055417f9a35cfcc6dec06eda6c6d6b6d0926678ad3a54b0e3a287b0658db432f5d99863d230aa7ae981f5ff9631ce09ad2e7474fe54ae9cd1fdf3f98c2957bf7830f5f3c0d335c737e163aa335bb7baf6cb9edd18f10b16fcf92afad9c544ac39af36bd12037d93683862857d84474a64a413eab70e214aca73b11c94c596f0da2b44b6f1d8d7d6e82b0da3c10d2fe6e5c6b03fc9938f1deeac14461902a26ac79a1ca43d3d563e45a1b62e249e1afd0230f1c864c75744cb182adf99e240405be48ffa71ae29410c53d5faf27f4c7fdc0aba2ec7c5b4f16fce6a8ff32e134ecbd2b44474b9ede51d603fba6b671fc1f4da3439e4cca35924eed865d439dacba0ecb041d54376d56e7a9073cdde590d1b2749f837542146783fc4871e2c5ff39c6c5456ac3305ed6337ac00cb89d0b7df290ba84152725dced85cc0dfcbafd58056a344007d5a484a153e3ad0b3e0b3d58eecf7f70c46fa61cee36824dd2d0d21cf79cc63fc8c25d7adf37b6b74bc00c761e25f21234e28c7931b6b6c19572451d82170e49c8b93b567426c187cabd0ffaf7a38a8c5dfd2ead9b9269e6b340561369f86287acfd549c7d4a0d9e394cfe344328e48806f984a4f1daab7db93a0798d993ffb02123d5bf80f4af5e8cdc7103ae763b2f8703e4e0ab96ad28fbdca78268866ff631550a75d3b4d7f08330520b2badd206d2a1ee2e2ba89b0d657b1fa39a11ad4f7e72d2922cbfd3634e0167ce355a5c017d443d58d0888ad51a91d81cb35d61f8e7d79b919a37dde86636a447406d76175c37c3eb6a294deec4e03d2f6f85f5ee724ec6d445c16a0d48489264b553455418c4ebf5fc4f3b389c1a57215c9599d20f21f0115be7408ce034039e7881fc1125df455360088dfb0a306cd65a175b3b07d3d281ec55edf4271801d41858102d4692cd220d8089c82707d6d3f857da08114ad6a265c4cc06f3d61e736bcb60c43eaacfcb960f7705ccd6aaa5aab5468915c31de6f07f62da97c8ab9ad4fe9147966aa4a7250172ae2ae45628c1e4a70d2d039d0b8686d63ed50b2f8585c0779bd76fd5d3b6b63a8c426ece9a59e937d79c40f138424655a52fa5a03e4aa04ebbdf249a99bcf7a589641b57cdfde30f8c2a06c25e09f4e15f8b0b7e755e16c62496fb8dedb32a22d4e43742ecca1db0aaaeca332179be698fb2c75d1a32b5a713cfaa820cdcd672a430d97d5cda44febb320eb6f1630d92f2a971d7cf4451ecb67c685c8767e8eb4b6cb37f55d4a91869d4306592ccfe580334242b7fb7eac88b37e493042e0cfc518217c30bdcee503c121d07df4e34b33b1d3466847912c64c187352a7c5e9b1d1834e36b98dfa6c133d77fe7bc71908548fae56f2227eb2a41727fea97f212412e87e3492ddaca2bb011a526d4f6fbcf3393ddc6824437d7db0d0fb9229a062b423cabd758b8bdf2fad9a9d20040f22da59a35ad9038236ca8bc7d6ea579d5f251e72c54e74ef1ebe38a690470349142bd24ddce222c6cd0026dcad9c817bf1e8b24f28d93acbd6204a4b12e9130a7cb363176969ff1710ca23ee84f42417d0327997e1bbcf44efcb049fc90f76ad7fb86b3809a192d08ebaff02b01fdd77371e99d9b60ecc199fcf49fccc4c8f72510a6a1b1019d178ab4fdcdf9d10131de0e8cd88ea4a0a0aa1a4bed3aeec0236dacda121c0a74baadca2f2409afc49b54fda812eaee82e5668c153d9c7ef6c8b6772e75cce80f1b0a397aea54bcecbe5330bc855729e8cf1e11e6b29cdb2dc72222dcc3c375bec74bb3291c23b9404d9ae19a9e0ae98cca6c45b11f12ae0200c2d8643343f48368f1093e585c238212bcfedae20966a55fdfb8bc339e22f67f65d73354c726ecc5a69abe95685458735ca9778063b541f93df2cd64a936cac8110fa3bec440c9944e52b6801af29fe9aad15b25b2158a1395c605b3d984085a69df8ac86d4ef805e7898f2b2e36a34d633445ad17328a063dbc6c47fd3290ec28198dbd040e676b3def107d37c8e0f51ee2b13374d4f02df8635a35d43318eee70afd1f73bdc0c394d36bcc85e33cfe1c9a28f2bf41bd5fea1e92c38c71e94b40ef3bd6a2445f1cd51a3b4f3d259087b12837938910cf28f49d04b76e9922cba2a56606cce7c2dc3171902622488aba69b3c2579dcdf286c1b87fee7ef29bcd008a6ac7c42d44db4cc357677f6098dfef7ce7fe4749b47e80843c10e997b6926be5063d7f35d6bd9f45ebd28150cf3f99df908d356018851d84ff1b26acf4fe3638fcd941dffb9b8e7a1fbfbd06ccb104966c90301e7003620524e44ed96f7e73c12cd0ec109bb7b42a4a62416d0a01f87bd3df594e1b2a19d0e9ee4ed6c9b5753e3c69ca69deec50a30b8ad7fc187e973833af5d97f9fb6071daa55217c44688d42c5bcfade5881c30d139f932ef340287c8e1de88edebf8665dd72193539400208f980a79574c5fc675c686a55b8d4365b981c898f7f020db1b03819baabf536109af34048d10bd364e1a7b6b881c31f4951700807cccb70a44710bf65863328e55b3ca07e3d3d6c91135dadfcd7a028a5da660e7eb0172cc865f80fb91347235e4c65f41e83a33d7b38f75e4886efdd9246390975bd852a3d063904b10284760c717e6baa115cf23297f9322cf9958880a64ffe51477f46481bde9e901ca2a8b2c5ccbcd234f22ca25bd0628f1f8daf15fc074850f21c965c3419d146df9f5bb59995ee947f608782b4cb8364a2e7c871022e7bbd3713dcf32dc50257c0f224196b4ded4f67412261e36d8ae5fc494f1e858fb9795f91f6631328890b7b502f0aaff1e2500355159d10fdcbff82d957c3b9fb76a7ef8fc662694c27ef8f84ae0d3a4dfaee06ca9c4687c89d390d27f5f1858ff3b7f285e4dff95aa8a680f8bdef68c12f94c30a72254c0b2d7f3eb892fac978e1f9915a9ac66312f07860421325449a8097ce35848a44d1e5eaa826762cc77c28297d39b6d0bb3b70b74db9fa3fdd6d501449fe6cedcd245dadb026a6db282e862b3a1995ceeefc31f5e04a5270da3f3331e65089429d087ce0cbf2d09ac6c8e44dd5b518dc364cd833e2df7e8448ab45d61aefd4ac8f180e68396afc893d80503369c86d19b01f5e759d73f6a906a996f1b0331effbddd6417c593d38b85f5f283f1b2184851cd2e13e506cb39ea037ed822b20d871c5cc0197d007cfbf19330df5753d50140f0cfe9df938e26697bdc85b01f5db49ef1aa3a165859cdf9b118ee36f16b4fc572be1adad8f5add67be90a93e92997a3bc34a3279f1abb829a00d8986346371ed98d688df6c95275970b7fa81cb4f784b8301480d704ba6003319e7059b67be8384dfc1337a32459a51bc43085969ff3daf02c406ccc710c091fdad65a1cb445fad1709efc00d96bb5bf764e499f903ff993f6e1ae7c52e6b1483fcec44144eba4a3005deb582f8d6e65f549f045bb0a344f6d29c2646946719f96d362cdb7b0feeb3895e3683ab9d8d2d55b7a2d723b8944e94f88dcf86df2165e791104fd598c743524171641fa83fb3e52fe5418d84987e08307d994619b53bdbd205b8dcf13fa8f9a0f1774db62567b69edf659a32e895d0f445c01e0c496a24f54089c8c709e09f418bcf5fe6c50bbedcc31d17d6e235515ea49526b5027a973c0bacaf95c9c2f5bcc06f31c637d52a4f7180af131e32f30493352ad1481b6a56174feee3421863e570be6a8be1fefa4af6f81d1be2ae7301e044fc5424ad0b0625bf4d15d0cc96c5259a24e38a9e92f6903dee285f043fa44ff46ef3373d42b6508ca7ca5f34dfeb4c494e6f180fdef99f3ffde0c5e334462c82465f6e2cf67d0269b2a74d5c3d67963c37f454e5ccdf2aa1bdc73fe516325ddf5949c0c2b9eafed760fa71116fbe1729446a7c3018eea164ca757f411f33bcd3233427ac71fd678f826875d3b601af59a4ad54e7c8ee3d94fb02eb0f5df9b08cbb77d86e32d16eb5aea1ad5d30b464d3c45ac713bfebfbeec77515d4aebea29baca3301d56179f6c39d8fd508402941653da8c57f0eac938b0c854f6022e938fdc8857e952de2914333e4a59156aa6f2ea20fe5de0e3b5fe972647ec701a9ab55bc569b530a7d245c1c7b83358a0794da7fbf9320bd2a067dde8aec96fcfd86ee35bf9c9785a48cec45b08621297264511bf5d3c7baaf15821696fb15b29dad7b5ad2bbedd2b83a77a1494d5a78119312b0524788d30d7e1ec7a8579f571088fb0b6d56ab16ab19fb25e8b309ea6f8e7f1670b588d480b1afbfe1434187fd92a381156cebd9e96b912c7d6f2085fd356248a35f882f78c3fa5995eea9be942dac22a185db5cbe7b21746de4ee5e5e0f487badfee699d339cbcfa37038c2c224f6545e0970a8338175f31ca178ab2bb292cae8122e1dabaa49a9df4314264c5768a0113036a2fad7c20c5dff40dc676b5ed3f2a1524171b8a48b1de49f1831da2a3d19ace823b27de4b4577e1511fd05167be7146003eee977bba24b59f5929331d13cae9cbca444589f91e840cec0963aa4a2ebb562d0704432c8e264dea3395e50a5368249fd80451ccf1a52ae9b6c385149af6be836dab9521bf99eea9d36cc19335ac3fbafda89e020e3e271fe271420cc5377ccaebdaa005dbf555aa96382a707f723ef12d4fbf73efa1de86c0c1c6ea85452f7fa7367b66af9b7da3bcde05f47526587e906aa2b19bac03f3c697e3fb4bc52905f20543259661e489b0587173f9aac78369717ff173509c7cc27527da4e844b7dbb730085b70291320bfc1457a26788567d90a9a2053589587bc7a78d08cf173e44677dc3d166ecfbac71ce61df514ef7d2381d9a16731a6920646da6a9f0947b138f0e5908cf7a33fbdce65776fb737222e3b5f674af89dd771b5436bee0a373fccbc332dec8cd0fdde0023607c76f796dce1079511f0dc9f7a94b6da92ef0f365087fce335aa624d82d6b61e9c3e5d3f31f4299c0081afa505760bc1bf746c5af74b1a073e5cd426ac37a3514cf57678a1c875a84a05c395ab10e3cec9613a9308ae98f41b950a3bdbc62f2aa038734591032d671f8b5","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
