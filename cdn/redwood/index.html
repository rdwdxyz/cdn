<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2804453aa8a984152b75f43cd27bddc68b7eed4f2e9972281bfabbfa99934966f1e233cb5a85d88239c35f16a1a56f9c1c7a0028d8ac254b833c8c75b27c8efd0a459cdaaace38bd992834c312348131ea3ad72c9c1fe8e35e1e8489fb300140cb9c16041408b8a8ba30cfbc70940c03340f9f52526fdf8e837456b7f7cf3a98455d89dafa6de17c7376ce3c4a961e6dbdc6f151750b9e8cd176b0b04359b78aa07843eee6bd0819550595be21c826be0eedda992f6c3d832b3c8550cf1ddc06f9dc3dafd5d89acd8f3f610b1967ed463bd9e728e9104838110db6327927c70487b158ba0b3d904bbb657f50174f40477de73c6836be14b39ac22ad9efd44ec7a07e61f1c650c4ee2a8992ef22bc7c8e21459442a77418d7f92d48bdc8abbe63e98ff9bdac3316c5cf2caeda8692f9fce79b7e805126f27e69abf6098f02012f5d1a0f18f5408e129ff2b0ddbe21f9bb3d9ff82c733587fc494290d6736fd56dc448753567273ebb3e7ca33245b582921824743cc92abcc568637c71885b1974e81e184792b5851501d5811f7e6d00af89dc6d00239acb68c73b9639422cb95d1d0941dc3b13057b348272bb0ca2e3c2af249f5d53066bff3d2412b6efc3d9d1a723df46dc15553393a73071987be1259805b9a9ab3a788e9a2b0cc229bbab73ca107669656593091619584a46a8fbc1e74151dbe0d0ddffa2b538b359730dac3892b2f72c94d0ad3a878d7a5b6177ab1931dc7a2ec06d7a06aa2fffad9532ea2a6a57ab17bf2f356155b06ca178c34bc08b2c9a8a04c537de70029284f2c3c9254b4bdf681937599def8296af7790fbfeab423133041e60bb31f39605339349f2de5a1d3f39ed92ec4f73afe17d5df7543b47129ed0610708ea66eef092df341c79c8f357a94650d4f1ffc0638eca6d97588657298816e0377e8cd05c5920a9a7767d7af916acfc67d8df28dd0e30a357d3906842026da42eac0375c188cf819a1aa211194baa5166aa55086a1dcc7a16b8180a9de5d78d28144595564cc6baaf2160e696468a29959f2720c22bb987b0274b8299fc03a7ec810031a2eb383fc38f7d94d2295afd5daf283d204c92f849886b32449c9f96cc4fe3d2510f1e8c8c0cd6d99db1b2b6aa2bc27fb78d56d8feb9d828c9740692dee64a08d7cb494fa7fbd64e23021cf54c60eaef51875a4ee772dfa5f20bd101d08f89a51d9b06f84ce5a65d04ee741fc1eb21659144f9ab6de57323c327e6a702211b7b7c0f0721b0b205e3eb15c533bcdd3379343da0757950909ebedd8fc4b2ef119c790f1f5ed11e5bdce1cc7cf63fe871193a9c036847291e0294c42d9bb5376bb4cbfb36b4e9b26d880a3e3798262b021d3e77225e1e4dd16281ac1b2af7f8b2b4bcb75ce115ac80418d418fda80e77b7c2673240c364048a76065d950815fff8ad7eb52186e9d0b9a1f97f44e408c2824e9d218c3d595d20191027b07f315e79960fe73732116cf977953814c8e6b6c7aa87b459e9fffd32e28dd1990a7ed8ba53cf41ce03d977891d89f3c8bdfdf01d25fc4d5ecfce89934212f7c58d879053c94e63cf4a3a6c454b89340f2e098ed810b06055848789d82c8de31ab36c6ff889346363e710bb099638d028899f6210f4250a18ca0163cea80fe045446ebae2c9d27f174df4f4ee93d0e35a92eb7c33320dd471bbb42b48d276f77d2c3ba84370cd328a7ebedee02dd290d307792b719395d047f778012a5c415e9c64d15adae126f8ab034adb90672eacdb35064c7dc2e98171624f350313ac2fe15d73b828b95640b8df08f9a6d457b122cd2c0c6521844f941d8e1133e532fb82257725401ee1cc4fcab88a2b9dba80e1c5b98637da3cadda3ffd07fe2dd9aec75517225cd7538622d0c8861c95cf028c30a331a0a0ea05223fbebe548d9cac346a085875f14574cbb9c0a4eae810a6c5f762f510bf9afd83d839e1739a44395413839b2a775b78b5364b41d758ca754a9c13dbd4b7ed76a7541062ea21fa09f0806d296e557e7d4382aa3e80a19e37cd94921f154b5aa5f37ed0fa2f4394cab8529a74b4e130f80a3eabf65156912c4ba99853fe44439a6d9464a485daca087c265dbce6355f8c16d6ac0f3b3a212061bcc4fe96cb9c3e11e9493c20f70d486148fb2dafaf82bbad6eab4d1225894c79a1f933f8acb450229f01755c520f17a91e308e7f98ba74b5b3b31ebf22c1e7651f990c2ef0fbd1e096487c576b6cec5fc0095f5490322805ad65ef8dcd9c5ebcfa9d97142b67391e8b73580cdc8ec8d646a9cc9719d4b209a5dd13b476d283c860471d60fe3d4f58717a32699a9f1ac61e492346ab34720d176fa83a6fc42cd322e0a3385062e8fa29a3df688f84e13cdfd9131eba2f670508b72485c7d00413afdc3343de8f1e8948794bcee96d474f80a9c5fc322bb4bab0d44b1febdfd4bb938bbc0eff59ca299b0d753b77552466690f056f8d8ef23d7be1ef21dc022015989edf0b3d51f9af9b1df74c590839f5759b43ec3ebfd1f4d91f56b2ecd59dfbc1cd3720475fdc73f619544f6b46988365262033e5253c87b9246ef45daf97272f64a9ece955b48490469299950ce6c4f67afcf6b42e8bed17e7bf4b265c83e365bc0652dceb47e26a88cb91f2c2f3cb40c8a521946611e27f3b02fced66f7e420a8c70520de43ddc25f28881c8cbbc018699328f1048ee4c1120055b8a898223d09246ec2e60a32f17a79fbc58af2673548adadfe2c2610a0dcd9921f2727793548b69852523d2dfaa352be82383e3ec25eeb800ee7b70807dbb3b6caf3c1049cabb1a2d5166ae1ddf6f4c32246f21ec51c80dd2ada757e2f22ae0814bbcc6dfe43617a6ca31ee36abeafabcb947fee205a6e7550fd7114c6ea79f5e2bc603f0916a4ae74e196f70fa7e01dd1f8179a65d24c2bb5625617ab5e56ff838ce26c7c3d2f0da6a892eb8ba4955e757ec5e5fd1dbc703eff00b58f9f13850f9e3287652837f535a0478fc07582a63f85bc68076273059f84eaa33bcabf262e035ecf10871a6f438b9d0d9d7b3f3f72a8611ed9208f1b9f43db0180d9d885f84c2824ccd8f3d5d225c944348de77dbcb5e6fe7134480bd155ae136e3e4e16e9cf6353af037b0b98165cbb51dd67b0e42824b3cf977a10186ee5d49968325e3de2ee54ec3718f151aa550be8f8c2a152df07cc61b8859677efe98ed6fe8117ae98483ebc432de2a217a62ae1caa20d25a8acd89c7fa787704eab070770fe226ac83d97b6ebce237465bf16d039fdd5222d2d7e447e114ad04ad3a8b0bb271a5505ff01c274ac30814f5ebe349d89dc586fa2a359e2a9076dc5dda51b2642271e0bb9081e583824c2453237000e6eb55688eb94748ef1e6e963aab96123e5d30b9300630282e587aea87e10d0c70641e00794f1c14c9a026765fcd65c51bb523bb8eb306bbfe4afe089f4cab64921b3c53a1abaf7a411109966b77cc21097bf4c1de84ce4136d078c8cede6361a465bf50c9f65285074e8de79cebd87701ceb94eef701eb9d12836985dfa8f3cdde691f0ab0bea9095d3fb8902aff86eb9d86db6cb389f3ed20353739491684410ab9f3e34d5fb6c7a99d816f9b5f093635b747032a7daad36f733ce06247421af78fe8859a7f49c2d86c11c32c4404628bb7d80d920bffc5db76f82fbb8cd861216bbdb5aed970765e2302b797a17e4603ae0f5107756c2d7ecb32f4331677a641058c6402171a55df468db1979b0e784f7df60ca237dccb6b650b9914dd885539ad36d1b47748de764b5c2227fd9c706d8ae4df307fd9ed3cbaf68063dba8b04db278a36fc812c761e553dd51d42cd19cd747da6a592e2f60e8d3e1ddc355195776af0a430ef0ccd378c35b03ee66c9441acf3f7e833c22c277f34d8997894634756927412640546659d3777e846b1ba749e60fc943ed52599762a732ba4a377377e6da1d079e2bf266cb3f1da31c6c9b916a25863593d52cd97f00a7e23b592b3f7800a4ef86430bb7f54831e0ad2d039be6b3fd69934cea9cfff58ba6231c258438ee39723b2dd592226f152741fdeb009c926524fdadd1129000b1d293727be33209351abd77a43b1c4ed7655aedba8cb4180ad2c51b2c095fb11e4c0c66f76bfd3fd5c900661adddbf7f7c98e1034894a583acd990eedc5de0cb0a40fdc28e432c4cbd1a188f00138d2948fa79fcd4cca2ec078a72a196dfa4adc1e08963cd161c0f953f9fbf0cafe0331999f86b95f5a455a609a1ca9a59691b34faaf8b84ba442e6c6d2d45e1ca725431c326cd94868d183e2430b69d24cd5338bfd5019bdd53f635c30d0057989d26e5f1200e33d8e9802e88ea1e5ba543aab42b1f3696027245e811425009e467d6d98ad0793b08fe4885d1d5cdf9b83d0abafe6e3327859bacc412724933a81c02e36216855b3b04fcb49885b31d6e03ac2283b608bc43df4e32a36546fbc201f3cdbc53dd325582b002f43878f1d3982c77d9ba0002df83e9865e46ec1c21e60d58630274d198c59f1fc15edab0449072e4962963a50be60258f381602dc3750e1e011e16ea689af445f29146531d9c2181ab39a86a80720d83328d4e2f1b0998bc7ff9ae7f64e59b6187bc997fb6a98fb3f90964e0836cf04ff591e29655954a19f65a15ad8b421dfcb98148c03af07f3d4ba5ed6840df0e603f69372768d4472c58ab638a2e0f2030f218556b8d7e8ad84fa4a0f23e37968f1aedda4744ffb6670a893ebcd11eae8b275e2bdf684c1e6bdf9a5087dc283e2c5e999a8d01dfac86c968a6ff957b6c2cce57062740044946c0f9d7739163e5c61bdcb548973535b505906636895589ead799bc4e501f08baaad4bd60a460f6348e5fd9b43aee8d291c242302736a33fca0de230398b2327e2214a702e972a3730a0049dc04ac839642f28dad5b9b309e6ee042ad09f77d94a781f61a6bf3605c076981166a57da4d21dfbe7ba98f5912363a75257f09b005c3ac1e9a3c089ab6040156676664e1e5ac9954fce8eaae4c903bc276a8977edb56f04868613bf94d97c48916f3d7fbc421e23373c0595dfb9ce28142f719c1884680221ac178492262dae1c7088ff8963a360c3e9469990a24183bf0692e569c10b2e8648e5b6266bae24972cef7d3d2579fa9bc30574b92baa7c24859f0eb7bb6eb2d54b003940156150c763884f8d22528e62f22fdd0c2082d6fdcbf1379ebc4b2c1835214d6a757a0a5200717df75b7ca607dd9771ef5e8af36d9192bc5720de1a8318194804ff8278be016bbed40702e5f85c180520565d36d58b149ea7d4ecc0934a36844b428afba7f81ad778ea43b47f29a97603321fac89e60b996e6f4fecd7ce03675aee0ab57d50d6b1709a398d9db6fb47558b9d23ad2f4aaf505153069f50ff733f3cb179033b93cc3e95bfac51d09ceae36a3c52330daaf5c69afd58ef8ee34f52f66770f6d98036d0c73832601675436a1665bf420de11a99b976cf6e76bcc78d2bfbdfb522b0cb074f970295518f43cfed32ad8d719a6aead69dda590f475fb8a9ca65010c51346c29b1d3e720ad6d5c647fe3939fae51f4bb3aee28235374911ec7b61ca2e299f0db826d5ed17f84964137711cd240f5b0278fcd0ea415a4e658ba3af75b93bdc03ebfa41779a01eed77c990f81d53ffdb9399d9c3ce9684a88561d4c02a0bf5c8f897c98ec92d5886c338550818785d8437fb3cb9da45d3a5d3fa6c835cd60254574c06f9d114ec7f7def0e68e7d8bb2c13bed66038dabd2d61f0689d0f258691c1b2ba67267971f529a175b4d0a2baba8ccbbd33420a9aedc03c823cf2f2e3755eed26412de1a677e77cf0f4a55b81ae530fb4108ab1c2ec33cd37b76bea14a4b57cdbf41f419faa3a7afe4beba6d8991165f4b864804fafd993f122ceaff785a9ba25709c6b94eeb24d7d7ef068a340499c33d8da4ed2e656564f22f1e6a6bd99835c4fba7c1d63a99b1639d2447e80ac4627737f32eb9fd98a4ce06b6cacde54115d9442db41ce3c15aa5d1311dc10fa9d8ecf18eeded398d8ceb4e5a13fd24171301e53acc9e01058aaea611c29d804b3dea0b002f4a25d68020559f07e03f4ee7a67d9d9125c51d60ea3351b4098d402aa732b0099a4a29487333fb333c2cb97a15bd6dd73c4800129632c3fb73ad7e5b0d523bc1920fd5c3126a41ad67260c921d2702decca1f37b2a41b2c253b00c1a5077fe8f49ec2c6c72e981ccbf464bc51500c3946555e18ba34271a0d731b08ad12892ac9f102f6f43057cbfcc157dfa80cded5bad9603aa56cf710f2cd5d9fe78e2ae3b4e1fd375246ffea2e05e90c5e24bce77dce55fd5f93211acaa440299637fa03296d0c949aa81f6ad296f8accf1c35b90867ca90b5f271ba23901526aadb0dfdf37946eb0485002ad14fc7453886a8d0d7e3bb04f224954927392bc4710754a3f244b0d276bbc69670b6675ea86f44e339b59587594b7d4f3c49e27b338b78b948dab69b828a16e55973cc487fe629de0c74d3e9b2caf5f6014414098563d3998d8f384f421d2a2ab063cd75f71b056edc2f81fa76cdb398e9398609b59415331da019e682e0111304027e3e5b37608e43eb0ea17aca588834c45f21e96e78b3de8d0a5eb0a25667fdc268c414027ae838f2c9ff0691329afc9f97befd6127cbab498457c238db8d7d85edb7010017d8cc9f62a7893c929cc8d9f09f3f063371551a485a707114144f8a08ae78a3d6350f4e176f71954774bfd55d4d566dafde1806e77b49d8085c9ae4e425152c8a2d3200e60c193f57e7e5ac294adac74745eaed1f656563ecca9f7ae2a167c25d627c752301ab110267fc453313ac95cd2bf0cfa630c35a11a699ec14925f83042cabea3f524fdec6a0516aa6a7252d961709c6e179c65d58736726e80e08ef54ea0ce793b2a3d1e852463032f4e2442a334fdb055c46857ba3623b8ec9529c4eb67537c66da9aa2aaaa0d1fd774f3b9a1b070925d1e86abfd501f096480f928a95b7913095e4b7e3a8fb01081b20adfa5dd9f6f65cb67ee22b3a81f1bab17b1e1bfa40d44a602481be38ac3588fd6fd292c00644f00b414f8dc5f3642cff3a60e253f9da2e9b4a33a5fc81907e32b82b9a969b19188511c157a66efa59e7052cbc532c2cae2d3ef315de4a9aef327629b87bf9998877cd4589ae97dff42d88dfe3dd5be9c81faafef1f0e6c97f5df8e58913e21917569b4b6a097c338beb0df077ea258a13b18a00a09339d7e1acd9d76658aeb929deb6779c7fe521d26f8c0a6c38abb6e87e43659b45b7929fd2e006430033e460c90d9deee597f2e68d5884c9e3c016d406930519e4f727a7283ab03fc30cbe7d0152d27f0c50d9192c3d37b8e932de86e952e5083028f5fff37c3942ee115196d9b839cd81d010921f276da694f3fcc16b377a1f42f21760f7c8cd63b356c197e46bae2c6ef993ecbec5362c4c86785f0b51f7e39570cc1838326155783a73da67a195bf67abb471000953345b7ea8edd25e545da2b07a782c9134ade960b85658f3523a8fac29cd7ea39810c6f268da5cb49699f2015ebb957cd60c9f547cf2d3eb76c54ad4aac371c504a8deb9163b0ba3602e9d8b1620cde036a653093945c82422c38f0c3fe122eeb11eb30d13732e69f260427508cc3cbaa81df25e53e71d4bd9676e8b29fb6e6da9e072de0524cbfa3cb2fa17eac1824b85354ee713019d75d2499297d58aaec88d2a5ffbb9e504744c646921d0251b7258d4bd85f67b6b90cccc7d6bc673ea57b8b6e7e11f7e065dad33ff4b173f04fc767355d4d19c92cf2e2728f0cf191ce02683e6cc7e981a788ae616a7ade0ffa6d1b6980c991e0434c671ce2bad9d044109221428dd6181a0abcb540bf43775e780f2c564601be67d85db26fe41194d24da5b13cff6c892eca313ea7b4774c9998bb9c582c490d1ddb4345483171333e45be8e1d969b5bd5d449f2f2b3e9d8de282259f294c017d5e361790f0942da6a19b4f8b032947b5afe3087389b94bfc375a62f2ddf92899e055eed7166e05f5a0d9b3c1006557c9c35a4ea898605e98aa503d12e827382f783f99083923225d21a94de297b2be1633cb00c0ffd92e8f72f44a8aa5ea3f083461bf747010248c1b3a94c1ad694be1dc52bbe89cbb07ceee01e8354a6c8d3ac33e092e8d2f4914a809709237ab487a1f6a7bc95531dabb93b3e875706daa57fa2da5dd9c4dd3abc16dd35af9c895db0f749538c2a7406569537069944d7b2bc51aea24331be7198706ddea9ad2f3327257e3b89c4519e99f8b46eb3688af959188f444cb228c8f44ea042c881fc43ad56bb5543f88c0f1579fa1b81ecc17aa34c88b6cd882654ef15aad96a497e91dc6456ca112bd762e29c1bff2576da8982d5747b86941892852d6425d1af4fb4a507a7c6a8eb316aafe1e63f9e8ae1b9e46dd0e484edce281e6cf97618dc6789b1322d575b15666b373480b6adf30255a36c9d066aeeef6601ac9341448d48ece4417cbe1cda554a1d86b383bbc01b63274fa2773815b57593588e691617a9645e38003a3c324ca5a13ec5e67dc749dcde1007893e265e9220f93dde1da1de157ae9af8b9ed92cef3a7a6dc533c98687ab7d3a66716519b3fda833a54ea7ddb375aa5210642d2e66b6da3333ad8a3c8450427e397dfcb730b2065ef63f2d83a0ccfdc8934c5ada8af124e450494d1449dcc70516fbde75b0d7d84caacb0f16de7b3ad887a374dbcba31326aff97dc42e21594f5891f9ff814a6dd73912b6480ace12f8bc667bbefe7c12af9666e2e895881a218e2d929f1e6d59f0c7e43f314a963df13b041c63ab1f15e8e3b0753ecf6572218cd89a6fffa21c29094d691e180b1a3be2586f9ea90cb1d8c1ca2be65479285e41a125a901f5bc59efad3503d42e9c9a2469355273d4987e46952145ca90187e8e069d227011a186712bc56b22cf9fb104ef4a8c1bd29c707bb3989a83e8ac74f5278445f6947b92a9a04fafb87f39124176e3e2d386efc4af28c610fe5c0d697acc82ef724534db92067862c8fb7ee13a42d65615ea89b709f82b21363dd39f6ea09b61abb47ca60f37c51d01868ca60ef3e3df0358340f0579449bb9beba154237de26c2f2cacd4f0ec7e282e5e0e4743ccf5940097c80dd1f66ddb2e64245502aeff64e531d5186d18a4b6652a629d9bb447d34ee99e91fe883eca53dd277bce711ecd4abd412e0a41b0052904602ae12905728b054d31c936e8fbd5143128c717fb0097d10a10a56cd7375da39b804b4419819e32195ad52558899174389a1b2a65dd086e4d64016b9bc6f783575ce32617909e9b5551ed480dcdaf7332241cab079af6cd0d41630f1667656529957adf40a5ec749551bb2c20e8e66528244a0aead9521b93f25cf56e49016f6dc96369564c9e4c8db36e72f07b48d31f19291029a12cba7c74a6fde547c1c1830cf995b0cc60ca0e729b721f3bced27fd91c15a2ef70f2f37e48963d4d766b83f440c7f0a5810764c07dde6e9a59beb0bde20aa71a1e09ba14ace63e6a4e7c086e122707886334a67d34e867e53d7360502f40504c6e7f416a581eb0ce66e5db4bf6dc8fd78487e4b556009b62fdbdea41f85d435d4fbd9241af0e4bc655d2ac58b9c2eb1df2f952b30aa1def5544dc70c48a82d7967bdd73de273c705b9ac5e24b6b9d9807a34b62588f21e51e64973a2065231197c052e2523ffa01bfacbbe9fe288f64f3fc66196acb073ed70c3230b4278e06ce4bd9a8c0acdd2d6614e9f0c9e42ef32ae528170b96f450c46b749adfb70e84005e9e2e11d2ee4e5d69eca446d34ed750a6c056dc3de959bb2feef4c687fdcaacf40a8861d1c7bd803f050d71670f2d7e992dcd30e3ec26e211bcbe6fcce5d3812440a0db08930d0e250c7243fe249fc6d5a8f4c7cfa400c4d0547633f28b821a85416775ddde34a0ba9bb51fd2b9e32ef32be396ddd954da01e1f7fc11b3629a47d24a91b0d41c66d034bd5a65c83da5e1137d60af3acb576295c1a8b91468c43fd13168d8fdf241a04171d2b11410d78fd048d06d7c594599e272e12647121aa3b66879dcb3bf6e2d1aa4312c2740ef1a302a671ef7db21e06eeb606f5ea64f1a8f171e2836e7a9eb55e2fb923d4c5eab279808f279a07deaa203eb3725973fb0b611a31d9b57b1f288914a8591daf1e500a3e5e814fffe7ade7101dee719da3f11c994b469a668c87c560623ff95184dff36567b3c5b6711d88a69d17996387f314d46a4aa06222a7b298948a27e609e19ba4fdf8f30dfb35a6dc50fb30a2ad2c0eb7e27728fa92f88ee5159bc52d19ba7022b08b1de130b1ce91c06ae7ec28e00a403c0e1c60a37cfe9c3eac7eeba2296a51b9e63fc64cf77fe8834f9b5e6bce79402717d4539782229d8e38335f61ef7d7a722429d70d6f72d7395c02f91f21d6315e063dfe316435c5bb56dd9d47d2bf973535f55f34664b8ae9538bd2e003c6018eeed0710c016ecb1dff4856932f483d9aee5f0bd5d1767cc349a7b1e33aa1839b2360e670e843816f40bce70df95017c9f296e757429f38435e9ab494721197d9249eae1e7aaeb4ac42a4d414a2b106ab68936c6e1db949793549161159568e70886278a2118a8e91b5f664d1cfe4ff95cc7fa9c7013ae8e7cbd590782761cc7a5db4e24cf51264c611665e5bcb2fd64d7b784e06ca2fa9e57b3fc91c982b1282520227ac82015d6126a3753bb64dd98a294ec5eb8533bb93e68cfbafecb00e4e17d8f0c8dcb460231094d0e532cb14df3cac4e0956ead83646c55e3bf6d3af7df25ef7f41a5e4691a9da2c483e3c10c9514e9e0d4ad63219c268b88a8399e1c53f869f6b39271841bc3d5435461c7dab96e772ad20a699ef2c8d1bf66eed5cfc32611a8c26b0568acc329e55fd53c6d25161a90894a095e1f55703650d0c8d3b82de1606586670d1ad1ccc84243c48d30eed8d767216436b44ccbd83e008ee12e4ec7dbdd7e2ef63805d702b8e0dedb44e54758441c42dfdf6d0038e6187a47ac890924f62e937f79fbc305b4c2a65e477d60c60ea53e2b613e8f02cb142219394db50f0eb7cf45db51f0b71d4ac6f010509c3a182a522cf3c764ee420eb7391f741438c0d3ac272d3a4f2305368e7e081bfda645e650da37efb5a3531923c06d8e1e948add654ce5d27210470f504e301d5392e7ea9e15f25ededed721144a20b5463ebe4b0354221561383d0fe4b9bdac0983c128906276a7012a5c88f29f226e268f20941b6b804e494320db4ed5ba1fae7d74d8c6fb6d3152f7226337b09d8c9b577dc56506fc19eeb55b9e8fcf0cd72f71ca685060ef2d94bbc2f93c4f99ae6985ad415e0baea7e85ef930d9822ee011d71797a6d956baa3f237d8d40f8ed059525c0da9156bcf75c5b78a152909eb71ce65cbf6839c5af0165cf6fbb843e47d72f1d7ff4defbafd562af73d4eb440314ae4b8319b4195598b9449c98dc7686f3e0a2e4b8786e11f257a95888ad1e72fe7d6b03219f82e697e2cb3717897b62ba1e446eacc1af30724f5db4e306a6969b637080bbc7c69a99d456cafe6a5622a0da5d8fc6c6141856c39b71311d14d0505438526f14678b71920794a1eb1eeab77e6b92e598265aa0196d868c708e3add3127b471d3343a96856262628f14042a88551a54ad02ac31f80faee97b0a06ad6e3a7fa8742aee04e1c2db4cd921a6f7edce52dc400a98e2c09e87da04895ba8549e005a9188ce451a57b854c2788d1f1eaaa354bab19c7c198f5c8d5eb8b8e38b7421578990aa89658b3e1375391dee56718039746cbafaa2d50cbd12dcf74c264bc1d0d4f6c6d33b8a4414cda7e9058e67b4b90493f8fa5c64108ebce6789dc2e263278a9c06b353b68124f34e03e1f9cd28cbce2c4cffca6afb12aa6587518806c983fd10ef01e5f46bcdd29efae21fa03b1195334bdcca325b4300a39a7a418b86d6c71d0ee1292e51310c2bbb771ef5d30b2569802522aa04589073f4af53160797fb13f54bb9f41c06370a92a2be92e9dddb385beed789646d6f77be86f5986d91819ad91d7c26d41a11c546b51ed9ed4323d7861b8fc9ed8dfd01c059395b8841560966c805731629d310b25275eecf519adb23633cc8b3a0032e3ca08fd4c4ef3dd51e1393bce4c7dc1ffe6a27f6f8644422446f684d1a1b9b856b9dc51f19021228ed3ef22b1c89a79dd93e9e755266726da50935c40897c6fc690b938f9346b12bf0b973cb4059e89379fcd13137fc6aecb0cc6de25f043dbb6d75c55d9daf5f00ef2028a43adec5c76f01c686be6e9fa03b936df1f8c64ae417cdb3e57623f2e056166984469aba49a5bdabdbbdd0ca8572af09eef061e11b073caa8aac11171b5ff26c3a9edb88ca294a111fe385da95d42a1cac17910164a4435261197584e529d256adab5270678da9158f52b90a8f0a922eabc2cc4fde8325d2453ad1793871b0218be2918627fa07bf92c84de7ee548f052d69e99fae886886050c43df81b81f48cdab23ddb956174f58d7a77822436bdb08da9488b9b5038de23cebe3976fe1ee6d1e7f7a7675427335420e752aa82ab0843832e6565b8f8bf6b84e7fa8159aaee213f035f50c1b0176f055b39d9ffd6eaa1ae9f6582733ebb1744a2f997225776d84a40e21ea7890a1b4983266c0a683d467f32309afbdf414c06fe7d1349823eb052cd9e2193b3c6c3f8ec4057bca7e92bea1be70bd1df8c5d851e9d415a443198e6b2fc691752ff3ebe69cf07d849e3190d2ccd240b4acf7df70a9eeedcf6e98b8d5c6968045f32615e752b13bb200c3385ad1ed7f76b14fa884c603038cd910a5153433863c5346e45490ffaa3baa53e8a25e8e10383e5979a487d48616dd1e103a0f049b8fcf4d13d66391c45c32797223dd5047b8759ace7452b7460c07fa0e321a6cf775a88ada933ea1d571c27b4b22a91451b4039eacb9b7ca985a3ccc7032c4301a468e7f876ded4a8fdcb36107146324e518e41d23b2b3b2c96b8065bf47b71f270bad5ae212efadca924a81364448deb763c2ac7d4c9325398e2317697d99aedbb4c9a3ec7e7c7f799e27f4449ea1a55eb2a38d94f4fac6020d1a1d444ce5581952e7a76808c1dd79932a11e35c73d8afdcbd7e1caaf37539c244a13dd35e197861cc77c276e01b15f73ac9ccd32d63ce982bea436d53a15c12dbfd058bcc74f2034cb4573e3ee708fffc818295fbb53dde102fa67d08707e2fb3806be5b63a36bbbd2edff6ebb1afd043ce74f0ad149ec16881ffef8c7a39e02965aa6af0c8c2e8e7ce89e232dda1b60e1d9aa93e92aa893b644812760d55fd4606ccccc6f1d1e8756e82c647c2d9bf99fa0a61421d3b04e8ac82485271320f37481f48fd4e21a25faf4250ecc5f4d6c74738676e379193a974e0de615a2c0fc6a02f27b3a6011773fd8e2eadd10ea10af22df3654bbab4e6f42ce99670b5e79690021b8229b3f95de5c1245c5cb5a5d78b2059458d0aeedffba9674a3475ebc1eb7457ec71dc662f698e1967b9696ad74e6bfef1d9e99d118d465b89fdfa927122e56543501d7a32fa81bc47c7ed2eb560b3831dcf2c4940fbe20bb4f2144fcc976f2deb87bbf6af64d1f6365c6edb4a1bc4710eb69889b486a32d4aa2a657ad1a97358292bf7a58c5c297306596f83288a63734a4409ef2197d23cf142fa510a3b2c22bd75b6d34f18b6111d0f020153341c4565ecd1437c3b210085ee5a92386b82d09aa30d95c8d5bcf94450e9c34cc49f7ced416ea6c53bd4045cca93ad78b56e3f835e14fe13e11ac03a5c188d9522b6099d79a2da73e58445cada6723c842e6951c1bef1394e24bb17e7562e92927fe60948c7e62a52759af4fca990f0c035be383a243e6af5f28e6f400990d8d1032c27103d3c0224b823efb0bab25e08d705b49f632f610b3245f5da6d7fe56e9eeda1d1c1f5349d68b0efcccc96eb164d72ee045550a84a0a7727e9c983ab937e3aeaaaa4b9669d035a68bf3284a73716a9eafd5bf902f41545a7d44f4fa73391f35585f94fca60cb3dfdada52a8e12416e15998dd3f8901ef0ccbaa2be15e85e0ae76bc17de081ac3043d2a1f4408b97b1dcaf0d2300710e7f00a148f87934065bd44812b872e2e1efdc706a174ea732c1e825edce3a1f4f635ca149ee70ca99c0d6ad5078e3e9a909133c54112a1bbf70604381cf160877e9760d270e9179ebd8b0fd11359abb021ae3fa1fb77dd747280878eb7ad0cf2b208786a20418f8625a66098bfd731573bdb315036a660dcab3e689ea8f0a899cf53debd464e109e8d6033c109d0c34c58fa1f76aa78e91c3a872bb1c8cc85feaed582112b012d6c50fbaf8f87ccc4b2f948be18ad8c5394ad3f3544c33467bb5ec179cf5be7de0793a88972e7a2025a7c0e04a0b9d4bddc084c9c83224b17dd078b3bc67a87a9e28d8f65a54cdb3d206613d4f549747af9a3ca7fc23d39aad4b843770dac8d30062709f0e82cbb3c70da382d61779ee4569bc60fd30d9d7329b9c8d24da9e89a48474d64eda6e73028a59cd0c9557a9f4efe11a15a45129efd3871243eec3b8d66681eced75071cbc08ae588e1997465e368a604cbe14099fdd3f9949aab9993b85db40b367a9b3c8ce1f43983a576e2301a6bcb1c46c1572692d4e14c1cbc84bcbd0a0cde9172b6154a3a550dc398d469dda5d0a6da00c3471aa89f445271dae940fda901db3c3cd425a3932b2355c392d218c7133eb26fd3794b34ade71954a322a2fc95d5f807095ee4abcebfbf8361cc0185e27e2c75a40accb86d46ac2dad276cb10c4423be547946cab3635940ade473af8d14cc62b8d3425c2b23d57e3b44968817356785938d215fceb81c494c7effb512f8e84db4ff893e7b47f68a90db567834254baaf66232a49934a80dcc5eee8a12863750348c2b81900a8802c7acccfb0ebc7cd25670938791e3d6f195dcbdc913c59a8e256c6cda74640e092329c3ff22ac98161a07ced36110173ea4b57993b6a6d8a6a09d0903ee71ee3141255cd46e292fcb90a1841e3f08fa5272dd1e5f151222eb5af7239326f83e22f1a8dd46feacdd82e10aa4da05bf33cc80695ebd47924f77683ea54d89213e497dfd24a586b1f2681fa44e08749744f262a29730795f00c10a9575b11704df45fda2d2e2bffda9060f97acacc199cbcbf724e3feee3a544a8ab3674fa47ea3fcb03f1f2484e6ede10ca304373b7393de42bf29bbd9c2babab822e5ee86baffac2fb5b1f98fa8df387b1089465f0fcf2dd0aae993b11ce7321ed1f5b85b58dad63efcae83ffd09c270445657718dd2cfa799ccd62fa81bb5138481aa439a536ff227f4025b2ede7733d39d442633d7a71c77c008ed1fc38bfb3774a6b69595736482a0ad16bebeb56773b69e441a09538784f121a6b0db419a4f770863e22d1d87f871a86a31ec072a60690b59ddb0d66a012e4217bc387affdba9b5c7466f3da7d10ac34a87e04dd3369cdee5a465e2baa7943c9eb9e73b4d29f39fc0032c21a12399de9d4b9ae27fc48eb4c84674a391b645bce7d6d0e19533c1369342d965cfb171cc978c780dced7f1af3733d60e150e0bbb0c455090b53aa992c301c36b5c2843755be4a23eb9f2d154f3af3f6735092b152e60585cae82a7bbff30e84b38e8b85a7594f61b3a4381d3f26fa1151e88e13e37d3aff8e79be8df208d2e0d21acd4d51c5befadbdaeb70c018f1c0de9af6f3f5dc73cb058bf31dfd1c79ceffdf9a1ca3e3463b7befa2933068957f99a09283f0776969e05fa5e181065f25f8004652c33b71f72f6447ffd73cc2ac3760ccde770c6507ef671efb3ac535efb9da17351363d8437c534c2e4f5dd31c269fc9b2f92d5090f59c3f82b7afd4b0448c135e416a6338e847178146a639b32f8eaf4d9029b10b42f963f1ee6dacb25f6f28322df3a5bba32ca66d11ef818cbe2bf2c915f926213b023c10421483f3f03399d4c3ff1cd6d9490c1b4376771e7f2a70980d30bca96d51b7bb07310671ec13d4ba36ba3c38f59c9160b70303c7e96f4ad0a7d1870b4e3e9985493a987854026b0620704803f1556a82cd72d1e235d348c2abb940ce7d85b657788d246559f4ea7373342b9fa1307709cf4064f6f4d9c6ea09915e0e9c77239b699d58be037429d26e425c66c8219cd88183c1556fc00a65a8265e320a674ca4567654763a1a83ae5b32bd49b559c413fb9adb5d56ce02c0c112e525b152fe5ea1e4e2a989da90010b3b7c5326562788c29ff9197a9aa7e7282efd627ff5acc04cbeee20dbb6c206f3b06935afacc68d4692a8e8a059bafbc46c46c907bd2b6ca45e75d3727504244502cb8a646d6bfc6ccccc7c5618d3cfb628c2b9343885ae88fe9ae3a7af7c380aaeabb001209a15b79da2207416076698bc5399ccebbac445406a4efec675251874c285b5806d07412cb29065e6e619daaffadd9bd325d60fe838f39433c3daccf8a89d99d33af475a6a9ae2eb32318f513691f6aff9297283fe49a4f67c4c3ecfb5c278aab4a335c352e3a214c104f0208404c7a3f136e84d1d3b5fc569722c3138a04d305e5378be3763fe5c28705887e5667a39220f9aa1edba229234dc7d63a7b4b7e8993e6c937175d034b228894876edcd8e4bd51866cdd9ab17e1ff8c6cc94b13de840dbdbea4e10677752bf4ad59095fefe7e4d30a0dc4a5bd15a1a95ed5bc9bbb0e62d69df9c18f2868db51b95441113bf6061f648666d29c9d8b266628848f84e3a1353bb59f8e52a234c37b9d3ac0377827f585fab90c34ecd69d95b44be9c05abdfb645e03e5cd81c80925efe888c94a69847158b0c560c8c7fa361a64fdef7fd9fa6217ab4ab1434748b6b29219820fae5672de22a35f128bcf37767d002070374b2c69582fbad075c9db599f89d3ddc4ebf9e55b13a82dffb24c3b36fc702e98f75032191190b3b0de42263cbf05c27a72984ec1e3d2e85a6e36baa4d701e9a23820b7db3193baab5e0709584db45daa143eab8f1b6ab61fd269545dc14d53b419cf69944c0d4f28f790b7cb512b4d699e562cf670d882a3ed0dbea2ec0bdfd4b012a05ed55bb42b6f19426a25bd8e6bc931177281e9ffceb2d5a67aa647f36e211f90aa896d86ad125cdfd1cbbb3b301e234f3c1988c91c683ee9cf05ff894a6a9c50da408a4386ee4edbb929241f8ad6388d50cb0d749c6f5096530c9d3c8a934c46ab52d15b0079d170e4e62f2c19ec3e3e0c08b881cdaf496c33aa58975ad57651511f1ae6341af394b38beae55c904ef4827885188bc334df3dc3e806d4e3a5160855048736865ba1f3ddc60f2806823763eaf4c06efc97572e3fdaaa79a5aa68b26cb9f60c151983d17638ebb887853896fd35fc291d6a701b8ebde57d6548d8a6b0e8c0b0eaa3e38d7ab958f835f39c63bc49fd3b182117570cbe42c674daf985c8f92db798fac825b848f2637934b3d8d25c609888a4c91e440d235a179fee1f9b2b0ee8b93a5d8e159a41d2d7df16f0960a2a18aa324e077402daab456fea2eb2c462f089fe707f44b18235577fe5292ec1cb6dbfa8e122b33996c9a64f57583af682144b21d07a8394d1589b93d4d33941eb8070c389e2fc4c8383c9ab795a4143d742481def2cab73479573e638f6bfcaf38d73e4c6fea27503eeba85d31a9cb9119061b38c3418a14e4356cace76e40238e2a45e3f98db75f584351a2bbc9967f8a44564eafbd2f22022496637369400582891d262b1e049d448ec48b2ea3ecf1b67cb013a148caa407614ccb62bc8376c7140f15b31e6fde5e564f1cac63d1d39a6e60f9efed216442abe38768d60982a9ff01cb770f1350564b8fe0bc075895a7ec2303f818f33e732a28804c9e81b8df0da1f875c894e5ff6ac3534362f633913a364a652efc3f3c111b4584284eb5a6d22d497542e379f420b0b0e1c152041f18d09f9c995da502f737382d7d0dd59dbac7f467bae3395fcce22569","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
