<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ff5d2d29f5eb3c4ff41cd515b67a9f1321d2fb33ad1e6ee4cf95c011c2fa7124f80bf1f9d1c3f38c9e97f8d2edc6854b3bed4647d9126d8c8319ffe4e2e8c839d341118d1a91f827d2e6d603f5262d691d4e280a29beb683a8cf9ebde02eeeb0660cb7efecb02dfab89e6eb8c3946334010ad77f66da17e50db7eb1660b22a2aff1d3d10d7869434ce650afc3f4f9e5c2eff3ec7d74f27d9c35be2e5c15d684c770d56c271807c6bc93beb98ee46e331c7f523f8a03c1df3b4a152f65165159836d3d22020975e49706ddbdaad9d4f838ad6140d5b95a20b8e5a8932fd35e16b9f7a5cb0eacef517198b7076288b73a63bae597fc029a1d69c765901992f99541899b79c7d5f2a4e8e8659de77c99923f2545e0b8f992dada6949a32ddb0d732b22a2757d39803c3ea0cc6fdf1e5db9ce66906c261a80b2c5100c7e1e98e574e4c6b0a6b70caaf4280ca04976bbc871598c960bbb719589eb096670a6446bfbd146b2f03d11eb4c7a55a5bc6b7266f799ca5afc4fbde113114f125a1dbae930784d42e29b2b3ac6cb7a91b06bf134098540ad31b4c9a6b69f11addd00563dc4ff4a4db387181baffefef7c97bb4765d4f8815401f053abb4f665afe014fc980bafc6ac7c1dab6d47d788ee4ec093e7fdb626a6fa8ee0c3e6231ebe69d74edab2c480e1fd81edc27aaea36c8bc25789f6ef41654b25d36d56bba01b680ceb17b14c632498e8711b66b1760adf4ff568b40bc70a33aac3030e35516d45d24af47357730625c959382ffc29478d5bbe433820d26cf749993a53a6e9b07831136d3e17740d2c6957e1c27d783285cbcaade46570326818a844865eff2cf506b20ad3ad1731a7ba1f05522a4d8198269633365a5be4a81b770fa2b88323dda4c502968b21ea33ea3d8a107a086760177b985ea42f0f3a856a3b3e516765b8ab39eaa1f6336daa45ad270d6aeef67bb3c8ae70818b7c61e4b2116455d00942020b62937ac56e76f183f4466df715c1ee4aae87f5ec31f0861f58b7cf12c4d1ef5784dce134c1c27e2c1a1d43809107988b328d8c6e5670e2e480786c022afe83bac751cf71cdcfe47ebc0fe919f013dcf2cde23050da73d5ddbcf7c5fd5fd9f916a031b2736c0a29c6b19ade45825562caa88f36f30448f0af52ce32d9fafab8c9d384487a8482849264a11ead237581ed4d7e967bda0a63e403240566e1275fc55c491af279c1e2a71c1ba2f97d06fd8d7b34a83b71b03c4680beb9c0bb015d4b3cd50f9cbda20235a84cecdd33622d205650479e23367f17d0e7ed41582ca0414ee1287d1eddd7dbcb9ef3b66db006220d09868425e29321da6104155c5f46814fd64b9b08143bc961f2309f75dcd06b75daf3b64d59cb35831d54af7c0cb91bdcfe64f2a24a1fe8f5010d3e6e27f45875380a92d7f0e7a6a5bb46205a0456d2ecc218ac3373609ac5289278129e50a4b7d1709f7536e1d5d9105b29ec2eb3ebf4718c44ef2524e6bef022d10d4c8fd60d7b9d669b79013a4f938dc261dc725d7c87b47d803ee49298ce0d06115385860af74cdc53998bbe163a866fd8cb302cd3bffb0748456b26b0dbd59a11796ca24f09a07966df343257241faee7d71697cf50cd2e2b65c03bd3e1112b5a95813563f9d5dd51f7755a7a2daa3f7aa3a5e899eb779e69ab80b79be68d3e2dc2b2b4720cc06b2080debedefb49627e63985289ad2bc5907fc1799aeb769b8b30a125b40c98ca362964740f9bbc48eec6f8d3f8c26f89bcddff0e83e3449fabf2a98f6abe10f2fe6332eb13b4524862545811227afba3ac36ef675f8f49c073aa4e5cca6374e6f2bfc32e4025d672e86bba47622ba81712ef5907b32c3239c5f63999afa59f8349ff2fc29cf84fa429d31b6281c291b27417a32baed952a631ccfed7d4748ee880761106d0ac0a563b42e32e591d258359085c0c2445f7605f4336cb358f1f4c13e426862546ebde950a21e10c77b9f7b59e05426a6e7533fa7f7e0118232ab4d81b1399a2a5531f7dd20c5deec38e8972a6e5c6a035e282d66dacc620f57cb6f8a530f91403179df9814463ce387929a3b5e57a40b38ae868938ee7d4b78935687c02ac54c71f23db99d7cc539e2deb924d4b7ccb0000084ce1f1139a3b961d1cfbfb0d98a0906c4d6ed8acfbb0b58d848c34af331aa5f7d66a5795151cff2a5dd4057632eb51fde578b6c034bb3245a900896d99174d83f1950a646d1b3c9ddabcfa66f1e2159653137a26c53686152a7fd03d9687b190eb39d53ad4a1f33910240ed2d64e89fc7a3a917a67f388d6e0996befad58e9250f570911059f7532362a4e13d371d55cc908f2b95d6d254a002cfcbb8896b83476089b903ed0e026188d20565f6a87d3a3b0e201e0f80e7a1f5ec59b33063660af390e3138b93b1446f61961d40133725cce93fed8d6fa4a2fddb414139c551a2de848661618f5754e7506aad6a2fb2dfb99971d1edcff202a9690ec5b5d7833091182529e08338eaf559ab30422ad9a4647a4bfce24263bb8896eb3e3b8b6ad48b262de377eb48be5d9bfb161db523452512bd9f78dad15fb0539ff380cf5f92e0e3e271a51aa8dcda4e35532898569adc404f252b5b4d1502847823d5f2fa7080f74968ca6eeb9016cc272d54cfd2a784d4259641c4af9925ffcb5104366af62f670a3f81b7d227413a00bf18e08cd59be44d8dd0854cf5c119b4e8926f25a01db45af516d2be74dc965b01ab7fe89647a76f9cb7b416e8efdb4386281ab53e617205cd0ad84918f4f1e111f3659275fd3adb9266c6cabb4103605ea705b6d100572522c0f77ab36d935eefcea70336acb87c5daa5316f45e43a3f8c645b454ae3346502aad1b7d5459e95de5b7d51c1cafadafd9b61185df7fe5bea9ecfc5cf7d59c0c7080c46a54fa64d5873c4d8d67574a78e7978edf2be378048ae66f1eed77fe4dd85fe3d17dbfcb053507f030e2e5e57d23c91619ed0ffc71fde964890c1c0083c88e859cb75d23ebb31fcfaea84e34851896608136c7e6e433623c2c58d0a3944b0d2e55e871691b76037c17f189b654f34ddbd8134d42ed00e419673e5f25cf3ed7f386a8ae5ce80d2601b0e294bb1f56484fd644ae501ae4b1b1c403245e5b9d4484db980673545b830929e30a5f653da3b033f327afd15cf806655a37352d9c98a9ae9b5b71ea601769a2f387c904ccf831c048458251b23ff636f0f10d8d397b117de404861a135bc0062281197bbf1d6468def2d9c712cc659f87ee2bdc7db1aa03e291697989ac61361760303f7015841e80ff451bd39b7864af0687c212db31733c4cdfb37d61b213cc22bcd4ba6e1d40f0eec87822db37bae0883e13f7af8d73dd50e3e764eabab4dc75069a11ebec5be73d62386aeaf8a36804561a13d8eac7cac621b049168165c4ee4e05e6e6d72b17eb03a524faf8e024ff289b6dd82d42677a8fe4917c76d73ad7e310e0f0580d5dc112e5b18797167b2bb2c828923db298abcf10653821b8dee7fe7b69c00427e009ccc6a9c7007057fe3186bfb2427ae6583700369bd62d297e97f6cec62bb8e663d050ebe2f61e9d8c84c43a611f29ba50aee046d213e94677467034fbbb942aacedeec46212cf1dde7cc2b055226b4c746cc2ac3b462f2344e7d387a39b1a525d6d6d7976163c2bb477a3e7329eb8ae2920176ce012ea6dc933642284dc6af04ac35e76254710822642ac886a16ea9d89cbc30828011605fa068539df903ceeff618f0d8cbe995dd9ba6dbffe0e50da0b95ce090374828280e9e103f6b37b475bcc8b26e730a4c02e7e8be9662597a7a899a29e690a6c9d9dc240f5e8c911d8fc6ad2f74267fab6b2dfff26f3b02bb20d9aa264b0ef696bcb593b906edf14b735698992a945f46cf227b08b4de53fe01bd80a698276d2dcd260d22fddb1d299a48c8002179651f79c43da70633184dce8100f47bbabb278c33ef996f79e19ce9d6589469210378b1e7d179b56224ed5dea32b04e10f9aadfdffc720a6aeccb726b07521545773a635fb8be31002a74d64e8498c1ee2c2d06a6e729736abae0c8e2c6f3257a2155d7d23a63f0f519bacf0bb13ee949dc81141e440b7fde4df595084d774c3547352e4d31ea57fd72c1dcfafed8dd6720c150adacafcddc9f3b28ab4633aba845c3b5b60f53945b8ed332698a6926102c762b56afdc694598553089e68c09f2a296eccda101f6a9d9116897cd54a38e48698df0e78295d5c95b789e35c4f775feb9001636853ea2ce35bc52765313fe11f7157c1f1d1c21d6809212e74b295a7a08cb39d9db3b431f54f22b343d3f9227e274b14adca6acd353495f8838d1198473137302430ccb8a52294722be30962ecd43875e6b1d384a4691ea6ba11b2f39632622c1b81dd43d2e1cf82ad76aef56873654378a10632715d0f3e15f7f9cf6785fd2e4efea29d21f4d50016a6880a1230308d2b9cf01a3dcba4a09b98af88a4f49847018144fe3c8962073aebf585e838a562111b9859fcbdc51036fd42901f70c202ac55c4a1c0e8735e3f9b1d09b21dc149f78fa100a40e418168816f53d6d136c8c53ea9fb9ec6289bd4d94db1cf1b213066311ec1cd9979035093557eedc93bae66afe1e9d290c3a5f86f7737496b174a0314c775b2baf87a1b7e30816ebc01abe38f02adb58e69b54c49aebb7b838600d4abfd97684ed41b35f06108b9e938f0d04ebb5810fc509b30666c9ba4c5fc009b7c9428b86c307da9f0d4fc41183d811823390566bdb7956a0a53e35ef5ca97ceac6f523d061db6c42d2a09d82302654f0163cc4cf43593dc1522610267850ae51d4774e367c3ccaee068c78689615b02507a76552f40f23a3341f1668a15b9fb0277c102c010e99467519bbaeb708fea50e911ce4c37a132a5e248656c0398cce77acaf373c9ef940d950af8fd91976cf1ea3bc6882a289a743a22ecc19861cf183973d5aa716c80e9c492e4400229a2eefb4a24decba6f65966965d3174c5f3761b84b994206f6f62cba8a29140d061346fb2756124e516f0422f6fce47e88a5cabdfd92c62f03a4ee8f6a2efb68b728f9b90e7e7d24460abfd1a64ce5ddccba7531ff038692fe8c1764125070b24c45df313f1179af67314c3fd9403fc08868bae683caa04c4410ed8ec010835797de988b392e24e360fe0ba2070042d2b0f57d375dba6a105f471a03ce28f4315c28702940bf8d7ac7558b46ce1d97e7e0afe81527e5e3d17e9425e94792070676537ef5b014dcc5363e5adacbd775985c14c9d3c8acdd33734fa0d255b398a8309db760b667b439feeff399ecebd061bf9165de76fbd814a490b4befd3f83a1c8ca69eb4a9ab370d95bf31b5ca4fd939cbc72a4846af6cbedb96ef6edd2a1ffa0c197982d5ca91dba046e9f76aac656aa41a56ca367cfbf718507072d0958e6a37a4f9acc4ca93f6811b16a701bf6f340c7d6d97a623e16cb08438e3e3d648ae183aa7d112817ac1f642b8144ecff09b21850e21b84ebc53ac79594f6e7be0a39ade10d0d9933444ec3a3f59d1eee105860a48c374332a829056d4df795adbc1e6265b5402bd84374443714781969afcff1cd1531fa7683d75729af1a9c880aa16d392bac7d2aafa61d8a91179126acfcc6b45c0ea5f8a3b0688029ce0ecbe734855ff8c31c894feeb0527a34645528d61725689c7c2f6f0401cc285d2570cf1b9ed9f86f5be82b6ced8232db62c774fece54b90fb58b21d5a85639e50f4a954ab029c889e705872b440f89ff735b9dc1c19c85b5e0eafde7596ee8bb5ddc0359e3876fcfe74d865db96ae64895143376acf9ca60dd9fa4410df285b8d583285cac02da583c0caa8e1240532e0acab3ebce9d85631910ec28c31101ef0ad8fae761e211dfdcf50513061c2e66b2eff7e82506049fa6e73a6954fbef54450a871ff3879a507ebf0c974a8fd8964909a6b59ce0d1654c297b48ccbad88abac7d1e54603a5292cadcc8c8c688bd11c3ee8d095f7aee48ded63d69dd640c5fdb0496b12aa671cfb3888ef1426ab08291ebb231b3e3630e836619d835223d972f206316c14bf3ec5d8d8e3c5521eb5708a0d52757deebab80411ace0b6abbfff64706b405e5ee4230f707305cf741d09e21dc5a93281664651cf039d95930d5044376405bf90d7a64fef227ddd314700f266ced9b8bc11c22608d7f1c8d4231cd398a0f85c8e2d20c695fda5ba7fbe2607f5a05a1fd93f5c44c30df62a18c61f4bb7d894142b8feb6fb9b90fd5950c5f817707d54ad1619e8cb79b04dcf8fd83bfa4ebc4488942d675d16468801921aa33675bef5f6151846505592a1465933c403703d9b4581fc5dd84e72dba5bea71f362a139ab00a5fef8b799c93cddd28f6d58a82002918839c772902a60ba5b8d534f3f751a7c8a95d85ed0069dbc0e167f04edee0e423702d58496425d5b6d5e6c3ce926ca8777012f4cd4350992731f1cae6bd1326a110cbc3a3d9635179875d75c054a72eaf07b875b0f2ed93e50e7427d57cc28758c6d6984311f62a8f807c51835bef6d355ae7a8a072a4e6e1df7a6ff787317018a5f2e35de81d47e9d6c391ebf09ca28d1015bc460a36c99faac171cd10f2f729f51c2b3d3ef08cf7c20ded2606d9cff22c95faa074508bc4c12c2bfbe6711f5bde05bc539697da16051391291ea81f92dcf7478f21a4be17c46318f9eb994c81c2151e5a2a0cba319059791c7d5408e9b9040803b333ccdad4d913b31def0fc8e726961c32b856f7472eb6a09d051b6252cd5a74119ef55d889c6aa6631741cbd087e924c6ba2f8651930251b65bda37da2b2f7ce863fccbe89c92f34c489634f8f75e942f540dbc81bb0bc4c4ce789a236fd3d79cf4c4aca8bec8e01b59979a7e59ba6fdd3cf13a5a8534ce92071dc19f53795a391fd5e2af0abab1cf0b99dfd12a4d6d5fb5f1653f8a82997a85df8e61eb60d52677a90d6e86fb00c0770a253c8d3837008d6a262a86417da0b69d29144105f3f7176a2c10127b2281e7dcde0c1dffe7bff299bf7e82d723f087a55b2afce3c83d73cbb82395725b4582c58011b452877fbe022dda48e2b4d6e0fe5a76e2b31d72ad4789d1b084df3b8fd760caebcd257a892601b0f4add8d4f617a193b8501a7032d810b8638e7f7d8ae7c6cb16649bbb51c41682d57ef2431942cfc7538c5701450e918ab6289d16d03318e649f5b1dfd1afd6c7e6b445f849accfca61c3bc6c3b23a7e2ef6da58472e72ef39aa9b51db4ac7eec636a276eff2d18a4f0279779d15d25a6669e99d9969607e59b3ecc5b9a39ce1e70e2baeb30a15ddf6b0dd503a4a8443aa5f35d549d7fc63c3c11a62cb9294b6d503566e109afe18f729ff3b98f94058a1d7a23176a9759e1bcd7d176f0bf812f3f8b49d5a85cb1aa5eb5ad24602be72d3bb73df8515b4219dcf15f8bc0e346fc4222a4ff7928bf5dbbf81fa1e84ab8120d52a08134d67ff44b39469eacb3b07110fafb6d0afade9292173c6d6a84728129757210b031bf17423b6a2790e88b1833c6f790f2b5636d82f4069856a58a73e66d5dc25fdc8880b9bcc5cb5e8539bf0fa6171a64a8d7c4d01d920e4acffcb8539c028579c8d099f5c0f5b5c42136a13bee9150f4c76f0475587e7a03283da39fe264809039487c8edb006ad0283309573551c7407ce5d89f694ddd0117d56959366eb8ac2d9603646562581b7d31582f904a0971d4dbc5c53abb51bf5bdba97a499288a1ad975792d37e88f786eea0257e5bb5dd60812aac4690b68a2df093c78f173cad1487bed951b3edd5366949b07a4771bb47b6197cae545ba1b711fd7f98261875caf906929cf85b90c1900924df19c58ccf914f114b1cef1b37fb9cb5338fc09ce5534ad28d1e37176f3bc965353aafc6f4a2638ae90c5a3ad15bd1aed60937244114b03ee75d2086894bf20102840529fbdc7798542d79880f9cfeabddde1a43566cb56493243a5acd656dac10759d626c35b3e6deadbc453d1ddbeb41a213d60195ba80f897079faa7a5b6211748846ee9b6d7273b52083b73dae90c4f546091fea33999c6c6f48b5b724440ecdb95b033146e80ba82f8353dbd46fd7d93fcef400410a39f794a337a3fb6b777b7fec28c811a189dd51fdcef63ab0bab7fe88e5e41bf024c09ab24e687ba000444a80ac8ca1d4ac383d6f6d401601f1d65c35caf778dd72843bd9d2a45eb627db6ae30c17dfd87ee46e65c2db29e1cfbeef5ff2c31c6b045801520395b5cec7247e6724576d566d704b72de4b425f29b9490087de6174fd3b5d6fef5a8be1ac022c4f0c8f2922c3ecc9695b252e0fc07d4f1116bda5933e20f23ab91c17c15e28362fb639da4c72dbe4b7a00f74dd3499acae4e17bac8fbc208da5c24a0b232201e51baa8b09521e7d47ba89fbc3b33f44f6087a729c0ff2de967a91be3cbf4cb55a8ab9401524f2e6241488ee82446724c73696ccf95c7ebb0be3c619b7b883ec09234b4cc59b7fcb3d0682cf67db9af939ee12cbb46ecef3603a6050d8feeaac01689d0794ee273441c530eecdcf1e66e1dd294a067085acd59fb602727a0d03f8249f516f1c5ed8d0a0d94abd042f5f933001d055eb8816cb18bad00e5c860c872a58571860d1f8177b5f1565171bbb36cc65ed8fd20975d6ae5e60b9fb794ec20b995cc1d76fbe1eb7a8817ee437346284258febe1e1f6033683930c354d64fe079172cd46b7b6658619ff83a06bc3dbdf320ae3aa67c5e02f75f667cd449c0c83b79febc3d94f62da01e7f191b3459852149b68f9a4343767c5fec794e2e2725f021c38e89b763c49cd6c94079a30b405c08d80c3bd7976a4b45d169263062f99d2e38ab20fc7298cff267fa0aafb24985079ffc1497668525d5ddbd114263db0a2da6dc406be6060aa889ca0fa5202008ae056349741f712fbaedb82d63e237fb74e9df80ad3f7af7a84f18252dbbe24a4a6b3df44705af121dbc328eae5f18653d4585df530fdd58d81b1a84d90eab20b9dd852f29c25123c86faf9a0d8208f78975e2a16935f0c0144262c74c853ed838670037ce6395bd0047fef70d5ccb8d4ea87cb29af58a29c6341f328fa5c6afda0f19a5a2d12cf2bc6d1e2bd2ced2f37c460db5b4032eac9aaea1cecbd765228098d9ccb8f3b1961406cb44cc8bb78a76aceba1170b1c5c93cb0b967dbfac7f9ccfa50bc8f1471c235cb5a676bb637ab76f1c51e329b954b8a49641bda9c71750b5b29e9041afa368b80b2ad5bcfd6c046b490d171565863d924839e67583cbb5be0cddce69a6aaf12626253bcd2b4d0bfc93110322ee91f2fccf13b1b4162a65e0ee19bb8c4f36ef940c20eceba1b99f442275e3aa771e15f9a2537554eeba9ca8bc7583304a8b6240aaca3e48ea79a5f69f3d289648b9b1d02c010254840fa52e11a75a339fc33d22f3d1822e76447cd76baf9256252ec9706855bf9066214da08995df97331426f22339995c57bf4adb5a0b06b0480bd4c417c9901285d8b844a10c5d2d959aa3fad9c97b8a06583d5fa79ed3d0b4329a54db5a26fdcdfa6d063a265b2ac9faccd0b5c4c0a2f6d3567e22e6500aac75d7760b3e930b947056c0fc6040402018359dc6ad7c42591b725412635011300099932a4089c497ba549e9586a4cf24d9bc314b4095fe53142a2ce7fd060b535c929de5bc997de0e434d9c414fcbbcb257006bda831d3109f6c53368dd921872ff269ad833e34aa08de15ebe795a3249a340ef147dbfbf4d6942a6925dd4f7910ecd14840b8911fb5f7c1e878928321e97c45dbff4e7bf2bf67e9f3ea7fc59e6aba1c0c4c9e5d7ecdf77a0f700f6a3932c92b30aac0d8557f71657c50a1417fd2fd8f85e45406e828b83be08c01a32808ccb01d785c1452dbc5681f1ddc5ba33509fd76036e3b679fa090c9e300354ae2852876e3e5308982b49859785b75663619592660048d4534bc7cf67247ed169955444209fb455bd471be75eb1453e820f5ed5a731806e1973e4a7a49bbfbe6bee236acbb19402e0a87823b7307d3d6f1085fecab6eaa5af03547aa8293b51d08193f1e352d29c51350af912aa703c7178c48ebec4f0f27053eb1a3f23bd9f4471ef8af208eddd7b3e9e5d465b19c8761df0b0f9ca8b914740cf430889af991e5594db7c8821da97ff1a55109eaabb729efda49e2129c3588ede785eefec3cd080997ae52fd28e6e7ba8598d0b7f11a686388e432851e6c44dbef9ea2ec172f193630df59a842b8ceaab2e5286f5f61101095412149051b0cdf9af1e36c36e698674a4cb00951565aeed3c379d42a5f0b7762e4fe36dced7a0d914495d47dc94799b7bc3830669f9eec3773b8fa393e807e446b0c864953e2402bd44e7c95034653f48c4700a21f631e99abc413d2a546835650568f15304717043480272ec72dfa6a8b7c90b84a1345c0dc3743b2b29b411093d1cd09cf8e8a8520b7f7324fd7897787d49904ad15897a913df896ddf48990b66c9ceb98e583efe6eda1895f795bf034f9a0946be1889870cde9c42f9aaf8102367a73e83974746bae8f7f2c4fa7f2aaa0bd7abd752720740dcdec727b1d181c3fc4e05d1ef3ccdda9a23583282e27fff9b92a774db040be73fca2ce36716dee6beceb6dcb19874ab44952fcf0ae14f99886b221ee25475cb7953fce69550835b341d2949d93c4909664162caa0a17905808492584c5b5d3410e69c237cefe9b5113dcc96b05b65a5450303b2658e48a4355f6e319cb06acb6f989b52bab1054e1bdc862e353c021206138b7fa36ce053cd5e3f629ba785df30ae2287eb2b2f84dcfb8e0a0c2677e8aa902eb180f9c45ccc2a43bfd14ec636b590a285bb4b2043ffbd2f69b05fce5db0f18bd1db1040326da117922b6ee8adfa752496ffe4f47fc802bac5a392db45ec048ba2ab7aa340e3eb70398eb30cb1cba2d63fb6b936d0eea754df6ea5ee6af1644adff9c8ef04c8501f1aec1943adaa92a00c91054fdaf7cd2f893b61ac641de9d0e8dbe4bab36267957f713e6c6f68277068142c12a065de2b5ec6f9f18b0ac798f0c88d29ff8c86d4072ca2ab40d526d96cabfc267bd209322758ba19760de13552910094e51c63cb0f6e73eddb49a3ed34a070a7b24182be58ffd6ce849bfb873f09870c77bd39977b3bdcbffcef1ef06c318566fe243c62bd5db155866eed8a8595c02ff7e3037951affc5a17a1927c2507e9e37d6b38d18b9fd4efde86e81c40026bb898eddbe987da299010732e4ae5ba196be3d894cea71013681add5207a11465c5778abfb3cdcfb876d3428c2c413c9a6924cfc3913495035c56a627cada8a68f87d7331dc539ffccc119c4af6d1cd17894f8572c454fed087c6908d119ffb8cf00caa662fbab15c8496300330290ba6b1183b0805ec6a6ee63614064a1f44876e1c2bc2457dc29e9bc66d0af15c4dd591ad0c9d7a16ba9073e0ef92f7107e9900fc98208e5af5d71bd7ac92e6451bbde612ce682718f885070e21a3895b22d636bbe51c9b67c063a45f430575a6b049871d2dac1d2c535651f8cc5ede716f8461a02711e57ba6a18edfb934ef9b3b7f8852fcd4f04d67bbcc069211da307d6b8f803627f0045ee0910571029f7851522234d4ddb3bac626c80e07555e690cc9c9c2f048129773b7b481edcbd69e979779e39a33837ddba8938fd27641674b55e712b9749a40c24608134594b96e604f54df1d8c2046bd62c5f9bc46310e875402bc0d3d6f51cd545c315a3caf1f695ea89382e44aa68e279ff332fe7112345ac0802e88aa10def5a3587a2fbfcf71fdc12f738d415502c4eeb800e251ad2d166f40f8f6c66df5a1a0c97de549a7f0348e424cd7a97f6c5ffdf08cb2184aeead9ec17d37344c61d1b0835825c05117900019256b4c45507de5318fa81f9cc8d4a99a96284f41cd92f17bbf1bad677b1c9a1f1d0d23755e119b5eb6d9084f80cb1549bc2d655128cbb43e9c3537a8424bceb78905522d2bf24aa94fdfeaad20a7c1cb046f53319c4258407c20f9693f0e6f1fa93a88cdeac927c71d9468c87535913a5e1245ac0315c6734472a8b313cc4c9c31462d28ae2f172ffcd8279c4c44a52fd93890fa1c38c8824f29f372416f155aa6fd7f18a529ab2f471223683c6f6cc19464aacea90b5f9f86159b870e4f906738604d917eb568c318a5c29fdfeedc184c91d4529c1c038387284f75e537596843e7ab224d2d9bfd7dc6260ee3cc76f543696eb2bace4b595139f95768aa1e3ab2df0648228e3c8ef9085a8579315e46d8ac2fc45233a703bf2e1868d39ccf189e5093d9e0c0a564dfe7f57a9704149571ac1274b971d28491f5b3678fccfe760fe7dabf56a7320edbc03df965f4e61f5140069382ff9787a6ece5dd633281fff1a9ef84d00e27a41b25f0c89cd7a774e04eefc46b6fc625769a96e86c69f2591b1672328fa260d755754f14d351faa9b92f0aa08cdecd2ebf9682aac5035ebc1f05fb64660594f6b874c40ad858fb477a5fcff1bfe634820afd74c591ba5934eb465c706de344ab054754abf42274de2944e6cb42c42abe8ff9595d902426f282dcdfdff97b9b35f07ca4fcb2ef23e015a1f52419f715a5ce6063c7f623e60e2d8cbf7585e39cf9ff376f18af9294ba3d564c92dd72243716b9b48379d4d373be19aa2a735806b29eaf85adc3f11e2f59afb53b3cc885e7359d0a0bf42ea277207e183551de4c119f3525d8b3441cbb31375f7b07e28574b728c2c281e3cdf895c6dbf49b73af94fb3f18ad65670ec605b9cd3a46e144201c174cda233de7396d33b07f7557b35de0a11cff1cc40bd57b94eb4bc66baed3ca095ffaa96cff5873daf1dcc356ff730aec951c7a66baa405cc93edc4247b66b82321fc34f9a6a858671b6ebb89d08597b9b9d14f45c2c6ee2529ff66408e46d16f31ad56205a6f4f012ae8013e81589e3e015edcf45108b4438339619222aa5f940fd0a4b5d184c04ca1c3df9ecb4b61f784fd337da3cca6ccec9398b3e4366c225affc485173d07c90b7e0850154feb14932a44b51a0374c9a94312c763cf0fb514f9ffa599f720e0c9a9230a2b82c766f6c4fcdb49ba4fa1d30607a10822860a85cf2308f36d8cc30708e3f9db14cab397ccd8953701f0039a7642de962ccab252af8b92457aa58190e286654f4145a7747e981a893c22945b2da7d78c343c135114e634ca397f7f79d1deab1e7789c9c822bdf838f8df68f09d3f8d79714b14867be4f46e2e839feab61d55a61a0c08c75021e8385458f41d473aef3dc4773a012c5acfc84c5aa67ccd1f3fcf8da0e17c7b838f4c3d645ac57f861ac1e3d58508220e71cdfb3f870d7834d8ff8badb756c8c658002a777d10deb1d85202d4796ad2b6f2280310a87e53ef9303764dbc5f944fde26e23e2abed742d0bb68dab6d9ac3b5bcaf3f2f89d55821372b4b850cf123d9f7ddb69af594a1da03085e5be6a14f0a90afeb7990e9d3b46479f8651ebf281de0bc9fbd8edfcd813b10f0d6ee27110132783fc15e9ec97faf6c85e97e9cfb8afd30b525fc2999c42f92fa76cce159249d09e030957e448918632da23535d10ffe23b505db053df3a18b21673c594f624534f5283c9a6731de3da37577b43123f55b2206b5cbdcf8dc3b4035d35e2910406fa4b266aa26fdd66f2c9afbdc7e292757b6bfaad009501977ac3671e44c57f581b6efbf7d17d8569c2f7987f44f8105a0d7b619c58740be991ae895fe232a2ac1dc1bb65f2991f4b8e8e974d2fb36e1076ae049664a3ab5f81b2a15cb98dad24b7009402d59571abb2790543c52879ab75a890b7c549df5665b1652683a5be97ebd1b17da6793055520b0bbe1f4e231d074fa06349e5f5690ba0b4fe962f6fc1da25d439818cf62032ef7a2c44a691a4f54921d2d3bbfe7ec42c26bf15306362b12c03514d2f7aad5378db4896cbf4e2e19f8692958c31a8216f7032e444c217e315594efc24e2bfc31657d666cb687168f2e606f13dca56fa2402f750fde6de7fa80d1b218b5c1017a03c48abe595106399b73d3da0ff53befc31d5dd17ab48f77ec1e1ca4a80c069828600150d28fc122069708d328a3941d0588d9e2967a5b73b4a4749e95c5feb60fe6314dea746dd50e272ea58ff4fce45136f4b8542594c9aa6e2e6842cb0eddcc45e42cba106b9a1359b9f1808312397ca36ec53f1d4fab79c701909d2f1dacda510288b34b5533f5b904d518af4259379c0d5c86d4026ef09b4eca50b02d5bece7b070b7c314fc8ff2bc0895de1931fafff9b7b7d4437b4810390991bc36b682bd6078568a93d89f29ed7b5292ec140bb8ca610f05079c8e4c41e978aeec2ff63b270e870d24a16d656b57fc160bc66c0290a8add9024a3b4ae88c9484bfc7f3a2958139eee743c4f68941b31e2b11ab2f94c164ada27ac6f8e8ffe8beeb974af3100df185949349a4e5fc2fabe7ab696bd699daada2eb05ec65597513c935ab48b8e9effb5cbdc9bdead01176875eaea4bc0d9edbd877963bb4e649167492cf0373038766efdf7ba06ca995e22ed4e89802b5616a6464eef7e4821d8884ec427e357b901598487f5ae905b27eb91e95d776ce58b14d538bc6eabf6ff674b3a7b606dd6e1ec50baf43b5d176c45199b544623de835849abb947df3b0f7e3a93eb66bb7ce1b40d1fdc3ef8e62e1fa9b30f05ec2e64503b9eb7e02a2be9ea80478c887c238899fa13960f279cfa7a2b707f55d7172593d7ed9d8198bfe672fb032adee8204e31536505a7679f7782bcdae295b33d9d744b55f6f21c32ec2974a15a016da71e1ba51ce301e99e93d7b1a092d9a3a77a58561a871a96705f6cfbf212380373a7451be4dc667c77d5a7f87e5ea0bb9cef37dd9cb91cfe0a2abac4f3ab18929b956f803380815a718f82935bef237c53d6b12ad74f6af9ba7e52e6643ec890c05138cd516bcadd2374444388e095541a029405e57addf10093dfed1a6e4067364174298329479207055d984749d21b02f736e790cbc644d0242855b7bd62dc219f17ec360c326be680292cdd0323c9bf53b50ea04b4f10fc35342a890408aeed5380de7ba6688fcaf97a0a311f75e908cf835e1b57a28b8270f66b398db1396e2eaf9d458abc07f2909604b0dcd81855c9dfbd486cc2ed73003f426f82ea44bb4b6f85836fea8ad3750ba669b79013f0ab0e1f96d38f3631806a0c403f61b8736e8806e18a721b738487dada28d4fb17265350327ad168e9cb2a5f9ee8db8fa1ac121e0ccd3fbfeed5a53baabfbb8955744a097fdc8cacea7ca09d4ab2088fafdf0b2cdde681dc9012489aef14eaaece9327d54b9b8654cb1c9c4759d7650f953e269a9a7012bba4f8320011861d349451cee54c11ddd4ead21a7def7d548359582b35405743bc1c00515a803b84b88402c6defc46036b337a8d55f36d424fea94dc0d7a437ab1535ebd666bdfada81ef2195129cc472c4a3509c68c85697c4ba77f83976c064ae3d6de95448d20999b7757312a7941bde27dcada27b78419513e720f945273c4d976c7881b9407b7164d3ff5269fb15652983b62ed760ba20d071e279dbf1e4bf4054e10faa1f65d166f091c872b92243c33485ae45c3807c292326dc5c745a942645ce8487e2fdaaa845451dc147b080967df3b0e8a71649ee0645a243d0d0171f4bf454fdf8d0f56f92790403ff5a9a2fc823ffdfa38f827ce3b6e5d15038e4838e405728af3c0b99bd2a99970ee7ef77226ba4190b929934fe7f6a6876efe3366b20007654c25439112a312ba7ece29aa818a5e17cb3af8e87f7d91f826595101bc1a3452dd623ec96616cbbff65cb40379b5fdce1ae60e3653ce1948aafa6b0856ceb78c1ffee59a37874083c9ed260c3ecdf50aa10588e8431e8bcf96c42a1d430808b63b4eb11772ccb8de86b23f6a7c5416dcf5b1ffb68b6a1f4382dc0aa213abb1454540916aec27fd4fb6fa6b459bc237912fc5d42bf7682cfcdc7f112e15b694a0b0dba8f860379ef7920ccf23c9a8f9688f400e285eeb0c26e62aaefe57c635dcfb915022f9e4704c824f4891c1a55c3712d86bd00e08fdcc24687d4fb3486db3f26503c2aa99e034c241f4b83fcb7033cbf3139fcff46262637e5d74b12783ec6d8b17c2e29b44e288c6e32899b6ecf62d0e5f0232b9e05c2b898aefea60e2a073e1cdb78dc387296294f7ab7e617d5bbf9f0e77060128b132c86a5b60c3a93a782714c9f5da137e4bf9e073b8730e9cd5e6637966f058607cb42ed4577c56c8f4e64c473b6aa10b19b29c5b1be70a5a444dad68d8dbd3761f3fabf455b02c662f4a67505fab1ee2fb4e99683681c82789e78dac18618842018d07085e95f95324524e7d5ee6c2e3acde19ad1473c61f946bc0c2e502eeefbfe75b8276a413a918952da13505a87cd8c24cf79ba86eae60ff9070aa62e7a40dfa5ae75ba77f9dc43bff813170e41addd7dfabc61407fb717abb93bdbfbe12e9f6f04760216ca4e83cd37d5dfc8cfeffba05e5467c2d4548e6ad07586700e558ef433592b897f8de43149a282530c4ea5ca027ca6efb2f8c9396f78f2e1c751c5bd583a65c1df5bb5d06c94e9321491921d73a4c2fb9855b785bed8182abc1ba19058d8406da99686c71e98cf08e1e4709b828dafe8484500827b85ac7c2d0023a62c085e43fc2a87c6b34c414b866f37a0070b309816827c8ed6a1e91dd1e606bf07e9035b2dd66d6f097a8e836f05bbe76508f6da31f31c1868369743df24afc0b804cb976cdaa33a81db16684814c86a862611c78b6f828c99bad5e8862937f09ed1fc9e24bd6f2f005f3828a17a6d236f6460f58a8c263e4c39d251ef44394cfb426d3ec2815afde188a3cc3278ebe8a60995b0508ffed31f1dc3164079742a61c15f95eba363800dd6485f4b99308d83a3b53e1925c8c87ee0153eb1521a3a39b12f0448c3ab878a04851b2151fa366d183670feb2c7c4e824b6dc77b3d5924546117d1acd8e11b7c44b0df2a5edf6a82927b5f472af30bdf690808f6c141c9004fe9223bf3a85c6d6869ea16f8e3ff4f6aa6981e55ea443784368cabb3669070902e67f886edf0e08a83ae4175cd18236111c490f6ce35968ed970d0f10c5d895496ae6b640afce1f54f885845ca303ec3e9e0a2da449917f1c03da3fd5744ccb90544c2c82b9acbaa4572c82ae13885f87b6c05bacdbe2ab224a5196a0c47744bf5cf5018688d7825e72bc65f309d86a79d206bf862201775834b70a82cbff2b76b354bc791f372d37e38418d92df889aab61185aabf5939c52ad9b836ce3c9219387addb96657e3e6240e748f6dd640a520d38158c7dfb47cffc81ec639894bfcf24696b59d712449ebfb1f8f478e7216bd69c26804325393bd0cefd37ac4997a572c35350e927ba835338abcab0586320f1b3c2f8d53db448226a41497f802b442ca4e5ea113456b3309a89cc5d13721b1ba314d0b0f4cc8a87114fe65f7ef3f1c3f618182faba23b71f8e606996fceef965f5defbf12ed03fbc1ee1338a8c854ae0313c2e1c43e2883c44419177bbfa217c0283ab077535f01469a17742fddfe329b9ad089db18f96b6ddd9c26cc5a5f1a5cf7b2bb0e17c964f3c2b23bb79d1f6e159ddf539256eec263c54fd2bffa22de9cdc3ac3352297a960383e4b99b256d350c2b1479bb510c5708dc55fcb0f14d3f7e78b0fa02379e2e12ce88e91d9205f1687b9b7a3974cb71665a7a28345c9d895640cad47008c459c0d57a6f32fce359ff9952969f34464576992fea623bad25536b788724047a6eba497e4cbd859a34f83e15bbb7bf2930f7e9c772e7ee9fb43f3dfe5017f6e013f4135902b074814c0d916a0aa7ce857f6815e701e02564b85568325100b8017b3d6d0a0a012094bf819d6d5eb9134dfd30089ed325e51d7d9a9088f6d31e85832bf4bbe80774678b5f44a905581df44f04756c1f5553e264f2872767e984749001079","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
