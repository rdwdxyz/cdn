<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"dd56596e7c64e23f456fa24e906b675c90f81db0fdb0bd4192db7bd9eeb15ffda62c27b83c477ddcdb36ec23aa510fa756926971d21c3eba947eb64a68ba075216bc9dd00c2b3b65684bf9fd2a651e67e15701baf88d0c84a89f0d5e7c7712d0444cbb66d6b813f21a2a134fa68dfd639f135ec21ebf174959538383938492c34bf97cdc1416769c8001912a9ce0d2c05f1ed1188f219790fb11e88369b2ccac36aeda5decc851dbe4227c3cc7cde55a89ca6855c169f62cf086c837407746473f6066faa5b775f4caa5014eaeaafcebd8adbb3d23610cd7a58d51afce78cb1917329eeb30462ca4e847149fdcebe2ac61284c126ad0b7e693b0fa5bd66451727f5b119e9a901c8da3bf64fdcc609848fab84796fc318ab0746b6561bc988cfbd6e7da278a7d5d951cc1b84fcee7dd401ae91c7d252b129a0879b3c9578de1bcd19d1eef92bdadd6dc1f6ea4cffec5f39c1a5e6d6fc46c3406bf22dd61b1797e60ed71f680be461c4e8379e0a2ba699e3dedd25930109bf8dae5af030525e0582ce87efe9514bdbf517b0c9feceaeef8a603a2d94f144bbbc6f9d0e23446b93f600588ee7782b3f0a2a00df70c135feb7a455f7375ef391d9c87858939e5113212b346d3ada0f0080620d8c4a516a62d094c771c84ccf969449b6dc2001513c394ce966f924524d143bf547beec0da15f214054dce2d229076c67e883b778419290bf2adbf8a56a34f3f6069161cb91dce82bd5708ed90e4965bb151c9e4a16073a7b4697febd58dfc8b1945557f9d99cf12d4e50b0cc16dc15cba33d275fac4bd5a25d8941bf5467f55ab29b27ed34c0867bfdf794991196dedfdc5985095f9ba842d24971214f5562ba1723e0d63f9a08c8b39fb84b08386f5c75139ee204f0a7ca3bc21f693f8e531ed663c54edb6a58cf80a018356f41830023249dfb5b19108ab9433ec3aba93bb7a5eb802ac4e8ac658d9f0e5ffa9867a2732a18ede6b5026b9b74cc40de8d26e58ba5e6a5e5f313d1e737b5a1b638e6fc062573cedb6a167df074ce6b2beb6a5a3c888045fae5e51bba35ead4cc6ccf362b935d396135444c817fdbccfe954cd117c93f3ec8a23a4c8458e87ecd3c435489fb0bae9046a2dca8c67739f58ea47077f6f1fc3724319f8f4d7dad2e97fbd557911ceb8e85162cc808736e1b422f800109d4a202ed239a3d77e1a7afeb5815ecf11e6226a836b84cac4492bf29416ec0f64e08a2bad626c9f9a20932425712be5a518f8b537e8b49d3b79dcd352ab79d1f45ee267c432bd9520a3e402c5c6c4798b6843a1c8bc50bc87654a7407f83e93d95ffc4b6098cf422fd20136ac46d0d14209f65b3848c2888ce1701e1b798c164da101df093978fac4d94a56c61d5380bd2fa7f6ae3a0ad62c08229ba28229695a3dcc1eeeceeedf00afcd40e97721d2d17df06aef98eb0e76799ea9b0806ef98ab60ddd23426c13faa6a14ca9faf58dc9e5f241df83de2e87df98b27a0c4d89c3031b13067af572415f9790271e7c7c7cb44670cd4445dbe25b3166d092548a04535371544e59f32543c1c57dd8267ad3a8be0cbb234fbce2e348ffbc7a1c46acd10fbe3eee131f39566514a5ed92724562be688e280f51eff83bbe221d0691c23b92b4848a5d517799e43fcdb413706c440b166b586bade5bd1739976c53df432a5c79fd85183ddfbc7fb385bce5a64dbf713f42ad0c4b1dc9b3d349c3f817f22cec15303d391c581f3e2dfe5539095c0adb56b27cb434e1e280826960b88edc6c6dbb7fb64cc6faa0649c1e4ec81650c3f838beb95138362bd25267ac431f79d087451f595e5ee71b97296c29722310d8c2fc1e958ce896b4e3af3f1dc6eff39d36ea7a83b5d0e6f10eb8848b02a3959a8d69b450904d05e6bc02003a8ca9fa26a86bd496d34e36fc66fbc8e5dc64663ead247bc40b64e0b2da8d14ed670cae8b498c5d0aefc95f9890fca3246080a1b5f52a2398c7834e1cf55f8986993cd08195c30ea0f85d68b741ca8a5be5833b939d41950427acbbe5c929347b3ea8f2a721501fedc81ce3338a6f267d3744cb63ffa87577f739cd120c9acdefbbc1c15dcc848535d711ece55c9724863c0ce868149b99e7a4e9ee813a33b08cbd6ab4134b1785374fa7737fa1506339efbd8903e69ad63717eae93794d11cdeac7722992cff7b1b8d58a19b4f4c78a144ec68e922507f1b95cec04b8f28134d69c5c2f446f1a614ee751ff83ced3e890f7163e3af5bcd9608c7f6cc2a05be8fc659fd2054d59e5bebba069fc5b2b69f2bff7c6d2dab8dd8d28edbbf6a391f31f6579873de227a166dea6db7513d28aacb38ff7adfb3b3639501d3903ca8521458a939e2f4f8976ef08eecc82a7b315d234744b2949fe66e3dedeae9817bb423a12c68d813f42f9f8f55990cad20680215f4e066f269757a73a4abe4cf53d9964c842a0fecc246babba1bfb2a7fc3245182139b8deaef51b7791b804cd964afe3b0639516f514845986f64683d5d90550364fa95b4fd2d64cbbc98d79d28abe15aa6b6ecd3b6793f30d1eb239a46e43366e9c02cb00582aab3aaa119b4541c3f2dc51525d647d539ba84fe22da59d18fca930c116a45004078c78e92180839fd1302b6024f48a331c1b02a03bc813f3fd1ad1be803d6e6b95e438e353e604b3fc80f72d92b9138faab1b2061af8082c9d540af4293ed938cfe4a1074f383760c25bfc113322c910f7575ac1a5dff09b773614b61a8417aa7e6bd0550d45fc262126d4d0d56f0ee19c7dfdd276857e20ccc8943f94950c5fa98b76435e47acabf47dca88d946b828cff661ef18b35908fc618400120443461592860fe0ed00a87c57b87827508cbc8ca28c0aa99a31819ba0547a18744d7d1f714bb20e602a1ed2851e59178412d1a20fbe65f61633eae2c57410c2b4a76ffa13846fdd02179156b6b41e81c178b80c4bb74134721f46e20a2d94c535b9873a6db8c59f74eb803e316202c7aa56427003fa8f6b6822fc01190f89391f05e7acd277926199b8a599bf778310113b4e0e36f6d548e44d03c8233f4b590ee9a14db1b42211a6a224ca408616e39bbe1f4cd34019cad4766e733a8985bce6cfd14e042a831bb72f1368c0b4b2aecb49d3a3c6edb13bb63bbc8e6ef8662e848ce8dc077867e4376010226d25df05ea57e91d5265ab7c360fa643fd30c645087bef10954dcfc456dcd95eaa8618eaf78d180ed0dbbaf5a414ebb0589dfcb369e24029db4a44f5a7327bd6400e3d460a9215791e64a025de80deaf896c948cb07e13698386df713b2c0e3fd60003d7bfc813d1ce790deee4d04e891c516959bd29e8f3fe9912a9e7aca4c583016ab9e9a94f3dcf1165bd0911e8512b2ff12f8179bfaf689f425903a8d82a46ff839e58777a419e36592994fd792b23b7d95b5b32e13094166cd7a1a68edc61d1fad2a9455051cf9ac4e989990763e01cfab0cf8c618b3c3d1815252fcac3fb2fae35ce490d75daec0b28f8a03273d89fd2d14523c15ca7a31899ede044f6bba92990da305204276f3fe5ae5764707290bdf277fb22ac839397f6470b3203aeb4a15ce7be20aed4956a2f0128235bde02f43f1ab73415b68c9317a56bf06d9bb8e3885bb6526dad1b4a61a82de270f3ac9de9c406c66dcff43e9a03d3bd6072b7e50c9c565f06e716f26573a706d3c6ba34f85153ad7abb16a6462bd7f4e48a3074eed4d96404d524a36d60286fa3863445e2b0c2cc75c4ad88c7347c7c61c7bf4c52d289707d54aeabe86a5c3074de597f9c8da60797a47b8779d8f64258acccbab2774cfe416ccb90a3183846e467bf06ef0af0fa09f060405857b78e039b996fa51af6eb8a0fb55442473ad6e6714c8c7afe5868e517b6b30994e2a68c709c90d2f76d1cac30c124c9d65ecf2e6e9e8fa878865e8ed8eba97a85e5dcd2a4e009815b0362f5783e3a018872434c65718babafc77f7f47badf61d214ae97f8a7c3deb1c8dd14960b2b9e6c109d4c9a60c5e9556c30e9f977e6b99892fbbc36b10c17227f59f85a936683ee430f0ef90fd6d2c5ce96f866b93e6292f5c32b9d2ef3d242ba490e63372e57863505a66cfd938dbce99a28ab65c14a77fcbdb38ad39ea15a8000525a04393038e75b61817eb4187e4ab80e15638a4556943af1cdd0258e4630f4dc4203053da2eb514149c679407f6a1595f946013d346eacd7ba000145f18ca1aead9bd1ba6f7597cd5a7ed0b4be11255d8ecb1757a552fd0c13a351f8b38542feaf36ffd633039656249c855837755e2a3ab81c42eaf289744255266a33762051115361a6af7bad0a40374c76e58e71a07539ab8d94948325f7d4d62818329184b8c98511e098cc1e44739778399898ec49d8aa64eca344afd224ab58c2175c936e5a180d63e7c265ce9092efca6be95e444d9cbf6d407a464277701d3bbe7b69101a0c2bb44f81f7b0a368a66eca558fa74771b58dda5acdb05ee9a981b082627daf8c1443b76b0b8027c8da4eb49739422a8441892d77a1e82c3f0e9dfebea546592a6259283c44a9a4da7088cf192b54087557e250927a7b1ba62fc957cd3d8058beadf0ecbe828307f397b1c2d2d1e765f02450874655b812b9721e19ef4dce1c79af6c1dc4337c617b8551a42ce2224ed99bc363efff985ea65723288cee81a3c1ea81313fb96a7ba6ffd4c1594055377e1dbf2738cde76563535c879fdcbc94336ed750a7343ce9d3368b80cf031e620f8e7913b7fc93d597138af4703665560458675d5eadc9c7386aa7c7d20cc3f87bf0b8b53f7d3f224d38bceb2d9d9440fbaf576452e8c8ef4e2260abc2f45019ed863b46f2fc138029f7237836a6994729bafd4ff399ace86f42c76eb465f1b4daa7439170c6943d0fb28e27fa3ee7dfe1a7f26023f592ed62838d7874b0a7259982939507e4a0ac7b650bc67b9991a2d58bc5869716533cf456952cf19da1fd0daf4766375a3d17e364e25810d104260d8808f221ddfa374eaff8e71b226571227cfa7ae65ab22f602428b87890f771d155bf173651aec20855d5c41710ebf2b45ab9f81d87618cc273c45700bce3432fa1e33594ba541e2cc4b0a2a1a93c42a416bfb00ffcdfafa1f46b286f05c546ac204281f5f88eafbffbea926ed291b7b616d7745aef8cabbde98c9b0fd40c07bc827f6f6ff9d6a72e0b4b6611ebd8c75b68db89c3318d0c8a086649f1c2bf1ef9b3834d5cfa5cf5008f29c28bbee242cac43e0111722ef6a25b12b4adb7c945a38512635842ea3a4cb2be6d9ba3c28e6f0d83a8fc33cbba303aa8161c048bd3e9d4556bfcaa4b4e5bdf05602dac4ece26a47c0380055a28599ab76afde7564b8cc330d532c21a9e3edf5c3884015961687408b275a9b5ea9034b7510fb8bd637738b1a42cc269cb2e9425e1f75bd410f374cdeed3ac7ee1dcfcb6d8762ca52e125ff28a46909b74206f76430faa6d40db6f6510cbbc5cc92c230bede6b4028f69833520734aa8cc0bba1abbbf9417383ad5cb36801b2cb2b4a955adc391be46f45f7805d6edd399bd916dcb65297cc785ef90c99c3a9ea9a9894ad72fa6a42c5e3ff879ba3e596e8484a7ed9d0a6d0271ea03f41c959353f4c00f1ce954274b4f296a9727a121f273daca71513c20a13fe300c23050b16ab8757db364bfa94aac288edc292dfbb53fa5c38e655962682e3d5cd0dc3a8bbb0a5eb596843794e150243e679429f948311517b586f996915cffc815fcee3ca6b01d827aa65a076306277f0118a14b62bd1daf20eb80afcd1f3ecec6014f2053deb835ac12c31ee4634548fc21de2a848accf79a3d07779dfb5130007bdbc3d4124c6ea3700f17ab5c73bdedf45910c78e752dad249022276343e018730cf792098fc0371d26ba50176526b20701bc707f48e2d51b273ca43663b858643d768699d56cb4b4346a627119df03941173ee4feabdddb6e7286ff0c6455a646bd48454e3fe2e0fa6833821e446a7707b59e6a6427de0147ef54714921c8341dbb88e47303ce12e780fd547d94f5e95771011cef00ecd591bc55d895948d91e500b832cd1c0e331d01d719820e3fb4d6ecf77f80b15ac8024d464d3445ad06f1674f12b9c8997dc59340fcf39367edf7c79f50599f07e4a30b95e9d389c4db026addcdd5abb0f3b409102b817123801bacdf846d3ef89fa5a8b7b265bc9d4fd91e9298d3213f25168f5776dfb73acd49e487ab112a69c84ed54c4e89ea4f2d1623f1bf956ce77ecccd02fc66dc57751c45c708104308aa3ddb3e9496cdc276d626bf5e1d1eca0c27630de195e77fd906bc50bbb9f78243da5e40f66608ef1c46f0c46f72537d70417fb7df4e3d4b5a31f2704821e3ddd06164b4e19772b490b899a1c130720a3fce96ad70063b58f99a7ea88b97262dc24a0b6f48ddfeaf8a1ff86fb2c3e81f9f59d79f08c77f70cca885a03c1661a46cbeb28ed721d5b47a6a9d8333ed07522b9403467242bc07e0e4fe0399f02b72879c8a524e58d9122f92eb0fcacd062525671c5bce0de644db656ea53a9068693bf9155d20773c6ecb8a58af6500be4a114161992a547e360a3a5072751bf2596f4c80f6ad624cad004d24a091d90319c4ffc1b6e22ca5152fe1e5c28da6c931e6154d28b0824eb061280833b4d4f99e3d98ee0bb4f4dc29787ea6a08a84724b14ec16718072825caf2264ca22d798c07658662b3fe8372b9d216a69106c7bd0131d1f94fb8b1770a15d9eea4291d3be36d2a192883952da166d8ebf470228895a57085c7f9b518785a99f28ea3324aad0a9b442f86641c61b17924959efb0ebb4985680f3325143a372f71e12e754a80129398841c70a2083927b214cc5c0d4cb08892ea69d85d10871369a49687fb424d5c6a6e1f574e4cde0222802040d6677eeaa93d588ce36ec4d5f7cfa3dc3fb4ef5e7e0d75c4c7532eec144b634d11e93fba2befc1fcef115f41cd09f433ed47acc61da4e367835e0e89b7ff4162e91c313d4db1ca7a2795e4dcf5c4e390b4b2d5da3f0ba24c3eeb3fba1fc8be163a2f4084e6210600fb1ff1f8634bae136a38fbd8337fe7eeffa7e02fd56647ec971c9c1361f3c0b85bb67a627b402e95db5d703a5eed13c31f0a7e04298a1655abc02982452f8d606f3a9bb880257b0030e2b13d0be19bdd1c871bd6536e54008a46fce9f30e8d10edc10f29cbcc52576bfdc782e245903a25e448a6dba4e017060dbaebb193765fcbbd8d5e3936a8332cbb2e10bb6f4539698eb9ffdc48c2cfa4001a51d3c062823a2c9fbe9f2eb49c5df80af0e41c9d044334a8917d59c53a0029e5515b320a89106fd20dba3f8ef16ba46667f06b72aa0f6cecc88c1dcef2cf13262ca87e59a59f03e5f935c729f61fc845468051e7739bafd7c7bf7e8a6c6a95c91131ebcbbf7f87f65e6bc16ac4918e16b9b25fc77be69da1b55c262a9efdac8da2b96c7c6e5c7dc7bd4a07d5bea28f0cba72dc437dfbc1e5957f70ac93afb488ae3433403bd7cd8c844aa5f584fc632219722ad9372640e2cdc888ec3538d468f387bca51e7fc26441854dc592a6064ed4b5a87d45b3eea6b76be2357224f06e9b87fcb73d3420919ebad953af173459ae046310655da5780f2dadf666eb8c7a2367acb31072510e0eede0c16fa472a9e163ebaf34d7ba940e703e6d487e35fdfdfdab4f5e9fc41b7dc5971cae285d8449479f2ddee2be7c9a4e7d8e12dab765da6faf3c52c354737c16beb1df81371d906e9ade580f565a5da0fcca86e5c6885911df4a466478669cd28b637ca48d0d4887ada0302fce36b405bbe241a66c69bb938d99f3b7e3ba8a2c72c8a72a996b11cd93784ffd1420b21da366caef6205634cf2207651230527f567858538a307a02e4dac3de7b6ac3ba23c4957293fa2b1934022cc0cf460db878596f82c63181504371bee84b08267eb75418999d7984b6b733c1a2bb6a841abfa800ebcc945bc978c2197d6df98a73451686a3460e1964a153ed48b51b856eb53b4531931b9a143414396d28d3a5dd902fba769f40c6ff6c55a2451507b77b1130b18ac78ea1ff5771d08a30c9f82ec66b12cb22fb5bfce66064659359aff6bd45fde5d93d8de4b15d5151307c3f75dc62ed30e619be5e7c950f8c32eb942f2d32d4bd14ba14ecbc9866d00a683f9d41546a69e2117f4df08213d31079fbf020027a8f6714ce8cebd1016cee4448c4f7635e176965c5a6d3d332f339b2a35e638d74580dd280a59d721f6bc43dba7e4bf1382d62befec20a2b553b21e15b214df5d1c1fd98ea38b9a7fbde3b76bfd12fb0497986b27b1cbae4e4fe93327a3fd4784d7c26a068c281c66c0cfc34dfa493dd7089dfe08b84ff4c9961a04091d25233d2a5721e0ca68806c8077bd20b33c571b095124b863334c3e03f9df40e9cdccc00246e373aabcdf10cf32e325fe1e648a12853460deb22eea43f74bbc9ae26169124c9f0fe6a0753dd3a3cfbcf3453a672a1d3d697198be51366869d6a85c91e4e9c5ad3b93e94cea716762151bf2ba5612a94194a7039652dbc64f117a6e9c328b1d6b3ba79219f251603a0a65ef8815a11933a8e8859d92cb524ddd59f7af095ebba7bfd41ac9a0fccbe736c587f18d5c32326a4d9294444f9eaf21c40b3de705ab5189a2860394575089e176d453c7d09c90c6a60e4867be3a4c2b1b5f952a79b82a679a99092852e0dbb3b4814954e761b94d911f8b0bc4711112cded24aecd3c0b0d397127736351b56b1938f46d18c21b7ec2f38e967c50503c1341b42ca1b15fe4fee11a37bb93f7bff9bd9d95e8c8d9ac3d766af9e920fe9a910e727c773afcd95f681c7aeae67035cc7d8d328b42318a15e2f6b52b1b75416ed2e124515fea55b42f6db9f7fe5729aa8555c7bd9fff86a94816825287e1a447f2645029b4816cd28049a9b8194cd63af25386e7e30ce336e014da57706adea030b4ed85af4d5c2b5d3f2f31d44c32afaff7d4733e52ffc9ca4f095d787fbd1e8a08c0e54b07373d9c04364b75ae26a8d845bdcb1699f8b8e33591bf060ee878e04ccf8c81cf53f0ce987696636953c6e5dbeed0e6a300d391b596f6a44478aa306a4031c912bfab3de0bce3e0eb199abcf7ca60e9b196f2d74928b464c199cb42df2be9bd66efa7e92eca0dfb314960d2aeb61e7c30ece5c6ea2a7e98680bddd9ac815c220728944465c7f47ed4b9d263626d4d53d9251dfa2b488f1fe4c5a57a933f40d7155d3646a929591f1cdf0b9c1375118551bbe6a58521c9d29681720abac222954f16e39ca7b044e29885cb688bb8982f8abf64f5591762065b196cda173851134158ed884ee86ebe251e7f2b14ba9101fe88bd42f4ab858c87d455fa786ee0d81d58d62204939e11d732ea5a8a679e2e95fcf1d4a1e46bfb159da7a2ff6ce1e653d312821ecc4a0d8075f1d074d42bc2d0d6a43c2cf85fd2503b43a95a3363080b86cb70d8237d2bbd8e6e16a9a7392afb32d1e7646c4c2eb79e1e4979aadaad3b50014c7986d7b1bbdda7c7cd001b0c33801d90af01ace15217f85c3718e5634038b05732976c2c37d7cb48b5dad5d577f385af20e130875f3d060ee91b02cfd9525485e0b4816b271ff849afa0749b635bcf69c89ea64cf2ad663aad1d0b4b2f9a0b45d15cbef932edca0e7ead4b796905f7cef85c2258bb9811db538d7b647b089f86d7ebb1d2996a5632bbf83c8e4ddfbd8de654adb527c8fab3ef151b148369c5b5b5ada0bd37e1253f855477e39b08b3e86241106eea3d294fed1521a0d2ee00e330b6e1f859bfe717f04ddfb8f60d4f82ad9a0fb214f7ebfbae8f33cf34fd7ad9efc258108fe2a4401f9124fd51e0a176dde69df4899e665defca347322ca969caa0c3a8cf010ef815364dadc676441b931bdf39d7b5014eaedea9e3de0573bafdfbb8c1f0cdf97bcc3f3f817b9d37746e0441f383993ceb25161e3ae6585a26d16c1b05763fe139e7804bb62098336cc27303a64fae63c74807ae95aa047bcf4d88e5a04462570accd60f692cb827b56287f8e221b5c7c5a2b1116e182fa770f6e4e4ffce387bdc3bda0c2b5a4f2fd413b9268d503d7636612add9c7c3e2fd1ddaf9a2cc141c6c0f020f84de4d3641f0dcd61ba148428087330ac635360c7be49fb2b91cb663338ebcacd72b962c855a2a848702a7b192553a4ba7e4bfb79361ce6ff64a604e390d4a1377a64ae756db5de64621529c5e47f24ec6c475bd6ad3eab5934809bf55173d8d5705c0a8104b3c5e93b0b2ac28da8926e0fabed7ce44095002fd15c9c2f9fa619d14df77c7866d20ebeb1d63267ccceb7e8800304b80dbbc17c29403b8e94f8de0cb4b884dbffc60666db6280522104ad1ff8af113640ca65a0e4575dc1cd569a663437626bc7e38ce36739a5e56c0133f764602cc51b80aca44d3c339389a61997c674b93bef685f967185f52173ff8a6659a5e8a9b4530d33c96a4aa7bf6177a2a00cb561ed0af9ea60fdbf84c7380066a4d25726a987aa8549b5196b42f6428f4ad0785e0605d5bd205aa71244b1fe3b76bbec63a63a642d23815fd1c1daf19d4792cf5f2ff7bd2ef5ceb5560d3be8f2d0c4cacedbae55db34d1a89cf8238a17ab06b6ca04d3529442a10cf25c7dc1c7e966d20becafddfe728b933917f9505e080f7b08814a293522601986017d7ef8c7ee060ae556dbfd94ef7c7efc686060dcb2ef6e5d37ebc22e9f05d7f8ab5182aedaa56de9608a7953495ea0b5488023b41cde099edcb134b389d22d4e0ec362353adde1ae593dd733dda5713e1b43b11deea549d6bd296cb9e3f76ef7ca15f8e7b431e263e34804ecd2b62f7144ecfb8e224b59b10efc020c1385156b78781863b92b1840ce6c364478f9db1cafaf74a08961d765deaa38719f849ebdfd040c86af569794df449a0b07171cacafdb1494eec03945ca8fe360c8fde324e9059456b42e78011054e7a732ab88c9ac25cf329696ca3819d22cd4083553d58e4b958c9996cc6768c563cdd9010dbdedca4b384318dc641a93372f72489c87e6879eb95e9d11e757275c1ab379c3df89e4a35ddaf1b5dcbb5aad6d5d046c70287f94c48bdc30467b56cf6afe88b6ecd64d79dcbc2d9f6cf59f9a95d59705847f51878ab3f82dc0c2011292bc02818f421ce50f921fadd30a0db9cce158eedae119212205500b9a5744299550e6ab02811b2b2d0899216dba899b8485901526fbff734dbc99b84ca4ddeaadcac7ea376d9c58bccdd6ebb48ea7021a215e753b701dd3b92fb29a7ebe47fb445ea0673992b178ab52e6f0237bf0ba6fe0d683e96bfb6f67bbde1ffa32e34df3bdfc6ce4e2925b35761a3c0d55738f06d718b5a06eb5f35a002e75c3e4259b3401e5be5d635e30ab36801bdea7be81007e17a9881c081325a4664c7549ec3f404f601ac06a6600071a66359e183c7714fccfaca51ad5abf18387d31f794aa13dee3a133025f320c30bb218e863a65910dfd18f806a7d306a930caee3d2f4982f298da3514fe4f09211eb28a93269701fdd35e07995df1d5f0a85bc8fc27491bf6e06e9649adc8342330c9d27010a9fe9af89c08a98c101addc83bd7c85ad2eb4dbf805a969c35aa930a430fc29ec4c38f84d04c0af01fe90655190608dbe8f1a52bfb83ca3934743292c5a45be5c73dd183520b5d90823c72299220dc0fffde0995885a713c74774e17a7ecd60b130e46413d5b6e10702a382ad81a95c683219dca33fbdb3938edfc5b036d47391f75a9ae8e06c8c906975f336da11b6657722006b8df83b64836c0ff83bfca9b91af10a59f746496d47d76c8646b38626cca6dc93d86dab3b3b1460dfab70d695c387c4862640e8ab515297625af3c593bda6e12c0008f0eef5e8bb0f2bf86adf939ac6397cc94c7c6e6763c9d01e30d2bb7357935b3e53845106321f3733d296ff8c62f5f7a3cb8fbbd968bbe7ec47eb9ae369413fc170d709a0c449eecf74692e9b1d5b0f7b430086d5fe3226c03f97b57257ebe2181d4b22593ab28ed552ff7284b6cbe119bd7b797d740ff91611651f16bedb668fe93c21b2f56c48cc876ab5692fb5ce987ded929f3f782957e3c677ee5e2e3f7d26d2f34c70577f938ee1c0f99c27281f7fb1f34a22475f74e079b66a02c1975234cda9a94ef3c542f3b6b4285731041fa5904a0f8a152ea2e9c88fdca5ae1e098fd90d858ffd37e26252a833bfeaa4de03a6f79e8793623bed016e31c64dcafd6cb66e26f71f93a94a2b2b331af9b7b3600d29d5ab26508470f66ecdb759ee199be3944676eeafa64f40e2ee80fa7f1f051a399fb2ac0ceb99688cdf06bf5fa518ba0f10f8acaf2ec4d2416b30a97a67baab9c5b31ddf854c48b2a652e76d2d662fe5798b43343f9e95026f81f73631e9c6649ca91f95403db50c7a6021ba4971a344faed7f10dfc1069dc71c90c2df205a391921dcf569cb6610fb0d8f7c516d006660784efad65e80af35d09edb2f78209c5ecae37a9bd0195d4d0df54eba20617dd4c923b6c70b05c1029497216b6a0eb50e851bf14cb70fb786e0bfddb67e30f2c0d1b5b6bfa723e3482be7e158ca5dcccb31de81eaff996dceae8e2aa86064ccd7c40317ccb7005444b2f08fbf6fa85756c5893b9ca1dcb237eb161586d8207c7f0d3e30fb8d6fffc98081add3d87cb390cbc3e40246e40a193be2879cc5987e780d8c2f24e3076f423470fc19915c72ad3157deb9351cdf988a4b6be9a49b68b5e654cdaad868f0e00370069f4b5cf886eff19ad08d9dce5f6a736a6273526fcda93ed348bcff03b6a4bbd559e79afa51a2228de43a3357978b028b09e20a1f8bc4c5b1e13a730ccd34135ffda49b54dd7881494ad74d5f31f6dbf29ab5bcfc172772a5ecf1e633392a19c9046d1434e8e69f03f5f23b73a55e57064c19de47aa94129e5e38a1956bfb41e9abb05a0d5461c493b7f4e7d1e525ba5db89d5ecfe4ad2a4cb79511b5591182aef153a2ddaad03c0963c43a4bd1f06f8c0b7ddfbaa59e7bcc6c2907857e7aeb688c4ebdd20f2fd2aaab5d4f1c4b30243d4f9c1de9b70069e3e5f0a7c1f9a214d6a3c408fe52717ed3acbd002d9bce86bbee4f26b14cb5effbf968d82ef8885a878b62ece5aac158974ba66ba18345c41d39db10194ae49977ef4f616fa7590dad2c3b3d048c5e85ec9ede7e1d856d76d095cb5f4e53d7eaeca9905e8162de5794cb7afb0a24281a5d6897e4aef71e341c1aad6921569d102cff55b370c950db0961715ad395b78ea663fcc1affb1f967ae54515dca2665135f6ecf7f20ba0c33a2454e6cc712caa70f41ee084fdbf357e6642e51a3ea141c4e28a89585e2e74c88a32a8a46095f75ee4fac5668085e57dcb8ae873da8e8b8f27244f1e418a7a7e53293e6506e245a94376f5f251763e8ef08abd337d6598f630a38267fee8251dc1fcdbd99181af2e7bfc0fb924b6a8e31970655545034f4968112631997c8d8ae5fa9035da138ac53b1cb69c3bca89de1e388b2d4349cb0fac409ba1b69335dc1ce665f3a3782e32333a40b8c8d132e1596c460fcf91758c98cb627ce267bfebd54399a1bde6026129d379acd1b9f2fb1e6263997f00d6423c2226e4d310de6e769f442562ade5e4c6c50801678915a9c364c1571cac5360a20d4451db3d45e9784a495ea69239a29c1bdcb20e50a089fb32cfad9196d2da3b80f8af5cb0f8aa2c9e979ad238051a883a81e3d693e681e64f81881a69240e769d41b83e9dd7b5b8a25aa5ea6fedf83c874c06eb3894f01ccb4d75d08f23439d705946882119e190f3b26432b3470f9f4396ac4a801d7c4570963a29be3ee342a5eb3e918955328bf7a224a858ca774891b4de106fd22cb821d08c66187e16a4761bdf5d147fd1bcad4becfcce89ac6d7ef94ba59030fbaa2d0f70581838f3ba092b2f1894e39f4e70f919085647a0bcd59461da3fa20d54f5c233a8defe871bed3aff3e5e0f153a433f2d676efd4a485ea941ab6090908649761e905a268a13741e935dd299e52ca773026556f682b05cad001aea0c34a338b2bb7e317bffeedb6a3539eef571c2149785bbaa46bef60a4de98835562a6d698d6b8c8898cb17862f7ee5f0a6953bdbe80cbf02d3ace328f1008eb8622ebe0fbcd8d3e2c26470e8a4cf9c4cf3bba3068cc0338723ceca5cb42266d0e96b9060b90ac3846eef6f635c84ed78dbda6f04754ffaf2b4104d452337071d2e03315b7bd39bf1c512afd1bc7a0ccf0a01dbfaefe2111e28511f64a8bd025102c3ce201c89e36e229d181994f6d2cfee02dcf69816e3389ccc471c04e12b467098c86bfbf5dccf477339d3ef4ab2065d5c32d4c556a38dae6673f5ef2d3c95256b9c5807e8acf7d8612ec62754ee2933a0c4dcf894f3ceac0890a4b73c3aa6584d2f01a906ea05fa646c2e8779d66e2709177beb3df506fa1eb76f518f60ab7198dc0d41b273d1791ad21bff9abfda9e3cf574747825828d20b083b6ff0cf5087c4c50e88bfdeefcf2183d429a86db53756a133a3e08ae2dbd26f771826cf66627370b20bdc47fe9a07d1615f123b62bfcabc2b5b643f20650fb69f2f10ddf74cd80ce672aa0fa59b9ec69fe6cc2197d6a47e0670f3a4b4a3ced2b7b0bdb0882670c0bfa48265a3743c33793f774b26e0bcfa73906f4346b79292f12dfb683b3c5a0447f66e4b279ca886f061d4ec7fa824578c0cec995c9a261fc3d3764f8e0fd5ab73755d8f63dec88ce3799c3dbc4b8271d41723441fb84bdfe7ae03551a0ca771323dc9d8b903732404abe5ee6e4e32067897231059d125efbdd43526e226491be07748ab00cee2dcbfb32455ffe2e35dd2486bd87ad8ec82e53ee9b33fcbecc95a825059ee0963774febbdd6e7abba55ed6f57ef17efb6167ca28fffb73a4dd2b34f4f1d2e1427c64f6adb4c17f48f123a5c7580a68aaffc59fbc80f0960ca5139e518bf03dc377e20e3e2dd598daa22597200146013e1d531dd660bea4f33cbc045ebd711ddf90c2ad94d96092e3cb9d267d4faab103b68a4cdca6752ada36f2385ea1d65f2b0c9a573ed72d39f9a28ba8030660c42b3f05f8c404c39ffac8b8b8bc425c46b539f2f5704daa38c53e202b19521e678fc0bcca49d3b6f9be2cb927b32d9a323a1f110f52183ee984a5cd3a8bbf8d08c3ae7bf8eed54bd936065a45d16a000fc2a2462c4819f1a9b7e6ecf7d4dbc489b3db3303ea265f4fab46f835313771832f3bfbfea441830a19b69722e319ac7d7c23cb28a3b40e189352ddfabb8539490081c22aea5075c25cac04953ee3d5eca1fffb05070d3324091938496224a08e38100e55714259c219cdef3bbd2e8c74957aaa17aca53a3155f2bd5c0e35aca0515583a6f99e44ea49ad6831a0e9a475587b3cb341b588ac2b69167251d36ffb13e7b7fe3c28706f15213626c034c1f0fd72d3d00ab177bcf3467654926abeace8a024bd895873bdf695ea63d4c758336ef0a38f2b5c3b9204f172ae43158219af12329317a3f90d2f0ce4c973d4a1a6cc3eebb2cef6ef219b51b78b406d5684f39f2dccfc485b2ecb5762b89cef37301652d4a4db51878952132e9f7b18eeb97458133e5f3d3858e9f21b64fcaca269a5ee1d424ee8d43a4efc81d14a2f55bcaa13671032ea6e0722595fb534ebefc995928b3748f80ea453548544442cff5c9e33b4d968f3f4d7ebf1b9dfd9cad58fb17047e4368da57ab27625eab9c5534dda610a405c9febbc505eee42e44a810e68e0319910e3e6a8c01a71804a15731bbb5e6ded044a43b0b645b222ac0e218c7bb456b434c64dd79b157c468f6374a6a8dbb264e92aecfef72aa8ae6c901788f77dd42669e01121a8fd687365148bfeb4e7a9c82298cf070c703f26b50d3035b47bc38b12c20b048a343daf3678b6805f966893257d47fad18a6682e9ecc08e74903bdfb8c9eef8f0b1d2d4acc4a4035ca5dbe1f83a84aca932df699ea84898176ac427d9086f4255fe6058295268968bff94dd9e86ca4f1795158d79cdec9188367b8af143daad2874fe5a73971fe45a5cf48301c74f0d279fb6bc19bf5a26c6269703265d180c097efbb068d1614f69d699f21af3e9f48aa2b6d69d7e489ac2bdd8e00f34ebf45c00189b972ce0306c29b377a4b1c1b846381d0deda254eb448f738f21514b5f1c34df4874dd7bf4cd35ae7880667b10daf1d068b5c1a052a05722349fe668d1edb217644f99ae8de40a848e03cf7330139544513fda2512bb92c866a50328b6169984919f6cb1f9513e7b595dcea059a355dd2891240ef5592aa1ce1f172b673b596d3ecb60a947fbca26b9a4fd83c254d08fb0eb19fc7de4f0e922d45da35d0fa667d0651f708bcf07e8a8a5fc47ed67e745e7a0c6a54de9439d0204de4eb0b754b571ccad5238e9280a55a0aa75de7618fa0e4974a7471e511edf31de337bf9c1c6127f8deb49610924ea255abc771946a1c6e577d4752c67f826e1101dcb9a9eafe4cd2f34a027b64d3e57ade8a0a6f67889c151c98aa6dd528f58404fc4fdb0e492abfdfd79a7e0dab656137f6123b7488d11d57fc7aee123d55db0f3c5bbc2122ad0aba232f1b24c8514ae595eb424eb283139d9f51e720a93a8277fff254a1f9562a75b15bafe8cc6f6e12d54f7c261c29fd84e0cd16266dcebc654baebd45a00cad63eacdf0be5a4fb3d1b140fff8e186f4087dbe7114d438a8346bcd8ed10759f46aeb7d65bf84fc7c0688cc680f805fc5e5f1fc0b529f00c94632f45c7620d8f1748a6e41c57821fc8d3c81c12d4e5adfe9c56703abfb5ca7f06b151984632cb10f1880d4a035807b04bda3be49f7fde870c9090d56a03e18e75007d1b0402d44b6400393440afc6cdf4bdaee1440c2be7103f5c7c7f0444efeb81f49c1c474250b08a9fa2dfb085023e09937d2db89ca29b49967ec8b94cef0d8f8efd1dfe834474bb53273f135989dfe16fa38347bb42b09b47c8015217f9c13b07690b0e019830332d14ed4e3274dea6e24a122313675c00e827407ed93090923836c40f16a4519bdd69a802f9ab1fa819f399940060c71ab89986df7a7e6ca8306e2681fa08fae6d6f4548c026d8984aed14ca145fd7fd7353842bec56e7095a343b47f5e6f9aa2f7b9823fb9d4896d4e3650a3c12f5cf9b50a9ac9ea4837e713bb4450abebd3c8331a58d1c9afb09b83ed3cac3919bda6238c192feba01317ad20431797d7b430a65cf406a423d67f4b0b10bae4fd25647d74e16068dafa27a1af838c5af1f1dac828ea86382247e433a208d10798d9df892c41b2ce14857642b49ee425d2231ae7139c87ca3877034f443bd9892db174f981cac7187d5c8deef9d2f6d327915ac2c89b866fad37ac6a7f1db3f5728b49ae52b03b4d1bc10e487e934b3944c193dd5cdc771903e950965633ad5b42ce1c842cdbc2fb298254308bd642e656467f4b23eb022208df3c62edd828de725f930074c8a7f7f608fd5959b5391ae0ff6e6be6ad5298d692322a235cee68d1cc99f176bfe10fb815c54035a362f68be2b4b0b7a58778ac23d3decebbf7507ca1b4f5445a720e7308a64990fa471a472c216a455d03b9d3490fda702bebe6afb82c2461438954ec23578987f7fd19a197269856462f11913bec7766234b8e142ba951d4a8708c98c4ff96971fe5a994b77a957f90dc9523fc3809112fef745998bb858cd84d66a55d0e5b7cd7771dc4f83ee69821915d8c73528b772b4d855cef7f31b3886512e7c7e04517fb40a31961c09daa67195d6e2561dda9e54f49c8059acb3d09ec151a11fcf5bea549537ec81b8ea523b0318401e9a097239f8d2eaa010a08c22f625da90497190d131dff91f05e1971ad0fda3e4d2c96db9f76929716939d1a267867d8d05ad3de109c0347785385b38b709d790203835f6ca35ef2a143dbebf17c5dcec6abba8b618db93ba1fd60cdb7cc05770c63f52be7522866333ba03227eb47c9be9ea453a7f263b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
