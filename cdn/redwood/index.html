<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"cfb89f5ce2938d9bb00cf5167dca217833a4861a3aaecd05d62de86758c6338abfc85cc9e57c58da7d9846fe1d31cc04f926f63f50985de91c9483aa6a1965c5ed50d8fb466b18a0b4cc6754076a1e87779761501abd2dc50b7d2887a1b819166710a0f0e921d1523347ace2dbe440d9e08c147e54402e290c4d8174ef427b500478df19cda953e577bc8b971f6f3f463438b4d760ed68a55472878f7bba390c31c9bc3320267d44ef49fede43b6decc1af2696617b51c6e903bc7023d0e500cc3fa1fba8e1597459168c6fba67eed310403a83e7bf3ddb07066f7d045b0e02b0346e1a6688a5b4f6f8df9b11300d8066f1ab96e6b03d96710e336ec4475048bac0e3283a9d380be9ae1660afd417b3c78f14b77040320f83f4f3ccd2fe900532a203a49175f6f93e968d20e19053e525034004b69c52194ae706b0e7fc3f0f7e12e26563e93a89719f85beb77b9db6aec8144e79ad157a5ff6f5fb540546eeb430d92c61b1bf634000eb5017622bd1288322588f4a8bbac4a722436d94bfc9c8abd78ccf8e062df6891561395fd76e2cca639f52895799ca752b7e565d35ef3befe72af90918d23ed2c6d5b4cc081b4a4f31072b56c341dd5ed907f9092c5e9a8f157181841eda8b29ce03250ec7840729c48893d855d6db7edc79d65c0149b8823270414180c7c822112ad67dc4d9efa1ce2f5d097f2d7b3eae5d6b20bd51bbc61ba821267d31a227a461a49f5bf011a33938985f34728557f91333c812db928d6a6d1cc9865a0dad00e3e95ca2f6932e005d1633234776580b6812d8510621685a12ac9d7e22dbdb8e8dcfd8d6bcde56b1e954e0d99d3b5c7f063765c9c182fc1d0192bd949b0fe74097e9254c8edfbc3972c2aaa89d28a1283f17e364dd0382ed7d12ee51b95e7e4d3dbb9bf962dcf85e1a882a3478b88bb14f30806ec3f1d7ad742143cf7be90f8a032d1ee09658f6111b241f518840b183c9deeddddea88f0ebdda9cb8233c13a915a9d9943f833fb55ecb59f9eee5216fca134e159ffc6a2fc9d9264927ce0fecd136f36b7a8ac09114b8845ed035fb74b7d47a2a267b59ec36c1777a598348c946394a1b421ec2d7a94040c8e8a0689798f203bc07ca118ff691a51057deba98bb3efc406220213da07552e98c8a35b41a4d9c4c7822b96e493b399f0aabfde6ced8c740fd5d56abce0da07eaa25fc4fb210651fab27f8559534d6cc2038556a88aaa6f8f053708caef8e56c63c34d83d2d31b11df364cc70a5ece0f09bd9e2a8317c2cc08860da02fa656b91397d6e01ef635756f41cdb9cc483b5199b1b305b37b1d44e28c4164217f20aa64a268ed357b56283f7f22584a60dc09e0de07adcdcadf53e304b87d564b187b10d4e2ebff211bea7a987949cc0b4fccad31c869101cbfd5b4ac47d07cd56492fd5a3792aa524f2a8c35a080d94ed4d221a3f4c83603b0421f8da560417c724bc343d09318e99104530fff315921adc68ffc7238beb4c724c7fa3a059c4a0a634eb18420668209940375ff531cec1d5a3cfd3d4ec944a332a1ae11a4723df1c958d2adceedda2b3250f3915e3cdbb6de352ef72910fb8f5d9fbea500ea074779e81c6ea474400f485eb900ba0a57a1b0c6eb9d8179957ad50b00711293b6f6a367d62f960e4bff0ece9defc4104cd59ef3049cca689a207d40945d7ad5fb8f4365f3d8b3db71453f2583421b838308eb8487753cec8849b9331c591ad3ed0109408e0fd24ff2593a13852e01ba8cea6c5f6efcc846e572513ed107919de36f6ea721ed39e48d77d2ae9ea70ac444ad3abbc0e3f44d70cd7d1e611906c4c4d39be21619792de815135ae5e2c740a4a39451d0a24e3eb9a5081dc3336e8b567a802e213d2b0dae04a4f9950be724f135848017a7b2fa8f4a153ab75546abe2af97b7c8335ea4dbbed8c23737cea406810e7e6fa15dfee53739fc523b258f63ba61885824a02aa7d07a9153e590fb3667b2be92e4ef007a747220a003f0374111330d8662dbfde5a6b2169b460519c35a8e12674f23446dc100d2c75bfcced9b8e05c7dc92893e9b00943809b1a15fa44da420690cb5dd3cef366ca72de90d9eee7f46a0dafa4c8d7163fcd870fb15ec43569c80b22a3549128c7f3045ffa12ab241dbce83e186fef3d86957abc22779f65146853aa412cfb7fe2189b8b7db4f6908f8fe0c3acaa953bfb437be6003398dea77dd21c3e12c85583d399ea01a82beb65f963acaa1f39ad18eae35b53e0fcf3f12cec4820e8852ab9a5f3a3f5e94353a4c8333a53eebffc7dbc2b26992a34b64d748cc1ebb546a31b32d710618afc056c82cdfa9684f651b21bfffb34fd90fb5334b02594073bd33f680b1c42beb9dd58cea677e2042e39f1ff7021787cf4d0ae9dfb34e3e35fd75d4dad4dfde3ff82ed9c830bf5e9f7f0d28d07fcb49bb60eba9732c141accb0a41dd37bf3b644d1f6beef663e085ddccbe41d1da6bf1c195193b3684c70b3fdd0e3724c12dfa9de1e13550a7bbdd9cb2b8eda7b414ee6fff9b33f9ee2d9858aa750c0e89304618f102027a7c33a4f4fc711356cf9ce9fcd149e1732a86946003e097f0815f9487315bc60dfb42d0196c1fb7d100b4c2264f0be3e74598a7b14a3ef4abb81d6ee315a6db815deec362d5be189bcc471890e25ce331f2b1789638f38d6d279343641b5f63b51f52ca2a9ce97c45f7e64da02fbafafabf0d158ddf90a0657a5ddc1229baaccc3fe632967e1b651f1bd7e4ffaadf6c85e391c0399a4d2eeb829786023f1d6103f788897cb0b99672ec28a903db1f86c2983a6d7f38876c8bc0cba0e2b70a6619ae063665ff6b0d75a48ff642476da47bed7eb2ffdabde7882312f4ae8d48789ee2e4aa88957a76579a9ad3b79c0958821bd642471a54090972e37a99ad8dfa4de48f1bb16d264e5be637678b4e47f187a50f95977f5dc66fbbbdc481b5b274313fa3d24f556dcf6142aebab0d362559cd2afac898503923680bb4294fc0554a3cababf474987d666ec8e3b40c0a38ce1c23e6ef114ebd137fb43e048fb3706b75e6ecbbc18f5c7d357a760a6b824ddd4f5e44a98eee90a7c9780f51f6e141a9b1d73431aac365994906ef22fe4a92ef391a96313b162ed6119348fb44377743465fee36848ca512532b3f007ab1dc3697886e4124934aae2c128d260b66bc34f302366e705673b441e6b1eedf253149464b8f2a6ecac6eaefb42832a738dcef08adfdec4d364f9e0e8dbd40187c981f5a0dac0522079ff6c7919e4756ffcf7638ebf7d96949b0006bb76188bbca8dc9752e4c0dca9e293845fa4cc0c1d4284c87b56a20a2be883c47149dea49aa9ac9e904fe406dad3a41f2561b739378b4d9fc8801d3488d54841bd8d943118d52315f5d518dbad4cc8028316438d4bb5700def82aae1e41e65b3fc63b843044ee352a8fc81747a54efe13fe5f0139ec3b9728ea06777ac2292e79b1e1beef3b9142d6cb616d501815374aaa5c4bd6d13d773055111a3738c3e3bd3d2b1288b9c15a047c0c1622e886461ef05a2a63cba295983be9f3f3beb4bb3c37dac57d701a619b960ad148abfd3bb26c6d37927a2ea9dc339733631f11570068921ac752116c2db59aa4ec45f1d2cf05bba1fe4a5263a59d6c9aa392051024a269a97e1cafa52aec6b22fd2fb413a50ec9d35fb486ce1a1960717546a6bef664e9835fb14e24d1c08ab9a9da5a48d15079f1a44664694cbb3aea308660859c77ba199ced536f3fd53594ce1b621570e927e15284a53edc31bdab90ea3e4ef14d85f8abd5fddd293d518072f8a8f79f1831767729669bc08a6a3e0fa4a04aab9194410b55b5a3ead267e060b063400cc5b3ff44d5c910cde9f10d2f498a9571e566b210d31a33e20ce5fd9d35c07f6ce3d4b34842c9c79d1d2ff9a6cb8073b71f479c53839a17ee8fde80eac1961670816cfdbc849393c79b5a166d6346ad7851d25fba0db069148b19ee4d360a7c53a66aa9eb058291af1a8afa1e72f5a7aba26a57aa7a0a16ac16427c27d83754a671696816ab3bc37ab21d64e41a585a5280cdb6b13c3d81d4c0fbf7fe228bbcad7524c541c7ae2a727a1f22bddde9b652fe8109ee61899c094e84ce2f329eddbc166ca047b127ac47ed40371886589c3e8159adf9e9d25d08434592ed275d1615114c057dc813378e9e8b25e245b114942f0c69fad53c32aa25febf837ee54d978a5ed66b021d2d39c67cbed2d255e198d813ffb3439be782e56d4ba4a6b98337861a66431c781a115542e732f2920dc453ff58e5a458109b4814cc66de8969599717f11919e04ebbe120b447688eb844c636826eb17effaa572619ed0d4f7c12a950bb0a1c2ef9fb092c942ec47d761205f2b1aea2157ab88bc380857757df28a250230fc0f3d27acad1670b4ba69a8e1df523599fcbd68feb1b844e739d50439c3c8d093bbc4f1c7022e0710ff44f30216385ea16c74ca68b8945b71bbcba44bb43703651b70e8634b32144b0e976f38a42c940c3e7974af6b4642cc2200f570d4d46ff73ace5d1c83e217e46483399c2a3931e78c98d5d43304a7214a01445f039df8f4173c0c04c016296f8d3b0346d36d0ec7217ffbbe8feb64545e057799a5dffeb55efcda57898575f74bd7ca1740165c663303e5e0a9e43a205fc08bc25c34e5303aac96018ca50506ff5c77b46359d24dc56fb67582d13462499b22d239e21f0d50d018a14c20c63391c8c4f849b889385e2b02a19ea0772b8adbe1283e5cf5e6577c0ee6d270d5fad3f56c5a779b4692e2998aea83e8cdc6a9a451154fae5eaed4a42540137fe2d952563d606b9a46072e951a56208e4f22203e507a90ff38b1cda28f2fe866032b2e1e04f44aba95619c3421451e356fb3569c6f97b58cfb9d60bb2cddad0d4e65272cf5f92b63fc0adc6b612267cc9227a28e750b38632586d8ccedf7c6a3319b41949431e929805373ca9c223f3a6752d1f1aeaa144c37e520504bdb0e8c019bb85209bf96bc2055c6d273dd317ed6d8cd49cdc4f7c72527642732668b34099d8dbd15028d85f2cd88edc26d3892408a18236cbee1e80e319ffcaa14c96b55d7e02c16b38fe60ce7daeab50ce6582f14c76b337540f471181be38e06f11d118e60fddc1a2ebfc2c270eb4af4e1cce4ef2ed3f2c1035cfa2f6468d4923ad880885693514d23cd08e9465c2790051202363ab729f5220f48f80abe182cd6c62fd14bf895c7a93f5c83c5c974ecc3ae92b311ad76d2b5a4fd7fa898b2cf254f9db14bd53765aba329af7ad3ae8c1087a505df02d945c3828586eaef47e7c5cfc1e08eef98ac9957a5273c923fdeea161b54d3bce6183a54496ec6844693143aefc30abe7f997cb5e17839f29332ba9182cf141c057ed2772cb39f3459fa3559919257ab5a9b8b7fc88ac1166292796e0dd137f7d48e7d90a359a7ad690e7b4562f0898dfae0c78a0398c62d6c8614bceb163f8a734075f2679adba51a4025d77ce87b18fc8a69b09f7a785ef80911c592c9b3ea8d5b548bdfb3be6c10b12b154962f9aa75e77ee6b6ac0af85e470c5c7dc5404faa79f801825f9ebd2dd955d490d45b3af79003345c5c7e82dfaab60888f893512e0375f224877bb259fdfa4a642b5bd4b97d5449253c8f2c330ab5ada0063b5506a0efa0a147f47c81f40905c390d6440657e1fa7deac199985894f4c3fdb6a31a18500a5b8a36fec08cfd8994e4d23b40bdb6b6ad4d7d681dd3f979d943bba00116d22e492055c3a2994ef38ecab3b0a0a34f624d6366be246c0c601fd7275d21d1a8bda80e3b1879a59c4f5d1713abfc10c6f0f86ad20a9a5eabc1d211e1f213316678fee76175f3115dcf382df5c287b084efbca962fa019636f95dd66786135bb502572a35275fbecb288edb545ac2b1553b84b84367571196b45722a9f48c47e9af98e82d450388dc0af06ee6b80326b6a40c82cb3ebda5f8ff11b9198ad19b1fbec132a6b9a991f66f86931622197051e5efc7b889ccb58bdb4c94d52207da3dd8276530881060aa8fda8d8adf7f99c0c456eefe7a03856dd3336ff2f11cdc3043ff2c0608ff73b301c2f682a8793601d5ecfc219756b7eab35409bcb1856eb3d36511c5f91314ebdd7e2e7032ebb25e4db7dcc85c99e48e06122c9ea3c1be112a9161316f4c6fec20d3ba898d80001e1906f1498e63fc8a0cb3553223beebf82556d0e0fd72ea2fcfe218195b5c3ef5da74f75620f3475c613d0d91cce296870c27608f2867dfb5e28f29a786a2c2c642c50e966c5d0238f10e81b6d3c7303a554102b6174ef811b6ecccbd9b7c289e6c9dbc10bde70e1eb885b5ef1cff7d8aaeae895c25e098185f44bf35a0878f26a22182d84faaff44176a93558d49d5864220bc9c21d8f94835b4f25fb0bf1dcad5d34062ae660188dd761200a4012a1d533b6fc6a6feef2832b4fe612a79298497d838e3d7d31bd09b71a64d0a4a21bf713a9bbf9a325b8fa1cac182363f03e715d7c3167e646747707f95e598bb127bc8685428c66ff78252f316378b4f652502df36e244c0dbac9ec45ce3ab53624df51836113c0cee2f510dfd5b197ac67473b0a0ab74ace6e2ec0f752ce42298fa5a07d1d57468dcfcde455cb7b0c017fa5b8374f5c99021d53196ba1b5efc62a33d8ecb5f69a9adebba787cce5bdd68b093241deb462928abdc5e5ad4c054f328c632b598485e2366bb344ab4df56a42b45a18de886f25f3d5006eed310a46cc0c2555b2a82e494b93d6db3a30bd46ed00bee57c8aff03bdbf5acec46cdd9bc4b74e222fd01123127c4be9b153eaf139240c4f051a394eea5dcf51bf1d621d3bc19f0b6d38f92f70f01d5b04cd30d1e1ff9b1e54acdd4bb75a3293d2fb94d642379fb9802e512df61cda5bb55368c644652c057272c6fd0c7428da5e2ba10ecd4a91c3c6dc92870f34698b07ba2080e34577d8e7da43c4e6a834e821bda234fb0a263f9d0c72f906c432831015e4abf14dc15dc1503302d6aac0168469f77c9feab3ba8b419ace840a19c4f5e708cc99abf9ac642dfad3bcba672fba38ffc6f8a82f5cb0a39a2e02f1a1bab65b0f0538df9187bff5b8efedd0f5312c25842abc5c461fbb19b81dafea9fe4f388bef76985b7a723d0231aea5a1906b78c1a0ca84167413fca4c5cf32664da15811c6539d64dd32d0285929909b0e1c6667f0df2463036d761d614b219616fc679c5825d072dd214e1871c7d4791c82d3b2bee1a72800d60f1b7197a61dbbf75e680397af63e53b8d5eab8d182cd929093be2177fcf52bb6bd481e4649dae69b76627c35a196635d9a38597419ffd9a7134f83d972e74e62b6ad29abe136947c52630116986bae9a7aa43422d9da599a1d138b8998cdd44707e893afe54f9fd808eebfd190fcb2c5cd90c744b689a6c909fab148c851629551fa081fc952cd411fda22d01df9044b543be9afe98379ed883f241fffe9af2cc9d76e6d4da4aa467f45f7d5d8681a02014e7923ac3922c76477d0588f614ea7966a5639967092e372f6e2c1c86cbcad407af440b0636ca4118fea697ed1365148bfb1cd3a3cd6deb83aaa11dafe3effee7eef699b5f42cacce4188aa98850d4cd5d1308dfc0c96e032a907b21d46c782de0f910d6e90be2b846c4d0814bfe426fdcb3c8c6822b712016605e00df04d0c4e64a2cafd84de3989aa90748d2af82b0f1ab2968848b8b79afb636c41b9e4d26087c60788c7a31fe4da623037b60902119199d1f5b57154c6649ec3f99a846da8749dc9043e3ded0ecd864efc2739b8eeb5210b1fd74e1f399666c92cd0ec06842d33e0c1ca0c42c9904e7b5a93f83a6d92aceeeb9b1b355e34003e04e513cceff39937bb19c31612a7129faef048a5609cb0b1440f7d5004c8938ae69d5b9e764b0753e00267b3f4cc5028d4b4e6766fb78418a19e0126f67d6d9c9d1ff0db960497aa3e5a645f63833450ca35202d5c942e3ef849d933b369e041b0f8efefc4644f0070751f7a5f21b9f98f5122275415e932f0723e256529631f3b800ca3e9e3003c718bf5e5783dc269d172c0c61ffd232448d3a432844ad2f378dd07e511d1fb27478668e107b0be955216496e1b9e97604cba99098ea4e3fb7a5eb8e38b7b4e3293703b2de44156d74a5ec10d5d73a6182c3ee05c135a419e11608488dae009da59288bf8acabf870f8e1efb294051b37d6b30c361584041715de437fc52de78bfa9d4e333f3f3d58e2b836f451e8eeb4f05c7190ed68fad2fc1d433f5172b45f264f0b3d47a7da555c883df49ea3dc6cd8a20a2a42f4156e5bab931d42bbf5343d7b420fc7878cd554ed20bec17f8970cb7dec78780d8d0e105a4892a0629659293b593e632acb4c7bedbbb3a422980c8a3e08b99fd7d9863adef84240669512fd2f470b0be1bdc186278ce207e61cb298fdc4a7ac56bc21fb3e930edc6ed259796b34190b1f10a7010674e92d9f1cc2004f1f66c0e9807556fa0f1d139c7f9005e84757d5eca103d7319fc7c4f106a0f00b47815747cbcb8da1ce690162b334117811cd626f372babb8df4920c918c1a6db50ad298dafce3e6a1c2f67290b6272d08b651bc25e1f9879e65d9814dc03308dc30f50bf2fcf884e162ecc6d6a1fd07548f90a81e995870832ece7ddfbcee27c05ff0e1ee52cb02259d8ec302870fcbb1af8bc2a5ad5168aec1c00c2fb88846a7af3d299867d2c623fd86ef5db0862c55feb44af6cec09e9c70dff7489300ff8e88d8148e1a0564a63f6c9459cfc0926ca1fa328914f2d0720373290d6b8c0bc7f2f4a1821cf9122a8193878564340efc247946c3d024856a2ab8e6edaed25d24249bb9e87f834cd34bd2f2e4566f4c14d45cc1e4b14734519fdd674dbdc44ebc331067ce3d98649bd9b2b536b0f49f34513c91282d867f6dd68228c5e5c5dd68fd3b58600492ab9e2b785375b966f9f4731223e0e22cca949ddd318728a63315faf939a2097a12f3d52ebeeb0ab529b1d17dbbec4befc51bff1d5255305da8637b470e21bfcf8d2b80b2d381b47b0582942016e956df8aeb448b6a3c336625e363d3a4cc1a61cac5e61dbdb5c5dfa999c1f3ce51bcbee9e4f2118de6ab36d1be26ca36b7747c8210dc7ba1b29dd4f912fdb1a3d244845e2df92faf5816813fc472b5e3bb9e0274100ac9d84550bbbb4e6672cbf2ca694145dbf96f00726714778bdb5b8465309acbd11b2428db76bda43f3a442b16220a8db7db33aa7cd44944df159febd2acb8dc747ac0a41382752a94dff665e4fe68240ddf591ab59f32183236e7d2427682d4fc0efc342f732217fb04380e3d5ec573e1f7b4a98f8554ee4e089dff9910da094fc00ecc91b949d96cf7c6ad74e15fd6e7937b7696c77bdc2878dbad94137839cf8951dcc883bfbef109217b073bdc84460cf7243ca82c245512c3788676957c48f729408407f9797eeefee3ffb8ce533c64341882c8246e1a1080040e2b02707d50b5f5c340b642003920bc7079fc9f1cb67c1a08b008c69feccdf623969b2c6e49e56bf0bd66201852953e8e2e59438641fb0e6528bb3bdd63de25d04dd866640ec985d4422a3573f77da37ad14640341dc313c2926e21b7e1c9bcee874eb082f4548cf9a2a685a6e4e5d020df6ccb88454162a85e0a4e63ce36ca847946514ab755d89655bb2c2ce4195489dc8d80fd7070dc81d026f3de104adfc82f62d0107a0f47823bc0d54138e945374ac371f47cc629d5a3df8405197dd36325a1e8fbdf81ae99d190605324eff644a1a7b91c114e663bcc188c91f516a64eba77ff9a35d0155183b4e78efa2995b1b7bebfd6e886d7e9c5adac01eac3079c90c47a8a8bb559e060a343e1ca39526314036cc77170f71c4fac2e58938ded97162d88fd7289e9acd1c108f95b9b8d10db0a5ca450b9bbb74be95ca2aa630e6c1a18b838d374060635b5f4a75c349fd163b813adcd60e8cec802d215acc43fe4a9793e1f5a3ca6ceb5e418cd08c578a8ebd782a3106ae0d843a81ed915d92580a118a03a39915abfe6235b8d3eed0d00f60ff4acd70efac98260de6aed3500edce7d0a3c01ed97df4309db686e6b0abaaa8539e7b2614d4c62ee76c72e3553509f19c73fb82db6802bc78ad75d17e33239d72d4b2027eea3d8911aa5b9c1a8f69b22acf96939b5b8e5e0a793cd56488d0b061fda4a51c016a3990f9bdf305112f401427d036480ec54bdfcc4f7847a3ccb53ccfe6b193630970b2986a3f14ae7dd52ccdc55689db877249bffd1bc2674c327ca915c48f0766cd9f8dcd3f70d6b0c66de0ea24d50efd97d21bdb14d328232fcf3e80efaffa215c2e249008bf6a1b7704584355b331b5ff172d8e8ab8fb78c789f252463006c0ade37f4016abc05cd2561be1806e65aa1eb21b31a9d7d4aae8d22b0cf2736792202a7c1eda69200749cb4b3b31ee44e2a509f4a4c09a1edeae427b5295b5430896b53158443f08797c9eebf4a7a62b0d0ae4575bc17bbe223d12998dba78e47a3d77da8e469c4be8d0f141e8306f78b5e3ebca226f896504e1ae0cba95888f0b4ca42dc1c7f199e6e368ad3603e56d99f3b30cfbd68ca5b658bb9783d54ac9d660303dd1be1bcf6c671d0cd6735f3413f784c5360206088e90eaae8ea007539def056fb0ece164fed10c10706ef87e52c7bd9864aaf725c10844b9894d565f762dc0f4bc3a3e39dfcd28811fffd7b3a12baa3b2c5e9f0c23e5152c02e4c8ae0fcb908b9cefd649d3027e68121c7fe6b743ce228b985e72a984b074716fb0581025cf85bf67a1c36de0d24abd285c73ee86aa6a8969fe4e9b7bbf1e857ce202204cb277cc5caf8b531ac6ed16c313b815b7432114442cbb53fe5aa9be5cb23047c926f888b0be490b835a7a14cdd2d3ebd157e72119fe37d0013d92401b139143324d3ed5c5dc256f0d484ac8106861a7eac750daf36bfe702080f2566900da301463930a49b84aa362be09429dfd7eeb83f552c292d63353d8a9cd2cc5f1aec630f3f4901936028ea207e245aef0dd01828092488e5776d00230325348c463f48cacd3cafcd8ebe984fcdf509afda5646db39aece2660a58f2b71fe38652a220839a80663368ef5ef0dc8669e350341299257c15aeb360e2ebb32f5a060fa48d33338fa31d192b4a34eaac3cf6d8574ad58d8a46abe5bddbfa82a8965283ab5dc3f72d9d25174f2a5e2e52061f47053f41d4fe8db479ef92130cbad0b089c949c644158de2bd96c08f4c709cae087a5c669bae21c26edd13f653222e7bb3f394a13f4972bfec8159c704854c49760cfcfff1d37178fe26861027b2f6c53855c394149665fa7a171e20426236e01c44904873e01071208e2a45757a2eaf1f80b4b778e00c08d0f2ed27aa3c5a1a4b56c1561ed046f860961405fa43f793421e2b14a34f2c519519b5f34057b04bfb18ffe120a856026d06b31de960c78e27e16f1fd5f75ba35e8eb27b8463c5bae26beb876d9560cf9f537501ad55da193137b0e07056e7cb98e61727a80cba13fb153f49e452d162c902edc430c833e67a3cbc969aa1284341c996c98ee8f30e476421718f186088cfe9058f88c5468458442a975095b482b0eec1ddd82e39fbdbed768c0fdb11759f178ec5d7acb09c95c4f0b5b0bca77d473a1b08d42d7521c7ea7176dfd2fd7e3caa063814a1536f47fefeb93915115438e7bde55b7b69bcff6e74cde89e4eb6d7466173900e651dbf003bc07808c8033c912cb725b31c4fa2c742b03cc2b119363342390d521e1c6518aaf7a6b964ff4e5d27a6759cb378b9237c2677b5af276818e2a0cfd4729b81902b4eaaa76edc5b834db4fec424ba2b747411453fcdf26adc05cd7e3bc23822c0e0a46fbb85b368fe9b9f43c0771bb8927b612c6fa194e6f4be1130df48bf91c6d207e254547d9fe24a085fcd5f206d955bc94861b3e52bacf91e02adabb9b09b24d5290f4c50b64cf636479c60bd369516cc98a5868efdc840bbfecdd063a83c93090eb694512dcfaedb100e81cc0586b52ad92c48e66bc547f5d5900beb2f9d678ba624df892a39cf54ff22b00d1a962ac46cf005487d19f244a8b2f77b345fde5eedd4371955178e2e105f2a4fd9b054398c9340267db5121fee9e072d7d4f80dc3dc6efe5305b3b921b6988e55c1e225681d4209ef523ecc956e0d59d327ed9815078966473e554124e37ccb6ad0d84ea4dcf88325716df7b387c61eca7971c6a7933868cb17801b3b938ac29c395e3e907a69acc521087048e5ec3289645af0cd5fe031fe075badb8421f079a576611fcbdcb4328004b846b74b00610cdc7deb8725eb8ce7b4ba67a3eacd1253a701d6f71f512c8b3e194fdd3924e42df580603cf16c5b2ce7ed06ac6c9d26017dbafcb54261dfd9854048ea717eb2a431ab2c28ce4850abff923a4d31f5eb6bc5052f80b43f97543cae732f8c77ebb36b05f060e293e5cd4951d8563d5b4b7e7412d296570c46299952be1ea7f99e59919c6fddf1622bef9ac483775159e8ca5dc2bbe7b7b3176f85a70d98a5467d885f1cd74054ab035054cef59723adcdac497e21242e0729e5bfb5614e60f6073c972782ddc387d8668205b20472d8ed3494e0e2a1b063ec74e27edfc26d5bfde8de7145a94dc17e7f1f3d0b338ee4d5f612a4fbd58318460d22d6d70df9178134995a09e94f27d729a6156dad45a5a3e465d22c14cef952c8869f12fa06093fad003553e6bc1e0cbf437fa57e63c69c10f0775e6169b3ff1d21b94eea39010b394cee05c16d3d65ea11159dba56ee6b4cdd58ba5fa31373accb1ff7f944f009cba6af6362525bed3e3e5be5db7625c1b6d7b940cc000aa22cd357c091cbdbcbac7d5a7f5f3ccd8c9c839b459e629d8803622312a98245bb3cdeccd949319b76afe3407bbe53530ffeacbe73a64225edef7132f6d07541508e822f55672662e0a4d39712f810bd9af427921023e59dcafebc2a097bc2a843142d3dabfa90583b431767ec9fa46f6b7e39cd59df644a9842f3932f9ec00a9f69895c64b140a63145d443dc473fc0848a4cc7569c232f215fd390ee5b0b68ee682f5e7143ff4872151d6b16c392f603ce88ef8164d51406e131d09c7bd038f44ff76ebab0252743530e8a0b731aa6720c4daf193d2fa529331ef5ff952c77975728e7c2345042a439a5c9b957ccae0fa4548ed3e2c0753f1a0defe4186a13d9d20a27f5874be6dda2724b8c674f2d3eeb48eadf8c6c125b2c7791afb5a9f8afbd5eb78c1ade6a0224b3485182a9fd212fe514641cd60c6f264bcf6d9004e1ab4afc4ca88b4347ce4f9c7cfeac8101baf05b4212efcdff534f99a236fe8284e7a7973ce4f0de81fdfbe04d57084dbd11626fc75123198cd61053e239ec33cb1de28a5391f7f097683a5978f9b9e2b72668a7c66e55607b8ae03d389427be103ac00aea322a709d10d279b26802cb67f439bda444d153ab9f12473e2643ad8da48848a1a1b1da649e651653298e45f1f174b2365172ebca9b4a2c4d3504244f03c98495274c6394d557137ad0ad750160f5d80a3a2bc922a3ecce913a1dbd2b3c28a21c49ca9510e7b2b908fa59a4dac7e83fe63f5a62eb3115cbd2dd104a75bcc924af68ee1f530828c431088bdbe1f3e3438a152226cb957db783580ca83cb4941d1c25f95c5889fa5f70c3c3c9b3e5853196fa2aed0f0602624a57860c7c627752e71cb0cf34800a57fee66fd4ad5e6b143f7678e7ed36fcff8f8a9e027eb2befc6dfc6d6ae6ad49432bf70cbac135803f49c3c8ee25380fb3d7d5039188fd9815900ea1d61d9f12ecd03bf47262b020ffeb6b86af6b78e5650162b0e5a248ea344ee27b592ab1eb4353f403fa937d9d12735c30e95b5610d6a422dd43c9bbac4bd18711fa1d79d03faa98a7659f53225470aa9d5b1045a856c6bf0c01fecd41248ab33370c8a21c1f8a129ef168bd19cece1ab106fe811e544c32998102c459f661e1235baf44084664cfe8428053a959ea2a03e55338ec10b9e41059b6c5571152c3aef986da1fe744907ab02c0018ccb9cb4868e2b39b6b2c84ee420539180303cdbbbce508b1429202a8fc745b43cefdec05de1a36cf8761d087d9349c84acf1ecca3e645cd6e5e898999d5877747d46e50cfa26993342376eed002aac716e4057af061f410b1d0e490fbcc226fd896a7892c465795c032d2f0cc80fadc4142ac44a1d159d63d1d553b8bb2935c6f7caf0a69e7431375ee07439f89e60686143afbba2dccc931e8da73d131d798715c0673850c51bed3f374082c15bfe1d4e5dc448412b1b3949ec58da138ba289eb201e0f30eccfa301bcbf4fd912f562ed0eb3fe161b53a36b4beffad624f51aa458f2d44c609135895c34f2c0b4d9f4afd185cfeafca409f8de1c3d0719d57653677de4eeb681cbde679c85b6a2a6bb252989cea5270debc3e11fd2b702faa6b0340f066af88a6ba7c3610d9be3e6ca1444a2b4150633f006bcbe5138744050ce1af666ce5b559c3dd7118b10df0ef59b83a7d9de617c3e2d0d3f6688bc7dd48097a75cd446191df5d7901e4116454a98d4a26a77cc93bc46f51971b2e0efb1ed6f05e809df4ad99a359b1704996c6456a002f33c65d7c5e856e1bb391edb6455e29582bb4187416aecaa968a38eb88ca93b58bc8602c536d7999bb37f006c1b366575d4a2cdc12572bf88e99b15b6c999dabf12efe7e5786cdab36ef62da8dba10a0df810325e907552d9f01b6d20342a2eae9fa4953e9bd82291bcc34a4c6326a27b2db2929b22fae013d3aacdebd38ab7b2390e8449c7c4fc8441ff11009052eb22a7a1f65f545cde7e3794a3549cf7d04c83e9a0b73fece4ae2868611a574406e8beb4b627deb703fbda9e5a19debe7b17b1f5b20f6e60604015edc3defdd9934ea156d25e86d543262e01e2aba7d24b3a84e385ac3c704c0a1a8b507a3873959dffee4f48647c3a411366c71a6bc4f3d9867653c3d90f3a6cf7b30c19d486bb2d3ac0423f77cc9b3ce82d5bb518cc3bcb2bf2ae9f27368f6290c6d20e5e2158a05bf44ea5731f8d4dd48cefba4706884c3a053aa03f30d3760b7d6ce6e463e24c2f27ec012b6f8937fc8651d353ac7e15cebeac84ba99d6af32666324b0590344595be7a53b2742b95f4f526952cecde2f99737b2728d32b6119abd6957862a1267f04654d3d52280c8e098e09e2071cb1c3e09abeb1c0e1d64fd2bf04ddc1915a09d8fd814a4d89e4706df4a5c864246c10bf4c73fde8a93e03edd7c0d8d877ff6c826533d97b765650177d9d8a138d4196a93afc64bc5a2b1089386257a56b6356dc400a3ad859c3cc4e367ce096af1e00330d0486d57b7d0dd73984b4239eebd669f045ebd3b940d430381db651467694604845f53e7fd86de85521700d1401e87aa01c3877d4e068426b91bfdc684d2b927e9bd926b8b83fe20839641f7a59b509bb28c65d7626440037077b5dc88add7d303dfde6379cff81742aab26832793320d462eb75c2ed4127d76c1f9f4b493bee9aeae1d8a7f02196930a64d137fe562a528097a1e7a05e32c37e2f3bcfd6eea07904b1077d891157835148b7243e288c231f90acdb85f761ca78bd625c7cf536614a8ec91fe38a4d8245835e1da7387268d3c21d6b11674efb744ce3aa8340aa905674a179c8194dd35cef4fe6a5c95ee305aeab9f11c7534cc89c7353831a1cdd9418d3c073434538f0a8b79e6a2b94f34e34fe68bea08f5bf21c9e35febd19a7d5709b683e4eabf7d045ef9e2c0c5d31faa090b9a345f0464a97bbb1433afb08013f32e44423d756a5a620ad35036ee6a0b19453508bc9547337dc2951e909fc3d33fdd895ec7a4b06745cae46b10607f9b18def69c1554e100ee22f6a6c7c160d47a71a024125c1c0f16eac90ac357f39738424f8277a080cf033235d67f636526d539d5f29fe13317ce37f27bd7d8575c91d45d075b024fe9c9273c62b9eaf3ea95b93cb6bf8c17212a75f68e8a7e7e3a75d90a69cb2c5c534255bc40663668ab5aae8d60f8bf21fc38ea6f93fd669f0f78362a7f9d1e6fd2253756b1c36bb0ed621e8845ef7ce65bdb70e7ab64c024e002b1787f463df3596df7bf1b7de94a0f25b290dfa29b4c0576291bd98fc04e269842d15ac26e52166186bf40372cda648c47c98663992aee7a8e3810d9bd9289318fc3152cff489cedda733122ce64ecced8f90f82a40aacb039e570506780863ec80fa029cb669bfd52af934791ec5446a752dfb05278563c45450b5de4b7e43df16effec5c757a4f7ca3278dfa1a182592cec551a531f85c50164323989bf02e0dd5500da313be1ab0c0decec08d777ec9ba79618a4d422d3f5fdc8fd205b6cf4a4f268692de7f2d52aa7dc105834309291178bde6f31947a1a4f220c17eac9b50e1dcc986db3ad5317b7d60675c39287f50770264a3e306c5efb736e34019a58494577727c55c9e86d3cae4f0b9b7786b9c38f45e265e44e45246f853659f007a4bf300f6255f0ea8b35f9c008cb3137bf105d7d00ca790efbc726e88b5e8de42c58c332d3807b77bf0f43d20e6bba3574bb4de65d1fdc48401c6fe244d4775f6d9ab2ace128d1dd921ac5bd28b1a39a17e6e5152c85ddbc4c6667d7b90503dc092573c9085b305d01b79e2246a7bca73fc74d631b126c372a401d5f6604629aa378546f194574b00d3cb5ac6bf2604d41fe04fac788c1ad5e5bf3cba6d43ac25d832304838163fde0183e8669c3b80c89f5f315b35b61dae8df2a76f530ab75780dfa0c08f41d934adffa81c7743fd6989c7d5c3b2324f4454de8679f3eca177b7595d89e8a2e9f2e3405461c965c7d03ca99e086e286624a10c10c22667f88efd0228706214d17e8bad1865cd006a5def4ee19ec2ea85b685f139df3216cff0b370edcf98f97f641e954cc2c5064738bf33ffaf7c0b4acfe1eae5e2ec2c67e7961d737657255bdf77cf19ccb5050ffa342450897a5ed0a05fd6e99bf2280e7cd3807bf70b9ab1d33278b54e80a96e239737038c64cb612a8b4bb3a7e4fe35d034b36589d174c8248fc56ab5dad0ea22b0038f27707539de29302a16adaf475e97252b9916dc5841aa49c3f532bdba316bffe87488583e2d5b74b062e0d5ba8b953c7c47b80e7104a70c7e837dca9c6cefec59b3b8cf316236dd991a8142b808f8a592505657b185bac33f129a598061084084b38091be7c26e163a688c3cc116f0dd2e5031db8a9cd2aa8591c4c4ac3912525d5b44756e3d0f7a514116336af824cadc0313807aa8126e09ec0e65822c9a01bfcf24373e8e2d5db45903e3e78c56329cd578972c4f41981b477ec63092f3c9f98da2536568aa6ccd80acc545e560619e8399afcb1bb141f34c92db4c2b0235024b6cc98ece7c16437f978d74aa900ce442d4aad16116c418a2a6daf95b1b6ea9f518e01f38f69669cf5e59934b4ac3c5df9e78559f60b0abeb7d3be1bc5c0775dcfaa700abb5414fcbd7134742505ab71fc15da87140e5b10ffb1a5c86728d8f184c92c0c173a74a54a57fa02e5012b7b88b36d163c699a558f23e034f71c1700043128ad93d15687cfc87dcc2ec6bac3dbdc46f40f9bd36271f000ca2e363d40bdd177d19f8c20ab609c0da14fcbe5846292152dd7ad58d73c95c8f98a9679f6843a8cc5c1390525f46e7e712abb082bcd64d37e81d144213e45444217bacbe1e949296ddcb55fe5438bf2c897c971bc61552b50a77da6274b6e39b724dfa405d1f4e22a1eb37053afa1d638f2a36b9318acd432814dfe05215e515026ca9f5e9f02e30ca8b0c017565075af22352ddfaf3b81510a3c9acf3e0a9f341bf8945bc596b221e2c87192c3e4947f0943fe3ec99253b27c2a4c07692c4b3983a15d5e7ad4dc3dcd804b96e2a0754db843e923e61472695ea98aa71b1f0cff3b3f1657cb105bb7c6b413b5d616360d8e7442b89a6a978aa4801c95ba664b17d1f0cff","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
