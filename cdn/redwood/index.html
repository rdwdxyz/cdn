<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d52dc0c9032838200677684caae47545741c5881972bc69a25b88e61a914d5f9c274a36926fd1ade249af02d353193646898cbe991247deb268282f7a2e916a700310cf4957d2849ce02552676b66b841d01fa692caddc739a6acdee1825e8588df915d23aae3deda43eb18541b0b83c06d08ce8a8bf783cfa57fa32d8c1093a09d88ef09cc30a239a56b9cfefd2cb74346ebe794784b8a018f290f8859616b88e550c74edc2a19b76202e590d994b8a2b8e4acc4810f3004c2374c894b5ff7e96402de593a043b6fea70e91a493f015e617ab806cfd5aa4a2e07e59436b96559574661c370e299e9ee2fbab7472c46a5141119aabed3bddc3ee8c0c004d0adc8f70f6148c7807732035f27911b83219505778ed6581ed218a8d6a5a9d2790cabbe329bed6b3be7e968dce12229ec41cea6177a63346fa8a21ecab39a0b15febf59bd44ddbc7f8ce6f8dff5ee9b7da24ae3bc7a4636ac2e0f0d7ba69e6dbc0c9642c8888df499ac0388083629b2fabefe2da9987b1b883adf7205b536605b13bdf37f1226aaa3de03ecff10f4d4318174ad37cdc1704a2556fd9b74b2db04d07eb51e24bc23c2e9b4b67f4eafe6e3a3970938f33db9e3321f694b5431bd096ec3e1eb1e74ced6ce7c44b14248329f99303f67071a7a704440a5eded85fac5f3b6dc50092b8be65cee3bd096ceb061a237e80585189e7b9eb42bbcfef4471243f9d0d3e48bdfeaa2b4ad8d247a75cca9bab424f2ba4b311eae574b4224f5c801ae6a7fd5b0e871b004b2981aecbdfc7e4123c627501e548fd326deb8f787f9d3c675555c0ab127f52e586050bc2d8669e313ee742d787bf634d6c68c4dbb0c2e0ed887033a2fccb66beaa26a73f821ac98191ef9d96632ed056e1d0f1ae6063119beace5a883bf272a96dbbe861873a7c0661fcba650e85a5e46ac5610dc7c785df7445c90e4290b563ecb798a1697db1cd3c812f44660af05d7c9887b949f599a5b072283faaf9028b0110ed0fbf48ea155878519b2832f5bd22089ca749fece234ed57446d95b5ba8ffcccd8ec7b2ebe8311d6f051ec0510661bbc52dd30680a3479c10290c8bf69096a003450df3caac6fb8b1b46858139f6ea4349ed5af21ad8c9d17a33f4527691b850592c995ae93efcd392451c8d12a32a425026f516bafece9160a19de61292718f9e93b6aabf3fdee1cb3bb80f508a154dba39583e56a16c4d0298066edd4a63bd5dfb3c417c514ccb921d6fc67cee065e8398f76bf2f928eb8a8a8a9a9036376881dfd51a81eb4dc241d0147dcef2db61d5aa5c165a05f4418ef359b75357b9d1f8005d0e5b583a3f90c95e30aacaa99cbbb6c0b575f688a9d2f7bd1eebbb5c33d9e0c1ee2523db2e0c71a9574eb06eb4b8e98bd779ae0676bf2f13f45556f486d72478bb475318e2ac1eb17aa2df49cca9f74aa2f1cd1699a125478bc0ff2599cd8ef18b0fc51d6603a9b8d47e00e4db9b49a1ccf52854de983c82904794af477d696a26a81dab5964680af359352b83c1f707efbe06d4d2dc9e90fd3ad0c46051dbc0e6de1a581bbdd948bb2b432fdd96908abbf2d6627199e001965baec8f0fb123c9fc89d8a574a31e135d6d394e72928be23f1428b85370ec219da03a58d456b96a08edfcfc08f632db52f4f4dc99a86dcf7ab02d7b7671e16ce32857082cbdda4b7adc4d854b73fab008107eaa13cd8577972da286476830bf93e3e4020a7652123bb3e0ecd6832a8f33972f9c7696ad74474e5098c39bc4699a445d21114dd13ac4b509cd6318fc9ca7b596d2daf0943639876b22f5b1b2fd96f502df3cfa3e3f82b780703c78ad2503e304dc817d06b85f02740fea51b0663569f73e78ef559ea02fbf9afd8517ddee46eb19544c1cd00cb508a58bbdb1fcce9a5780c96b067a0efa33b5bb860b30aa9182405f060155fa664bb494cefff2cb796188d23c520d4c9512e5fddba59888d2e63601d956f0fd8eb183beebae3853294dee779e0e80616d9d2a98982d51943727c7facd62d58e6b2fddcdf3b8b0d87c5cc1facdf5764bb0da14c9a916ff2e33e1499794abba3cc0a27771d7bbad707bc248cdf20b822bac75f0d71ec86aebfe7e508fa5f671b3666b16dc2702f6ea409412d97877ec41145f5f25a7b2a7f174ea43a2c818f1db63c1de9bb79b70e3c8eadf39ab689a99eaaddeb217099e891b08e953c317180a7c1410fff0e59b7b24be7801f80fdd8341f19838540502095b3e7b259ffe95b4946e70d5986ad8c420953f288a516870e5312f6e1094d269f6a2d8d69b67038f5bb8564883efbdc58b7d8706b698d2cc57f5701e8bb09c5da074120d228b3bc08a9391824817d3c038594fd84c493dc55fa7710c2f30db4658b05fc9f17d10ef72f50305021f48f726267c34ab6c6385c6ffb2a5521b8e7d4b271a8e06950290f9fa2e4fee5cf4cc4b3716702713a887cc5d5469e457df4505ec2330a5eab05adf4c91d922d70c29e34b1f146a4bd21f2e8eaac4441c2c185c23aed59ab03cf775f5a2183f803ce2122f4586971b8d372fc3f222f9c1e9464139426d1d2c235fe413ccaf66afa8c45b7218940a56d2fa6395d3332d7d3fa20f26599f6c55b51a0f77456fe2b2459d8af55a1c8854662b8ef7b21353febd26c3642509773129e8187314520522bb240108d2c3787161ae8e686430852619c9459ffbb2f418cdfb9dd8a94a2742c5ec7777ce0ec54c474031b0a32ba0a19b95e130c9245d474113edce1a337259efe8e1a205526c8953d2a1d051db041de2c0f2e5494ac8f329111c4694016bc9a3b3654aed3f5c93f36589a4ad0b84f6789ba4073756328d617f4c0cb7ce56ad35a33a92ae3b3a7b1fb7d5faa94f33eea1065c211c4d75d9683451357a6949de0bc2c1edbed1118e4618735e4796d96a03e7bb7c807092027ccc81ee494e670f0b1dfb65c15e6d8939a63f919c277764e067d6b3faa30c88234e0c7ece55a8bb76657dc6db61186e0e4fb7bb389f119f7d570d862b0b85e7424e8178cfc5e7a44550f4f2731da3321e9ba1402daa7f3c7aac291be20909468af4ef46569318fd5d4974e99e7fd7247d63e318374cf70aab1cbc0eaf1847c6cc63349dba63b396cbf78bfe6af365bd35cff8cd5c15e4377e0b74243d7151dadd5bcc6732b69f96109345fde7f0a6044b54bfaa2e5d7acd1ca88b8e5da541edd4a28f17dc3dd42ec7687e48edfff261feb1918d6a5037c0c64d54370ac5284b7b318215b7cf475884b928450535e75115174f841cea5088ad384fc3a457db78f4a9c11938ef2bd4fe5319f90e1e7e1b9134a75ad84e46f2e373ca3051af86c36cf3b04f6dfc07adafc822e7350fb096993894cd41ed36eba3d290036704615f7a106b3c6635c095c9f57cb7d9b8a23b45a420aa3b6a05160693773c0dedbfa3b442feeaa7760b176932e2e1fd15fe78dec2873fa5de8410ad0743e344fb06ac88c6cbce33117bd18e9070fdb58b225161a447a6eadfd2fded4df66e9ace2cf06dedf34bbac00492ec368d5804a8a751eaa446597892d31a51b56c82d36e11f0854e83e61c945535bc0d498bd558cb4239693ecaa490e37d412e9242dd39d7f9bbb2c766a37e6c4b3a2d1e7056f9ee8ee37ae7463b405968168327ddf3dd722bbe3f59c0b7f934d867b9c6b9c845c0131a12a45a23c19b114b1676a2c1b2076ae9ca0b7e6db1335fb7fd1464163d478ab17a1a88dddd99e3e72ed6e1fbe49251b20b5e136bb72a7f8d88fe6018d3eafea3984a57984106262e5a3eb5351353f5ea230d76d330b47108360a8495d9ede95df9c69bf99352103866056a10a3296e1d910054dd3e9f58a475949c12b686c353be75e31d49260165121468fd8d7b34c4c74da25c39863a20e07cb3e2d2edfc3001d41a7d76aaae45340256ec4261bc511692f4e7f71ee44c7f072f89aa5df54e8e2f24c0de81370753b16fe72f8693b46d2790522af759c50ff4f2e1bd6a214041fa6b5c979ec11b9bf609996638327419fa4178dadba3a905befff4c33eed549bf03649f109f9ebe7ff239aae0920b17ce76ad95ac3a77733743d1680bc487db7564d20a47404268703727b2a200bd9237af30c1dc3e2097b9f29879462143fc59cf06c04846b0bb414a8d7467878df3e589a7a4bed11c93761aa184fecd3d46e719a35979b469ed8cb964bed1bc257bb98c64ea3149fc1f191ab2cdfc8513a2945b11b5003171d92b7bc0d79437ea02373eb37b528a53886fc8d8f9d770339587b0db4800bff6b00071ef252a4261d4e8a235828a6f60ec7c6cff64a3fabdc2bec03aec4d1af69230a70270c1acde5e9f69b4767c22f2bb8a500002598ccb2c1e78179b96ede0df94cc279288528de4f485cf8f0a1175a2df9de3c711495fcf1e787a9e74b29170774c0f66fe2bf369a50a4945d07d145b716c8cd644b6f71867d35a04d4539598a9122e86a26e0df649c7b7aaf461119e76b8bcff6515a6a9367814b52139cc351f6b2252100836860af05e988a729a23fc75c3b1d0301c8795e6091baf0c0575272286c52457cb252bf6e152a25813b62e79a204835de551671b3180438856f68e6b25d4056a5d06680de73f89e3f8839448893955c319fec3d312807d1fe60db78e6f6000b899ba6e55c694dbb8bd04bb9850dfff0311f1d986ae2d1b4f6d496c2c07caeb62a16daa48ee04dde9ed9aec70a85266a43c3ddfefdbcfe54be0991e03834815c6e04e631bf59e9d0ca354b1c93e7a54a8df976654d6c44aad9aca7434595a95df9521f078ebe788233a3bc7ae0163ecb41810ea09d214881d43bc858f6add16fd0d15be0548c85438adbd5ddbb7339f682fb966862e206b39b16696faefa7a4b1bf90203404a01bbd73d530194def5674cdb1c048a2f02029fd1f667ca07f458b081683d15acdccd521d3d38233ebc8bef23069ef93ee3a60173d4e3cc9a3bf42381b8e2b93c685482053f4208370c911e1da7cd2a20eb9b6fd412b53072c042b62260c0b6c456bea1f3545ef1ebd6309ff3fe19dd80b48734f25b1d8b3aca3a725b95c6b7f1458d53b5326c62293b3a8cf824944d962343c4d21ffaec7764c623476a61f9771a8c7b18ef3f54a7b82f1f3410d20f6ac1f12ab751ca9d2aa59098572829213cdf0deb3830d8008c886784d7875b7d0e798fec76c2c22ed8292ddc54531a1825c8a5656c3bbe6610e8d065507a8c565ca881c7d25f99b4459ae59abe665c2c8cbaa09f70ef42817980ee4e996bde04e7e1c7550097c9daff452b9710a7a98c26f60d3ca0b41d19dfac33c7b0345c3a1d6f8746f59652e375f45ada47ddad41323fa8e1b48424848cfaf962262c1c8ff63115e882e3f0289bf0250f0c0f7b10a0f2cb893a8b2cefec5d53e923577acdafff496508646457a2ca328236b99ca6ffe48dfdba2e496daf427ce8445d492690bfd3336de5bd6af65ed094f8494d61155d3a9b9205e4d9cd4808a0b50d9517b03c367ee8736c77874e315220a567868158ffd2b1b9c34283fedbae1edc2ecc35e3593478464bf8c884a9e35e4b82b30a3a82e1fca7f1936772929d728dafa76d03bedcb2ed927892797c6885b4f2114d9434f282ba4db2e54fdd7cd06f8677236d618e219cb67fc68587fb1348cf7766b4cf5c7d56affe2c360137daf75e7711889da9d08fbe56d9f8a414e39dd0337d80b1c0f2f53fc8b2e832984a81fe3851eba23527d770c2852bbe04ca9347a18387af9fee688e7eb3063fe483e0c4c708a16d5b3def277882d880870e68d31a18a8c4ada6eaa5bafedf245a54384d7a221194d592b49d95b5289484ac9f0a4173263e7ed56b5dc34530e6144258c8f424996a7d8a035cd4c06cb018485ea803ede45e615f1b78918878060109d1d552845e67a997d4b2b24435e3ac18a152fc11eaacf3882ca846af0355a43488dced58b7759ac68c6998b51a810006da19a30733697d9fe3100303b44a70764ece2e473dd3a98d3364574c0cb1f8772d51d6e99599d67f5980b66b7e0fa200a615b1ebbe71cf3ead9fadd6c25d48a5488e09ae13999c6053325eea3688360cdc91b8de8f3b3f34802e2938af1f7dd07dedf603690484e4521b7fbd034d5da013ab8b7c0eb22ab5ecad8e94e5ccbc46772c84323ff13dd95aa4e528aa868a06e9800e4f8addeda3971a723cbb6229f07c64fb314bcb645b4ba0425d8140ff34eccb839e0dca66ddfc83226f095b9c845b2a908cf84f4fccb19c355740bdbd1cefc6fae4c9fa0fc1941eec11db489cccbf22ebc28e90788ce9ee2dda06379125b65d2712b91071e9366188370e1ea4c69e75378692c60a20e0b1ab56a312ec8c1b246fdb55580694f3adfd41d97b87f8a2143aee06a8ae2fd3e624177927e23d5326d24cd49fd6c646b4475ae5557bcf3770124657cf2b079929abd1bf19c636c35249163f7a5057d0370d84ed9d543d201bca7122a084b359dfe41c326fe5fa22d1eacfc1bd7e7ca20ce792845ea9e3344ea61c5b1a3efd36f243e087cf49cf1046e8cf8998748af117bdfcb128c618b8db56cb0d55655eb24ab030309f1f68b921e706ababb7cce2e22d03d5bff9e5363a7a495b00a6f6f4a935bc9dc75de9dbb684ce423f5f1ebdb1ddd7dab71ece095611e234fc5823137caee1dee87ed11512fa2fc98db6ff7ab3ba5c4f5a1159630ee2fd62faa40ed4b6f1534cb3ae6a2648201f16ef3c724c5e2fc372217d72bf45c1d15eccf85e65a7d097f2b4f2c0dcccc35af704f5eb0e4cf3afd50afce1ca6c9775195111382035a8a230ca3f7eddc0886804fe6ffa92d23f542856b7e1be4f2bcc2dcda68c56577118c385885273d0483379363a0ab80d17ffbb5526057d37324d1f91a66f4f859a37bfc71212aad04cb0852f4938bad012618b5724289b4106869fbc05c429d2704672fba00aea18d72ed2b2c6d3f10815b77b5bf387481940f6acc9074aeb1c0d1079f78ea5d75eb145dbd43c8cec5a630e59b74d5f2a5dcc24f350d2f4fb88eba884eb867335cd4d22103df57ed44068c48998c856ba23b3c51ae824e3dc011786361fea0b54c6259a355b647b19eac29b56e265ec2a4ca7ceaa1ba5cc8b37c18f83c1591c8a9a369a383280b5793209add43cfa6a2ef02efb508fc7d8e9ebd178c46a58d0e5634bd1192ea63b6f90e59722692bac567f9f9bcc83d89addcb94036f2bbf20c8c069e0e10c0274f876db692a7d89524d303339a6a3b867825628584892968bc4207e6ae8102b0c087504e125fda6a3ec57fed28ce26faa4246a62cc807a8a7360e145d102b0d0f440e1d5315009760a7ef33b6cdb96462069fed601939dc99f1a574bb9e3878fd391e7eed37156576ca16f6461959faaf47eb85630b620048b244eb606ce106fa45f931dced4fe0837963d47b341a40e3af58d69aabd24e7910d0c59da8745667522f44480bf18a4ca4faea645d1945841405c9ab623ccf284bc539f7dc65b3c9161cd5cd1f56b1a3b33125b6eb7d8b08be4dcce05fc0f3b27950a64296489b58c1859e348e1a3ac5016d105791cca738db6e06a7321bc97b572f587f068c947b379093712b3fbccac2318d027da4215bc1eaeb71a2a707adfb055daacb3ae1941f7586986f4cfa99818919e6a7415d349e41f231d8e7d5fd707b5b70e94fca5ce527251bee885297012d1238a9baf2395be95f9dd862b102e31a76d8dca8f4cf81b3781a23e03eeccf3d4414217b510475908d22514a776bfd0cabcc340504a70bcb661db75465ff0004ba97e007b279ed99cd60046145483c6b0d3a138fb5eb9e5c59252d6f4ec032e4e1f50206e151c3ebce88e36be0aa4ce514f3fa42ea5d4dd1b49a5970bbd2455b1f19c938ade40591b21ca206bfc7b7557b13a6c0ba6c90c15ed7656df9248d16900221ea5ed1d24f05f1e5f953795693d9e3aef47b1f46eaebacae95bbe1018048151a14aeebaf13bcbded15ee919c0c91939e510ef92cb194dc2678e3dc77b393946f7b1f4e3fccfbf28047eeb6e6f14590b892d51bf379a4d26a9044271111c8ada541ea4e794d22725f1c2402a798b6ea043993d5e67bbb368fcc6a46ea16b6a4cd5fd929c9a6e50985aa369552095b42fa517a26426982365bfab7c00054b499d8909c311781a0ad1b6b8815aaeb9a2622922c5cdfa285c7f3abe9c450985d053b3e72607063c2f53a98333ce42213ead6f13c29d29effdf0be3b61131bdabfecc36b9aaf2097723511b34dd3400763888be86716d441dc61c45a6aa10eb48776dbac163f96f1f92cdcb25a67e3063d888e963870e64c3d2102b38e3575d5c6a64dd161d8206dbe5b9aa23d9c7ea305edf4f428c80856a220813ca37f7db22075ca8130d79fad067e63dbbafd68d94a941fb0b331724185dd5c83832ab61b1bdcc848b2d411b26357c81b1d6091c531bf6b595be94191aad5d5aca68815ac46b7a08f31163e6ea1968ce861fb53b8b3da7b9470c63efd484d325a810555c6a72bc6c689ed2561852d0c0dd0f3381930914c47fe2bea089b7677711bb8e46e3068388d8c7f25c743266d96975351ef7030c118183941ba0a11b8c5e3212c999354ce9a45ce1b11fb98f2bcf7c5cca1b7abb0e433abbd2fe6dd70e90a6d6191ea8e69066fdb0b04ce4147ccd3b02e6f9e159b7693ad2531eb903ac9f6d444c898e298073d001594c2154027bda62d768d8c008a81f293cff8d7a670f9a75ddac81705f74b5940bb99a7627d71aa7c8e71b4583b06c2beb4db93248be16015266d327a8684a062aba1b8fb02800af0fac284ced5b30ce743c532e6262c36438aa1136bbd1f811aa4bc3ae5371730619f972bf0b038246138713030941a5bcecd3870ac36a2a88d6ffddf8e7cfd07cff19a2c9204dde482054a2fc3417f860b17e2e7afedeb05e1becf323746cc37044fe75b13287be9acebe006e92ca67d42adb5ca45495bfd96831c202df3869494979bc53d50a107620c6824a7bcdbbb19e70fc5a31c0010f7100f0d8169c1b564f453aa2f96821b5f18ff4b39cddcc208300fc19fdbaf2d6c71e51b08f2271cb8391e700ed5948bc54558e0858809966d2899b4b22487baff418824edf48a3f2c751d2482414f48d729da4a19b2f77c69321524b05d6eead3edd5ea79cc954798a3802246ddc7eca1029ec774579fd0e45a7f3973cd1b3c0af44b2a606ad9c37afa6d15d5f534779465845a6726360990cc28e5bc68f270fd780c2be8eed7828fa6b208b9124a4509b99025e5cd96c6a847ac10964b0d39b5d6f18cb2f6470953a2c13548e70ec5572b728d9381702dfa77b8738df7f3661f1aada0db90a75ffd9d6817636bcdf62913a27574a1170d2d5c7fb2261b767b05afde072b6ec1574f53b6e4dcd73a950052552d05933a495acbe17c15ce81c82ebd42aeca66713847d328e2f84293f04bbee722c25db51c0b85cfd2b7000820e344048ebc9f079933bdb0bc939669dd7ed6f5e360fca5d51efb333a5ee5d429dcb42f4ec3c78ed75bf6069b355b1ebf165833c0ff66553bf426ad148d9d44b2966d569605e2481f1ab1d6f0434b7248d62b908efd0bd826cfd499f273a35ae723516b62dc6dbf143e3b0c6c4e11104cc85507fa7be4d55134b83ea7b15452bda43565a05830ede0f179d139edc3f87dd306c8e6f0998a4a79c53c0b4ceae0908b1d5226de6144ffa42b4211dc34a4ad812b1f7d35b6ac078dbabe93710fe285ce3a192aa2283a25c10c8e99de07b6fa8267dba88027f18581006f069cb80d300eeb2134ccb3eb9d313eb6323507b50831c1ec202285e3300b87ae186b3849aa3bf0eed20938e41efcfb677221e41b82ed34b1bdfb4fa3024cbfa15b1a7d013b9f7565dd0c2dd66f525fc3dfc13158099cc3581dae1a6e18ef7dce1ccbe1702523b357048819bfb0d2075a6d2332d2310c395a39b88f120218975b44d7d9f186b274c84e6b616d714eb012612a7a1e50298e2648e54d2286be607be97351a8a516bed897b349e557a6563b0eff59d302940c6479a7bd687f1ff38ec90cf982478f171f6a8e76f1a3cb34d21c3fa31d47b705d93a46b193b08363496a36d99612b3ee46780ed3936c141990f80ca715d71727534f73269902c556f2ebaaddb922ae12c37d108ff4a403458d7ef9b16d20d31b6cb4f31ff77f515a72a4afb4d3453153571f8ca6a72bf3f532d5ee2be5356e78688918029647408f169f485f52b87184ef499088a7b857e7a5ee64d2902da448adee727a45ac0b9ea8781e5f00fb8e56fe175d45d83a47e6d965ef1f79e2bad474c7ece9e255942f4e75d17a76e206cb65abfab6d1b5eab2936c8a1c6c1c1e0ee4500b82c4916820b322912412055d821c67ee4cc6ac6a8416a0e0ce61b8b7aa135b2c7005e04b8f8dd75f6a01fa85d14a874a7a8ec8db81ffb2684d3bdb1d022bd678d059de3dd40e474f0a8fae4d672ddd676b68bc42bf35cb4a9221d08bfb2d3596ce88534724081948319eea616db3d46fb0166694600023e1a74d64d8c8b5b6111a3200aae4544bd149148ea9be94e9d7fc846a72984a1137cd2250b1b8bc40e87040f124fddfb47f80f38ff7afae96f3b9d4650f2c8d28fb6af87275d8eda552f25f2863d7b5e5ed217953508675e447ea045d2bd986f9ee64e88801d8a4ad6336bbab1ef0b7dc2101dfc58018575ab8132a1b06777df5b76239aecd5c48aa27455ffdd3589087abda3b77f83d85b9456343425248556654e29ba9c1e0cdc593f4a393e2e82ad5b0351f3e4a57564b126db4e7b9767c92374117a84cca47dbf090f64444604244b2ebab3d2d5375f7aacf610ffcf9c837c9e2a9585e0f18220a31614b39eef5c5fa1482f614ae33906f8f1f60733e6114661a28816799698211d3d9da373f89132dd5efcae459ef3e0082cdbeba32032f8eca4fd28d5569555f4096c19f5abb2f92421984ee22c24572932ce72524634bb79ea0ea8d56a8b8584009ad563267bd99a7148936bd4ef72d9b3620be639a96e594e1336524dd8aa665629029563d68cee6a8dd98fc60e2174af97035423ecc2451c8f932584ce70a3aecec31adecb3c55b514457e0838ea772622596a43f3c9a108248de4f934dcd0f56331d5435226b56113b17452436919882d18597419cab58257cce1f8d57ecd3a74a8fbfe3b590b28228aac26c27cbf4f4eca7ad6110038fe593b80b4461141ab364f6d1fdb4134095aa9d0c742a7b9bb0aa5a8f1c5d9debb77586c97a4f9be2cfae8f9207ff05d662868c2a30db8d9b38cc196c78e0f7b9a719c58f33fe72e3f48b17b92defe5abd740f95c9cdbc8ec6134bc539a334622c191b7049b29d81aa109df27f9c64f2c1b09fc257e85d8f24642ea36e19f8a23fa2a1497af1cfdc373c8160021cc368d93f24e601b19591df4d26f00196a139cd4bf7e756f64a4f93f83f629914334d8ce9d239ec8725bae2848921b1ae3d113ca869e9124db85f81d50c7dd85c0bc07fc934b4b7b9ae6c0f6076bbe1c85a64f09123fbf5b8f49f5f1ff09083aadae1c8fb62cee2019671adbf4218789f71e7e94e83092498f4e9f70523027d4d019646dfd0e14680280eb2fb0f17d41f15e589a267e4089eda230d3ed1c6fa65abda2d45a4733ec4bbcc9ffc9d42125b294257545c921472333f78f39e10deb4e87e8ac4f8e2948188a1d3c28e4e49d0274a8823ec468f0de86fbc36bafbfe66a0286b1b95dcaaa60c083ec28b4c739691b6efd38faa78b7548601cd45e15b273604098ad6d75e98d8b28dffb657a5c45e5050b2291d90b9fe5c2038f7b09bf8d084fbb4bbe9ea4c462a544b43c85491e0c539b594db4fe03de5839a0dc188efbbd964a4377a533cc5041f7c7d7153ca163054e1a9bab1c59918e8a597408922407fca588bbb11361dca1b6fcf4548f9c4944d3a472a35fcee615065f33421e03d143e601bd0e5c523ee2bb644bcfd649a4f36424d1ac413947362076ee959d1a69840fd1fdb618c0ff167ac76f4e59f25ac18c74a17b9ecb0ae9c46f1cb71c274fed86609d548ca09548c2a9fc999f33e2a3940fa28e7dc87e5dc18a81c6f4f323eaed9674e294fca0921a20d9a0ece421f90511a9758bd2e720dc5a48b0c7a312d1ff07a2debc0b3c36e8497c10e590f7e64886fa5902a5ec7a88fd02edcd62273667070af96a2d68c87bc9aebb10ef28546efcb781d6d08d9e0cef9b3990ad4006c01846e5305042f6833d41f2f973a273eaa20a3c6298591d6016489b692877027accfa89de39ac68a3c633699ec0d6c0d6049d660d78fadf525b8b2b9dddf4be3c62850ac7eb1bd03963ed0314f9e6449ba3b317a43a8ed846e7f538c0069044954d0545b504b9006ef03b85581a5dd8e1d836c164c33bfd15b14c177ef447d51897ecda718b778025fe2e6af5edc41faad62dc3ee9d4db3496d44a6b50d8fe68c7e661d427939b3b6f768296e52fd466f9be751c41862c4665a9b496635d82d54e9bde72eb791f651bc55f17a19fe97b8dcf381197d6888b5ae9c0bd9a803ddaa52ae66fa95d349ee37dc0bbdb72ce62e79df25d51b3d9164221c466985d40587ca1a0a148da3cc8dc8fa4e0ddc19b6c313f82c257dd5df5a9b0e8aa6e621cab0794a887453631088fb47992e5163a6c94d76ac7e7b0c4876527d915c8eaa1e1ddffcd2c7d0f895d015ebfb6d7bb5ed7d3121f57b736e2534d7a6e2169fd0ebd201a519ce37a57374c9e51968e2a2a44b286dc47c99166052b28316d03404131034b7b45b5fd762dede4c4af24d2bfae149947e773d7c66b0de629aed6ca6ee1a7077ff4b807669c11c5a9e8017707ae0670355463b5550a0326607411250e74e4c2fe83ddcee8edf36931a2410ef4bf8ade25857b602d3e5a27b821487a733f5464f9919939ce1a65947ed650dc5995d1de376c4c225c87eac0ea6dca6e495fc64814cb676543082073c24d61033c1cb810ca0daadea72a3f3059ba2834d8ffa2a74758b931cb44deb56c0dbf4f592def6b9ff1797e99b160a6fc451e9f49ec68bb8487ca4b08eea712123bd04c2f869dbca96e4d9282956e9fc724a592155863e5e0bd3ad083a4ad855e8693c042dbc172517cabea894ec957f5507a70cdd7931b70c0f1ea8d58900496fd0d2c3d80c7082d6bca35523fcb3cd50df7ca88ccf2e64c1cefe1bd3e4e3b64b845d346ecaca5ed32c867a38a48444d9b31ab5defa7bfc15ec2c9640c75cfbcc3783a356960c531f830d8d9398dc9e310cc9722df145285bc4aa5ff38a6da72289513c97aa5925817e555c8083967267ec62ae4247a893cf9f87dca8c889d1d11218e24db9104ea21eccb0a116b3b2f5f721d51a6148a379f82c703344678e17093c064cffbe1460c6a75089d936b4d2320bc7f65285e16233dcce491fb099b03ccc15ce2586ad5d2d3cd6d35221ca85d9d85918e599e9801aabb744a5f335826bebe73e00a2934ef6d3da3237b0841e0ffb02ea1b08b78c90e1416ae9cec24377b509946680a3d858b2eeb53d13c1464d03df96021956ba986c283b611448b43fd8501bf29b02f138dc44ddd29ecb14eb43e9613108c2696eb252b92eaeefb5e933ea9ba6286656b02234fb7ebffb8fbe07efa1197302849576a6f8400e53a3d3326f8084acf1565189bfd73064650e5b2a58639ccea7243cdfd5164327930c594c4a9ebdcde771582c3f92dee4e961bd23e41e9ecf689913e1fccf148b315416d703a58383e310e8d2ef0522e7609e4ef2fc1ddcc3ec73d03b6f1041febf8b4a9eeb70ca11e723286d33938e3daff32c5a45b4ce7e9c14f65a54d3ffabb3f7931c8553e311e559f40d54bc10f61098f3372a402684e81850ead12021142bf20bca4ab8f6c384768b6c626c153cb78e62b6f9c5c58911d5a3e60a3437fc094957e523964bd954cd39c6347825a4fbd0b133080c49e0953d27fcd88757e6929e827f528f1c5cc6bf6435d6f3aded99c8de01adf3a6c984c87a696b8939affeb94a17fb96884ddc318ab347c19dd34c7be055d8ba481af57fa7918abd498aaba53fa721ff64fe4dab5d5c8bb012030e14190ddfc6f4e005163e92c862e0bed330ca295c918913003f567a50041ae0a0c655f67d12c4cadee185c01a353ac81e0f59112eb353468a9c9da0857fccb1ffcf98c0ae02d06edd65a35c711165744ede5fd36fe263202fd4d747bfc00a10082e6c4dfaa431417a7ae7d8df75baefbef7d880bd369e35951cb94174ab53766cec30c7675ce593bc031831d6bd70b98237647dbc9226de2e6e3584823c3f626396f39af204f48f217fac8332db6e320661eff6bf5733cd6c6318a3f59263f4499bb728cd5d759566e8c7b35bbaa689c1fcda6dcc64f97fcba10fe34446d3eaf6837e3d1a0eb5d8908d5c5c187530f31c352be2c5d1901cb49546480c392a0b0a040aff11156ef4e65ac62829dd7b97354ddb391ea5d034d598a691026f75dd90b58d2732d3ea61034c435d9c1c224c136f4b8ac38baa17d356aca26bf3329b2b94382167323dacde6ed8c8ea6a3a68f60d04cb35f462579f87642f96c0bc7963895aa29763b8c3c4939923a0ef2a8fc1a5b3fa07dff50b2cd1f8fe5d0d8af561488ea7b26f44c00d1ae48f5474bac7f893025d7eeda128695991ed12d6167218bd982424457a9bf72be0dd2ac13ce9fed84bc65233bab031a6ca0c3400b718a826b3904e4728f25ade621b2bb9a2f9e529da2cfca2d506f3a7f760dc9475447749bbdc0786d973f4cdd8e028b431fe1301d217a33d5818012bd327e1970bbbbac93e0500247f23beaefa4ab6169bb15c0382a15817ca62ae329d3e5b81c3acf03a94a410ebf1b7ac4ca229f9babbf50f29694c0276e117d22188bab9d495262b13e50c18d1265662581db15287370098caf726657a83569e8000dbe755db94156947301488534cc439b5d45ce55bed01441a8c153b2f4c26520d49916bef45996d79ec318a1ba43ddddf164762c79a0020196a5c1f8d59e865796818eeef395afbcb0ea509f1d7a290b21c06a1485e77d47e1a639d2b71fc914a968725560d19b7a8f446d89e18677f15e5aceedc97fc9ad9f4469d8ca952b396df8074073996850ccf316a44d660ee3471dddf7dc1af8d1e78962383e4576384f5d8b8fe5385f009484d90c71cb38207fa2a158f4539f1f804c6a288ad5d29f367e11e65f7178e8628a5b74f190f9022242730924d06cb3c156a707537cc90d11ede6fb189430bfae05198c637a4569dbb5689fc16925b00c7ee8ee4bc90c7b407ff520c5994a67e1015e31ff1444e9fd42a16d99403f61fce128c49c12d7e00506b1cec5f9824f5b4062d7b26091008b92e07ad4dd2a0d8c3f05c7309c83b7aec3c1b215aa801bb11eb8be88d37fe569d568f5b23a7f536d6dd7f811ae3a3a8930cc83c2e3f9f85052aa375d878dca70d92c81d9319ce859cdd35d8e508a6edf4842c8d5b56b10e36d11fb84a767e12a2c063b22466616099827983fd99d8f71f0103e0fe1001a9881650a8e64cfabc97b89551bb59420356b9d043ad130b0c4b38baab7cafcccb3d625779311498d1314566791b62c88b2375ef6425f70b49fe69973ee2df0bf65042b3d0e3421def35669934daf5d26cb51f2b82c4e82f18d9ee6f45013eeb3b304d55802ba16c9b47db9b987f1815ddae186c321c86c89e0507038b602e633a121d4e2a1f2d5c3e5731467ab6b8767a06fffb7bfb1c873d8d5b197477c1161fe1caa3b23b8a896d42f1b7b7dd541ede2d19d55eeef7f0d72daf5b7c98275ba528e71e2f57d3a6eff1cb1a73e3269c99942b40c8dc855d98ad2040435289fb1279d231326994d6c4c2f87cc28da0099aa506cb0d666a54a86152aa36e8bba9de7b1ca872b357d3654e5d70054764fcf0dd77d4b3455a1071de9a2392d10ba653c62e1b377b2c776f68fa53050b083a84e2466a1669e2d5c8ad165f51871c73ba93007840139cdbff761a168619fe2da0a535754d29f17eb8cb7ca2251e39276461f8f0b0ac8a3fed7d31e19a40a3c86634f5a3b62c22044b9e79af114f11a594a78139533b0d396926ec6f990071b7b7461ed84fe6d13e11a890b567e2ea57da3232fde3f0ace8bd27de71bbb2ecea929a98a720f3b6e93a746e874a1cc79dbf16b4fad532aa806a90c995e585986cf095f413b4a16d5f5a20e10c2d91289782aef991ed574681fe85e19d29851a50b2896c9ddcdbc8e003a677daf07b773476ee33b4eb0ecd18638b4c745a65d5fbec36668f8f4960927b1e19f8e56bc0ab10c9cdaf60f2c96adc556da6d55b52dd25225e03a873c02695fa64a9714a32f84515187e68ae589902a3c836bc86415c935edc574573b32287070fbc268f1f8c783b083e2569628fc717b9e616a6a6a00645df02b29affd135c086a1cfebcf2b7c11ce8e8d175eb5f50f53428b681cc45c8c43c31e67a2414e4a58b721afb0f471bf98ec25daa3fa8fa99a601d0f68064eff26f8e7bb2631a0b54a06ec3627ee668acdf0843f7fd0830cb2badabe56102848fda82295631971101e6c7aeca6df54946e9e3fc2cf6e99ef5bfe26268b2b06273b3970841bb3395635a4f7bdf181fe7dcb70fff8c1bb032833dea135706a037a6e00b96a7388db8567d3efe2b8fa3136b66837d2bb24b84835d2999967828bd1f6bd1d512d98af663fb953e1ffa3d40209a8576c20c64edd901b6fe771c917c52186e7631bd6dbdda7b03d67c4b1834dceb58f8081a7de871e80caa84cdbe599cb8374e0c14591f1d5b406e0430d36c0b614266d4acfb7bbb5406a2d0b78b9a7e4617cf0b06bba7ea774339c6e2303caebce5195cd4f80611b1c4facc9b216a2345352410d799368ab8985b9df4e3f648d7d4aab3bb8e980c76516320dea32046e1209c3fdaf503a30d3eb9573d4631b9a9769af93525ca20c457efb5a6ed465120faa81c5fd94c04c058dfc993a654005650d76f00aea966f6fe2a5d751d25285a6c5b7b0ca93031fadda503ee25c1f2079fcdb84ea3c90ba5388c35cbf7e4c894ef1c0decaefaf663f8c162ce2372d2cf788e5238f08b35833be5199ab1e1f22e3bc1d4b2e124fad0fb26f0a840634422268c6a72636c5ac4a74a3ef2defd608e20ed9a65efc393a9a202dc0de5db7d011b087216e27747d73e1901b34f8f254a7fb12500ae5d858aa757d9ff8d04d4dd74fd8707bd32caf9b0daa5622eb85a59cacab6a46dcecd3549ad5ec01a4aaa46c1cbfb55e8edcbbfbae4d021fa16581879eb2803d7382acdf21692cea6c8fdb31a6772920813b3baf10db20cdb751d81519cf1f268a3c97eedae3d44c086061f40930b1b68a79410d2b2631f4e78abc141b8368dcf737eca6ea22c7cc73983e6d9e391200bf6368bde817fc7df23c893c76b6fcd1bf7996b6cf60e0032f17f4a87cc5b7ddaced63c9b7f58cd50509ac0ef3630f96c4b913b2b5537c6404e6eb9b8014def7e2d0b16bee651a63451df7479eb38b8f535c66fb690164e149f3323fe18011fc0c03839d67b8e7a89ef07cbe1a56eceb856fdafdbd5c3503569f7df80d7c76cb67d765a1fabd99f5c1e1506022bdc9f46a42d1a5ce1223374fa09398ec41438b8f5a9f6c47ff7340b6adefc7a820f61ad68b72f034db9921b5a14d967d88e7227b6015fd9775e057a91e85ea0fa1fac85e18c1e2bd25cb0b79e00843291752d29c5d3ee364784955b02503d4064c37f4460591898fcc9e7b89369aa81f3309f9add0bdc2d689f2a97b69ef9add8c6eb25ffad414b4f8fa95e6f9e02204193de209520c191b0840fa6a3ff61985eef31e22dc7527549c98d5239365e1e03aa8401d53c8f764d3b666d2c433e74692bff9feb30bfaf95038697de1de811d4d7d8dbff20e25176ca3b499c9207d800dba3d3d176d47469b71a1dd8d5536cfc6b23639563d40f708ec0f6807f19a024718d140a572c4c044513c1ad04a835e751d319564b36d49649e5ee4210ed0094db36e1c02e1ea3031d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
