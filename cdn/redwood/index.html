<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"30fc0588f604de7e293b311ec7a5f4f99f9a4cb0e48c58b439c98ca9254615fa79d4759ac5ee3cb77eacabb5eef87c291515f421dbea8527cb9146d79ea0577bfc5ef8d0f7313de2c0c6b40b46411bd7868c1ac8cad0af173b25c69f318c71ad25cc8e98b6a1deaae6c8c7cacf466e1da723f1d64949cee8c07a2ca60dbb0544cc764349254654de87375b68c32bfbb69c31944df03adcb7f8f9667687248e0ef200f698bb96598a8297a5eead0b1b433593bc37d6015fd50662f6d1f172f6a21f52b0a3c4d874ea7554fe2aec0f52a452439e84af509b378b817072dd572ec65686522caebd6119cada1859fcd4a4d4878db20cf4915fc201724b232d9b2cff49da1677c99c1d3b504eddc0e164aacbb47f982393d5ec9309f4e12c705a7c211b91469c2c8ea3ec5484160f4a8f17011c4f379520bc591d1c264a262bc31d51f4054220ffa474023dad7791cef457c095dcb794ad18513282fce2f4b1cee54309bfce5f2cc0e183b6440cb13d10d0291d0b6bf42f952048cd1df01296148c724840f6be73f57de25fb78865fbc10bdf5d1cc5815e704c05d1711f6569d10d16f705c4918e26d13985b31cb50000ac9a923902f4258770a97101f745cf92fc9342d9fdefd55afc504d24ce654eb9e9e7a77862eb10b2c2c0060fe4716b1cdcdd108fa6bb452c724b1b65320e10ba67e307b8b2c954ea388302c415db81880b32f878969709a4676ccbed018bce840ea2cd6219c950db1819ba358890fec643ce1fd6865bb55ff711df5987ac3395d617e2c1b15cd9b910170ebf540a921c53fa3e8d8e259815316ee23a1d69fd9b08ebfcbfe40ce909eed0dc6a6ffcd9cc55dd02e2dcdae0a0fad18642a9bfe9091b33a533cf04b4804d9eb3c3f4be77ace89b61166ee223cf1b3b72aa0620b89087277a50e955b2a8dd5888f6dfeb5ec10d1f8307b7c3dc3cb4c13dc6e4b91b6fb315b393b7e1c054496355a75fffbcd3a12c8968b9633aa54f042433967b03deb95490e6eee272e77fbc8b45d413dd498e25425fa233fe4383cd58feda9e404058064fbd1182b13122c1ccc4474dfc49b9bae8734b03fc28225d7dd02779a953070b210f662efc9ebb71b0e556b6204593f90d5848e81eac6b58e20fa4f1ba64949cb26d87bf4432e7ef2b95ac6118f36131c161ade8331769cd2ab31bb65ee6471ff2b9dab6bed7bbe3fac8624512a07d539200c10a744c947ae81e5ce3e287a2467d50fea4437833c4c8223bd887849934cfcc188643a2a220eed8507dbe44e21034db354ba7e080641850e3a8a9525681e6baf8802231e668dc65dcfbf6399221fc5457311011630c1e23ce4371f723a4616e93f02ad86eddb73eb52901ae97cc3f1abe35fac8d9c3e4b10ba263db59f95a2d8912bb941d1728e168bdb156008ecc65801d922516aec4dafeacd90be12787a66e525f3c855a4ff6ab9610a790da6b12ccfdab630e484d4c3b0a54fac0d13276ddfdb7d678ea8f87698e6becef1a512bd0a6725c7971a3f750913b60977f9dd65bf02c89e82c7ecb5343b0cf25e9c1f2b8bae80d3c39a2636f689120bb603010858f18b5d2434fcbadbf96187810b913ed3f884069cc2ff1f609ff1abf260e576d3469111bbe636d5db625c271c66e5e1deaddf93fe9fce6f7a45cadc0b4043ccea4f5aa1071caf8614a9e8025bb2d22101e0bb5a5462decef2f6f3bf4a674b276620d4dcbec22efa992cff2f7809720569b74df4c3f6b4d40681761b7fad3471a443ae68eda480376cf3a048544e8500fefef46a58349ce1761b440d93100faaa50978e8fb4458855bb960819fdb885217fce06d10d61cdeaa85f8deb1d553e91fca75c33736380a10a6019e1c0c3b24ae051fa6cedae575564973d8174474935e61a9f383e06a89f713a7f461316a7b7c7cd15a316fc05d4b762b3cff0f55044db747bf4724ec71da78d3e30323b119f6fd95d616ebb6acafc233931eac0e29719b462a85318947aa62b49099268e7076a6591a6bcb12ed9b00ea2d2cec315cf612cad14b7ee4ccb2b315e3ac67f76c6668744685cb0f4e146e0776f7aef76bb0dfa27f4e81abf8c958c439bbd5a2a0613e15b5383476699f3bdd0195414e213f2a7ff88f1f3f0e0340a85ed39fde28733490ead898848f505ab25b69a58be7c7e63754be78c3613fd0366e4a9833d855f05e4665b640ad7b520aee956d29631bfeae37f479a650b6cea145043f2eaad6309fa4601a2ebd0eccf5b489cf1fb171333b4368202c9519c9e33f1e117d433bd53529f0ae00d2463467fe9bdd0880ae5d83ec709e61174446f089f2f1680093de002bf18b6d2f46d10599d3460b85143e5e3fff4f015d1020a9bf0ce2b833171ff9b94f25f1ac2085068dd286205a26a6e6f54c609d7e08316cfcf0d9db227139703c0b9477b9c1ce69c0d876ebdc83190af383fa47a286c39378cd1da1b0e4c4592cd8646ccf4ffc336562d42b189bce14212b074cc080ef3864d04056f62716084ac9d35aa2f12060a88c00dace66559462656aaf1bafde6be5319f362b64ba9212b1a80155973002b9388d4ddb42ff1a78c09475006f9716c7c4ddde70d0d3f0ec0c31b367b2c6bd9c0802917238d9df293b4a639c03d4d5d15bc9673fb01bde018733ebcf736e61501786ea7e3987afcfd349813e2950c9f9c15b07343141693baba8383541c20bb462a1f4fb131cbb27e7fdebd4e8994b452504ff7a34d0f2514d2e39f4098a641305144063246a1308e8197204e06fe94afebb298c05e1b59561a66a259848d0704ea84f98b05d56deaf674f6f1e7d76ddfba046b6f4d8140e83d3b13dbe37421ed0c5e49202b86eb3bfb91b5c882f6fde619e9be2dbd18a297231c20064e87a64e98f5aefea1cc886b9dc97387caee46eec826852673c1efcfae187a8a17bcc28e017807d124d8ac3b23fda6b0c619e9292d13603a9335eec28cb730160a3421987dbd714ed43c7666dd98745062e78b501f103f3bdcc3cacbbc30593a1c180b7ac9a58dffec5bff11bef1eb5863c41c398148884a8fa566a6841a84125a64a97452b75685325a1525bbeb3041e47c6942b0cfa84e1fb84f2a470cfb03b716b2411d40babc34aeff764f8cf4bfafcc3bb103897d021df784b556d0a27ff0f79dc429b3386b422fb47ae1ea2b82b7855e7eeeef372bccd8d30e12666ba0377b4a6ce42f4f57e0d532efbc970a9096399f3ba3199405b0222e82b2123933e0beaabbd9302cf5c70e686e69d014a8d58cd6750434adcddff56e3000169170ee791cb30f60d55047adfa7613e64b8706274ed87fbe9342ea3a201216ba707a7f8fa181726766065f59c171a98ec6ce31726ea40b1c62ab6feb02d22f91022387fdf2d2dbd4ee4884abe870b29100b37d763b140f58fd0176644e3f633d30ecaec7f3226a55fe74bcdfc0d0eac77e7217ca6a355c053643f8f500e63974f082b133cb25b6b6a097b18f680649b0b87072907b8d18f26a29aedeff8e7f183a37429bf34229f3c6ae7f7d3c7d07b0fe044283db85f4b9be818ad67852fa86cfc3906d60bc5c3f567e82480150730252f0e77f0635f3a9df1386d044801bbc7af797f43e90d9614ee8148e8657183dcf5aad19f8e939f343afbcbe80b98f7cbf805cc8ee76dc10540f1ec20c34bbb0f97d25c5b30ad721b127e561c650f158fedcd5f8988a7e27eedfa481620b11b68848164c65cd85dc2783e0edead4dcf6d64e82c4936f6e631fe23136ff3514c3e8e876250eaea4e50d448bd9ad688089927b37fba1021123c2414832ecf1d035c639e566d1022d6eff38ef54c004eddaa9a03e852e112317193926cc968af8ca249cdb533c472d961f159e9912dd0529955b2dbdab908f851ae0be5fea573d0c812d973f07a5a39a8ab56a7a5a763eb69aea1ba8a832346e6e13407ebc4f53355298593064c86ab014639642544d9301b80dac1e5a694cdd1fe6c5bb6220bb75a62981e9cb63deb1e04aa43c80b3778d23d642256d40827adb654505736158943cc00918adaa87246b2325d514b55a982db199eecd2842f9a9009825a0c4580dbb72be14db3323d72f1ef5560fafe8c90d6b48d54a75a804ec0710f5c080b416e412b818ff24ff25cc900750d9f691a46c261f13f6670f23ed3649912d6f6625b6f23c071ddd7d8e504e7f1468f4002e2b03abfa87e5852a6d89653a3972ee19d0df61a204ec5b898576556c6ce1d473a3774ecabbadba2036ba4ad6246c848efa6b116f4944a844938b3062d464c7560d563cd48d8aef0b34f27e9da3663d4ed08f1b930e8b3e02776cfe497d87af436597901714c87def5fd61d28a38c652eccc1c1e77c35c4e4442862e02a8530f23fad2884445428e63169d0308d350be20d55f6983e44578f699b15647334945f19018392302935dafd166ad061e67f815f89dd57af6f496e67610b4a6bcc13f755113efb89005e03cd63b6dceb895f93df5512edc35312a0b0c26e3ac84994fedfdf1b1cc27e4c352b893420be53ede8ef5b9660dcbedb5e69ea125341dd9ac61513cdac84117c96af8a124a8a27839a0185140ec5d1f86710a97e2f0bc5ad7ecf702fa80c3b43f73bb1a081aacd2f9562e8ebf973fb2c58dc4dad59b7df7feed874426c2aa5a55081e292019f404144007e1b3e5aedb9ea65e6a1ebc853baae8ff206fa6d0d640a9f68de074862684318b3886d145881ccd266c9adf2fd990b4f1abeffa6ceb113965dad528f10e39bb126b84ab5080c8498870f865c005ccea9e81965972db5a215b4a9343788a351efb63d612a0ac80b6b4cf6d1b90a276bfe5a15c16fbfa65446eb301e5f599bc2f5b4ec6e7dc9ab5550acc3796fd0a55fa1a4bc36273f631744f0c9396d48479444c6fb8163df94903e14a966151f40f4d4e464c9bd5ecdcadc9c004490c1faa49f2b57a2f3071c5881a164cc1dc3b12eefe12d8900b64cdb66312920515f2ef3e96bd3f84655a90787227556164e20170d08fa5d6a9febaccd3d31d8d6c4c486741689f2aeb3a2a7a974a2d41cb09bef99faa5ed828058214bf513ce1ae37f9df3cf05c62f15f2b163f57f440e14dd96491701d0260e467df765aabab76c5c022eb86ba63a1ffb3fceda2562e21fca4ca24d941ee53d0a4250e85f4ea0cb5d80e9200ccb9794624b422aa15f0160818ef61b91e64b0051c810ca4d3343a2e1dd361431b45c12b32475a31d4338886f9855f9a08502a635f67cc912c4175d79113900eebf2ffe594e28ae484960ee1b8b02a9e2f4e1609284e86ff86e874362b556f33c41dc628514c4ed9e815bf35c9641313d8d5d913fd4ec74d9cfcc29da81db838cf45f871b3509a28a7cd93ef9746af9106d0c9ea4a55767da502994069f492c39fb1fa3df7ddea6effcc64e641aa7060c29e084f4c3d61d1512226e2d3a89d64f618364a0cb7bd8a2dac4ceef729175ee1807ca2538d5dad30a58ed174d1cf5c70312893ac2a73f5ef7db6b0675e2bddb8c616cf6181b1dbd277cf9328ee96541ca0caf1feaad8aa2a2f264943a8e32ce3eea7662c3e6dfa2c64e18dba006d8a9d391f24a4f11665cd4c5bbde7c3c439edeca4322096ef491f454ae7ec3f4e05a8de72e7bb9736875189300101a7c072540125a1a9f29f1bee8fcda726b101f890ea3b02c9399c88914daa3105467ca732c6844127e24d9fcd4b21beeba995d31e897290d792c2cda1fe7a86d633d7030859b1c02f667c293990de8ca9769543ac26070f4cf38d9333a5a8ee0ce2536de194990663e81409f7c25d2d926ea9a089ac94dae18b9be67a2147284317e01a343f7d76aed0a757e229b8fa72c7c19d3e72f79f41c0817802fd0d5e817882a9657d67addbf20b39032ae010f36582656a3924d27291ded56da8e68946b2da087287e2ab940db078696c50916317ef61a6f6eb3e6192093952aed88c6a5d738831ac5d3b4f5c030c7c6729a61ac90ee8e787811e63a0de7dbbd8c0fbf3e108a5e4796d713fa62ac1dd66a91724efeed6de3a1601d99686de2259281f87c8275a720c8f139976622211346e7cc94f5a964970cf289114f041f487982ab006db5a4da3324186bfe332994d3661c0df9a3d575932f1d64b4786eb90a3a028e89a1d78431a9c26ddb2ab877f56b3039356205decd04de6fa607c3fb8e80b4dbd7a92f438126cd9ca1fe2c096d3fa6f4e0f494001a150a12e92ed9367e269c48c14adfa922ca53d72abf0fd4b699733a886661aaef22f9a5b73bdd6936bf420c4d1b38a4188938924ac39b3e183bdc0367b12d41e91950a3ef2705f2db29b72fcdf910580117113c02ac0a0fb8c30c13189ce99b2fa55137a518b6d1e54b9cef90fa3696fb45a9bb413442c3ed38e7076e72301c555b10515a10fa51269e24872750465529fa212f1d3754bc7423680e3e2d502789e224c1a68d4c5e84870c0a68dec7cdd27df473ba22d55781518904d578a01eaf5ea8f68b85f608d3f3f64153112206f7c113557bf9baae8af8c7e5ef45fde93e237c4b02abebe1012fcc12a5d0696bbf90c3d6dc9ddcd8645462519fa1a6e6c63fb74556415806504eedac8acb23797b72a571323c7719dff5e32c6ca7a855d42863d5544e90652b7a162029c8508c0fb0aa61986af7b895dd0bb8e1fe95abd8ad15ec1f4367f85ebfe672f3b4366144517fba26029105effc2201b7f621580640af340552785d1ab5ab0e7d23ca9e0c7f5a8b73674c5b6fbdfba4bc6cefad0187365b0e42bc455465dab827c4e5409ac20c982bef474a79ed2de63869755b272c87d699e7c80aaa2f2f427f2d1f6b6238e025ed0b18501072594361720aeeae75044de5d45c763da8d6efd0d0e4a110ec3b003dfa05a676085616726e41a707d633c059ad572d50fdab18ca6843ec0749a4d59704a17ab197f9289babc9e509afa93b77b8ec0cb1ee098dda31f8beaffa25a3b13bfa8dafb7f184cf2a0b416c7074922b2b907b20abfa45ab5189aa0c28e323365736a692606eb05d5c46cf19315c508686d9ea4d4d8b09154a648fa946c80d70b766ece1b23575c3bfadd735887fc90152037f42814a17ac42006c61b25f424da3b856dfb06c0bc90863f739f7027d4c2d3c39f3a22e18f11f0e77ab7f9ad8a02a58c79ef8a480e51102b7430dc40990d6c07b2bbe2990dada3b64f3e877d7c3795beaa6c35ac89784fd1e89bbcd3a5759a954c1d2ac689754fcfa17e9259d7a158e58921ae64e441dd6b8431c5787076e1917c603ad0cb5bf518b6292a8838173974ab8f34afe665e518b66d884af0b2e3ca48f38c9f3786830757ead84cd59996e958cc880dd6f29b381f0efcefcd7b85dad5d387e1ac753aa038769fe0523632f70f665d5a52176ac21f20b55e597fcb070ed9ca8efa04217d198141cd343be71f688fdc68d836467eae5fb78dc73eaa00452b0935a93be5f79f7d4ab0c262970a2533752c7ef7606fd0ed56b6f123e620577a5b2fc4eda62a66e8c4c1cec1c90425814055f8ed1c1bf67eef10b48108ba1777d4ed5b05d73719057bfec09331a83bbce3b65b836da7bbce71e2e75e8b286c2369722dc034b6dd0c414ec4f077395c6f674a2bc5bdeedf56b5315ed7fc9b26f5256a8dd049e0f892b658eb6490fb6071dd75454d452ce3befdbc30ed3bbd7f0351aa8d5ae1e982efd6dfa0c691657f94e8a8a927238f1b8a664fec347cc061965091d3a42d07a027e7aa060ea117e686e30afaf446447f7175e7e66e7d85e8cea2e74fabb4c77a837b9361cab06b3b2408b64af0136d1a00bdbb6ce548f4ee24e4474549134aec4ad96d81a5f3d99ee3880eb5762fcd13f1cd0d1514b5dd83d94b0a32576ce4a9b63c83a158d3d3c2d15307244bdbd006750356534e72fdddefb58b79b5dc5da4761332114e96f8a1ef52e61bb213e1daba72798e9b828e9ec95ad5fe6fa1eb5a92bced15e47bb002d4e51f7380310c33d144c032d6c69713575cda061bd4b84d49a7c4eccfad23f967be68bce2144a2204503f11f6c6482ba963b9580c9c57cd161ddb4255c5e8fad3149f2db9399c85303d2b0037ccd333e1a915747a472bee4f66a129dcde0a7dbde6df389d8448454a24c5498728e7984b7fcfcd5291177c3397a8dc73ea69600410b66d6ac296d65087f2054579b4398771f9c48f1cdd1e5d96b37ebc5e507a3abe540c1d9055325012b4383acbeb1c6a324e8fef6ffd1002079340e553b88021293e81f840283a002e603833cb2cf1b6adecbddb9cbe3adfffe8372b2e1aa0f62c5086e629ff1b89ddc52e0933c23180ddcbdd305c4ea150baf040c6d89540414128eb8dea609236e74409cb89fe94953cf95e75065c69f0ee188d02b868db2539b91a5bacba38d239934f5e397b92fe48e1b072387be587b6c672aae551f80e5f655d87d7f22a2f6b6804390e28eb358d22bb56a4c83f005dff05062ccb0846f9497d74f311be1ee0dad2663180d6e2cf00c130c7b17ecc74c2322a89ee0226f1c3ceb81759f63ca104206177856456b8535f20c50c4997f3150a20aa1ffa9bde200deeba74f852c2cde6429f4456ff1f926136bec6562d18dce16cc870fca906518d3c791631eec14e02a478b8c76eecebcdb35a77f0afc980a9ec4ba84dac0bd813c9765b2aa2ec2b6445e732f52c53fc3139b67e8d62c243ff9562931416accdd95ac3bcc0c3796f43ccc301d9a5d275b29d795476fe7cba557e90ef66b5a1283e4fe9d506f5690f43023d2a2ad7a9d2ee1cc35f4aeda3ca7d0b36d96a62c96dfb372eea76cc3531b34bece8ccf741153176c6e807183271bfb2f7cca82b20472dded417f6c98e62471600ee51835a575660dd039863f84856b80a4d6cb651b49e1d858cdcd6b8329cb732ddd5f9868a3cb2f00a69a14a1bf87059fa980aaddd821e81e0e2ed7853d1adc89fea0e4cbc4e90a84a9d965dea3066e5fbb5321730318ad35fadf20b5dcd8c96fcd20e476f6f251418f84be2de38ec7fd1e8b7a9b4e28e2e00ef6be09bd9c42ce7a27a58dc5e0541cc07a0e505abd778bd42f9d7f1bbe1d158b2194d6659e0477345eff20c0187d1d021d43998667bc6cf117601102c159486d96ca37cd85a8e8d04d99dd468f357b64a9f561ce7baec180c855efa0b45c7ba07ae544a9a8ceb42422a4cbff7b9a1bd9bbc2f8c75794f262f1928b8ae2d923c5a1083f8e97de9823674e5daa74a205f4ed5e7f0b26e30b87f9e5c421898825c7e4d72b0129ec1dabd6c2c2da7e69bdbca328a9e534c620a0d539d62d425ad6772c1ef3f88a7561db3dbefde15ccaa5a697f18b9b5f69a5a094d0277d54f08d3e0857c7d7ffc15d29fe8d5352322d0789b32389cf4ae6c3f9f0baa3a7da1caef0a218f880bd1f10e3eb97508d17cc0f946c8cadced65c12352a4cab899809da3527f2e899249136e544f11493fa17d3dc85ec951ddd5d9e7cf3f26d18338c0e300c4c451415c3c37ac3778eb8449fc9bbe1e02bba3efcf77c115645c9f90966edccdd784bcf20f94afb27387d3c75dfdf62350ea9f4d9569cabdc7d8260b77e5e008d140104557449c1e77ddfe35dfea340ae6a4749c7f1e7122812ae76252be6981050f536755b8933a8c2a070ff32c992ca4313da278a7d2a6e5bc36abcf9dbbbbb53f4d13e59bf2ad4164845ed117fae7243bf7a0e9c7506882a04a44470d120bb0d77aba0d785bcc436485399f3cb226b45650f646795f063a08a41f3cbd3bc23f75db3a1899c5bb8ecdc6847f0f8c20cd714535ca19c78abd67125b6cc9eae72ae60b85d3e6837edfddd11b03bea3794dd678e3c0b486ca1cec5834cb71713216135d714d8a69c585cdbe1bcf9fbd8ea0e89e498e3fb7989dbd83b21f8963706a9cd20b49c4e424d9ca8b2cb30c16fc82c49d6803453bbe8d33ebf5f41f44fab34c2312fbebd5d5e065e4294a71e643c6d6c4badbb06a860f23b434103783547008999813a2de059afa6a074f5e684aa65dcfc82fefbfffafdd57668a627f7162f049e276b2d061233af5efe42a91fdca28f9e2371793a352031cc0add23ef9223a915316b469a325d1f68b267cc843b5ae5d7319cdb91ad568313bb933fe5063983174136c7be57cc09771875efa5f765f5892e9ae4e8bde0a304f67a16834ff858bcefd26b77223be69da8485d86b31d5a8407929c8e306217a15980b4c1b138f11e168029f899cd92397e642dd83c8bc47169f311f51e82cddea2dd99eeeab81aeab773f1615fc89ad6536a52fdfd794f164ea8b931393539264ec5755b1fedae54b07440883a3f572becaee512c7fb353f42ef5ef0888ad0cc7b7b5f291e93957b9b399f09863f0ab2a9ab2f23da95e485d34e80bc13ffdfbde36e98e02898dc51b591b072c3ea04e1470429624a6bd2d2aa9460638e48e2386f66912c7221b7cfc5eb809db472248c0a8dc1a6e7d4cdbb674b302dd0187213afb3c413c214049064a93e3911a020fdd87651c8c0d10b84b8bc8a311db6522df3c1c16402af3aee5fdd75fb1d2c01a33011485aff96ce55bd8f272eb011307c0787a50e052e347bd88ae035b312acb6b53c36a3d949e4b840384f69177e27b1d31e57b724760df067e33b5124be0269a34c153906558e7da8bcdfaf8f2a15bdf1f9d8d4bd3e79766696f855f643a94f0264fe70dd565a355ea7cfd57ce209e54b1538c855606268206897645a41949956fa27588738d1059bc2f3b58747a747de54be55a6ba1a1a70d0a9c506e90ef8d14189235ac706990152b0c3475267de50fdc676426be8686b94823bae784b8ba435c2d62286317370d4a209963a4f2022afd56c7de904b383d84eccc4b861f2118e972e2d1a95beeba987ae390d6a8e72146f50ff4d5511f4d383d4f5bc1f6938425952df01882960cb3e7a8f8b3112e9d890bdc90f5af95015d05fd209486f5a07aa8d0affaa0ef7f1dd05aa57362d0746be26a18b52775dfcce400c73c42566f00c7c31f7bd7c92930d29e6692af7866777f801650843f99d09c2fccd172ecf190e86856a6da13862b269716f4fc6fbb5dd001ad7f1ff7ba6cdb4c03d82fd4c40325a3551af8183ff56ed04af30bb6990d38da4c8ed4e42e6da9055d04e6eb64a9370d0545042bfb6d7c3cbd19a342dded9e756a5d71353d58de0f406d70a6d2cb30faccf2752e6fe5d7f7e98178aca18b2ede4088561fc4a01ed73662047621a9faa81045660d8f769484eb46bf49e8a33f3aec3647f96f6cf14baea10bdacb9ff7a48507e4c906d5cfcf978c1f8c6bb78b08f01b700e8060316abf27f0356e2b4a74d55f293f5e9912f6f0c54638764a6a50480c0b9a6e7cd0b5d1f14e182351efdb56980c8265592439d6897b63fe48203ba3a648f1444b08c39803acf2865c36b810478d6afeed66d5f24839ee517a5ec73814943b3393bdcdb0eba315c22e3aa3283f7118768567871dc114e3adfa3cfc90e6b4722f21c7bdff3d5ecc26cc96620aa787d7a12ba7dfd8d9b730124db1f36080116a3a4382696d589c2924c12954f377a1cb09cf9b80cc894ceac29002108ffa114520c4551aea2f646a01c632d842eb2879265371bbe203b96ad38e8bbbce953fc7a40d73056354475a5f7169d66d86bada49ec0ac9d34eaa9987cc22e4383348a1b48434560ac6912236653ca747bc53cb5681441663047c56f4ebb603e02ae672c2add27f6883f360fa7c8b5c28daf7060cbd458bfb2f744e8670909d3f904ac802f6d8be3ae522de554c3517d9211df65c2c5930326ed6073159b3a313bfab05093c5cc40c68b992a790fa57fb5dafdb7a8d2e3ef19a756f743628dd8cf5c3eefa126ab6c566cf449098659eeaf61f97f88e9f01a1e565cc460e3bad74f052c97385639ed3b4579854bf1e5c10fdc0bf008ab83ea878af118fc485644cfd54d9af7baae9040b21a42360a3fe0fa3bdf3fdd88923db100aac7ec58014daeb0b204a8e226a7fe155067521eec9700403429da37b5fa3b56e4f26a67280a0a5895daa3c843a1f55755ea9a5ad72e56edaa362f7619366ae8d1df7f80076438d734e919377d6b7b5377c0872deeaad132d4c5a36b6c5a7c3baa4d79ab1df806b1747218e8be387393bdccc8ea56d293b2c43dd594c74bd3884051f750ba1490e73c9c91f54a29905ada39c74fdac194713fe81d69fe2477be8bf279da1a2e8f5de59fdca3b0b54d0fc66ec5820ec0c5329a3ad8cefbe45990dd2ef04a825b6d216b8104fbfab144ddd9b1a170d009d89a8633c427f09dac091349e1ab78c62d5d411509423eecb8974831a47704132aacd15d4b2909334772cb48f61078417f08b70480130e606296ee8cd7879ccd60734e42c2b5b155d90c07d83fb87f971992323fde17652a08e830a68105d649a89f649529195d1a1aab0a94a2b7fa771517c2c8b1ca89772aea4bc1a4a0ea5a9bc912f8cddb741a635c803ea0ef7d5b2a460eb30f512257b1fda5394618394dc32192a888a6a1dca286ae2a51c6649285220d05c06d9748f9ee91b8c136da3d9daea31ae8accf79ef9588b5e1b391dfbeda3dbe2dcbdc78abcb994e8101db40e242dae191845373ef3729b4c3cd2f0631aa2afe823026e8cf3fa9c8b9e2e82b51505cb9beed948d3e95b0cd2666cad8eab49eeb7bb347fe427a1f809a68edc9934a51d89a66a5c0b2eaa458d39ac1371dc31b7de49c52bc71d6bcd6a3d61e73dd60ebefeaa81af1c736c7510358294d4642bf0c2e308d8f566540ddb6b6dbcde17824ece90f17fa7f911b8cc1a566c981a80af94ae3f47887049de8c4adc0f36336fc71e47b0e4bb6f3dec2d9626010bb45773690c0685872537d71fd9a74ba4fdcfe184de2046dc15d9fd8fdc6098ed800c89d6bc8e9cabcc272a6ee30be3dc094b236c61f346248dc200d0218f53e44c83e4aa92ebb2b914bc2864b96d3b42f7948e8c3285a93b3fb2915f5777b1d10bb52b5bfb378f3ab7d205608d3a08dee7b1b3b5884bbd046f3f183635ae3b11ca8bd66f022a02624b328ddcb64b270da4dbc23b9ee65e5c67d9425736a0381a300809486acf978f7100f88bb9fa1f2fb9218fd4e10b633de6cc6f0c75f8e8368443fa1d42b08fa2cd3a9c18cbe71a550a605513db6d985e58c6da728f74ea0ca0910dc8a98c32306a56da6d313fe43bcf851dbaf9400f901f36e4d1a09ff4c62125ca0c04ba5a5180972f0002bc18917962d612a41dad20472c7b5d927435d7edfe27ba0bb1e06cf5fbf20f5fa14b3b990cc56057d8eb5ce7443f2b1a1837aba8e42851d35e4d05644d0f77d5ff5da1d6dc6754d60eda06f82fa305340638b5c152e73e36bccf42643e4646ac303d947e01055b69efff1246484bd50948872301a062aa4e0900e11598542f380a6068ca4469a5bfaea9c6cd8f4fd5c643b245f92111db4177dd70ba745ca9c8610db85006bf56daa6adc0149e5ae3392ca1f95aaec3376673244683e2489b0f8ed521b35f9f2bd8c43a6372ccb2654c4ee3d6f03c5775fbb74c0b7c5807d760a281103cde92e3efbd1197a7b8c752735fa5d344119f33648cecaf5c92bb93b5eb52584cbef0d74941df8e1c2efb99157f68df0038f830da2c14e53e8c4421f825fb48dd88ea26e86421c27c0e52072f0d913cd0d81b8a17ac77bffbcca032106e500f7d97d3b8a25ee31d9d83c0adb468d1f77409e4cd32d65e62860ca6d505e8e072e2299104d8936c7b4ec6010579aae25f9a8a99b9a75bd5640cc6186a878bb6df8268d69463fad1e93b50d7e2a4194de18d4cecefb58d1f6f42cda41a61d94c3cdaf01cecd9542ae569ff6c738f48a8c84c8ffc80e52b75c16cab44a231b60100f533e9c705fdb4489cb89454f50077882f36ac0a193f9ba30a0a2cd532e72325416f2316d8c98243e23b94aa1442866b273023f4c84b6c97cbd358dfe7c1ac75af8d61a560e0378279bb78afb29aa0b15ad2aeb2b0ce838f1a712cc7db498b7c1a4bd491d89e1d1af4585ae29022959be5ca1608f8c1cfb37daacadb85ea33503a3631b3e24c1dc2bffc2d096936a1f8d5f3defa552bc7806bffd0426b264a9e9af1188d80afb963499025da8daa3a79a8e0fd0f70d1afa93adea7ae4940633b8bbe3aa5a1ae7f2a17f6c662f47cb8a7249a17b1fe5bb47530c4884ad6b073994ba813b580db3e2abda11a888a31ac3efd111b84ab3c7ff93932130e7dc4d4f1e0e4c0e7b2523633a349f53c68e543a87d811f9ffc913a04b05ee74785eea0e2782f05f3b329c78b82fbf496df053c536e0bc5b951e963c49aae35dc354bdee32dd2e81f98a482f0ba8eb7b8f334fbfe8dc5bbca3db0d064db4b847200e34bd62a5fa7fcfbbd3c135b3b0bd5bee87d0b49ff60337298c6f2605a4c6aa776741bf2f79ec4cfeae13b47c8fdcd88f893aa51d4b6540467b9afe63119c730824482672501b911ba1703739485e7fcdb83348f3c58d6c05a0a7d5996fc256ae10a8c4ea32fda77e6fcd5306140660d71d19e9ca97732d0f0659bb422189f4dbb1b7ac62ce7cc3c6d4140c5566388c467508346803b458a8cbf19f6b7d51d0c8b5a5559d1abb204652398491e1a39d22687334b2d28898a559ea6fb59395bc4f24e7fcbaa8499a44bb375d4927e94aa6c665711b475540e4e38dba08eb59387503229bd3fb3c87eb374582329783841b7a3624a7b904ecd2b9384945feb590df25c7922e9d670199ff1b93303935522ecce489b6cb7529c038ed4ba403c3c080fb00e71287f02f4d480d5e0f5894e3fb23bf80fe1eee6d3206e7698eb2d2470429a657ad963090cbf4506250bba25be21449f1cebba3b9aa52bb26190f07213e16e2f79336ce4251a68293fe98ff252c53681c29df659da79d878c448450a019a7b2c429c7f4e440b90edb93747331fdde7d2e7c8225bd190bc83fee0956f67b673db00235d6267a227cade43db3278ad95e8c5780548508cf0544caae9fcfd011c34bfe0f4fa3f033a615c064c4449575c9079e4ee02a788bf4a28f9dfe2cbd5eca4f9681a1814d70f74cc6ccac43cd7c0a563f00e36f563f24da6cc0d1ee9d525fa41ba740d217b744cca74d419c8675e7d5fb9836d281474022b071435227c9c78048063f3c646bd86598cff714e337ae712f227a502820e1a1e71d87b8fc7a7464358ba2b692db411c035ffeb5de9d398873624e5b95cc66255afd4637759f98223c46fd8ce677fbf196b21bf2221695fb16bcae866c735a665bfded86189435a4fb46e1f765662ac21e65fcbbcf3dab65e933cfc80bc53dc35bdb569ecb565b0fba2388af669629e279df865b7072bc4701939f6bd268539edddce70628d80cf0a4399d720513b13b969afc256fc0b95948d4aea067ca51cc030ca1525810c4c3701a37cfa311f6807ad4b2f553d78484a9a7321b4e29861f55b7956feb2a4f4667ad64ab992974cbd45454fe09925f542f266a19e8fbbe9b0e136496558849d426e57f0bbfc373f4d768467409cd3a8fd610b935e5a61124924ae47189b0781c9f37696cf19bacc009f3a96b614d3910a6134d47decab373df8377938058d7fe207c878de9a602cdcdbdcbbab648ec124dcae5552eca08cd6fe66d510f7e1838fb83f7b26534df53359f2855a743f5773d453799b8629ac215270c955b1ad19a90bbd09630e06b3c9f0056ddc96445cf91e4624acbd190071ede6b1da35f0e082e12f4637078d1de8d22405d4f511d0a8007f52135eed71a31ab8df26c89aa2fc1605674fc4785f86273506367590417aa9a0d43ec5b1a71bb20e2f6a11979b1f821ecbce15f96aa6fa8cc4060c69a33bd5dcf12b817908a6a43f3c66a2c3b5477b8d6ba8a35b04d67fc336452b454eb6f3c50f4340d3760f4fd32982bef7b5a7fca785f950317fee292adc70d8d435c546b7f8e89e6a47210685ba721af8cc8d06c0ecf8036468050412199aa50c258bb1c79886e7b57ec03bf9d21f93fb51196df15bb1301a7a20e2a08b0173e5cca179c484b21a41e9088e2f306b5d0062d6e0fe6f10ce4dacf117a26deb35bf0cbdf99eb4c45c1d8f214917fbf88e623d820028cdb928060d42b077901a79ef1b73cb0e62e59da88a6e9752cd6742b53ba2a2242f07413586b630037715da42e66b5a16e1c499afab291aa9231303db4daf175d8376f2b0de04b71f6e83bff4060e36fd253a7307ca785eb94dcdf4c2ce49774cec6bd664130baf05fd653e16742201837d145495b27cfe983872a666fef11833592dc8ec61fd955715a9fd3836bed9198a5d5bf5cf1bc9796bb620770472133bbf46f9254aa11ceb409712e4326a673fc9d919a1ded48e9e4d0bf8d889105c0cb4668b935fece4347ab0079f5529c0ae517db47324d61710e3d84e0af63646e98a1cc617f4f6ea8167b678f3638c80e1a0511f645208c3818e819a1265ef783b761348509e6e0dde545bcdb0a5dbcb49218203181b0f92df8ae961299e9b43218cb5cf2fd62790198c66f03bef1b6f85e415fd9f1cedc6070cff1fe76add93570190837c41c4653ed67c528ea5e5d8ae7ca78318fa050b618f5eda6d8b4ae3e087737b87845dabd807a5785e58ad179f6c4b00025735a051243d0210bf38ad442ff8acafefd61cf00f1af8b639adac3a90ae8275f9704cd357a87584ad87608f76d651513c50f20040abc570d17f0838e8bcd12cee2c8757d882090fa827d2e9472532ca764aeb8dcff3257722e05d4713f8ccbc56ff95c8714afe5070d231a75363c687f927d11119ee39486dee8780f390b898e8ca5e675557edbe1c9e19c4e75368a851b824e17f5b352484abdc9b33e3e80608710ae57919455ce0f7962601f2e1b41e981f2e783265856ef10657bada9fc97bd18a9f1f7cb79f7f2f3ee9f376183c2c510d2ec296896675351fc1f985e1c26b087280ae535bf961dec2a85c9658ca5b532e2aa7dcfd3195135d2d09bacbc2ed1ae184aed64c9efbbe299896b0da7b3505853dc151f3a270bd4423ddbe544a3507fb7f3b3793553324f34bd4efa0d67dd49ec3519602e5a6eeda650840bba90e05d67f521657570de24f7dc540085855a7929d0bd5cb93d8640756c064a65a0318db72a1ccafaac114a2b0d8ac9f76f22240fdb1ec5823da3f4b4edb8c2c377cfd9a5151b19ee5db0b9d29fbd871a3d244385052448f826651f6cdeca6a4f7e49cba5a9efb2f17c03958b8e1428e4c932107217830fc8537eead4d5a3d7e89e330272b765f9a39208e332b8d854dace2e8bc58edb183b5248e61cd3fc385fdc423f3aeb1af1c01a5d420ce06c0d6627b9a709e28e8e8c46b69b359c746c9231f9a1b971f869f61e5fe3df5849cfe17e1b21b86a20a566cd63cfd6d7075c6727ddc1ca876f7085d8a13911851b16613b9ffdebcbe6f209b593d3f8b1f71543b821d0189e69c3ad40c7d725ef4b456c402c66f6b3bec2322ef6cfe2cefd0d9ebd262d619bfd1b61545e090184a3b536a13acff82177c7764c3b2c32206fbfb7053078d59cb57af65d26b6fe8310d701733220c32d82977543155955b7f70dd6330c3704f0cde2c47a801d6ea592bec4c4bbd82ca7e88ee277f0fda388dd36ff4c5f202431ea01c6c91b2c0ca924d804ee3b0fc62c1e9c4c19c2058e28889b1e71e132252fef37eea7d637f2ac8bd090941c02b74fe77c7249a0be10d624bc265716c92308deb3802e601853fc0aebfe138405ead75d6f0881fab9285b29b6b35adb070b808e7d658bea2a9e55d02a8db05d95f03fbd67dd8f0ea22736e02b808a58bce4c5af49fe85ebe15b2f9942a39f83d954d6234819955b63f01feceaefaafe491d69dafbfca557e16a71ab73420f8de82dd29de03a87affab90817a534b2561996dd93fb6b499bff96d8bb8f826b0edc5c1b6130c25726a6c29349ca243dedaeeff883ca2e9c7527fd52f0bb6fd3bcc152f5d7a38be2224e2040d3f2cda1df1058b16b9b208e44bc014d035ac5ebbdaaf48360b9264ff0fce9f98036c7bc70ae46ae2c941fd9f7","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
