<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"0f74af23bd7a7dfb4fda720460cefd89aa19ea8cc67555955a2030257fd39e35abb4767eb41be696ca3d0aa3a5c72916738f1bcfbbde428d6a70be3e79181268f33affa1bb98a70eea424486839f986bac6ba9f1b2dc1d48966049af6e28d80701a1a7894347c57911eff196ae5ec25add69554ea283af6267b0093adc3952b638f11deaf9ab109d51ef9db4c461c419bc7b6824955bf00bc5354a0311ef1eadc3f59f2ca157f2828bfc1b787a450cf229d540a05aff1878e32c0fceb85b1ef07e617066aa1019657b7b061622191d261f5710c2f0924bcade93b3a5bd66efc9d5b8a6ada6931166d38f1e18d579591d6bc96dfe0131819630feba495af51dcd144b3c402254195e411c41c59405d66e5ba86829856b7bae6755bcc050c453dc05549a574efc40412fc1a15de42c66ea5bcfd04d37a907b2413cae636d0d7874ee7808427db993f8107403392e151d4a8c3581f957e53d5238cdb652b87e5ec18120a8fea81b1ee37b4dac0bfb5e953c2cd536bd9e3304576d17cf5737765802091eede633674b6c01486c839c05c97eee3792c056860f3728d0dadf5a3e397fc6d38ef11e9c9b920093708530c3d97431d5cbe7e380f17eaaf564771403d225952cf18c79790396492f6f5ddabcae9b6c9ee7ee7374757e0e1f77fbf184a1d5f36960de02b59959b752b72d9f32162c01535f5d6cbe2c06bd4d82776a0c69879053740c7ec3141c6789be5dd84f8d1a161380e3215bec3dd15f021896b3677e39b204aff00c75c126c0685f535b4c96da1f4ff70034f863cd13370028aa8e50ea5e67ecef457a5194eabb7959be40adfdb0173843f81a912a0f56472d410407f18d8ce85d4f2d8b8ee4401e13c2747f68ec3465e42c4303d096704a9f6a99ab1b2399e34e36a1717ca8284ebcf75f4f0974e093e903314bac92fd3b081340809bd5800360fe6cb2e84e1139cc7f525d589d5390b1f257316182c2e7432abad20d6f339ec0992396267e2d264480f88271ce2374142f762826b9a33411b165ed71db6d648ba44fa0dd88f06ab4a90407757bb563f344b667b2c4bfe9bcf2296f7db958670f388ec68120ab6fa042c228926115afa5e3927e438f88e9a691f9ad871e441c8f5f0257bf1633805620ab19ce8346663c6295287f6a1ff8d95678cdc404097fac799f597a30db0e0f7f26be752b29ed5a41921f4be54ca2668524261748ce58cb046313c201e3aabbb7ac9f6b3ae66ebb158d211cd1e9df7c048d1504ab0f46203b832e7f82f6ab92addca1747d8e027b777648747c810f1196bbfbcad10cb2ac9c23a9594439a22cd32bae2d5ad867f70f8eaf23bad4d44e0b38df76bf678d7fd0c27647705694e7d3b0f022f074ffe893d13eb5fb54a47ea06e8dcf0211975950da5fbf3fbf9742614a88a9ffe69948d80f65d5c10677845eca411afdca10c9eee0727c3617dc3cd1b023044177177dc19cd9eb1f2599d7b2cbb6080344b74bd34a4ce38d4332fc931a8d24ea764f77f1b2499e9e85c123f117782be599107dc34940b3e8734b218432706a6c873c79ef84d38eecb32565cc14411c79c5e1b9898f03e3e2430494e476cb400c8d49cf4ec4dc38b1cfdaf880c6ae853569e3e83346eb9f7642a2c8e00db201b9c51e091c06ef493ede10416cbeaea4ff00f6163116f8bd77f6847aa78fa472247999b4ffbb45e2bc34944c938544ed507af68debae630e50bb5617220eb4b0849e84fb950b1f14c0b14745b2728d97e4b1edd3fb00e9be1caec72f6c83bd5d541de6f5935482931ca95486cb88b8dd582cd4d5230d55401ed495d5170ee4ec34eea7ccebdfc5584708f6869a8588ac95eae96cda8e6ab84ea12b56464d3b003944992dbc2d3d9f1e9aaab1a43a42b11f97809f4dfb9a047b6cf8e0c4e63d03f2f08e2a4c60e3e517dc117ac50175e58a7ad1a25a9acda02dbfa857600ee2eb8db8351b9cba100b8ce4c88efde4fb327e5c8ed4bfe120ec15087e1c5eef681dc1976e35eae4e92262095da173c1f98e6fddc0469760c4c8f255245bb136da2d1e1397848a1f61eeea063e62ea9a5d15aa8880423683bb51affbacef8e73f419a7a6c8394dda7f21b058a14c899804cebc0a749454d3ed981bc264775f1c570ec6c0e37fad4dec58dabb2e31a92b7ee2fa2d797c28ebafcc05ead2e6c26e815aecef7e7eeea99df21d5b86b50f1a0c9977fd5c55a4a68489bede630c5c42bcb70286871d0af08131a7c21a70d11c5857d006fff1c0e37b26653d176cea707608cccacfae92ae076307f9d2d0cb3ea59d21a7dd5993382a5bbb49ce6f6e1a00addac0d63e7183bed7ec600f09720fc28cc107249eccf66e86b3ce5f2b2b62b434a141ecbc8179635a5737b5f3c943d4479dc9b5bb83e40aa2e3768293348d0dace2ec62b0012d58470c4d28d7107710caccd4dc016c3a462295c51afd856bfc9a0906407829fc2f20da9cf05d38814fe85cc6159d3e231eb467632f3e0d468c0f39d358ceaf1420a084d3cd4a9d78510f4bcef5ceb6caed76351e9deab9ef75dcb18a9ad7c5c6331b7f5e0ecabda16ff0ae4599c52bf92cb4489592fb579ce947e81d94c73bde408dc0a2f8e30f9c2b7e7122256068dc045d64a0326cb65dec7c279ded244037c32ac6143ccd85e9f5875fc6e877d5b228c0cd8b3eac9b888fb20c0fd237bf50b8993166cfa7ec50133423b66399671f4f308133b3f37d4c24887c56f048cf39024c42920a25442624b9616e77a37f40edf6c3e91515bbc300b5d1ad56ba218c7572328eb02f3d3411ca846c2e4ff1e39f5b6a199ecc75dfda1ec9b7c12631778c2f25c79d6479cc8096064485293cf1c24219577db5a0d17b13241c4cdcf971bfe4fdde017409aaf8c609f0dce743f43af050eae08fc9d90884298618f538b909dab9d75d074b86316a0c1b873a5798269e6f7e15853e7d9a270147fd54d45dcb7138932a1d42b4e97dec70a3209f79722e2d48820b079e1553f268b6eda43c81694e3fa81db1de2e853494f0ea37849ba5aeedfcc8ea0861c77243e6fb44f6e53f8968320e8cb642e0bd520db92f61cd336ac2090e9871d51d8c409df1b766b9796222e4efbcc0cdcf9e2e658e4e5d914b0c74b01663f4f2c18349ddcd3d4646de8fa42da0a1fe7e039b8975b42bef95b9194e4dcb4157c7166f78db8191c5e72a09dfd214c1f32181df549d43cac6ef960aaef65152d68930d3f6af7f3b7027130fba75ad4d391075817727e31bb26093ad317d554443c7c1dcf88a212aa2e96a83098e3cc973d3edfb11c3c1f19bac7aa80ebcad47e78ef4ec9ead0d325375c8b4b1ec8339660a50680d18d8ba71a7f8f6f95261dd5215ed6207e36d78b7c79ab6534a49f0d4cac72f179ac41171b3d6e50b1fc2df12557e4503a711f6ffe83703f3fe9b8e31068221242da8e16958f422502eaafa923a20e79206b62a3cc8088d1bea6a291035ce352606c78edfd205cca3e60f33e2edc5e6294526f94d11425d35a24564c24b7aac843efb194eb56d20dfa882b5012407599a991af20bb459e13a062ee5092d97b8ab41029b39d31afc47170905b76f00a8a4b57a6a14151a6573d276668f83178735ef710256c74ec109b089fc8888404cd9836fbcd5cd7752327af78554664a3b14aefe2a762c7d0fcc8ff5a8c86ea167429bf55dddbebf4598f611c3d6d971ad7dee4d13fdb0cf101ab0d949fee249eac3548cfbd1c52ce512921c52e60ac35b54bb0c30ba92f7513b56c5f240abba982523461d83e12c0c4c2cb280a728c4fd48abd508fd75f1d0497cacffa4b9f4d8ec0d68e8fce676258f7105ec1127d17bb41c5af9181af2704d2e12d8fdc3e1d3aa5828eaeac4d58740a9bcc254204394920e00a74231ddf8b5d76290bf2e86c95d1f4787170c602428c76a285f0950370e84ef9538de3854b4b71561fc9cff1f853c95ebebaa302c11004b19f99dfa669e40826392c84e0d9e4e9f016a1c9cb84f009b342d581f845299799a11e199ac3ad9370dc22c4e3730550d356f9b7059aa70d6b3172b9abb0ead05c5007ce3fa33ddbd09db760c7172497d29c542ba09bbb7a4f87f23427f5a6468f471579ec517bb68ebde4de60ea2f5ffe27e1e3c4fa856ccb537e534c6ce89864a0437ce22441e50204ee3dee7dff8d6025f069bca8a13dc24d5346bc035c3b6dabe9c35a30100b38eb92e1191f08acf587148b3b5da469fc2239f97c404aa4f0aeb91a67939918fa3ba5d1910559f6b69c009378f459d0dfdebd31198e4f7562cb7f110c66139445288edfd849babeedbf0e989d046e7d6f3aa56710d9dc57a539f8f0e9335ef0fa9314d9052d85f129ec07f7777696c0a37fc3c7a559107a99500e1f6325bdd93e32100290ba544c9ac879983e4708461fee4974255cd61f7799c237d7d24fba0f646075de111a75da4a3070caa2a618aaf780b9f981b1010ffb352fe3111dc136eb5b19a6235fa2d29aab61795c2cfa61326a2be02c65a72b3b1861eb9c3a95c8993817f91950a81d4d617df9517eb020b161ceb9e26a543e1cddce88a8a79918c5f2a263308ad3aca4b0b16be212acf6ea86ee0488fb28e6d4b21daed0d261d884e53549e38049f195e1f0b5c5c50967f6a05ec396874392e58f8ec7a88be40db5fd182e9c63e42f1a2b1c41399c90641ffec2c9e91eb35d672f8d3af97336cbeb5d7e6ee13142c1dd3484f2883cb6849c29104214deaa3971a2bcec443dcc279affed741d3d1bd9e373813638689e80c2693ff43af82cdfd64d9c4ccf092aced69ae27cc8293b1cb67f4bdd9714fadaf21fb3329951a008c7926df5d177bca662151ba951f21535e43ed469283db57b881021a567553dee2d2841527014e6fd1f2591d8eb8c48c6a9e732639be7f74d86fae066c74bdb675436af3c5a0f5c2026ea0f4287e993ce721d88060a31047b8295f0eddcc9de1f0e119c67dc25c9f08c2e3f10e309978fd8ead0bbc1848eb58644d0a97cf5ca7f3023287cdfeb7084b38e64e870b7b23b82371c7e875e2e9d31a1c0d292d4312b8fde6ec8e52799a30a668ec4dfb592fc59dd095def926492b8c8d16aa9769731a7069aa58f935736a8e70da90ae5134256e3b10bfa333b18535310c89add3234c4ba2507fb3f55b28bd8772454c1635d038e27fdf52a4aef78c39771f8ab86278b82c5a4c9e08d85dcce5a96208b1f9f79df03bcf1bb2ff75bdee8e04831fb8ca685c6eee9acfbeeeb7cffc60b7a62a8881b884e978277627aeef0175cc2cd9644efd91a5be7f7f7c812cc43c8690978dc4455112483b93730f45351cd93ebda7b3ed747d5524c3f2545054778b6467034007fa5143c4578cf703d686174fbe6fbd50b6ba13ad6ec1790ad732f8f18f3a2da19ef4a13cf4b6d8db5ca256d4f42d6b7f3d49583431a606bad64797db83c986797965ba062553d97bba0e76eedeb7e5bab600168919113ba5e73210541ffdfef714c2fbce6afe8a1dcca83fa45f5403beaacecce9bb348257fdf132e5676275ef78e4022cc6b6dc1d49f3217e628a45b2022836c72aaf5d17ddff70b7b9844f9095b7dfa150ea9ba68253cc59e6c66932517431b5bf4a9a8a726465b0f194130409c0263559fc21d721821d4557c06413d11f552ad87e595e2d999eeca56cc2b70c06ef4f75cf3f11c8b35d147733af9baefaa07d231a76e06431d7b28a43a38ec9cd3ed26677be122ca1ba15d91bfb064f58ca2b451336264de18d1d8cbc4d5e8b29fee18b0109347b629bd2414fd11ad73e2ad6d5a3653a4a4692ecabf061635085372ae7c88f2fbf7e4c64088cedfc52efe391095c3604b8f081b94768a38c2fc12507ef0ce86eb427935f1993f96cbf00b41b29c8247515c9dc220a79b105c42281c149480c2432b8363e4346a5845e042d7e62e04799c2cd67d1a7984bb9c91535e569719dceb13be6f36030d8780cae0d74dff81165688e664e8c0494dbaa10848e58dd8617200dd42fc0059e2a7b02c303c10075d447717f4e20c1172525d2ab8c46f11a63e1c8f34ad776ab216d27fc9a928e55239d1bd7743ea6afa8acc39bc08ead18eada267782cabb2b6a8c4309a019cd082e87d314f3f836b3ca9d50c37ddf7727de505e8072283de0f1b8861dda70333d75c89ec01fc6240d83019da75d10436b7682f9b12d2c47486980171c1e48d3f1ed0afb25c9e1013fc8216eb537c24201ece9cf629ade89c4b8c2ba0e903159f940afa3ec672fb2814f44db1d26c8eb293a386cad91ef3061a100d54bc63c0aa22fcbbd037816c91b6a4dd83b32d0212aa8ba97357dccf61ea5c67f8d02ec94b37dbf33826b7eac5df625f22fed4dedc4cc3dfd35a16285831995212a7d0c3bf1461e10905f2cc4acc23f6284d62e9123e57603ace5b036ac75c0ff9c727fd877f82576de8481917a2704d58e91ec3b8f8e2c75e777bc016dbc5b263f660bf01ac9290cb842add4c0e63d3013dc289f8d6dbd25a53f56d1f4d65c8a6eaaeb777de9808cbf54f5c5f2a6f2b1603af32c10447cf495731f7fd19f65c8f4558cc638a9046e43022d490b6b6708f36226af4f5c1ecc9ab9fcd07abc282fe121581a91354a7c97c44da5f0426e26f68c57e13b383defdcf776bc4f03e50308bbcb58436f9a5daee3cd33cbd7dcfd00ec0355e112fb7c920161e505e65f70f4971b2deb421e445baf1eb0da3e9b7f9462f06bbe2e801ca54769be33d26ef3852946d5cef1bfd5db1affd5cff3e22713b1cb01824f28edc49f0265f829f8ee38fc76a5a9d2e3bd5e3c629623a13819f38d7a393c7ab67a17d97d8c8f3d285bfc4fcd317331d29dec5db428e2ef9cfdce75f29bda955bc16030f8b64156ac263845438b951d4256708e9425d59c8c6dabad91f839495d1d5a003342aad020932ec1008b5dc42c1ecc9d78e9a57353ab7ea69d9cd54a1c8f97542a4650be676bcb00e6b1701074507dcb90a0c7c6dd50eebd791187a3e0f329a1f28914a187a1d70ac6e7a63a48b9ecd9e9b06862b2ae0dc1d813e8ffc6a6c78a4f63297c66ed69c40c5d4c02ec04b225f1bbedf8ad2dbc4a0f9f5446fd2f6254fe5aa068b86d8debbb8b4e284c27208d7c12fa338301772f0a0cd6d75ab267eb83b36618ba9462dbc974e977dfa7a688228ee7c832578a490df79bfa0bd729f4f4ae1e0df5908c34d8b3885d100796a72b557a8e67f1f519b055570f28aea549709162a8a86627a34c824a36faf4e35bce4bb4cd1b1ed9323c26b164296b661905e7ad6772f9bed4c8495677226c5ecbf3b1f3ad9f011b5d47441fd4571806e6ccf47746e791aa8194c3683024532c004dd20708ac130d5ec1b594d5e762672e16d251a5cf0e4d0ce457535bd3aeb08b4713bffb79aa75eaf56ebb0945c67b92b0bf546c3db7fed4a974ba77f9aebb1c381b14136ff8d1613d812971df8b9c65befc30e3718a7fca0009c89fa00a4969883f2d469336b602de6d6328a383c6de35c6ea84a14c912b280d00012a43d132053561e6c50d3b2117145395641838da05fe3b157ad5cbeadb9cc0433b1b4035071ad81828fc0ec3cde94d7cf6a6725fdeb20274b640e43de69e55fc7b314fb2e51bd2225d2a6318eef4d087ad4fb76e0d0eb8c959eac5e7b26cb2658f91779fc7547bce00bc0d1dee0097bb64b8e63aadebefe713edfc632cab3b768f3bcc33d0b9a02d8aefe6c0030b1d47908fccc3fe0c1ba4b749bce9196192fdf0aef7dd468a49b7108d3542caedaf6a84492f4a7038e252aa5758aab2f0873bff7ce91fdc3172ae66faa43703d8e38f27a74ec4acec5b89719868ca1735b23f985fb8a157169b5614a4ee6048021bc35a8c6f355b2b499fa7c6ee6d10778cf1ca3717e8bc18aeae0f56b402f719708053769e4677c18c61378f45d391df35fe807291e18caf2cbb3ba8f663f6e2e08fe381282baf65af4f11575a180f07614816f115a8013684d0570d397112fb08e0f7e57611b7f66e6a7ce1798835d8c5c6d50e8ce772ff5bd5a68ba9fd86d52a086256c8a9aa6f2e798adbed844e478065407e70c6f63751d56eabe4ada6838a821dca939f04b224e9ad851769f79a6925a1cc84d0d5e8c2079eefe9969b6beb0da862260eb0ed2ed63f304dee2d0b8afe1a0f45c05633f4aaf7f3f84c225719f0ec885568063353b3307558c9e9e99659b2ec8001279f653b58f08d498f489502b613b5b1f9b923dcc1262d80c16e33c27df09e2f3e07249da62c3826c3e5c86f81154471f12b9dbc16eeda217f1445a844b70b4d5f645ac7a0f5869c62da70cd28a16d9d4456bbaf4378f91a6d816b02dcc429bdf9d18313e2c1982247f98eb5b23498d81ffe8ecdb6cb639d10092618a7ba9fc54a37168400a919b9fed6406fe7bdc6ade723b5d85b32d56f527e612ea1db953734cc2421baa5b25126a9d53f346614ff8b6b7ab23e86d254489fa286b1be3e555a0a6dcfdaa00cefc880b28e31b356a8657fd151cee38573316e7d7006ace03142839ab4d16b2f93fb5707e9ca40305806ac6af52f3de349d90ff3fa2250c3b57ceae8187205d7a5bd8f5dddfc34a552548e952b227f014299d0c6ac2f93c23dcfb5a52975dbe667f083b0668155eff743d285382b406c75f8e136fb3db710c44e798cddcb94c9f51dc68c4018cdb12041c1d82bc3458ca7c45d047e34fa17fcc5c290cd77688fcd58002007f44f45b67849ef81b0a1e7c8b91dd3b336b9c0214454d7f6ecd4d1bc99a77808ed883d9cf8d93f1876a07dd68387f72ef27d1931decbed8a4bcb3878362a03e0f323c70d926c460cccb176c44b44569d3bbb20182f9b65a9aadc22e261907e2e7c17469e0255fe1839ec0515afc6bd160abf58e8b60987eb2f6a2f0ce3917e46bfe46a0789a46f7470e6ba1651d9434161846b8bd52ae3b2d2e33bbbd7b316483c1655406e66fbf9d4c03d01cb5de9b8ca09c7b79f0ef18b40c15c73c92b3d59a692e9419c6fa1c39d15bf5080357eb12b78a80ed9085d9b9213e483beb85e5f3e1b71a2c86be4715ee9126181d98bf81286e42e12015f20c37226a5f08b84a46065c8f59d4382b075bfffb50f5901cf8ccdedb2a680bcb58a11e900b142464140ff973f81ced26b6d1a80c1a4c03c6aad034ad924007851390688e2967bc3c354170da4d092e481de6519f546c60e642c20774ac41f3cf66237e37461db6d826dedd1465a3f01aac40c2cdce1faa4d0ce9d5c1c9597d6dfd4a85152b9e36204bae9cbf33066ad59367a77bd79930ad82368d548351fc7ddd046993bba360d2b47306d16ea6ca2c17b9db9431c5188388c6d6e0aff4bca5f94ab67ae407f7ddca7f0dd0561308f496e40ec3d54664aa35e691be076f9dbe34850e95e9043d09fc8d31ceb728b3e18d757bdecfb7cd6cb02184dd8caa923d22d258fde8dc96519b7cd8f23815abe6428c20e0a808e854e390f0a72af55cb01f04fb6ec149ca406882eaa5b3f1ebfc7ab799ddfdf6e900cb88bd31f3d60e08b0cb278e125cb1fb17c9e0bb0ad1d100ad530a0634c2ea9aef9b4c77e636cab0628ac14be16caa4eeeb2587c8b04d37adf4c0aee98305d83879c961bb67267c327fe4d864fe352b100440d68d9cd50e7fa59b3829100c7f58e84f073e0634a942df02545ebb687db3115402476a377cc67989d9dc3e653afd41e96a0692bb97c2af8ed181c2cf7447a6f7ccd1a081475e5f22fd361bd836d87ceae569696993886c4a84ef657b714ba20388b71ec7d10860c60b3065002804707a19a496f2e6ae7390c9001ede466c6d9cbd292e03a9663d7172117484cc05f118c0110cba727991b89e5b3587dabcc52a840984417d919fa69cc28013f0fba40b243acb2f5406cd496a816057f93dc6b0eedc703499d507066827e89136030706b96b91296edee3eb8f9f567343e2778485a1c5cf7a71701eb94326cf41dc0346dd9f51a1a0deddbbe3d0e7e54df1f3537886b367e1a38f08baf8f7d561a15c0b56cd5c50cc6b4ffb09d9150c499003daf7a9d94a47686dca6fd2b490aa608164451f742d369b4288bc319d869f946f99b99905370c3bb53c00b02e5cc72320805a7e3b88c760e2a033329b2e79b002075f4b2eebad49856fc6902466e9411b51e19a6c575185b81346f9a47f1aa04a304577065afc81646f65245b4b29dfafa2a86d24f75d00e387a48a0e8d419f2e7339d4687a9993a715513bb46e874713e53fed4e9ad55f06a29a85a125e63ce74e7e5e31871ea08187f2cbd9a4465a3ae13710584eae59e27f47704ec126eadfe18d9f14033eded831b91bc851a826d2e7ee96fe7dbc050ec5441863464ab59d8559a578320ba3d014fd37d17eae4d08b1fb1be47528a2f6c0e01ea35e75398156d2946d2dc1a9af82376066908fc2d48184ec05b858be2cc8db05c35af3dfdcdb5ef2320ef32e161a8576b9d63728d828d59997e34779f38d7fb205c2ae59ea916760f5d994e801fd75c4025d20b70911fbf4884e6849b4e8e9a648d5c3e3d5d1d4062ce043c28b1821170b5ec3732de8fd2dedd96cfc3fd3ab86c380e949599805cf71cafc692e735fe373b8defa2ba719934708578e0a3f3d5b6ba73769e64e1cf6bbf5a130b942168b4af53de568234704ff5e3dfe7abce36b186bfdf8eb6bd72ecab943cd0ef430d18b17d0c86020d8f0b0db108f7a883e68779c8bc8d6951786cd342b95d985037688ba3db0a6eba332f0a52f89644ff530d04517bdb6c7183ff0ebdc437b235a31b9887acd15f785893612c36496fefb95c27769de34381ec0ee46b33e6ffc04805b58244dc524207ce50d91bdfdce46b8ab42652200e0ccbf6311cbd1a880b318b23524d0b35af4f4196866f491d5309eb0109ca5b05589b89b2d0aa901031851d7c3e511c7dad93d3042b3af13178905e1011c1353f48c9ad3dcd08cf281adcc255089f0ca71cad9688e554254efc8ddb2e1bf2ee0ec88bf5153a361ac2f635d7b8c8f3a4a5efd249dd2290734db7319ef819f5c1f2877b6d09feb99d62d8f7ecb385efbdc68e4ef57f14defcff9f9dcc418a067c35e260d11dad87a013b11e35988a75a74f699e670e8515f773c6a64b0923c2ef3ade03ca6102c95d261df9eb4a44fc7d9cb86503aa81add6d4b9c7549147a5add3242a38cae5c09c73b81d43bc417c0be70f736c044d5517f87d516114583b83e90327af042768ecd26f1246df320416a8972deb8926c8fa88b80c319c4b842a50b3dde4277750b4c8503eb28d6ac1c62eaf0949466e92e3b9865423cd05b5090a9ec5650dbd3d45fd98faaa1a1dde473025550670890ed710ef044dd6d4ac6982018dc3fc04080f74e8783cb6982b26e6669316725b8327ed73a8702c67c5bc666afb9b94de597a9642fbc51006d683211602c2053b2b5622ac1508166c5624a59276bc7013e880547b001447745c02512c2932f7bc9b3c2ccd37992cd2459d04a3aa912d136f2c98827d85cc4001b8cd9eb52dedf529032ca826a0e63d343e337cf1e8bfdc31954c6212590741bc6c6de392340531ced8f8f26b03e69eab7831266306f5b615862c09e47843f7424e6697832d7adc95c7b9ef02404b4d0a6a26ec1488d1bd2e1621e3f01e8a28f2aac5f6930b40c926a73454fc41b041fefaf3648a97be50ca549bbaaa5d8efb1a0264175d379ead1d9f831094220f23f9c55840b1b01e18b8ab9e004213191caacc4efb07e1546e998a53da05078ed488de926a8e7ef58a68baee68424c10cab4a39f021aeb9637fc644fa430c2e518aca95a29ae328774e20825d1afbb2637c13978bebc158801cacba44a18c6c2fc7db9e4fca64cf0f0bf52dfad779d9305703ca836f906353ed996d335dc4057f942ba28b827a67caccca2fc50b345058a410ff292e3afd5eee611b10af29cb8bc123393bdd622209916e67c6f24866d26c43d3741407d5bff9f3cc5fb767f946f07f5f54eb92147c70795e9444aad4e1f079de9ede73f8e4df9c8399b6973c15ef66896b7f0e30edf47b17dc8e48a2bdca59bf35bc3616875189c069730403fd624da9d58cf4cce5f422b5aa0a2ded33a3a8288bd8015eec890465af08fbca2a579507a95cc91b67552ea60b3eb7f5dd740d439a5424f57b2c768293301218fd622d7ef7719513e2f34d3ed4b48dc8e7234088fa75b0900200bd95873e019f02396fe53ffc329f83f08e248996896ece442e04785592ab0b536c74fa3227eaedc81792667dbc88eb9fbff2eebf6810d97a762875430190307f8bdf4e0888abaa309557208e878c1ba247cca54ec30eae53a8391916937b263c109818767ae21c2b3818db90239ac3285b40c408aee1f7842854169c71528d4f52851075daab34f11f423c04a8ae00ad044ce8b55ba0ae745831160cda8bc6e65b188822dbcc363a1d5c35a4461f0bbc0e804d347f84c71c14f45670ae4c91782ec097c276be1466bc66cd197f4a3d03fa33002e264ee5b3ed7921ec392f368a0c484b3a56f5bb9cb1ad5f63856904c55758dc70e60ee2ddcfdf27302344e8c0981d846d8a6090d04fe57a8c7c5e2e50ea392e714653385e7c5fcbcdf1a5338a4af4246ccf38c8fa172b904a5d2d06ecbe223d45227ed86c7ad31cf92b3f70a7b97647d779f7c47ce035826be5d239824d0da543d2634c16be5da4f079f077964e7e2a82fdbc3463aebbc1cb0f318d37eef36a2ef333641b7871ef579363cc661db46d3bf09a98b3e8856d7e57e97cd79622ac5801daf2aed9aea4fea976acc6fb883e3eec2f941154ab8a161dcf27d0b7a0c34f92e900da063137e4b3aa9d7ae041b612c567deb15724907247f35337415e3ee334772ff6f561ea348621fb550ca53f602ff79110bf5b9622b754a8004088f54661159d54a3d95efc72f045bed5a0a9a526252ce7e9e31cd19016e86725be73b7c8b7c93f0aed5a1c84fd923c8e72761281ae844f9016aaa16b4b24bde27370324d2bbc784e8c84bcef94077f4f7e524b23a72bc384cdac9cf1e49cca7393f35f75089f6f21a8ebc0f68d90499581ee5a409ce73f817930fc8a96435e41ae53c1fb3ecbd042820c513550670d2031a5f34bc78410f35b28b9ab5d2de8efcdd21a3020442ffd28f33615546f6dea6ed916b4494bbccfd1e212c3e217eba33f2b0c80a14e87d4260a1c517bb4372d41bd57261a52da7b47d9c734686a305dc8a65e7c9a27818816852385e2532cef9e55cf335ddfe3ba1eb1a609cfcb78ad76a378ae40e52fd590c82294c5d58982902c2b8f18009351b76bdadb8afdfb1eaf21ee626a1c2d881a7d5fe5378e76dbd3bc50e42a536c1818218046302802ce16eb95f4cf5027f8443e4a401cf8914fa6e1a14675ed25ba4cf593c7053fd165e54c20b2e35457de59c603414c425bf8152c3ca81b504252cdaec275d905efc147db0da622f5239ef97d47e91592499906238e49fcc371e3a859be1f40407358d7fb80610e3d9e62141facc8d236072d09e254736ea50a6183763f21e754fb7c7bc33d4bb227ab4086715bcbc435d7a60cfd31abe35cc98adc5cda3402354a012ce2d7aa5364a7cc015dc9c1948eb9d1af6389d90e07a1b7a46c0f93fab06a5e83fa0e77efc52c7e01a3a96063f353522ac0139d98bea65a629bb87c46ad5d3d70313e2b0167a950e827a585a39ede25182624c9f8b20afff72c4ab756a36f1738109390df22e5dece9d7f8816f4a9936a9de6732b52dbcf932bcdd27d2c1c51e5a05bda01effe245c25f7f7b265d7589dff4d89d70aed6dfc1d16154902d8b90a765547e2c5a2f60054af4eb260cb1582ff9bdfd0fe3db921f64fdd615b468f13c52a3ff7a35e62f6675eee7a6c4ea6cbc4b385eb1335bcf450dfcdf2702f2bdefac0c3d1b3c75fd873a5c32c1fdf33f6abc4d784267a005fc7e5a1ba4dd9b09a6f3a1a68e2918ed56a20695a5852d93b0176dce03d294c9b7ceceebcb2f7805a0179a2163bbd56a84883f3f80416ebd9e308de2bdf2b649b4dd8d8d4a0b28553759a24c30d3b8ed95d33744a2edc7493816629026d19c58e1d17fc6c8bd4e24ca861602653c341fefab8b85fa503b0f43ddf2d6c63f6547fa9541cd92a9a2fc62f303c830179adf6c387f2fda7877bec30d3b374e12d7fe6f0c21c1c2507e484e10d7f354641393584ff1a0a6ddda3e1ac9b36da9bf8269345b77c788bcd4aa407e8d12a79cef0a344b21ae31c015f11a63a02641ceb5aa32a7e533342eb6b99bec0fe6726ea8060b7e119b4d2ae830facb69a512eb4275f87e554b1d305154320fef8530961c2a844d448e19a129c9cd59cba1e5fb8a5caddbf95a0d0524544887bc74a42e3455285cd6991353f731c3c6237d5d0cec31b2ca309b7c7ef560aa8b86708d9ab7b8694dc7dae230bfb0d1752c56d052c846bbb9da8a872301154fd2f1dbe7ac4c261c92f2c66047960594223df0db64b67e0c5c707f90a26c47e72d5d07543716f050312537177e75945ad2e49cd6847a065941fd6f9c2602fe8ddce899bbf91f0a8d534a94157f7ae2cd2300eb931f88168ae37e0e6ac8a97b3997486178de77a4804cc0cbe81ecfa5a6d14a13e738bb82385ba19fdb3bd9770f4a497ef02e07cd8e283f8a2b3aa5bb6ccb7e99df1f731ec452a0c9ae3f31f114f7ea0c168fde6d1590e3908e81c82b1c33d6dce5aabfcfa83161a30e37c4f5c1657c8d1e9ca80f81477b6c96c6b6e1291cc33b219054bca957d42134c72e7f7132b75beefb71aae66cf287541c4b63976ded9852b5c3c29c16eea40eea01d61bc9b4f74a4ce33d06d07eeeef2890d2b1399cc6afdab0c43237b32dce6245f7c63a37e412184415c60409938c05304ede1a0446fb28c7442ee0674d29611122616cdecb3ab6dad62c436b97d09351e57a1699f1075d9088d687b3ec9763ead325e32a116571971b48750877c0851d125cd7e414c13dbdca113f7204dfc73b9e57d39e926347364c6bc3bc03d5953c4b9673983d912ea6cc879b82af1f0d79e22547882b21b30789d9094188ea8edfbe6640a616647d80332aaf5682b8f7c5ec709ea57c3660ee67e795a9649b34eff968eb05200c310679ec36ba50395382d4397f685fce1481574351b9f475fcabc387d18b301d1e194d33fdc33435e7fc24777a17220b5f662b5c71b4dfe770e8b0b51e8736689ca3b874a095fd92412176727ac5c9668850edc48fe6d0d7def067332781136df8e36d809b629b07b6010be9e74164e3f6028cebfbb565045b2f752e3bfbe3356b2d746ff7c5f560afc33f819312cacf7a54166c9e80e3cb70b7d7fc7492da2e80fcb00f0eba568e6f0e43128e088908467ab716d9b8c3e2bc77dba1730c7859f94b2dad76a60ee05cdb1a792d72132c484961cb2df388439c37c24ce868f84f22984f089e756a48e71fdd418127d77914621f55c258eb1756efc7f334fedd900804e6b485b504ea7ae98989562f2c8ad45c40f9c1286f2cd3fdf307a7889e1d4ebfc73aeb249f9bcd332d9979e12782e42d9573fabf40371865cffb702fcd4a8a6f9e76a489aa32f7fe6cb097bd3c0d1f91890423f04b33260ec4fd93412003437ac63e0bdd701c0d7da812e9245c32d7e82e9fbb456cb7c5d54d3dbde879ea9f2e2b9e3bc5a38cff890ec971c8021c692facb2d9a77c7fc031916784c5e563af20b7d3ef3f3b0f3a2df5ca4e91f3615eb09b0944db2e613a95e20c51b1dee915f8519c09bdb3439ddf3a9d005a2b0511f5617542aa557daa2acba0745c05f1aea4a3813218bb2bc3f025173aa67ab621c0452d1a0cc0d8cf1170c94d8c3393fbda2a559237cce5644a78485c23e6f52b52199e936eb277acbeed934a60ec6e62eb82093cf244df9c190a29b4c7c343a23dc36763248dfa58e577337ee2069ca81247b3467a5d265f58781bfb688c03935274c0c074d82df7b10ba14c96f39821d422def28931bb47794c63875cf6c86c911183993f7d2e2ce7988d5175ebe20e5fd3f499dd72d1a5d7dab67868f39c2b864aa24e6edfebad0e10146a59ec8d06a12d20c162d18119a3388e508c5db6595d2733779f264dcf2cf7748801d02a8171e95f0a5150ba4972edeff4824ec343d2a8a75832c0c00b623b590941dd2d9e33afd336856a790b111ca27b1b684e59b017fdcc763f34af2e46ea428be96a00ad4ef178ad5a082d2909bd2b2c8d52dbb5d137bca879d36ee13e111b7b8834be3f1a4b2bedbd2557811d852732cd6a31036094ee6282717d0adbecce268f87e6b01f15cc611eef6a6a3ded40912fd9bd1c1ae6ccc4df48946dc59d26a03d83b3e8e0d57e1069da148f7816fbb68c194c0936702837cbbf5a72b6778e475260ec2ef882c741631e6389c3f1fa1c51333350919dcd448988fa369f473017c84bde9dd5c19eeb10ae0a75cb6adb082a9678b9961b7175eda8a8e886e61ba2be380cc983c3b433d0fdc4c4b849f1f720b61b96645eb0043c6fd5dbc1d0b730254633b5f9a336adc9a9b74a47b62bf49c50fd702a793ff3c45c7f0ee457f28044236af9c484764f6afc47e82af507d72bce3222fbc15ed8a6965594e1681e84828102235acfa2192ca979f4f695ad6fbefd2585237cb29938a257d4f781da0af760cd2db3b84b98887f65550e51bda9d2c3426147ee2d40d794f8e50ee9572636c6676e3c1678585984855e06b776e1247c6f8d69a2ca12d5fdd9127fefffce434759b860bdac800aec8f95ee0577ee5a7dafe88533ffdd9d28991c0cd6e94b5f8b89dd34f777b6ec7ea9389e4cb294b1e39494be936377fce09bb34d043578f2daf6678d92bc816a63a9c1a33258b492603df3b03afb40894d5d37117ef630101da2d33a0d3945e290e124f9344ea9cefe6cb19566d26f71cbcc67e12aa00d2071daebaf236f1144132e03afcdc950e197c26c3e3c7b74310b80a55b14057007d2b61e8ef3a1ebee03cc0f8ac7afd3c0fc4880c3afa31fedc337271d4709b4549ff06fbed61b9df6c2bc671a031d23645df0c5790bdc2be50c0bf0244010bfe708c02425e7ca805df7f0288aa32cb92b70d11e8b0f8fa29540b239caa5ab6ed3710f51dedb45c3932a2987d3c15a3ea0edb1536a2444aa9a45d430578f9cf5360c0f2f67cec2e712e4341c92c056217c7c530107fcd7432cc047a3cbd9e9d80fe6974b8fc7f29cc5b1f31991fab6fa5f0a5a6f82283c7927f356781eb9d53d76211aea56bcd956517d293645c6193379bdbab25e6f774dfc4efbf725752e9d8f391591e7308a0d516eb975f2dda24ca1336ca9cdc51f11a0a44130f64983a36f250774f9fee5e902b409cf8fd0cb2a78e091155153163f1fa85c2020100d92c25aca78fae81a6a62dec735f6ce5230515016ee1a55634c7930184c98a2d4ca615c50742b9a6ca5bb99ae5cb0094f39f54c0dbf9928e188bd3c7253bd0117666bbed81b70dc5a6a4a6e8523aca1ecbcce4cf1a76316d487e58e68eda39bb96212720ff4708efd22cd489566eb1315305cf1a30d1f2db9bac6cfaf178ccdffa01b55440749e2850a27463915158362a311723403e0567ed83c75fd765d8780fcc928886a85de0aa281053b15efa2edeea09910c4af6b9bb4ab72bd81db064cd037ba1decec6cd484bd1c2952cf3dfa89333c72b3e7a2db4db04e5cbd996e43d6f2d5508e147cd8af35b8fd1e6ca97a07d3cb5de563477b7b68aa3e0f8f41147d2090659248174db125f3ab411714618ebd5da06cacca9d185d1ae08f6ab6f86b81fc75ca0571e208ce3a98fe4fc907a920456e84049d1838b0eae28fdb93b08494c4ad2434d5fcc0ebe7c0036b5206bc307cc9b89b45b97a9ddb18a5d23379b3d61b4b3d43151ab50d0c7e0af85f0778ae12a79bcbdfb7e71f84e3bffb8e4ceba546405f36378cb4479e7dfa09d1bdf9a33feeeceb61efe99c67f016fb2e8695c44dc7ed791abf4e186143795c97a546f171708919ab04b70c44bd12609ced237f51ef2e3e142be16b2f03d3b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
