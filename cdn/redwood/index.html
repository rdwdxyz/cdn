<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"032ce2505ce685a55e0f29a6d44bf1d07df6846047576b112d48f0fc6d0e610f4762b6e62c8d41c6fd5e751d2dcc09eb8f4ba84552f7ddd803301e9b584c6cbe490fec0d47a49003daeecdee490ffee91cc9e89f7c7d068fa7da642d62c800f9a2ea8a853b83326d37921325e1a5cad9f987e30e489d2dc7049b1ddb56ea741ad42b80428d9051509603280ebe85c7baad9122660edf7ab19be0987ce5665e1712479d0755b3d008f5626463eb65407174b32ff8a7abe5a0f60eee76523abba8a1cb94d416604dadeb0051cbc95cea20a8309ac55578cd0c6e9ecfe990ba326a1a8e693caa5a61e24b1dae362bd75b7b0019a2b39b60805a86282ae8456afc926eea84047c18329b049ccbf1f7a4cc9c5f08fc0c3d8908ac45099bf68f394647da378d4ff87f5f390346bd687864045860365e638093f8b662bb144a30f91bea94ee1b63ca14b9f1b582500c4ac76d9fc79befda8ab76544b8e7df5c8b63229cfb30f5b9169ca3e30499039d4a8db7dc312acf19577aa90a36ce310affbd70f7fe90579ae899354846899a8d09d2836032dca7be3501248e7792c169c3ca9ac1a8fb587e39bcc7ee87bf7c9dce3875f9f7f2c89b6f2fcd48a4f695c36d65c5905aeb198b82d2f6f4e78c9a28f9729424d257fd3bfc58e68e8ec11cbbdbb76f89fc22c0e80d112051b3d3bc0e20745fb8f2ce1023a9dffc768557a700126e3e32b6285fa1e573f7da00c06d75d0c21d22784bf65f0493a366e081e237f88bd62d0f671882359c41db10aa9099630363aa5686bc195fbad1b6a29856e1a1a0943905731af6b8914b572dbbe385792f65111bedc82f345b2bb260042d054644a622b7900d68f95043c069a53f76bad4db3da224220930bdf6afdd6fa2a0d240a670c923976c68857b940ff24fd56e15343374693de818ae133fbef44f67500f5986507d0e22329277dd5b10400be03ad3a165ea0bbb5f35ec1dce1ca2e74641c2856a500298f2c7f69327f2d9168658301c5951528ceca72661beee3c29b26cb325df3322d0bcb6e41fd337ece2a692a8ce2348ce793aaf12c68bcdfe9d71fc5a74491a0513e015d0c66088f3a86a4493897ce3eacf2546a7ebd368bac0b0437b05d22f97a337fca15cbf8c8194b9d27260f598999c861040200f690f8f3ff8e898b01fdef30c8966e6331855b1eab5d099f7e9cc478810a09a72bea3d11165632fec42a56002b2f341364f50a2550fceb60606a63b81a9367c7571d925f007ffda224e6b22e76ce09030d7e25f1d4e960171263975f7b384f9ef067a9ad78ff871c9515adf34f5dbb412519e6d6cd5cabffea7bdabd6a1a62f127b528fdcf08f692492d41ddfae1a679496de51d80a04174c54b219d33b7e26f8cdc0803cfaefc4ab0a45341aefee233bdc72397e4ba0e5463a4f69e41423083958c61b6c0398c6656e5100036404e729093fd16c9725fd6ac2fa6696b3b578b436a258e0ca78fddd691a0fb58b68b983adb2861dac437599642d9c1ee3e0df5fd591a766b2f3b3d701fd1d327e032c1929312c43a513390438f88bb6764a38a4b4acba0a8c1b9888f13d2a3e5c3910e7fcbc77a498d5c8635af578bd9148702d0c9883f5e054bf7883f43a5a18515071debb3afb27dda2ae0c851558f6eaa06efcbcfd268e19207fb89cc24bb9ff5e87da7d62967ada716d8fe13e703977b55a703ba73bbae32c9351bed2993c419a55b798dc430f248958d65a263fe2a8bc1c7fc0e06de51f3c1eb38ea2971d5066f47c0d022e94cd4c3c9df578650c47b8c4ea8d6e7b8e67ce9ab02dad97e7f7e5f068a6b922deacaa969a7fffdeb58979b777a8c25e9260634639b350ad6c8ff04edfb1f31c046a0ea09d76fd4015ebf52db1ae1c4d7dc9ed50dbe390f4890bca690acd1a2e453107d76ef596312b3aa9a1705942e73ee02d376f9f1556df5662f2674f9b2c72fe48e46f47d75775721c33a91344152aa3e6c9c8ad43b02c1af0b732ab052324533fc4b8a82effb896cc96375617da7ff7a93675c9a747eddb262bd08303255bf6b66ddf2e3015489a11c9629aff524a4555f48adfaa443cac823d39505b9e06d042c0954ec61fa10ae849e38555f32e2974a88cc7c7b30b75fdf851f7ee9e29add26a15c244a97da143159496f4e17019590e9f034d6c65974192f9ef884a9a3c84fa45a9e5245fb8b90b2dce39f3165e41c4534939103f47eb28ddf9ddceb6e2ce52c6a87a33f64d15f06c34305302294c82b2eb3e511a80a71cd8e73ca3425f49b7b6fc3ec27795a5bd39c4367d2b6e9a722a57edbacd2fbc37dc6a140516b10a38400072d7f97ec6bc215507dd2a2b6b7e3724ec59a87bd6a1fd4f221cc1cc132ac2c2b52b79bd48ab4fb100642fb47682635e17a563986949d75ef0e29c63821ae04a6ceca637a8ea29fe7860e7eaa51b4387bcbdddd50e84c45d7e62fa4c6d949d01cd0e2ed899622fa56d10f14fc829368c7504288e86cd46bf8f126267c8d99f95ed8c2f43300dd80682b6ee4d2c4931020f530702e15fa53f2e273c459580cb9d2c0bcfd5b19fb24701afe4713a5fd913bd74e5657fc40953ce60dbe08a2e31c2b1c253956523af77b0a64862be54d42db29b26406e2b8d8cfcc1144d9ad8d70121f01270f34b2bef59cb2b32f157f6928ec36c07caeb44a5f738b1f7da8cab872ee1c19d6e530677ba766067e298fb038ccd11584fd70c009880cb8bebc18174efa6bc240160b7f9d61c84a1305bb83d000f0b402029bb71c321341cf63ebc2207930e251082f384f381323ba2caa3e6cb9afc570f579f9808ef0c561c231d6184dfeb9a26fc4cfb05ad179ee219dfa700454d46aec84381d8164d26c1f51418029547e9d48c09a29b6ed108affcd72b0228602f094d66d6dfb76e77637717561a43f635387d775d74aa08de2da6dbf6d10e0976179f1bb8fe74d4c44be7cacbb697ebe6fa8314934c0d6bbeb0b06f0444beb3a7f69638cf8dabd35c16758414545c0cd4a2a847a8a5606307260bc0efd0b2dcabab120fad6ae7e1d0dac0662cebe1031618deaed83440fc5a9cf7af837fdf129c517c48ae8f5ceb83e5ae4c8d27509d241c7f729e1cd2197336244cf26d32326953b0fb0124a3e533acf06be27faa41370517e6556f2c2830b963c2e061b2efc7ccafb6832135835c0bffde3f3e52b2a9a99785c1bfbdf5e9a3820a27b80594eb239f67a9507b9ddb03c0a520d2de902ed533e7e27072966b4cd3c8069d3c7f9c48dde384a5bd839cc8fb41b669410ae8a7316af7ec874e57ea47f9de0b9aa87891489a88c86f8d4a3f8fbf69ea119bc730bf26290cea1ce5af95e355a355d32fa3f2fe54df199148052c07d5584470e1872e80f774a5609c2a4efa8f0e16bd63183629f0847ba0c116c11a1da9805312df7566a154fc48c000e8582939e50fa8f8fbd3f58b5992ad9ac6a56cea338d8c6e8a587d0abd6d22db9f4a4812c850c926fb3280d9f99e1455b4cd44104385f424eb081aadaedff994b6dc5b72833a3edf50817f52ad8bc933b5795c6d2870d10a1d87e73c1b266a064a37a96aaae97dc6b2c0a3bcf036560cc50861bc881f80fc986710129fe7e8817474a662ff00fd9eadfbf4f4573f85dfc6b2dd51c694f9718c5eaa088933104df84a5384204f9157f3e3a365b70c39df95bc64b49b148ea0fc8372deffdffeb53ce68efdec12f295b1471adaa5cc27de97397c853cd7904c0bea7a6501c83398d09902810984be2a9559705362c969654810733fdc533f2af58cad65a424259c68a3ba14ab84a4a96585281c84c8c3b0b7047d62b19ac96cdf0cd741a2075cc8c804c7458e8ff081995e4495a65f802ae2f14184feca471cb41b921b79122f81a46d1bb63a46e92e0898731c53760d16f16c54829f6965bd1033f1ab589edaef52e9d25509aa514fca205c79011478781b17712555a4d6736fa752845d141b02dcb1d228b20601e27d88c68d7412388c33c551b2e654913b4b7e76578cd02d427d956dd9fd1f2e2921e850cb44c67748a6bcad4d58155c33561678472d75561c798540b23d220231d300819b61b29c6e7c983c6d20f8c46cf30c22c17e868b2eb06ecbaf781ad6f7173c48c1789dbcbb6a280e4b2cec92d795d1f1bffcc600c1489ec521574a6daf5b3d90c2c51e96444d3a698d4e39a87d95eb2cc650d09459715825470c566f3b4d064acf83312d55b5e30d86a7a8264ce2001a040aeb72b75e5e9fad7396cd9f1acdbfb60cdc578383a4aec0433cdb2c5e9c05f509d83c45f44604b8d32b886f16c5ff9dae09e228b9e8ba946af70de8177efe5ec74a6be732e2dd51997fcb2bd57afc6c26ff52ece0cf1a87b250265334fe663a4f6903aebef75b169fc69c66f9bb316e0ff9eed29520eb6e1ebb65df3b7acf5feba2ba7fc6c42a22f14f93737f9922bd330ce6e9e61a43e11f1430e0a2ab74244585821da924ca3e94c5e04a6a10ae3442a7d7294d15e4a19ae7ebc78741ceb5b2988d6b11c3b693e0a5eaa6c8ae0299c646503c98e7fd58eb67ce4163753b38d4ec8a0fd932a7b764e00f86d5eb621cd61f719c429ef824254a93740f4c69966b8de9b653b94a9e218a6a7bddb1162c569d14e07cb8b61ce018021f1f3c00f5e26b6b3318c546d0210ae758aebbca38af228f246f4977043f95e8b651ff839d74ce36c2c7204b96d9fa2163133170c01f45ac5d8b65437a339a719f4f41d97589931bb0b00134a48ffb953fab01a8b99088fc3b9312fc7269c3cc33c2a59264bd86143dfd1eb78ff05f54467c916d580fcd2ca681874230672c99c7e9ab32cbbc590ff609c9eba98ac703de019a15a71b109d07217a7b5e65c383210acd87ebf991d6d25985984a4e880e2a4891860a061d902cbf20394fcd533e3b235fb39ef8da36507d8100f965c8ee374926b7e28104e0104bfaeb1824b942b06ff81037f398767969087fbaefac2f6618629eb85f6e7e7e7b67c535245ea725ac56bcec6311eb9b68f520b6b8cc25b906169c7e7eebbf9a39035c444daa3e8217d0e813cf47bb9958653c09061141d58f5e1f352e46be5044d90874bf90a4444f58277cd10e697f9485821c1b04ff3a6c4deab87762ebc288ffc216260a3610bab6c3836ee3d65663c9849f02fdedcf3dbf3c169b5781b586960ad961645412728f4f67d1d0bf8f88b0ae1c3516547b5f1bc43811bd021fea45a425e4a26c918fe73ce52cf2b9e7e3be414e7fa80097c606ffc4c3934972b29ef0bb190bdaffda07873839432a114faa8f42149d425feb521376fb41173e962355ff517633c79c99f85b9f13ade0bed4a9ee6908cf5997a97088e0a9974cdbc939acb43279f51e717e2fec39ba271f7afc82e62a3898d391745bf3707dba50d40c74a50dbaf551ea01854140a66a4cc3e7bba703355bb197d03e50b7bc9b8690ef569328e4e89ef8a7d99cc6dac9357403290aa61d8aa5569e4e7fae0c07318905ee052db6987cda42cb193f6828050e2390d7855113bf319ca77c13f854f7746a3cd6d96022b7e4a9d58071abf25d846c32832c7edbe6848d276a788d8d4132b738e9284753eb6917a31f695e8edbc0325978625214c907731d9f16be9f479e6ade983cec1f56ab422b35d975dc02e9e9c2cdcd3f123b7f77724fce7f17ce4f88c99b10228e7ba03d903198e01ea3c2c7ca85f0286538e7a5d04f5c3dd7d769a05ab16c9be9f4db263c1feb4c7b4f32e10b1e1c132ef343414f97d89f18f38b510344ab43afd4f7d3776707ac11277aa61ecda3234c582c7bd98041763ab6d6e88fd9022dd286b8ca7d13f2c3d1a5ada90bcf06c537bfc28c39340887187742cf79cb4c8ef45240f177085f17b188709eeb1e77740680699a5f8ea8f55c37b3f41b380effbefdaedf734d7883009c05a63da324a89713620c6e1b4428fb0dd6978ac6a489265deaa2651d68620eaefa476206e0d9aa1883ff31ec4b2595d7354b7c5eebb310cd58ca76653367c49898b5208ddcb25985fa76bfec5165b471b594185d8e7279d56bfcaf3b4958e7bf53c367644c5b81515f955fa9aaf567ce3f02aa71c5466bf5146a54f48ada8972c31762ff6bc8d091fe1816349b813103356424228af16a3a2e8a44f693cb79264975c66db2ae77e3fb9bc9fca464f68a8f0733a7ee61e9b3ee4a0c07e92730019ff9a180ef5f94905608f1b78170b2c2cb3d1d337dc66e165c36cf935a4f6e4548c21d80dc301e6e15a2b8435708c0ea92acead50e72ab62535bf9310bd6d3e72b22e6285fd2cbff1483f2fa41773c8786eb59b92a320531836956295a023ddf090b127352b06fb5b91bf96f8db39f0601febbb3a0df2bf5b8736d80b6c8572a3faff2ca3a01b28d55477eb1fd53b86f8ec31fb65fbcf9e143edb27ed8b12eec3e176946758e1c0d6ee80f1f8f1b98ad3918a96b0ec996ac90d8769feba887af40042848141c9070af8e8a366ea437f5ad30d43b6663fb207a363750665b9e321a37acc0cead2feaef625c120b585689603b1787373cd19146e0dd73197690f82e4d2cb2b5467dbfed0cab3c50da35a2ae14e585e8b45d2899e136ad083b48265c939ddb35ceadf7ad2d18a63c26259b0a31f209f2f67dcc5702f7bd9b7be55107f17e604c2addbda88021c6ab77bef284a095679ae737f642fae85a996c02dd705cd25e9fac1e7fafc3701881ba47fc5eb45b2e093d3819675158c634fe7f91bb66650150a3e9843479f0fabe3b231b23688a16666f6302eaccf552f19c40d568dad21ab945b0f07fd711b03783d813474e921dab405188d7e591baa0f910ca0725ce61fd2ca5aeb9ad248158620130cfdf761791fccdab85a9b0949e77853c3e17fe19dbc42d0f3b6dc9fdabbeed93a64d80f8cc4b386defd0851405afbff270c58b7ced5421ada2a3539ce668306fd9edd39ed5e2ccd428c6b746e5bf6fa8c29b829ca336d37021bc7c23a64c20ee207208acb2347152d6d7a88f8dcab80b551eabd06fb728cef5e73edd6ba4b8c0010d8719416f401bf1e3705a515a95d96d4f02c7f41ddac70adb9a251b534e8a910bfb59fcee2518b2411b8c48c670da44ab2a7156bd89dee5098907869eadc80ca059c7cb8def1439b0e53b6eac882b83a927231d43661e9526fd8233c45a056df262b63c5b302c1cd94e911d56fe009af9fbd63fa14b0b491560ff138676bbeef5330d2f877d577c67cde21a23050967d93339ac319da6b9f2994767e4f97b528371be865aa16151aac4264312ee96ff869b8b6c5717eaab78fc91e364a26c5c2603f25672a0212393a7f3acd398e5fe64b9eb4ad91697e64e69b27cd7994181242bc6174371c48311b230b359c96b0c8c8bfb0f2a872f07dd21982546ef9963f08f74b0b97e490c93736145f59da52fbb44e3c52379bab80c58cc48d7bf9afe5e7278924b7dae6bfaec30f9b785295298e32aac9bf19088b91b014d8791d8380f67a5b29d6341896530c56794296975d920129cfd29ff970d1194b5024b73cb0c6dc45ec47d1bd62a43563e3ac431f088f1ac4e65f0eb2b28ee6ad99a4430415e42774b2aeab1a5b1eb84f101c5a025ed6e7e3dc92018e530710eb44208b0217a0e319ad0d6ba8092ba218edea42197fb9328a0f9285f0b79634b5decfc31b4f97784eb8d3e958d54e2a5bac7412ec39afda4631f6c944642337b9ec2054aa09a7e48fb76d694984876bed4798e610d89df65734646cc319ad10626ffec5294f2a5684061292d78c6674cb14dc501ebc286c4ed436cbc8226c01d3f40e0f9747b42e69049ffad97124727826f5f0b42c287b8acb89f8e6e273fccf5d88eaa589be13cd7670c4e1fa2b1d0da6d924ec107ed7f3bd089fc6a0bda8616b8d6288812aa21e67a91e488d85fb08a5a8e504b31b057b2ecc3d40f17558668740f20b46eb15c5656e4e9e69bd780bea747bf01735fbf24f18b9f2db17e975a5c5dd011bc9a81fac986a61a15f78cfcd6164450566a0613c33374f78fff5e09c1255d70073b127aa0d10db5b427df9dba99d1c7ecd9f3122e8493f49f7033aaf2683a2ffad565aaf8216e77904e2b3fc7b647c31c079ed838013c4ba40d368e73cef209dd27bb4bd514e0cca211208905485a08dba00097c36474d40010fb3fd317eb6e973d84699f378a421813016dd68d6b189e7de45f058e83b7d8aa363e78b4ef165f642b952b8383f9ba081f0104af7f49fb9a1fb1358736016d1b3f45548c44eafe9680069d6e234c31092588b06934247e5aebcf0ad36d4eb392cedcb86975ad5854b25d01dbe94341af3145404523d9669d0f1884fa88d4d3220c5bd6ca0deebe754571c640d15459e5c42e94cd66234229a1a114171d3f36a4f13e4f8b772d38cd00c29458f560008f9d4f270f125ac1e4e4fbfd875033d4b0399a40e26f732aebf40e2236c8d09c475f8a4e4acfce92dc62a4cc5693c30eb717c9a77dfd67c3841e4b6358bdf218454996beb84500425b7d1848d30d63fb25b884870b52d1d2956fc70c01cde67712441449093c436bce76ba0b7de139c24833da52f78921136bb82953a73a1319f5a75c40335bbdffddf6256a6d85006ea896514c4669fdda99fb00ae602f5ee0433f13a4a3eabd8a7484404ee3c6669c43a1ed59eb4be111c8643a2692b172ddc5a5d1e8d94c16b435c2c990f7e87e0526c3e4cd34798d4e08da9bf492dc9f677701774038a30a2a56c7d28f59cd149dbd599c3fff669c1fce1139ec582fc53d51d8902a300040ae995b6b40bda0d41550c5fba3c7abb7e0d61e4e488f453109e0afecbb77d47265321ce026642b420bbcd51a9cccbc6b2dc7ed76d40d3780e80e7a545500207ecff43422f3c91708e0ea58642947ff98184944402e153e44e53c53cdc31711a4e09a94b65186e19eccf5c36dad6d95b2d72c09977919cb07753aa047affcfac57921b023b8f59e85a130291bd60e5951e3b4a14522d9f823d13d5cf441ea98e3bce53f7fe0ed2c0f83b2649729aefbf4c92a965992904f22cf58cc393b0198826ccabd1d357c00dab5876e95c1cedd23a83f1c1111363b24717f4ab4334a7d5ce15d08942eb3bf34f805e70972336b6d8f16752d1eb322d373be4e97dcb9f36e1cc5be7dff4439ab0d55e94cc3bd98078467ae05f8bafd47b910f73f9d2a5dfe1edf3311ee6150fa2c08d032a4a8aecae2c400f05af0837a93b8b071a819fe8ff89248924742154b35d7927c1350a5ba5feb0bca273d58ff40ad057477437b8d7a2f07f39fb730859678bcab6ca6253cb37a2fbc77b15a9f01411e15e437b0b7f7af92619173134eae373358ba90daa38a36e30dcc1ed268f6e2af4549b30993a13fbab1e47b74d5a4fb68387b219957aee2bf97df30119a8cd36d902deaa7f2e8380bcc50f436e2f7c32598b24cc7f0e582e3d4261ab959d202f0789b23f4cdda9e215114b151de69bac19f0d0c1d7d44f5fe1e3ae6dc495ed51c4a104e85cf59f59f2111cde77508dfe93f55b41160280aadb210df11824fcf93decde8ae1ba97359b33b87f8985cf9c36d6f7954f27c824e644c8cd499846b88861b6ec8faee5c8f8a4a32c486991f1ee5dfc4fd0b525eb3a7842eadd27dff3a65e35edf2ff48416007ffe3f75ec719d15937e611b57c24b5ccb6c409366d30f46c548ab459ec9c3699651b1ae7ab28c0c08a166272495c610511ef6c893ae0cfef04f96dffd73a3a295a3c5fff1e6d69fbfabd2dcf6ffed55bac62f45deeb4e4608467621b190de8dbd98b88be1c122df5a29d8664a0ee8bf9ae0664429a7c0c37a7730648760a7bc8638837baeb6b0912cd7712236f36a4b00bc78296c5124c409af32d9aebbe3b878a8e65268d664b22e6a56a603238120e00242f7ed9f212c1e4c94523f405575d118a3383f259f5d998b6226c728890a70a7eb1c1e56a69f30304f21415db6daae84844aa05550a7c47b9deabeeb04332e0c4121d73e138a50bd000a14bba0f256008cc3fe2341b93c7ab884e5ff48fc34dd88534b0f30eb61b8bcc191859141c06626fddd084b1813194a4ee0a7c19d17f028abf5d428ea70bf92b4d8c061753ba80926eef662d1d0ba840de768e1de30da8ec4d745badc3b26b9baf1c2c4597a5efc45ab85d37e4d9cb879832b98c0c3f46f91b7c0b1f6adec8abebb1616f427810bcda788e9f45fedc8219c53ffcfd076ad498f8279284d06ced9c503f2fe1a99a0fa0332951b9c77e29a8ce527681e6131f8805236ec819a0ae23172091770788b594875176c3cc58a3d781cf2f9921c0d62b0e8f901999a4b72d1557806f38b0fdb6f2eb402037ca77833d16bf0f3a2b723d08bcdfffa0314ff51a4461b2225d9feaf2e25f105898bba0ad984219a5f1a7d10a9b3706db6c99781bd1a64fe9c1355d3190eacc6672c50874d4d6f13d1e0e2bde75dc80d0859152143bf3022c67eb8a427e2c6719bd92c9be269443eaccb8b234070fd8d2143735c3f0b1493c90995dd913ab38772a711b30f35c9088c1ae3ae142ed83fce117b34964dbdbe47278e95e7dad0c87444a91e3d45d89b32e0dfd4a67838341c740365a1b8f91410d45338c87a7bd45605267a1538e78b7d918cd48159a25c09ed7b088954ea3b75612950435f159c79b871b94ba1121a4ce5229f2b9d3eb302e078e5fbd9d6a314def39a750c39860629976fe24edaab4011d6fb22969e810c0e1eef01517ba696015fe77373f913c8ed3bbe9a0e88231eeaab459c8d195b5d9e7e1152b080a1a8a5a98a6bdc6aeeb48b845dae09267708c7ac6b10d8839ce2e3fb53db5fb82deb5f8fa71f1f51a5899f96a09d8db691cb4d8626eb0e31f2fd1776e1135421187a01459c26e9e75a7508715cb9c863e1ec4e818e42f8138cbedb9792798568b605c7985f7fe9c63d1e53cf6321755b700cc8f6b7da268d7e514def77f009e79bcd2d7f7a5cdf4916837286f9662b355896039be10f6e2288dcdb69b5dc630c57460c796abaad23c6886d3b623c17b78d47d77548f0ae13fa3b8c556a9b648012253f4dbd95923b1adef7cb1da9338980ceea49c4f74e51d61d583cd0c5a6941133d0aa85c3b1ffef55b7c5ed14a7d6b6430b1218e8a802b104af438d85a4f58fef140e41801ca0dc6743a90b2bad8523c4dae855aa321ba2ca1e931506cafefe0c47d8038e86a976e0e0ac01e5903eb7fbef68f53c6dc691072bdd32956dee4c395d7a03c6a90f3e3aa1e4309ab57cbbe1e02b3a7f8b434d943dedad20a68a757aefa4b11df8d7381ce1052ce85ae416ef505dd4fd9ac208ac69049063cc5bf7cd7fb1fe7bcc8c0b7f04e791438425227ac28b83333fb39d0ce0a7f9c898ababed41d2e41e4a04704ea7f3f8b07bee8e38a2e3adea3607915aea4801ea92b4d604641ac9209af1cc65e776dbad9f9682983d383f2822dccbc8687c5c595271ee669bd53f4a969f80e2ef96ad0b81c1a1e6bcb7ea7fb2ebeb8965fec2f3c0992d1a1d8933295a252ba016c594cbdb51c189335b7752179a2002a91788a57387ee629e9dee17c76726b1e8575f06eab0785235a88a6b66e7b24c6d3ddface798671eee8d6930c83f2642e051539572b0c3d989d063e03774cb41897bebb7af3593fb7081235b155eb616ddf62cdb9935776940ed2395ec734386e193777aacce57f3493ffabeb1c80be25cdf7bb310d77db9f2375933a49d365b00e3bf074285866b0dfe921f7daede48afb799d3f648d2a38c7ea5e81d13d193068d5326247bdddbd52afbfd4b6e7282090e10e0ef3a68ee4e785dcf209cdb8b31bce98c6568131418de61cb599918e4e9ad93515a4ae08d5347c6931d6aa3f0cc4176756017dffae89f6727bb16a5ed648b57e1b8d7e6f5fd3bbff88f8f3c969020323791c7503b9d7f390dae02e531b2f31b1eff42987297ad12beae11eae0fdff37915a02cafa2866bf251916d10635402875373944897188777f945e3cc3f1f6d4e227442e81f4e2b8bd606eb1ae3bbc85f65640fbc5fd07434ebd8dea24dbb5e3e10feed1b9dc7a39b29a82fccbdbabdadd06176375b9fbf78b148f4db0a3dbe54ff1e33a712696b0176bfe534991300a7f93ec7e5901bac4a19564f49deeaaffaafe38da88c629298964b79817568d645917b8261eddeb194d5284645ac995fd54cae60d207c7f07f21afdf0b751e9418b3d680f39e8c7819c416c31fe5a300b9408cb35a3091a2fe06a46a63ef3948650a8e3f99e46c6e0a88f7ebc0c45dcb6619bd83b5663833a2c7383394bfebe2ad33d18abc7afa881c36a20fdee04039eb666bb45c51005a1b94f358993185fee56de23a8d1b8b36fe01f669aeac4ea8b29d1a0823411e5aa682da02fd4c37f54717bf810943bb41b011878e011015d8bb5952768e1a3a670eb076e998ff02043b3097a10a42efe7cc45605bcb29f278b21f81f0530716738b2ca064d9bee4ee4a279a40e6a287fe50805abf5eb04e189f3c7b65e4acc0bdc9457f648fa1c32ad4368f18657b62bf0ddb1cac402c91b95d84ee3fbbcacc47df05b1865d1f2eeed1eebb397864926ec7daf37f0925e1f0e7b746a843b9cd683064e33bc42b41cb93c2c43d88803798792a648e261091ddb512accd532497c1e344e15b68f9c6862e29b5f8753d0e396730527dfbac2c37445fca1e3073213ef23d1c0046f6c7b9327b1bbf2ec1bc96a8a6e5cafafee82ea060458cec6e77d56050dd279a887a96a8941361a5090a1ab52c1c6db726fb3e44e3574af996a0f45d84e20f452d007e9d4ad22ce3d4d28b006e5da1715113b260e41f5f236d1325114e3a786449123fea8b02ecb7c60d0c90b54d8218a0f13eee6d3a8d24cf3cd632b2eae3cba21a89d6508b994207260467d2f0bd6bd258a34d63a142827e9010d75b36c30c3264d5e82cdcbdb3b9cf3d5033749e822bb12e7bf62c8e920f88e3d9f41bf1c4129d8e2de01c2ece72b86125e78dbe2b4874035ead3e3d05ec4e3b597cd5edec3da68dc2363cf8e36ece257ba66447bc42f1c60ea3581b9436549f05fca8f1df3b56755faccb77e64e749d7ed086624fd8e66536c4332e23fd63f0dd78b705b86066966554e8b711b90bad3143c965269979146a8552c2898186cffe645446683f2bf5f00f2fd995732a84d7f8199cbd384bf3a81629d7a35c2feebf958d21a611e47029dfbf870fb0fdc4c8a7c48650bfa3f4b65d2b718c519852d24790d10614376d3e3cfc6365289e6128447ab6e6ef467567d51b25e25f7d173dae60415453ec6f7597a362bc9b1d1c59006159909b3524851eff58cd7e48367f7defeedca47ee5c37245cb0682a4aba9dd746c1c282eeabcc21faae533d44c1cf874771fa6e1f092af4d07fea971afb8806fffc8e1873b9bb53b68d12f2b4e228739f9ee1920803eb9c96496973cc5c22a85b8e78b7bfc1111b39ffa534ad5e90347bf0b3301a31b32036d3d25678cd1939dee67c724092529f501bf105630d1b8b8e481a0689496a91272d063c93670a00bb77876d8d2f284021bf4ae35500866069b76f9626c29edc94c1a62ce5737e22de9d46e081f87f796da26cb2b8180c31fbd46fe8308bc6b00674bd9a8d0057abbf4d92fd7cec85be9864b7a14a3aa9284ef107c69da10e199c179d4c1a0ca6f0e330262dd8acef45e774efd7d077394d348d65418efd8f21aace88a06270e6bb604dbcf1dc56debe9fb2cfab7acf16dc9ceea8dad3940f1739d35a1effeb82fa88ab935f38ab59f6521a0a45665271f52cdb1a0ae7b720330de86ebd57fab89de7806a7615bf30699c64ccce1cb11cca47e6852ecca893849ba9cc1a2fecf45a5637f87f2c6fbd752a8de18826136455892c030b2fe7f0825c309267a4d0aa295d25e15c07050ad466bf84c218da6da48666ba8a66b495770b1e1ff16a3db707a2ba6d3225ff06664e6901cbb56b81ad77cb4086490137b0eb6abbb13505d116832b208aac9e7b8816773a775b822eef4cc4c62b66a11195ee41ab53ddc8efc06eecd839bbd5d5450c4bf2e493635f5b33ff62d6f8bee7c8ad2b5f0da18adec9f222b1ec1fc69d30e28b9a3c4d0667b4888bfb1794704e7c5286b47c1aec12f3685b72dac452c824dc5557a16fcfe7c32f0e78d1acda06ed0de612a3d25592d906bf73fba90a69cf34228a9ee2d96376a13b1f557d947b13e747deae501bee095f95f1ddcc747dd83562ae53ce071460664f6d375b88bcf28f4438827c774c01cc5e6b952ae5b6984b7c1006ebe200403e7b240b415fce0681288fac207d73fa5617b263edb67530b59934312e0a1af079af5e657b651a56812b8017f3bd2ef8c11241fd4e056e97bab26a74b0cb416f826b39721493beeb3ab6eebf95beaeb579522cb7ccdd4c66f1941bc1e7b2884d28bc0fdc2ac0db506ce59243e8526dc90450bf5fe7b07a1beef394620176ad379164d2c4ff3fc0cafc3fe6020022bcc52b5aa7e788859651cfbdecb0f54b74fdfff76559a951772d52e06707337d20209253736d0adb3274e1a03584c90d16e3f65be31d7c5c3fba8f63ee0c1ffcabccaade76681e285749e431a3fc39acfe41c0705bd30a7ec8e62dfb9e1771054007efd633fc5dab7db14bba245ba99f28e070ab1dd9b54e04a53a6c70e8f01ecf9ec4b28a225a29a44498c9dfb36f98d71333dd96536f279258c3df21b7916b0f3cd0e9e91f2aac89f2860c6c892432da332eec1d725e69de72297e9712fda238e0b0a3c3ad23ca3cdd5eb3f75718df2bde82e373572d95b4a3d17c67c79edfcb700151c7762ced479e2f97426c6d63d415c974d1b5017f4a79ff6f514b802fa60d5f1828cbbca14a5a529151b0aa04ed68853aa93159eb55f3d5900fd1391e79d1b245b495257d943557930bfc48b8eafaa6665eb7a667c405f09b1fd35860d1f6af74f78e71d8166a30c425706d1f03b0d52732aec91c2b002bd768d89f81292270e8f974f355c555fa67f95508426aaf35309549d5d5cbcd7d87bd82644bddb6a3dcba51a7bb11ec806a277c621b645466284889ea63dfd00ee58b751e6cc7fe68e09cdbb50cdade79f055d2501d5ac1e8a46c65370e568dd85d00ee75be6316233da53549e50373242a1fdc34f69d4d4d35f10b6dc080a9e33ec883f9d037f5908986eecc3775e9d6fa6b7286fbcf00d0d1f113b5b7fc0997a0c20730c65541747b4b95404ce8b84ec73a1a73e78382f09833dc92e9f12c379d033645ceddc5d20f36d418fded2dcd4103556c6ea865c06c0ccfd16171a11150eae37e72f095db021b14303b604f20737a254c09b1773c67c68ab399841aa4a030f96f1a58ba11a04e385961718965f95a58f3424abd4145b0dfcee13939ac6ad952470ed24f41def0647dbe34ecec444b4bd5acee005f2e0aaa765924bbf858a4d0a337b1dd46f4c7a74d5e1382260996515e54ab3e9115c119fa6850b216c90d3c7dd9dec5172536071f2bf5ae7583351a651e73314bb9974c6aa564c86d89134c89399baea7fb59a55f316bb3ba97938cd5e14cf2b1b8c47c9ceb4785c2d763c45f65662f80a536c911918a14d63dbf534f6546278dcb23ef334971b0170ec9e11e3f9501b41d31bbd6d8d6e568a7230c03e925cc670de0452964fa5ea2f3b1e5f7d25158ae4055398d9182207abf3743476b2d3f3114a08a15671078ae5872742e9dcad40fd055388ae5d67d0cdf34da1760280169592be745f9019bfa1e2bca43bf5c50314290bda299991570cfb7fd2adb022bc46e63f41726e204ebefe9ebb35bc08e8fabba962038c3890264802eb80831ad45753f99ccbad0351f2531869cd6ba1ed7dfb3ea9fb5d0a8654a61e83f5a30351c7111294d109b968928992fa91eaf906634e4e2074972947a9dd16d61cabc27b0ae517ceb5e138121dfdadfe8de4e997bb771e803e73e26c9d3b55c986e291520aaa89d40eb5e6aede11857f0466613047e64b8c67bf890bd9843f224e4ad761c809e7c569d83d91d2363dbd739b2b5d9581cb5f082dbf2d4b3d112f02d2ac3d14c66371f02d1e70b8a7a43ba5a6ca045123988c63caf13daa368a6adfca0cf2d797bfa0c0efd325058f0b520b5953433401fbef5149faaa147f4187b03592a294801ed082c0f92dc024c92419d4981eb6918d54a2c2e30289093d3edf55c71e3042015503cffd36c3ba021039790a22adc7b0753304bb2f3883b86c1c97c966990ea559a5046213ea032f2b2254eee35908683e2dcc6fdabdee83497958c38a8fc6ea7107b42bb4d9be2ca7988b06a182ccfaf69b7cda483820e30a11bfc1e0e59394d67983e2743effa5178b511e045b4ec7370002c98d10a9d28731e2592b99f0bba77e5c948ec8165b0d658ab6531ff8f23f005dc7f58e45f87dec334eaf5eddeb25b4d724c60118649a32b70e56a9e817ec0ddc8ba61ed3f6015d7d9c0d33d5add9b5b6d6d2b5cfafbb38811849252dc5473846d3e8931b998df637389e99dd5e9f9b723f8fab3e6f615f5c795b06d584c197ed6e8a589c1c61835f57c24bb9ebfdbb20b72de297c1f61d3ed488ce9f174d4d8f530b7a6bdfd1338506fbbabc35590e80b68f393b8ed06c443a92f667958263d4959982a50246760a9bb29c4cfe7ddcdab999171f75ebe2b2379763630b43ac921d596af954ca82138d0a66224af8268b5f8b05023b1d431568ee89fcb3d53f5358794a118cd9b3a060ab42e86bb4df2e6f92e04afc0ebdbb7ea2a8e5a15d0a0c52db8ead230cad74b2b0c620ea13c027d1331f1ab67cfc5ed08bb43e684a3268a0227c6150affc436eab3fd91f03629192dee4e066643f114e98113d8d5794e940b8662eea50ef15e0a6906fab6654946555a2b3a0054c322ea49271817da1b6ef37a6a661285e2e430f86c99a538412412a853ff285c25680579ff3b763e3ba82541195cdbcd0a5b92661661f5801d842b0ee17578ea3d0e1ba0fc19cbe1b3cdcf6f9bf75300549eb955dc75eb9d469353cfd5d87c2891671fdc25bdf7f9b4d97a34ffce544ad6b0ed5185eb86d55e4bd1fd5692cec671f6f48877fd6a754745a650be43506779d35a9dda1ff1ffcf5dc5aa0850a3f4f1bc6c5c28bb8ec0a6cf84ab42702b15ad7c8116ee351ff5670e061f365481b8c68560eeb5d72e77b73dd7151ed560b436b1791a811b90553b519eb78c361ade86e09b6938b25b83786ad66725bc92caef462203e3dd54e4823f69d4b126d2a92afa32ae5f66c0890967f03c44c24fa01172f46817b511c93d4f8a85982991bb9dd998c179629abf0f26cf0be21a2e5dbb3090131295c3096d78b32558b4ae2c9f12d6496a220e6769c5052bf8dea5021b7763e6dd480995f48b13398740582b2f8e05b64a3b6f73839b66da7ae97eca6994d69f40421d50c1b339e4145f28cecce69c522c113cd47ccefb4f4eff0eae26f22c6ada313aa7e294180bc597a583dfa139498c83e651c4a7de4d78e67686924458a6d8521cb29eb6519547cf61aabc0dada13dfc883913abb7f1973da15042a5956fff7bb055552dd3d070738c7e02b2b563ab18dc70ddc5300fb57b8bab12c94c2e1f7925e16d3e8bee30a6915591ce082ca9c5402df05e8e9f6cacfdab0ad329dcfe9194bba17efec5eae9de8e545a42d3832b11abbd904ab51d418f84b753bc387e1a54565984202239827e1912bd8211093e6b11cbed870fc40dd861d7ea09f841fd5820b1d56e2fcb21873a36dd83ddb6dcfe555008d35678d10bef3f58778be1353e11cf01ab138c3f8a06a009dd45a597fe363f3a9c5bb8057a6fbaf2149a88fe31ed2f482cdafcb57b94829bdd3c7c66cf2f31082e3a2f5accc3a78802970e51f48fc04382dcab57ec1c99a845a9ce95b0eede6ae9956debfeabb91e06bb914e2eddf8f32950c945d56ca138f24c1cc2043c22421074b5b16d4442e4c691f0019b02dbb4090c7c8be4221a1b65f20907251a8195f5054322b81f64a7926a8bf73a1e8869f2b89b40a29356132bac0ba7","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
