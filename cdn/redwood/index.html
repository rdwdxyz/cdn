<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"422a539d832b09ce78aabf227977a8e01e6b5a83734faab4fa02fb7e7e14cdda23713dd76cf41e966bcf282e3381e10dc794011c5164b0c64085224c99c87745a5cf09c222a1dcecb0352746c82a512d9f981d2d8cc6e19e274ffcca6de5f107c3691dbc61087b1504441468fff73cdd90c4c63d2f43d32674ebacc262f6ede571f778353d452772307050e4c712185728a808eee46970a0272fcbfd37e2ccda3cd11a5bbff73a259ac138c03d9cca0719c56d4cff7cd4d0882e67f0961baabefa52bfd30e45b62eef464bb766fa55ac122b45de3b74101d2934fc23ce9863e14b853e5c8b73261d93b7bc0b801dc0ee7a825bd44ddf02ae42987e2dc998c127b2e27fac6a70fb2b083310a9cb76a61699956f5ece0c956e8c573c617ff421e30733cba6c4d247e4761bfcc1bcc97fc29c9d421e9c3615008736719efe8f60c99989b0003ee6ec412ffe0a88abf8733185be4c0ad4ef1140d748ead0856d5475cd8cd70dec903d8c72e7c394533386776e2f27391d02033886678a1a388c66fd1c949a4b6c82b06c96b256cc2816a20272b6bda0497432556dd7d3704ed28d2228b2ba0720f15800aeae2d98a96568028aadd1138740f12b986f093bb62fdbe5a6a6f223be9296ecb92bd491461ab82afbae5afb5a1f90477c6749000c964ee97d2d12478533061ce4a993c3316705afeb0e9a2e9790fd0027c88fedb67b1c9ef4814a49a0c1c2475a0479e8e0014cd7b5a766a4acb1c33f1eeac9794537184fec9c78bb015b3c7b0497fd09ebabadef93dc8eb9f667727427743dfc0ae55e9aeb4e51f27e1f043be8e74850103ee751d5d39eb33d26cf78dde46c8788827094d4c58ebf4e1fdc653c98c172d0db5aeb71173b4a6785e630e1d9c8381024afadaeceefdec7dd5773ed4fa16870409a696ed8a1039176fc9221021f99e0204438db656507f4914355af4d33ab48f9b9c2cef3d55f1b3de0536463b80f59440bfb9f377a6e65da351fb87de4c16831207c2e682ac4161a8f7988f1f8c98de21ccce508e3e762727f05e7b86d3004523fd1146cc7bc21a72317852ef24db3d37938afa01c9d107154a67f233d2a5e3b8b08bd1a9b8c31d5ddf85ee1674b976fb59da1b260716e5b1e76bfcb5c021ef510cfdd2151b0ec3901bbe47276cdea1744ac9139ec13dc792d2bb3305ce4e0ad8f3c2f7dd8a9a78a118451ded6d2180fb55e7bc94a878d741acf97addfdbc5a2c344d433d1a0e0490ced0f1b6bd213980e622ef9dd42c311ddb979d2e719d0be986e14e42ab5ca48cbfd79589fbb516679c1380bf3294bc66201fc56344658081427e601bb98255ee12867f5167661b12ceaee13abd781fea05b28dc4bdb703a56b94cebaa593b2abce198739b548cc18e79663b27ec8ad9ec4258c0c7c347ba22dac7cca786341e19c185c9b95283ed84d92e3afc98188b732baf475c2a35ffe20575cd5b538a202f514be1e42ffb3aa5d840e6864185bd553ee6aa528d27c615bae2c7893faf1f34c018826ffa4fa41903a7cb5661dcc19d3d90056817c1461d5a685d3182e47ae739ffee5addf91ef9d3bbeb71fb7665c8ac24df1086230ab88a0625f3090131976be8104316269b5d2c201410c1499e38b6b9125ddcca875eabe808c4da0e9e5fa4270774dfee44b20ba2a80702febd0b1baa348a7cf4686b9958c7833932d076ecb2aa16ca1b3c6a8ff9ec49774cc13d4a78cfa9e64bbbf9bb49789514f172f28838c41b36775b0175e3b6526f9b61633847e72af3fe4bd2f2091420743512952e892cc086c48618549be3deafe2bb45774d50d30d928b6f42f29c52bcb5105da838abc3d42f3edc23f0abdac05f966250f9fe4ee712c2a6e13b50497a8d5689267cb25d28ca04925c75ee961007ae5981690efb93ed6e29aaaf1721b9d1d808b3fb6e75246ace88b7b6785902c1f99a675dcaf11654b07748820a25d912dc0406f76902f1d0b294a521d0f42c2973f61c3b4afea2c7ca09ceca1e4288da3a09af7fce60e19ec012ae78b16c5ef5630ca91aac94f839789c94439936731a26d04dbd0954c088ca2157d342c7a7ebd1cc2b889c5da5c2358c654c1b4880890864047b260a5e27ec91bb475a935d0805939be508d1d7f94e4d4f8dd53bdf829f45133a1c5c9782193068fd2c2d5abb721dbb5ad6064e40079c45e2d5ed27217092c9e4e499b6f5c3f7f55f1df1b41f40749d33827173605963f21fa647e0131263bfec84be1ee6a8bf0c26294783d501121eb615071ff9f1db9011d0c2480087a5e98e93f88174c7a4b33e54aff4134bb3969a2fd667c55ede0e25cf00dec7c500290f47479e61a89306438fb7426fdb1468b9c245e107e63d201c23c62dfdb7fde18ce82cf26643a0812b9d16d5aa2c42bbfbcdfa78a373e5a1bed99116ac26e13083733b4a2e742157743a84fd1e1f14c5bb107b55f833f2c8e687005c73791c94ce99b71232752280170dc4335c797f5d94c40b3b48f2fc54b15539abc8a428cc39afccadde1761e4dad91f77914ea2baf7da4ca474ae66e7413c3461b17acae4c8258af1619a91358d58e5d0cf569e37eaaa76ed8eb9dda127165c70b3ee577bc91f3b4841e66602991fa8b464fdaa1d36e34368f9f5fd506d6da89b34de1dc6b6dd5ef6ed55baf3ab598136df056fc4e10bf668717cfde35b9759b8a748c8d717ca147fd973d0e5b9502fd0f9b436f894375eac737930fd5c4f3264838c410192f83090803d65c04dc6654d344d31e9a28508cbed1bae53608547c65cc4d5d41d1d17c54d27e1a85b5301fd2ba3a0ac39568df950aa5bf3fce753e2e173f2738e824f75eda01ad1184c17e016d3b68c6089e751ecae72800cf8f3ec62b032ba931f3eaff4ac54f956d94c5a996fddd958bbe558ce4ce0bf08ddddfb7f777189329b3de3358ef867e736ac29951360b89e474b9be258188e40002cf366e8f37139716180a4b5691377843892a28cf7dac9cdddc53960db6ef821fa494a2d5bfb200c43e4d02b8df31e4b1cddada86e519d8a2faa0cbf6fede566df3fdbdce33fac07a2352e0160fc5f3e5cc9d0e6266b210c9543523193f76a281e2fb3c13437c3e7062188a585954414d45010283703002d915a9e2d2a28d986305de7d238b483c1c685948ff6f0c89c50620a0d22867c7daeeb57a7a7eea093df8e34e12282db482068b373813fbb6454fc95ccff848d56faa5d91d5e17cf507cb40d77d481d4604a7cb9e1bf9e5de653b17481a9e54286c1fcf23b4bd697d263948bc3e0ec3d18b30876a4b93c97fb0996f4bfac145b5818701951be509803f2309abffcb2a1670f4ce90e1e7b32445a40cefb185bc2d803406e512e5dbea184f092f92a4a5a4566bc2b1f6fe05fbc7c87b1c137836277bfcf164700114890c98ae9c6f9060d2eb4de3f5add6461f28a5ad14d645f7d9d1f7a1a6f04b2c1ffff81c44a42245553106790f5b0b31145ea3d5445f0cabbb58f79047effadea179b61d7f63fa9521bc10053e3cc3e68d7bf413a821555c646d555eb8b298117b4817cf65234e8a7c00baac21a10e6cc1b44fef063764d556158e7a2960c96ee15ba7300ccad396fd49c43aaa56242a493482491e2ae12e10ab94f783c53e4b6207d74a03e5e6f495ad05b5a777693b0fd232742b49e0e8e781fe6686c6a4d52e3f1d7cbd344c306f51757fe7d3b71a7b249c166c4cdc9355481ade245dd2001766706fcaf04ed7d1c71d685f661c947e61c68bf3f8877f980baccd2e655846b2a279fcc205eca8f4ede3849728773cfe64faefee3e7c310debe14bfc51800385443c5f692c77a8004c7a7180606da23205111d8546d62ce6e5067c4d9698f40a7fc58242b0d1065eb5a91d8d4f324a4025d966c5baa943d13eabbaa0f60aef6041acf0093ea1fe1b29db9ade8a47c2e54609f22931ecc23c1db6a2dc38a454c4898cbeb65931eeee3db7dbbea746377562dc1ae7b87f2e2a07bf3cf710955f81c3336657fe5a9a22f48749c57a11f89128ec0ce0e7f75a7020ec3b860ff99ff10925a0224dbb1beafd85e149234bc4f94e4bf6e6e3650625a3eb5b5d2c4fd60232e91e7a1079dbeb2a163960674795c31eb4564648a5b14ad567c5d1e63454f6107c7f5f9d905bac5632b4f819a199dac2ca369ac5d1e93c35abc0ef80eaa79c61d641e4dc54ec0e12f778df2251ca4917d40083ad522e1c2e041e609ffa957a120171b7ce3b5230b967fdd2d8f120ae201ef9ab113edf18b0abc23b22015fea837a96c1125a1c049ca32b91921047194d0f1be143a6660274a5bbcbb8c9629edd09cef7b8e6b65dc41b4fe5925cd227f096d101b57afae5ae79417f2fde57144b3d66e840ea4a5b69866f84e298ac627165269521d8e41bb0cbbb5a9ef547ae5acac279fd525c1682418fecf3050f247ab65ce3b9ed51401635f338a8dcf49ef7ec984690d14cd4df19ad20d77f7aa45e45bd2368f0925b93daf389cebddf195539d047ba589b68ee841803dc8ee0a20e259bd78007ed7abaaa8cb5270f8590e2d05962702eca6c8c7618cd71ddce5655793a656406fa40acc85fd5cdc60a193274d6a16eb39e5c183f7e0c4929191dc84aac034c4ef84fc28d5408cf34eff525ec8f627ea031fd3530959b4e6d825f6a1ffd1a707d09af1837b699af62d5f20ca239ad3cb8353e4b3ce9bc7231787e3588f3c62d057d72d4358e6a951f4dc25df3f2f8c8c9a2bcd22a54cc4db36d47ad0003bc43e1883158a24273e0d04c002662ceab7bea57d649db35a2dba3b56004ca50da64c80110229776855b71c0d0cc1c94938b973fdb233010d76c2fdb97928a50dc4fad7a54b837ecc6f6d2f50113e04be4766effc42a8dc4349ec632f62259cfef05079afb1c14eab10b330b81f4183f5ca452ddb0a74bb8c89d68ab52846a1a8e49ed434cec130e83bcfe00a02d26b7d8f52746aeb035f02e42b49c14e87537230cbe95734bff9021958bf799dc506feaac38a69883f368b4286548031a649c6e8445cb6bcb3d3a0b816a4529048c2488cea8d5a8b9ca6add0ded7d9fe976af16c4d7b621585ebb30431f7d5e039f8ca43b28f9a295c8b659761ea1c811437aeb53a4684efa6638b3f2fd9379aacbfe1e045365f9e7ca9c6eef81b7bed69d4dfd4c74a670ccecdaf017bbf219aa74ecb05c1af25dab7865399309189b3263f7b61276a56c4a2940a99961c766f1a6071da0d255dfaa8182a57ab4c884e1b9f6ce50791d303b100b755f7c7eaf33bd8b9f2e2111525beb5fd32c7d70fb81c83dc3ea7084c607e6e561c6ac20cedf8116ad752909d8a62d0d1371bc750f14fbffba696a4231eaba9bde422311361d4857ec2ddf8c59e41c325c0f91619ada44566e00fe4ea1fea186fc2a89f6b451458da203ee26433b17e1393210a9928b65122b0f5926f6b7ad51b0d18d24daedaa13b3339551bf0d932ec5484b2b8152048c78c7872945161f66385b3215dccc61ffbcaec7cfba5cf60d27f705457a41d7336827c4d31fe83ee70566181205e78e09a3d15c34e24bc7537adde00a0a396c5ba7754dfc3e99a0bf3d169a8e8df819820249f4cb7b2ff1365e9d268381d06a6427eca54b4cfb972eb84d6a66fc8a19f627ca8cedb0c636de7e21d109705bad191cfff12b5673c648ed0bc2051cd08bde6a7a765434b2b4eb871b08e708be6776f1e0e0f33873fc35cf86275588832acc1eb5dc5c2339016715dfa99433726d6d8858313e4cac0d3b6a9d281059fe600de1cfc12c1edda2205eaa549f905c5d610bfa0b9d34b518a30e09ba91400720056094dc5c7485af2e33ace38b6e08f73d09c69f512ad71f9b189e76e545b59a0dd192fb7114d1c567403c82bcc0c41d9aa427660151e118df32a198eef19e4d5f6f4bb16873ea51f5f3b3a1721c877910aab78d7570f2d84607940140857fc6052f06cbb788e09214f3e01e2934eaba4f325029e2cc61a71813f6d62106b1017af63521cf753daa5079b69b3af7463b75ec55c7cdfd24940f109dc3eee885c1239d7c42579c51c68c9175fafe368d2678230f5c8327af395eb60ba0f8ed73d82ff1384019e037a2c790c11ad02c091263245eb7458c19cb1b6457e367e47e21319d5841ca5183f6fe96ff1d1a989e65f28db0c0b5ca08d4bdf30fcee85ab63ef4f615d06a02031ab7cc9ba433f5d714909d7cc617b9d5fc6903dff53b4356dd2631b4e926dc3715c97bd6e81f43dd8bc5ceb766da372a6416fe92b5c8186b218869396c3c1813d7aec29b4a2a1a33bbb3e765d05ae6ed39149ca3a8337573ea7e64be8d687a85b420d27a69fabd0864f8840f76ad62fd19e39cf341258a70f3c81363a2e5084814e26362dfe5f4fb9afa16e04b71dc17b76314aaf84e228cf1a80b93939f5c9e98fba9b0ba2707c0e26b4169a855d1888ef734de4c0690632a62bbb0fcda9cc524803aa461157e6e7cf70b1a9552a9ea631de55087038c8a15d033ba744dabc799c36239ee0a94814aa37a07a6b0c6a59851ac0e7ed10185a6ab98cafab6af4b21b78df749c120130326df6c86a6a818602b570455aba2f630ce2d0a28fe7b5d03d09ec30913ec43568b1838ef712d3ebdd48448d5397da7d23295c51107d770a7060d8239fcf3c96e5f35c8d22e7a86d75bc5a16434ae7a84ecfa739b5069f2033fe70b4eafe535119117a94be013b49bbf48ad804c10f9303be02cb598e30e6b013198587055ef959f7e71f5ac2308fa725f66d4a7970b08ec016f446ba99708e9233a87698aebeaffdbbe76bcee0c15ac84ff12ab3ff60a1bd733da4ceb6f25c9e7f1b1c544a16967eea75d9c88b13d1e52b65c7e5b207e63cd09098ddc4b633764f915bedcee5075eda3fffeb12f2e04e492a5fa2d4f3572aa313259c9b907e88fa96693bab7cacaf399aba2534b871d09860ea3a0fe06188ee69d4539c98cbb757c03c1e29488be6dc6d67c935f574b9e7757d391caedcc74445d3ad2d75aa1f5d94a7e3369d424cbbcffbd6f430c6e417b23f144b84618e1b60222ee3899131bd7bdf2ee377675e83fa1565a0cb8eab05c4d24fe1ab5f144522579b2bbbbb95de649d2c4fd85a225aaca95924b4a96e5cdca8656629f16d34a6b0adb5468e8eaec3c83ef73dafc95c71dba9294c83a637712842d4b7ec77b5b1582e719a391001808502b79701bd73d62eb1074e5070fb4321006f02ccecd33d8b6c19c474cbd4e6f4424711621355d97fa01031ccf9b18b50f1121ee393e05d6fa0b9b53b7077afda891b118c6b5e7c80bd04f39cfb7b4b9e1f13606b057fbef972ccdfe6d52a73ce756a8b6323a346c0be447e11952cf07a4d3102e03a69a1e90cf0e14dabe02f648730f2976149268b13a22285b4367a33abce92cc598ef9aab92f6b7ab84234ed784ada6c1ca95b9fd3fa40aec2a3133cf48bf88dc9d00ead8aef26187d740d4cd3c53d4a6d8055e2f605183bea5f5379855bdf0049b17330a0aa43dc763026d7392d57f240c52b6843bea7a1f612e3c01b9a2dd90e6f5d1b35cae69d31c82835558ce7ecc1ec862e677ee085793c0d2b685fd34df14ca40ae90f2dc7375bf82c779a028928bdad6340736dd70c1d08af1b1125bd9996811a9a6ccd84962c9f98ca435694f466712e085f9335538e6f32b1d120a05e496f21d664fc8419ccc40330aa45e2a687d76fecfd404b10ba8930fa41895c8777706fe179077f7a6e7c577ac716b386770fa47544cf141bc43196421335b1746ec90f144feb90dc0e5e2c647fb84adee03b80d20020327dfb6bec60c57312a7bd9c8c3dd390b673a312c1fa9c81a6ff4bb4872eceaa53735f4f43a46971b2b818efed09477f5c786c2cb091562e957480d3a0b3578250e57ac412d68d7141aaa2964f848e1119749333a8944df5d2ec973247bf7584105506860baea2f0e93b1b8bf5dd1a8e0d25945579e92cf0eeefd5db4bc069979b74286edcf50a7c2c04f610d93851ba20a2cd015c938686b78940386662a100d2fe0207a95c359fe78c12b31534e67f7ed017d05c3fdbcace2798ddf0254f4683c49bf673e60c00d5d87f1ee20681ed8b6f886cfec3730dc9c846c28555c9707356cd341bda4397d6dd82527e37b54ff1c03aed381ffff2a01214bf1a6ed08cd78df662f8a2bad12562f6bc1d457c8c71fbae5be78da6628125d39be38fad7a2fd24bd5833592992e1b394cbac63ea5439563bb1cec944e10a34fbfd027841d82670ce0c764689a5cd69c67f743a57cd1fd0da1467468a147e1a74d9d982cdd4b09c3e4e6b2c20dbb4e02aa63f4a07e53a3be341d8d24e54edf32bb90e854d076593e17024e41f375823cd35bd8567442bebccbef075c4699172c98932f8002965099fbac8927c94e6944a7b322e5b41083730c6e5c5fa4eb88c12f698bacf5a45f39cd170ff0b112be7441ffe116c7bb10ec36784d5cafa278154d3b9cef2a4a0b20e41884cb14619e5e0449073317e5e62f02087ad7bf0eb05bd0326bfac7e2b20fd3f68ebde207bad7009aa6fbb96a64e8df7baec48f2bea17a19a436a9cb49a90f21e35cbbdaa1918d1145db254b0709feab0ab75852f595d7ebbb83e6ccc3819f558fa54a56251fd0f63e48a0153e5f6f4f5ae581e29a689493851d317867897a902f35c63f9d3e7d775cbef64f74d8347847da2c80e7431b166f146f19e9a95c0e650e456e14e1e42516403ef9be9d9e85b393dddc87f8c1a7dffe2ff94154e1d1762a30ae564a2abf0bda4eefe4f1e5c4f9acd19f72ffe98c972a30469e28c59ffec6d89ad3fb8f805179b0f490739279dd2b7ae90b7c78518214250a121edcca679a1e46d55af67bb72e33a3d4032bde3be2e3c388aa5eb59c690b0d4a17f2206e644e33fe5cb20e6411b13adedb304ee1695dcfab4facc1b1c9ab9a6a89f6215c563e4dea5bfdcaa469e88e2ebbd4fce047ccf85fefb8bc79adc24bc26322cfd3a9006ebb0bc0fd68bffe79820d02ac46b2fee4402b622b54cd43221a8ff21e5c9a49249e90ec235a1692551c1bcd68076e530582ed80eb4f82e913c22db4896f6820e2dc157109881ef62234f78b965141bc4baa89192767870fb17e68a4c87897e0662a6742a0c3e59fd60689ca9eda834081edfff8b8a43fcc74a49b14e60204be75eb74b233ff23f20e60df520bf5bfe0bb75a960c8dd6e0580041fb235161d1802544cd7246b9ace3ec69b5a40a535fe80a25cda989913f37759c50f6ed5c2b3f707dd1f52326a441583846ddbc29c2bec38a86b795ae71202884bd71833a7778efc11bc4e7b8080725e1a0c93e97794eee63e33bd0491de235b102a5e8053405f9a6465bd99365550eaef9caf03dd2469c8f45fd4faef693a3d590992dd7108f935c0d8335062b9898777fa258f93b92dd102a9e05d76507e3a9842d4d15977e87fcae80294b1ff4a89467e215a41ddcf29ebe6ba8623116927535847633e71fdf825a3b0093786d686d70db1437df3059066fb419d47b5451aa1193389e2425e6086f4880d678dd8a91ea4fee17e5da7c61e04182f9fefea639be886589e0f29badadc6e4339eb584c88ee42e7628a76ebb2ac29568aee9bde70c17e5020805613a92c6f560fa248394455fcc02162bf15248663660bb4b374673d28b027fd344fee46e91d5553d26222f0440224301c709f7c4ef94b4c7704bae17087abf32996b1a15b9ababf3bd90c85762cba8877392e300f30333413e964cb4069b08badc62817771c49ef3190d651a48671b8dad4c30873ebe495a40f1466783c606dfeba69c7cd2a3081aa601af91d9222eafef8db42b36bd09819044f826202903c3c7c84129ed45d3f78f15922483a896d05d03a21c90005048d77ee0e33710b99a810362e2065345d0d06ab1a4fcdc49964c5b2009f8305f74a675af80fbfb93fabe892a2b145f2b3b87d338574b44a7a810b7ede5af7607b67ab112014cc24afb07cce8604b69f1369d7b5e89c98d20f16dd6e4a0b97cb0f4263afa23d11a4f84d8410d4ca8d4efca8ed69d0a131d89337983828195d5d7d869685552f8620bab4b5d9e13b82455d31175feff55c55d5f38255a3b99fec47359ad68d9bffe0bb343224de1410f6c82f750f5f9a38d73fb72997135a2bd169578fee08e2814cde134fe5f331b552ededf093ee631eabdb7364c7eb91bcf8ab735d25e77e32864f3bb42db3f6ac61b6bbd0663be2baec585731d6458c1beb4cec884c162dccc2b0eee478bce94e8bd05b2a8717e74286b53a1f3e29813e195000028648754a67936792d81fedfa984cb5f153435987bf64a1d1be673c79870d2744db1aa7932986cb48482b396bc04a597e488bfce795254e486d863a85cca4fd737d0d9505b0bd1586ac5f85902cdde72e67de573fa657fc923009ac7bd06aa76dcf3e07e870824e6708ac263bb7c407a21e0304b25224a640b9d874d0fd9a6e3342113f0d8e2270f917e5f248e65ca92566633990f992048c6b3b5a58f31a435af812ae2101189caa4333cecb341ec58268603be7bd385c594048e6b8fa1f8f84c2cbeb44145f402c39005d84567ce79beff79a7b44d2ba81f5e8caa27bb7328bb1ed9a927573282f5146d34c94758144417ff92478cf2a331b8f248559bb8efd49e013388648f78daf27f308c95cd5ab7865c4ec8bfca13e0dbc5284cd4e15d292e110db7035f85c2bc06350f8c898b67b139b0460e102ef990d32c90c81e23ca0a85593fa00dde319367c55a099bc37a247d0679d33247d9d07dbb36beafdf5d2ce39de75896e0be99890026e80dc1538edebe3aa71e37497d326bea9f7a34abad35b00cd33163217d1cdadf66ad6838406e6be27db5f71db7a3ca8a69331013dfa20f5d672f3357a1e4bc1fac98971fc63ed95deb9abb4301125311251593fb3ee9a1f637f13cbb01517023dc8b8b0286e8913faf9c36d1f4ed293de66664565c905f38e2dd0e416e5289d51ae19cca777f59fcac0359cab337f225ba7535d77daa5fdc271f5228658f0dc89879b0f3a8348bded4462f433a23bdfcc4bad6904b3c44d84845cb1914d6048b285445c1850a228f8c8920da75e27802bb290a65b209add5ba370b306a17fafdb757ddd35a52e16b4605121461c34453c39946855e26bb97eb5a91b744d321a12256040cb3b86216815d26334463cdf41db2081a49d74c78f8ce8bb485f64b9723d12e7494c8bdc2102338b260adf13fbe16f68b0b9d9fa4f36a429ca251791531997c6213df7537c8a3ea5b53d70f21f320e107d7250baa9d9270f0d87e8275e202981490fc81a510e8b33c9cdcbdb5314236284ba102f2cfa9c8bc9c0fe752de9d15507e4069873242f8170a63e82783abd2331fce83c577ffa53ee3c3297a1dd57a8868c798678bf678f4ae26270e1981af94ed68b0ad4609a65a67a8f7e80f2da00ef9439fbda60204bae0c2c35765572df506592ec589b7cfbde16711bf33ac1a8786d7dd880992d389f93bb133d214a18253d7d1073a94dd7db16d7fd2f8a46fd1faea64d867556f3fbc33b0598ec10affe54d87c35ad683c6cde206dc6a67775da14bff8f4bdb44c19ab1d03c82e4631babd43e1ec5b9f04e3928bccc547e7d71594746d460b7edecff5b64f2fb9566b41d08b1217a496c8a60e518da147f8a9636b2525e81451d6108c915e6fd3d7d18d03efd3c74227151eb4cc8751c4205de19240a8d903d4dd0fe2f1f54f33f36842153454b96ec2303829540f6d0d7fd85aff20afdf44efdcf790b08f320982c507babd9a1475c49bced9e9266dcab71806840803eae7f1ab758d5ce0a773f414d4650d891872c99e246e559ade03eec4c4818f28dad850ebfe715ae672ccf837126fe7e40549c7b4f32ebfbed77a0acf378613ed3cefc309dbebaad5a604db9e8ed7c0bc4faf05886d6508b557b1e982981ff7f8bdf6bdb24788c3807a201e580ef0cec6b044d6f41080333e82c674a21f3efbb91f3277b14ee58358c87fba8c98da016bf165ff8bced75a6c5b0cf560c20d3672bdddfd8659f202d7bd9128fb8ffd0c80cb37463cc9ec035fae99acbfc51c43b5ce301d8484976b38341bc5d5aee2cff214fb2033e39e3c1f31c25d9087b0023166762e23e252d409ac4e16201bd635ba60bc88935a578c89764d36c41ca24f06889546f8272a1a05434b100ffd4dfa56bb8668946c7c704c852bef67ee1a0f9ea768168a5a8c45b88fd673d391d8e10493dbce46fa598546f0ff3aaf99d8c4a0503b95b0d7075405f0e8ed1202ead9ae3490a276f35f8c15370f478e8ca5408e092da0b4be63d3d123e6b446cd3a8a61cc7a36b04fa6818c8e6fe6bc420488304fe6e8837f447fec0e4a56596bccb4bb1b775c8702505755c8e4857086686f6800eece2d07caa741a80f32b7a0048366132467139173b995bf287f36aeef23c6c05bee2446bbedd2bfa8b0a398bd9b7b4de7ef053532df13069961bbb6a37a29d3aeea8633e9cd277a070b7e1ea450f1d50f5b0ec73ce3772fb5e2d3a353d134da88d21d57be05e9b3b7cfce92b7ba10e7ebb55b5750bd59d4258ba9fba0adc606ba20acf16a4b3b6b33994499a33268e0601dfefa583e0be00d417b4fdd0e376ca203093fb78bfbd0b0ceb2f30f9f7c5814ed8c3efc9a344bcab424188f53d93bc9b27cbf3584991b1bcdeb944d829fa163641da781a19274712a9d765167f44cd29fa44a9903c8d68b19f39c0793b9a695fce61494eccb62f332fb6f0228621f2ae0905e31499c7585a3ff8bd2234904ce9f974a89f68142211daaa255bb30f552b6eae6ce1f3312a7d48c206acf186379844ba30741dc795297811e80fda59b6e88a5fb978e4595ddeae3711421cd1f106ef6b82b6f0e2a76869ad38698911d59070a0288f019da28d14da4bdca4ada39a804c88176c3b44e6f178db1a3a61fc90c4b1b65cbc69bb1d2a259487d929d125f3bd05a9aeb0e173bcba61ce27b254b4d6485400b82ba37e1c49c5a419692dd07c64aef801aa2c27c31e4baa4acb5ccd6c8445c554abad0b7b0842b5f30830c95b33ebbe4fbdb2a7f1a4c69b53fb67675c15af344033c46c76e938b9523c43e786189690b71e5a8c45e0c9f9c5b63cad2b6982b268014b184c8726c500239bcc60fbd69c87046e42498617a996e9b438dc831337272ee9dfd9e433d1348d850548ca265269ba8266fceb7144c4ad6faf198027aa0a3fac04dee47f6d922c49e636b8d2833f91cf58a4763bcb024c72a976db61d3fd15bedebae154078a13e81766a2d8de79fa6879c3afd551739c2b8fd637e05b417132e6e3260c366b172f0a91b3b918d535c0822432035329c75f8de9d6081c3f7a5a27319ce2d0c5fac8f16e37c1a3162faf4c6952b75564044b10bc3dad240678ad0dbb59d5da392714aa2cf03c0c6ee53d9827ca5f0829e79fb8ac314fd3dd95ad6cb4fa2d3ec25b91459f4a306be181fa1a74cce0208e956f58795c5d8a488f42e4196641b19996c12b5a7194ffe8e8764407d3f5e02119fbff3ccf90a0989a40a9cac8ef3254d5ecf580c259cda635fc9397806c3b10eb7ff2234534cddf54409a3fa4217a23e45ac6c17b0ff5c2f71fe83e60b6e0c04dc1aa526413550aa2add63a4be02d79325e6c8098871c39e6b92ebc844b6b8f10a569dcd47e7db28aacf7f9986e971bdfaf0d2da3d3e9fd8be9a9b0dccc05a3cda2bfeeb835161eea293952a34f303f356f0b16aabe1ae643d9869f91c240e4ae24603b172bddb41e7f2d6144a7f60c49329ed34856821b48fd1429c27704d2d85db56b669e44d61986a36baf4aa022eb350b7fcfab00bc175a09bd579d46427530d316c9d38cb0ec91c1d469067cd8b924224b0b58c42fb90ad5337332d0840e964a5fb6b0535e746b6dbc38461be6abb48a46f6190b5ba674413a7c81edbd0f9a6753848ea1e8503a5106381c06b9e445e26508838916228d323299053f56b463951b8af0fe4281e5d196b09182050719af49a24af7e81b39608186dad424d81e7dbbea80dbac66180f777f3fb5c53bda96d2c3d289663298991a80254074156ea93693390880f9ae3166a532945acbdb4ad070c061cd2c14fe85ff965283cc333ff79fa25dc98a4ee03317cd6be6077502731ee0372715fe7aced3bd792d45902b23d0872a6bd746a91e25a3043768df8f701f682fc78f0e78465e039f1656bef8db6303c2b77d6d586ff653b12fab568d7ce30c7c1694d7c6af71ecf3a89852d16aaf48ac0c08ce9112dc8eeb4c77139af7b09aef64bfdae8e13975529106a5a411f55f5019a6755b24f9f60ae3a142ae8f1fff3b6a415005bbbc7acbdd9193ba57ed1fce1b5bc93fb0cd9173bef107f7608ebfbc4defb17b0b034ffbb2e1ed62d9e28da1f3b219c371cf472c568a12cfee3b89cf4c137ca58057453d198418647b014403e31d0f1a9712f133ed60d0f0e5a2fa807890b23d89350f99559c566301b98571a83b895d5af7957e212d6c0801571b6e34adba8e944188dc03b571d166661acc393311dd60f5870907d52ea489c3f8f89867dabf56b9cbd35535a13368950120a146b8bfb485ab892e44ffc81d37596acc55dbeadb64263a22bbefd2a86268adbd97e8541afc360c0bdcd9dc7c1d383010cf87d07fe5f565c4acd3a70cf91741160494e5dae5a447dc613e1d1056e71210cf1b6117dd17cbe4e1ec12cffbb28bc567bc59ed2d416678f4ea3912b646e16c036a5c9624b4101d4e8336de789e778ea05f8b5ae17a9d964f5da672e9dd9dd9e934ccca2408666d793ab699cc9aa7b06fc44350608cd4a9a5e6107a491752d5420b51c0b1b7850f7dfb3b3f191036ae3d1393746f0171f4a93a5ef426e0fc389107326371fb8789bacb65c71f6cf7e5017ab5e0e1c0cd6976711360ae94dab236a4018247fbac0b5620fad9906a2ace2dbc2ce36d6583bdb77301313b3323ef44eb6ff53c70c5512430b81646f3aad4100d046573102ca1a196bd6d86954c9553e72a50e7b0225f4d2b9a717e8de2431d3410cd4e1ca027ff74c52178c68be235edc14846013cc301624319aa40ebf4cbb365246a5776232c0b55d4b534ea81b695ffa84aa4d00ece526e32b6487356c4f97c6d89a59ff717c104ecef672698b0ed0faa1b5ecd257e4423faa9695931cd24c807750f6649496d1b86c35f12fbd4296846c891008a0cd91b484a2c59f14a5198c162c1201cd264817b5c323ad6dff4fec04a9c3e6736c799771649c6d01a1bcb6f46432b769c2d492d1d9d0312e7aba2d07b017694ca0e33b55b7fbb41f87cb630fd5bfcc5e28c4bf710d99cc64f5b6c79bfbd246f44048e307b20ac8503a9a60874dc5db994d9a1e79f12ce0ae4eaa65d04a9ec25cd4863d04e80b3855db8345d58005f974b2d734467205081b9240a3f6a5fffc6dd43156e784bf796755c5b8281f4a06aec830e63f89c3ec8af0beb12c70502c17bc1ceb97e29e2b084cbcc1b6f938e561cc448bbc5cd070915a8d33a389769ac9f3c917ca60a42b715eecc60ce0934d6dcd63c63861cfe61ed2dcb1e6c3da97bc815d5f9caeea2be6ec8d3db0c6ed238a98d07c15e911148741d3aeaaf0edb384d3fb0df09193a902f41f279c743a9ba4de7180e90f11ede669a5382f2bc79bb9b0ff5af5dc4c1eacd81ebdb4a8dff3235993538cf4f5dea22bc48fa44b612d79bbe2a83a18386ec653a1184d0a33c6403ac370d66a003ffcd61c582437817e2316f8280cb7ba91589f90ac2ef2da14cd7176e63bbfd8dbc9ca99a0170d4ee31268ace6fdda0d06fb8723ab2069e6114cd8d7c0f4fd13dd6d5387e47c9f5118fa34ac1d4f31959e97ded20ed3e13f50ecad4411cc30e37fbaa6067ef6ccc4ef94a353c161ef3fb4216720361dffb3df24c7238bb1b1f1baf9d59ddfe71fa16ed61f22323f8de994aa8774f97260ba753a6f239a74df376fed0e42fbb57cbf8f4f3066aa4087b8aeb53c9a2fd25c189d706a891cef0bcc2c5e9a6aad49931454b97fe40ec4a9db40d6995f8f5bc94c73252df298da44d521af4e8195472f77c121432abc290d54c152fd19184ef200a7f0e751b0e2ec229e0ec013decf373266448c0f8cbd1dd131b18473773325469e76642d57c615a75286fa22ec7fb131628ada5e1f7108ea3c8e99b99c3b086db021ba75ee32fe6fdbd3504aee875dc8c815c8114259e4ca2597c8c38ed3fdee6be150e40c332efc9616721f229c95bb32bac2dd2e4ee95d62c7004fbf08c0cce82a7de63a5219bd6a772a2b8d06136e735102d833df5df199af64bd8cbb1983c1eac0e5d08c7f6cff53bce5b418f47cebbd0ba7d31d20535e26743734b3c92796ddea75d1117a99423170846b4e1fb7846b98cfcbf93f046c82285362534c707a083cff6c340cba157dfacb204ec8fcd88ea0d72690ae0b8372e03bccbdaf47fdee74382e40c73a4e6e768e39c531e7b5aee6e4414fe57ac3d2ac8aae23f5430dec4a30ac130c295830bf391ed8af2b2f705fc1a56a56e423d0dc4990f43a3ded1bb4c6ebb58a880a19271c44c9c0621d43ab643e5fc8946c6600601f3f7b80c13a9549aba54e5af9be0a9b146ef373d59efedfe526790f6690028a1fd9c2e015855a6c0f91c03aec290334bba1f0a5d01aa1441478a93667ecbbfbeccfc59e5cd89aebb62af557125440ad562f01d39e45ec03e0e54ddac1c8a7c88d865b39bd8e9d6f8da50c330acac529b005662966af4b72581cfa4dbf4d412f991ef77a7ce83a8410008aa654bb096f3c262b52778743bd15c275a71d1db3a11790a6752b340bcb49d255055796f07f6c92679d14ebb07116e391274e8443e2966d27ef760afe834323727e6f310909c7f13ca5861968c68d5473437b7dca1f388fec28bfa2e48ae735d6d049a1bdeaaa6e28f361a53fff85ff2e547f788b7dcc4ff59e56d4b9e9fdca603607ea8f22f422e9beb68159d3ac33054cd9b184f812be3882a22f2c05ab15108b917bb0cff5d1c4cb39f42645b3dce2eb1e2bdb666823c9ff4bc3a5d560a6facd1d3f696bbf06c52a3d20e96d675728229e3352ab6fe003b90ea35b446ff44201c3137045cdf8529e256bee0ceae62bb50ea4c0c19c1b84ad53811cf8c869fe4bdafd0fc647608b1c4f12c1e1c9dd1137748592432e9e68f643a38fd716e7368899278560b2370c27e5501c6ffd5c11f2877974e9324e4e3b1ec508a5f2a665bcc3985f5b83c6ef92a0e64ed88e4961f1e99dba3458f5d0d0b4a5503b47c0c52de4572f52952ce29668d18546ce01fcc958b9f032e4a9ea0db94c796a8488d735f2354c5dba37177605a765cf5626f8e29418fd5eb8c760a4cbb0e0313b004e89793a6d08fc66b9120fe3e7ebb8d2b6c7ee3f0b5661c38e3891b2de22cef8a5798a332fbe7d6e6d9651ea68e6f739b29f33eb70647bb944d5f061326858f69dcce7d4f6f8b2e29703478762ed9e2acb76b61c97f126af69385d573dff7212a4c0b948102172328901bb4a4b660cc4bd262da5b433c300995c762d987c67817aa8d72eb5b774e9410f3869a74ec702a7c7f6fc1f58298c4b75507b2b87f0bd882fc87a46ae57ff3aaf793d8460ecd6dc1d594681596231e7ca98d6bdb372af5b1c458c4e0c4bb2077e429fd28fc7b311877ce2f3ba92ebee85ca61ac8451153ca21a19043baa922506fa5d0b408d909b749bd9c4dc227c5ff8c1d7bd2fbef808713d65b75748af4b354b7a939b7348eb4d11fd2233540a7ea15ae5826cd1a648a4b19cdc146902a41c08cdd8f2dc7635c2f332876353dd78e89cc0cbb1525db3f9db1ab4ea11a2ac5fceee096a79ba8a1109723e1777d82fa54157b6a4ab2cff8e2e030b90ce4861133bd11d880fa68d523ff7171b450fbd8ad6a5d59239ea504005efa77312fb3f67a5f4f8c3ac66b39effc315bddc55ab240bd281e8222d337782791321f23ee0782773ce6b06d10de721cd62c5b3cd1d0d64de0396dd2018f5a200211c458a051c84c","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
