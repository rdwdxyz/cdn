<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"255bda92667e7c731e0742610537e4f0eb70b48689eb53999c12e0de6be121fb01433bac29dbc0ed982742742e5f9ba431bbc1ddf83a5842ad9b9d3b72c6081878a2e05420dc722f796313217d4ed463ab4090d9828daa80840d1e1ad1d953739fda0654c54ec807e27b691db79a871a411e305105bdd07cdb6fb1aa23c60c67329dbeb491e8e554a81372f0eb9b015e971e57c93f49ce301beae9f51d9f53940badaf8ef087714fe9e8049172b632a3fe5e4d2c3a87f9b1cbdf9841f73e74755cf23934e3f3a15cddab84e0123349ab7f17eac27cc0786633c2f804cfafad98ffb5485f2cbe2f38439763bed8c09e3b500aab4a424d48dd905bbe1b93f19c5a1acf63f8acfffef2156415712e47b19b7483d6c1b5631f360539bbcab019e1d9bf9c6adba6173521adc91fb282581b1d05587cf8505dcf2a7eaf9814b98db1e6dbf7b7f7be9c3b519965efd3f1c720766e3009dc0547daefc6879032cfb01940d116561bfbe5350d25a69bed37019877b1bf4a083e0536e8265ef3826d563fb1c64facb3f9f218f612f9907f6c48b802a54c7c375ec6dd1d04cf37489b4b81c93bb352f8843e4b101ed2a0d8d7f461cb472436dda42cc6b313374d7d4c5c23c731a1b1ed4758e30bde22b552f1b0149bca8b7b956fffed21876e3d4a3abdb0df02032f5536317e8bd4060e481a217cac5bbd743da55978f8ba729140709d2e8d63d0d713680f3014f7a7fdadc64a23f4de1922c8b797e4bf372c54fb9bf0ef3e8a182508851490242786065873e6690e099d38a5f5cfb7b74f2662724e1faa6e094d3d7f93d6ec441cbc2927fe5501264bdeb8df9156977250da0c747b2f900512870ee369215727c227b11de2209bf4fe47727e618b3f1b6a889da0822696cab2a44661e87463bce2d915183a531a406f081565d0cf0ab8c432c4db6b334e369b1d60c3bb0af8a7c10ea670aee2365ecd4c9983f5ffac0a0d8c5bd8d1fa13f8e5db94da0c51f9d47ec4702590bd6a8bd161deba618787d9af1dc49041a291a8b95fd4768884e1e577acd154997500030f319f68c23aee7cf59ac5781bc6153370c57c3791b891455f6ebbd359e388bd0ef20427e08e24a8b4b066a34bbdc886cf940f8385da761881c49cc06e2f3351d936e839a4e39917021b9bc7785b56b231771c761f280699c8422d4b9bb7fb0f26e43b44ac2ac5ea2bae9d1db471da494baa5a497c6afd3a847be818785cfd73e5da0a4b1b255143b72d9fcf87ccc46ff330e38869a23d4054a47d229eca67ce0946461a778175604f6b248f9c9f1ea7463d007c6cd5e36d4f070f8a72598f171906ddefc7cded3f9d637c01045efadb274ee612b65527f0fce2e60cac00c6c1e6fe768d3008150771dea2d47fc8fe71a858a84aed1ad4509b7d19256c73d9213bc07edf8537de2cac036aa07f661c634cc89352c1a5324ab58ca2177e2e2252ac84e7116a6024c416f20df61e8a60a4659c756a93d43db5e207ef3cf136ecdd8d9f143faa03fdedc99fb94f0971ff51b471fd856f7ccf2c944cb8a9db8117460ca42d96926642d19b6ed8362795f7bb7881d26043b76c2d2a7c8b3f49840a0ac202196f8b06e6fbb48724273c0948c5799f28d8cba2d357229b956f1072ccc981e49cd71e693a0fc8276dfe2eb62416a0abcb263e6a2510c66ef5d95d16764585822743e14c649eec88e77534b9bbc94699afb4ccabc896f1187fe7040a227e15247e6ffc70903c47842eb6ba9dae7c7619bef0c624a0d9831cc296a3fe5053f24d196b2b5128b14fea875f5ec108b97727057a90a7e68064bdfcd22c9c63f41fcc5ff5afc81cef1b3b61619261e2df036fb95c0c8c19ba1eecd2029d27f06ef0296692d384a03c4764547a6cf95721d3382d93fb2f69ed27a3e2273ebeb45baabb5898473b4728aebcbef3e7127e5dc3d1e0db91bfc1ad5768745bbeac5dad1513ca0707222ddd2b7b7327519690771d2c501b9844f7cd0632521319f1e2b402b56ea13e4a49f500c3497268190d706184e996138f0b094b3a59afd57a2dc7f3000b02521019f5e81989043b4bd4c54b8d0f93b27a26557ffd1fcb21d128662759d65b87412240940c06422a42c354fe3adc74c1ce1c2db4b314ceb0064b9fad242f0b0cfa74efa7eef740d4e54a204ca2f1ff44972e5a0349851a5304bd5040293de685f15e74c01c4a3e0b4447deb070425ca4412e03ff4ac01c3806c25efad391fb81b19802a5fd9824b5d92f447083571c061cd16859a5a0b4ed11ebe8cc2b13afb2ff6f8eac41e0b630b7bc2f3379a21d86373585bbfdc65d530476613e8763bafa56b72ab2e6afa5268b4479c6db99e01823e45588914ac1dce7f6e2b4984975a5fbd440cdd26aad5b8a26d42702f1e5006d9bf35bec76e3b5dca0577450b87fc3abb6816646c1072612adfdcf3e934d4fb1c6325ef9e6d87b7d70e0d283be6ceadf901bf8a1bd41f9d712d0935f68a722e79e7039c16c1fabaa0c9740f576c81e3873902512f4f766ba769f4a8bc4544960ea06909be343c164df07845058f1f50c5af5e760b00983f788614fdf8dab22c3320dc7f2a605118edf2741d8448f3a3f80fd8cb60749b8c87ad10cc0abcc0f3bea29c8299040f0307808cf89d9109a3d729766ed30bdde0bbf67ec0c47c15fce42d80394b5c85873f2041d09092ce3aa5e40ee00eb5e3e7fd694943427107b666c5a2c64bb6c5528fdd5677f8c6610527c1b793ac69b0c0f8bb685541a91a2e1091d664fef1fd20219131938d08d58b6203fee586749b4cffa595e85c01b7fcd750afcdb8c60237906a01727e133cfc28391219489f37b4376b9486dc7af3203ac604793459280d37b74b1426407de392fe23a7e25919b5ab8469c167c554d315216f2f9a8d2415252d4db84cb5e43849efc7ce8bd651fd0f1a3a2d691a4b71a831bdd101f844bfd9ce596f9e19fdb544ab844f0b92b2839bdbd0ebe1b741d36c2bb741ac9c3e9069c8c66d8d5974bb18eca999a1468590ac6bf1c6177b60ec052b95a3afb030afeba26e7bc95ab593b0d55d109080157e6ac03ffce9aced73c5aaf85a891b8e6d3d7747cc2c482b26f71ceb919ca6ae632a7a56652204b9ec0b8cb1693099bbd3ef8451aa01f6408aca2f7a7f2d99e93bc51024f218c9a9315bcd00aa8e24716c8b91f0032177b092a4389cc1eef8a867fad04729a64a91dafec57b47d4762f0c49fff8b59f1e3a4560d77e6371a6da5bf64260512833fe4bcb81fb703c910bc1bf1906e23eebb1445a8650f867ab0932773b35c0046f437fc6df02922bbdb0b417d566dd05b4bd5f76b7d21721e27d4bf74352be8ab35f6cc47a22f9e61879134e180a97eaa918ad9dca23416f9261809386a37119f998e9aadad2c17ff0835d42f5fe199c4219740c76ed2fae99bd5614a50bf58953142044ffb83c36e7a4e4fad23d4a1539110d1ef66747b826e6254b5c3e43951eef1d949d85927e9c48700636da7ee4523a4b95628655a1482f7979078565b22c2b86a0bf6687d498933060f56679436fadfdac80c5b345479e4a634dde2ba82903f12560a367d78bd20b4640294628a30821266772fc75b080f7ffa41f479536357a55a078fa6f3d3430b842d5e50f8af8cbe0620c149f5cf7304ebed0a41b81a3b2009d6c71102e04f53d28bac669078b4ffe0f1e9e0145c4dc27abf078730c10b630f26e9fbe3a2bd532d601a22b646f002302e269d3f0447b2bd2982db5dc9916d780479433ecc42a58435477b9d12a53976580bdad667c872c4dfaaaae231b8b23df83658cd8565c3a64c6a95b54d3d1dcbaa9a2981a4311e62cc33e3bc320f606bb442386659cc88eb560390dce1bb614fff54b98bcbe36e0a68d2db44830565bb3e4eeafc12578c641114680d0753b431ba127294e3f8ebc71802ee96ec808330847b78f171a7a61c654a200f4213c7775de92a527c6ece4b70a158930fb45735741f3bdf496e591b5bbde995d38294c31b3f56079257fe4b30e80ece81e23efcaf95b8aa59e73cf6fa7e12e4c281e2c6e6f683424e779dcafcb4b201dc3e98bacaa7c5f7c5e4134f8e225e581e18ab7ade97612083623b2a17fdfa79f3f081ba99a08b0f326de3194ab9534e43db8cdffbde46c6fcb88429d181bed9412c646d292467a24e32ff449c9778c0d2ff405d7f1a0a0432ff5bc511ad57c064658e7fcdb26d61a3945fb760b0966b8cde01e452536e73fb20fb8d84c8278daacaa5753b3f73be4a0200da849db2b295d8a1418f6907af98cf852e293ef245134aa13919125d709ee12ff2812d21d8e846e3594622db6adc71c98638d000693d05b0737121f0e0bdfdfcc3faa747f3fcf776277b12ee6aff075b73a80161be5481d5a7d7412f0abd345610d11fb398d15770fbdbcc263151b55e262108aa6b6a57d2ffd008e2393395903b040ef8926f06619e4e603e6d2a95a9c8ecd8895f088aed6bd83964063e2bf3d43e1f9f25e9c0242becc705c3bbf8c7cd6964dbd1090ee2580cc93eaef574fb29208f59c4e23d0a208b8679ab9d38dfd1de800e938455c4532f8eaaf07af218a5c219ec3ff6fa8f2b8893c8267d376c527852b17c9fa0c324c6ee672e84af0043ceb699e55b336de928daa694098b40d673e813c27e83a87fe3cb6ceb1e269cd7072120e2aaa5f6affc5f088078186aaa0a0a3f98e43ca65db306caee4e17e1170d54a959e010ab0eb50c880689099d459dafe282a6760880e29563c8370a8396cf1ede14010538c3b1072074bee6f43a690f700ecff6d806cce1ce88d81e41c554b277e1186eec50490be0c77ebbfcfe8d3e1fa0f054ef0745a0ac12e607f9944cee5fbf7c58089a6959f36780b6146b6ed7cae544a469f8d6e17c49b20cf40734415eb1ad43d4fe9ca6705ae90f0f5aad4b6cd8bddc10446a69540560cc03da3f8aa114d1e7d48903dc9e5850b3c4ba97cba6976cb7d47700836d8ec863d55ccd4fb7a07f04053e1eea89f58878eb85f201403772179f7a36dd48c875c7128979176be493eefb164d8dfbeb92a38d130c8c4ce81ff30da71d3708a935f7e1df2856185a1a540c6375afe2d7de8e8087aad9f210432ff6ce06552f9afb154d0d97ae7b864854ad300d81a242449a1dfd55e520593dab4d0f96bbfa32f8625fd55689789a2b59438d464886590e85cee062f5904b4e6a4bbb82710b4b2d627958a37b6ebdbdb9ec01c39c0c5d221a3c4f5a9780cc1e88a6a5940ee94bf36ad87869ab86eeb9f907c3edff00423444105e3ea29be55c3efb2541e6a9675e0f90cc46f67877e612680566374ee4223a7d689410f24cf2e4a3c727cefaee356834460f515f653ea56cca50e26ed3b8ae97d0fb49272e7030e773161b0c9d65e68ddf3f20af1f3404e9ab0f4366bdfca61b279434f9048005622253afb2a13fdb3912561b3f4414afa86e1e74023e77af185aad4aa80bb9a368c103db6c15dfe85ec12e306651b74cf67624765667b95199510f31e742bce8ec3e9a184dde53845761dd2539e080f7dad22ea49becf60b1eaa9437d269156d7e9b061b0acc35462379721f4f3c4f6be234c60fc0e20dba29e60b90304b6403909ee28a1d0af29f0ae7e4bf6a398f68d716143ce33c50aaba3707811d0c76a32adb6c82aba8641e1df2db6ad1b0b958fcb9aa3f12ab487744f1145e5e8a6666ca3662f96a4babced8ced0ea306ba51111cc46c963f791d33c80d2ac7c7479f32ab8042027660535dd8e25f6bc343b3aedffed949e8270ef37de5056a58add2f17a4d7de6ed462f39674624d0260b936e4fb25f3c22812956dfc9c7af16ef73bc88bfbefb3e77457b39f3f98698c8d353b84fa7836e20a2181f7f82f1846f4a286233c8009ac6130df8858f5a09d8fa0eb42323a78a40c77f06f99535b53bf7cd80d30d5f367eb42782f9d4e6de4056abbecc17b0a6be407fee8525f1e4339251d0b2bc57820a41eac6c6183bef4cf9878a78b9edf55f5e39e56c4fd8588e5d99e79fd0b4a97968004e156ab96da9ac8bae140512880848542e49a77540c6df41a7d7656586ddcbb8ac7f1f4e5a69f5baf41db96a922e53bf1d006c499c7b3ad2500016eb509a8dc670a12466bb4d20a41a5f1b14a9ee70f1f29830b05c266ca5caa3ae2deeb3c012cad06ffdc36caeff0b7b57f13d66b3a0cf9c29167e31ff1c01cdd4ba2acff4d21bade758ab624a9d37c579869d9bc331e8ed080e99a8015f75d8095ff950aa29aa008a101cf827bff3020f716e0991ddcbac4eb205a6e44bc5c5e176272c10387da9de3e505c0753a8aef6ef27a78a3e7f885f972f05ade01d53fe2f8df5fd7a511f288c94612563468a41e8b00affca81e084f7ed333b048f07b3e90aa994dc5d895502342be08299c3f520bb6dbdd00607496a364ecd3d8c2760011fc77bd27c39466b36c6dc5f731634665f4a17f1e1a1c1c4c7924cdd87c09f4d17775246c48c758722d6a3ca1811c45e8534523587cabb62ebcd4d1a7e02d18a7bb001fcc688a2449ddac021e10c78e9ede6c385a4e2c498d269ac6f7b50965b8edc0c1b3bf49bf2c7bc6f5a80a34e55953edcee28dcbeff9e44eeb878850c52b0cee347ed04ae4404013dd642e4c3662874ce72ca4bb1989b0a65343d39e37dd534275ddf50708539c9e2f0a29e8266d2b197f3c5e9865c3d3399bab5ecfd0ded733f4301944607dd8493ee4595d973d594e97bd6fe0dbaedee8eeb4585150be76c24a7a405cfaf74a4fd25489db3b3862b1b9ff0a7831a949e76c2336ae550fd2e0cc9ddb3ea04a34cdebdeb5e67b764632e4f3402433d5c615bbaf3fbcf819d814707618e69a033f8bb036e4dbe5d91cccb050addde722ca9b820098537926b8afca52eed51e9ee1ca4ea0b3d2bb349a5049c6d069ad472e061bc2d02f0339024dd004600b38c19e1259972ae09d2d91d03286fd3ee2588e9a6348ba73b08a057879388759c5dab7aa1eac6a12df5fb77207040e8a02c0f5b19590ae4e71e6676e1326529341ebc0c67b630e8dfe29f2c67f9d2c3e6fd21c988f4ac1b8f25114ff637d106eb6f1243ac04ba0dedb32b0a2a585c011e9b7cb8bbe29c01e3becaa0d298cdd1b3a12e9cfe98d9eb5177d9a8a9ca5162ae322a062771199c7b77f31e3ff346db871b461278479e44ae95c92e5ff39aca2cc5880025978594a7158eeb4529eaadb02751f84f968723e6014faf40b40a0efca75b12950016c428e28028d07f70d07ed63fdc122d0e1344ee6efec62451bc3dd92a3257e7cc32746690077c04c5b4a6d897049260222d9c720e560ce9598a8e2914eed76d42974deb9929af5296924ac81397cef639fef1f98ba6b5c50f022f1c8986032003e350b5ddaac08ba670ef90264fa3e030414dd5980ae4fe1ff2aee6ef318b796f0abb017dcdf5ac237a4bb5b9040f1cebca0e30502ab3a1654362036dfb6e1c6c538df39017da992be04d371a5723d58b5364eaac98d80a59e0f61ad2d7e41f3459f3426551be38c80cc70dab6ba9cef330f0019528441b331ac9fe7a095733ec42c55b966d1568bea67dc3c7ac84a6df38b342b2326704546d1a8d8a740db9fe8f735308ec58d50787070be1c9df272370d6ef719ace426148cca9390be9b0680a3e1714343c10354950df3ebd215da1d52ab46bb8c8504396d76eac94cd35598af9c69ea4f5c2fc917a125b5975ae74d7f1c3cdfb87432df8a7fcf4ccbb36615375f564e6d0126e622faf0e6769dba3395bb2745d2cc886732dc3bb19d6bc345c55dcebcbb8e6db6e22e80a939ef4f0159499fc6deec2c214ab77db40964146fcc414f447bfa5f5beed04c73bf8dbfbce1add83812891356a8af4a380593653c48b3c913a3c788b45c523812b70c3f53144898d5358389a761f5b4542a35516228b43e18e90fa4db12b20c174ab1745c7ffcd0b4f3b063a572bf2f230b6e117c36b22ab551341fae82136064b96bc96e2d7c46f145e6c3977b41b2dc0fe36413c76c3cf51f49e4dab5c40e707f3795d4bf4dc6a964d55887069571e7d74ab4534769b8ebed491eab55600c75915466be4b2af0b0397a477825cb68e876ef413f2deff6a4737c2358b587771cbacc211914d3bcd5e17b4bb68b1cccfa260ef7f1517b2302859704715bb392f4fb50cc1cca422fdfa17769d6f3c63e60c4219774522ecf9bec03ba50c82102f143ee20de720eb55abb3fd6256191e711a39f754b09c650f20e7c2cfde4d2fac3945d49355746171507dffe6fb91e50e189affaf6069301dca1989f34f190de6df0568020aa0a7f6d11db51e1e4c647234e8bd3fb3512226b86737609196484991745112bef9bf986c372670f55b52a7e2b832f2f4a57b0e1e3e33409ee3dfdd6e6df98e74ebadb80845d0235eb86375bdec2fcd6fd8913b7235716f61500c12795556690fd24cf748a35b1a81ad5592a1972a341e7932dfffe390772e649e4d80cc25ab21cb957807b9ffe89fd61e1ebf9e346f4c6055a79243329ae42145c24de4958d491710e95aab183be09aad68c589810b3138e8953619b1108ba2ad4fee4d22f87a064bb589e54b9c1285f07fa1e2aa9fe60d2bd165929a4259cb99719725e5d9952c6851906c71f21aa1cc77229a51f2190cb3cb71eb0ab80d2ec5dc06988688f9785a38023c254cb6736261bcdf3d0a5387dd86263771ee22f7487b4ed85d69fa609497216f20d14de2258e02a78dc086bbdf60280a0e0c799f01444c903dc77687c92faa1168b6754ca015f5d581adac83149bf0a1f50d56812e852aadfd839bf4e289f84c539b2301aca3f755e1bbec6bd35aea28d0887443d06ae123f698dadc2c70cc9ebd0f3448bbf138725476a6d6e91e40caa5d2f3ef786b350936ee3b2ceed8218e20c80fc31aa490053b7fed8bd77f94155590dc873be189e972ae2567303516066706f1a0aa4b69e9c3953f26fca9299616d2e014fae778f4313cf5270f280d906e8004572ce4df0d8b43340af211a26755a29b0183ae9f8939aef145d2a9c0442897ff8501ed1735cecb647bf58656143129d03c888b79039d4362273d22c158312a7c559ec7323513c31f2f19d775a98e68eee3556dae24298ef903569e268dd42831fdd2b78c3591beab4151200d3db17d2c3c252ffdf9243de462fb876d67fcbd31fe7f15db9a3f2f951a91ea3c4a3a0304569847385c04825ad256e095ddea77edd56aa2f13e7990e2993fc0fd5320dbbee8d6de9d2eac46b9db82b3f1013ea8cfaded63fc40b25fbfd3af2aa5f149d1159f587489a2411a3c78c4f22bb80b88231d32a36d318217257a0f64efd90d2f7b8ab82bc5a34e1f42cfefadd1bcf62a98736cb07a2eecebc2feed40a0e1bd7a05d5a7af8591667975d5832ed7f833df6a9587dc683b5a27e1a5f0c56b1bad91a6fa07ad96d1dac6ee555c6eb196d05d3c9b527ee120875798773fc479c595ddad882ea7b12ea2d1c8cff2aa28bdafa67c7f922e05201078362a1ce722f3d19eb71dcf2ff6aee727c47e450be9e546c750b82e12150843d9a091e3114e8e163a5f24ac1bc560383941c6ead94b3e1a53bcb73c353b300be9b10af1ce6cf561a193a9f4e02ad925ce0a01d60c4545aef7c9703d0fb011ac24708c8ec8d73245d044553a9e4a7ae257d5e9d6089247695220d860c5bc041f24e6fa0db5422af1472c82aaf4d74c44d9e7858948852902747c36f982e0975ac073ad32dd97a09b9e08dc09d892a8328feb83a956f4a9728b90e525f878309cb7d2af7f6f8e721e49a50636820f40505a29fa3d552c1661eebaa646752e2dd677db235657b000919eae462614f6d3e774802bf7ac821d53ea34f04194f4092ca216c4ff3ce80fc004c2bfa168c5c839e07f86b2f8d9ded9fc3a80a726cc941bd6aa57ae9086da6ca90ef42b2e1978ba730ec0f6518ede02036cef7546b822d9698a0c8b9483f7d451092117fdff0148d5c0ffe5341f22110f1b84f5795e3961e8c4260cd9df2810f635c6637d1fc2be3bfa60d275a226c47a403cf699cd274d181d63fd284c6f0718caed8c8d4dc6941e604e3617818b1b92a7a02a0fc343a08eaf7ab6a557212161741eb7e60e2e7cdf0577ad8b39c2820e20fa006dff2aee0b50f1d5b6e023c1e8f9198acdc0b5673aaa7b4b5a1be529673f931f7e6f2d06d59995550394405309cda3596c8dd1a2d300edbcaabcf2aa27a4fd68bb913bf38d79a53b7d69270830994acc5a7b61db3e6f1f58e24315a6a86824eb040e89dfcc2ef7e41515122c7aa5ec3a46fb5a0a1d90e48f379ecfc17187c5d9a609568c9517ec3a91643d710d573e7815d8a4585d68ad832d7e97aef61e23c561496442d2d8a9a0245d0505e7fc9d9375503a7aad07356180e929f79f9317934473266d650889db600c33c48bc8b19f44ec4b633306c4dbf89930b62e067020897bedaa6fe8539135675c141408111d4231edf235d69a021f91f214cfbf87abe2e22f0e131a62ea442b1c54aa10a2e7f2822011a8d5260ede0086692c6185c417fef6b0af5d8dd5a9cf1ec4cc95969aa56aa04927e4565b4d16524825fb25601cb90f3c4b57795db4cc7e703d90cf7b29dbe50f80c42f48463a4a7021d39a414899a4f674176a88c70c5ef3393432caf5f7f6d31d4b56faece51a443aea17d1d8de8225226386aa501452c58ef86fab0d1d186a520cb101b2891e40e12d5c18a45215462e6e63d7b600d8ad328f804eef3b098e96c23067d70ac4c7f5da90a305cfa6edc137fec6ec81106130867806af92773fe2d608c0ffc2f9dca454dea5989fec8390632ed4799c6fb07926bebd06809b9dabaee00a509d9a708019766964997a87019ae2ee392e67af18cb93d30e02d866e10238fbf6811221aa77dbb279912d3fb0863c203701c2c6575a7839723aa849a4c6c9f7d81491fe83722b5c54414a0908c6c0e1392e2e55d4ae566870026cba5bba81559aa94ec0d9354771cae3a32028413b551b4c7759e7100a8d41c23980c866e8aafb9e9a3826a531beb5f5883e206c86e3c3a6d2da5676568293ac88ea33516c05b1896a12fb62218d06d717d60024ee5e1b624103995fd66a5db06a0956db0b3325755ee3e4df634c42720b893381c4697480b318f94b15dcbaafddfcf5b88f01fc4eaebc0fb65c4d169e406f9b84b8b973852c489f625c313be25e40ed83dc47873eff5a46fbbd43576076a57ed434834a595c10f6b5f77cee20f186f42ceebf443bd3b164f163700afa96644ba53a27a617175b22a0bf627b816f8f093ce6ed74d4c74482ded9469a40c78ac2cb53ae368f50d21af7ee4173b2272f25e41f9ce71a4658fcbadcea31c47bc30a8ea05f2439e11360fe02c95363c37b9523b724fa052fed324dc934cad05c1ecb6777a2ae98934a89970fa95d00ed2c61d6dc22727a7e873c4e6515a7f178e1ac6c1c03cdf87b4a5f355ff9e40b093224cf80239456772b4e08f7d44c1a7c83bb1a9753f367a1f765783e3e27b3b84057ce4e7206117a3c2e4f575be7c3db803a27261d5ff8d7ade71e0d75a63721f7b3161e6a239303d39114b24fbe8d40fb740237e477c969c911f4e5aee783e167e8b279fd62e7b459a1de34d4982c61ea77f6e6e418c2d3f696be0fedfceb87f91e81efdc8e8901214674148a5105bf5fd377f39fadda332e6446d52b46326c4605d5533b321ecc8ab8f55396b263366f4e85e9ea2177e2236246152494d883afa6ae5a661630e261870989fbab8c1420c767c7a7df1f25d634b03b1a5969af835f7fcd3650bc66f63b9b6301eaf18871c9d8346b8b3e60610006e34792162d2245757290f916674ad4b5a58c7c747d5aae28015a856931dbd6386c386f032c05a4e62bc08e931eb44ff07ebc2485a1f78c77bc029206c1821823937fc82f1f56f5d61cea1238370402518dbbdd354b3da6899be0c0573d0ccbc5f4ba35cc51799c1b128db1a387a9f08171b3ea65ae29442dd53a26c55015bff6de26d0022e66fa050ce9fba2cf8de179f298b87d90027936d256d3f5317348b3ffda0f3af5ea1ba1e8778b0be10d50ed76186fde90fac680110f5906b28d3bd77a94334a67188d30b9dde1c721f25cb0549cee8cc60673677989cc433052fe23236e673b38e24dd5ec1de03886cd7579091227a31bd6cb5db94c035405a45e05413b7c36e1ee7fe9c577a5be4b3ca1985562dbdf2c6c7c67396f34bec35a4fa6d6c75d984f3e6450871517f23e43773038a67168ff6b16985f755c29aeb6fcd386fd8a42504da3654c30eb5933fd008e1b40d89a922de9f246f63ee795f4a625616757e062dbc34011dfd7f589d0758fcff24dfd8323fc460b8ad5b0263265455beaa0062ce10b02a69b437e565f187515859da3112a2035c111f862f0a3a0a153eef51cb8afb23a4c2fcd98d5e3debbe31538dcf41618ec89782208df50594209d2150cc377e2bd6cc74c213e596d39c72d9b75c8774fd9487ec8e84e3533c28124b735472e90c3ca501d42fc6f65a2fe5a00f4c343c1c7ad1954119a5d810af650b1ccaab33451fd88cd899a64f32bda5ebf22d5ebcadd0460b66b6298a73e3df9b54ae6748731cc1f0bc324c451fb9f19735357da5e675b2e915d2f2ba702be2ceb5633e8e8e6ea3b76522c26647eca5aff6d54fa91905d546ad3a89197d116921c7b5134887aa1d89bcfc576dd9e480e8a71b44fa77d5dd24d3dd6d59aaa93c8f302a39110a80e00317a8c356d3e3d7ef7e8ae96e59a17471692b6ddd9c4471508f319cb38279085dcd12d64f5dcd4828da1bfdc549b1dc2f7a2477ebe284d1f1c970fa57cca7b168fea03438855be0cad4d0b10ec3725f65e872afed44483ba056d88b5ee82b0e6570bb36304fbc61f9b6b666f2bbbb899abc8ddef99dce3d1162c3b6590c761c82f13cbf191ba409a3dd0b1f275085911bc008e4496353d58f71a3596cd578052ffa586ccc94629b5998ba8fcb0fa3ef8a464bf19748fb480bd372c95d3f0438ab818608662c26ed03621ac40b09c8f1068ba8ade99a10b1cd3e1d6ff77fc624a9c6d2fd1be73e684d82a352bc30ec264f6c607c38fc3b2caa27e9dc1936fde433c88d22285f596c07d47ed2bdda61141d5c00154fa4e6488957534247a53079bd86a4ff0df177710c4bafcff6f11fb363203f08ace93fe27175935c40c01c3480f43c06ac6b1902dbefad77aa5999b5ef542aff7410c5a993921521e1d6b073c58b6c67c22aea09fc78316ade7f22a91fb498b0eefff1b1a027e3f71acd1f1bd9304a77817ad60301479a460a78e66a29215b56f1de20cae9c529860f8ff47770d64708870b97d06bbf201ba3d46bb60ae5a8a442cf4f3cdcc09189d290951dc49c8af84c66bc693045ed34a2cc689fa88a7d263095d019ff500d88b5db26e726f68f41950dc96854ba63363f6723c632cab527a682088da8c58294d6bbaf5afafc0ce5d735ac86f7503802d4febec1367fca49c7c31de088b77e5a404591710418c079b67527aaddcdc6f8a3cc941b801b53809e0bf6ab12ae4b800c7506d543f0e37322d4c26183b654fe3606df2a29d883452ff3337962a86b887a94a6c6e67fb2cc044a90916042cccc89bdb7cf30f3c51774cdf2fbb48e00a6c58aaae2677a9e32a54e4d481b69160aab6ea6f7ac77dc886089bb098a5151b701f6bbf5e4346044b2a4f2e2ad64c2b3bc092ff1590e238aaefdb129d92d8225a973910e6236db000a04c483907299574f2759004bd547daa295f5757a365e45c4aa05d14969603081fa8ac90ed8c99daec13cb7ab836c8518990b65a4e9974e06d727cb3950c08a5879195321ec90bbd71c165f1262bde1f2a00b5e0b48ded5b53280d0643739ae0b250509a3a622584373274f4ffc133183968d5cd083d964c8ebefcc434770f07c3c558dd9ed266672bb47b374b3a900ee10852d528428eacb690c50983a862b0a870e7aa2e417017192fa1a3279e8e2c86d689ce475515033a35107cabfb4b4c0223ad49c37b85c876ef0331ce86363eab694581a9b380df266f8898ccc74c993ec13ef2f91c5580e2960d63ab20b4fd489d3e88807109096371a179605550d69e01b977436e498e8dec24f01aafea4aa197afefe9fbefbbd837e6f0ee235ea1859a1e8e4eba876b22d1e17ff2a8c561991173321652102f5e066b181a7bbbd705203e51abb6bf7cd1fedee8bce35e386fbe29a1a7df71f3e6da3ff8c338832eb1d8f1914d627c59a205c638e6afb7108a008d6690c17fe77bae2a7841b487fc79ffb12190de2d02ecbd5568dadda61bf6cf5156cdbe0d885adc0eec25690b2ad6e182a298c0be1406f3091490877d08cc4f847822bb9db1284b3f3ece91fff09984414eaa680206833a35f4d6749d647c6bb2191e0df0d93c2cfd6f86eb826829233205f8d67585e04224cc28291200ebd28f61efdaf628084a06c9037fb7ae4e9957e98d9a5c724704e4531856262ce956111fb771f2983a5f607939d0460930b484c49ac1492b19713a1220c16772fddd079586ead992e76f36756ab1df83958aa11b8c3cbbe26459b108471beed2c5e229dd8d1522865d7af30074bc85c4f8beffd4c0f4e9658852ea61083d88ff9d7b6f1e964986aadf6d3b23ddc6f68f1132477ef231c48a9be430daff731b7dc096594b8bfe8f1cac823195959ebccccc39d15802e8059f205e795f6b75518860044cad62cecd926289a15710f523a173f01635b9bcebb9e9a3b0ac434b424d83866725741f55f547bfeb8ba24996b465138e88699e18557cf638b5acc2a30224060102182939746e0e472a119ebd1fc4e0dec1d6f87d7886f1748d5ec4a1dc65d71336b0610ab26b278079c59536e319521abfc24d792a1f9f43c5a0ebf1aa4aa43c876a2314331b6b151dc6db234eb54063982bc0beb9c0ef8d96cbbe1130ff78c856e2b78eb4ba08922aa55694e5e5899bee7e16251788942dd1306d10152782befb1b1dd25edcc82302aac065b198a67bad06abf9533a740b2c0aa9dd68d3169a01f58e57259a9815c8cd01b078489130b7f18fd14831b8f1e0d5a05ab9698c7","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
