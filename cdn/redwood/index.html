<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"71b0b9df4d8d6a8bdff973748fd6704b204b1afdb95a42bcdfb0367e849d4b3905e96ca7571ee533f18e7f67d030c095bf5e42525d100e4c163b04bf19ba58126e9784ec14f3abf7c145e041469b8e737a6e4a6dbdf1cc1820eb292aa8f897d25cd17a7f7dea8ea8138586311bba5d91d9d078af63f9ff07fbece872e4fa5d097227ce81a8be5f1e195bb68f3a5f2399ca90568a45fe32a15f3565873108b91a3be2e54be4aee29f78e0aaa752ebb5122064a375a33d5dc3ffd08117837eafe0db5b1aad79fc36bb880351c50462476a3b44ec85f4f69ef46f8f2e63678e1522046dcc47aefc8df8e9042f59ce9e0c607ec4f4400e96272e3bb10e8d6488a3b4e4ead1d5073d679c3c3888e39c3ba2f66b4ee112b27fcaffca14bc4abf5007455ee5aa1307773a74404b0826b2801d551c175e08d486914253e01a9c8c90d582daa375b4bf09723f48b66692adee40935cc6a68128f26a1cc0eb2cf361af8bb951d1f18a8410f7a6680749ebd1c9f583fa189b14c1c4b6b5fb8b3630387fdff31141c857d370dbe3a9fe3ccd77e2dd77aa262f65c6b1789d1d77110ac25e440b56caf9bc9e93d4e56d3632650b1eae43530d018b384212ae4447086babef8560460e93d861001a3d6a107f0fbb7e1c384012cb896c67f33aef22671e17c89ff55f6a3b88d39f12c368d7c0ef7ab3c63cb48497ddee4f1b61464059a1ab273ab5469e3df93bf4022f42ff1074dec84ed12caeeb26a2adcd8acc9ee5b58e8781c2a4e49af39ab28585f0c50989bd9dfab93b5339e51cbe3da6382b6fb20f6de466e0546ebfb3cfa7a43b9f8ebc3520c6243d1546ef5bbe2058be718222d0c2e1723cf9fa667c6cb0fc8a040afb0b28576e0d97e7b05cdf2843581e2b2be0c241d8920092b46192ba28b96e81e83b87de4ac6720d0c9ee7feac7d40e6cb19901b5c06effb4a674fd22f361955478705e99bcaa92fb44912b3d8172e19bf4d8fd6cc25b406a233d3ec5802d305106bab3fdbe405074f7a96e727e02be9fad254908eb7835dafc72e02b71eb15f9c0683ab20621f9720ddfdda53f2b2fd7481c2c545f8aeb3b4505acf1f1f18ec57da9248e5c572e11d2248f85b17d02f1a463e32ffcf60ceb21a15fce526261cf88c5dad317d6a38bf883cdb0bc5ab6b36b5cf23b8b0eb906d200a97de48c598d170c90a388eb5e495f507441966f3b154110b7dc55b872bdd34a1371f0afb5fcbdbed77b1caf767c90d455adea49a844be8e211aa89b5101c473179c59ec2286773c90b6910d6f85ac3859a77774fd6e712df61adea12e92cb52f140af90f115824a11f673c0c8129cebf2f03c33f132535240ea9227b2843e4da87890a9cc81e0a96206bee59b08465c69f054b58b5869e6df570177643e5b3d5c9f8cff3806f76d3941aa2aab79f1d0c7fdc8b186bbaabebac5e0e16bffec175493a42aea177f9ff6b72b124f2edfbf1a8e2fd21a6135430f43e5bfdf6aabdacc798d497f1f3a3cdb2c0cbe7a442d11afe140553a8337344cbbc8d929180c0f29022b3aaab10cb93aef4dd2d6251570135c2798312def7f4154269d3b3424a3299f908ba13c0ce9791a07821fd80e7120556f4428f5b7806a39db98e30b5e3a85f1e1a954a5c0dc75f2e9f5b732f58145b3183ba839c6effb2907164e1952721df05694a34719865010149ce6c1ff501257a153a7174edd501033ec994c3338cb6110e1ba37ee1260e259512aa324bdbd145e2702dd487cfc97e70d721ac814c282ff247b627f6b0bf8ed4d1d59ac5ef18088904794a6877f41faadf142a006aad47d23b6a93579cf5794b3c217906592f31b8be95dfd2b7c38a7acbf307a79e1460300d9e09976d338cefeda6b1021bf6879bee074ed5eb8970c9f38ec196fc6a86fa4495cb970f03d598b35864c343cf3e0a075bf2452ed4bf8ed32766010c2abfedd66042aa7dfa12a804909de0209e7ed81114066418f7354d2e428e0f277e54b78650831aa427f70ad5b73097095c3c6cb2d595cd6c8e41fc65f00869064a31fb15d7b41bee163121b4832e7d8dc602cb7390f10937eaa49103d22eab65f8bd8b2b6a27d3adf31ec99072cf9593ee8b943cc5969122b8e63c17a1fd9397d957e07da561de3d6ae7de13c054a4c15a238d6e35b2b7f1ed68c1b5796e69fe56ecda92cebfabd8267e7a0eab6d191fb57814f40be39ababd0384dfd9db8aa01f276a18eee8c5a2fe42ee7ccf0164f27eadfdb84d78361349f24a47f0c876298f1a7d49b33a37d17ef61d7af8d774457b4b62200661dd2002b42a7d096b86f069b80d10766328c8a53d254283fad9cdb247c26bb5c55f918c87d8820a7b3353fb1328aae6cbfaa60418d9c3d176a293151d31473981dde16dcfca90eaff35d1ccc3f5f0827e7948160a48d3ed715da4eb42f3bb82fcac8d28fdb8f57d54f7b799a1231fa5318f55b44d33ecf61ff372e5ce758c56d4f1e93dc45cab15e768cd11ef1ced0ffb7787b061b7d4797b9ee91be809be6116323901c88a7fc5fa9bd7a32deb7b580066cf5a3650106dacd400ccf028f5da56343abc7424aee54e20609d06001953a56da8b4be642d42e3fc88c4a708708dc74fcbb18745ce9eb56413bef7b234d5d11b7c72d46795090c9d0d03ebac659e8a4002065a61a8dd1b80a0f9a05da45da351eb42f3047a89afef0622c0010c24d306c8b18c6bdc52793886f1add6603bdc2bd5386bc188338a52ab7e505420e90c4e55d4d1123c8a10611bb50d407c32ecd8567756dc182f141420f5de31a1dc0dcce3da4ec0a277585055339600cf68121fa374242da3611bb50541c0f840c243880f33c9c7187a1ebd4b11c31b10952d28cf229daf70fd839fbc36a92840d8f666ad1a4afd9656a1b1a28281bda8b47b22fba48ef096c308f7273aac645d7bf1ff6731b22f00fabed2cc6ff81fb8004541f52aa714f7b48a225ad4dded6cb0b088637e4dc49c3d7e170af2cee40ddcd16b2380395432c18c053e68e5418167a312bf62c33f63ef9e4f97d13e345a6c532352dec33d7260a5768c12a74d3f65bd51a19e62b8f1baaf592b11ffa2f0c20a4f3c8cdfe48b31ff583b7166c173617d6c73440cb9cd7bf35342985f50303a44b949a5d9c79d5da5a1a4b64fa767610d6bdff0a73d0a1097ea2c1b5a7336004b3bf8bcb47c5a703a1a67b44fdfe5ffd8983ca8021e52b2e1265fdabfdeee1a984edbd4a13eb8fd6bbec003eac7d74c794cb2547f8369786c4bd3913c529ce74cf551d74850ea045b0585655b7f980928d4ad27ed4648ef640ef3633f51fd98ccfba07b03c9681dcd2ad353d672d74d1b074d92231f129e2177f1970eb8460ff6e9fa6d0ef78ae1b72c564f3b551d85ef2bd7b72bef0c54ad49f02646718f84e8404e5be9fad3d8855fca099e08d0007f7bbb26088ec39ecabf14152e6dfaac56f78a20b2d466df91250d5d8f4a18d305c779bf7268dc948c7dfe09f0fce12c609291747e5c32817f9bf6ad7e6016808c4793da489a21e4cb199a1f6ee38cca73530571bdb68ee17d1721dcf9a9eb0e52ceb807bc6bbc2dafab7cd2d192e3588d6974ebde5dad197e1af3a8d944e722509237507dcbf76d01f8284657e9ec0453531b6e29e371c3a71576cf52cd5ad3bf96ed7ea0236a7b9db4e6d36d59f2f5083554fcfe07fa6bc39378590582fb2302aa83d9972fa312bf901f9f7c4314b894c4a2d6cce76267971c376fb0931c32a032dd7e6a5c7336a9832ffcae55c1d03daf39fe125289a096fff0e2209e9dc0d4cd5176dc5e84f9e184b3847c4649d43e6adb3f0ad4bd94b955a268132325760a71398b3fda805dbe4d855531c4b64168b32f6703e4133bc6f563d6df139346ea53390820af2a6ebde939f82b05d3cc662481aecd8aab9130ba046a81acb50f8954d97c2c787f4de31adf73ea9e007ca360d6e7072777e01ebaae9afa91c7c6118ae4f6117ee0b11e78d9ef98740af3767a011fc9886d899d92c155234fc8a1af0a17f8bf5584b66188c79d897e36c842fff2354e7051d83c09a9b8a8a6940e2ced18c941bf2c6a002f22a6b1f19d651f09df47a71ddcf496ab41be18354e1732519360bbc7349da56544f75aadc752a597a5ed249bcc12f4437e8e1baa4a34b37bdb65959f0c5429c8524b3a003d2c5cebafbcb6b44f6d395d5491228001342e6c18e3830028483e50a9ba9df886180d63be91d4875b4d3afa10aa44a5c4385b994810ac671b4391c76048defe5245b09326167301836fbd3cfb74fef9bb281c0d2cbb9f9a25266f6b13a0f2ab31abb34184e8c481f5036f5812b87ab2f9e565cd0acc008e1d9a9f3b767785f01d5cfa2424f9e1ad08e111211a27f99375b3775a3571e518e272b98a95644a943da3fec04e8732a89954346f0b95df2ce71bd60e336ab679c29e627da51f340b7e02847156f5410e98896f0dcfc1334b78947ca56c107200e86dd6bbb05202136eaf8debd1858b88991f298422422453b92fb776a297d080d033f2b89d66e9bbb22b5280ef4ca1962a1185253cd2e9e25f278dcd37d157700ce65ed704e016908727714ac2eab6070c59056c0c75bc50c21cc1e0fd0cedafd79f2d00b0f9858f9332ac5761823ae9466bcddd89df23ff4dab1e22c50f122c3d374bda3f9266d10a1644611229ac13feffb4757a6f6b3f930091baaf2b56d77060170da06bffa2b1dc87fbc60eef1e88980fe219487e2a1482bdb9df383c46705ceafc380388b1cfd548f3fddbad52433ba6907251762c125f6ac8b51e4b374fdf397c258de84d6e636b31efa9a3f55cc5e23116d31a4f3b4f746227d817cb83edcafbea73bcbf21f6faad568c62f8e8415274e427b6e456d8b1eb45dc75a81a07d880523bc7545b461cb8bfc5be0cb694069f163245ecd7d95f057bdb22596cb286e7a3d0162f30fb710def06fd4ca70699149f43b596285062a6fd0a1c10e11219b183dbbe7f40ebd10f44aca97ef3d4c0251a71a55aa898ba8016232ff80de4d943efae13900776374136b73649f91e8fa4c49d8e4f246f95c7221ca0bb8d06222ccf6336447a5e881949522f1c74c0f7bfbbe8f1f3ad03b93a30a8069f963daef33c0e88e5e85375a39655196baec95422721b0b3030c53d511bb68a154143c0b08153f8337605aae73505cef98802c7294b5cc745dfc04496bdb1cae5bf522994ac062ee85176267803c7a6b4f15e677f86dcf43f1d50b83889c4a8485de48949e84e57cbbaffadb6595d8cfb35f693194461bf76d770e2e476f24e723bb8c3788a7ab57a2b7f1f8d001c8b3b0af4421eceacb054ae03064b7c03dd845c3657739492ae63c17e11e202824da81970036261fa3e454c269df8bbd7f039d112d2e551f3592fcd262219a511136f689cf70ba209c1c37fb40c108b80225713dc7b2f802178bb2a9bb4e0b405d70626a48cb6a0aae407abea081da1d15510ee02823306774c21284924a15177ce05e6b7868fa0c5cb2b343862a39f2a7c5c7b8c932856485a3c8f713e634325d13105507ea9462a6d8e64a4ac81da8048fbdff822c97b9f44abb4239eb6962b9fb413133ec3ff94c1fca7c715fe4215b2ca01c5fcffd9a5cbce148fa9a627dc9bc46fc7c624c5c25a5a8ba4b9bc7c894e8fadd3a9b2f14a1f3b96bfbcb1b20f8c0ef2fdf198ebf00647cabbb102af45f216a354a23708c544a1506493a1e5833ce0dee932a6f53e0ad0f4d570e1af75b7cf3255e5023c8723c3e116515d5bffe65192b7ae482a793454276bf074eeb69c42620d2c01f05125367c6a052e7cfc0ed676f3918a4302282957559bb8179b91d71723dd958f38b12fcc2f23f369172bf4b3678af817dcbfad41d3c72f8831a65e6c6c944b477cd8d89ef22f2d607a27ceb361bc2d17002b062b1e07632c2d0aaede4dc4c21ef5bb1a6eb6cfc82b0a197b9afea53b946d011979c0309f54ceb6a3b5c8c3fc06a5c918d532b5f2560b7496c876c460f569c42e5c57e8f53d7a0430972baec5fa528099664744da657726daba45cf8b63c7110494a3e3428a95f1ee6a6b67e47b43103db7c0c2f8ff19a333866eef18b272a471aa771c7aa437e2a681817f7bd11e53fb80f749d955d99268a9b796e9801e429dfa973f9c8de1a31b8f2000fc894355d765fef34e6de64e424235c6432ed4b6c980b881ab8f5f9f00c05c691579505883259b303abd06e1984e82ce917bce2e1557b1b1841cdb6bc88f449be9f5beef1389f43a39ef4202518d6a5b3a68c7e187b954a219766ca572f66d324a6650eefe6cba90b0ca87f4458b112609483a30bbe7b2147ce87f2a270e734bcada32adb9eb63bc2254387695e73d36be153ae67e4161d9ce143cfadef0343515127124a873690f90b5366de794810a3a3e78af2dac98e8b114e3b1de381b953f0200a2b0edeb76c821a9d35ec208b15dbe475bd4ab743fc9fa73449de6d5fdc4a77b95451eee9fd6548750d5e833fbe1a48ad7a9aa4363f2338d65f09b0ce4a9b8981f172cfd6d5213410b9ca34c94d4e7916fa5fd81f73156cfed962aae92b2a89c751b160daa6f13dde8dcf44ac8f5a84077cf0035c263f2d95501943a3f16f4f2fd095c97aa1556778c5b653f3e4ee988901dee100bc7e1a739f63f0714dde36f503213d30fadeb529de36e09f082118553070890377704d9e477dcaf7a30399f6a9d238f86ee9ba065b38a160de095ad185d0f2a2a591b24c1e315c77a075d32f990ba3eb701042b2c7b8f541f7359924318d7a95a79c11b3a0f07d2045dbed9f5714aa6f389c1cc14f92ef93e24f9ad6f6e67f87c101a7ccbf3e5e11a90aed5e5e7496833c9418bf6eaf8646822a43e3a27992a842d034c2de719ef4ad2eda072cc562297e0c6020dbc2cf96ba9888fd48ade16061d883e4130c958fc616f0f83d13cdf99671023df73a21ae97a1b30095d834209410d8eb2e6c0d0ef4d05ab45df18bc513adaa6498f790d705103703c8e4147306bc6a895cc20e4d2ad6e36325d8cc725190f6bcbce29a56ff0b7a987f659359673af4c45a2a83e25eba2f49f8b163012a5325a674f360a3cb14bfb35d8279a5ce6ecd3aad145f18adbf720ee9a1e8b6f98cbd460d34e67589a545232b520ec7349a89d7d400ae11fb6e7192c4bcea22299c24815b0ffca18c5569c7c76fb03907d73a778505442250bfe236c9965d17336cc92418e5f03d51dba2448a052d7d5fc87f11fa2d8ed13b27266b371b4b79b975479083fc1a22009a3e8bf16dc27cca2ba911bcd739a95240d2ef50289cb6cfa140f9b97c3f62fb061e6130f832361b834c4b9aa42fa5f42387fa704062a331927266fa2ff93c686b0a3cfccd3a45ffa1449bccfc30c1bf5cdde1a59298595f38bb501938e0b32c074a738c2ea46df05a583c8e19e1733bb0fbaab57b4eb33f5f79d03d0deb1048d8c23be0885977cc9590d39b3ba32deb7ecc06db8290ccd36d0c9d99b358fae8cf7bfee72d23a4e80867a44dc4614069c33fb3430963a50f53765dadb14bed93c74222496c6626c2f32c3403f17c35eb8a2509dac80015c15dc02236bbf53d03e30509a1a792f8b6f042b628154600ce6cb0ce40fd98af8df2972bf1505199101881e4bbcb615129329958a0f3fa75be8eb93ef5f99ce070cc9e9bff57aad869978528907f65166e4f20745bb28ffcb666bcd41596387d16890389c1aaf59054dc46c9262d48bd3366199c73ed360a999fe98fbf4d393a3242ea69659166e21565cb8a05aa910f3373861612aaab65e31fd6e621cf19e0535b607c2190bcad2dad1cddfea17f230bfa673535f30b38cbcce78f67995758b53d6f0dc61385269dcb0afa33e8a02acb3595b04fc91653e4248842933560b01702741c527dafecd91e7485a83037e409635536e514c8e4ebbaaa184115773dd24c098b4789ea9314a7e49928737cfc6669f8346d917a1906a1168c6993eb3948845192f8f6814034b08d07bd8f110eed02392a45dae11f25e0d2e81c41333be0f3029ce1a75b402b8f2955c30e2873f234a4f33ec74cbbd21bc5e353910b022050bb75d212bc1d9be276f6c3c2f04ad9efcd7d0b40ef13eaf1cd63df92c91de8a22b449af77ac6585474aabdc272e7d2910de20f8922efd058070b9abb939ab9a3ccdda53f23b863a72b95070c93a1d59d33eec220c2fd8cbfb5e6a06b27be1867ebe7109c42b1ce843e43a606a3b479f61d2552773c441e42043ead6bc9b459a34f9d9e85b1be7bbc5461feaae043db3f0a394d633aed9b2cd4b2b2754ec25f7d4f132c350c4c93549e5832e4852f5a95c3ae8d23b699c5370121f523c6d057c861b87044a6c058de64c41a7412640a79a2741372ef7ea10f2889fc32e0280058994cd26805f355924042f4f1086ee782816f9a50d8e0a6806ea2f8e1563e1700ed03fe920586e71f5cd0683527cea36aa31ba7ab15b5cd86f83c0506922453dbe08758683bbfc2fb7be05137a0995242720f91948507ae2202525fc90f836cd6fd2a52449a217e4d6383fac682d64053a673a7ad8475eb03675de6309931bc0cdf88483bc4a97a86adf667948260d79eee4fc88eea9f00ae05bf759f8e4b36f67c3e5134c3dc6ca4338ebe5e309ab7d9a08d51f1f98ccc6d63905e10c2c1aa4948c07738b6162e9190619a62250ff1f6f2a02ec2ab0922de8678450c985f67563eefef32f26e4830ec9651696b1c7616b4d64ac8085233c2aec218bb16ecd0e248a8083066a59da6f47c8c51a27df4e47b3b62c724c1d044762107cff06dfd9516a5ac84411c11a7b2075ac4a4862c1d667cb23832fa604df5040c11a651e4fc923dfa40d9da934f0d5b6a9841d42ea28100abf83421055e4a9b5301574d7ee112291d975ce81cdd8b391b7e120ffc93ce3ee027d25e6ce4b54fac5abcbcc69c1062dd02a603c773295130b1e2028d9c6aae9282ac2809d977b6d1c1271c59a8df34de21f1f80392fd7978dacdefc5e7e4e671030f844844905fe520675add536a08b7fc1c7a9d67dc3767fadf33205deb26e7207e7f89a660161cb05ba172dc012f72c053a27873c28308da540cadcbae78302e34b4e3401135f6e3a3c6a42a3c8a5ada00266c00649b802fd36eeb7a176938c310a3ba0e2f64b59e271cf8a2e7c3f6056bddb01dde55728412353ac6a840986ad8509947d8fd93af771a0f07d11fc60bc6db24dd2940f225eb4812defe66018a4732b17b15f252997314198dac1fb146b3cc516dee99fb3083b1f31505b7fd0537778bd559aa8662a92e4556087355db71598b82645034c62d58885ee844ae0a4715fabc6341a0ad893306a1f25f6429f224ae3a6b3cb553551cf8d7e802051d2d0b7f5da8cb63b6961894eea295425fd55792e3cfe5dd5b23876257ba655737a8d8bba0521ddac677c10c41c52f5e0b607a9e1443f8e7d104c707ac4bfb6ecc2c5c72b2b545965a3c28c13eaa44341d0fc0891032e46ecf723b839d92a6241673e2b390e507d1dee5f419e638dc5f32d0b4721275dd8ba01d5bd36ce448724dd00d209d223c619bfc79c1a89217f267e249d05242adc6c170aa355a1b6a0da50b368adbd69d4c7ece00e960c86fe1bbc0e16dc6ce1bf1359c59f0cd094f62777203308eb405aa5e50ea6fcc0a6c8515645a608b099e0efbb7d18e0d59ac8d4ad3a32f6296dd0fcc292a6f045b27163b6d33f5d8d2d8c0f2c070236c7ea8e815d02082700d7873aec6b9d0823d18203969a52794c81100b0573606213e5d4e81a34cff0123ef5062773e754e506e56fb1fff89bbe5e332873f44249323e35d51e5d273222492044442dc085ff344c4c2b1f7da55c6fea4272b1b733eca771ce22f68f61b4c297f467c8cefe7695fda4c60b88d337d8bf94546c614dee59264cff925521476be98b912e96210594ee15105de59906753a9bc1da767f490caf3040ff7953589838afc2b3249df946030be725565fdda69366d71f581bea118f6d583458dbcd0d9d45dd61e0a2566856df4bbad1f87b1cf44a55635d602a3a01ffa578cc49ed327b43159ec82e8ceb935adcfa2f8c0ef0a7c443942840e54e6d57d950d642f784cabf8f7e2a5372037f0ae0d6920404db9280cfc9d1b66422a196d85e369c7c2c1296e2613a329d1be0a63a9e4d2940d38a495ec8b83c3cc81876f3cd1c9fb506afb3104847bf34d098844913fcadba20589abea5f2017dd764f4666ef6d0fd0c7ed82ba29d27bb1d2adfa942000d9a4fcf75dda21571468320f9e5dc1b2a69445f66385027cd7a8678db096a23f6b0ffbf72674fc8565e2516ae68c025aa597f3c2405cc7bb06c64caa06b8f564d27d57dd863c3889afd8dde93e34612b240fe33f9085f6ce05ba2131a054fe8791dc7ccf96a80c8ddcd6461975bff820788664eb7b2ef5ca093a8951eb753d18ca78c38594be65a7ce8a56baf69ca035d133e952829329c6d05470a9aebe9e95b23826accfd580abd871e7741b066c3d8545c035010a5107bfad71f27d9da2c0ec236c030f6a523e510e0633a8b3199ad3ab0dd27e236e94061ce835aed3e9a81568bc7518420974074b930ea5e15928801b28258febb6c29e7c1fc59619422637122a171f2018b0bfd43a2a70d29e3a89c18817a03fff2cbcfa71a6ad64697d28a9a5986e00cb9036de7822ccaa9d5b5f36a1cb970ab9dde6c870344ccd835ea7c866777027e8ba3f91f0e4d8a1c09b0561638937c7c73445bf760b6a6d63897c739317bd07ba32e6ad3adff5ba8e7bad5ba72d384bb9c40ec6cbfa064a33ac588e6804c4cd7a0b6c3b201b471e02da8feebe1cbab682fab47237652d71781391bd9a4aa9547a70aa5f6165a9e1cc2a6f985b195e0d2f2be53d514f6636c85e2f2964777bf2e828b36d8e6d94eb9de84d4f61f1c6047d282c054d99ec46de15bdc59ca4366486b3125445b19aca4807fa9322cfe4d7c5672d0bd773e9470634a43c28aeeff64c4075de3a269daa8796e25c8ae08c87f65620377f415012c30c33f41dc06c919862bec92b387329532b25e44e3a1a04ab2fede9d46f28108aae9f6e0e38776244a9a65be167501bcf5fa6acc76436a22de6d2c6cfad10d14fdd9c0d364d666c008b0cdc580eb69586a282519179ce70fcbb4af8db6755cf017374ab66790a274631c67fd3672569256aabaf94fefcb596f1edf0604abb8640d3c4a5d869c38954e59a5875151621640cb7d4e96af96b282247dcd8c4f01a0b0d51c4775a9566bd993a3895e87053784c8fd7705579dd4760ba2b67734b8f897aeaa1a9d55fb35f38c0586f77d539775810e4e2cbc21c19f82201f4f7a07c9a310b7cc9f540269ce986cc8ea40f4ca0ea57eea8380a791857cce80a5ffc656c172399d272f966d01716f591dfa5a0839d4d8074fba42c40e3715f78a74e126a0e829376f5de0ad4889d0a6a2285e8f0aaca814a93fd75d72d65757dee88ca44f0b2314d7e8e7e8117d4ade6cfa1007625122c1bebc518c704763e2dfb9a3480d0160f24ee44e66ab22f6477556a36453cf952e1b577f594c723c67b67ae8e5c79f556198e329409dc92ecbc237cf0550afcfeaf212ee1a7a05313a2586e17086421353468b8bbc81eb3b3e685e3e1ff3ffc4e33f2c6fa6c7ac4a31fcefc048fa7bcd6c890adba4f2723fed41146e676c0cc71e1a43bfaeb8cd2fedb836335579aa61503c873701d47b825f3111212cfac127ddcc4b14605801f3ba7d572a1a864ac107714841f50fb48eaaf8f241f03d27bb0c521d82c25d9bfab385b44d54b632a63d3635064c82d8989437bb25518bd1ed3d33b4844becc7ed5fb552e2a32a80c33af5df55961512a3302e6382929e47e5d172794d39dca02982bff13ca65a1acda3c2ec7ee561787c5b67e36b796c41a4f2270be6b9e64a2b689acf5ca36f841dd6e273c16bf97fa203462f34b8ce7a0fa72ef383858015b0ce00db98b5998ec85550e4f3dca67320a99b6df650bf88d46232badd283a4cdf729ea91eb305a97fedd61eea2381e9f8332aed5aa9bc63c49cc1f4ef1590729b62598a6c60f9099980162e81389a022275e8fe49db8156e7782b1989457edd642dbf6bbec0270a9cf881b8b4aa8c2af906494e614a1b10eb9f38fa4bb2cd394576b4f23a8c555a3a23f6d1449fa6f9efed0dd9992cdfeed24efea5e9d9c843c44a9e709779bc026260f9190f75acfdf043eb08a82129e5693cc5ad3e6f075b87b863c873499290c9c5681d817412213ffcf4968c244d963c1494341a03104529ec2b7aff9911d0c50be24eec77165e76a35cc92f390eefbf130ad1c50e22cb9a284f0cf1fc07fb2fd4242221807b337f6f3f0101e6b4030677d88da85f9dfc5487f9680d49dd717b387ab2220be90219b2e24a9be177862d125d9ef773069c0309878cb36fa5f0764fde4c975f4be6f6ecb2c9eeba3acf5b64f95adefc8a08674e7038eea82f50bcadefdef96e407fd73e9bb84686c4e9bcdfb5f371d6e89feaadff98acd5777574d5b52f2654fc33810a7368bb9a749b1828b6fca56e16357dc974300b0086106fa0ead73884d7a8a0b136afbad064fc9e94000593c7f8d7064deb968e6417bab0514642b406af44bd07a18b67642d8fa62642e39b8777aeb62109218e8612d70bb00d010a71865db660ea98c2894dde5dd86c970b1e39b7a8ac29737ffed0e42a0c906e1736a1aa5a51d429b3b23421c97f52b56014dfd85cf1636bd5e4f57d1fd1983c9bc5c0aa55eb0d421e59f0af800c5cea5041d6724bfe908450c6451c2afbfa2ee3897df5666644ea2ef9e65ee859a23fb342e9f9306b91616cb24a0a578655e07cd9f998681c56c0364a464828c67726e1a7ea440c77bdaa4295fab549331d5a00c820c05181ee50efdedb7fc7e031e360fbc7c3634e67cbbdb4dbf13bcfbd050c977f23e59fddf9929b0542ac02f7d38d263911cbe8b5b8af83e40b93124e6d64a996bd2035d2822314a1db717f7cb647518ff36f949dc943ba7c61f18dabee1d40d8f8845e0f23cba0f75d1bb7054a84382ae5306f98b42a480b8cb45cbc9c17c6d7e30802788d53cb79ff3a7ac4900464014af79b1e738dc0a795187cbf2a1ff75dd39888e57a4d13293d5540ec165a71dae4f6bfba550dd42bd4ddcf8edd35116b66cfd6d3d9db7d014be46773a28fc10d5fd52f73ddcecfb8681017004d38fdfc384dddedf99338ea464d5fb817945766f6256278392ed5bb8c98c2209f78d7c2a22cce0c5754612b8fd1f46de0a8c12122e524e78005c4f174095efb8404938cde3339310db56d66639e663077b53e95f0eb650250bc69adf37b78496363b71a62d23457c97a7fac46202a2e02cf1fca3024ff1b6e81ff9b6800febc1101fdec3a8601935a4a665d19ef8f443fc2fc44efc4b087d918ebacf4bde07a77943e5322ff0650587f0843023401187a07d9a014ee01172c221b456171722c621e445d2facd56a2b4088de7aa86fd33262c41c751c6661e789a72f6f4456480d7206d9cc53a63689abee3c0c15c003953ef76fdc6502fe02513a36ce6c4ff9973066d387a10ab861ca3171e5b6125a64bc3b24c99358d3cf4acfbe9e8d05c83464ab87a774b20c97e4b1f34ff2c88f37e2dad7bccad787c7167d2ebc6187b6c38f2d929c8934c51996aaa29ddada4b1926fb9f72cf07f0878d7a0c2eeef10376607d4ba756e9b055c8ba31ff4ebaf397234bf15e3037b83f466645d0626effe0d5b7a8e941b6dc1b50b652a59015f990a42aee4ffc06a74a5fe749c08e1af18ceea7c80f1900c36c55d5ebd6269d03be1c8207df08794b0e324dbbaa4ca53c1dc57283619619903452fbdbbab5a4f00dc35f5ad0a4fbec0613199918b02969a37b132c875a22ca5b764c42d037acec02b27c607bacf570b3465a2978ce4eba74f84c82ad5774a7ad1b94c3dc9be29a9139e1bec01d2b0399808bff268482a179342538861bc653fa9e7f1b5a98c05bea010cf15d9a2b9bd4ee2783b7a8836b890514e12c74a28882489b3748d683709a9a5a33a4371161110a348eef83729a6acba051fe7634d7a166a370e214910995e4b0fdee2130e08fdf657571724b92683557a80c3263e2136304b1db2c35c5bc820d91da09dd1390e6b14305d5035278ad83ca664599c245f0f8dbf58c39278c229ba4d51c16c38ff1178d03ccbfe78afc03c3c61df8525a4fc5e35e1a0987bac59fc217aba9a53321ecd2d3f01c38e57ca9e72c9c1d180f0325b903a11fc53fdfec42f24faaac1d0145ff911659aa3b456a4d5bda53efb844d765d2b24d4f175395b3cc3561a4aaba3173da18c957bbcfa2165edd6b9fe2bb4392d656336d2c4beaa05da7575e19349350807078863795732536ccf30b386599d23a8944618aa03d5d9c15c1b36e2661602520d38552e1c9a49557e92a57ce83492b72ad293bea285eb2babead7571a82f8a53bd7df9796b7249a8a8f4e27e462a32f1bf49f0541fc5e1c5dbaed3c9a8c53017a04ec44ac00431c40972b19cfe09038cdd19150cc3de899b4353d30eda84f5ec207d3d46531e908ff0096cdb2695726cccdb4a11bef07f02e5fa3718e1ff33658b9ac00c641e8a998b15eebe9b47dc3310500139d9680a5958f45a71d1b55bc83fc8874d970dce16a0ab3dcef6634fe3ad8fa7715eacd019e53317dcad3449ddc612779232e4b3f489f3ff7ae9f022e8a142c37d01a170075887ace449a3a61f629b48f03ebd98d62a6b844e08cac982c1be4eef1c20f16c75af9f2281fd1ab6a49aa495a0ceb107dac65443d0de20c47d8a4681a5e1e4b8a415870be6190b5f0461d4a23aaa1ef83f0263ba199aa00081ca5cf4393f3195a9d9374de64ae04730c5663d214e25f4c8c84c30414b023c0f2f74111b06ecbc54deee22b6260c4f796fcb0af74acf3fe826320b7c6d2e3e1f261f530284fee1165732afead233982d1b6b229f67f8764a84ade69e3bceecc0890b8b35469908cbe0cf57b4c26e3fb7e7c6079229be07b6659e6cac84851b90a5fac1ef828801ecf38fd1a97c1b213ed85ce54b08d23a2d637da1234ebf2dd0823c329a190c1996a4cb6fd95b91055b7659ca2a24aec127d685761b3192041704850d42d8a55a9e2916be47f0fc2561869ef44ee844ea8efcd399c7d26824f46f1424cfd8b22bfeed28be06eb5030463387fb189ef8d8086f4a7e356edeff31184b89d332bb9933d2538e0aa3ee0ee7823b7eba0a07b58f3c9963ee6af000231e02656132c5ef579f47a17684baf582c631799b75ac2632ead13caa6f80e2f61eb732740e451342e189004e02d42710e748820952babec39b85676d3aa22d75006aaf7e7e75bd4ce2152fb37325785221e65e9c10a16e77350a16170e162f861d75813024475ecc52064f0bfd696030891f26ae959dc21ca69c6b5093e75fbc1c127aae26924d1921a1cd10eec99f2aeb6913fcadeb1a7ad83e277c504026e1a0c2212d5385b584b2a44059f4e7b665bf42584df826119130d0445523e0374e48138885c387f1113847fc91cba3182aacc7fbafdb031c2cb09ab16a27d64a5588e8b9ed2a5cbd2bf710fb98e42cb66c87c3c766b93eef12d4cf99a1cf6763f5cc5e74dcf6d83f84803300b3c7f85f8491d7701d8d48bdb283a59fe47b35e58f7583665355f224983fa42e705c4168c9b92f3d095c907e19887246cdf702451a74fbf0b497255145bc20b40adf157b2b07285ccae98666e3cdf7c823e9a11ab9b23bb92f7ec6f5e8618fff3a406d8aac872417e02b0c4fc8298df4bd18b9fa58396bda8de35eed237f07eedf13f6808d725afe6a31b2d99e9a90fe3f8c557e9ef9a947236c79100f5913d08200dde6aa8161900ea0c45ef754ea131c16edfba447b2a0731de4e1db635896bd5a3dc1efcc8b5c169ee47baa53248ef99088630ae0c5ac6b5acaf54d7894904fabbbbce5ee9eddc723f4c7172b7c4fdb5a9068fd34f72b1a3b41bfff8c12608531571d77299ad90a4410b11611e2132aad50b58d31307e2f5854922b8c9df03ead411bcfd8562e528786a0339500be550228c49fb9533de76481f48a8df9897c24147d2f21aebf8696327a3e842ddd4bc4e772226e4d62e28ec5b2a826a67468fd8f1481a919ddeee4d6909226e003f04c341f13cdea83556a60a4d652e16bf93d82f95e3b79af44c3af1e7ca5f35fcec570071b7f98e9c92bedf80d1a0efb56ba8279febc7185cf3bc745a5fc132090a76010b17a6846ce39771a7d58e2c8676aaecbdc0091de372c8be2c78fa1cd282975e3264ad51b6b13f098b3fc9af9524d85c3ec08a0d08137978a24ec5024b6147a6744cc372fe45678945c04ede3092469d904e031213241f532d6f6b23b983a12fb84f5b18819ba2272620b7a18fa3f1d4b9e69b869c409be98593e3f46f9f8c0dfc686275dab2026f23f47bb2e031cd49c0e463bf33d158bdcc8bc609cdacebeb03f4a281d863596cc56b125fac6c5dce6d2c7831a45917593a79e83cd5ddad5a5b93312c205959238e405ed8bb151ef00fc12e430518860e879c76001cbd738d2ca93415f7bca4b7ac0e5bf5829b78a98bf37585e266f9a3563ef983e7f3e3e164703713838c1ce1010934c986c2e1dbf396875c00beb673672f5b876c00e62e754a46c5ac71eefeb42fd12ca9ffdaa9af5d13b445f9904eb3a0ba55cf195bf7b59d8921358621536c2d9e1b467a510d13382273ba225426561aae39575b31d964ca375a404c6dab27d094c25bfad8091ffbc1d2d256a79b85ca284fe0c378f4c04ef7231fe4cd4c499481ad3c7d052b4edb88d359fae1dac67865a6774b11580ea16551e006d2b93b34f59cd1d89c823c7c12110ae2fa70c8999f848f9f74e0d0635c6098192ee132af62fee812ab245e38943b9d7b6489668df277e6903db82e6f08d162256b71a16866850ebe3aa25491b1b4c34f96dbca738ebe543e6f21855ab637b2e15fcf055bc784729a6220e280c8f3617203e04ab3eed67710683b693c2da9bcfb99ff82dfb2364e77d92895cd4c22459473dee00ddfcdc5b7ffb2df8539160975f1ccf3f05474dc3f101585b8053e80ad3ba6d333fd61bc9e08d8480f0269a1259dfefa748faa01450cbba76e7b9e9a7b87fa36662688af4fe887ae08452f696e54295c05dbadb560b697b5f255345b877c23466394f777a1084bf7c1def8fe7d7cbbeaa66f67a539284d3cb3d4fefa628e258b74d9541438aac737cb4f9700631ef35c8e6db4498c543d1203630622dc193b94d9c285b5ae49c81d2f2d100b472b5069ae03d7d04076eb40cd2057bba47bd44dcedcbc8250bd60d52e80a2e8332e95e911e7cb2e18375dd2ba600a6ff82f9a14f61f6109afa2df0050557893aa111b4acf84ca3d4bd9d0d278abdc4cdbc5125f2468166ce22c7217f7ea025f7fd70fbf9de22e4dde6e5c06fd32953d04864bd93cc8c7dc57e6ef8e9c360780a54bd8e727e2e1f2ba24f9da580961984a71f48572c214eba6fce403a8cf702522b084ea14e4342a507bfce9ec3e759a0e8c50a50f25b58a47fd7f90d602b4eb6c4db223ed23254b329d1461896cc8d3ee9d2c130ca7921a4bd596af4f54539432dbc9e8d21b6d0133a3c11f76a8ca53cb66321d2d3fe2373b1bf7af29c4d283c8a0c941e699e631a3015f6e92e46c97bfa08094ae844973abde405657cd1643617ff5ff7f472a38f5b550ad69926227d3bc566a3f144b4c20bc38de4cee63d8fa45c08be009305a98ad0ba958173d7bd0be33f41f10b15a6c0ddf3f03de7686ba4761f963b783c2da2d756dbb16d08c0cccc3393e798f0fb1b21c6deb42c40750940978e06aa7724eb9936ca078ea8ed775aa0eabf60ff3b358a319db1d4f81dd576c099ccafbd54b91c6e0a3a415ba9eeb9d359432bdacb2569b7a1e968d057d22cb75e420b85ee1ed99bb18b0478a4e4548e23127b663d66ba71a2328817c5485196d1393751a98995d2b8077ba727a05b2cc891","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
