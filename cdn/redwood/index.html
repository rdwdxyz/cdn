<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"db11f3ac7ce2f9f6cd5d0792a41234f02bfc3b2da5c0be9e4dfd89ba7e16074101b543de7fabd37874e168884c0b9f4a23214245a30f9fb4adc8185890e729c22e538e1fcfca6e3323aa3cae1165f7e2a7ea7c91e9e3492abeef40a0d7e0a7dc0f2bc3f0cbc20b8009899a57dd92d16a4e61bd043ad9e9d060a1071701969b63ecd19c51b7d9e76a0d641d85056a6fcebb31717837a1f7fdf241e2c3c58b296a1597e46bc45769377d0467404ea151cb979405ae54cf989b97bd0765d6da05863a1dd6309ec53b2f41cdb3e7acd2c4e28e4413e3227e2e1e44dc1b891709c77df512d12ae28dd8b115a333139b0a57eed3f801d4d33ab4459d9789fa7e46dc0ea9d98135b7d78575b3a7460e424e73a8e8341d322119c8266a5451a40f1d2f74fd6e6549b02711d5eeda57e06cb7b7ba4f10e7f2e82df88006df57411ab7a04c2c33f7c898758b8cfaca21293c501751a4e3374cb6d655d4df00bd106c4351f31f9ea30c6c45a2a1378e28bcda070a405ee4431a84b51d1d147db7ee418c57b0bd900920dceaae4980af98e069f4be3ec3b3ee05e606ca313ae22d9ebbfb35c01010c4e6eef28bb3713b566748faa79ea03b076bdbf7389823a22b25110fd139bc914e798de1eadeb3ee9b6f844c0791f02e200f6b850e8d5594e67898cf115e308a71238e3e31b2267d3f22780e84083cbcc8bb779fbb792de662445c47c392ddbc9782a8b6b04c65b3436bc55bedf9914b63c1b65a6f997b5b172590aa7dbec4794407c8954e452b33caca3e53dda1ecaf7fe4d6f01875ae9a02ac02424e7f4702f9bdf756d71963cc04251af0359bd53d8cd169bdc75c2c2d41f15ad767bdfb6e04f52979fd11a281fd3ce9a0f488c99fd261fac16db90d30030f4177a3ba32197e8b35993c16b3d659660548cbbb242af840bfd60401015bc71b7f204dbdddbc576a1856ed15989bde2a19d9d8a539f50a0a647a12a2b2a19869ff32ccefdaae24fc963ac6a23cd2ace85f0db6068fcabe3e40dfa804836e6a2e17151d6f04e17f2ad168e97de389b0d006a4b0e2a78c3c2d028ca6784e888937899e9a7a91976a8fd8d4927f4dc95a1e2ea1aae2e526da700fa0e0dbf558b3ac3cdd3f68c560c06eaeb2bcf09b40121de92a7a257e89a17b38bff698db3de6649664b983dfa50c870bf5455a9cd44f374a07942af6e8a52cc2e1d385bf8fb6f120562563754ca3f8ac6c298cd490c19e7a16230dfe5524ca07006e96f9c38d345a2b635c6d096e5af207369ac67a27e64a441436e7bb61d4d885324d972fa1cefd8edc1f0ba729324d96ba8839af085c68535769963c3b637c1ff3f243172974cd37afe7b53f5fa8155cd24b426826bee7752dd5ee9f7b3bab17e08fa4bd4fdd618d6f51c23d0f0028e7cdb62a6068e039c824644d088a1e7c8c2a57acba58e6f8da33b5e9e069d95bc3f12911d427b79867ed49ec6fb78aaf1c1b0578d169d54a0c83d808bda8445bdc314cc8d053f4297007dc217ec8e86fbf2a195a20f458d1834b0d3753aa766d6f49f3003d2887985720c9cd223f6c34945fcdbbb1fd2a8d50eafd00822fa82151fc8b66aa63e2ce7f31ff6c72817a1d6da12de526ebfd2e2c3ff43ddd7e849813226316b7d114f6b989b51cb49ccf5e57c6e576790a9ea90295835c429a94ccac36b283c3f9848c7d13ab6e5619f01b5422a66994618dbf680068e56b32c9ad11ab1c897acfe732f13510928922029646b386e796ba31b24d6f64103bc2537ecf2899ad1d59059962dd862edd48642dabfb99e3c7e27b42e31e68a1cf2f3f1d0833088e7c497622c43204a98074fa858f12f206f7820ca16d4189e660f25160c2aad7cbcb67efcb353fe536731895608583b425b541dbe32bafab7e67b304f33b4640114971ca77b7de2033b0781e9ae2438676902925506c8e7a343af9ed0523819a04f8803436b755125ace2e98fc72816d6220d20ad8375b37ee3da7caf58d5822fb6755ce753fa453ec15a98cbd97ee6c40fd966d506155fc730a0071ff6afb8fa3f2071568ea83fcb9d795ae31929b58fa20f5cd98f4b94b8bc6161ccc81b1e7f3bfbecff3b19520f2f0a9ef7af126c0634d49689f085daa89ca5fde054cae75ea6d9dfae1db88acae3bc52ef47b6726c9e03019e3b8c61eb566da545951828ce09d380ba289b914a6c043ee1f97019e5ecbc1ebec631ef40ddda49face3580f874415b3fb16a020dcb5feef83dacb45254dc84b951f8d9601b98d1ec91dce7477e55b389bcf494eff72ad6741c705e5bb379a5a899debbe02d4a79c4e9f9418c1aa0d3b43bae8fb197679e5f6fcdfd4a740c18d5aad526ccb1637af31a266f833f544f4e5bb6fbac54fd4650afe83396bdee6e2375cd5106687f152bcf8ad9d087bf2d2892e5e183b80fb55825c35cdfa1868792d38a22141b326681dedba3eb8ab0c42e410fc69f58b4bdc67340d28634d829380311cdcd714bbf8b23fd59ec436cbcc45e23f26ba764ab6716dab7e394a28c54696fe411f7459f7dc1752f67d0074b866120753838a0db35a8dd3d46a0fa5bcb2e196fc7ff96602aec1ec3ccefc35b4c7297c4597f2b9d0b77e7ae4583f35dfbfde2572a802e96653ef43837a0367c860f48926daae74042d131753551872941e9add05dce93db3e66bca13edba16f232e7af2500df8839a903c31c52a36f498be2b17f3c7f6aca9fda3c4c7dd24977855fb4f242d352ad131622edb66dc84be0d97bcf2a7eb877e1e236b983662876e454080bb05fcd0fc474f01f827eec837e236d264d671674676084118d9721ad990db7ec20935c0073db0fbcb6dd692f28e9872e47c39062d3e20fc89ae0c3ea9adf354c0b8e575fd36dac561cacbe514091e2c58db4eb45eed58bd0688bb9c0c40a4d960a0d61f8f7dac8da981422eb3c3ef74fae693a34bbf2385a8e56c4755b4b85edfe2f76e2935df933dbb8bf33f938c03ff44e884dbcdd6693b93bd11fccfdf47320de3011754bde1137c47044e14ff9ab9d8302bd78e7fee366c8877e3c4e6b75e55a5be9cdad841591927945c6f64fadeddb5fa577cab2f5e977b11097700e1b686745ef01454d74e06a1ed5e3e39a3df10c6b55f629740290f5fa1be15242b32f7d04a0a2ef327ae18ecbfc4969576f1f9c12037ba4cbc0f21bfd0a10f3d9125bb7639eead2384d2b08f87f021680502a2addb6bfa4ebf5d32a5e014fd20129fa58ed3469a7ed2b9ac15b75e11f8fff1142669512e9d25344099a5d6ecc79144a0aca822ebfa4b636a12480843135990cfe5c995cb9fe112cda80d60482fd88ccd4a99a3bb9e5727cf23e716b011a53c426bb9b0b2612a5a95f4e8cebb181e5353917eda8f595bf5840b048a3152a688baba301353b647aa41bb1c39d4e693d3481540c16ebdac30006f9ea28ee0ad4f898904a166116e66860c1944f0381c3962822474f65a78062e4d29e2ae95fce41e54aaaf08a8ff1339ce80c6c53ab5566995bfca5c6c9d332e1c14bfa7b44dc69b635836c0120d53eae82f279a8f6aff4acc5513b869bd3959a58173f5fbd657e75c3d9972e634582358ff159f8f64ef054a514c40c84b4bd0c2cd6ccdf016c67c4e44e1c44f0b6942f3e1e7e13a7313fb6f4826f2763f50735dc7690f795ec00f20983440b0a55272f2a06a2fd8dfd56277d732b726c4c0268ab46b671909eae6dd2b4c7d0491c0fd9cb34f9547a74a7563b3248d773df53c900499f86df0094c495cd9dd22fc69ba6ab7483d00fe561851b445c169fe17b6e9c7f90abdd21ba4ee7d76befe4fa10236724cfdf4bfd2450d046bfc621ad58918c3c4314ebd6574c069788b5e3eeb2cd55de7d44b77524efd1dd3ca6e0123eceb74f9acff95d995628cf719428b45a3571e761051524367cc01095df87421d1dce55f77234651e473c823e107148269ae34f69f33d694c0b9866699a4b027d97df83cc093efba59c8f4e3906d8045d95c3790708433d3839fb435bc647be8b2a7350cccab195c1f442000dba4add125f729782c1f7d6f72efbdbb802f81a12d1915c83747054073b72107397e34497edc1956f591b69eccecc3af3dd4a0a523a0af0a3e28aee87b5e5901a28c8822455ffa9043f888f9bb02985ea42b796636e2a3d04b0d1082f38e5fa17bee836384dc5819b476845c59e624a5460651af4931c5289b17b6ca932dff5926449c6a758d4006f71416a8475dd56b1959d4cfd4f665bcb07f4eb23e2de577f0cdad033686e50315a0ffcd117f152e429c0715fc99db9d711c3291d5ca54f25806bbb8f2f58482e8ff2444ed4eee5aa75bad3c93b0a0f917284eff1539d527e302358dc3118303f13875650981b2862f0ca2263bd71f30cf4bca0b449f3975f2b7481f40f4a3e3f737738cdd2166ed46d786580b00958741ea0cce6736f2273b7fc33866a1b0af77bf1689573032c78d6b1c708e0b878a738ce6cd41aa95f03ffc2522cdab3bc3c8faabc10f4cadb7e54f245cce2a0fb726d958ab70db090e3dbed681160b6c415f62855d316c4320ffb6fcb1c9531816d62a93f4b50a151ba4f800c037037ac710f3c3580ec2544ade1692fd5ac8cd3fd7eeee0771e67f11224385391695108737488a59db9fe899b4d72db1775c635df4f741fa2a320b807f1aed0ee2966dd6d131394359acf22c5112ea52f37d5c52c060128ac7a47efbf7b2ec9937cf2b3afec37d3fb13288007ce4f0d16136edd22cd41f21df8c41b46192198bb6db07a2b23e7f5e548c6f38f5bf426fff827bfb16dcc925432512d56ad6c949c0f9ae9b8dc4b4fd798fbb04eb40b6735ce57fc008cd5ce3a602579cac62d73fc142ea9d6dfe712c4ad82f5d3b1f0c0e71679a7b882d501c5ec1c4e7ac9c8fd2fb5bc57b2be206294c5df13e18ba44f17c422b9aad2812c6bfb4d51c1c7c3633b60bc139d2f9088f6774b86b68c03e2ea85b303fb67e51b015dca710816936305d8161aea1c78293e01a7a66e1c87cb1dcbcd9dd28227eb52678c29fd0b030c82f47ed7c87c07986f47494e019b6db8050ffd38faa4047741807bbef5d40734745244351361f9b9d1801f96106167f60e462e87499e468b713e6d3d34f7412ccff86a764943317cdabaed4667f83c7c960f29e05ccb48fef09425263ef42f515ae679012a400ac42378f174aff54d148e00eb85bdb383f4350eea94937d350d2ef5feb89abb6ba977917176f844df5b6578364f30b82cc6fbdb4405b827cf2462b3929d1418fa97cb97fcca5d0717edf6a7594e418e89fde2648f24498584662531ac38532ce39f6fb8c832efb75e67db8b4a1913bb149fa6d58582c10ee023c5e67ab2a4f2d383ca55c111b51489b74f7c465c0084701ba6fb0a2d6b78beea69a4a09858715381dd577b60201a5e8f4bba5ea3be84d7745565869be887e7d7ce8be9f7862c857c1e6e5ba1aa17927853c7a41f7393559720d345b2383ed68d0b43fabd96034d2904c9ec6a6d004b43e8795dd034ae86f5fd0d3f1e4108def9dab70b3f95d5665a5668791c108d2eb58c1f739413319d386ffbb8c7b7ec2db663257acbcb2a92e17f24b728927f13ba09e0959a56d528edac6b42574b06c6fa1ff6d3ebf8fbfee60643aaa76cbadb12e69fa35a7ef1f5b4caa4b0b52691b309fb579eb7122bd11338d3d256aeae2db095b77acd8316fb821bacf6e8f3997a4f30549c0019fe11e2f0f3c3e1a88091557186bc5f67346d4a7ed3ed1e3da9fe9a1ce2c82a3f0f687ce3910b5d4fbcb29d68ca2e9443455e483e8ee76776797fd25fd6ff4afc70410d9c66872c7b5b15accba9504ef903cba447377838f06835c1a1d6d3dd9def7ce161e2d00455da922af3f7e0744e49a4546d46b091b3e92d61e722be314509bd38db056cf234221c156adfbcd24706d389afe0732757dfea6802b287d6ca27ff466edab18eaaf3fe31dc24869465004d2938c37d8a26d9f1533388b47ff3da2c3793c4e3bf4eaf5c3178658b3c5fd2c1e0113bda1492d7b78db5986b9051fa292eb1b0a110c1078053b362e35082bfd2cdc83bb5518638baab0501c3697b29f0637adf3e9bbc837026fb74c2c13e911b8cbd9082508706c2abeee802d59534918f9bd318b3f51f6444d4d5effdc817726b80ba2ecd8430f106d8dba2aa34b6dfa1ea8098557459b19431a42ce11dbdc911aa9171e2e6cc049616a0fef702f311cbdfc09e361c73ddd18535f2b73ed8946b202100342e0be5e05b779db57b73401e7e6ae7cb350367e4ba6970eda3f2fc67fba62f424fde1869feb6987962892a7e0ec1bd4c835cc511dce38f6f75cc23d4a103f3f6bb468431eda1662ccf2c9e965e9d79ced259e256a8c91b108c437378c51648cdc2c635227c02b88a48ef893dd32dd5b84cd4bc8d5bbdecec1f0192939f85c3e9848db376e3b42996bc70b966f0b002dfe5bf57d7eee651336ed14ef5742d394fbb454f65075f4b4f117651b9d21861e6dacdac6d1cfbeea8c1e49f6bf9d25bb35dd31770152d183da5ca54f5a2840bb599b7ff38e719f90d318f30243f24c15cbc8c73dd037650e8aef91b0fece2be36d00c93a4da3cdc7b6e5f9a1c93cf35f64951eb12da66c407ccbff805c168331103673ead5383e70944a9d9c750feea2cae54b728af905ee8aa18dcd4c66056d56e9cf233614b76390874b01770cc8d69454b8134391250fa5c1358b1c4304a9ba3ea9b5bc4aef31287b1e1ec4584994dc77b2b2c4f583804bd5e060de7618e9c8c16793e3e9128006f627ab9c0d1367d0ff901c7648674adc4225297c75a5c12e7e447ffc0a084cb974afeb360a364b10c021e98e9ea50cdf878e338b40611d50903448a32cf9dbcc4630a3e25615b3f3b303810465acdc23093aa11e537b3636c000aedcd8e3747cb424d45036baaf7c026ca4821c28ef3a150b6c67101ab3712d159a0e314b01ba2835d1ec7f715d9edbfaf91e14fb3885a0c50ede3f1ac0dec6a48dbad31a20fb559becb7eaa61b2814435b2a81d32f540157b5a44fbdd897298276a7c4fffa507c977541c4ed721de29e38c9976a6cb097a47b04212c954c6badf7894e1fdb0dad21247cde00c6c1b125e8e46da5dceef9dc90ef83c6a00d31a7f73c9246480781c00be786e93800a1ec96de7ae25df4d294b23f207562dbbfd5ec3ba2111468340ecfd84b20b6ddeaed66b8b157b012f4a22ba11d00401979e2f8a62da626cd43ab7112594374b534882b66391ce528c5b06297d6f1a91739601a3f58dd757d82fd15f39d11d5e054dae3df8bcece555ad02559328f7db6724c49c67e7e087be2bd45adb3366af689f6f6ac770b4cd1b8d749be81ecd446b03e3298e0d1923a7e18328dc7c5b3af8ba9b483962e4e078e1ed7cc89a02df0ebd314706c9a6f415fe9eb445bcd1ece78198c18aa6439a75f02a66bb24510404b6a883d0cde3e8640b9501156cf5eb63b5ad6cced0cfc07692b88709186eaaf8fb1a9127d16e3b5f37d2916dfa0add946795928956a5d8ecedb185aca11c6a8d32a86268daef386ad15f48da0b03461cc7a161a047195f64f8ded64b0be811ee3fdd805b62767c4f920bcfdd595c5fa1ec1691562d6a4a45e9b5134e01ba7eae02c599439695caade10f0fd99dfba5faa391e1a0e3910e13c737a9b2a49bd26dc79dcf0517dcda2da51c33fdc33d0d82f78f88139cf8f7e6a6c2dd5228d9d2ae580c0f561518f7de148eb94f70386aad52b4ad2cce31451ff4e4f7a6c565288e08fdeda1bd6334dfc8b89c0f6721610b84efeb73150dd68341a1222b6cbc966cd706241657bc47a0a9a8ec6d74af3ebbdc60fc657d1a3d5f89f0f86fa91b25b864e7b5d6255695710bda0e24f126d60d91c886b26c3af89ace2127f5ca9867a57f61caa0077792a3546dc0e58cae2421072d93053c6787882929a1aa2c74fdba94fee160ccdce63b5081a51800c797952e00ad790c7acf14a8bc7cbaec58a4dd4229b822bedd1768b3a9755e3bcb01676f44ca0d52c3c553a55bcf0a9b466012319b24b2f0f2a06c61a9953d93f1265a68fe974e62fa27de61c1a61480cbb1634869fa4cef19c05791bd879fd0c793b5a049a8600e1a9e087f3d9f5a9adcade01123ed64c956b9e014e3f543b417835bcd7bac8a921835e1094ba5d73551dc5d5eb9b6c4e34ddf2461bf2acc2ff169baa7122e201f600b562195dd98050aa50e08ae3abb3082bf60d75ebd626657d725fdc723dafe821b457c25aa563e51a8beade79d7cc55eb27c3ea6d4f65e18f3318547312b8731eccf547051c8f8e0f0b3d2e5f52bfcd5baf1f017497630a8085d42a80c279cd66d05cb3a4181cbebb7ff4da12a966125fff20cebddf2e98ab5a29adc8a70a4609d958771acb6bbd166653d2aea2c45769f78cd4f90ec1f4830e06ac8fa0c424e550f2653c9fb93bfa9b70633c848f98b32f134e1fead5a5716e4aea728cd74cc7054371101a9737c32f88bc6d84a7d492dd4770105939f81652865e6d9a819d793c87fc3be881ed9cb1e34f226ef0a45c4df6e7f9b3e089e99510416a6e2bc08d8875c7d881db2a24f17f2aaddf22257c2de08d34ae00358e80b33b1ebf5edc202098ffdb3fa5411944e7299605af837a5cf84224f26f78f03040a015499260314c9c109dc18d4e77c89fb9fdb37426d09b5866b5056ab012ade93743f961182923fb0160e88972bf28a9b1a6931a7346dffc6313363ec8486076c68e5cdc1b3e172fcec26c69c7384d7729801d4e0478abd334efc47d074c05fdb7331af6eb286ff9ded958b29719ed0f0204fe1b62b36d3182c2aa9105da021e41f49d459f0235038e93150948bee5b57ba9dadc5d5ab8ca3aa5a155a872bb576e594452f40af686074e8ea4511badf4c68d79e923808254246d410de559102f827bd56a3abbf0ef97532f0b5109d800b09e6cf564c632501f88ac90e5818bde9014f060e833ba1261864bcaf7d14d33d0a4c704a8427c8758c7264c842fd6c587478e55ead051ea3c549a310f39ff7d3a8fc73c26c0a8c4b132a4f3e3bfc6c1df87f5349b151bf360afbaf02b184ed0dc46cbffdbfb789df885382c943c01b6da3192675dfafeed751e15af91826dac4bd4dd6b85bc38e7e9f8451ef1bf2892908b1cc6c85ec404f791cbcfa96e115e6f886b57090b56d9e596f00ca96dc6b42f65438ac5e2164fc41b822f70f8bcbfc24bb42f1d1b892d0edffda1b904386cce4767b4af12512140a858bb0193ac6a55e2d211cf71f66359ae6c7f2c73ab08134536d29aa2373f56f34ba6c79ffe0993704ca5fb285b41cf21439059aa20931a546c197e5a108be0422cf1915341f6f1ed3bf93031918ec445a244d76c198ba5b232517f49b9f297635f8635fe650acabc505aeef4bf8dcd0c0483005398abfa6b9b14163f59dc54675898ec5127e532ce854fd8b9925f6cf29b50928f2461e8c0c29966f98d8d22b824125cf0b08f83f3ee762829f8fe1730b801199033bdaa29dc6281198867b3684ea1fd4e256ab0402db0c42e4cbc86295b491a54620fe84030955e8682806511e2f6539fc4f286eba95a0a49c539e80b3dc39e36d8eb308a861d1ece0151de430635bd07b55a203a8b1a8623397bfd2551e02e23a2357afdbdd27f3ed6406cbb7beed2c600c18c192185c62acf9712eb75e9565968819c4fa290b6edf8d19809d525fdaed172e342dec0f10264b86226e02280fc4818799a10fada95fc18ad0d85bc2913ab0bb4675c46647df4a4d2d7fb7e93a5eabc4969b46d82f66b34b67758c2ab2708e349a4143c92a6381a3049a7ca14f38a11aca70eb07dc5dc860f9453ca81530d1eaf9444a52db42757a0209148b2a720101dbf44b02979944dc01b3c50ac1f7d8f9016c343bea9504e8557d43fd089162a6d8c1c408ee833fc895989c27444d7fbfd6a955af423f2edb6b84e0a896ea5135ad11edab878697388ee9bdb6ff3c181b1216cc72f5cd7dbafb091e835fd214b5ad71173d41e0c20783360a03d6a73cea03b01a53e784a41afe07cc34c8d457a68466edb9f7daa056485fdc8cd5642b843672da9b20d926b89d9a115a6c77618cea82702c4660b6e231c05ff4be1ae1f61b8facbf28f1dfd3cad08deaa9833ea6c09f6ef94e14b1dc597f181583bc736191c46b65bdb42a5444d558a0aafd245b848d2090d0cdb5d9d3ffd832c6b9b1da90e52a7a07eb09d54a2f1015f71ad42d50fefe2a2eccfb2af957fda96d27a217e40b568a3fd584a7acc78284e19185c71feeac1bba50b6b44c85cf52971347eb1bda117cc6d997b737ca171740ad223f63b09e38878bb8a9557ee91ffcbbc89fc612cfbeccc8212cf090aa8dc248ce4b68fc9efa2b6268136c36fa1e353f8e22e0774e37b6cc4f7ce033b3bccb1cb37b2d2c84d491b477ee5d545aaa64fbae8850156380f977a070ded6235008def313293a85389517fa658b088998b5830d022e8647846293ae0f600f370ce343440ce271f3dba1d1aa1d2a8235a0535df53b867f17d5ea1655242b03d7403c5a50fb12fd39a714b2e3da44e2bd187f373a3ff87b25c104feebf4834a760cd1196c0c31cdccbac01d829ce5f9f061e52299eaaaf85241f8f827d80d2dfaaed9291eecec39ec45b03101522658db675529b6974ec2bcdb536a6f6285f9070c0849baebfc6f300c32994402b5bf7ab516afe0802fbc727b6eed03f98e0a79b544b47c6fa2bfd57845c626047ba616a590754f15c6dfe13b84d653d64856b61b77f35e42ff477121d0618baffaa980ca888f8d5e29b556a6ca86715ffdf5cfbafc46ca99db46688f358a220cc528eded6caba87e3f95f606fc9b8b32ff2cae4b7baff1a26c03659d746c04a9fd2516f243436727c4c9324ee0ea6f63900d775887d65653f42bf98bebe373d10f6c120a015a0cff7d067d4a5637b832d3e3d2b1675b1ee9ba4f8c2a32c7a843485e09889309d8c7b728417f6bde9f936f61a88e22c6cf83c628529b3084d42d70ffd4d465fb8103365509cc9bfc18afaee76c28744d3844a03dfef59bcdf2c1eb714647d1025490c1d521ef847fd4295000d8c4bb40a85aebf19b4b3fbb19bf475588ddcc9ada9744624f2a76c1ecdfc04c271157de143f981b3986927b0eba973dd2287823353314c5426a451564c3dca2a37bf1d846368c2091b2ee6b62edb3b07497993878993273e7a7e5218789a6434ddddac0ddb023a176d44c1c9194bd3aadd6a31c696ab92f9801d9ee97ba38fcc019af16ed17e0e0f6498331ddfdd2080d3046a767d70d76cb43103292d8876212284c1fdcfd53dc85774c0d70cb1505c09a618ab2709166549b4c575e6cedddb62687da82a8178adac2de69ee837789cfb0113795827cf36165084647ff28fefb55f50c4d49864c4530bdff5c2be8b7f32b25e9899475d417041ae23a52d09191408b37ac40080914e02584c5baab581a943379c96dffcd941184dd35c6c958c3869e9cde0df30690c8f60349e29a6648066a2d19a03e0e8a71577ac7a579da0c67345b0d7639aebc6f19d4b257914e4b216b4e76b40c0dc44741ee9c298ee0d50a4718c884bb65df93d5ecdbdad16a7a154d1f703caefcfdc4b04164d9bd2026d0b15fd83fc39c3daa815ec9b0ee47857a0babcbe6b0e263e1879ffded8c6865d732a5fb92ac2090d08f8993d83b4f86a008a72fd76515e30d8f10e5b0cc4d7d06f22b4ca98498616a8fc241298e44469165d97b6b92a9ee4abb9f750df5ab52be96e9db4c82f09a6e6e7a57472cc9ca11c0a21b55e9ec7818fb70159c7f2bc973a4a5ad39160ccb2a28813f45c06e31ee56e0e1afefc82e31dcecbfb45d97974e4b9d8a4ba9b147afc405d1397a98d320a7804854adacfcbd50ba8e9ccacec81a83263bb055ba05f805b5335c44edd08f34d9911d0993b45d23cb983b2beb3d8672a69a5f26abd72b7eaeac1e27a98cea35290c6ed328bf7b94187f4d61954945eb78413c105445cadb9331b6dc7f69870273118a3c50921b54f45469f2f9befdd63a948ea0b98f3e865ba718e832c34267aeda55310adca39f409552aebd11624c1216713f6e62e3e94510b45de772c0e89f60fbec02c344d511c1f6e1a3035324cabc59ade07be7757cef700b7ff04564221899b01889d969f6042e4e1b25eb045f8509b633e153e7ef1f3e7f205cc561c408122ffb8a1be1178bd99a35d286b1be0416276e75f77c9c16b03cdcce52c9679657d3d24e28c4e570ece8d10fc776fd9611d3fd54e678696a456a83a72528f5effbf2b76cb264ef8fec9056d6ffe126d7b575be3119fb0bfe5ee21f6304328a1baa4b9d222a8ebc8d8838cb0ac940f85ae9172487eb312ab0c3fd429d1c6453698657a1f749ae2ff6761b92e28ad8be1c907e5bb845c174f661988e1a277e601792540e5c8bb3cf712dd71b184f0511211eec2ffe608d6386c16f461ee33ad72d88ed845c8225bbd34ce41e74a811d9fa1267ccd30408f1a366ebb3da0aaf44cdad84bc4548f23cfcc23bd484a02a57ff3ff100355f54068edadc9e71ff9b7ff638e6367cd7d8a5ce5aecbce5a8640ece19b97dc2fd8ab69fc4d3fb96684ba6951d900443103b2be2e4d93d1f9a6cffea4153ab042bed158ae3768a6f999a08dcf6975f5bf481377a6ccd829cb604bf639e6b216293a78158aec0de4509687e095ae2d9eaf5c2d439b6d5ac7feae793e0812387cf27a45a662d7721ea6244a86c3c36211bca47ba5f29ae9a29482fb4daffad2d182f590d705a7f66527f137536c3de7081f37c1fa2c6faff5aa66274fdaf5c503a25501f9c1550a41340863a741738f2aabc0374bf5eb5320cce9b0511bfadbb5f25fa3a6f72595a05dcb7c5f7bef1e237e6ceb8ba391fae3a7956295e8be13d3ec6cee91ed05af6b08234beabced53180432c360c909958313149a3a1fb7a61aa6f9b8925299b8446817b2f0864bfb71bff63a6f7efe170b3a5ffb56c1a12c54fa2e931083c5ee73184fecddf5630ab47b6482a394aa745601b69e25411ec6fd583f5560ba8de59cf7ad54a782665d0b0ca8d940c4832b8082190b2b7457a08ea94c0118a55709fc81bf3d20fdcf33397f0fa4ffbcef5d8eeb50c3a015ef86d90549ad9e378bbc87cfffcc4a0a2f4375a7b7ae78a98d4d185d7e2e0a403bfc885fb4a9745853d9e7d9020bf1ef060b53a1b8e11e4b0d6af4fc641d4a526dedd322d3af07909669b0b399d501f7744b69df57d8730e5340554a30ac630ec24cc5d209ca69f6e388fed2168af447ca04cef0de32a0f160ec988e70b8442ab4085deb4f839a65337a619c6824550edf32f644f292cac3e5b9048b3d76a0df2090a072bf3ff19f794559a90775b3dd9b8b8574b9261f76e0e3a32a4a0a93d0fd402c241fb2307a64f01d239ca2f4628ac282f5f292cf3a0cfea5d87bcdb94224059b33096051e7c697a0e447338369c8e00da5f9659194741682cffff7c52e114d59a033cb136556bb839bebb203537ad10218e94626148ae569e159959aa9e133ecec30ad396e19b78938257a2ed5968cc235508945d068591a28d8bca6cf9a17764bc495315c9c8dab277a6cd05dc9ea8e3463165f2f98627a2b2a5778d1b57c84c64062f6de68e23bb2c005d7aefe093b7f1077e98407e13839d290d3efc710a5dedbd165b54f812bde5d9e1985907022d97d82d6d331c1d2e748a9e7d2bad2fbd5747fdfa9c232ab91106c877fe10d8e6ab90ee531d58ce978f5fd821e3dc957d48db2d5031f033ac8ec33cdf9cb14c115dc0ecf6154e1766b3cd8b959312fbd92fdbf17d5f2f3c503fc0240c8a1ef4d829c03afdba7b82a4c71ae89e4b621e64a380d83b5852955b917cdd039094aa7572a4d910824488b081cf441a12931679f4e1d830cbdb0711e2c10e93edc92869d1a2f73dfe0fe47e0c85aa314886d170382af403f162c04d4eab169ccd5c0aa1c27f2b0d3ffc630a222deb7db32e0d57c64e7d816ad6bdded8d4cfcefcf59cb9383f7788dd55bb2ec2f3e8a10b797cae6d891467f90f97c29fcc834c1f46130260f25e1d38aa35933e60a9d501369baf8ccfa918dd37cdba9840ff7328013f6d7f06d2696e4657957d7ccd09a6011491cbc22da9f2f197c48763e9b156e5f2f7b79b735d33e10166039cf5beda1ee3721ebcb429fe6b3778fcaf16b56ab956d7757d09ddfd02a4cb135e4df27497e7143ac0b5ae937319af396db406983155a2d14e8ed532e42d4c50e32e81f17cf2393cd2a26fb9dca194457afb01521f97ac580be20bf685b37cd15bd054f345cc7eb3d81b174807948edf8bd78656aefbacf94b535199dd470a3c951b764ffc4ec05840dc903f1e68367c366347764d680014165e9d5f713f5f8dcf4b0623c75b532f506996776080de7752aba4841641f4ccadab6c3443dc465b3d1c9150c25ccdbafed3eac1646eb42d01ec959efee01b2876fbada5b1a26c2caaeed2a5df6552e8b8c5ed2ad35e6cdcb0901049ad802c5c12d9699dd0cc8cb0acdb3975618081c4eeac4560198591500cf5602633161c585cb0dfb6d04d4e87139b0999ceda80363e6410a806929db7f6c7e4d1e1a162979944b7582ccaba66cd21d41fb96e43d8f63ca0a37e22c1d7976e59ff307ce93cbb8c4d8ef76706c32f8f7614a5f3789aab65a7cb063957b780bfae0ba7977c7db3eac66eb8a1af77821f0e597830f498067f5cedd3491aebb32be3ad27a81ca7990ea28e36fed1291ac10633beff2e082dcf45ae87117ee3fb3d9eaf8bdc14f216fa0034f443479744911e213f854e6d3de02116d4161323055b57b2e9bb6c65acce8c0b0161608442de21cae39beb619380163d9b7b36f857bf9e265ef200ec3815b923c1ed680f11f29dbfa4b411f88a406ed6b38a7ad2c36b8462869ffae185ce9a879316cd46b1e609af5d5db40f4d6b76e57f6759329667d3484382d074ec5e8cd6a464a9eeba08bf126119ee698691ccdc344afcaf3cd1c2841481dc6eabb7035e31abfdbed1cc5b12c0009e2ad1da5c1103100c2d1d77c99f9584cb372bafcaf91022ab1a4081a14ce1a925a553b8ec5e14a2876a7ee2437284d4323fbbb22cd7396943323a4747cc3c832eb618a1c98e26d80499b55236190234e4b2673987faf189d4b49332fb2e1feafeeffc8d27ede9bbaedb14b5a60463b36be2e9b8ec2b144ae30094a69752d5b2ffa125d532cb9f112052e9268080dc85d71b0e3ae26b1341e3a58499809c4d0993ad97119280cd8c254fe9b4f61060c5aa31973e4e510b0703743e5a48381c0e9b67fb6f20eaff9a89050eed011385afb655ea67e9e500acb5848732f3e7baf4734005123131f23e9945e6481547acfea30c5c3390520283c18fd5c9e2a97d29c2d6c41e18d87de655e59f86a6d0d8c36217e8d7188487287f8728e993e3677988e90a4590110b8e20f7387234a5751722beca22284fb63dd62415aa1da664e04bb21c9f1b0860b3ddb144268efb89cf167723702fc514d56fa1afc0ead4b406a633185854543887536e5f494c3ed027fb10fd0f15a0408e51e0db2447ed18134275a610c324b4027e6ac5e3247b2dd363fd6b1776fec8b39f3cc16850865b7db78eabd13924c1efc464b49d607b92b73c95a84b981e552ef975f7bfec08b6d0dd890bfd01af5306b4716374c94a3958f53f8745249ed0ed5e3edb91f6418e367f1da5190c6a3260d9c9a2a9477a34f03575ec112042d31a08f5f65b51ddc564f40ed082501a245f0f8b22a8577a5c1373a14cd1995911c67694405feb4f9db8932d230fc3b61c811926d47159382770446cbdd1c210a73519960159762aeb5e9459fb74078f2382cbc03b2dce6b307ccfe5e55e22921e9ed70cc4880e47f65367a27845ea7b2ae8bf2ffa9a8b7d56a8b64db866a1d8f93bfbdb1381fc00505abc923e2e6469aceb54da2b23201095deabf171392c71aca157306e3edde04e6edcc7cfc001142a0ee0cee7d3ee50d3bdb07ba350c396c98a58b802d794f5aeec889736fb65f7febd8103cbd225f3fa265242f68572632d072fddc96f9f79c59433ecaba10419e3fcd14b0638e8d9a2c47dc5344e5feda0a46609c26fc954f0c74049719ff0ae38ad40ab41242e2daa3cdb0f77720d4e57230046b6e50af71ab811e057b6be39d2ae2d145ef2f06f632ec007dbee5edd59fe3a3a70d5e139b472ef0b9a592ac14c72ab570d544e98c24eaec41da840fb2ba73e9919f5cbc8359ec881a0da5db5d0b1c4e59ddc60da7fe3a3c02e5fdbe395bd74a0089b1db72cf1b9a644a491c2b86544f8051910e591f682778c1a08e8d5b992d3ecc0196a05db84a40723020bdf41230723941020016e97f614a7b5aa9b9d16f0516ebc34af338f62c2b2c61242c13ec8b68ea5cc3f57593a464d857650562895145fa3b7ac234417dbef4a8c0733a513750b3e6b76ccf46a9b107e9735a8c7b6f1fc636744e26bc2dbd9ef2fa0bc333385a3e7e2943b9ade347f99017eb60ce9e7f071b895a2826faadc9aa73474aa71de03d123ffb7461271cbaec94b630232bb0c12cb509450f3e715ab78385df8fece41e3becb266f911f62f1964c60f384f4e78eb0f0d954dabc1592a5111e469995b81455eb1843ef1a6529e007af21cfc2f0659ee543a7233ae5fd34240902e115b943c04d1eb3db7440d6c54ea837cc6843eb8936fd094f3e504ed7e21f4051fcaa504872ba81b8c56125213d3a6e4edee4bb21dd4c1af2deab85acdb8bb6e183948f9d845759b3a343cff535d6ec723a6a04e858fdbfcc23094f7c0c156c36c8338147ac93bf1b95afb1911445ef2d5d38709f1502ef10c0f24169454f886ded62a0e03b91bc13d546993100f72ab2594c46172dc3978a6156684d67c51ea3d89df3cbbafc618c925a7c88dde72dd717aca4de579d9bb167898d84537fef5d8ac03bb64bdf392be922fa9418b000841a0562bc0f7506b179187557d6f982bd3bcdf8e8fd4cbfcd69b95652fd276184c8daf4fb9079b145284b60c6268f87866d4b0eec9361e63c674f06ee8479009d76131e25287184e0dc5ced7304fa032218bcade3b3c24a98dd14c27c18ec4c0ef608e9c517ab849733462bb8cfe75941929d195d2b6fc6ed33fd38b5aabf2188755369e5f0f3bdfed2c5ba42800a8a32007823b308c30a26139639236d4247e34e8a212fa31895c439bee30da933745c80f50363d25ce82da0ad0117cc4be14e6e89c5814ae51420ae6eafa36f23171c512ff2f574e1e85ffadbe7e429836a836944d08171dbed68bf7f53dfe82cef4a29985f99390a0b903e002623f7c18f440a6e68d22c28b235826ebea8c4c70f4b0acce64420e5031839cc1a0db720ff9db04b0af22da3abe5f1b838b4a1005cc593862fa816d356ba2f5dd0517637c15da6197c65723dc4107254ffda0311100f747223c1a8e20f652f1cdf732e884acd1abc56c30c67714f6fc5766f566bade783ef50302cb25978d99785a9b4f5b85e8d37a1f1252d166d1506ce0736d5b609ea1f6c4a4fccb374df92fde86b1c0082f86383c54b6feac901f39c24a4d6e0d1bc595ee919d63d7db63cbeca39813addecc08ae30185812c96e0f602428df06258d3958f89afb093aee200b6551ba8e914eca78b7fdd468dfdcea6e4adb16ff656eb4bca3c097f9a37cfe7c76fe662228ebf2fa7d53a7a21a6e7a9155f08a0b44cdd2e0552ca2278ffb306217d1f8e67a8182cc42ae7f823147359e73ddf8bfbbcf69b68eda3ddcec98088f9be38dea292f41bfaa713fe4ed456f98a7eb2dafe4b8d6916aeb522a8c0fc2a1b53e2c0f23355c335e00cd77b2f2243ce37e159fd8282bc48337cc5c47bab885c66a482d8da4bf1b0aee0e767fc095f1a30ec956155490eee7251409a7741cbecf1fccc2f345a3ddf77bafe190635b7dd9ba325a275984df14cb09c7c6862fc54f0ca1e9dab2261dea6a5f136a5b23e8f0be5afd3283115aec79ced871784c3d00589","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
