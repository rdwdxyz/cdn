<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"810e82a441cdde030af5aee47aba0a2467c172e9383cf0cf1f3a012233a837bda85f60483858869ff491c6321bb28a4a6d380aca89e973fb84bfe08274f3f7d981ed44cd67b8e946eddf46aeb6f8a64ef6b96530426cd05eaf06c49c5f7c691344721209eda4ed3ceed3f103f0e42b7240048ad124fac22b566e640641508bb43fe9fb45f90741508a46d0368fbfed7eef6c79156aea3e1ee166d99039e5ef15d9309fc0054e64866d8fcf820803c831e720b4fc64d20b5c85db7eb1e11ee41e016117b7ae08d58335f9c46fba0d5c58ae1be71f12e792001597dff6097abdc53dba0666e0f70f9ce14600c3e10efb61b11c8bc0fc5db3b8adf0c3907f2a0b005155c78e2357c87465059ee428e90b2c2ee4e3529a006c12d7aca59b7224f9228943038a8bc3b776e3bf7c35413c89602ee33571d374525792e5fd3d0e72787cb0b75d3a03d72c39716282def533337c03eaba8c7ad634b0da6f1ef04751d3510746642316158a94813f8a0e5147bcfcc418f8ea5bbdd9acfcbe5c418d04f576f80330bf59588efa407396f8b130f8198bf85c766854da36c56708c7d55ec8cfdd723ef1d3bc701c6e770fa6863fc5d53cfc328203d7bafd7ba10bde0c7e23089d7351d0ddad893d8e36dd62837c0fc813c201c658fae792a8617583cd7afec0ac3f4f4856b7e74e572137131460ce6906471797fdb92c093798f6d1c4627bec9ba491d8f20d87ea5c428704f83aa92eba8bc135fc405ae433a2fec2967c29db9c3a5d231906cc49e67553e8a3183337a86b8b5d98e0d76033fcd173a00fe0f8cda8718926892ad16aaf2da90779970443de736db261f9afe40318b92292358bee179aed2916c9d98db8b266d4f1f56bd04c104ff2c75bce48e3ff8d53602e4db83b3532fd93479481d6998f62c38bf6ce0398ac15995d6bd0d9c075ab0877cf290f154c824d6ff5444d4f4062372ab22d25b9e71b0bfd69054962b0bd36ca2291dac56e1ca48a34a2d4deaff07542b01cda3274c1de9e0b193ebcbf1b8aaa76007749681a2caa5ccba3c3101221f460dca523053a47a1df6dbf2a134cfa03e524118cf0335d0029159fe7bdcce1f8a63ed79b379c23b8758292ed3d0c358bca83a0ae29f538e3ac3003178d551fc32b36a63c044bbda58b27f3ef3cc5290f473a67e412c55ba7846b625c0a53caa86847bec3b2648afeb0f7bc00e911a55f855b3f114df3fb2de92e7ca014bdebad50a6bde3de14895fdfbf15236732b77340e76298944fe3a505a1516e9a23b29c09c7cdcbcc8291424641307c3c27f7b59a6e89921e556fd1277a90c0ebbdbbc33766db696995f3bad7577efa397086eecec38453c37e9b2ac3faa86c3686beb3540dfd3c21ed33f2053260b8981a085515e1c1d74050203e892ea2f6318a8d68faff85b17cd9993ca1cf821cf410423ede57e5b588edbfbb494f6650cc4072d864a83fb2a23fccf6741db87cd7412f5a581fbba3f8c296cc88cf2503e4c92d314e823d4839983dd3a887ff455c60bfe9e47adfbdc906c8cc0cba0d7e017a5c90f3d6cd2e6f6775a62e5b967697cbd4e7e83914a9b2152521a5cfff5fc1d6ab2cb9012879413d457cce659de0f2f2aebaa763051eff46ada921daca6e6b973545db4006cc7df2e88d622a54d72cedc5eab48af0c2dc4ac121a93b8817657bbc0bfae9ecf0771fdf677b8326a525bbaa57c822fd244e214af3bdbdce66b691b195d01bf88ff8e6720de13b93a2cd1638ec964c537909a787ce330b1cd6e424ab34454e5a5302865c2d38734ee7f173a4dfcff4c31f7409acca74b2f7d16ffbc32c5e4c74b9278a29e19648cd200857b4b4baeb907406c42a5b4b353d43c648027b9cdac1f6bec52a56e41df5bc219defcea5681dc6f2d588aa48a2327fd797c3ab1270641adfc2588ee72c4ee3ed31688d67a057f6049ada40e34577b4a489648e487ce89df9c1bdc04c97a7e8787e022846f8bcbf3ad73fedc14fd83b7b0b0f1c179c963dae9f1e7b7c892284acfacffc92a800e4209ce7341f47cb2f744708a8172f84964f2f2b0f427f437f0cd4ac0c34550dc6e1cbdc675469609f18fa8eefa5696aaaa5d9e80c62a5dfa765204850cdee48e5a60cfaee35a2bdb13e2438285de1a02737096ca7fbf5afd20707169b01983f0f4cf73e930879112bd2c8543db5bea838a368f6e0d17bac6138ffa8b793ed753d6d497004e8e4850b4a6d0d1579fed055dd40946d58dfbd23bae255c1bacda8620e576ceb56a81663824c41f0b9d22419c60a107e5d6ea9ce958e05970bbfa4f37f7ff3abe385248dca87637ab1578afdc20179f0444851b41a660efb9bc8121dfd3166391b1ae241c02549a5297b27afea965fb6b537a657a5dffc8f77b866f69a6064cc573368af953601d2674f54c9eadabbaee5acbe90167900823bee2540e0c27aa34e8f608134bc307d6a5fa1dab9f512d1b3d4df7108a0ba1b1fffb6cc5878bb613e42f105dc4cca627ebb5e4bfadc7aefd00d5d20d94bbc795029cceb94f0f1328f99f850ccb258da5710c5f3edb79f69f250450e5476c4a211a73b33e0bb865827df294895feb8f4b222233b2711b720088661c4b3865c737229d62450b2eb69a6eee400d716b3661c38de7dec3c1ceeea0a837e6b4117436e8176c721a8e62a2ed3a861580eb7ab32232d1288cbb08e8a18ed1891659852a72f0eecb30977b91588b8bcbb3cbe93e91e62e1d7f5209633b76a7ffa4739988472d6b25bf979bed454c955444d1748181c542b38c1dd15c7bea87c0dc08de7397afa6c990f1e3f6892108c1dff8cc39f3d7c310bf5857415b9109621c42dc069ebd0d8eddae23b9c21b3df5e842a1692869a3ef836c690818721b216d6b71d66c23eb413ceb537a8a27b9701623abcd0b5ee923e47acd3f1cc6a91dc179b460a280207e43135d8095243d01672f7d7c6f230f8d299d4148bf5c61d7ba9c75f533644880335ec373b2ebcc435a9892659aa804b49fa2a450029119c0415c55f96022ad487211342f1b022d69e14c78b723ecc737b43ef01fef878a104799fcd8169127d7fc5176783c704abac9b91dd25ee5db53c566a38877409d5ae499eafc1624aba950032b69d5a354bc47c1a951330c3b684d6a3cbbca02cf1ac7b146534eba5d79b8e161b103cbf778c536768d1882a34dc04260bbbcefb49e79aac68f065e7351b33f1700d6b7932177f0b1d89e22bec55926b85078ea57d1ede571b4894abd9b1bfbbc320281cd175915c6fff4ed1166d7b0ea22a1fea3fdf24d1ca251ef3660079dc9858616f5a2f941d9cb2389bc2755d3d3d16f45d606050456fb068dec76be0a7663f61c5c7926716203d871d6c68618a7e006325679c48b74952e1056dc1e214f1ee0a01fc6d2062ce1b557eeec7336e739d49bb7faa43ed8900b9ef5b5d1adace9b762848d96d7bf9a5818bc8e27a63cf1cacf7d0702a0209ef27f94dc5ce69629a456bbe17f3b84a7b6d636c6b48b3da0abc62f31aa9ba29e6a6073dc2f3cb1ba74a401ef8205e7db85f31f3c6bd248d140166a34e8a9dbcc38efbdca760e3d1bf6d5765852393da7fda7a289dc9fd9d275fc6177143a26a7b7e784d474224c64f3fa09e127c8f7f64b413d1ec25dd3c7a6483acf8969699457ecd9a368cf5b63765d36bc61f383bb5685e857a33c4064f3ded2560be17cddf9ae2758f72a29d29e40aa4086983386553f5ea7152f671c802c86341db4c331d0afaeb34fce0abc73d56a596cb84d4190e7052ee820df90683db82c1c8cf2fc6d513e8417be4e51849223bbfea18aff495dd0363f6847f1623737ed3274d2fa87b040c1ee7bb4857bddb8aad97dbb8b6719f94e3575c0988d1d6f2f779f9a646aa388891d306b82e4b2618ec5e8f22ae1b2d4490117994c14a4ca57650268c547488cbf854049eace13712b3c650e8e3cea29bf2c25187a37709540a6a8fe26325746ee4821b049517b6ad5b3312f17cec7cc987dc374e3224caa872e6a7e6c54e99ce5a07def5d6797181532b6e87b356770826869b0655d3839d64013e8348a9d47278df993cdb6a2b4a6d7a99f8b084f7dfaf942fb0555897f59db490e8bfcfd656d006e987d2d6ce7b34ea497d74f6bf6c9ae1a51757fad59b1e2b9d13eb77d1970436a4c4c5703ed9ef24852609ab40de3e0f0ae87af253db56715fa1ab1f5334c6706b3697d72e682c9cf8c21db1533b521e322d0218eeb28e5f47e258c55cec0c4d25cef6098a2fc18e6f2f8ebae21e7a178b867169184622e1e48620e34989e2f3d7ba90ae662cc81c5b6f1cdb6161c0a27cc5b004b60d77ff0dd2bcbfa3b5d1d3077b133d9c99d4fe1ebf86c79d2692f81c71e72101e03544e7302dd2a7dc90c063f498fdd22c9ec86610506d0f54154250f6275d976804a2070a58ddd60fb79aad7a3485e85c5ab568715e8afb3be73b5d13c3c0bc1b8c410d84d4e02a17bfab1a719ecf25490e1ac6f6afe09569b1292fc307cc4b8f5306586222b174e9215d7d882c27c4efd212b563c180170377497a5e531f057ed8730baba6ff4b86f8ded2d9fac194a4af0bad22331612c125c8a30a0fba89e37fd872dd656dc3201f685e6e5e6202b12ab5fe538a638e98acb39509ce04219f7118943486742c10789988c26ac8f06661a603f6c543ee64aa9a03920b051ddd5d8a0066b95d28fe91e7771bcf9f7cd4782e9e87057d373633c77fa851caed62697130dcc12ecdffde084e937186880fedad016c719b2ca3fdb33b617e68a56d50c5aa0856938fa1d9141a94f3f63b7bc278303b873f02c37d15815177b45e81fd1a306bd3665e1c24a2c0f346f5b6049caaf545f0b2a370da689b437cf95caae3ed451c065ec301ea73a2a007bfafbb4047667bb240ef5ebf574b363e7274dd2fb2cd15e7b2bb16ba85ef128892ca76281763faf2ba86909f1746c1c699c029f7ff948d414d5791420af010f3963bac0817bf246ccd492ac9c0cab1e7fe12910c7ebf4b481ed95e4275514da4fdef2f9419a591244e768a1b9de79af6e3f82d5fe55d1da92f9a7a449e0bc98e85dd5815cde6916668ee715695e12cf8c43a9d2fe1e971afb5b1c344a4b0404b5d7a55b14d3ba77be860fa3f2ac0864e1d20c319a9366b73da4367758363947261e524596246a77171707a3ffab3e8104ff1fa9e08fd3a32cda83de72b4869342b5d03136276186fad4f2cd7fcb22420c0c85b04ac95920cc8fb0c38c0cfc0ffc1f82e56faa2cf4f1fdac73a652f0c8899c8aa15720f8d2de628e8c59a4ba7290739f399fd5f498a650613c00e7d17fdbd9bbb6656780ef866d729fa6326ba0b4f4e0d3e6c69be2efecffb8b3a4750f321b020fff6b112d94e8a82680db4b74dde4115c354c20b05034a80fe36f4d25f884270ce1f1d1e7c36a481ab3d5082d5c99fbe6ae2744bdbea50fb1c77c476995e1d8f09ab07f9ed0564bcec3ef740f2fdd48e2876438011aadd23e783be11f2686fa6891b3d4eb16142959bd2d5db9c0cd91dcfbc16c2914779e1bdb785d969cdd69f2922d35d2096d505f699b580dbdd7b36a1cd03266cf939bf91ba910f392aa72843b736121c0be0262bfc8238ede81b972d90352c7eb34590ead5300a5c1627b62029781e21541dedb739fdcd56993f866901c391277d2ddcf5c713fcd05e001d45b396903b34a1d2964f6900f16bc91fe40da8876b531a263bd384b6c479c24ff747b6b1dbfe08f35f87d8f1e716155d82adf555d911e39c014781baed99900dd26d145ff93f308f02953a69ce1f8143609562df522f303c79a09222604e877f030ef7c2aac4bcbb144d949b0f2affb36b3ff5456d50366e37a19d4c0ae795527836797b270b6c50c14e606dd9832c9566f1afb4f3efbf785e9031642b1a77db4a148f3665cf27a705117a5dd2f5e3379fd23171522d6d3321de3ef2dbcb9497e5a658db06222ff649441482c92c7b3ecb9e8e3f5a6c7ec87d4b2fc70ac2a1616bfd9e41815e41d69bb75bb7e7fe9063ac5dc89c18e4c34f3123c32fef9aba422e4e1d2c6f39991e8bc63273a5157ff91e0db42cc4259883c5ccbd272c118a58da21eb3cb391398a64007d6faf1678200e89a24e8685345c01eb8e63296503bb4708778c7bb58bcfe14d3d8e3d7af1e29d1d3a35cf18d334e6974bc0c7864f70d208f77ca1b3996360d7d3697f1fbdc5732cc97915dfc487aded9e2df1bca2e1a95b80ea14450b2d6c428014fada480a2d1657c94adbe9585b36278d400d9eae90278d3b66a4a97e467ceb686aca462e38fe69e1e11c788724e6b1b5e8fa1e5ce56395de74abbbb204a84fb5e5e31a54b643f60fe106e09d8e2629852d3df3749ab22e9af19ca3758c6a2ee910e555995eff576c0d25cdb72100e99d6a351d5bb298df088e966195aa719c879141b470f664ff970c38e26ed86834619c2b3e55080d25654921504dcc04567ac9f48d92f393aea1ac9c0cf3c7be47800cdfcca57d50aaafd57a410eea07d7b0a30ca70aa3c59f2550930373effcf8299a51ce596e05b68f9bbba84fb78c1ac7fde68e6f93f3e21592584fe035238fe6fcfb662d41b215108581097c1a06ab91460b1150c81be16565b2f639a062bba2b0bbda7c0cf9803b8130738bb40f9905d6adbbdb239942cdca39c62ea6e6f8a1804e9dbafc19c68d202811aa12a9db10e25a8f19552e3fcc6f936b0478f8a30009e3733c87d839731056f7584ba051c7c0b1e4d43965f6d39f7dd62cb3f4e2f97a0c899bb77f84ce307358ca2c6e22cf0097d94e5bbce52f583dc49c6687c75c8022ab882a5b5a4b7d03f5b85129a79af44c7d3df3d19e20b2f2d1adf8f92ae2bf185244bb9a23898f9e6668dab78ffcc1814d9efca58744b531e3419c7a2be06da501eab2cc02d413a37eba80694cec07f070cae94598c53165335fd45959732b932e2b96953d3eda509cd6b3afd5a9b8d200ec17c04843d8cdb9c80f629b5c58b47d64e4100324f6fa3a1d3d556745a23ff539ff2dda63ae5f8b47cd55f57ef46de55fc8a4c189bb22326624f0a5f857f69017d53cf5ef1eeec5942c7924041859d4d323f85d0b7d5ce7060e1607a7eecd0ed328ccb8595da8662c2f634c765db12959e91050d293d492b8d6d16a33721920132997d80159161f3d621adde62838750605f834e23585366796e212cea521a40e30882f825f291fe119567cad2591788304b0d62b39ccb5ea9ed8eb575c4d1fab97d82d52938cc94d03efa09a69b1ed7209d159b76304a1abd1174318e947c94b7f2b9c4f2e84f3e185a621a0c1d97aa7530c3778d20be833b30d811a770e174b26395cf6421d5d0e5b8aceea998201df8dfa40696e3c2c80b6d44996d6f5d0f7c4df1cdcb66bd022cb7b85e385c7bb0f78bc12116fc366b8ba22fd10f0e83db80a99008264aadfcfc22cac997176a17367294a5d2121695ab5e9dc6ef57fae38e7425e5abd2e13e7226882bfc97b7108e6d755cbb24dd18ec71bb70344b18c068775c5701fe5e91708d520b4b43a2fc74d05005996affc0e4307eded8a7867b41388c744e34a2ed69257444fef7cf321e9378053511fb3440138d0e36b8e8360f2c7d5ffc2c0f1a4b33f21c165575c4b313a3200f35068a3eb00a187d1c109ded14507687fa384adf0f7bdbaf5606925001562b836965cadf58d7c9a2fcbfb9512e82d401ebc938f9864592d638d635b8e3fe277af04beee3730b4ce3973a5451d8e2adb7b36c9a45e367cc8f757878e6174e9ec6508a7dcede645c0d67a62ec9e1c71391780e99d39b42a9cffb88ecc1f04db508d794c05e119fc17341d2c8ef14ce3d1e95654422564eadb82f455d431f099c7b7d9aae1b3854208ab3adb761421502ea6201d415533a4a56a2818c4dd291a129d7cb7b2b811c84c08dfbfb0fecaa99ce636dd96c88669cbf5e358518f3ffc2fb8c6829b582f7e82b7ff39db2df6174c76bec77aba943112db38595f1d754a91be027ab633ece9a1781cf112c458c29f7a299245e78efe0c9e35312f41468f0d80ff07917cb12ee7a777674a2aff5dbaed955faacad050993310369869206339b67299abf3cfc5342b9abf4f80f4dff127cea51ca359331b0d890059cd78e25c6e3c67d7a0482c5fde7b34988261deebbb26d69252346514534964f7ddfb61ef3eb3c1319a54f5addd563e35f0f82dfc32a9280a451f009ed03873194a656fb1dcb1aba3d683ebb196c463036c4b9d9957f0dbe19f7792460127a40ae7480ae3c72206e704f7dfe4b3eeceffbf2cb6717532d789a185bf531eab33e7527c648e003892388c2d82087456857ca294938a02f28700f2131f73f15c447e225308e36c4307e217d89ec1d217a9035f2f7710f5de13d4b68ed2e32283b7ff7ad0b632d33b5555f9c79b4b92d06bc5cf3a832177e6f1eb374afb5c2760e27b9f650bc12f8110ca8d5893b7c96375689d5f6f2585a34d1461e628dbce70e8a1ee5cb8fe0f1ae3fef93c8df096f1efa4f5da96deb34637f258b228cee70835048bcfb047396d1b63f6fd492026fcc8f4d8fe18e57502c8e598e18d3f590cc73fdd2eb386e25f87cd7d25acbaad390962f646d9c65f95ecb85761dde680998867c8ee4a3146aef1b423d51bb5a61d309bef8a890426c3c5958a64184e8c829b03dc6c1f07702ca7eb19657f9eaaa53d8a34db3860eb4af40848800ace164c2a970e7ec90c4e8770774928db9d65f031734194551b3ddb3407ff1629d88e70213498682e16fdbe14b3471c91914e9f997b320ad642e9c87608fa8b02adc325e96691427c54d2e51b09221a4229ba2da82727af9a6ef73ebbde3120ff9a9f19964a799dffa3db776b34f2f5d5c4c12f0707e509f0f35570751f43675a7294d1450f9dd2c9fc3ec86e3140f1eb0e1a67ba81d44281401a9930e739b6c6801bc91dfadbf9d97ca7c4c87428a2cac76e5db39fb70c284fd5efd2a5754348acf80a430f419093e75eb8e53c076f5965deafe8b9adc731caf87fe64b4225983df2a3011e3bdac884eadd93017d719f66ef5fed8e9faa274b1128af3c70126d8c9403fc637b810096fb135225d1ac2ddab5d888f559d690b9c507ab5c09e40da5c58f42984fb27816994d3d237252adfefec865b0b679c82746264ba60ba05e7e31bc58db4a0b362bb785a941d3fdedee4bb50c4a7a977d89624da6fa5f7ea067e3ff617fa8fbf411f48c91235b8ff19a92e081da84843cd5fef342c897b31828cd5cffbf89d224882a4b16d5f2977adbb8aee6ae8a5e5e8795a0ef813e4d119ee19b95540b43d77375f279b4c7877aef98111f4c21346859841dbe5c288a5e7a0c8d11271782e280ea3f997c45411fca9a4d471d64bcfba487a828478e06dadb718db3c8276781bf63aeaa11e33ffc714fea0200132563a702a9cd46c806fd7e213a0e09a5dcfb613b0b9f1d59a782586048ef47efad70e13989b28b0d2042f879be41ab92483e13640a0642b1ad4208364a1f45d8c7a09274da9daef5b201276e5897fadfa7cd97b3abc6488de9c4ef654a75acf118178d4106170b8a47401c453d7a699842b1969855197671bc8ecdefc8b834f760404e02c5065a99e4062d7b8cdd92f0374abb147bf9b6e64230293cc2a8322fca58a506e33122cb02b93953a52f93347861a0ab8dad952b55162e63a2cd6a7404778ac361516b73e7b5c447f14e37074cc742b6858614a6ee17cc9372dcb9d6e8406877382f686b0df1b382688fe2b3819173dabdcdd80515c92fcbbfb0c7a4709d88e956f9afb93902b3675b30552e949dca090e529ee468a778597531a99b4b80bf10db9517b51af9d5b9199bb3c6dc9ff58ce18f64a3fa9110a8f753ed264bba7899b80d1c5be1e8659aa92553f3e9ce56dfa01ec974f23a2b9659c66a369b0e6f848284a8159d35579c948826f52b1b65ec451d0b0562f4ed52e8de2716a7cd480227be029c7076c15118fe533dd3653a59445159379cfb10fb477da8afca354d8f33421e7c4b9cbd9144dca72703a80fc33c3929bd15717144960a9c4fe2e05f31dbc3c91d233d16764f96008013a7a0df72bca434c49374cad0ef7d19bdc3de90526942cd5ca81495cc17ce8e1d002e93f3e9c80cfe4114b56697794138a99743217d54c834c2f462e9571ef837417b9d7c04a66ac5af3d5260e84e8d2b6937d1c6afc2f0cc27594e2536c2acae9cc4c405d5f2540b150e4f1d82ee823d0d8d45a14d7e83d2325c9e400c0baee460c92bba4edb2ef8e9557d366442e4fa2a3c2929a5b61fc8349f5aeb61e2db772a78dac66dac615bff294bda5344e2c9d1ba0e33fb38283cb0a60024b838947429c5816f5ff92d2b9240fdbe0ba4495268fc2808b5de9c776e503f6b9e2452815ef4bb1773fee26786280383e23693805241df8311a29418a2334f760b39df707bafd5c51883155ea94f9b7894f00cac0b849e05db63dae9acd4ba8c70a5c190af8c3f93c3013364a73f766cadad8aa0edd01252fb06c37b8f974d7bc09797fa04e437e408c9ab9f7ba75c2b6686d1c8d6f73729489d2dc557f0b7756f43c91d9b7e87c54500d2835a0f72fed406f9dde3d839f69bf1bb58663c635bc56675be5882709c72cf8f22a060241128256b8416c03882e596af74bdb59c25a7132c95a94e1db7c32a03678d5e75c45ceb3f97a91a75c7bbd2f9de07d6ed02806e02d1532c312a357174e1031774a41b69084c622a3d1109c91148b86d4a6d6ba166117c9800449d0d96da9b1d2e9a3888c4b56989e84ac935198bb3a739f1e8a634e9d76ce5216fdfbe2a4d032adfca1e73ac99957356c1c2c6bba562940991184d3b8e27ac595273e8626fdacc39ad2cf59ac6b7501c10af611efc73e2d9522a41f33edb2040806b5e9659b8d54775a1aa83caacba32530a333e5e35068903f8a9e3f510c081ee813460a55a648cc8878e82d0941c2b449fc412405df06158050f8e009aff027b5ddbcf7c336eb04af8634af3b329c05c1682ac46acc6b1b58f156b79145dd6aa6406281e17d04318fbd756cd3fba244414242e3e3af1158f567eb2b04ff8ec989257a571559e5e9bf8735b32ea980eac68c28d561fc05537a266accb6bf927520d88d59cd2b2b92fed8ddb94f034632cc1e2fa36794e33067d3f6875b29ab023b12d9a917e0517fc3de1153eab55597245c9b715b38fc7364966cd28772b5e4f53212d3b428791f2e562c4a8c999b487682f4a0cb041e42b68ee1be37ebe985c1755f643045c7a7708a0c443f6072f214a837185153ad3e8e0d2565962b490ca8661d8530bb8e1c0482ee4705ff4c7af6dd3b701f58c8a5d1d19e836a9c6a59872bdb753fbd0794e5a714ad4cccc02d625d6c3224416aa0b3240cddfd1e8c955aec91d790ecd06e6d60edfdc43c1816fd6bf0619a79a2c3e3317efdd373bb2d54be5b248b38833e9eea783799715797a9aea174af265a00eefefd24575e21047ff2630800d49581fdd890969e376365d92aa5a9b15fac6fda27018ccf786b35eb31d65e8370a9ecb2e7777240f07c883456aaccb12a1c66a289e05d337d5c67cd0a3a387458d18c24bd26ac4ad65e36570f1a85e1bcc794cc9d139c5b08f7d6b9d5b8eabb3a9a1b4ad4270ec0a5f045d14ca582b36af9a17473e8c9105bb4b3140e299f7e145ac7d4c721ce01791e6afa6b9baac01866f0f10f89a05d6de106ab7dcfb5a491e783181fb90a86ef493cd1d28f1ebbaf24e87cd71f0adab95777ad619e7e2e56988644df9418bae9187aa340a1981c2412718e0b44c0a3b770bdf573b03be499ffed5f0cb7940c3fcf268b86fee8531efa21b6251204e201b7e50d3af222675012d64513ba7485ccf00f98275e26d3e4dd3a0113dbb7518211f9cca887e8e051ade651d1ccbf439ae2a18d73236cce0793a3bcdad7a5e468755f092e6106994514978dddd7ef3d2d106ff9371541520e118876334c09b51707d45be7cfeed1e038008f0d85febaeeb4c199d2dc510ac390fde01ffdab02e07d100dd58a7fa02d229f934615b48e6fbb3acd3cc9770cc245973ac5663c054b6bc39fd4d99cd46b37451e820498742cdb25c8f2503854622f8d0af2b8d256bf0c97b12a34d1f366698f0cb6bfe51a198de928f34ba83d92c4072f20f660d5618be551bc373c2ee9c05670a1d6cd8d4bf2742e1b30ea10b45558b5ad07aa428cb56abe62ba73bc6a2a79bf92da8fc31f25be8a4aa9b6f416f1e37f70a97e204ff00843b440b491ceee03ba1d5b71c2580b6dbe325f97581657a92e35691c375111f73463ab33427c982b92d9db1082c9aa5c285a3a1563843b7dd2e28a3d14c2858f5080c4668cf41b305e784c6647f5b73642c487d6e4123cd80fc6c8e491fdac432dd9ea68979d6c3b7d3884facd8e6c4affbcd027e6fc976da1b589af70a3cc880ef93197f1a6b4118baa30c835846628a296ce10346076137d4b0360e7c318ea0dbd15f7eeef7b48586e613de582c545c8593e4fac1796f447b2df912e61de978f85747f8dfdec80e1fd97789ad2d19988cf3bf4aa1ae3d239d5006a749e24a0c448ae2d1a2e61c8bc1a9baa7e20dd94d6ee6e49e91e812775779e1c694d96a2b4d26f087850c264535654db737f854673f8b0852f1732a57bcb0a1fb13dbdbd03ddc3d482fa8d5977ccd808fe7bbe3e78638166bf02aa83ce2a5a9c1cf19b888ec1e49eaee3c4785a1c9585c4746fb56b6d6dc1a0f041f592c25edf69c708cf0b26af0e0dd7f41bd984713800884fd579d9a327e7aafec289a730c77a442ec5df4c600d22db125aced2c27e49028848933321f3db5076c345fdc5e75836b2d802070c1546e2fc7391ae63f69f07354beb4eda1d5fc63c1f6e560f0309e0652e303abf5682eb6585dbf9f4622ad074596dc283d86baa404b11ff5c2e51587b94ec650179a49d6f7185134d457ef0e88d8f41b5b0ccf004e1bae0895a2f6b13d6bdd5349559635dc69b76768e6b172eb7a20926940a5ca341f4b609b52bd7225cfda42aadd6a1c4178faefdf12bfb5ae805d8e23ae054bf16598d6162d0caffb6555557f332c6dcabab8551f662449fdf32b1e99bab751fdd299bcfa2f260ccbe1d305c14c16a31b0d92ae0fc1dae4a6a15203df144a7910fd0e3f1301078c7783575c7aadbaa29769a2a51d9c1184b88e283f9b69dd2b1101b219a2868e945ffb00dd5c322db52bab7e4125d97142df332b30adbf393c25992aa28eb4fc00031c3dbb7023c72abc1d02859a725f28717a89f0253ee97d08690dd981d7a6c68a0f26e9bb0ba8b7403fe3836b4c897a8e908907c8f4092427121d3d93f9a518bea11bc3a2efe66af4246aae91a8e1fed7cda39815ac0272845e8a4827be3b45c82950ab053e1959f320e2e707ba65f426bc771db37eb06eb69b14f2f46cac16bd4128a0cb70d39b1130b0eb71054e09b74abc45ea8508d8373b085e2b3961212f5d88994ad6f611ca8aeb81357e66100f45879d93cdbc21ebc6cef3f8e506658a4ee6e8a825c9bdffcbfcbed6acfc2ebc2bc3b9e2039798374719869a9eb8a2f88adb5d8a62c180ae08968abe72a7a05c3832a01258e8011056b55106fd0be3e604e1af42d778edbf4b47c5a484815cf069655c5429d6968f8f6c79396fe8720664bda4211749b0de51ccc0ddcf2b6c5068290411012f99aca8c6eabef727955240ad84e261683ceeb8b373ad251cbd84c60766a3bf4d53798b03993b50c44dadad0b2fbe1a15705fa9a03aabe1b639daef716e8800b5fd6d4158491b552c3cb26f402d49cbedd71c7e22f3ef9a875c77cce5aa82593f5d9006c2cf034dd9a496c9e06faa433a95b556269996845288b2327a624f4ec4d48083e086a7f96625abbc30af84acb1829fa4286b44b34d5dcbc3a9412913b395a9713ca87f872b897bc88742c81e3b42b106b1fb44c009d14f7e5121d831b81d219138466da290252687d8747cefab92a469f528360d41e6957b6dc07424c17a4905fa60960671f28ba26dba4aec322c6d2e4f05c611b54ffd7287e71065641a636f432f3008829a7ca2000791ec060b285094b81c19e448000999c49ffed0a964d81ac9a8644ad389d30d43c7e222099ba2322b8fe1d4bd4822de3b0b0d06b9406505786fd7d068268ac69bc6c7c80403b025436e861e7354536780aa40bdc08f6594558c6f6a2346691fc8e9960319b2be7ff930f13f231190a7ecfd0dafcf26d14342bf1ee4ef3d02112fec668330743878f6b029633a91fceb48d99d70c42e8dbfa9b9ad50aebf2e799d623755917d9ea7ca6409f0ce746a73b32848b9e9cab6e48899f71d5ac0d0a3fac39b83ac7f79f8bd9df3cc3f8d3905340a22e6f47e32d269ecf787d3092dfcffa1acdf332287e5a47b9aa546d93bef83530a5faf19283896d21a6bb5f02653d07afee544ec82f5a8f9e61da2abd7227ad7b02d7f08fe831f3651649d08e6ffc1b1a7cb53a0b4a10e7b98f27b5311a1a5945061106f1323de5a9d0ce0079a604fe646389e291241c01bfbc6bb317ba6ea48aa6419b5cfd31858f7ba0f86f85c07b89544958ce50aa8f38d146e22aed6aaba31b85137b3f886644e7672d926314f5fc282f706907131e85bc661567a3de3734b2297df886fffa605c0e2a7323f43591ce0b2ae4c45ceacdfff39c6dd1686c703e2add98d1e71fb24eec1957828e0907cea6ab30978b91b203795d039fe3a56711a5cf18f1cdfd24c8108353c2ad1ba3711b2bf9758ea77960e81c67ee8483cb1c1e1d9bcd92b48de5d8c85a32e339c96df679852c97951fa59126b6518f32ce937c286750761ba2297fec314472fd1526b3a1d660b8768cc43fe1e94bb8b277f3975466386a1c0263ff27fab789edaa103f8efabbebea5547bb8c20c01f6b27d3cdcdb41e03103dae5b567d0ab5ef67c0c3b844668b60a6775e3389afdb1b418b803877783b0bf519a20e8f953684101883d729330d194dd2aed71daca09593e5c57031b8f79926988efb50b654213d2a430fb595fe45ea1c884d9d4d350d1238b44ce7ca175f2032859e4ff29641fd05fb95ff58670323bc320","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
