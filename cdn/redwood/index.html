<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b3595d9116f76cfa157764b593aab05d089b63138fbc0ce3d72e1e5e8b34ed2a351c8fbe9a7e5ac2b5538333c6a6e646b12b717adb4cec0ee0811c32d582c7c0b032486808ad44fcf7c38a1eb3739f55ce691660ccd21bc7b81d881c8c8c0301f42755e69584ee099a1b3242e70bb3b3241f9d0ea1523d7b7e7e285f570824509db6b7591d1f76ca545345b5c6ddc996b252115ac649adb0fa800b353ef33c6e1d4a7631a0c2b7c0c8622dfe829d172432bedd57ff6a23e3367288970a0a09baf1bafdbb2c9f035e7495077f9c142fa3c25cccc4b484bdca03e5e5479dea32fc0fe6a6bbd035e38d3c563d1d754e45e54ec17fba3ffd5bdf52824c2f2b7b1d16f2b8f1f455a5299e910b50ffac30230ed6108d0e688dbfa221ab7f8e3a08083d18e186939be359834198f45d0dd05dea8584cdb544502db65e6e541148ef2df44ec4bdf31247ae55dbf47683089d4a57b72fd29b82fe8d364d1281e2d17871636671016194550dff6ae256d178d0356c1f61eb7e6564ccb8e8b1737ea7ea9533aa9370a31c59e035e267e84970d119729837a9894bad3cec9f64ef3c83fdabddefb1849a32ab5c314fa6a87f19fac1c1913b9517555ace51485c1e8468922346dbf40b56e4d439801057961d2d20e8953986fbc77edf5b6e2f570046c8ec04e61e976f2114af0f44ff6bc92523218c8f50d5797c0c2671f07cc71620eb2d97d335c8987caabf13a9f9303272f5a3faa15ea7676642d8af2d5ea737cf3cf68fef5bce47d886a87a502046ac541f68621e00994eec189d12f07eec4337c864b761aa7413e665b8058ae13fbfa93f0ba977f25173aaad79fc4c4fa565fb78c3e8836d543b7d9e634a9d53d38b66bb09b88ff09971f1a049756f198714022375b67688325a6f19ce5a644beeb046ac866739ed13d5f5e68b75eeb5de8d914db1783447b9abe5454fa4894cb85a85af59e4b326ad89c4b67412bc546b0fa7274c16e6db09525df9044425ae87b239b3ec51d4b1d5e9906ebb0afb53e651199a551259c9cd0705f8a7506c68bbbd6747a7e02fc495db391eca6956e6ab5dbc9389ac2e12f5bbff65a7b79341379697d1769e92d3e634f69d142abf41e503b710e69d8d831e09b6706591f639a7d8df27c32b21014ac85791430d090687038cfd809bdb9072a2c60b875f5a1d3f6fb1a2cab277b1044bfec99a88e6851e5683a5cc368579699fb38626ffdc2056aeb46b92283780b7d2c84c6b5455204c78dc8e6204837d815ad2e7ee8b4e19539f056a71d599d045e0fe4d52ed3056064392a9676ced43e1aa0057f8c9ba51acced91b18119587e65b608e25300df47803a0d0f07508841cba7b43aae68ca4a1a87af678890a10a7dd8e40ff72a2d8ff35d5b932329640f7466445a8a1fb45508fb1896814d38d919b2dae3a881b60387ea2d2fe45905f709d27da23338ed52409e82207f2a0fa3651555f4bc8a04eda74aa34e276afa2173ea419f5f87bdec7697e784bbbea018c250294e8f616eaf2d51d2078c541fedd24913aa941b346408a044fce0583984ad0694db95c7c29016eeb5e0ae410869c1a68ab07913a44c40c93a2dcb68cf9239e2feeaf509243ab8931119c9b9ecbf74a0b7ece914d1e3140044a2c8ab8f855eaedb1deb27b889abbe34bcaf9b88cbb16c263f33a9cd22b46a4a9bc7304c84e11f2f8c2e98efc60dc6d5c8c7ede73858f2846221e6d1b85ebaa181b7c3d6f29d5d3c607621f4262f1ea196614e8eb86f6ef051e9e79bd5060231757a22f5d4465cf8b49d6f6ce1823baf6e937f5750e35b98cc510ea88a05c90caa127ffd63786801eb5351da69196da9c63a12cec24822e6e5de2d98c97b88bf1b497edd829d0a8f332668ec34337687ec5753a7958be8a2e91d5382d1604a573c715a07422b31c407a4f84b5974eadee03ef22fdd549beb701e71cfbf0b5bd2567b009a813d2d28c45a308bcb4439efd2e0c4c264f99174a3091e06a9fe082ceea07a06532c4ddf42ce753b2633ba69d9d5424322f7a23c266a6e539bff7f4a89b804210cba8c2508be9e8d9f4bdb2dd6050618e711d07bb99431aa23d0349b303e9790c1ada93145cac4eb2b97d2ecdbfcf0dc3517366092d2b1244cf32c932eacc9d6d9d14d3fedcb5786e8c92d2b0737786b0ab454cf181e73c152e6f5d20f197fee63a2c4ebb512ea4cc2c82770088b19f4bca022c743727364ddc52ab13e04be41cdeda449254086dc72f2033896cdaec38721237ef5a943b05a53d2720e718ba0e2de7d658324176bbbfa0d5f1b70f73df216059171b3d405b491fe5ebb9a5cb6b866ba07e98a73af2eab99033811a4b76e704bb52e5e8d0b48458f60a8c080ff2f21500d001b6e2943dcb9e9f6533651d3f34230c43902819a69f2e54adf1eaa5c71a7101f8cfdfbef7c92dbf1c0bd800e8f682ad06e8ddc051c44a19481b8b11b7d6fade405230054fa58fac1ee059a9831a94249452c4026d97be23a419c0df3dfbf16186abb414476e2d07a6f9a36c10707f68be409c2fcf4e01fbb403a443d7455e036528b2855451757b664bdc30642f105b0cee3e256323425899fa22f304212fad8dfb081bd144b8374088da9ef21a5c20000ce76642717a5e141c34846f66282c8acfefdd30ebc825d824a5e1606e796e2fa33868f34268280810e6eec21aca8a44187d680fe27271e833c3ee7fb797acff53f0483ee93fc92cc5c78bfa1b9136275841f7721ae2d37f2e0cf103e71f2814edf695f7def833bb6e410469f32b32fb370f06ed3b0869f0381ddf932e13dca056ec8034b15a5338351d80279c6bb104373d06f5e8cec14c1e2b7bb3263208678cb75a7880841e231edf50bb02fe3aabbc6e1b6a953f7991619bb366a7ccda141a5ff7e36943fae39928eb9587ff6156fb21bc204ebe13849a3867e4a5a47e03f4a1c9f34b20ad79c22b97256cf4c7d593339c2a9b3e7cc73cc5c7477b4d11fc3e539baf543b0536a0b7008e2dca252b46e929c9ef126a42f9f69d9b91bc5e7e92cfb80301596b013a5b4641d3927a0cb21afdad68617338ee11bae9142fc81db5f179bd02e8177a2885481c9f1f5aa5d397a771de2e8b74338716fa40d6c9ebdde028477f0d476f6ba0f094725a0b382ca69767e12b321177bfa8d7e94e6db713240125ba0e43c78e051c11bbe0b5dec48f823ef194e440774b7ca0aaf54e5cf696584d667369fe825200ebbe3b99bacdbb1bb2d98eb319e347d8d92ccaec8a46e0f144b0bcd9583e6d97b5da1388ac88d11ee08e9b0b2bbecc28a8c0ab59301817865e5a762571788d9ed7792615033fa37d5913b029016517817d1855b4873c84720eaa5b7acca51309f410c03363cda9b5a7833ca7665961c4e5ada74b30f1780e2d4e24f80ef8a92bae317511684882d651296da165d6f6c34d8138d600732b4cbf1e3929332444eb7283c45d6938930394f20b318818c3a7397ed44c2b08b629e207ab551ff4a2f577e862eb5e57e999419757db4e3afea5d79e90a5efa0c7b4ff537105ebcaed34fea0dc16ead1167e1422ab669c710aaac1faa68e3cbbbb8321a91f1ca4fe0adc2e8abf0198be77a1a3d02ca175da1ec0541b73cede0c5cfc087f3b5658b178b797611e10cf3dd06bf95707fecc356d8738fee0cae48396753f6aa14681a2c40e82c83623634dc25210ce63c7a07cd8cd5ef5ba7ef84de6f2d0b07a689b00abdb6c2518e0549418484e2291c3cf6a7cd54b888924f973cd62215b23f57004877d471c119e0d80600d573f1f6de4d5a92c1abeb05e1054f2ea5a88fee71c5a0d46b1d2777a120a74a693ea36e7597b11773aaf7eae52233593783d89ba503db3e18d273599eea7c19d11d1dd626185f83018f8ef52166fe20fbf195c11869c8771159cdece0eec4901abf16c2a9f372e813d6fd6239c600dffd4648eb320d76fb06adb3b13530790506f2511bdc3db16ca179649fade4dec95ccce70259516b090a4a382574caeb40fec642c6c8ae5e345d0c500c0c11874e5aa43325053887b87f36fb43259c18359bcaa6a05dc7c8a3f87ed236db577e7bfccd4af3abf73245b479bebd89a359beac9f6c84fbb420308f3058f347414a11166759d95724b6381a856bccf4e8a0f7e739101e05d09b9f89aeaaa72600fdc0633103f4fa1393c088eccc5415e5961485776ed821d4f841bcb37280a62ed2cc93fc9ee1f124ddafb6cb7a8fefa7303538d960b2dfa58403a4cd1c382ddef5d0414ad5f6ded4e07de4de9566f8ef0df3a935747b16b83c47fe694ffbdcce5d56540d7147a65b250b6e47d925208d55ecc4de8cf2284a532c1bdae8ee7407c48feacfae94bfeb5ed7876fea733291b6a538b0791da4bb21a5f251b408b448edac780fdbbf9d95abba5d60f693f6ae69a4f7584080d992746ccbebc749cc0c17106f1ae9997cb8e6646a9a41683b02ee9a0fcf1581dd5aa1b75466bbc5d3129f702a56d98cc03802266e3be69ad7eff3e118b974af153c9f172b7e9f49a26e82d67f5cad698485cc9c79ab7447dc1ddbb1b20969e63c82a6e4d9eb20593b85bf8db8ace4f5585445c333b6e20da3bab14ca57fcfc2cdbe151f3948cf5e8022120fc2fc7989d2f02aec6bde48ea5cbc33db01a00ff0b7d48116f07bc8bf9601127373acdb20721adb8228cd6199d8e241c678c54380a33dd4ee5f0af7226589792bf9036b14ac72128abc9b00ba256c48e62985b698ff0a7f561689524939aeb63abdeafd40f4b94ccaac12e8102e79883e1906c06a2fb012481fa8a27e07cd16205c5d4076b1d1890d8fbab893e1f8d179e18ce56e30c578b38120d6f4c27e0fcecc8287f16c3d1275ca985e57ad4c1689add416beee3305fa725d124cc0a46d6a80e3a18e3f494094f4a396b1cc112c52e8387bac628494c266c8ba11735720c8aa8196ec4baba92574409dd4c4211d2e8ed4d6457a053f2223df0032ed514412cc1328efa5431df39daa04cc04f533c79bae3900800deea2e475d4946ac5428f6223e3efba4c889cd0dbeb5cd430d2f4dc8fabaf8d829671a5b7878c7ec182d9ee55ebfc65b5352cc74637275e449fcc20694486ade8b4b516f6cd17b5f3b795d8755964e654e4ec03ff5ab447964e0e324f6fcd64db56af8efe5f21617bd780f80956065e00bf9e235b6f2d404b6a9660f6e0dc8cb0dc3a892e9dd8d625d4350adb6d9876fa707cb7973229e30fbc5b0cc408f15e42dbfc89c837324f6c84642ce3d04b71e115c142cb561b1d243e776192935a97a36af3a89e02aabd5019ca30b5844373ebd36edff6ff6510604293e777652e5337fe97e76a4eb92e3f21930bcaaabfb8a1a806d88d90d880d34c8162f0e4288512d1eafcf4599258a992aea4ad30721b70565651a147c101532d00d19eca471a19c293784c37a19fd34f5b55131e7cd30279d0278d238728b0625beff9ef642a91b2faeb5cc56c05dfa6fa1826c6d8828ebe5b8efa0e8f3cba71aae240c980df451cc14a5f64e9393389402cbd9ae58fd7ea01184355e304cb95880417812cf31ffeb22ebf72efb153b8b1ae93921c3a0651f4369c07b41deb4644bbc87521d3c6b7b298489e9efdf006f48a919d63a4a90b2b10170726c40fb729e867d478a4ec0aec1d93eda0844953e4a81e1d7e6fdfa63aa52489153de318931b01729890bc768a7b7541f626b14dc1e2a6eaf23cfd00024d740d108cbd74f3b05f2a2f870af44ad505cf041abe45842b66500f88c04aa154253402727590c8bc1c5b07a3a45e66d46463d44c4366508b7eb041e5d37f51747d7e8d377b64e199e76d9c7c5976970b2111e29bb73d27d1c2814ca75740e76a43a4449aaf7dd2e6cadfac84289d47f1af3451ac0deb1f81ce1f04edc75732f05fcbb3feb73509b6a83818469ce6bde3e3e9247718595d93cf205f559c62d90d87a90d1ea9e7ca5231834c08a3d1d4a18989b4d6a08b1e6a200f482292150b023bf591d0ccc0b829a30fa80090a73c0fd4a1b5dacaaa88a85b91fea798b465ed02b5d14b027c039dbc2ac13aa1b6efcc1e1ab497b085b20d1df0a575f03c1cdc5dccef206547ae50d6f815d34ed1f9b35a47f0be8e8ff91c3dd1e8d6dc063d9b6733c9182abe610d51b8b407d84ed9f0dc19c448e10c7e3448113d5a1641a0b208282b46b0222288fe3f32c28cb3ea0308e68ca77e3f8f4088eeff35a26ab86ab3e4d710031be6030e4313df6bff374dc2908f9ee8a6f8e1202da1078966fd5c5f620caacf09f2084f852d00d630736cdbae1839aacca7dcd71f3ba34bdbd42c2548c4fcf7f9c4aa116a0efb8a6f5f1f4c9edaeb41759a3c6f6897f6bdb0bd1dc2eca25a6b4791d2107b70f21586a10a19d0b29bcdb702fd0eb2d8afe4cd659980d7f45ea99729c2d2c151e9b9d9647bf6835ec7e6435358e15bfac3095309543c00ec6eaa968107ba74e4a72f6a666f140d6c3cfcc26c3841c51e1402033678b9e562173d0bd1689ab1fba1c6abcab07f277ddd855bab5da3fc227a6a868b94dc14bfee806e03b904bfcab271841e9e479e9d0d1b3da79cd2ebc86c6f27495c2ea435333d0ddcb21d52dab51f85ce5e2db0ba8e9337b4ea7e0dbccdd1f5cb18dedc27e1703dfc378f8ccd100890369658138700e3864a46c3e6285f62b228f6b37ee49c8943b6d399ed0a422f84e9ec32b3954195facf9f0e1cb1a79a2a99af34a1917ed1bd5410657781a4c7958b2791a7f5a6e8762c41886a337b8b7417745d55dbc6811f956272dd8810468da6cc9da68053d1b58c0c5ebe34a2d8656a66e80b50f8dbeb0d1862d358b1b851b62b6133a887e78767e369b9447247adf5ddefeb810b92c927bfa077d2ad4d3468d3837b45ff956a4a0a3d5917e43c5d26e99a4ff36f85d39959d7bf9aa2e4e6f6cf633efc118e5df33a6dcf1f42c40a912083574be15cb226c088585241d8dd02274d99fd20dfdf5775b752c7592245d8e08874ef01c8678aa841c18c5a5dbfad8e48f0f399d50df6e5c382cde9573d042d2f25c135bc09a33af0c6afecdfc8273aba471c6bc6cb78a0bf5d6e10c75231d1edfe0799cd1024763d930dc926b0b260ca4e397c38859dcd06fd57804d54f90c9e1c586127fe48c8bc43391cdf5e516d3557a8f36a95abc2d33e58a90cd13787f961238222b4d53ce68419e651082210d03d47f46201653e48aa2b3244b0f6e7316f5520cb141b775f02455a282f0bf771c327a60471ab0ce0c54b5f44f58e7166016eb1a84279a7e0e21827bd4c93c9b135cfa7e396c203e5592c0cc5d152742121c7ff2e9f5f92512b9d02839c88dc64755a5d8fab40977d4ca21dcec11e2a99f14cda9cd626d8f9ff53281b443d060bea5d7abfb1f3c12a73e42d9bea83e6828dfee5fe0137385d1eaae192aec951a36c0cbe3250a80ebe0ce9369340cf863156c5526d9d627083aa9768e136896c54d5420839c9cf4e15aa3e40334aedd3ae4a0c19fe52645dcf736da2cd489dffc642da45c5ef2e8f3c24bab25c306f307c5a599ef2f0c2340351d36c54645f7bb64aef6b15a7eae20d38d879951ff5f31fe947fb4cfb45a1a50669e8bcddc76acca7476fd140eb75efe346be45e037eb3eaa24519db824bf22cb4669b8101a47eb0a62bb1939c90c3ae6377101e164eb65824002fbd8bf0c8428a13afaaf17dc11ff76470c0c5c5e0496050806c9c8d44d1780129206b1496b0c97f37e7026a11c6711c33a148b68e1577b3cbea232ad22db354ab4bfa6b2d797a6ae13c345be079adefeced1db19f314eb532cd7f2675d2f6d5738b68a7b86b7f7404c0a85251662643320949dc434f18339b087b8364535834b335d1657402a62b04ff7d6bcc175154829eafd446d95b06b26a387456e046267203d967fce705142688dc2f56483da59955d156b7828384684d5fb051a026a4903769e74521ac679c8b987a549538389cad840ce1fea16b67299eb8ee0c8d11ee43d1087d237e9c68f63dc4f1edb941e9fdb340fc53e029334fd6c3a9c3a9d992a69daf904b7d212c92f649116215ef916837c56a4f5e4de3aa55da6e2b7e054bd6b1e5ebc717e782dbf58c0bc8b643cf1a1dd818aeb526023f6b82412534d601df5dc71279be9cb5effae397f7d8f536b2a443c7974aefce6ab234724a185f0dcd895ee0c1e21e0af388de61482bb02a0e7a7a48b7595f4c0b44ceee0f041e3427fcf3055a4f4a060dadf7fec6c10c959a7c62a66d6670f4a92d682601c324e8ef73f9ca4aac620b16feb5b8335b60ef176bf9fd03de86aac591c556faac685daeb4b982775c085e1d4c87f36e6b6896d847f22d725777d62d677d6ba263d0ec530e6e4206ccbd3df78005aeab790d7b6ba33b18cceb173a17ab6a805d4da021653169354ccda2d73efd7a099e69746588f7a07959dd34cfdc962620d34aaeb33e1db76cc6e387285b5796c97620cd776071f8cd8dc51cfbf485dd6c84da3e6e1f01042aa8f369fdbdfb0f2c0c7af4429fdf33a96122a1aaf92739154345f143a98416691517803a38a6af803bdc84477df6ed76a0d05b0458f39e69300679f5b1d99a2ba867b417923a867470276e01a36989ac6c7c6baeae527dde2d45bcc05d5d7105f0640ab1cc60cad8ff76777b5016264d0a0daed43c07e28849cd2c9d4b93026bda0eb723074708cd4d4de7caf8a26627f4b4015dbe71954f56b7b6229a2627d830ecf64d0bbdf5991b25a5c73eebd89c5541eb90ab0845d122bc9d037015a3c106d0a95b6bdd07b8dd27f1619f7dff9311dbbfa5cd4373b94122691cad3b6745018448db5c499567d18514f0d0cb81b44f9d0bdd79a04ebfe1ff5e96be82f4e5b484c1f493c7c3f9ce484f679a538e9a081c7c7f22c2b7b24d2630e855b0a37256eba1f31e1a9b6915bd6ba240387c4bf681082555e752b4318a91190bf09e71732e83ebdbd1e302832de5f3670e982237668bd3802722fe248c1e4d713dc580a23cfdfb8c31fc44e2c9c5994dbe3887fc80c5e34cce9a9575c0ef348fe03fa81524bf147295b81c2d25370282236d492aff0d0a468215ba57bbd169aacc4a54b7d6d316422bb47db67c559be22c9b0dac8eb1e0902790e70b2f10f9f8233cb62c91b8a840a5bd9a1966d2aea8f500cb92b5f3666a870269c44b51e0cb4a7757ca6d1d82af7bdb1d1d72018277d60819594f795d4ea82bcd04b1b9bd90ac9676e9a5e96417fbaab9e5643c6b5a44ad457c0e9f0c633f2b0a04506b16858313f72ef9112f38724187c42d3ec00ab7fd83c2f9cea3b5432365f12c6423f856607aff61e000df6e5949ee6aa483a48e82e8f5a67c2828bff0939ffb5a467f671b09d2cc81632be3d8a8b9e032dc9a794f97b8393390df9d6c4be3d8d9f176996cdf9e366968827147ac05d81ba73901e5bfe080c1fb68f2eb9ca9789d765025686a3093af66141ef7580aad057456118c33670b85fafe692b896f9051f36e6c59552755b4b20b46ac156195fb131ec9c7691260c1ec0de76820ba2b6570d7af473cc61ee9621c53d7f0974bc6ed090e22de95b9c3cccd95273fb4bdc6f7e58c74b91b8e4337c32c17a60d34d325a90f9b0ba366cc3c4dabb0fe051a01fad064dfca0bb91ecf491c6d2fc9487e7409ad2f5371d0f7a492b927ddc1531993b4a7d823711226c898ec82090ea2b86bb4f77a36d31744a9c7745448f520e2363a8a26d7cb74a6265f1ab4a47ef5df3ec789520b987870aeca410335a80b1bd1147a4d6c13c9c71caa0525240d1a7579459c05c2590e7a0ceefdc824a6c2c15a072213645ae7805824f77aa050f4a3a028e516e9622b5222b481e226aaba74f8d4a84265a1fdf095ef5d7c0955284b6a3decf22a3558515c3c4d880be2e5af3be81050eb7a86f03ad2f65f020516938d20166ce9f683ee2adbde179678d5c6dcb0d00302a4b765f533e3e3f80c93e997d95e8fa1937c00dca5040074804c004553f054b0f7c503e54b5cd764ea81d0ff1ab897a4a90b0cae9616f5e8b73af8147e1f17a5fb54a3a322952a4b2172907e6bf1f8beb33a0218e343cb4fbee583b8f08358ec38118383823162ec6226e51182d6a786f54a9c7267a9fd80d99e9c5ad1a18ac4287042d911ef1f5206158e5d9b48cc8235895c087f664beda3f8cee24a145080d424fedf9dd3e3c0907b7e06ca7f9fcd72894d53e8e84458a27762b9b6f826d4f70d9ba16c1e6e1628170512a28d549df78f47fa5b22bfb791ca7225757e83100e9cc618c1ac0f1548ace79a2f2f0b6023d4e0ec987de8cdcd7fb6807a1578857e241f4f48b7d3594a6881cb49fbf0aea99359661b57f7b1fa83ce6db8602bb21b9a86021dd9e2b6743bd7e47bb0ced951b72d5a53d348bffada2b334d402e77d4d43b814c7f4b8e80e58e77c9e039172a341abf3575a5c16c64c2754d205e24f206a716b4dec006218743da63a9f3680975e450da5588d49e88d5066f07396d080abd040b45edba4f5e98bb6fe46762c77387e56002525d9ad3ae37766ba240ec2d5ac467146cbfc52cce418d29ad620c35c1ba1826370103a1d7c9942cd3f194c8ecd0154e054225cef19f2028f816c19da4d6f67c2eb73b387e3a1ce0757113686d6089b373fc7c2bc0a30d7faee0e95053e576defd751eb17327c5aa4ca35353fd323d4b9af632568ce61134c4104bdfe65da7f11ebbaf0c21bad7f39315017d6d039db33a40c832f0b96c8c68c69b31eeafe10fb5f34f5bc8e85ab66c52c9a5ca3fcf07a33077dd67a6040650974195850d36a5232c6858017776c6ae00eaba5c71202713375be648386330e271b39a9c4e7315e29ec2e456c2493ebdba15e092bf569458ee2b5f1de98ad4481c09cf6be46203103f4ec4dc86d4ad37f67fd1869b1ebcdf58ffaf57519fa3939a1960a12ebfface10f12f587127ff8453d3ff42e2119f8e76b029e85e423f047ce35beaa6062c1feb6afc6a58af7a282d5ab1b4a791211326fd1d9fc4f5166a876ae1c819e9f2923005fadec3c36592a38718e9ad0bd5559d81f23b117893e5b4c6f8cd494cd652d53d07d06b4075c1011cee046afb9d3bb14b169067f7090a9e856baeeec9a4eca9d3b2146868f662a1c887712099f1d60acdccc8e09b1ba7e3822d84eb663670ca28b2899a0047d64e4c96ecf900a5bf72ada5f94060c4acc94580787fc7c0277cf24e58b0513ef5b82ad800ccb0e3e4aa4332279ccf0cfd548cee186cf269fe47cdf23e89d1f66c7c0c00f0e34c5083a1cf5d2c3638d4dce02db6f79df74def4921bc1aba078d4efefc8d174b1e5d8b3501d5be5ca004f07718747d2ca3f386889747bdaa13df59ade4a1e89182909b34b24393b9a4c8302ee2e9bf376efec40229a41b337c19a03ae6a9ba8aeef90708fb913e727542fa6925c3d133f170fcd8b5131b66e7d6cba2ad412327fbbb96fe7f4300e59af7bdd17ffead99d4a16e79c203646c71cccd960283b6b78f8f4b6bdce18019e23d7bc5f4d8c426f53d68dc1274b5f9485dedf2e5c6ade6250119547b9377e80be7ff5a515a28146c76d909c85c0984603a8af2d857c938a662ef0fb0a24e92d719d5d2a6cb6ca92d1281ec3e7ead3d4b58ff40141612da11a0685d268092d2da5e84508c469fe4b1102e81b68502c78d8ee541393c3e8ab2412b8d9c41ba0ac9521fb335c89cf4aa22c173519c412a3e4baa45c83632b06e9ec336867b8035ff803c31363a1276044d06398a2d40dee6337bcb0126a9c3e74382673a7a96c8467044b0a646b694ff653bf132ecb2f138ec00dc3eac63fea1816ece3b61661921b9396eaaa1ae488d3875be21ec24bf2b3c83b37ceb056c7dc0e76e8d484baa95a1b6755e576c91976033a84cb76a0efc8cccfd0ed645790427ab8eae9daff8da68d587115806e878c1ebc6aacbfe8680f0dae681320003461571f3cfbfb99261a1df2bdfcd51ef67deafd45d6b6bfb24d85f49d702c5a7af71c587852ed8a05c3c99f8b8e4a65d6e3cf223672fa937544223760c52c6be518da498f60b8d9f94e4f030cd93bd62c90de04a9d12c7df70a22e3d064fcf7dd2ea7880d4ed75de80a90675b53b44fc6200c04295fef6db685e653f3139e6900c23261dac3810348ac9d91879d7cd568634af20c9d189cd8713c823436cd8898650c6336a5a010429e14417511b3e0302c469e407c91956f78c58c8e7f9ae33d4b4b3d5b7cc56cd0e16b4799280fef8e617bae66182bb30a71125a07d48db9a050940d84f9c0cdd031cae647a2ad69ecdcdbd1400b7d4d156b0a7075acea7a6fcbfc8d4ba16e93e35bbd50470e3c5c84070b53d81a21f9274b7931e939394dd3d5cb4c9b24f0a3d6b2ad867c5f09fc255c93bf22dfb317996f8654132ce2c07362ad8f30c987fcd62f1512cc54d3ee264602ede4186056b0fe21eafa4459b51e3c97e7ae46b91164349e2fd2d7cb06d2f5406347826472e92ae3b5f1cd16ab1f3b8617898bd93b31165bde0e9dc63677e3b7b1292fe4d3e6847f0c32d0636b99b3415ec989e9e3fc36836bf3ab4974598e16d8b1f73451457d4e90901259d23586c29d7824635a10d1de82de491536c639a772ea0421ba5f540385c478e41223c8be0669fbcf2cd4e902c797918534a33d6d1acb7837f551d299764378ea742875e0fb090e7c548cdd8385ac9c06530203be48f6f456493a85da9d5b57ee3a5127e77e4ac70497bdabb16131cb805ca63927e5005098adc19bc83330447d759246c8295d4e94062bee7e6447fb4eb9a8e9198491de752b05f4859b240a4d5a6859876648b011f16e9a6a519ce6c83e529c32ec204a808a0048130ec7acc6781c63f403548c98ada5cac25f4cdc7ebe6ca0829d0accff85bbedc914b845063b8463461fe4adca4b057f3977747d5cb70c9fe8a225180d3d39249f37a94903961d0334b75639fbcc9906ef40b7154ce36f70ea4a544272ba1a54237b0e713ac496056fb4ff4e0c3c4aec90a9f8a701a4ed860019d90833cfbf7924700d8cc5fbe8d89ac3ee9e1d4be32d62e22ee45d85626fa453a99d89ee9956df42a86adbf6f1e6048cee34de84216286cec49c2b6bf4b45395746f22dc47944d0df3bd013e2c4cc5ca89e2a1a2fd93b3e05aa65f2d3b04b523dfc37f3c7bb12b62d74c07cb1bdeed90dea3eddf7f3912402370006a7a427b60fc0ad8d20f7efe156f4c073dddfef674449b15c6523a5ce0476668315e02fa243a087d89dae4369108c32a6e56b35e4797b2eb0f6b5a25b7212afe5a45c1ca4becfc78fda1462c6771866030d7e4960ec90d40c41fd508143dc5fdcc3c359ee96c8e060aeb14554d1c7db2c26603a8c6f3f8fdc76c6a66b965d94718ad1e8be8bba8db5213f652097fe05c65d519402ea21f44776f08a556162389336a7c91737c496bf457ad83f67dc1222f28094f61bc175631cabac03b9c26189721c7d25c7067ccff96bdc6c283ee35783380cbd88649037943b1c8434bd935740ced8d3690064a7aa5ed090cac7f19ed2c998c471d9479b3fb66f1ef23d1074648103ac2960ca95972bc62569362d326d8ae31d0692252e5ce490f8acbde7868ac4d5a34a4f49df42a62b7c7afa8438bbf1216b59d7b9579ba0144e66ef2ae8e328c8736b191020e0dacf57c02ac5f4bbf2a1aea8d8701bd5912e9ec59834890f09f15184bc623287ef12d87671f22688ec72ddcdd8a41eae0b5a9c2f6bad5bb4905eecad64502d0c4fd0d3e581818ad64f1fd48e92a39e0c22d48360653e22ec46c28c2c1a2b56ba2544c6327bdb2804834b99e325b04776abf01478cd69a1d00d0985b123cb4f0aca4e02ec3925246d1a035e681b464617d08cc1adc015bb87074e6149eee36b73c3fd30c73e5fbd18a6f6e23796bec954bbdd13ead353fce58c2b4ee2a5c4d9ef9e6fa72ab33af4d65a2a33684f99b21037e9b00b9f35092360bc0424319d09ba1aeadc3051443e89016092523675cb7c660a2ea2e763d7b0232e90edabfa3716dcb0ecb4c1016149a4d11bf5864063ecf0065a748fabccced23f49c9ed28654c8082b1df160169875a01edee42973fd41cd0527a17f06176fdd557fd3d089ec4246de08d3a03c96928b37eba044667eac1fc3352484d2d24ee883b4a7f73510136544ad00821c40d44623ebeb4170c44abb5c44296380dc40276f3408b7bb3659dafcb97773600327aa72a24281d8d200e74ccf15c51c6b3847efbfb6ed9697f49c8f9fce78b01827e25fa3048980b0703267fda91cf7318882742bea7f84c1f49af392ac4615f2f296ce0073e8cda94718cba125846d7ef5afb85e39d53d09ec9a53e4250a5451fe45757d1baf5367b101b86aee50d9119965004588ef076f277528583890f7699f3704a63ec15adfee98059f1bdfcf9114627dc3ec1b3efba81775beaaa50cd39c66ede61bcf6fc74814401713ea051b7e25ce803ca0b5c4abee8c2fc93e882074c709d18680431e43cf80f25147b029abde476b53472628c30d93b1d0b475e815a36125cff7b67868a769f6d8af10a9caddb5e38028545e31e7958085bb75c3cf816315967dba039654edd46dd6613284d6695b507c69c1258d6965fca68829209e0b714067b41487a871a069e2bc46194ca9412cd2d275965e683f4f8a3e0889591124ecf0570e4e827596e3c0d1e6ed0dbd8b127284679b3e9f285eaad6566602ec0e499763026df633740c4072e8b0bd70dcc505f1b528fa2e43e26d19c10e183b69e3efdaea3ac4f58fbed4764be379dd0eac98cc220f32a1a0bc3ab1d683eabf58b626343c632ddff5e1deafdc71ccd059592a2f5378a44d96f3cbfced9473a1756bab8ee91d34f1fa5d86661596ea14b541fedc53bf8f44522e73fa3925ff858e0a80a3785b480e6baa17a5630fc038a7bd597a3b215078233931de206b77e726b4e60e227fd18778f64b05800e438cb83197a98512afe6deb5cb2012900f3608d8bd6d60a5dbbf5c5e2b7ac498ea01b1399915df8214dd73f2de29f5784d480a8006adf5534b798aff5cd0610ce6f2a315970b6f0ba467f130741204b17290b1f84f87b5e5448397017e8df45bbf9102bc0fa5b42c67d0600560426ab09495f8028be82b3fbe3e846de527dd1ce1548f793b24d8968ba6ae99a977c88502232f37ac51151796faa90eb9444cc5d685aa0c899668791ff82e5983c8ebaebc6111ab4fecb6256765b6f0713f0b362d8ee0826e1229e90e8402c4ae65cafa320623ea741e7034b1205f33acf4f77c0714d2d7e5184b346ddaa8685bb0d88dd4b12f069b28236071863c05f63b9cee5214be0df277f3a073aea3587cf4d15b070195d5424c8a9bc501445fbf343638a78e11745b6f5874d9619b4fe23aff67f5870778d8c4bcacab79da16b514561c6b4fecbd78fc8a7f9521a30675990c6d4d7068bd7e2a140a8c6f2e1a61f0ef23a3fdbba83814cb278232fc3e1eb59012c16b4f863ee3dec89f19c5b3859f8892a15b238f9ef08c0d5cdf94349a1b2650681b534f2f49ebe07dba16e6793218a9d7f18bbfb94f90d0ea37c65a7e15f9cf16f749ad3544109e9024b25dd4b2cf5f1738a8920904c6fcc7a321de0eecb507c90620b87a252aff5d71b31f6cb9c80fe15814eca70c758885d07b27f638285348de413a03e6d1b8fbf8203fd2bd9330dd562f7c09fecc90958cb2954c93a77fc4b561e403a136c1c6422cd31d630ac044fbd626feb3cf042941e07ff9a4fc72671cc5ff9fd9cf8f9ec323d88a1a11c3a7a308f7f4691db1b2214b0dd7155846412d1a4f89526106ba250dac0346fe4bc3f28836e0122bdeda65dd260b10aa053fb92c1a758601c3a3742104a157c49de50170e400df35e0b9e264fc585f2ec7122d84bcceeb3adbc5e12f504f31c2c67b87dc90567c27799d11a00d7ef49d2ef4fd969eade51003b191c4b3f517d1c73bff36bebc23f32b31cdc639c763ffa33d0887b3d52b0cfbc6ea6cb5473016a4501290c1528f47ed72507e6a25c23c556ef6d6f1628108645d7f374757be05b95cb0dae29eed34481b762a5d83651d65d53cb5751130f4f375c1b1aeca24a77f0ac135fb9bd89e4704f31b02bf4e5fa5720603d89e7e34a4574620248c99fc370a2944b062c7a48540b4e710cd7689a95a55b727a27526a0e8e8c4a666db33ef3a5cdc295e74e1c675da556e981d081a305e6fefd6d79f572bf2b949f02aaa9a65206a04d5899921c0f743c5d9de967b1a035b1143de71534cd446b6bab33425129036d785498a4aab37917c5dd2ab4282641285e22a0937ecee322ca98595626b157775c368cff15bc5cdf05c0c87d8f19ae89edf8e805e8af934de7d392a537eb2b9e6d5132dd8e72f4cc2c1b7d0ff8e8a8da2c3dd3dc79ba03dc5f8285e3bede15fb9db4a16891dc990cd2d9348990b65672204162764239c840f06c5657a455078c913c63510553af056857cc7a5528dc6bfea46c9228239a57807e57a703f143cd0f9c0798a734c64212c5752f4fb18038b753986836dc38f7a37a8c55399519824af02a245272982c2721095d7cb4e6f141cc273236969a496e6ab0e0c69a6963939de82fa1be27609c188b720e3c0cc91435514fb2aa643f30af2bfbc1a682257d61cc79a34a139f07334dc38872849602cdcba443cca66513b1340c65fea85bbff5b63bd13455c863892e5f2c827f32f67d9a97ca6eb18fe677c4e6123c36761960f63d2abb1341dbc0e9b17512f26cd75ac5b841f0ad804cef897f59493e28877011f9b561a7b6938101565c24c7a406520ef690511879eaf757a7aff043cac49a13b7edbb3e82b7ca3508e8602df7df3b52fa2278234f630f3f836a77fec5998082fb91d26b25f281a79be58c577943ffc8992cf4405b716e2e568fad3c54ae10ecd42406add0687c4cdce1470e458fff227f54fc52628545ff3b13fa80cd3c04f459d9beea3c7b9b417df443d50ab1d162f60e0b4de9197ed405d96ba078322947084ad127c2d57025ff0adc9df66c2fb6434a0eb49ebfbef16aeb3d33658fc1b30069f56ed00e2de2ae37622fa6e25b849f8435e0ebd32f513ee10275cbad7fb8cbe4accf2453f1635469fe00e66575b92821298c75f81ea3e4313127c8e68f7330dd110c39c8b7aa39254e132825e9c4a286280d3943eb58f691940fcacf5673cae4ccbfd97ef470346dfbca09bdd6c55422d24d5cbfc0cc512fc32109c27de2423afbd21915226212f75019c16a4c7c021f166ca8e5af8e30d69e900e8309e0eeab1701e301901a1ccb80cd2934841b8a4068c1c715dae188cf87bdc7ac65d4f10b5e4ae2de7990783e96187d87baf5ae4f5b082026145ddac66159afe39d452b7d7a2768edf72eccf0a568f8aaba74051c5dcefb65e8800fb6940ca8ff781e57a2d640544e12363511a70e105e946c8f15964f833dbb6d0900f63b183a5e65a61d1e2ff1397636cb4ad87ef5cd0c372d3a57dffeae178434ef964af9ddd9f71f1fb1864312d1d8530ab6710b5f77056a646892c5e5ca76a146404a65e7786b6b493996a7dc44951941fe9a7600ffc721fdd293a7c36412e88c4688141ec31ebc182332d60c3cfc3194569489fed7934752204666c2c60f6e11e058db0175803db81585b4b94eeb7c8da254e2f866d35b98dfe468a3bb2d5d0ce1b2f450034315c58491d5dfd3baa7af7531d58f7818d081f8d48d31a48f03405788d9cf83c55b6b1352e3fc80ee302a52c96066ff2055801d2d35c7d5d6fac44b4b3b1a5c5a4cfebe18a322be7256d96cf5fd3d63949cf633bcbbbde393b46c14bb282721452f07b02582dca8f143364f354ceb90330c5e7f5c084a27e40cdbf9626c11572b894e312882a66e04fc634f81c39aea4f0c04cd242625cbf395647f22dfb47833c54c67da254f8635ac8055e362e0e52edf31f306221d4ef2f67dbcafb7534a40e94f80932b3dd289e701b5cc9e1b8dba9f693acb45fb384b4028ae36dd8c1c2c54acf0ba5ca5f2806d40eb","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
