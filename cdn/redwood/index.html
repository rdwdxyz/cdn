<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"0c5b2dcbe19e3626662e88d7228a44f5541a22a0c45d81efdb81047e63fefeb72a08b816c2bf83e5c790bcb493dcba6183afcdbfd80973549b9ab1ddf4f4f0236c544e0a624c28b20bed7cf4bd94aeac00ec6b196dd6b74802164b7660936ae7d2e5618172559bab0a295b1dee3bddde209013fb99662e82ba7829c34e0edc21d70bf9c9387b83b71f900b92ff1db4f45f62faf68d5c84a2623b3073ed4ad8278a2f5cad77ccf022008d86057379fb897bd0472d4478035a40c83d1b9774e26778ef237f1076937ca21763853137afd74f49d6cbc5a39e85da78a707edcdaa63082723f646e6aa56825a6123ea984b30bb7cca11540b19f16a2f05740ab8c3807ee0194486f125816ba0e4a1f0c9c6418dc2dab1bd067bde124ab639d6846e458747cc8a3c0620ffa3f6276cd7eeb8e1afa5370708fdfa0f0aa5ef15fbd18c6fe96acd41c0481a39498216c6a0f9b287bfc199cce3f29e82462a5233a00a7828171908a07735e794caefbf5d14312064140dc41f4073548df672f77144229c7608305e10d7c55efb13dfc9c0e49b0990f871d75b1b531b82688a0204bdb1419172f911488548e546b137eac09133ec97e27e0c92bef5aad1739c22a2434a315db2c0347c3f6eabbdd6ebd6f81f94cd6f53c216a309f48111722fee8175f66177d755e0c90aaca10223236ee4a46dc72148f6fce9e4529773c25fa2bc78f4a8a867bf1b1cd6754b5e3a4c09b5534eec8838ddb8b90672fdf79983a188384868afdea269a34596eea76e1994c7aad991d8a394c74d168b8ca0421666af7b362a15a92565f0efd46ab8d3d95e22f9c944f843bd05d1c8532f32535d4c35a01b5a3b9925e98cca94c089058878d56cd446aac8c3cdb73d5caa3f40c0378722494e93fb146abc543af691235c0c721414d448c8048f824c39e351c1c6bdd805cb725558831243476aeebe81b28385fa49fe9cee7461a60cfea92cad310a74ce985372e5fe62e42e95292824c05b5d24845123143449f0a8dbb09b6305e55ccdc9074c355a1231328d46e1375624ef7ebbae439e87a9104f0c89155c995764e24c54fe83187ebd5df3fa1855864f537dd631abf27cff406d7650a538e1dc2f86463641e605743654266d358cde7bacb37f4550d1eeb0fef824e577845cebb3e5256a501c67e1c449fc1c7db769655f3a76e251e1aa4df1d29ff865ff4dff78fb5ce1563ba43f458470f18a1e93443dffcb8139d57794e6e196b80ea597ba024e40b30e9e792e0a23b8a88157f4ef8dc1b4812350ea1c76daaa36f4145e58649635b228b62ac2379fa4b5804e6adf3e775626b8e0f5709c4a5dcdcdaef402287e60a621bd79a4cd76d54ada9c6dac8644c145ad8a2f8f7cb3181cd70c664c9de8d21b91bd5e0b60d397e9ca6036ffa4ddfb8bd5fb4434c7c0716abcd2fcc0c02c88bec8872cda284ae726ab924443ff657422b82969e20518c533c35f6c85649164666f23f397bc1aa137f7b1015d49df2b76442a615ef4565dce336bfd6a167e7419c6b4db0cdb354583c63dbd30ed5f2023ad86a0f1842bcf325068c79f856d1051f1f9abab2cb33285967abbaab0b8835fb07b64d55e1273b071bca6e9081d4894f3cbdc4a082245284b8e7ff7dba196c12dbb80086bd0de63a011da9c82773027061176e73e59a284f0e2f887cfaa79041ddc666ccfbb6a58da75934f91991e9bc59b66a3834261911c2ff194ffd58607962966643726ed73736dcf4b9ef5f0d87856cf9ab92901fe2ba916750feb0695c2b0d181841971f6d9938c433ffe0ed2fb4688b7221f9bc6b02d2c7ab5693c23a4798f4d72abc934338a655857ce1602ab08d081b02ab59db6b180b3e1b422d1139640f1fb0f9695d1e7007423ec37b44ecbd64acc8eb0836ed411899fa329df0e009599ae66260a63ab56f26d992d0a65cb3b4f34f233c2bb4b7c03081c6224a20f76d9539bf7c3fad7093422c065a9cae09896cb2a68bf79322ae89c63d0ffb7ae4891c426afa10d4aab9bbc2c29e19dd475d98331a66fb6637013067c941a17cdd64fe82c1edb043ecd976375014d7d9a3b20ddf35c90941b6c658f4e3b05f3f7758bce4f8abec692676b5e778132d35b920db2a5bfc52ce085062f980547294d0b6ce1874a2dba3766812811cc2f02564e266cb11f78be47390920934ff04899bbe876ec291c817331df7706d9cbe969378b6aaf208c311c0eadb5d680baea72a71f9fff0943bf7640d5d0a2c9889351576b24a6b604e99b3de189521e7dff0a1338134d6f4f0df4904c89d6275e15ba1ab2485c77a12965254ab43014c049d589289304c7aefaff08ea8f6750c05c86828b6f80da6fa1ce659059da9d5807865f22401f4f0ec3e8e6d05da63420af489a1eefb1af70c0745fd0111fb6276a1c17b08a6bc8c5c8b9c5edce072f9619a6c033c83018299d6d1d6450593506689dfcec984ae21d459a9871baa94f1a0cdc93df80afa97b966316503d16d90ffc7ad03f5d04b283454e88e54b6ec9d960a7629be0c099f2638c39c35c9f91ed5692c2a5cfb7007b0b7f2b118c4fff939e876249ab877929e754b6f1a3a88033f553c53a9499c9f01cf01c68956619f1f8ac2a69d35c983dea302ac70ec94fc907cf38a9689e46f63638fcf24b8ef32275b6393eb771ac9e9ec02dc0e27d72097017c31100c02cb1aaf87b138d266f3bec3e9ac1e609fe33845dc845227b087cd3e185861b95478138d644838e853b06cef0b45b6f6c93e30083fbdafeecc920353cb1a4df2e802cc05398e2c402ffcf1326e53bee3fe2f093cf76f87d579610fb07555b68ac6b9b9fc53e83de15e034fb3d277b363e95fbd49129a0d49fe1db55c7ab0e380989cdbadbdf86b6051b3641ad07b7c0a46d4e3f8e583555d082ac26d8d3a3ae1d6e3792206cffd914aa2b5db7bc9573704fdb965080e384ce400f42d3f980f9d098dd754ba443b43894e9177825da40f1a1000863b81cfd82f7d54460ff19d8b9c27531578a8780741b2e400974da46f1f9e3060f3352acd6d9ac2851c5f1180d63a13f7e49abd2743fdee0b91a18c70b110da8c97cf6435933fef639056607ac3b19632ed87fbca579114bf7794d3fe8ee139eb56ba8d50646ec9fc2173e3934f1fdcb2f172fd3ad3bc0e2622dee2269993c3b4f9f868a550f414d62ec4553747111182276154cefcc257ec4ee30e9cbb5a4336ebef27fef76ede8c23a612477a40380e723648ec6ffa4a2ce81d23856dd0130baaffcda25650048f30e3648afa21c25aa5774ff6af2ef62dc6289c84993c8d9611d5cb9addb0553a45efd98998539df2e66cbaada7fa27dde46a03a534de243d6822e8b0abb8d2e0f0468be91d7d4ff6c84f72e44a71fb6b9c2991de5089c23087574bd93c90138b4a9800cb59e261f36f0dd60c3466b2cf2171c2494549cd927edd1fa8e3c9a39d6b52873814ae7308d996b5fc114d56154cf46e070433151062f92f3ec01123611c2552b535cfe30c8c07540e5a0dc1960174f4a144258892f2117e951fdf528a449ac5852bdbb2d0e50a7564af7a60aef19da4fe9f18d122ed56aa9dc1da1373c5a9e4de3f0ddb8956ad5f4d77d6c497510273bd50acc227fed47bf6182520edf4c58795592da5e409b7213c55722926570b481e909eba0a969afac810b5696450e1bd9885f086ffa667de1c73321b6a6c1c77c9c03a126d436add5b0c9ab76c0415eb3e705179f61afc67bbee14db0f1bde9681c0fd93d12608835cdc22741cfa9ed28432630abdaae9ca569b09fc92e807d9f4464289d656b81fe2817c09b0ff0d3c8ea983950f05fa1276240c9628ace2607f8edd866ad3b8e35cca633a37e1abe682c6d181016017813aece1199c2b5dd5bf8409f890562b42d62592f5d5b21395aa9567b78ae8c4542ff33079f2a136afdd18fadfd1efc78748ea2df3eebb58aad4a5304895e79dc018797ea022a08e38cda2c69ef0ccb59e730ff40ae64a572d4bff29b44388be11ab7adc5f2f01102fee776e4d3919cbbdd4cdd7f444764ae7f0bffd9eca57145b313f73cc757c18e342d12f6dcd226e1982d8ca0f166ab5ab34ee59dc332ca10f1cfc9c8efb86a3f86ea2aa35a9521ae607add414c705dab60cd461fef08457c16fd9317a102fb478ddff1651ab3dfb8850bf7f21aef5279d3bbe71404949887b8328000e4bc973ab4abe96c7371734e6305367d054b84820fe3d7daf8a239d925edd79016b94d31a373de2ca8ff723d38c46e55d2ed6a1afe2a72840367a0462bd67dd952517f94da3b5eb723dbfd64d62936a8c40f18f174492f8cc90a9d479fd213e1f2ba78de00d943ec5c5c8c18deecf0b972aae15db22f86ec894af7403c52634fa1f281796e9006ae807f51637e4d357080473d84e3d7bec5e7690f4a719a45be99d73dcaf1cdfbc3cd6f3eb3dd4a35cd87bff2e5baa771ea8ec196250c757fa366c7a2d4c405f461939071d886a6789221701f07e07b5a02887e752619996e2860f381c4d8d37636493976b8c23a899941b9d4c1b7ae3ea273b7b10c8e5fa4a615e9d5e5f7ee7fc7cef7ea169da86fcf3582cd1e48338f6d609acf23b7a18e95cfcda08adaa47602eca09d000c757e691832c16deeec3102adcd58d2a4648ed2b328b193b7d89f46eb781bee671b62650f3007c8769cdecbaba11e3ae0fe60c6b9440bdfbb921ae14aaeac7af31167221b1a87e3a404aa02f6a299c5b6ca077092fa4e482ecee7a72586b642846d860d11fe9920fc2e4a4f982f438a0b90690ac9868e14fb51bd5b4fddf1fa27deeec93ee54edd779865667aad7d94e747eb71fad69a485f32bd90f4a56d266ea40b0def54b59f7fb389e5a8ffc987d5c596ee08389fba2a8148be24914dd56e731ab7b747adf95da7815a0e9c96c8882b61699204336128162422b3e9523e1a06024da7d7f8ae3fe48a220a47b9916ac046ab6c8c8b05a5cb9cd198e33a755349ab9a9f245a6afc2287c47476f4e9ed7b91194462d53bb06b5d601470621a47c2aa26650c0b2c7a10f62353051a82541208f8129fcf3c20630f8cb8a259bd193993d1ee958688a65eaf57242a8c436c47ff3bff5645136e77da349a1d3d7b996694a15e9ed7caf1e92bb5f266e4b2b0cb974c3c501523e0f50fe406b29bfba2e5d85b983b294a0680e1d4f9939e1d09f898c23989b33ed75050b3ab9bee35fb6ec2dd04e6874bf008cf805fff414cf5495b97390276e5f1c9692438f695c4417ed4694bcc054f927d626b3585f39cf6e48bc1bf6c29707928907b4dbbb7cfd0243829eb1908c0b2a444dc4b59850771eec8d63e6163d9505c3e99401e84b4feaf310a1ec2ff0a4441d3903c5055c84d564057b75ea68276c9cbb9f567d6b963050fec7a4d30e23e766321082b79b01485a8dff68fa2e59d47c7fb4b177a85264607551eb640ca07a9db7517793b498cb851774ff5ca97c7127b334be08a660c0c664b0e384458c81f12e94c12c5b60605a8f866c0a27baf20b97372135bd7926f5e0e6ce42dd90d9fad6f3aeec9d389b42d7cb09894bb8277050d1a20d38a86d387d912f468bb10b935312e1e8b20c135b9e6f60002874df224581055b492e194ae93ae2a29445be7b681651f745e2f284b4915026c86501a5f56af71083837198890ac32e3913d763ce1cb60a101ae00ca02b83ecd251e1fb6b4d8712c75edeb644d3bf1cbc8906c850303430b4edacf19b79aa5f6debeac3251682b2c318934a69e15f3439451a1110584566bc3990d3b9a192ebeb2d4a3148eb511145bce0493e3b7894bea481c595d43ea4fecdfc362e8550cbe75eb1b42d3ae994c3ddfe138125aa3f576a7867db90fb5fe85e4720e5a512e9274b21a220e50ad89f1b3736bebf5d16fde4498dcc8254f806d2df22e6de00600ce32c07180443d06365034911e2f98106215b157c781bb24b9b8f70a0fcd5f16d202d27c77990d70b7b3573d28dc70ac1e3b557d3afe1ad2c7a05bc9b93463d23601d20615439bc0eee670090656f5de0dd5ebe170866ac81f68a9279aaa174af1ee9e940e05b7e063272132c59ee2d14f00a42b5bebdf2741ebe27e98f435ff251dcd83d4d7720cfb817291ce5926022a93c227d72f25ac7f3e8b0a3df0dd695a5c4b60d9100254d20b3ff1b85bc6900d5cc5a2cff1bc5f0eca8aab7082e14d967eab13acb3d39c07c9c6739f6ee48e379bcfffd1fbcb23cb4bfb877a5da682ca5cf16c46c64d23e3da64b3fb8b0a7df99fe676128cc1b7194d5f5c8b31c8e5c7bd9d7c9aaf30c872301ea7de0d85df0515dc5ec851be48fd2a4503a9a116b84e2860803f435356dd2b54cf19d6c7b376c976cd14e70532413460c2cdd0319e43ddbdb7bfbb937b67ee59e49544fcad6a176444caf912acecc5f2f9f6b5202117822f7e98d5444188c344dbaa178f8c22a142d470b7fa04b08e4a77315440a6ff2c827a2f4de225668a375b7388678eb75ce62d25cd1e462d61d589cb1688d82284b79884cfdd0f7261dd0a791b742ebbe6ddcb7fd37a78072c7ae5b9d5577e991d3ced6773d438f2596b2fc43d709de74af4342458ed9d1ad89a75a31df2a4cacb931b852a9bcc04521bf0d5a66316222aec3be18a2ffec946d3d400b05cb4bd5fa717e5f3fab68b0e1b16e772ff911ffbdc3703bb47854f5ea1c72f9e1f3801b5794a4ab3128651f411aea33492f2e7431f2f54d13a4e03476855dc603b61ac42f8125e89a169e885fb9e799643775988098f3fb66ca6b458f69e8777041bbdd1c4626585765d63949318edec9f86089ec5ed36875cd3d561c895b00d90c767f8804f832c6f31aaca3142b1371ab625cb37d1c1445f2f60374a2978bb3aeadb82bad2f8d15ab0328239d5d7af9a4549e59d9e10b977db318898c85ab0c79dba3d27f578ba9e47527c989628e367e50740f8bc4db4a71acb3ea119b745624942af5a3a26b6d77862a7f6bd20fbaa002de174e45a3f912994940d6464918d3982d4938488337f7654c75ca0cd8f692577e392fd2edb5225b62cd56f1bf71d34b83d2f58f7aa4becbd1de13d8aa686e0f84b48383cd891e49909aea5315168ac252b5df6e92ef9585b1cfa70d3effcd3d3f273834b8d432693cc4a4902d718afceeb77574d612bf46fbf4bb0179ea39ac6218a9da3e0878f6ec84ef31f802c01298af7b112c6e2e85f42604970e1ae992d6b661826588826c643f4866cc57f7766c07b41d05536596dadd3bea73c01dcd83fb0bf6527079aeb1f250c4966401e650c2a928285eff76bd727491e52e317d868e570de77a1f6788f47c24784eaead71c987ba51b3e168e2684301b64942b1a3c779bfe5ffffe4d0853cb548b3620b10d3d267c491d3efc440d5021bc6fc8c6455805df17e519add8c1a70c6a33d2f10722a8fabbd008662dfe29c2cdd1581697676e687bb22adcc16925a42b3759d11bdda35e0078adec55bcfbc9979e361e537d4049561d733f66538d510af838e1c66a14e740e6d8b94a0dff755fb8b395b645f39d3d75b61c0798d7e1e937699b454f389d6f27c6af36ca68d64443c89afd832e6ef447ad985baa11a40739747a8a45ecb40d3c0e1d727d68ca239b601b53cb96b639465b8988ebdd1f46a4a342a780d668fe6774bccb2a979b9e47a5c8ebd5eea8cb7dd2b868015ed6e45aa99cda9b2e808327957bc70c90f903bbb3423686ae436fb719430644cc3e0df4cfdc4ebf996186adbc941c8ef5da1159fb589985e5058efe56796afa3a9b3beb7aa4a30b4de08888bcc6eae8450f55349878ab150909acdfb349c9d394a5548e8f1b94cf03adc6788b55ee5367825c8d61103e26e3bfa9cc10beaa348bbd61de65be26e2741aaa0897efe5b1ef3df0c79f1d1fb550cb5907e2306f98f9467d5fa300efc2c99695ca695fb7e6485fb776467bdd807e04e3df6355f65d81a109a4d61a667ac4810c746d054bdcc2c35098807feaa6a967b3e8d618954feaf0534621d18e147cad12f8344aeb7e505d6499719288b1a0a5d96ea8cb729841da50b0a95c77972562b817579eb890a3f6babee1e6f5ab53e02338118325358858625fdae44133339e79703048faf0ecb29eba787851a8ebc5e8f1522c59ee2b55113f0c557600f334044cd088e3a0affef6b123ed7f6ac9a617260a547912b0baa792e6ad4a9e55d4b46224e97f13268336598cb3cdd2ae20afe86bcc6986a19d1180d0474967a10f580700a2fb9b8e8dfc1a7621a351902f209389c0274a63555ffd8af15c92e4fb9f4dce41cc85e52184c22ae203fe1281ef75219efebdbb240fabd4855361be57eee2fb98f214e7dbad6f094c236c4fbd55e4324f094a6009d16af931d8b9a427c01e7c52c32515ff61887e28dcb99f54bf1bb10a4a1af0a5ce4c87857764b85833230ac61d581b2fa448387a4ab0e5f9e2ef9d7505091f504df614464d58cdc852d4761add517cde2273afc9ee1044ba7aac588b015c287411a3153d788c8d46375343f98b06516e6f8855ac421f6ac7b08af9e47e9f3c7a47417cc7a231066594cb295d2861bd4eb0842efc7b33b9911834e8a263913a3ed51b3691570a92ec00dce99fca16e2cdd4c355d014c2c2082968fcc17fc3aff1dc989918b4daca22738358de2f1cccb90e2ec70281a0f9f5105c43bb851d0b590de35b64d015fd68a1ff18fbfa354044b246c26300ed7374b38a700a264c890711a3cc0481cdf55a5d00cbeab5eec3504ab18e05c320f5c47e6fc96c8509a6185267caab3f352e1df2d20eef8d33f0ba5e3ea451c8a1f636e6d608d851fefccc319aed45b2575803cdf856fe32a454ea29af6fddb3f02a79417da7719e5970f963b307cd6e6cbaa6e1679d693d7ddafb43413ff6f0cd7c0262d6503a34e32fe4bb7028912a540a3fe83737e18ffab3971cf9a3cacdd106f9d8120d83790dc6a298d9ace4f09171ad6d268b9a66c7b7d97d194d6bdeebd05fb54571a431e843b3f66b202e22f7d4f138df2b302129c628105c20e0088fbc2b2665043634f6f01bff826bce7930af7553485ea3417b11dd98773742beedcedc31e6697fbd6f9f888006520e66d8b3fee3ca75cc54a1b1f2c47380e8b82c68916c16ada6dd8c3264ce3d57c9813ebc09162625a09db549899533b3f41ac32cfcceb568f50cebd06754280ca3dcf23a8b52fd44ebc679e718667bfdb1058c9f023b2a8f47f4030ea3e8d4767e86a2c681d7a31c487e5f924ac22e3532c4f786bee491a93245ff27b90b6ae5c8a8d79752d17398df3e25b7e84446cd386ced19b25a95886ec90675eb437eda757d8e70fb8bf64362ca3bf94c62d39e94584149e504dfd9fae2614404ae39bc79fde79a1b84f5f3a09ebdac32fa27a2cd557971c7d7ad156abd4714012719e10ff916cd4d7218a46329f76d8d31a74b8ba8eabf4b928c9709fbdfd52e9bc59d98b5e5e005bc79428af46d66df56fd9dbad358c72597347c10beb14d18a11557aa146af58bdc0de66266b6fd3118082e8c1acb2ddc754ca8d80ec51449caf448175297887ef2bf4cc7132ad6da862c75abfd8753ccc8ad938c46027dbc76bf83a4b87b782dbab65ab3498296dd2bfeb4ac3e4aad8a1d66e7b707d3a55a2ed2293e81354cb9285d4e73345c79f74181ee6a101ee5c754ea66e8c339ee25173c78901ef20b561b990d833e18fdd9cd4c44ad325074edd1245c8193a1ca7ac50596c1ba79c640a600f60efd4cf1f37c8df167829b27f079e0639a708379ae0427bd6d54d783d056ad8687e3e041e391e4aebf912a6ba5129794f2dd7dcde2ca82da2676e5ae974d80b88e00318313333f43b6023973e8f1f4587b03590a653779b6efeea871c738097f970fc91e0aebdbfca5bd111e35ecfe4c2953cd803f77b3d5255ac162398805280ae405057ee55b131292683a1235e1aa8bfa853d2ea9692fd17f8100fd8332a0ef31881fb7903c78ea512294ba3a49eec700100d26a3bf87c65674e7bf646fd432a6383e289679da91f0f50b2ebde04f71e6d8ca1a7358c52e005745b385cd9d59223335767fd1283f3293b58344541ee8054eee69b2fa3a7b30ecc9830053d954416cdb025bec5460390f6448a1a18f47720f2f0f8ae6df750aefde928bfa8629933105d7d75664416457ce92b26fac0cd47aec5ac0f57a9f775fd89d56b1f78abd4bd63d66a80fce8c1f6a299855e6d23d5d8a30a7f20e5a4de3487af8e86d768cc9dee518e64cc985fc20054fbfd01b3d7f08c074a473a6ab5e3056979810cd7df35e78f33b64e9913230ea4752ca28d8aaa33715a8356891455b2a6de18688578c02a064339aec7a0c9d9f1b98fa7f41c933fa9ee902e5ac2d8f51ec15e1a06a3fb1830f68d5238c2533f7888418a910fcc234076834b170a9c331439d111c5747f408a36ba1daa0c4f8440ec36ad533aa2a5bfe34bf0c625ea380c311d868b271638c94b7ef201825bc49a63a8a2b927b3699effee6ac44dcd95c8417487fea2397922af1919492bbdca2a844bf4db8cc3b026f9bae2120d56fa6e7e01ab72b191c4ba8b5f6ecb57e8004d33bb4074af86b916198f49e3a277c7964383c85836892994ee9f60ec4d00957c6b53d2ea45715857f62795c59b05cc7a696484717d4cd1cd5546264e6815e091f0dae50b7d2932d1913990900fc91afa439c63d1343c908020a3a2628e7c4bd65c1e1e77cc6d95154a1525f7d758abf79278830233ae67fd7f00f53b9c438b71156a05d60e210e6576afe7c1bfb7daa1e9bc085f068d16e06ea13a1ce4b8f789c0bed0f91024ddc945cb2a4a9187e515eb82b115003483308e9d0ddc761b7e9b0348f5c1476cc40b614300c828a06930df54f638f1170dd2f0dcd484fa437b1eb34ef0bd03386d3e991d76c1c5b72ecb9d127fce0bbfded63d53f842bbe501910450ad8db3c5c95704de21134b7c1707fe209f2146e0526ab5f30e381337ebffdbda69d4e20757f716ccbbd60356e3389fe9f1e7543800bb1c6880dac1b933416362a7c219b6739954fc4e2edd5b6f7b6b8c8ab30d6ff5dbaf8cb222615eff80c417cad0468bafd412930be66d3f7e33674b0b0a622a2d9a83b94083553800ee4a3058045fba9e3e9f2494379c4a280ef85091639db80517ff6018088b344d7c54982b1fb379a5ca2e76c294d1245042902198cd00c95018e5511920a12aa69f6970a2172cf359bb13d61ba1853c529c0ab5f241473c4258126487f953a89e582a9bcdd5c7e9ca09a44b757ac43d3a70d12e7d27106cc7ff18d7fe36af871501c6ff9ac2f4ca91e1841306f48bf2f7c3e07fae49f907ba26badaeb88013ffb2a644bc2c93fa3a28811b6579dea9a2743bcc66cbb8fd9972cd985831e3c52a512a032ececbb39e2d529f44583e3d08329d5dccd7f2df2d8e3be9b0e24770c979ea37dd22d964cbd2c65498218d9e90d974fcb90f47d5e7cac639a2527df5a1743d2e8f5fd89010af0461a6715b0b8313c2dd81e95cd62fdd56675fb51f1042a301f43b700f63b169ff748103232c9b54c2b091612c704beb4b5ea3d0b82c90c264b1b8c0c3c2392836b1780c8b9ef54b9a6bc2cd08a758729e905acc533d95234b6e7fdad543251e4359527ff3ca6461216f86ae2e3f9e9a3aa9a2d3e1c866a04d5f64b29053b69b45f007837440c273c952620b72dece6434a9916b1fa9bb5a193c1ee031eb34bdccb7f31828da914af88d0161735ea0e0a764201c5a8ba95b8a29ce4ff5f27dad9ae5d68efd417aed606849242ff36f48d84687deb1b21f3836b29d997f11fbe3f6173c140a66607d329a0caad37b982a6a92f3caf6e9b5c46ea769e5c6a8e1d5be65a646329e37d250bc0f52ec642e7c4b208447bc4d2d1534a139c3bf63bbed06461b5063e132cdf5e07d78b4ee0586565e5e68eb01cb574ad1a3a0d790e301dfdd0c30288fd940889edae83e92e4dc0a8a01ec0e158199d1f30ced80b47eb088ae4d2bbd7b117139ba27690be4b87e3f0e99ae416e9996f558f5f763d7f95d5d70a9c28c4b82c2a1ad65e3e912333c45e7ea536ab235b5057c464f980d50e5beaae9ae88d338551b43b48ffcbddbc38a37e35b8f1c93415fcbd7014bfdd0c94def8f8ccb79f7495ee67d8e64417ae484216a2b806763081c9b10cd4ef76e68739430b8855337bd65f372dc787f629e2f9b6e19559c613ceeea34c856d37a5c9ae382734017bf6a00fb780b5f4a676bdebb7df4bfbf0b4a821ae7458fd55c1567215b004014d6634427017c5fa41530ca3dc8d05cf72493ef7b3ac37728fc223011a30882ea1b0766ee4793a9485d2898aeaf52a905dc7ab967ea129d24d7260f52fdc4610d2e41af12f2d1ffde66fdea75fbc40cb282ebe11a5471c46db3c05c845639f1531bab697a11ec20d1a557a04bc188128601fdf21174d01aa9a31e734751b6a4c1afca234890963cc6115c40e3fbbb375cbbde549e2f6006d9d99952f8b2d2542130b5dbb65fbc6cdfe18a98d62c2a75e7d72a8d85919a2e954388328480778b7490030bd9e4cdd3adbcaf1755d3112677c28c78a3564b5bb0cbcd7c9cd506492be1908562dd02d836ae08db6e44fdecd45beb3ef1f25ad7c1058c9e0b46bfa425843ee83c5eb7fdd0fff56ceef0f30c7cf2cc51ffc04b2a4eb147c33d62d4c5839c74f21cf4d002e3c9b9d1aaf2fe10c552fc46b05aa8afbf84d6e66c0cf1103fe34cb1743d8ba5599920442b5ef6a46e357811604009fee274ed03167a690559a668ad8a184f7abcb1a56b2b911b0f76062e9233a18644a69dfb879809215437175c77a4374d8a6f2939bbbeb72b351e1284dd49ed87c22ba542c38ac64b30e16cf423d737ef3698a8bcf6761375c84f3c71c2d8097509c3758604f3b171ce4deab3e483cc89958a05164f16b042fe5311a41648954397f48a5bbdcefe136770bbd86a20a86b3b6ea12b221a436b994dcf2bb28c7ffd1da7cdac029ad82161a7f4f91fb7b8ef1e26bdd5cd9686a076853aaf96dcf4a4d6df55978186c386c9aa299d1abe7bc69b303cc325621b1140ff32f7681950ed7fb4c840f2e03c4902ef06cf5f03b6d570f33d8212ec932876c8c964e4beb45f2a4596fb2cb993cc74fd41e1792f890ede6fbfd9e889da639994281d1a8a8a892735a0dcf556aed7c79a29c7f52a8444d901abf6a99fe9a708a0938cac313ebe991a3fc6258f0ab0c180cc6e190d0fda2b50b2905dcea0681dde1dde32d663d3b51505df722958f636e7ffed335caafa1708ade94a2187af159e227fdb403f05f6227893485a4f8e787ea569fddb216a7857fb20da09459c9a28c79dfc3d002f46421ea942731629a8ede0e9cea843d7798ba75b7fc30e5e830efeac8f8c5ce9242cb7463515b4bd934df99d79d7cf5075d2627ebe0680deaa751ece6dc908d33ed8d1025d0be68d7343a9589a4d291d4a299c919cc7b1c6cff42ce3c8b27d8599f85c44faa2fe084bca5b3558b60a402e8f86eebb8904ae832ec4079c6dbefadbd86548abc37d4d923a2b44c1fd94fd01d35cc3469a9ecc6a6bee26c4a3600b2ee04d03952b609f5fe14b070fc826964a097efe4f64ee3d2e662a3e18d766e8de17f06c6d4f4e97687909ccf7e4ce4470fbbac3fcdfd083769d1b8212bff450c7fe4c89812401909f6dd748f85614f4e3184312dd88de913072227bd64770c0ac7a124fddc0283fbde00f6f64508446040c0a6af4f73b3b60b3324e52449502aeb9d6040c92787762dac908571dba36c2216a5df184df2831cad75276603544e63ee5c4481cb7046e689fda6e464d1a53450cef9f56bc7d6ac7f5f75ab6ca9e8fb933ba6378ed18077426b425c82fbdc8d82eb4df32d3e2447b584d66f02729276782fdda951a4786f1afc573cfbfd1b03eee84e5338ac51fb2fb38491b6a634117c263935a7bd4b1ef6e73d5201f4fc8910caed907d559d1db07055d2b518efcdba6926c97714ce443ab6e983a7fe4a10961403a2ebc5b2020ffe8ac8f8c06c60a7b85433e364933488be94dadbcb5ee2be40f86228991f5a22e86a65ab5a06f50d0f8f3d7e33ddba199361b4dbb40b02fe7ff87aa83f6d812e7ba1de6064d43f6e0ac248baa02e494f5e2ca36fb9076c8adc41629989308e269fb299df9911b902d5cf5f1d0fa2a8ea7591ac43009c1a8a16d7c2a61d5264627fd9f8c10aa4b0d830c1b8602fc2972c6057ccab7f1feb47bcfd0c9425a0237556d387bf07cb809521b2be972c26392e4faf5b53d94612c3f7120ae1a24700d0eac94bc3e5bc5fcac89ed30a7427b1e52c3509d7ab29ad7d175ed6b75809e2d39fd7786e53cbd82b5a2a1aa5e01519801298717c9fce9276b75d6af01675b295e321ffd432c6f74f6c017d87b124f61df6711edd75f7f7426afc174cfbe3750709e2151be1a3f632efe3a87efa5e41fee3fe3b8626dadf594e2888d52c3ff4f02a19ac7ecd797ee3765907bdf812d6a6c696e66be3d907cf89f1f77690a6db3cf3079eda3736bfda2897aae3492ca66eb6c01c7d3a93960f76b70043508512a3790f95fb6d3b5260f52e15afbad916e9420b142d7c22739ffefab6517ef5b31ff4c113ac86e57472d2539641e43281282c9cad2d0ebfb7706be40f1708d1a4658931204be97bc2cce6181003442d0bad5b7b0b7c9acd5ec9b644ec3a52335fc6a05601b87bdd7bce24a568b86d30d636c61df5552a4cea7dfe255ed2006de8c12a0ac15c0ef14b986cb96f02c15f2c065ed31f835423397037fd7ed9c775871b2b7f2ed4e4333a0c44081d3e91a29de7b18f02369242c7d0be3ebf3fb9c321c4f99c57136860bf66d23922f57c6b5461cf34880748f5fcc6474154212ec33ce66d2493b85177437b2985e9dae3ec61be343c3f48ed51daba4cb9fe48728eb3a02429dda0e3e7529b1712d088874f2097ab44017ef70f9e77278ceb78d54fc751d53f0ae775f557266d779f32db86f4a6315076544f7f0e5947480a94f44701fd8c33aa1145c4f4a53010ada64f5315bbaaaa1eab6b278c2d463f459476cba8d9d1cab61486068884ad3b8dd6403bf661820bc65a3c6ccf127067244feeb7b2fe1939ecff177941173ec259813cf1708b4449ee84e1367d100fa5dd4aefc46807c3f31efb48240519a7d94ba74de1f94a0a5d3841d9440817933a88fd7f2415836c9211a5269ddd50838a48221afa483852672b2912817369c5eca4f8052d284a80fbce0bc031417a2c974bd130daea8aebb7e37f0469d4ade38bb8b4a3fa1cc93aac1afed59df626d9943302e44e5ce2b7381653a971eab2a7b221580229e38db8af3e8224f4354cf298bc403bd460f274668126539ea02b9f1322704c017e52cc14e0f82324d01c79afa659a3cccd91e70651aa36585c9d97831972161ee399bfb1c7a78669c25ed6b91528f514f04f6f723cd16b750693d06d4bbae2737f2202891c190c7a186b14c3896da01fc782e676c56d3c7dfaf7fe2dd29eef34b2e74e7b033ef879af96e046d24abcd1fa5b305131b5f26e9e5412eb43f8da56706c5fd267491e3f6410c3d6e3140a44c2dfe7273036f62e4964caeb58168466c8a834283343e63773cd2822d03de738ccc20ac70f87275b283402ea27c6f58a6fb27e7a4be2b7986524c02c182dfa1d3be86755134b1b591a1d7846a6b7b09b59f4681117c90b106b7d17b9d010832a3098cb70337a548c44b700f4bddec1e794c4a261555c16eaa310ed2be83c7590a51c55702fea6724ab30a76d5ad35d3eaf16b2189f8450eb6955a955101741d185e258b54b71a688451f05d88db956506b37df387d162c3b4d002d853da5c1dccbab950b1d16364d388dee3a298d63465ca1ae20deffdb133a6ae4f27ed5786f056c5c1234f00a4a94c1f23197033f22a6fe10d227b913ae27a5c1b26e9b39a5ef127e1b40480c29481f53d9899ed660ba41b2fabecf351df2c481d3894f8cdd81db663145afddd5a5be1cdd3946a1ff807b5912711a0563364cb131d33d82915a4b151b44ddb921e84fd3cb8176eb1006f9cb250e28a2cf2d263f7dc7b1c341358058d3954e6eba0294240da2e73ca3a4510a03343a79788622b2a5ad5660a7daacc8482c22f0fdae44f4228652043f26b86fb02529aaa16763f16e6a3523ca60f791958cddc807cdd0720b0e4a9f971a430a958dd437a0946957c3a5ce4067e5b4444b540289e71512a9d6bfa01455238875d8a38de286d3e56c4711c1a3d508c5777f9420a35746b7bc1ffb453a0769a3e720418c8e1efd2c6fdb786abe42947f23695bac361cda3aa5dd8c7c7f039ab82b98fee68c8b8a860684defb0b055bbe26b7ce16daa50f3954f7de5651be417df96b2dc6c2dfb64bbf759906b1d542055c7b1198dc6595ef45e8812c5816a27bf4efce225341afecf11e12213b119eb53e3aa2a2ff11ea5cbab0bfc8df1e694eca487be9fe5d7a55a3da0bd5b7feb47c5a3c9b85bfa3a94908813cc776b8fede807d8744dfdddb9560c7e4568fe8bfd8c53944d1775fe6289fe3aa4d4e2cbd73b0045b0ad311953c68d3d6775bcd9eceade302224bda41970a5300c50e905b6152b280de4246e08d0909090c9aa2e1cfe95a2df590cabc8cbfc88407fdb92b482096b969a1aefd0a699d755205b8271ec7c56b37229d5971067d8f3a10ca89084924b0690697fb31f6c75969f3629bfbc118b9043ee974cea6017569ab1070fb16d69d754b16399451432db7a43f185404a0135dae0873717d27a1bc5617ea3a38c1ace595b8af8a25e2121fc9bbf61071d44759a0d1d8c8eb7a0b8cd1abb66c56399acd4363b40fb8dbb1f7d6aac3c40e2a7f557ec68ad22fd0aa50c92d4d2384e3b5876f712137b96b54a302f7afc3aed585d9bd6425168342c9fa130d16a4d7ff120ee9a4b2d0d99c7dea3032d9143df77e30062296487d3fd01be354214420e71797633793725fbcc88004fdf57ff2b72e7d71640d3ba3655a63d0d66290f2584d8b44fe1da14e9c2af83893eedcee76390d7973c800f206377da155edfd1c42b82075f720aeb052499c4bc67bb2e3a904f72091ccbd243f2d5b63e4da558b922a4e61538baa75ca6390e5bf509f9dc28a63a8b91f55832c7deb79f5dbbe9e6273a56c2c6527a50718b5e483b62806b98d2ce1eaf15a00fc72eb254736988fee5f4fcbf2977f4ec3ff06c4b3a6a25dbb6a71e711dab02dd2bcca1bc29bf21e3ea50e58a4994fdbd2845ba655ec09049f1a68ed349382b2d276d8e75a4b9d6fe193dfb039b1aeabf25a4b53a40c78d8fa570df7a741f7ed2a67f4c181bf42d67f2449962cdf88f366d20ca5db3694d8d91c44cc3cc4b172901086a263e32321744ee4799c8afad2c162cea3642bf438dfe4e94c3037ee52f5c405b4a421b789f56806b8454c744590f570d73fc7cccedd5579ef091b83954eb63e7254c73fc9c7efed7bace4c478132c0772026f25d4d22da583fc4277c6a8de72b2bcb5f74c8cfd1ec39d1f282e48d0e4bf8b7e36f9498a27237049a91d1a5a231a8efd858836665f3066c6bd4df91fd2af5ad3b3901a8539983adcebc163b3d91713e2003a5b7d40857ad6337e99ffaef88a519067e065c0226220cdd4c160634f9358c5138d151fcba4f85a120e110f7cab55bec130c8f7da5375e54ed68cebf0590230ba19fc5e23015a390ceb58236f7a7ab623a82b15bce148d712be756a8b4b998f4afe439420ae36b3f3f21bbcf0e7da63e4dc4eb18190df172b5a20c99916bc360d98207cfa1c861b98371d3c5e1d6f4fde473f27a8f7098baa2d67697e1e47d5b49ba7225ac20540f3ab61e8c6a95185f8d3cbd63e835b33a4e3c15bf03d6ad89c1ff48a7e6e45214071b1f4bf0c8d1580867686a6c9e5ffc789cb0f81ca0503a8aaa806078a9e88563e15c90fb60cc8bf05ddb4786bba61c3879e0bba1668f8e1f9c9a66de3c8c3317dc40b7815cbf01ef5758b6688bf7de999c663552e2dc4ed8f7a1fec554fcfe47ad","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
