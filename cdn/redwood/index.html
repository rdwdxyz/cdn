<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"690d493e11b2c4522a32ab42af42802bda27df3d0a4f7e88e1ff583026889cc3a50c1e80c86c42aeb133c98686393c7689d94da92ca3c085b48318507d81a4787e9c1fadfa61f7237f717d4925e89a564f0be9044807a67174bf3f3424779840cf49c8b3da8d9063d8b097f66d8fbcb2d7e7f75903a39801aa6524db461839dac1d8ecd0fc1aa852a4420f9dbf4d891608e9e27e74f02baed440113aefab0c3a344eaf14c3c3e50ebe679e7015475100385d9cae7351a832ef646c779531aaf4ecdfa6d7eefe81821bd8dbf48ea583d55f45a6c225ac4609b8e2351b6e1215a5ed123261c4f583aab99372dc94d8ab1f48911e8f76c55d5842b4e8d2135cab567655f8cc5dae10e9bc86d1f4b6fd1574c5c251ded9a1bf3e1aec134d534fce66f3fe7e34beca431b72abd9a5502f9d56f73af38c6159ffcd6e53dc2b7d3507a1e59a36ce26792a95661693b4058ddc8f5af41e788175ddbd2fef36b33f858f29f5e9138c4221b093c82abd160c575b46fea0ca44cb2d93a8ebc2a67ae6eebed1224a3fd963949a41adafd81839ba3a9171f1b062b029dcb43f397031142cb59b18b3b7e2e6152d1d768aa003d9d39a69754b6ae87c6d6fbd23e9aabd6c19a210d6625950861a565acfa33694819d71e2c2f2e889a99203188960a7bec2a41b576c9bcec32d7940e937e5936b6c4ab40a055d1c6a509e8cfcfe46cfb567535b4a3af264edf76cef335a85971a6fe346bb33d27a68c96f6337d3517cfcbe946499e4b2877bcadb9a635e58ecbb9ac235af7946c924edde711e41fb31995657493c49a306a761a0c139465656f552e3d8b191dd3fc69a3849edb6879258675f21c69a16b86fffdb2b4a6b2deee3f121b209d9ec576a7da48a1d77397b2b8b772e11326b2cd809d8df843777cb8bf056ad0e1659f890926d9bb62056bc8fe857d430c21db1a34bab56e89f216e0862f28f85b6227707aeb88c6ec78fe6903a532b46c8b6b4b6d2633466dec3bb86c8a9ec5a72e9335852b325f91e505e61d1c89f3a322ac9e9327eba93c4e97d88442a0631682738a54e37e48b347eec6e67d47118c5f00df11d978c8bd5fe5654766c91f2bd37397135310f9bbcfffb6488ba94cb43aa6b84f2ceee40faa2adf3e459c8eddf3a25778e040791ba8b1acbab3853735eeb311b8545ae7e566c6225b084e5511e41b9fdc7bb66efc1a9859ec3a1d4840a2df50f46d0c00710ea8736847d42ccf50857356cf44120bd226e15ea3095700ed0341cc3f3f79a1353e41979f043a0fff350915bca0ed7f3ee8d569149205bc82f267f23e339b67b437ceff58ae2620374806a186cb478aedeff6008962b0a3eb881cca2f304f41f4e1f03fcf44268e986f31060bebb06387bafd81afad1ffadc8fdc9eb167cd635a261b9afb0560162ddb6ffd1668543d641101b415354c7174a1c49764df20004dff756311d2431edcb712ed9991faa806f4b977569b40c788fa8dc275dcbce39515929c8c03771b6000cebae5c20b1f218255889ad0d08f0efe3eceb872f9287ae9392a078f90ff14b13fbad03b9fd74695179fb62bb6130a3d3a930d59acae6ab810d8662fcc94490e23189e190a7defa6a6a46f11370b0c6c3abc7e92cfe18f9e8db35430ed831b2754604545187252ab7f2b0f83ea6743405e3b7a157aed7ea27e895a69823a9a3bfa4ee89d173b56e9a41e6fe7d740549446aec61f048aef5ea3948784ce1c405086f68e409189c40b6847203b60d7f40d7d9a7d173adb7a30dfd5aeec469a18606bafb42d5c395de3399aba7325a36f482c4f1a7b56c76251ab88a9bafa3102f9e389c25902e422716fd2982669a54687e33978bf16ba3d7f4355a5eae2752a71486f4fad26e56a47a8f0b53add8fd2322666734777b76f35618ac3c868033d8834425c1a36fd1cef9f8df5c7a9bec5a18d33396042f42a3db3b95279d4dd5d30c2915ddada005e0cef24ed2b6f87ca02d33756aa6e0a28b9766dcb74dd49bdbba8963ce8f66fdc7339af5c8a1c86fec01d5f3addbb54804abfc68339c69c1772f6f193f0dedfb7a53bc7aa34a9d79fa5a1dfbcb6a5f1ec741b81e00d9adb2e6e937311045b9636f9aa5633f1aeccef1218444c4480f0d7d72d1b0c5274b1f7596459dab89e2007906d6d0cc3c8695baba65abb0b685ffec70c092f4fa77296ab2d5a38db58a9a85a5bf67a20038d89f69a11be59f5689f8ec0603e715531d20c8d09e2d17b6c42aee6f49772188b21fb4db505c03cd3e68bfb9357b84a7ee9b007c4ac1be4e7ef39cbfd361090d5e7f2ddd8449e85c890cfc499d848d147cac0d983a1890192421787bb679c80d1e4555c1e61232f82d7f09225f1a20aa81dcd109d408d15cc399c54a7dafd1faa0a7b020767234fa47f66bf1a01e718d25e6530ec44a9c5564c1f55c3921b4ee5d11afad80796c28fa99ad510a5a6225afdb54e5d89a8d314d86bfcd39a368c9374ac8471f40d1013f62a11b474bc4d55830f1810778ab7be347757f11f8f6b861c98aafb4a29c9d3e4e2c331119687da4dde57609d1d70b2b950dc7acc6577f9f4ae6568d83161a8904238064d9cbb86f21f4f39646caab59b50a642d23f346869a50294bc8773ac66ba3cf030b82f9889a3780c76700cc9a71aa11ea0f33b917091caa2b4114b3096201b88ba4d4a1eafba4b092ac80ae1df650cb1592ecd372b88e7a5947524ffbf8b3d750e16f57acb8c70bd8ddf26ec00fb65d53cfc3536ab46dadd5e31fcad0767ab169d0dc545c2aad304182e686bee745aee18b859db645678d48017780ede49da79670c4be0fb3d609680a77985b5ef388080bff8970473e6dec9218cf4bde499c5c1432f566e944875ea2aa2cd2cab73d06a679440a20555084f7af331a05d60d1c0afdae5d3aad82ee6d7d1964475f7a4fa503631260d3258bedf24f50881262c5c478dec15bb91ea477b887b0a5df2c29c5acfba1ff337f26a3dfe5feb0d8d220bebfb3ca8a44e3fbbc420bf6d3fb89a1fe3470bbfc6478ea9232d7cd687aea17ca8de823d35bf5c7d0cebfe189b121a7acf677d7322b19e49bee6699fb2c210e7b748465c993ce6f01325bd1db237c5bc4f9df8796a6150ca0371b4657e532df67321fe902b2b245b8865c5c20e125ba15d86d2f229afebb586a13d7035f7223163698b704840fae6e9632af9076910f191ccc742395be18ec8f8b684b594fa88dce4b848357f86910062c3fc42ec47894cdb041d857f3c894611971005164959a4d6e8cd6fe0d16be9039e89101b7e0db3ccc260921524e11ccdf5acb73d19c02410c242550786efc69cb02d28f0adff964b11565e2fd70c55a9804029e4f9755f157d640d9aa4a18e004c3864eca969225ac3a72d918203ce916c5b7d0cf1b8b957694cdbfb3b98f8c1b2027f718ae69ce18bf3978dccb669a2b05c732d005f4f636f0a62cfb244dea35c60fd604087eec095de8b324ff6251fcdb7ea1d16868b841db29477958723a2f105a882176c609392f8672404c8a83d38fadfbfe57f39dcc120219560320e9c93a607a9b9f35bec4cb97ecf93339d3966cc6ef14e3dca5064c78dd5386820a59ca76ea4d9bdcf0dbeb25bdddfeeeace06cbc69e33c58ceb5d5b94ffbc1f365e61f0336227c9cf354d4fba7f859a22690b8131454d70b11012c40b584c49b1afe3fbcf2555abf7012043a0ce68b47650cc6af8c9f53d0d64dfa819de0d312aa7dbc431762f403a3ef2b799d910b9f15170f77abadbf0cbca2c5030189bee1fc24840d1588134daa8b8825b7efd1fe292c0260d26151a721afbfe27ea96fe87a2ee30b1671d8967d0c1de2fd7e46568c6e4e304d5ad69d4462443ca451541a4eb3ef0e88c5cb800b4ca86dbdc9e6615f7b39912c08066c73a0363a2eb74fcb6e0fbd57c1c10a2a0b23f2285641783b242409b2b7b3cd46f8efd9f50734226d472c9857b128aea9732ded915e7f640bef57aa8678f414483f70c98d815b90bae3a5c354b122f7119b9bcef17c35158599123a083d0607a828fbcdbb5b2f63a70986d0780921ae1c959f9095e1b556432eceab89144edf67db8b7c855fc916c411b63cf1c28555152487d3bae38415790e625db7968d1d9d5ad4112dca48a942a0e217bb43325824976754882383059055f40b426d9da2d0a180433a152693711b3e8b05ab559588208988cba34dddb747f943c25a02bc3627cd619ff61a578f5219803bfba5c0877b99bbe764c2fa4fcbfe568a99b24113eacd3c9c10062a2517d8fd76823156f7d0572d83a66de80ba890c68ea93f5a7c9b7796dda26fb9c9e4232b1ec0ee7e72b47979dc4a47fc3e2b69740a8d05b7361a66c82df88cec3af1e158b6b27b24fd1b2f4fe39b9d0cef97d7b8aa559b49397170b5e70268ab2bc3122df8fdad1253f654bb1a40b6f230cddc3f7f36df5c7e449894b29a02f79be5b94d58f328d5badb8971658f0ad1fecf23afd29f5c5a1a43cb44da122f5966a8a1650dd33d415636884857a2252dcac2d7b16a600c94875184d96306363de0d3a243b4d09b93543f55725602649cfc9343136f826713b8a000cebd8951f5bf1bdb03a2c79faed4c87cb5a5c1573ecccb1fdb4bb01ca36f5955780c1fa4eb9dc217145bd2dc72c0835a749746e1dc3c73c65ffe29e1ef0730c1dcbb32381eef08dfe3834a21bc1209bb07ee0b7c03fbae956d1f71d9e03245b7458917b7b411ecff1429def26c38c63259e9550220f108c3b3fa97f9bfbef8abd62f3fc582014cdbd33006816461c60db842736caa0d023e427c7b212f25c8b158a64cbe9af9d17b94b10e9b0b03eb882a94ce748171fe84649b43719226273baad1351bc1098b923a1935b8e2767fdc3b7fe5a7862d9a8a13a97d1223f025392c92cd8475935cbcfe62f60cd038636682b356b794742c8d6f2a7d486c30b77c2c1a0928487d71daf8e64b5ca99c4c8b121cc6515682ec33dd95a1495e9d602cabf2534396c89aa71086aa53bf889edd79c2204afd4df9a3b51c8959410d44ca08f0dd6ee2769d6d622bb2aa67bfe189f78ad3484b73f4ba9cc3d9f7803b98ba20dfe30b5eb356770e96d39791849c4a0432087ae825987df6a84bb6547beb8baee4fd265b0839b0346b40914a17699e37fd724da3ccdaced4885fc76f75ac496cf6a989b8f3f3cc942dbb409dc61a81d7be12539a757b8cac18eae25034c8791fa40a929017cc9262397d337be3abae81c7076652b2eb9d828bdba0a8feb7740fa2ebc8f3cc30b77bfd35668bdeb0bc7d08133fa49364a1b9b45948e01b4435a69cd5ae99bd46f34ee78d2103824c527c7058b27ab11b3b9002661900f2876e1348b221bcf49996997937c9e3692881545cfd1d118fab07ae9ae7ae5ad116a7bcea6775df57b4c198b52762a4604ed3858c71ca699250b50c08a3787a5dec3204c05a51189551c8130e057a798463ce43faed48ca95d52685f61dffc26466ad6ec2bd242622c4603abe7ae703244ea3a8f3e94c80173812ad8114fd477d03864b6ceb047b3665b9cd92eecd37c6ddd676a30464789e6765e22f3aca43bbfa2c0a36266e0a0c1c6658a38ec3228532bb4240d91481be63e5bc60ea130d1b581bd12f287149872bbcf1755e0f61b74a5d99af3bfbacdd544165ddeb5ecc7dd215f15242491825d5a5fc63f4e4353c35b38f17d30e3e707a4ba85d45cd298b200d138249533e68a80ef4bd80f4c2442b15d48b8579d6369f3b07c6def7e8511acee5a0fd0ee295ac11d0ccd4f0b8ea4b1f8ac836b3c17c739341f17c763792efb3fd68af02423d3512810e476430927f74060fa3af09f03d9236a47e8ee6ad21a1885cbbb96e1be072acd0a9a7678d729b64772dafd17d8b0e46eec9ee59d4c31bc729d47c551cf3f4e82cb66dd60b06b97b6547053b05623fd6f4037e75b5163751084bf13eda2d47e433847105f79064681e4745ff7782a94bd09f8b0d748967b7b50f0ba51a1ae7f4cf45641ca926f80680eca86d9c2459969f2717acb1c2234ef9439147e227e77e3c834e237a7bf2512d5cf3c9fad3afb5c8674a7eceeae3f6e59fd166c3ba05f662d8d7e8449575c2a11f8eebb8f8ac559196a605a87090bc19c3e7add827d95ed50b83961fd9ad3dc7a306582b163dae7e990c37bef19aadc05177bf2e0aa8c43309858eab4e75f7c361f02e51beeef1324e44a09ebd20237b41dc2a8dc2833d09b504b931b950768635408a10585eb34ff1f119f0541335c778fa40d5927bfde8e27d007bf6fcce1126617aa11a7120ede81e1362c645c2091fe52fd95a2f062bd27a6a358b6b4ac850024051a94abb6d24f8ac6c9071df0aaa1c40b6b7897f73fdb635cc937d25b68043229cdd684ab54c846d03285824e352f9941557f5115fe9be91984efeba81f12853a21dcdf4c5c6450d92e7d470d567b144a0444b4e4eefef14bcc74e50e09a1211ebd0e8809f7e5f612013e4181ac633043e908a46f71a57fe05085061d8b0721bbabad20f9ace93336bd207ec578a50f3caa289bd9969b964d553e5f9dafa5db3aded26b133d08a1c318b7b087f266142d47cbc896e9b23358bf44e31090ab9946101b534458328d1956d68c4df52ba9d373f784d2a9345f3e18a7b30e1d456519aaaacbe407155a77b5376021d27182364d1ecf6bd7a9661ea7a88b6b7febc2dd79c874a8b23521b49c9667fa5c388c97df2a64cfeafefd4209191954adf841c15d2485fe9af094dc9062556753b0c5bc7dfe1f2106a8ba2331084610e68b39096e9e2deb6cbcf408bc262397e6533ec825ac9f514186582e350b599b689994fcb95dd84a57408d14653cb3a6cb04b66fafd018ec0eebd2fead66e1ef982d976d0cb520688824f6a48737f4876da1cc8460b3cd8d5e0ec17b0443182297c4ea3f066e8efd943fad8a833c76090ca591510a7b9d7845d7482de647907651e435699694695550313e4359b25eca35f578074cbbc7ce3b6a829514128c18447be84973c29e4409e8265566f22da6cef2148d0d2be33c8ac7c44419c00521bce9f44529a2aa3b0eb50dd46f70b9376a60e0357e525df93067c86db9e0af79103e788cce0967eb95ace9cc8881dca990995348667327cdd6d9a6696367a546bf13075d4233de3dc99eaeab84bd4db228e1bc45848cc96de8c60f31bef19603b71e71f3d8c3a91f08a28f6dcac4c72ce427339be1819d3f62da90148ef4580c0a6a2c81a796753b61119aa31959caced32fa4bd1021055955bf2fc148f94aff7260bb58c5329a6b7db15168a8ad00a37f93aad7a2cd316839b95e76b32909d8c6e9216158303dde34f1265e2021f37c2b6f3b0494750302c42e9a5c36b2c565b9396de30f4ca0780d96c0c6c3fc90de24f76f1718f3d457d80117ab5a14c529d49141bb5f2ab4dab0eab547e3aa6b70e5367ac64e4b33a6f12fdc0f326ca42eab50fd1083208e9d9da94b4f1590006f02bd47e21304100a28a603219de6a4a2550645a230283f1819feef89908a43166280e93ab70346896253e920c8bdd692a16d47a4bb0b333992786f6fb23ea9bbc0a9d222aa37f31fe5492a9503938df8a9e56956d23e62798794a80beb3e55f32580ca76d0a9705d126e80d4f8066d431b9a6d4287970462b12ba64a589b787f800837a9c90d0a49d7c737e4eafc70efebde16e2be7b2f8ae917811aa8a107871c580603b683ad628f7b5cb3f0452c43e9ed3b3be245bd39240a9fe5a13104d7e42436fff646781e5b6ae03bd4c72b7ba20b419d2708ec61793848121c614e84ff3044d2da96d20a04ca36527ff77ed9bd0d716fddfd60f1b23081bb3423849aecd6886c064cb67234749389a2487c42ee0d2811a22dfa2a9784d21a2b58e20b0fb9eec12781408d6ac6153a5598598f33936c8058c6dc2d19015260a5804180f949747444c64dc041cac287cc73837c649e023d60e694afb3e407f5565294a087474b805854b6a7f9b257022800b4e5f8f22d902b49db3c40f2994d9d620e762f95f17be1520ae7d66d55082b4aa977185966fa4412a559bb7f16b4fe435a1048bdac7af034367261d10a677f5239d25bb4c210ec62cc7daf34df9cee5709a0a977d494e79b6cd2b198147a1c4189e7a526e4da5de13ef183605da50ae3fb2f0637bdee9240eb84b5319699b4643efa64326737e8c743a54fc2be2dc7f8f5d0cffddedbfe9c4bbdc05270cf468517b7d902b8944cf108a1bb9d6f758a293d47050fa3a749df7dc522ec7fc457ec6c85b1e6e9538365883394f4d44f3b8a78907cc3cf60c77eaf1d792f55b96afac4025199f3f181b741f971317ef61cefd6fbd9e6e903e18356ada634b2085c994385892e44ce3b360f8854014ad91679b1b763b810534933efaca22d506970f5af24f2c8fcbed70182da4da13c9c274922837a247cff6ce1bd4bdcbbe6ea459c39784974bb77bf017aee56cb995556f22b5bb0a5e435a8b87b23efbe1b58444f87362823b3d8fca9f2498a7435e7f1d4efa1df76637ea3fb62b0c359a2b066904a7ae152e53505086afbf70f37f724a838b25763ca2013aa98e49f1f733e646a49afe24675738d6566ea1e61aef662e3a9433732e0b03b8a4c25ad48eb7404228d7854784520dcad67a0bace2d1165bddd6b236cc26e91194ee642de8a388f0f7a2c67941b107199c69fcb1c8fbaea4dba7cdc4abb09713638b7dc858e0ab0f0bdc9a172494d30cd33b6ae343e2ae6a29cf3370b24e5018228d5a824064ed75ea15e979437f83250c753bb6f502a2df649fc5b1615abfb523f5962cb3008d50407807e05ab98685b3e8e1113a8f6d8559439fd5649f3266e86eee66008287d5a6e85cf714a226c3d73e2050b8beb8bd5626f0fe9e8d70e4e92e757078aa38adfdc96ba074002b919be942caa0cdc69baa2fb5b25321125465f35c48c40f3ae2496533b8f0d0b5fd6fc51dec4c0b57ed7f3f071cf03bfb6b3131563f6defbee2beb07f5dba9d4430d27cf05f74a4951a55a33d0a02420df41c2fe015b55201d4b9531f5cb6b8f5a750dad17055990cd35e1dcf2b7abb336572e234b139467239e2259d125478535f92952fa4faa3b40cda8b0fe5af0e754c3a34f076613254759f1e2c2a9ffb908bda43756450c86bce97ed6ead0df613150137087a58ee1f23718dc5bebdbc3e6d69dae69413987936a2465fe22c26c11666a841030f774cfaaf8bf0442774ec8c0854353bc51942674e54b8037ba1ec330d7f110d77ac5b6d1cdc5dc94f9b3eb9c69dd0ea90cfcfc6ce6d7cb9b9c389293b56dab3878ad992ca82802ce9cd5f3f1f7eccecefcebb10d365e7e7f33c169615717b7d5cdadcd6adc723df277aa4898b8701c5164720fc0d3b6d31502e6c1a7eeaae63485affd497938a366bfd3ceab10c1845c5143fd32474113a6481294a157438334dc3c52038a0b6997b6caa1014f6e3ed3bf02e4f7dfbc5c5d7e9ed7f92909f054a2be1173cabb05501d410e383e8d79ac1150235dba8ba76a7f0eb32acb57473c1b11a622098b66528b59520b412e43f205ee93e58b7ab1b4882f50f938feec06819e7cf732ec1ec3c50703636a7c345dbbb615802649a4e00eb32ecb16162d32eda4ef887c09afb264e3bfd19f5ca244f5935a94efbfb6992e51c018a616732c1f4c89fe406679e1151b29fbd90c58810a451dc51651442f657391d8df05f678fe65cc1e2883f29dd63bdcbe940304d90d4f2a14ad9cba41b2586247174e7891a4cf8c585262a42dbfb5a19209ea563608162e866ace87eaa3e6b46cf4f6df8226ca6e853a92973039ed4fb40642c02f2b169907229114cfe9ce320c491f52121f411dcbfde7a2adeb92556f0f3d1cc5a9c58ba7ed14bd235ba1d3ec280ca01fe9c69914d1b7fd46d8efb933d119a7bc3520953088e1989fd79949d4d0cd8d342be79f2b2760eaed569f685fa55177351588346e0ef3153785ee860a2e51211d1290518429d38bd7c468c5fdba114b95ca589f3d8cc60a31cef33376ff8689cf49ee9620c7ddfd54db4d1c1a9171be130a4b30582f6cd8885f34e431b8d74d547725e6c73dfaaedf2d72b7d2647928f1b7919a2c245045b9b7391f86c5b2e204473e89735d80be0a618e7ec2d80ebce6ee043ada2695c3988e812d9fd1c1e44ca742f582392eb5b27c4a6fbb39a00d12da90aba04179137035fc9f8d7e7595ab25fe72abbb8a2c0ecaa0f663b91857bb0164d7a6bcbf6c2259f64ac185e00a5dca92f3ac7f7cd19e386a45b57cda63997cbf35e7f30c03303d515128a4cba62926e2e1b768c0a9d85410946014c0cbb2bc9ca7403b682b9b64671baacd99f4782375ad6a465e6eccab66fbfb579fa4749740810a6e49956997ea9755755e2479c323075e4f06b3eb4dd0fb2021af10bcb5b30a285127b8fb0e2d3b66a486449b049075b6842ffdf1b70c910dc9af274eb2adb63fcb8f220855d32d9f651a61677425fced2878a99fcbda810e3a82ed10d8c6cf359485351b4adf609323e887d294f67ced46b406d1c9a3f3123918a2ccf73951ed4efc8f5c622cdd6891b5f61830a64b039a72c77838a824cb89777eae4abe5c471291c6836c51089ddd4b15a37a1b60156f4456594708c1f4e041898f7306a7f319f0ce6b9e1cecb9367087162f356921188ceb8c2a06450100ee1289ac286c4a5ae3c2a476ec3f8979e3913f73bae3056f82899e76f7e8453ef46a7333e582e98e1bfd3e5af4f7dd897a97b1b8983d130203b4bc45dffbe5ad83295cf834ab793ba26a8751ba62a78734501058928d141aedb92e7b27beab81ac90860e47e0c3c652eb381379d023148b80a59ff8fe0c80d85dcaa01e0aa649b657b16da8bf8175db63abb2113dc488b523a9026a97bbad3dcf8218b3e732d9ebe86f7f1e486b4216dc09a107a67b4241493b2bea36bd73a9a563b94cef421047ea6f6ca15a860f05542815c6957815a4f5c682f6a515da7ab7332c800a7e40ed6437c5daadc715d7a9621f3fa038ed42d17bec7769f4d93d4c715f9c5e8a5dc7c6f3f603087445217aba574735d9f1e714e0fc760050476ff36f783b37667490bd17649bd62c34b8a7c6a80b2b0b42d95c24af32cab4341fe401ee95f554be6677ca5d323032a9f6533dd712ec89005633b7681db3193e5a8aac2c7d53ea409184fa521f1fffa6e8277d3089dea840a7f13f1cdc03156e528db23ad5688cce4c89f31c054d129b44d4f29f2db0347073733014756e4e5880c578fe901e9db1e6df93f40fc78daf276bb109f0c72254ac5eb5c73eb955e090e5548200492dcb9e8dc435333a71e5bda06c6a5e30971fc12d8281795c0082fab957487584e1d6a26276464b5cc4fa561761e89ca71fc39174c823b3ce87a23f10b813928311a39b19a47f4af094bf0352b533c0722c18ce4e57c0f8e948e5b8b6ace6c8fe58e13f0d2aac2176cf895bcc1f3fe5b4fd596edf45e4211731b30e882666b40596c9c00ad2166cd82a635ace791a1e31fc5a3fc3f63a6a1f7419c061558c99ae401385ed9395428e6d76828a6a5df620cbfa8c431ab6ab2d2b5b27f2e30ca0004bc42655f104bba3b72b22f8e6e6654328647412ed2f646d366d64b71b7dfb3b6e484e0e419eb810dad677bc60ebefdf0ed20b5716e65f771222fe36a17db29cd961b2cfb40df8451cdf5658b00c95d2d8f9ecbb35a92ce83c38a7472f783df9f8b589948c16e9fca89d179b97047f37d21c14a10fc4410cdf7b79ff8de0a4e5eea582cda9f307597ad7d0be38ab32aa03eb88941b8bbde539f0ea78312a4620739b63d9851f3cfa53c1306ba5fbe30aa28e9130c6ef31a78dcb724309a53895e39571a51f2a3eb25be93d75b0da781cd60328d8b500003e6a627e208f2e27e74062e94872392424ddb5539c4a76aae3ce8b9007de9f0099e0da6853096dabc18ac5e6149e69ea31e955b6c99b4ba98382cf246a92fb9065c812cf64905d811ac30ea87e29345496a097326714930c48c80b53e82ed05d30086e5b1eaa13c50522f50703a462e33988346272bd6b8cb223a35a1cd40ed96a281772e9f48bc412e988cd100a552d6e180efcd4495375e027c8fb8083206942988eabb4d949e06411fad24e799c5af0c58007afe4aebf0d75186740be4440275ca184963c6d364877aa8c117f35cda76e724ba1aa395ae41d41bc2b93bfa154b9160bdb1a29be4442e7d411fa6bdf0b7f9ecf0ba108dc32c90f30b7d64d137656c09d0829a361a2b8fd98cfe8d576e64b14a891e05ebad61e260da2848d01880e65454a58fb5a38cb6c147475256ecbf78dc75928e2d20f7a17a6f32533fc1a1276763d20fd81bfadd1b014a37d72e5ff9c520e945d90b6bf20588c5c9986d9ba76cb7a90f3850e8241b91a029996ce6da06db5f8f09d6fe0087230aa9480b249db30efe23dba2b94ebf98958b43b94441873a68b58d8a2a1ab6e364a25bfccb3ecc99640bb9a2ec029c377e57ca14cd79e1c2b5ee2f382755792d1b63cca7efdd636a498f168d80b380d7798ae625fe7261d9cb2c090f02629a1b8d13246185d87188aa9616be3929eee5cc901defeb33bc4787859e99cee5797d204f56f51c39cd52941ccef23e043d75d9d2c804b73da7e152930ca0131ced8c91dd9fd51cd6163c527b66be712aeaf37bfb996340deff4efe322cc76007b8e276a35c4c5f79660eb20aac71c523abdb37dd81b1849c1dc89f95115e5ce52c11575fb2a5d3aa6d21dc699f287828c90942cc478b0e9ce5d80cdf7e292c7166ea865500961faa26264101f9d48c1a57cb45c710fbfc0475227eae80880cd8385e687beeb515bba6707203a7c89b24edb1c89b927cbea90b4786a05ae4f1207718a6e80a7982828f6322b99c2a3858867451f52dcd13252cee2c1c7fe01b97c700520118bc5fda5a777ee996f34c85d2b6f8b1e100a5772b894a64be584dc440bfb3ba3873a82041eb5b940b400b61c3d4f1b4b6709e8b4672106900a09788121999a2374ba7396dd79d883502dfc878915f97f66a7e6013ab58b8dab799da7374f2cec071a7f2c5088d8a79d1b76101b24315c6a2f111941f32382beb50b34cb1d46a092d9eec8c7c92d3d2c6520cb00109445614a8963c5e83a4d4949221a71fe8001f0fad708e82f5ad0f23f5ee26a431ca3519bf39deb0adec7ffdd73c7c5948218c83642859d64973f053e104d141a21911ca2e88ad5b54aedf9e9d09d2822157d02324421506a64499c6e9baa912ff3cbf8d3a505b46721c8881521e4ed1580e3fb5eb57858dfd77e9eacaf5584fc61b1f759375b4191eb565f670727246e3bfde01e23102a0bfcaa749fc557a386e9b59a08e796ae4d62174e7bb153fca0bc42828a822ec3ea0f333a277609f168d7db010f1caa42530271a77fdb7af25f5305e06e9a812ad69635904986277a87f32dfb47611b3232688cb3a3a12c9d89d8a17b949eb889db67cbece48b1a7961a6cc8e1162c1fa6d23d67bb2b6797b7299b1e788e35a796fd07ff0cea7509f5b15437cb426d7ed9e1df01f62a82e97e0352343ffb5f232f84f0ad6559fc29894ed79d96b9e8275a53239c3f56324231cac68d68268c70ff8f8ae2c1f067357c521141ddafb52d99e45471e183a7e00b7549d681110b2e441e9ce630a9853c88cf545cfc429f1550bbb86da14e491db5367dbe7d5502c0d7f8a4f9f79fa06b58248cdd90cabff2ba1e63db7f1f632c82cf0489e971e8147a9af7a020fc6a68ef8e7e1f5eae9fe355506cb65340e6f8517e735c07b3d70a33db49ffe1f945e6c0af954611fa587212407e91218be1adf7473da8a1c7fa42848a866c77ec11e63ee58a1f4628409894adddf2e0e4a65e22902853adf82f05a40903f63c88055dd4b6f13191542dbe919b152e4eb95526337773e0e81cd6a97481ff225c2e01f60129f001089041500852e9f357f1abf1be03e1bc49674c55d03192eab873064b7d27e705cada00139f8e81f97d9de4046a6d65eaa83208053bfd1fab8b3e397fffc05807fbf520971e033496956a0ea5b98dba34b18e76c0a5d61b08f2623c730943387dd0c2e3227768be3c391d047559eb8590d5279b0ac6f7abd293e793f1803b412eb15095080bb4c3c075401248d916ffb1e3a0cd4614d466abfbc13e308027c1cde37304fbf76360d81be6a9bfbbcaa6e42ed13081266ec33c5fcda14661a31683cd74ddde2d66a66e1bdbacac34a731413eef4a577c869fd949f2b64a1093882c51ec33cc8b2b88648a42d30c4164c93599cb9a0dc8e51c4fc32072d4c20d7874ffc278c630913f9b55580bd126af5488bf6757c77807525ff4d38520bef1b3d9c8c21a3f45ec407174446018319624293e21f9898f35e07a6dacb300a5239c16663e97bc1080c995cf094d1d8ea10edd7bedfdb01ce6e8f64369fb54687261abf8ea1fbf90a03f9f3cb13fd39d65cb846befbb569bf01c522369c40bac6a6c5de49a155315c2c4c0143c85fbc6d40f135fc7e6322b819af97e762ada5ca354eefe89975978d71f5cdd5a708ebc76c6900d937ed4afe2bed14af397331d731eb027f2a1ed2a6306de923700178ae2d6ac99406bda215d9ceffcbc5afb0c09a95178a2cd07fa4c3231c89ebc76d719161649a2b6c7add4fdcec221145a242e5971ef4dae5099778a9612e71b6eebd70b1dd346f3b704558bc664e2d8e049f59c886e1a69357a60b27d55a2a369063aae6e74d5718deaf4603d00b811c2a8138f98c4ed55117044b993e247670ab3b4fa38d238e635a97979929cb559b67db6f37a06e3e79435e37e2d956cce4e9e48965018ca63550e37a412c358ed049132733acef0f63e699d7a05b62cffd8cc7d24b41f3e4920e9b2afcd0f513fbcd526e3e793e4a97237477223ce654e5578a072ba3220f3524b24d683e96c9c19758b0db1d42cf5dea109fbf231b641a029fbd9030074da2e3e016908bb27e14cf114ac6427847888ad216b4d693ad24518e994558a49e37febe4b5065fb7bd8b54c8038ce287584926dd1b1ddc31fdc80d7e5fb6eac298b7ebbf7c257277bbb68b1fd04fd028ef5a7b3b9b6960f955f24cf0c284400d610cd536e26db0efbd7835b823e3922a744ac4563bf8bc6837dda6da41215b6c60b6e0166c61bdd311ccccc5c9b6c9a4f78578a0d1452d947edc19b918fbe41fb24fd2de1ff5afdb9541b687802ede2f316e61a7af45e69d77391493f27ee273af60d9192d778ee8fb3a12b968deec81b2267c689ca0fcf54e233210a357513049d2dac92661043ce2c6b7d4c4d956e72442e61e5a720fb7431e0db447fa9191166ba73d458b4297aeae4e35356fda275abaa8731586c0128f30b3bdedfabe6ee3cc88f2788d6351a16ecc888229ac6873c5903599a198bb8899012eb6431567a0eb5235ed688cf5be2e59ad682fb92fb980e58ea40f2bab84198b6ed73f326fe4130c65bacf98cb4da74af59b15eafe7d73abfdff8c8370ac0f95b49a844e6e62a42873d0e2f439865849af18979453301bdcb90a9d361bb34177d7a737c1e93e33d27ee1d16d7ed6114417486a947f123d4c49e98cf7d35bd2fcae5b427341ac501a1fc90283e2cf0d4971612c093dc881687d5e7254ae83e02c337e6df748e131739b9ab70e7f66cb5a626da82e4e66524dd7fb4176ff6559d7b09069b6d360084829eac4966f92093ed4142d20442e226bea9fbb35b11bec279bf34ad1a7ba1cf050aca04ad18be81fdc333fdb2ef95dbbb06fb8042462c9f87865e7e250c7eabdf4e5ecb99e03123fa56e0d7784ab6edecd954fb8c064c12943998651a27623f4693ce9054fcb1cd32ef3833cad0a95af75f4acf6001dae1f62258e4d44d2b75a2eb6f11bc52a030dac034f79e37e70cd20a39019a6a959ecc3c91610b7bf290ef174d003c51afe198aed8d681639d22c79a771922d81f4e653dbc9cc9d4390f60611c1966ea1b65d3b01edc19e7f29a3ddcb2ee40adf78057255d2137f4ae0170af93bc7e1d8ddcb16af2a83fb01b2a6061eafc7fbc9e70b17e74a4825353c44ebb20b8b4c72c37e91121663f28a1a5222b4a603dced5d68236ab3a41d69d969719fb9b1920aeafec0aadb4cc4a4760d219976b51dc8c5de948f9cf41efe4cc7d3cb1c9deef7e59e27789c1ca8567be8e57db3c8008489ced23ff0e5e42b2cba1f26fdac771b700d6c44c29d57f502fa32a11a842fe3cc73147830656a459fcf8e2b4db66c0ee280a670c681883a61129b5c56fb3de338d2cb1e1aeac354f372e13db0243b6b61d6d131ad2c65b9ee04fdf150317729584f143fd9f53d538bfc8cb8c313be3ce15e84729288fe4b989d5bd089374d3caf66288580dfe88aa659f54eb404dc32b6db98da6152fc49fea2d69757dcc6d7ed5f7588a2ef58316f4ae9d59072397c6d2d28fa346149d1639b99547a9ee24e7309661af6f83e0080d682e7f8b1d30b70a05576c91d0d8296e731379b517efd23fbb87768cce91244200a37fc8dac3551438b2c23d1890280462ef8943e6f2cf3d2aac3f7f08d2ab3e4b82ec2d8f3b0ff1384609b563cb538520d71eb9ad5df95de8ec0c476a57764590a6b7f570e17698c6b88b4dfc0cb4eff713c4872d642e34e2301975c9c1636386a80fd335b9fcddf4e0e0747ef329ca09b6439f46d42ad165e581a657b90d92db6e2d2bb127ea8eb37e9bd48eba7ee528ddf92f4299de9443f6b47726b36b3b0b5302fec633c18b2b20a4b64a2afa6ec104dd3325ee935ac255008fda2af9818e002f908189b561d818f3c727e3023ddd9f7780d70ed652fb08b4f1e35945495c530c4fd138a62ba605867b0518b8e0884f1d8fc0c43c27f9db89374509e2273212dc925b0846a4da4105c3eeb13551a1d742b59ce8825e023e76edc2ee17ce32335bb7a360b38f03301835ddf7f0e6a9ae129b657d35fc5e536e4f0e5e23ccec81582252304b996db2c1bc3823338ca576952c41b633fd763f1f0ce1fe59f9d8cd860a780e5baa86965234d2a8e4f57c8362b22e2cf1ab6fc7025c2d701685d863356dcd5f3f76bc55613f88110811abda0f1ecc52bd37dd86d1816c20bcfe9979331e849fa1ff3ac3211122a81d7e71b9f8efbe2ed1e3cb10df1f237e2e662e07df26cbc08bb41f90ff29dfe0203edbc506872c730683909f33b2f6c30d814f699ddc75b04d94b8db13264db9d346f238b35a100b9ac566f021ec7ed23b3cbcc1b5de3ee009ab599bff2df610088e1c8dcc81ef86f11d8554ce59bd1b243a9e7dec88f326e69da803d7a838b1ac05d6d0efcec9e72acc742bce9ab923d924964658cca2fe4b61f836231b997c98b9674103ed944971a4ad98cc48878679594541bbd8baaa34fc5b3717789c3c8dbccd487fd34ca6371f8d9268b074c5fa2e4d323517281617017c6d11095330008ce938ffeeb579709942cab08a8148a237c716050aed5cb570c7410d927e178beca7a67842244833dbd625d7f2c9f761d2ce7323a7a75e5d2d3f86dcb7a69d12645a5f48b3c7d398bb4fc69e2389445d8b3bf58467eb043c49bd7cb678cf576f4524592792d769cbf7b8c651d4b1baff67d120f7e350828f43ffab03c2ce60b61d2d333eff830a9829369fb53c70aa650a4d9a67f2044bac8ff03082dc2acbd0c162c6e4666d13d21b646ef5d7f3fe4276fcddde06434a020357a7f77e332ce46be2122df5ac7c828d74e3b10d1d48fe880dfa1396cdb58e20f587de629ec45cfedc9d2600e3e8af52cac902084f76ea40b72d83a305e80ad9acff8565766cc9fca7bcbcc57b267afd21f26ee41e19aaa739aba41b61d031c3f75e6b19685fdad99c44742f7c3073af6d7885807c8c0cd3fe9d2e66248d5177561db1fc5c43abdcc325cf46f2aa7cbd98a3e47df526d3f71605d4d2299af6bca21cb6776185c61881b7a3bb8f00845ace4ba5afc74f2fa6672deaccf12bda1265393ae07b2e21698cec61417734f5af86696d2a1b368","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
