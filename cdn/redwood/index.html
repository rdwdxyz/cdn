<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5df8b3add3832abc53add6265017314b1094afb61bfd57244e9867763e2b025c5a87021a39be8e69a927991e2b76769458474420c31cbb9286d10f9aee4709cad683c38cd16cb5dce6c2d32f0f6bf99c6cc2ba3129e466d34d34f39f22ad436b275a6f12d0b13557966aa3ab5b4d5553f04391f7a0e091cd17127d87e109b911fda9785b4c3ba85907b2171b3a5abc9f34847e371c683e1f1db5f80d89505724c0fc4967c50f8cbaec0e875ba3181e1cffb11412f5be941fca6219d6ba2ae8cc6a368612c4e340b67e3f9b34e4949ad31a57718b84ef9d3d8702722b5fdcf8c2ddbd0f5bfbd5d86c3b4f2bf04c24d18f5b7b51fd8a6ae00e9efe90ee6035d9eeebbb39eb00980c913c8c152cc8e0e4df658efc2df3eb877967d8eeaa7fda5286708ea98e2272d09afeadb2aa1c7df99857718075b9dd5e05fba508155e74253b84734d385b23dde690de5dbb10d2d92d4f83dc379d7e4d0801c1ef3067c31ac6c00fb83bf0bafdb1f87efb760f3db3f8440c89eceb842199fe36076873d2353b85675cf59807c84dde6852aed6a560223caa39dd0e7a856217e16769f5cae0e34d2d13daa2abb806db5e2c452c069470c1c7b8108df4285f091cb9524afbe0ede60105d08c3bcf7cacb10e2a85a95a9f8440143b5b7e6c30687075415511ba2a2c2fa840d358e99f852a59c50935bb280f236e6756afec30d85d09df465294bc383d5ae06477b009db573230c763cb3663dd71185286db4d8c75774d25a2d00d570cd0bd4a85ded77e176508f0bf139e2ef804480b5a47e72515ef9f5d3b6dc3b2fe4769e17cf3947277b259f200d2257dfc56eee60a08155eb22aa2e3113a6bbc9bfb29c404094838617ed453ef81fa46c1b75b55a02131cb3a04c6de128895f9e230f1670f3d20400d6cc06d62bd8c088a9540d96601244be3096cd1737c31b2b59761006c9390d463c810041a9a0b92a9a0793a4b3dd9da2b1eceec4dc84b71d9bc9a1e809cfbd81cebfcef69271932c9df2c33902eadc8a08529d58e837e1ae3e13816c0c69494fee578bd60ebc83e63d7940f196895b4d402482a68264a7c1bd6c84d96e0ccf5e4ab23101e2907ef298209573129ae8117e53e5df47e1bd520129f2d118ddb207a9fc65a942dfab72d65ac9b7258fcdc12674e95227448b132b645e3ef0796901f713464faaf97e0549baa4a1aba03f77866b7c2a60de1f3d84965427b4a45c48ca31166bdfc7213845daffe98046eba2a93cf300c33b1ce092561ffab9ee559ea2c33ad7cf64c6dc8949f8415c77b5af08c3fe6df016dc20e4ef2fb3a213bd84716291b4ee06cda8bacca741464d701d184f8d5ad94a9a11824d7114b37cd3580d23bb10d982087a7ed9781aba49331fad0145be6b2287716786e4fa0ed6687c5d72469baf72eb88bc75dac72728d0de924c1144ea0344a55940babe1e7f94bc1bffb1d971c29c1d9ea110b2e77d6acd501999c29ebd460a5ae06fd6274b981ca416b99460eca62980e8c33c258cf91059127d405cea59d7e865d3583d96e921f1ad6caf292cb92e6f2907619a93b1188f4159bac87916a1fbd28c745a3df51b372b67a63658e4f92a30a75f48d3e09b12da4857ad31465ab22b8e1244f729d17ba7366a6d8830d2de8056280896d7b63874a1a96b87850241786c059b7516896fcb83d33abfaa146327ec42b4ce3fd2aaea0cdae25eae0235f2e8ab5f753cebc2a448ad0596c92cc330d7dd99a09e951ea59775886dae4e92540007913ec112251e1a41f6b55c417e7f53faa7e4890a24891855968faeac2a839f50f90c78eafab4af1b36961efd91ce9e345ea0742741a7f71cc8b84d13a15252a57486c74689087d6fbe1bd8619f0d6f86f6bb0d151f23465be600c53ba0da35d24de1026b72888964109c29ec02457f972045791cbfe3ace44d1e9bc1774c4790e830f80a79b42c7fd721da973351d17363c2c21bf0050d9e431b57d4642066e7fc5a9b37a3f71ed8262ae648c1c016d7b0ca5252854055d2e1ee26c9a15ef14f315dc487b0940b04e6804570dde3cdb6a30764abae56587c213d9df3f874d902695a30f7c8f27270998dda6979fb6d02d938acdbb1b16b315f7d958ee561774edd56b8d03ca69a46b0509b9bd1892f09d880f81b3e1940561e49b7655b7d22a83db3953f590e9d1718984077118b6c7397e808a919263156c68fe8455087d1bb8d2f1a7de5d47ab40c2b99c6c623dfdad928af78c632d69a0bf9d00bb113210d6f6ca4b5365e7e88682f410d390687d985eecffe58dac94a295f74d65b48e9698e392953edea1ff689d67cd234cdbe477598d2382dc233c0a325c241df8848df4d33ba098ef50b0f9aae6301902da47867970056ee453e603a3cf93081fba0f5d1c31848ed314a53fa0d490f8220e4d55725527cfb3bd516cf570f657727b7aa9aa83882463e40c8a0f558ef6c5f185fa71a2cd3f6d23d97fb0f731ca939a83448866194894380ec2f98723493ed937a9140226825ed3539fe96179bbf7661e1bdb34edb9a8db69260461e2f9f6eb2cd64062d5e63f4f257bb44e257f3ed66105b02acd48ea8d358f562b6be2171acd1e46994f80d4e6f79b6fe91e0c6dae10aa6a809aa4f26c65817430570ad0b56f8fab145622e98ba6ed327a9cc2e401844bec9cfe79f0d8af10d9dcaf2fde9bc97f65b1bb6dcea588054c5c666141193c2991ee81452564bf0637b2f8ec9adb917c9df506b0ae370821ef2ab80d96f4ae8c76fe4898e6449465c4901c322525a7285aa2cc114c6a94660b6d5398d1b2cc66129c13fb777c8b2214b20cb9783fadc15886b75b53c413de2306e4f7f04e4dfa42ed49dacca020019ce4bc6fc195523286cfc77aff93feebf69e073a0b303a262d9dd12ed005b9e98bbdc04f876b332c1176455e9116865f0e3eb1c8f8d0c4201a523d5fe845f98b898182c65d42566ca9a0c809d5ff0af021a9b32e35270e6a327bf90b3d98e98fe569ebe55373ab70810a432b72b038b4378e49a8d05c29f0bd6d14d68ac5ffb512f64877cb0002ed79ce1013534e7255847d5039c4536c11dcc17027210f989769399a5247b14fa7a0fcce8dae3234b154531b9c88871a0a3218447f8c4645a91b03fe72ee99019c10f03bbd0427afca955971f9766ebe3ea4b7d988cf792f0ec13e26ac8d3aca526c0fab2c8ae5b90efc51fceb6a2a0652105bb7384248fede17d7bca8149eba9953edd07092b2e42a88f714dd3845396fdc67b28c92c35c70a66721542cc4f729cba4ee065777fb8216b3114a4e5d0df69f559962a9aa16762fe404ddfdef8f77c589d67d0cb1885d11bac4b3b472ee910a733323e44c081d21b1b42d1a898012e34d0b7fb1b7d7a14e2e3f9e26ecf85da13e07ff1af2e550dfa5f3868a5aca0ccaeaed45aea31f8c30ec9ad539b50697436c879bbb853ef85787e67750efc9a50e032ea3c9563b6ec066f90cd1d3d2798953e63eac50275b7c92ec8254151f0389f2527192a621b7d63f7928a575dae7b563325a2fa362aaa3446a465dc742b361656924c29a8aea7a06d33e79b6edab70f8bd80b111556c6d4ad4da267653e3c8a9aae5d7d7f65da8aba99927baff98aa4df1f9788bc156d2a754d3d1dbe901d97f29f26c4b46613afc5c593786ae7fb0cb7d886447586f916e2fe7ddbad1ecd3fb5bced0bd2588b9d4e5d63eb2d7f61ade1700a56a8974eae180356175719aa1e57cbedb8b52062df08b2234983e53071a0e0cd32048493637bdfc763d35bdd69d657a2a6f16ce046d626dc0b47c8271531bd2deafd18962f1fff189face112c1b26f40039175ff7febaadf304bcb03b2823a29cac3088b39915387df2fb8f269dcc82637e80028ee52492cbb06b12931358f68e101a4bd2f8dd1e897f01ab94e238b526f683c407092546bfa91c6ca5a25104913f64f0d3b1f98221a6c200a21e6bd21c5ba31b7f4d11be6aee45514a662fb1399aa09ec0d4046189d27ed7218306a1c1621064414f4ed8f08e02b1102df191bf8ca352af2635f737b56f7845ab5a022a1c2718ccac7c488fa7b7edb2e7ed49ee6bab8c0dfc597d6ab66dbe1c2eb0a37fb381f5acd1e44c04574d45f389f75cf033a6159a554a9314716d8bceaec78a38b62fda62bc07050a6d579e4d92c64a0609bf3e46e6de324f576af91ce7f64dadead252f9749e03254d56024a0a8978630981b4bee497c28d227bcd4045c9e9dcf7466244959306a889bb62471797eef1894d7733a2fb8df0aa6daad51f005207bfd17d1d8472a32876c360b2afb4504e28561fc986f8236ca2cd7fd60c21ecfd96e10be1ca42465b24e291f9b76e537a770109ae947963a8bd655fde266e2a77b480199b62f3b53e5a244a0bb289f115f505ed102fd1abeeb63b9ef6fe9d0a1ef4691780d8bf76f3b07fb10b13b1d87b701a928af6de9b890677d9119cac2171b0160ceb2cdcd083b7ee90a5201dc7baf11257cab42f097863c1b40bda15ead43ec4d6f7454c1b84766094b23ba19bb14618c2e66bfe541b465bd8706f4a01bba0c2834402bca601670cd2a31fbaf9cab8f7453fd60128aab01139740b106e454821796c6db83306504f96c9915ef45b13af09b4bd254e04384f50f93d8389e41b9773c494fc892e02db9289133586cfdf5bbff929250a2cb482e89b3a63202cc6c76a62e101eb4807a35d8e707e5bc168f8c94caea779bc1e9c84b8fdc13430459547e0da8c5e4a6e9a2176716924924a0901e421ebcf9926e18ed8b6b2c8f9518b83183410d9438cf1853a55554554b70a954d847982f053e4e510655f2c5c5ef37bb2c0990211eedd5be500110577fc7c0e4f78dd56d72aadb36f6e0ba49cc89c693add6edae2180cca9e65da9d6f4bf05f4839a20fdb17857bbf05d1a95c7d91a10eb811f88a6eba8e074d3039452646afd65f047a7d15271571116fd974dcfd48f3c0a4e6d2847bdd8e39591d0ad4b4d1def30f9f4872f00a2135b112a2ab5390fae4fd7817701f5b72f7d24eb549b2f7b517fb675889eadb08d52eb195c6c9826ec6db53a41503b1754fab17d0398fce0feb1372a9cf150e416540c92d9eaeca895f65e000cfde50ee7383776ed8997056736582352dce3994338effc49c3a82ae0a81e7d7bf37a890856e5a29b5b0d6ebad1695b9dc546e92f836bcf1fd1a8da501544d52174d9cb6e214e000a304eccb2177dae3c70f9e11788065c3c9406507586205e87e45498698e798362995241686c6e9bf13ce6718791bff3e34612176f6940c84835e586635faacb093b5bb569b8e5b2deb731da72a8e377440c4a2ff433d7b7fe7afddcb5811bea94f476f483951a80e151179801eff3b358695a11306b97619c67d1a3ec7c60cfb005a7ac7dec57bf55978c14b8ebc1133f3eb28f6d5dbf32ca3478d0c728c80f2db20280714066a0043084468c1a54d200618af3afc5b2079ecf65cf49828a78c307ff2059d687e0e2c65da093626ac7ae2d9bf8220bc1b07b76484cc1cfeb6009bafc94d72e8470d75d6a39edb40d988b181e99cdac58b3faa898d074fd9dee2fcb3a63c2ca0f38d38ec99a2b5479970006cf449a651b025898977a494bed8d694481cf8095c2669f0b071e571e075a61be57d02d8000cc528c7130f6f43145c68a6009a33001c41bb8e0bd49a9a74595c4887681fd732dcac51b61a1b7b5171d7c8898ed99bbabe6d45e02657d93d0ffdffc0ffa914a2b794bd13657ee9daff45a1217debfcceaad20715238d2b375a76660266eaff9431d419cd0e489cc609a38de8143261705cd2ae05a538e6b67dce96a47cff117149e1dae51f97f00fc5e6dcf6aa9bdb90fc893e5c89d330eb0c67ad5e58df3e17d4bcb0325221bd3d7b01ec0659e15fdc1ab0e234ed1b8bbb19456cdd45c11a0da5fad64459198d3bf584786dae7f123cd333b4b8f0189c729c2fe1ad9c131d403f1ea3de71b541214c37db021f962d8f35e86aaebd05e152b28d3279fa68b23a8f058501d669578a1743148e21dad8284272820bce95b12f8c68f15d5a0498a205f59684f75c5d5239a9b376ad0f791be3d174a173d7f1aa67917974afd5a6d5da7f71700910c25aac6e2493d9d3c885ca8ab4acad31dde674221db8c94db8032c568fe11bd9493686809ad4e1e7fe524d7a6760ebaf06c2711886ed64c767b2073c9e282f407873b5e8149e04a48445ad4945c2696a4bfefd99a48270dd772b69f5f1ed9be8ee3d221b8885b7c801b425fe4b81a92ea15864d95f990640114d0608e3476e711f7891d47ad40348926e3a16d6fabc278d148f5fbdb36521f664e7691ecdd349d304ec51e02a11f819a035a80dd1ad21b16d90561d846ccee3aaeb30b9ab3fec8264c49605bb4970bbeb5f27e10b5a25a4bf5af3e24faba989cd3a9b69f833cd429995590810b9a7396ecb9ab6f0f6e8e431d80f6fd094e8b9d728919916a645ec44a49780d5b51ad4d7cc131d9543b7ea48a2deabcd4b3a4e2a69535b5337127d98afd9cf66f51d005a864ffc33c9e9b281e2c9b850f4dddc2619c60e9a9fddf8807ae78ff2d9281675ef4a28bd41dda91f1ab13670322134e5757d03a603e1da62c08f0d230e3b8fe24beb41895d6614d8da8a6fa79eb3de85b8b5314ddca96bb5a17b727909d548d2ae1d80366e143e2e5ed535576a9c19b640dcd0c089cd1823558a93110c1db4daa3fdda0013e8d668996df7ecd1e92f4ba930c6fa916bef6ec09535bc05035318b34b1f45c24b40d9b68cda223b84f91c3af95a1224613201d4e61ffdbb75e6f1b8555ba03541bb9ed80d97e9cabbf9f53f3b01b5e8dca391b681f5c392ed2ed5bd374d71338795afb713398143acd340ef9df93954e53c55a9626113c7c302f6a65fb3e758a796aaa0fdf578c889aa987cc04c2ed12a14d156891ee1087a706230caa03e4ff10789372f5eb8745a44d9d5f3f5f98e4f971bb15baafbd738bdb0738ba6faca39b4cefa8107b80bb09641d2fdb3b0db8b6f6142380315cad389fbf32d5f0188d2614d16bb64a39838bfa7530a48924e673fc84048e12f78515f2840cc6556f7213c2536b6a7f8bdb68d0bbeb535859298eb715abd11ca591109714fb39d26238db073263872f8eaa5cd9ff53a70d72ede0613f9c14ec7b0f76e87e9337ee388fcdca0ffdce08a6459f2560e2c046c50c049a1cf73fd8ff8389efadfb9668febfaac11c2478f20e83a5994ac35bcbdb3beb71c815ee139a46b5df6804c317aff7ff0f2a398aeca967eac9e9a1f47f3b60f72f98f4bab23f41604bd02960e3238b51166bd8ed241d12fa96fded37165da45272a34a91255032c7adb87011884f609bfbae9835fde55cbf5b1ac2445044df85e458f45336a371907e1169430e5c2c863ee799db142b1322cf90762980e843d23451439e2bcea6f04e1978ac854787dbf70e27c8159c706d0b5b9afd7b78aa226e299e9ce516ab2e4772758abb2f90c9c5fa7f5e2b098a49d2eb51c4ad7ca6a578cc30e7806c4f9468de674c5c9e6666d3fe2db921fec0d0f25e43c95c753f3aa549af8cf0c97ace29f6cdfc43e0c12255c0e5a0fa692b11646db09f4454fc68b08eee97873c3857cce54c8dc62b470290d01d5de6efb199e5bfd249075d5a1cd438d81aadcde2e55bda0dc8ab97f776bad820c14e0beb6a82734c0373348cab09e9a72fb4b189a30c39b03cb97dcbfa2795cd0e203b0243ee13bde18ec335f45c880d436a34f2d068a7e63da07abbd2b0fe081bcd43d34d5125dbcdb5e5dd140b9888cc3f95601358a86f336f73fa47c7d1a3010373884f01c3f794c99f0df011356f857f10e14d5c4e3acfb95b2602909c2cb7a66982a292c31c3782bd7707d82e41f4f5a34dcec01bb49d6ff91c7b6682ab38588722b304ddaf5b4afedebb3530f0db5deb4e1731ffd998d7ba8dd9b3e4f5ad43c5aafb7ee764bf76f55cec3029311d0427cbf8c9909a4a57a4d9fa629a227af4ccac825cb2f5b62663bea06f7ad45d7d70d791bb61df2639af9bbec2cac1a4e80d3255fa76937d52b2c0ff63049f192d70d31c8f0888c7d8f916bd32b38a5b0fcd9f149b061eed48caebe9ffb6fdb941134fc24e6537b174e7aa19b08b1064c534bb142fa5d7ad6cda4a6fa7ae4010f9cc92f1340ec5cdd7463acaadc5bd30689b472eadeb75de2608c8a285d8fe48dfbfa7c46b37407c4b2ca8903c7b36f2c1c6d9f76fe1fa200ebaddc150770d8774515880d2d2c6b357f7211861fdb953a6a51b87bfa9289fa458c5b9afb58b89271a6e5020a1caa90f9eaa32c59408a73917f13ab9b1deb523a77dcd7b3751ae95ceb45ad04ebd3c9ad5810662c7c1d220289afb681b2624a5b15143718d56d1b3b68a8e2584a318cd37252a9d818de35bd5fc555d90104a33d3681b72f1a9de612ab177871accadddb29041a6faf2d470f43a9e19e9eb48a9c804aac95d6e6bed49b234ee1d4a3318f82a31c17b000c0cadc82287ea1b0054e6c7155ba691f6f6b02907db7d3d57cf3305d54ee77d6a5d54ce67a5ab65a2a02e1bbf5b35c27d64461fe3a9db6d2cd0ae65539f00fd925f10f6743cc4878391b25e71fb034d8e1b4b9ae19f57de55cdb32dad522a26e0d9f5d6ee8861f5da4d20b8974bb25ecb652c68b847dfe969ad41db5caff6a33795eebbc7d947341e648fcf44774da2d625e74d917a848a6b15f3dff1c9276bb47dfb1e651d9b47616bf6d3e52a9ee845c4d81b2fa0aeb3ec033e5b2ec2834d7e31ec2088507b628d78f00823f465c1a72e6eef2d618ef632b9edae57e7ab00bf60839519f1f3c1a40114a83533a851461bd12586bbd3118e7bc001a752eb1de7927607d384d852df2c0ceb6f083c016a55292beed0800ff6e38064b91980410dcc6ea816bf684968b4c4137bc69bdc2f66f4bd4a81745d2b2d0d5de476a300b7f31ef335f2e9d153e24ac8e600270d4ce678ff60d0b32fa5efe82a2a71eca97557ac0a8344e370541f223d70c7217407e5bc0904590c9de52c68304c8bde713144e7ec2aebcc7628810a91c1489416f4e6a321fb7109e8d3ffe2f3fdefc14eb432785b9d4f95f94abaa984e812f78d9701867f661dd41ed49e12106dd4e3a3216ac9553c12f860093c31fc41c034f177e3e0766f9890aa2e00b76bf7f19410782c4f7ecb1cbb4e03dbc50193965aae11c09f4c2881ce183a329432215c77d4e6ebbbb7786ab565f012db9da26bf1565f0b4bb377335baf49c743adb8d6dff1c4fd2fdeb5b1c848f1acadc86027b5eddec072600fb71c9676153b5339a90d69b4ec313c1a9c84809587935da2712dedadff2444069f7fc5e77e3c10339352712929ef5f8b35292b7a2f0a6c80f798098afa437f7b254e3d53e52aeb0a1db23f3b2e28480dbc3f48c867e4e385c4656370d1cf4083261d7e1376756a94d7666fb239c533d8ef491f52d87b5770efe83620d9a1ea1df90176fca15fd74c46720bdf4d417194bf691988581c753327c21828da01a2ddbda0ba24bdb3d0946be3f32943f46294d5ac6da6003b108a74c8223499fdf39d15b8143c09e29e61a1666f2dbf7dbca4d28e79c098085e2e0d63b278474d57393ab9c873a9c69afbfd65040346049469dd0c2a47fd631fab1e5e42833059e8a5966686d1b65e0778c8f0828a2bfb7022e174ad919b5b41aed05cc5b445349fe82eec601699498dcae661bbc1b18fe4fa94688fccfd7e8055bdb121dd0d59e9af6c0df4dd42689295ef939d564759d0c09440402baa8280e19fae3273053ffeca1cec7c1309d1517335e8a8dd0417471e497b4825b1023f23c9162b12ac2136f724d7ed6c7d8b1c269f67b5516180bd89e899f3686a47afa91ac25e8bb49f6f170341fa56af4d2c9a83a275b73b68d8546fc56ace629ec143b588df70b43b73cc0552189a3d23ae261c6e319b892bab654e2ac8308758b7316083e6f58e918c8e89eabbe6bb9781cc77301a024fd3cd75bf2bb97ff1462ca073e0727b9cb1e0b7f8caad079e0a4e48707abcb7c44a475b579bf02dbede1bafadccb43f10c406aaa56b05b16e00a95054fa3e4691c75bd337abea488ed87d81a5a2c296d91f5e452fb14f44b14df2918076b92152b26e111d29007b72baccf8719acaf56426050c05805d00cc4e403ba8b71c6ae1cfa466f6ef48d3696608e5351b7574a1e95d0164943c3c92e3d454fcdd35d0d5b7ef2d41ce10324d5e85f04396654c0fc59f836c3e228a5c4e9ada8fde71a209998fc3c1d2fb28bfcb98e23125305f049875e44b72a95c81cf5f1a413c829afff5f8d844dd5a276ce2741e2d4c56a6fa8c671e2b0d4bdce9f4649fa95948bd82c0231ff54c9cfabe5b1745acc433ed4d9290666f9dacfbec61a3d85185707e8209ead58e045e837208f5b1da800ebb2ac687a5d1b4ed8ac58ebce62c9eeab6292023662526d81fa205151568563250033c304b5cb808a509181a9cec775b189ba706272e1ad4c04f51ccdbfc0e4089d0f80dc050dcb420dbae0b9a93517c65ba3e2c4decd2eeedfb839d9c5b8ec5259f744524f6dc5a7836326d2d83aa8b398deecce7af882931cf80e768b66ee2be22d2fbcedfbc955e0f070466a765f83d217e25990ba95b1dfa54bc1b063e27e07274365a64921535316da5179040ae808dad8a3d7352bc1c6d010c01e7db739016aa57a502c7287858e77361513479da0d5defc9dba57a8972fe7e2fdb94305125bac99fae69280133f046af0a07dd6feea8d4dc8670780881d6f8a95baa2f57dfb4dd7d4a16a69f394e9459141655869f3c3202c39739e5960db119f03a864462868498512ee11cc1a7636bfe793d974cb496d05245ddeda333c3d4e8d9f08b771006fd4e1b720117bb9fcedc5f1bdc7a5874f188b2920f2c50536a9796933889f43a09183014f4cecaf133d895cfeff53d6f89dcd9584899423e8c75129c541e907e93906ae2f047fc3628dc5ca420fb437248735dabe74e8f8ade469af6a302c4632e8614642a510be86a45199c82bca4671705f8dd24a8515935efd3944ed2a9d408d7e0d5eb10ed792f493c6ace826f80fb5c42b0dc6d1feb47bb07142381eec97e5e7d9a8647633ef439c70f5e67d6f2045d5d0e15614b2e3b7e6532c8b073d9c0f7c7f506f4457c77d753e9b525ff72d6a90cc429cce9a0b7a1f7d7dc19b69fe26c6dbf587beb12d9976fb0b547867353989f4a767776e36a5483e31c60a410f4f2f40fd49089d436ab2b45330094feadf6c8d387ceb2ef8450107e257be2d3194e812671bc86b993632472aa01f8312c55fd51e9686e173e4de1e9a3863ba2d73eb6ad376256e8e90e472e7e11ef2574e46bb9f8df30996d6c078d3af0ac86499ce6751213cade9e0a8bd02e36bfa9c058dd01239bf0bf0b37333af9d319ad9b7dd21d0d099676230f7fa5a484963d5963d3e32004e54663abb29b09710b476f648636dc04e3021e31e8fd4fb08e2a7e857b921fcdf5f8bd8c90b93f6beaee7b478dd32fb70af14e3d898b5fc110deea02a6103d6f5daec70ddb696fe04902149e5daeadc73bca4dc7c6aa9c8732ed10df0126430a14003d43a9f843eeba48bd439cbcc181967337d167b2999ba14ac3563c04bb517922fefe0a95ab859c9eac8fa5405188d1100ec6c51e656ebd1af99e80411e47cde908f75f0ca3c2e01e18b5ae2120be1c0052f2129c5783b8696e62ad9a1ce8f0ff1ea24b544d228a9b8a49805543bf518f9557e5900c658e543d8d9ff0850b30b63747b7282cf830e8a55bb400f797a55a1a9d11c1c1ebb5ce40482d4d859db42c2c73d51036af7c7046c2d2a10f53169e6f947e2702bb9cb31d765e0378165825bfd7102a3cf7dd66893a9bbb2300b60eef0225d512e704215fd26dd7b7a69d9e00d65e624f7393cb59d12a0fe5c5bb1163132a6ca9be557a65c4f510888788ea1144d576c7989ba5794c062269357f7ee2daa8776d730efa6d04d78885872f6c0c9fb6100a3a63a4676b4239f4f7e0a2ee1986596d9e94cd787ff4acb103ba91b852f10656f11a55f00f534ad23e7d7f18a7284258a5b292783747e609cd4bec48a5a1c5a6e7f382c5ef3ff84ebd3ede948b5aeeba70b5cd10ec794f2a621707c6e493d48e90b34218a152f213ed50dd0089dce166b6986912042b01df13ae0ee9957bd12e868725000e122398093dc6ada825defea2bf99718f702eb12d9117992da462a74520d4effee409a5c953dfc7b26a051ac3a8ed41cab8418120e1e1b765ec228b8db9a6f3c42d9c9ee69fbb23652bc88e72a0dee0e997bf31f804a0c97cdf08981c0bc7ba8e63526e87b08de58a2c654983f2e19cef1ed0f51bf9bb9b86fcf715bca021180aabd630690bf7a7e50ceb9229edbbae4254b4513c144affd821ca226041b346cdbf16b41534355adc1ce972a072a435b07efb5ef67721c81f2dbe9b3731da8863f087541dd94e47bb3d98fb34340d3962d92bd7f5a4274b61d55c25196e85c1dacfd29f281701f6e4876e43b65fb550b76ace04e541677a639c299566fb3005baacd0943636bed0cd951e0aee785ac48044115aa1e0d3efbafedcc3bae65708530fce43386295c8387c4c752a417f31849d21c3bbf3821053269b5b906cfbcbe25de45e080fb1d2fcf53d71b088a53a56b41821da854f048e604ad0ab012532becca98707ae993ac5e830138fdeaf879ed247f9b6f2842ff0e5d0a4733fb91a94ef576a4c1a0df20e3b53218f67315c135aa69acee230e3d7273dc1cabdeb912c05a02423e8b480620587802eb9b7c25ab6731da791980282452e9966a43ca682ade0bc4df4df3a7f63c1e75938b1f5aaedd5563f1813753c3fc95e1f05a63f8aea4345291d760939554214510c1dfef0d111019b3ab5f543e8ef53c07fcc64533529127bde72016fb0f0ad385786c09e50c11b6ece00f126792e6bccc7e15a32cbb2af0d13e1d3e1ccf53a26dd9a63927011150aeb1593962bfc9f2f4a9d01029472559a67e0aa395a5c761894f5e6124fe611085a3bcfc770555b33e4925537b0ba4af195271a36a68c19cee81eb85bd930b64a6964fbd0a5a9c28fceac4089a7b94d2c5ed5fc13dc5845bd195a94e75f1c2adfbc77232e1e268bb3b60bf78d3105b013d0df3b01cf9fc95461975c01c1464ac68da1fef0f2b5cc1f99a76782a59068d493d5d11ee6698e88338c884f1eddb13250cdac07dff2f3bf09e64e1949c0c817b967c5eac0ba6c0830e6bc53e1d393aaa4832d758fba0f0a004384d2f5be406414c42fb5c9d9dd0e9d4a75b4b3be1b39ec5fd75bf400f9ff6eb226fd7715802cd077094148dd3e22a929c28ac43186191759ce4e59086091b89a4738080e65839c94ae44bbb25545247d58733e7d74f72a3922d1d5586e012f140eeb78cef6beb9481e0eabc2fbea1fa7820a46fcaaaf28465a0adef6f889c757bb4739354acdbb92587cbef4633c76b9bad3998da86c10455bc3070f4c6a8eb6ed499fe6e1116193a754b4b82398b2106afd3f6a9cbb827f270a4d5ce07466eb785222356c01f01578551b0101be4806bfad06e2ae652dab360ffaa44d02899025420b64ad1e32f79047c439ba48399063144bf8ecab525be0814e81918a6e8f6044cf7e198949407d90d146067bf1cbeb0f556ea978ecc7a7431bd624c4c39f7a78d329c03a33532aeb388ca657764c6c91636b4d6476efabf607d367a0a12aa3c73d6ff433264476c823b55e7e2bee9fcc4b577b35d67bf12d871fe390f0e315ed08ec30d96ac172802e963099e7d96f373e93c7a34ca26ab2c01320f6cede9497a4733857d10c5cbfaa6afe9958cabb0d78063822f3689d85f5d019c6bebfdb216ba570e58980ff8086ca3bbf7f609472973605a29999e43557477daebe6ed14cb7ab25a41a1087a4a9e70280f3d56ade0e133dad2df6a78cc2450e3f16dfdef91f3fa1151fcbc303766d035a6ef770561535a141d4ee47f36f1f98547032965326048232851becafebc0388d0b21709b2c6499828c7dcdcf4da8afcfca5a811eaa589f2f566c82598d202eaa86c3d4d22f42691ac8db19d3c6f9cbf4bb3262c094c756a7150092b064b19cca65a09efaabc2031ef7bc40a8cc40d24618c5c56c4c05f698ea27e48e420cb96c12980f012cbdd897769900228abace1217b074570578b5fced66b7ec5b4f2b3336ddb659742d5ea1c266979ce3cce1cac35642cffc32ea12e065105b94450a6050df43291f1b6c2a1e04426cacc4f3e23890fd0b869f294cf574c9ee72eb5eccff245230916e90059ac840d90eb0da80805f05ac0987a140d8f4f2d5342f38eb0592f2d68540050ab3ee59905869c9b8240b925a5abae6e9d561935255bc29f203a34bd481edd8032b443dc5290dc2149f6e4d068e368196e20df3f7c506b310958cdf7a7be167c1281231c90a5f27ce84f32c8e20c8756736355919e5272a4d34cff1b181f89ff65f067fb036a3ec0e9999a44f60bd9603da6e530cbe0b10a98a12f03287a409dcd563571fccc29f695be906f9f3d4f02ac1c1ebf4a8183f9c0ed04c4c5cba02bb819f5f97bde99bef7c030549c6ebc061a87c47d951ae7ac20e9d9a87af502d0e38b9f3766e7c7b1d6de8b631f2047212916c257d19a33aa19122fb93794471b2496973853b051c71ee7ad81aa36783a41f346d6986c50ddda492b3531d49e16565dd22947b72ace750ce3a27185e6d99ca80db9f8b9397ac5d4bab50010119415fee6dd81c0199cb28fc2ee10c3df1a8cb1392a99a7c73393a973e9d661822417088a0d73fac0d012bd7c4d40dc59fa7a413840ddf39be0b3ec2524ad0037e3002ac4018e718240822c498526e6036251862537465fa429ea487da6a2ef4e8d7df49e40de96b2bae830b6a5cfd53994dea75acdb58271d8b9a0855f0b0198abf8633fc4023221d245c922728905f257271e9fd48643241a06e4e546d886c53b9589b669c80e8e222abb4be4f03f0bdd27184b829922b0beb4dca345087d665305ee6cdce018238cbd4fad887dd8dab046d9381f93307a097518e2d0539e77fa99a50771a557b7664c9b6ea52b2572b9f57beae778a3379144de4493b833101455596602cd7dcd635dd9860e944f46aa208b6542b5c80a121de0ea2e2e77b082c89779f3a132829dbf8aefc416f9230ec652a4fc8534ddb2903fd155d0bb6dbe7df49bc4220815aae6b9cb17f56bdd16ce80153d9878fff08335a7b894a7d1f597a45f36d3d9bbf1877fc265f7b8f94e3239dba713a1e2c8ecc2464d7c21d4243bcba27160654242eed5cfab8f9ab17ad07a2393524465816ce80e0da07012120f36727b75123b24a7289c0093c2095b017747884fef9e8b37ae9d5d75ef0aef51e10b6ada49087a63db36c789ce8e495a6b132db751d699e86958f582fc0f72cbcd21d0908ff82b51be45ff9247e904404a0f9a8cfa788b9a24627a9a1337a7983bdc594c071b8e0e53bd85a97f9f70ade6b4236c4ff6333398dcb41632cdb10e3f6379a419088eef9f92388df50e14a4ffabf28800c9596e7a281796f43d2482c574a34c48aeeb2446d8449d90b0bd649d716fdbe2461a1c4704c933cbe14294b06eae2bde64a0b6ceebef5d4332f108633a1eacbe38543dbaa5641e599e5187a182581312e5cfd7c20e659aeee81f9252f953c1871d312591efe371b965404f3fe2328b14ef6f6d93c040d69113642651030d27e82355b332458e6ce9d19712c490a929c7e12689273b532a5a823af3e8be29b8e16123a9f03082a24ac9091d1b583e972c1a08c26f0afd7df7500710ff96ae10be3c005da568203c214ddb8d803efc3b347e5e3575d583d3847d7f72dde36240648001a315f6bd7ac47e5e8bd74ec1703b507101b553f3e836474aaf91d2614d5880864a18521d7805015a5214b20472214d279b1c25b11297e0a11d1f6ae72cb01051946f147d6688369267e7319cd1145d9b6e8b1186c88c7f0508f9e39e676051defc836ceee950e52c8b1deff20b2de83e5a132314fbd9d97aef145dfc8679867ed97867ed36f65e61b32015a2ddaefac99134430945666a607219ab1623d6b43a80ded8c26ee1053c571d42b65e5dbc0402d6c4bcb8d1b01138512b7d2c579702e36af8b4195e4713d1424bbc92744bef903824549ea3180e9b17339308b4f5901fea05c57a40bd0d74f1431d3ad2de4b77f17c24eb598b73b0934e29af205272481846bff8438fc2616854782139cc86bd603efb276c9989363fedfe94d12a60cbf2c944c21012d1d698d0a866d4a8d378d5cb254c6212d87061742df48d3bef38ab8d0a448dd25439d8860052e260ed28d0d0b5181a02787c7849c7f8aab4cd9f6cfcac684457cc62b48eea9cceba637eba7ba167767c1ce2e9a37b4237ee1a0b887dae92b150f679d759d46e26e197baf86d19579f86d68239fde9b7fd6264c47f0193ec7bb4c53c038ae9e6a56dbe8ef903b076dbf2ec4df2db541d24955404c6c63f05666813440c74796b2987a4d3ded959c7ffe46fc42c13644e7a04790418e401a2864a41bd1e582786f0f36d9d602027d44e536ec9789707c606b45451552e71a54f7f4f0ecd906a63c35425f32aecee74a808d79778797a4bb8f3709d2919f029a353211bbf078a8e3ee988f9936798e6fdd007561865eda7c062068149c356864c46753b779d20ee8e99e9b169f9ac932d1f85a1aaea07ecf9e61e87c69e2c9c42b3e17a8fa1f34c40013fe288193b4e2328671a04fed82f32d4b8bb92abfdb31ca14440979c82c184a6416f8776220a4ac961f8499df0d57bf2dca098ce7f8cbe2499d938c8943651da86864851ea120c92b1beb2582a50fdd8eb46d25861fb51a0908a0d1b54f768955642e023139db8ca09155da751f0ed3244ed139add28f55bee4ac9ea9083c9a36b9171b492f4c9b23422c1cabedb37c5888779a7d5f92a9a273ee8d15d1dfdcaa6146fed2b3403a28b5453efde61f20f8912f63169a46b21718e16f1678a886904e2ed487ab0678fea09310beec9789b3b6ad29828c82a9ad63d8d0f2907839f77f8f0c7ae04744da00b0cfe45f504b5b4ba6268f990996836870e610a2d62d37770af1d30680b9974c3b895e9e88fc65e3a49099f3e153a552e0b418677765dfcb57b01229d1e27e255090d7b28c56c63bf80636e6fca0bcc450680bfd6a49f9a95ec015faa2d381fc6bc82942cb347fa4e1fd53a896ace990813d34defcca9d314aa60feb19b6e9182597ade7d9f9a6cd8ea33e68dda934b53aced7c8b7bbc0c87cd8f74149548c02dc941adfdf43f3d13388e4532134690afd7b44a5ef5f959b401b1ca5d6283369e39bd8cc2808fac9ddad5d5ce23fc35a60f3220c3b83f9d80c56c5251e53eb56cd6f0c4643b5c0519c0a3c16542e7d99583ba1c93ee1b162e344059f78e67f30cf08ba97d05a63e051efa0316dafc5da47f533c624752ec449a2f341e6b9990e780b58e59cc3e625ec760371f2dc569d7ffc7087e6b77053a767e0cde5ce91e80cd31ee57ae651838cf77b1d63e9995b28245855b72963156b19800a7f4685de4b03be925be7a61b32fb051d7204f8f8bf1666785aa46a8c404769dc776692f020f83343e5dc11e4d24c20718dfda34289a74ff8a2ee484a13cddd7deda58fd9ccb2cea75b55e8d68e930587104c86543ca8f07199120fdb8da598f7cd5cda226f9cbfa5d67401e5c2827432d993104f92d5aff2cc8a6a968b7bbcb94d9ea59504dd20fd0f726091cc43e5e766cebbcf283cdbceda2ee271c1fee327cf4e62210021eb0a9db9621db5fe3c0595b0b7aee7bb89870855dfb2819f4c16bf4154199780b1298327c4f2ea90ef10067099d5e589a1cf49384493e04149a2c1b71ea7ace1987659f7c20639b12e10cd6f0151791bfacb8c1415406e47c0c9498ccbf2bcdb72371d007902d361ca57832a4934980079b20d8fe6df272704d1640b18045467c9ab98d23607d9f88","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
