<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"cf0e82b662fb4abdd77d3069c27255485cce9ee4d7946121edd4ffa92d36c12ddbcdb67f59dbc69603fc3ab25bc3049297bce43f7ddc48933432ba67716cfcd6d7348355d7c56015b825c7a30ea9299df3761b770ce17348b5db45bf2e6ee4fe15fbba0866bf53f087afdf84aa7e2ccc35a787372fb4929684334dc8eeb1761d7c93a272977b7b25e11d09014a30afbf4bf7401fff8467070da716345752d138871b3a0f5ce9821aa102a35830a30213b6e0713560e833ef2bc78e20550e9d284fb1dae8386cc865c607ebb351e05c5c86c637d24f8b56807c10ad3b759d9fa7332c4071935ccc9e9d8a65440e4d7fdb639b7bcd32b4331764889d4f8f05446aebe125a7ccdb10e9914b70b3bdccbe9fc3e32812492808b4574d612204101309a60230a469ed5269e8c579ebbbc81926fd00f0f821f22a462b64bdcb99624581bdfb8c2e37f511d77c4f3dbaa2b3395fc608b255feba4bd6fbb71009cb5f90a7d1a81ca85567378bc473c3d4243b257d36830a06185a7b17a14f423c1ec9af9a106bcb703ec2cbb255d4d34a4ccc13c893f397ee5f47601c6d0ba931bb906617d3c5e885310550ea454094c7c7a310f7954f4165ffb573eca63d03fc8e4f02a049158327e017b594c52c4d157fe1f38efe680c0e412cfade768a0e35e33735c563851b6821ea0c6bed16de062549916e859d021efce4ccceb2acae897867dd746430383641a1c972704c11ec774f9c6ad8bf09799db52bacc951f61c23fa8a60f4aa064b44300836d59b6d19116e81e913b6df5d57458ecb8a88873d042249174c69f6687acc3ab02a7d064942bd2b417b86594b70b71b0083d1ba8505761875418085fdce6eb39e281ae913690ffe4aa79780ee901fac8573a918c4f381604fbc829cd7472a54b68bc90c47c435fd3b461275f74a7dfcbd6f3df8d8144168ddbfced50d2492e2b523f6e80e49e6498a8a5779b80554020a0528cc240307d410c41c3aeccc2c0cd21b578f6cde3b5490ee461173a18876b2ea0283f7b4f0815b33892f69f0bcd5b1a6c83e81bfb6be7ecd24e34dc2b02681ba87850f4eadcea3ab49fb6b6a4d28d4a6dd2c27a9415818304eff268c4f82406d50d6b488b30b33c4ab83266b7157cfde98a72e91f6982ef09bf6fb5cf4c42eb6e2439cb4b790bbbb0fc942c9efbc666ab9162bcd530800208dccbd0548f9afef0a04ff0379903f82cbb041cd259d94bfd5498fe5ce855935c8d5b506aed24a3c1769594496030f65437ae52292e0339ce1439abcdfe4980f7947cfe03add80311c121f4fb013a7eebaf52958699281af19be487593c184d69219ad27e46259bb94349f793d0af46bf57700cca7abd6f3ae2f1ac85a19bf32d8351e722240f2df216144ca84efa5fd28df10ad97b2cb024555a13c5888dcc12cf02086d83e5dfc05d4516d830493835f2be1938fec5f6eda8500f492d49a8c58528a63471423898aaa10bb971769b57d14a0d83f859540b0f023537755c71e79cec7db1f939901935e882a3e42b7a7e86d1c2fb38517e4b46da5dad59683159922ffb060d09b80425db12b52bdc522871b800b074d68d6ba3cdefc4fe2d180e6e5993738835621271c961543333fb1d46812b4b4b0faff7d4028fbc7f65bd0b094e07c57f42679659379f93d1c882a0d4f634789dde5aa9acc3bc8fde8f90d253daac6e203b5110e0f50c83d776c5f8ee22897b0c4899e7236c6ba64b42b9428e455631d2abdc409abaf94a3faf40c1e94c61968f49a4e37bb78446c7950663347810fa001aec4e254aa4747ed0d347fd3ced4588a7f71be9e3e3cb66c70cb36d83f6dcf261b15104988b4bdeb175d011adf9a915a3e567987ccadd14b818a4d27400eace1dc5862f2324d87331064225e013b889920040de77f6d2098a52ee3f7a9ec32e77c54a4443c97f7331d652dec9547e4a197e24499da258d00e932a32991108f07100fad98441a488b72e220659edb37e0ba88362230beb06eaa2b58779f9a21b451a8e7ea660cdcc3e5f0faa56126d3d0389ba1a9dd96439758ebaa21749c7259c16539f23f4037be31a70f96d2614ec32ec894fc3f6046a99411cc985269e2d0dd052687f02bd056e06dab6cba65a6c6c02013c2a67aa7e7abd25965f37ab251e199c2db8c9a28c9cf5a2432135a885ea496dd5a2613f0c9ff61a78f01ef848c1249b943bbf523ae41cca47d06e4169d299df1c7ec5b7ce9dbf23c0eab21c9e601d8652e7a918c1bf63619a58ba104a3753a2242e14d8f803712c8d635908e521d2d4241b0265f6dd829557073f05c9c38b157a19f3b46d7aaa363b36ee957ef1aafc4d148b17377eb2320a20f5488933cfa8208f4bf5ab4baf01463fa2f1bc394de384865e4e86d0c6a08f063dbaca202bc46a82a19a514376121378899c2c324a0d974a59b164f4af4c5fd4d7252ef8028204578e095a918c5ee156d7a80234ad75f58a9830d95d2386ef9183a8b4e0bbfff5f00101821227dee2d315870c8f1c979ea1b298a5171d4494fec9e3c051e7f90aa6919e7d25114fcb70e61235e91cc94fe136eebcb082fe61b0138a0ee1fead10730c7f947633b5f2a7bd637a3ef5d316f7e9ce92a57eb2ef5d642a7ffab033ef3401e45792e1175be8ada1eef4addf781032b13490f357d76d6023183bba6e13492fc7c137428c5333ff16efbe739a023af9454e756c23b0aa028afa692477bfed70ea10ed2d4a242199f12fc75c0251443005a44f61a3ade64be285b0f9abff9ecd6b143084a11092bd220ec7713f1131ea417104525b31a0fc022f8a7385cf776b1d240e4829ca5c1ba736bfadeea4539822ed3a6d33d6421587ef71282933a0fbb109b1e92fd76761f83b8f233cd8c9f395f68309d4c7c636c0b8f73c666a800cc0672462a2486b2550c1ff2b6a030b87efec596936c1a3368789560b63f5dcce2722f721b3d501305297a80fe79821f66b790348870706feea7b7549bc77f069459d21ae35c27067a59e20ecac554d4b049e2a787af102f6d37d5ce11e4be0a089ba8653c242d207ed1fb36af12704506e3523b987513b2a71a8647fb31cac2bfdd4703180d41ebe078d5793d5ebc6877e24a285eee2e7135c9bb823eb0357b1231c9abb246def2b7b9363f34e4215e403f589239ee4d18828fb35347fccfcd23000138daa9b782cf918b44a20137f5f0515da619a120ea593d4463625ed854d1b60d08a158209c7d331e85568f79529a80e81701e954b1702caf5454511477a894d2ccae7eb18b6f0092872d7c9a3b2c18b9c53775ff186821100aa61d68606dbfc7645dea7485ee900faa32b95762e0a55b0637c9cc01a29926050f417b3f4018d5c38d51a33696248d3daab1814776b3744984353c6ae8ddd80af3a1d49e804c3d5003482424fb4149567b83c97163d6f33dca5566fc5e75fa5948308b169967aba3d7f3d72c4586a46ec489356755347d2179f58224d76ddb26fc77d271ac66dd8701be608bc510cea2df6d52e30988778087913656c6d337e91a14056e6db3cbf14aa93d99ddabdd5b6df4c61b3d9dd5833bc94c4e5f27550d780895322b0c16d7134f2b41f4651b06413e7580e571b55615c67b8950e45ddf751b72b925ccb39b8fb66d00ec763c5f6bfc16bc42d367f1ae82df25a5943a59ee68683c6bea2458743e643fc1ca4885dc072bc483c8005d09f4341066df59553cdd541c6e29c6da421ecfd513d2ec60f87061c8a7636575a2177aa2730368c8641b653bf1c01c146714a86c781413766ec10de9faf62e882fadea335f86fc37a305de4f6e915edf063853fd5b84fa6aeb2c61fd8c8c9a16d62d99404b68186b769cb75c9251b70e6904ca4f5a1e130fca43c8e744ebaabfaf9c2cff0a8183346f5a4f4da73bc8d9c9878baa0a14649a9a14a7f3287b02a8e309434dea34f1e20f482fb3ea2c23f185dd03b207bca21915d417d33504f925234e5d95132c43b265d3b7210c94391d9d30eebfc4c5c71746ec6500a8feebccd4e6fae73781d67c891a8cba416e778c82c042d4c0321a4f353d7edf8c20eefc37263442f0228b11768751283022a66e6544acb47af8cb0ab046f519e3f3cb39653eba8c04672ce4145be57a70357481b9f26e3316d0011988ab72e315f4044d50416bb09d4e0390225cf4e7447ab9a5f578d7e82e114fa10e80b057b84ba46f648ac05081ec7785d709336faa3e9723ab7b55f2cbd5928d31db89bd84a366594013e940f8fa2c9a973300e126e9d2a153ca33876c2e2674874aa516e0cd47891c4a1b4a0c85c6ccf87faebba3b13f07b9909f738f5f35a90fa6ba87b3b920341a32b9290086861c017e9510810825abf8bb89449cd11e7008d503f7eb68e5664f0fbb2d9fb5c2ce2929478acd08defc81b1e0e5eb3e2a50f59adc6dfad89394df5844f258a9bc4585a655884c91866fc4a09ecdeeadc9ff3ce8888f46f0e775ac32cb9276426d9a3e793980565c36ae55124fa2950de33f87449ae2684bf561067ab227d70e083b880ee1cf4bf296e25ce560ba9dc11b25d3af8bafb1af250d27d148255288819c4e14fe460291eaa08811487b8d3c0b8a0e017b5893f4c7e0380648b0280274e82a4505752e307b5270aaaf680e598c0b40bbea82bb435e7202190d9e8bb1ac89e970105cf07c8a3e0f5151af74385661e30427360f55230780b1b79a3a5e24370a87dd0abebfc27bc1ab3942b547bc66432a9391d460428c467323b7fafdaf721f4a59f33d73a0fdf6908ebff77e19fe4ee198261600674c5f59f4eecdc332b381d3a36a4e0670d613eac905dd087087a013c872a8ba6449204b7c4c13399392e00ca81113f326113ab66a0139b14f249d76257d9ee2227946bfc16d67e68024a28e65fe13bc36e45db16ecfc948d2d1e5baaccb30db8040af2cabc6e5613aac2fe6ad6e19e346196cbaa382c257f2e8e208a55f182249bf77dc52aba03d8a000f9766a92f0f015a9a3c6a633b08c456038670552f112a9e03ed866e1c5e5fc95a1809d770988cc8a723e56f7099b2de74a9ae2e024ab6f6fae9a3416adcce77a8a576ac321bf37046eb097b2de4ecf3345161223ddb4c1c974f2bb810d93333d8d968eb8f1d1321d4e8ffbcb7512a4b8c0e569e36431a779f544f51d4e8aded580d967cec4fa0b56e41beadff5e235d84de9c0d0e7bc342201323aa5be1acf1f10d905e5ff5d03efcae95f3b177b616d5b9b636eac2193db7bfa306c5a4500e119a86e20fbd6e0e2ec314720b74b7f17bb48ed1dc03038c2f3d3e1ff0043d52ebfa69f80238b18745396f51f3b90be8dd062fa848ab9b1b01b1d5d7e271d319564c10fdfd2000cd0592a45a54c1ea4703cee3163df782b1240cdd64e8a4e53dd444b370858fd06867119a42410dad0f96fc35a9c8dacbe2b03be5487b26162e512f161be34aa6cdcecfd9f3272e59f32d082ab389eb310a7370898ce5c93795dde2a14fe63d18e549821fef106f549b2d3a565dc961132fb4cbff55c7057d3d3dee1d06757ba9fbb957737628ea1aa74d143d3888c6a7727910300a91e0e704a2f9efb4734ac4e8a0e3722b1419bdc286495c5d232300bc675881f8db9f7a3252ffa2bc37923e0ca47e5482389ae71d9a452d008ee7ef7716cb2a0b731d7186e425a2d7cf4c0a6e9c23f1972a6d4312e159cda2ea392e1080b1854121ee67614b7bec254c5b4c37a67a4b476ddbabdf00d94b2c06cbc4b139893f9ca7b2616c5972a7d084d6f9cf1382fd37ede2ca10650496eda71c9823c613e22466682eb7331ed0a5e0f31bcc9b05a2cb5a8249fa6552876a8299469bdfe254aa542dc94053717c87e5c1d3817d67367185046192b3f71e8548a3798e40a40adf44466c377035456d571f9d679628eda4f8874017b639bfb7c2693acdd30939e4c755bfbc8d93d11d229a08db7c68a6104a986a5e11da74920cd52751b3e5bd7c4d020b30864a51fbae4271d88062dbf99866d482c94c002d0d2df1fb0be35e244d1329d5a936da469dbe188971702c9ba1f4418149cc2e8ff5aa08e74ce4bcfabd6a63f38c94bf1e28a7a0d8c9edf8dcfb7904f898e36f610a3f67e9d401e8f0d9d742d7f13dff4c16618ec2538e0cdab74d332d4810687d8b5600ae6b8d147d6aceeb35b39d086374e6ecf3a73e607d6ea6a2cbe3a98bbf8a56b06c18eff8796833d97a327bd29f871ac643cb90c47a96f691a9dda9a802a9222d2b76b17b45f502847d333b947a167420c01cc9064454bbbf5a31fbf8edf63c6ff0b7f23d323c6843a0930c159761f80255f8fe45e0502107120805600fb5aa10905b9b71873957706020650d3ed10ba2c438ad6603d0775ff8d763ab6a98eda499a4580686b22d1c366c5f6e92d9e9bfa1865176326f1b0341af09b2975c5fe0c0ca695d88fccd95c962848afde291f9c1d6da4edb77949f1f2c098530e4b10c7be3184f24409ec3ff5e86ccc6099f8f5696daf28f88450ce354eec5b7f1793b3dddbaa31c3cd0804dd1d4dca05929c00c87115584b541f08ffef1b8a35e7c6040b21af42340ae4262c4e33921902a957f28ed4a48fa12b54a1305015864efbeb2ac54ae3b2db9412a6b26b5be2406006a236d8df31dbf4b30f8c0c978c954c3f0d4aff59fc868921e07a01d085df75d6cb08c037f5606b43c346bb03f36c2d9bf810b03fa4cd241fb2ea950c8c300f7a7eaaf29246b29ea1722fe37eb28a40ede222ca790d37b96bd95335dda91523f165e758c38a6555080cd23a0eb3319796936725dbdfc0819338e58d6911f8bf8471d1b3307a228b6239c0011fc0b2ca3f672d4db8e00deb2c153b7dec4ef9834a1b373a1f2aaf9e5f1a080694ef56e4c2f545379cc0c468451fc736f94fca8b4a614902d5bdcb7e097e7c451496fc973aaeefb9499b973bf83bdeae7c866f8dac254466d7d957f01c53b4ca102447557a59462d3bf6ece023c225206e1ea514d95764958ae43017b1bde6287f83a5c9e6104567b8aeeddc7d0a0c4ad2a595e5ed6ac80b2e7a0e1fc72ac0d439c3335114d36918ba86d4b76a192d270588e8d366536064cde2ebd23d43a7b6e8c89916d2d07e323272863629b841ac88fc6631292c8e1ac7683b379928ed0b2b724d44a2bf8174cfaccb0b9cfec3efe1fdaf9bb1f6830f34fcc6f76afba61dfb8c9bb5ba00907a1ef3e7d97cc40c6ced51679e96ac58e20f3bde86111c65772a61c58e4b76bbf014df8239b4186dc308bc90317e74deec532217824ad25b241688ac4d74744bdb8fe7e9ae8d15357fe24eeaae645ed947e67a2434c98e4f3a093ce0e46fa3adee50c7664a9da7ba17f715c23e34ebc83484bcd1a1b14b441a20a32fcc551c0c3ef814c0b91ba21dda324c4903f383a2eaa21a316622716fff18cdb40d3e4880f43bf3611d76fa5b8c9096c6776ff83e9ea0c44a6f794f69b8b41945691956952eebc38a645870323ec4829fba4bad2db03c8e04c18d03353ee898435f780a087eff21e2f0e7cd25bf442be9b8bad60ea98079b728cee784748572d4566e0dc1fdad805f9a1bb70f43388b991e540332ae85e8b66870a6eb8e9901e4671e3afbb5696f5fa5072029ebae0e3945beb8c31c870360e0d93fab12936c008a2c7837bfeea30545c8600e86e91eda65ee12694d84c22067d860ef2d5f65d819da045a563dd1e5fa12013cbdae16d8b8e409bb56b6808e1f2b9a13416d2b0fa2770f9103c766320768ff6fc711b071a2bdce267421f3cfdb4fe2dfa9589c68af043f1bdefba33435bff3966356cd6be40d4f15aab93475f60edcbb6dafb591d7d83de6337a74f2fa31f93441c4d0f471dee6153c61297245c2e4a083308582ea453cf5fb91293e8506ffb829c73d5f6e4cec6184a0970bc29e060ded203b5b7d220da51a8ee0063abcea639d6466a3a2f53f7836cf000c1fd03bd5462223b5d998a5e29b1385594fae9d04221eb612f2514d94f37071ae5d7ef18f80acc8c24f25f10b0f46c2937bb7f31bacce810bd7608fa98e81a19dcd12cceaba8bf50dc7dea01faf49557b10d20a9f319a2c4f0425e9d9b6e89e1b5a34a40bc2fbe0d532054227a21ad00395a31e7847ea0a7857997052afd8813acce2d4ee3d03b326799c3b2b626166a01a70bde0b064a424851d7fff33a4729272ec5efb97c854929b5e23862d1d49b18f581e6f5c9512b7dc6700374c419a5f560bdb883ada01013c136008196d6e78a0d64320918dd0c0ffe91f283371ad0c3aa175fc0d28e8cde2d6c27b1b2fcfe2dc7d8212508e8f602edfd5f093b3634692712dc615637f3d4cd93a808bfa0296e0591735aa06cfd888f32baa4753781313d1f5bf1cac26b1a61510eb13eba9cb50908ce373628c4ffd6932f407cd4b108ea6b5fa0dc2d229026070ba92ddcbd220e915b8a3f148704732fbc39e4cd51144f3136d8ca17803d13136e3b2934f1cdc28a058c691fd94d7300d683a72baf53e5bcffb245123f4588474215879586b7637ca5f1780d37c37a0f0c0fa4f783bd17e60656568534ad1a8ccb57b374478e68f1a0906b25115fd6a8cdd0c2510971ca20adfb8792e865f20cb77fc22594c7f7ed183a0282705b6b7c546add544ec032ba27c673eb2d679d970a4b3d4eda46b57a4f5da819b3c3f8e6e427f43971d3784815a30c16e3c9d61bf72caef5a305d571a3ec86c44a4b2c5198cf512a8100a081f5560cfbacb6c8757a4fed4f81a77ac6c7bdf9d36d6d4906ab2a3c67595a95b14e13fb75c32fa87cfe25d41e9990cb94a4db94d6287a8c92cf7fe265f930ab7db6484d3521c6298bc6cb16c22029d625222aed839e7109bbcb2bbac39d59272d65828ddb19d41d51f7d3cc26324dff0bfa9144f1e11c3d512608498597cf06d0c72dd0293bd87fa00e96aeecea45ba0f5c8603ef67f7d22410f521bbfa9ccec2385e74a6f59b8ecd330cb876726aae48432d844afcb73099752936dd0a12f29d0acc218bae5af343efc4adab7d07de26d1ece069da8129074913af3069228be0943ce32b42b186d5ff7cf6fa961721f7d020c0bd6861e157f00e3a73c3f3ad3eb469bc4789ca3c73f06d4affc43cf182b785d8c9f056841ddef47580fb2237622fbcb8af705a3feae34a6c95d05b0dcafe3dcde9974a4b86b43e1e7be58f11990adca91a84433a0c07bf6e04b40deb8f6f577653b20946b6e3527cc0f28832e1e18b59a2e6ec9f4d8a610f313836cfd59ca5148be4ff6134ee0518146fe32116dfc264925315eb4bef7b1eebf011a34f2860fea4bb5ceeaef5fced8556de95247eba8dd356df56524ac603f2de7ce3a93d1165c87472c088637bb9ad2815b5ca5dd9c1841d25f70f40c969f91ac12ac5d9f277d485ef71066e08baa183dc7ca856697c2737ef59751eacdd54fd08ebe63bc1af039d6db71e3329d20413ae183ca0bdb21704be82e2a6f7473878ab49b3803404ff0ab5b00a73943989193c061c945ec6f187c6abc890a11ae1e45dd3d2cfc24712cf33a7e61447f95f188edb594f5ef404074714c13aeb228754aec4c50317cad0d6309cba130410a94fc70513361d91b23254198ba364daea9697f884e45e723ef02b4ba2e7cbf6df0fc7f02cf863b18075c1e9826328f04881eb9b5e9373f88d0f55928d106055e46a2394d4821bd290cbdd09416f2753e184ab0bd4af31e1bffdc3afcacb6fa328c0bf430738cf5331ab8b2da475872cf6ea34a6fccc28c4eb247f1c21485594bdff9814b912202e6c43c88f59302f91bc1a808d204c8bb891137df95cec701c1d322af3647e8eba9f85e440b67cd637ac4280e1d2b1a57ee2c43fb2787f0e4b4cd79379c9bc8a1efbe4aa67c852da11535a2b83b49ea5b8cde032381eff2aa73525fff82d8e384dac60293e46d765733705b7c8834520f964f03496baf219843f18192d819687048161a9a6df3aeb14d5797c66e82d2bed65fb851424d79083ee684ad4cc57382b1e918cde194628e0ce5a7d2ad202a0770d2a343d1ce8b412a6a00aca5e1449651e6c8150d03cbf1a67c2d2280e66093bb96ea2c0adbb377e0ef39da6316a5e2abe7ce5576ebe10583225ea1621d633723b3fc42161e22c3dbca42a8b32385e42c57ad095c2e09b856507d30c266124c9a14eef5848d74a0ab159d873298405630e820ed5530d0eefa34fe61369abd25ee9771b0d00d6e20e375c370202133e4ff027738820a3bc72067f0afa6aefda1af244b2e8d61e26f2a6d84602bd13ec93d03cac11774ca8d4a97553c5e3ca663468e7544aeab5192892a3f5860279922eb2db0f413fa15edad1c4554029f7f280ea53b5dc913e46f942b20ced64fa79cf077fc03350786cf0a899bafda23b961c33bf04fdd9e8572b8a15e4e710f7924d3ab48a979d8a823a1a9bb1c34940329ea6f39281e76d661e09c6bf2dbcd0e56f635504b57658b5199c874a56f2c01b0fe59b48a11f595329fca326aa4bf34240a315ed31bf0545719c7b972922e601bd7fc18faad012b932d6184fe9939578bc4fc12236a9df97995df83d8b227a351d2a9dee3ad4fa8237a7cd93c7b1d09cf89e5ccd042cff719331126c33734f6c987c5c36e1be96d7d69b9a35145d5b9fe2d0062f4031c82b4e6464bc87c148a6b40526d61a670b1013d47611df2e62e936ee6892b0f2868a78095dbff0a608925516a44a009b1f1237a05eca2a47687da48da68b7965d367b979a606c907f78f1b71b21a52da27b0c48f781482bb903ad1b2e78d82acd594fdddb022bcc4a7cdbee6423e5c050f350f58338d1e23b0fac1de7756ae4ce2149391f85e585c2e3e35558aac17d9cf6528f1a1455e6b0d592729d0711f8adf430dc7eb736ce4cd3def19b3bb6a861ee715ca14291329091783a2f68342567d08ad258a871b5dd582bc68977792fc894625646155f9edb02cbe459815a8d37c6641341ccc783db8d9da57e429c429238cc4efd5f41419043a9ac68592d1bdd0b0222571358a110160de81582faedef4d7f870d3d3488c6deb5f04daf40fccfd9ac9820e3ad14c3d29ab9325782a0e28058391d85c458f41b69b9376eb41349adc1cda27d53e33479be0d5b6140d5fe6aadf563099a8bf5fdba25491506f4c4f90994d09eda65b1d45d900c810d396bef5eea822b6662fa6589dd5cac3b23146b31bff356063e60b4b86878d600c525159ae4e8e4f2d724aacb0708991c46cf413d711eb851fe0414d1072d937d8bd5f62bedc630b81baaf8382aa1eb9b47b401ef4c0a650ecc19f43c1a30d0b2a8c17a5d9164b1f7ebc5892a881a6b1cc126fb674ba4ebd522d982521aa21d686ee6eb6ac3aac5673f166570446565e9303fcac0dadd0ef23905af723b86d87e31125c5359b457a2b623bf9d82386409006e73b0662bc7ff2c2385741e93078437d51958c77560e3053364c66b93c2cfd523c9e07ea755b0b2a76c2d3bc9b102d7af24dcfc1a4a65aca3d210544afca78c8f1cb60e3ae487cdb1d2f84d4bc5d539930f94e044565d5df8c0549f290002594b637632fc986bbd566ca6a8f8bbf35f3c98071154bf5f8a33b4b2bf78ede6618cca796eacd9061c18e738e175908f13cd27b8e1735c337773bf8144f0bd55d590602298ff11e2621f8ed1f4664981e85ac7a6400ecb84db26eec1b07b73d28d56d08ef1fb8381f0bf784d50a89703bc0bb98bfdca3c0a87090b4c19597f670b6dc4863c54aabccd876d33e68b482b1792311105dca7fe70ef579b127e734197b37a3686d6cf69a085ff7eebb4f48cb41578f2983acd7b3fee1c36905f02cf57bb5fb63cefb9d2be25770705dae106468b41fcee669f22195778af84d7e8d34dcb4c7ba458a34d3a1e6fe89a4e035f2315fdbd175bdefb45fb0710acfc4aec1b5725ef5e36a4640c938595b7b90ed329873b1ea303c9c69d357bf2f43ba65d04d2d240fc1e7770dc05cab5c4e40f21042885508a1eca0d343d10e1d44b9a2f6c4f2e1c4f71c91da985d06219ce4cffb62e3a2d2dc56f3aa31ec916fc2fe0e464b8bcdd9b61ef8d0b06e589d385e502ed8537a51ac090cde00c7b10f8edb2b6b60e7915f9282ba9b80ce4ef4cf2d5de168f567424acc345391faf5c0b5e4b8c071215469d404a8a9c3202cd8aea66cff830cd08cf66af0d9231e9bd3a26c060da96a09c342d7f1442753c221701d40a13769f397531fc22db21f84e81932fe9c0ef90ef39d84f7268ddd93e7166a7a0f22ff62f9291d1c914b0ceee8f671c83d6eff8169c8d06022587596b2f3bfe708d7b9c621f126f888a91d647b6ad2f9ac1b3fc86a028ff31a537db41ab28709484e10fb1a8e8e87c55f08d4d2af2986eaa40baf71d01ce0e1f7bc9f2674351cbdd94daea48ff080341a8f82c34e44b2f301b99475828caa5f84b25d85657e32633fd5ee22bbad8460113b993546a9f6291e42754a73b02c623317300d33dde5f67e8e360aea212c3db48cd7a7aa11b11d291d2d5713851d31d45bf968e98315130d4656c94960913a7989383d3513016f675d0289be74509d8deedc0258704e02fa95c661da26d3fa811b79838cae8a8ec2264280e431cfbd07ff0d6085dc7753cef1492d3ef20dfd56ed1ee86cac8c1cea7b106d340fac483b4fc34535e0a1f10e5a7737d17d8d4aac6f7061e658abe1825f73baeb601bfe1c63dd37612ab67a83682f7a4e7a81052c6e4077120338d137a2de41772543ba437f6d9c23b364ff0af416ee6b75774669fabf841de8fa301145de96702d17b7ec4e98d0b967982be3bd60dfecab21878d37822d44dcf7f3912e064132ba003ddb6e33787120b5faa4794ee58f561ed0c9e66f65c15a2468b98625ab4bee5d43f78be88ec9a56c9e6e39daceb0677e304c12451cbd8984b04268f271b8c25e4c7ecd96e4f12baeeee5bc53dfa19c5f554f8312f06d367a7ce47594c6a08b912ec8a4f1b841ec1e257e7907fe997f826f52c057b98ad9a7b452b19226c85328495afe6a536f7e43edbd66d36573bf3106491293c20f8dc6bc15a217a23fe0f5809fcea419ffd7d62c8439f2f0ba0805038778ebaf00395a6ed556406ed5aa7afd3564c8150ebaf4eda03867941fce4f6c6feefd8291c742df9997939c79f3d4d5fa922519999ee970bdad3c0608bc2766b24ed281dc2e9bd87880a03f43f45d1c74ccdbf2dd55fd7d5f45fdadb916505bff62f0f1a4bb4242dfd027514be2695990bfc7ca7372142a6bc4e877f9f33cdbbfd0ef9da33fd68a28ccc6b307185ca717c6ab9f9054f4d4cc19c3090a4c93035c335b50352a10673dfa9893953a28a932304b3daaaa2494735bc54e426bc2b9f5a0b6a90d29b65d3959239e36a7e9f8ba7f76bffe9c475219945ca498eae5781c089f218241d35aa5b96fe3525786a5f859d0604d4b7a4ec19d6cccb62d77eb31ce4c5c5f7e17558d0f72fdbae3975bf0bc79d37241f3e76921944fbb45f952252a0a45719839c7e779aaaa2933ab9a6d341b22107d5fa96f606c57212735bb686b135c0ce8a81c773d96bd36cf074a622f74b07ee3c9d8d25152ae61e69348435ba932b506f0f95a054fc4c2c07316ea0dda81e41178e9c312b8ea24e28826825720135209a85adab9e6d10e5eb5bb46dadc9f9c5d69e412efa66fb5cef6a30cc37dc8829e06ada95aff4a52f632ab612d9cbcbb0d27f4de44d18cb500d3e991a24226fcd81a37871b86a99b65eae04e46dfce6d916f384a537901783b7a44ae8afbc86e90dde45a4409e3d64708f8c26cf0c43801e48b4c59f19e5206c7561b6dda09f0161028b1acd50cdcb91f0c0dc3b7254a8092c6114dd4e160ac34b7dca40daa5f4fe33db5c5994e90d323724bea7946df3102cf19f579bfa82f93cd4f4896736bdb93afe17d90da22271901c0dc5e2c0761dedbb05fa3d1cd2bdb5ac015f1b44b3d9c44515a74c03e8a1824eb2f98aed36f4bd3fb64cbd16cd5effe3fc2f3a8fd604de192c14941d6163d38aaff95b070e31019683550b916d4a1421b7fd8d3b61741664916a2d7bf5ef1713260a7029b074d47d4e53ed5a902f596589776fbefbbfe9c871b1bdb9265c0c34b98988370f92bf0e336c8f532a1b95cb2623718cbcce549286b7d6ff415b0580ac723f77c47e64ca577fbcddc3a2dd49162e01e352044bef4c6c1441b69b4e718171bf4979b3d47846aa075dbd0fa9b23d74909846bd31048a66b82b97cbc5aa6e0dcd85e4c666206a5263e9ef46da8de64789f64b281f0062b2f1fa61a0c37f8a277ae8bf001b5b4c60b8cdca450e6c08c710cc8a837b3f1cf7bb8ee5eb589a83a3cc33cd39cd33a5ea529e0a23090f09bfd0e4efb5ce1cac4893b4fee2aebe3cc0cb67baf07c27a992136e121122fbfdbe9242a4d212eb542104642ea158f3e4868581a881fd5a4b42e3b4d3719408460f02ed0e86d3b91d16117cb290a35729297908a14b518a0f253db6b1fa04e94c70a9df3af17ae470fb9b824292e35d7917a61e72c26f7beef26de2e3a0f2a0dd8829da1402c026db79664bf1844597d2b62bf3d8988966cb1225d990c2cfb86b7f6821eda6fd7fe889d0f2607f9aa3119df8eb19c9899e39c3a79243246e236cfee5e7872ea691f734d4e73840e17a854c0e277859ce0a03cddd4817d8771236c6f3697a7d69e60d2ffbdcf12a742f957016e65286310b02b5134a4ae2a219351a1f10be0df4c6ccf4c30d1927475b6d2716b80f012c2172159dc8014ae3d18a8e5e7aba5c0b5aa3604ce6d326f93c9f034c28b20dfbe0e34752d172babe19ac4e79ae6ff3f0c363f97aa1375d414fa21e3fe16bb7f5b55c87ce126b1ee9a052872ffd14549da327826e907ac55584fa647369e90b6aed54e8f87c0966f6c5101a41441c116a317a00c172dce761284ac0e3373763a4853f7673dad60d9e5f538c310ba14076e9b84a4de2a88f2544208406d3a4a725614a457efdc8982c44260b9db361d6640bf8c620153c6af60f0c69e1201ae3f053b48b4c20c26aebb7610df1173885a31bff290784980be3da2b18f91de0f4e1985fafa4f171820a2acc5ba56650505511e7ef88e29036c4b76f97bba4ea0b04b89b7d1fb7684f2f34239b75adb66f0f76a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
