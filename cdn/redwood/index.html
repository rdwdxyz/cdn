<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"775b6b5b8b241e4618f9c58f0a0a302f7ccec6a2eee221fb21a6a4b5e1c93b249012868030c2d3b63afe2fbe0716baf848fff28df2eafff24a0a6c873a95578bda9c17b35abb94c54a3143e208c1f695a89d7f428d5955c649ea96101285cb40c8424f2123452b35effd2a5ee18f48c9ce4c358da64d4db2e8d20240b4103fb5dfd1bdc66abefb0ef7016d425bd1c4c61e504ca3e5dfb81ea55403f29d0689b03205b66dca55dffde072ca8d01e5a4a09136f0f09f1c99dc836f6ad5418f902e64407c9abc1be6413d21f604e5405e2a820278e6c1467f155494ca15c4a744fd1714a3ddd2368bbd3b23c7e958cddea5a8a09d37bd2aa46f9a40afdcb8a7e754c1f7095aee442bb432abe52bb751c94d33ed5fcf3b8f0d88c431cf2c1a40e63064ba11d948580f044f43e1c027ec294d678388b0ce76f731969575af904e253012536b5842e47c7d63459919a0ecbd57e7d42635cf3dcb9ea72a202b181026ef7a5b2ba5c23d28b72c23a2a6b4656444c91d6eb6fb434bf12b544af5736326fd00a2d30c93deffa736a8fa3562a07ef91c07de9a0b4dc46cd2dbe12a56c12a1d24752be09f873997b414d25ebe60f20392ae8609bb8fb2dd10f47cb335d4ec143f20735ea1da2e19020e3db2ec5984bdfc5267ebba78d72b0f500620dcb115927fe516a5c02176a17d3d7712fb3bbe6c42dfa6cd1d2ebe2ed337b885366cdbee226c17001f22a749c238209b8132f90e2cc381b522b94b1b1b804bdc8caa71b2ad6b89c7331eee58120cc70eaf0a69ac34a38d6b62eab81ab6b3349c09eb780511789ef3b6a89000c82ace415033e83eaf3e69f14fd0141f4cee74b565907fb903fc71e17aa7dcc2b0c7cb52e384ebaf008307417bd98c58fde88ab4d0ff4a65e0108ede6a40f531135991d8bde1a774cd7df45a65560b3fcf90bab58e72c0d39e5b08c047871a93a9510c5d68423409423795f6c198cf8aec629c9a14d3da05525dfc679d0d0bd7ec5c0f86edce6798b56598298e0a370a3e0a3c38a9ec019e5dc297aacf697c345566dba05439ce1dab8c727c8ae98079c2e57dc03dcf0a173a88cb1efd8072154ca90b89929b95f3ecd2520201108e34388a5c0f73cda7af950ab59fcecbf179e62f4be97106e14e94c08b0c65938d54e8765bb92fd87ff237724c44a62349021d90f15574b14d6ad8ada369d021ebaf9bdde0b6dee1987989bd4a8188126064ed4948f52c7a8124f28df8b67681ac184e4cf3d7a3bd70ec9c66ba992518a1dcc87560ed4b397cb8f25935390aed2d6ecbd2f385d3a01b8bb39f41faea55dbfcdb3f7f870e13e61d13d3642cbfc05d137e4b18baa3ab244c211233351f5ef3d0b12a803248f998226315cd5fb8699a37108cabd2d4a3732b9b2d21a1682b1cffbb80934b2d7f2b3f9da7f2fec3e65d5395b98c992885efb654ffeb228964d3239a68aa00ca83b9c0cc38bb28a3a230a6bbd42c3e07421ab6eaa1e401a51714f2877e760569711860a33f07e6838fba4880d327ead480457910b75f0a4cffdcc3b165eb6027c25589a093256a54c9b498bb644524e367abb0748a4c2268f4e2f00545707946602abbca5314c33a11ef65a346be5e13a6f44d4fc3eec22e587926166b9a1c94ae011de72757470f1a3b8b9aeec80fb2962890ff8f78aa9d76627076b4bea11ebce21b1dd323cfa7b9d110444d160f2ed831bbae4dc46ad599e51c7d761515d89c0fab4215198f44694a1e9a85502cdcf2dec8fe599d1014f3a796d254378895fb8244ef519b868ff154d4b0154cd1c955cbb5ebe78758b85596c9bf0330129a3086e632856559293fd52c1bb29dadf03f9cf3424af028a74026c25cdf53a72286245fb8eaf71d8a504fa95b73849c418d789d1b54641db4431877ebb3aaf6377df0e7465bc2ed203d6859e6e5c0a5ef1069e4330b00da8a6b6b091dd36c87b1f22795456948d1e24bccb2a6e0bf048d803067c1d16ab7d41a391d3c07a55647fc419594e31346478f8e81ef02d67f0cbc5fead1ac26b7acfd5eaeb16bf880f82df05d1ccbabcb2cc0f93e46fe7d40a26b4ba521b77cb70a224804a5313055e33e962b09a7a3fe396da7f51993edca9ce53540ccac96c97bcf010b5ed794eecace75d2e59469aca2a5d0442340fefed95f56e9e7a8283fa8165f047e18aadcaaf1851d0bddb63f0a2320ad4b85d00ed1c462ae5fd7196a8e54ca50a316565fcd676167eac9d3f6241e0581a37115cc4870374e15d1de433be07cc72e7f8c1511e70d73bbab61d0f54bb4dcb51510c934b9452edc1f882927408aaa3d91469e8d6d8e3f1d3caf4cafda6f23bf6e9957f6ecfb2a5c582e5a96863b21e95ed60422666f0e9469b7abff26f563a84910ce6afa6ce6153229479f9056a632841dee5228833704df411171fec72b6f2651971b37f0ec533699967456e7c77a9d799f13d3253b9258dee3603232c202e02caa21a8eaf06bbf35e183198202e7d09697a25ca709126b4159ed8422bbd9738aad6d5d3f2bcf27e54335618c0d28e237daf4b5c1389529d0e9958b2395301f396d35d51ce4e9eda893586f3cc8511420f90ed802cd58b666c8da3a5f42f256b99b8652960d746c7639fb8a9d060efda8d46bd3dd9997de5c7d5d222a71f61762f6c3dbdd93207d3f0d0357146b82057ae5bc1b4c490a2967b415f96d62a6d03918bf2457fcdf12c0a7f4c40d68c97d8d5156020fadda55df89a2c510458f622160bcfc7456ace81dbba26c99454fcfb6318d69eab5505a817eb58dfc5590820d8ec35a2112db89a7c7fc427aeebffee32644a87605df00a8151285aac1cd788d729d4dc4471a0553e60419cd1fea2a7bd5147928ee005be1ed1dece9c48043c04c0e7c16d18a3c3da0a444ecb935e285a49cc6651d18ccdc64f20c567cb1965f1380385d2475d6516656989f82983a54bfb76ebbfe385429f69be141ae3ed80f58193b4cf2f41a4492e4934c1bd3dc7f587ce0598f28ea62d78a6651ce9cbe68c9e3680b22345ebd18169328956e226fab2c28ba1035b66867c679186c28661a9548ff60823a00accf83fccd9b8b13494c993aaf0a25f3e387e66b82b60742232bf9b5b4cf68dc2cc730e39e28a4804750a798dfe1762bc7f79e78fe64867d934cdb6cd574ce4bf98950bc86be2d3946441bfaa45fee057841381a5fad03c7d7ebb9a411c32a0439ec9b47f1ff185d23389d7649f1e32cf11f53be5c013024d50a2bafdc50d462441ad0a58d4b5b2adf1906045d5cf51134ef4aee39d63bcf4af60330ef8bbbd93b0476c478bbf0dc56c3e6b39dfce932568f4fba45caff3291211e980354831e6c26ac896e960e82d2b742c66fb4d183c6152b6ddc3e0c24e87753144c8543b7017918644f1bb58ac7b480f92c09ca42ee6b55a8b6425994c0ac08a788f6dc27e118d99725e523b9b17e9ee0312923c4b1f99845b8c73675ac6980bb0e03d2d83dd99cedb676a25c2a8eeeef1bee80e2b8f2be32830dfa629f70c8061eb99fc59c70dafbedb645c5ab20dbf5bc99ebf204b56fcf14b21af8d14cd0b72533e4cefc0d761319d794625f974fa23f34c0c1f684225bde0563912f42756b7825cd0520f23d9447c1cbcc4fd17a2bae232004a3ecd1c590c7da937b2f97eb941df843300745f1f124d636cf89db85d740898af52940bdc617e44d45d1a4f4e612ca3fbd76f56b7524edc4a1f348a751db8128129186ab5b340775e90f0f3d0db7d8dbad5a7408163169a501318fc040ef7ddc800575323f87db7b29f158b8eb3fefde6cc6ddef486c273d939bb8af842130e615822f3603515226f8c9fbecf33479f6fc2481b0dd8fe583b22a3856d30ee17d1bdb5a892022fec3c278595b7c61d3558ffc621fa1124038e0917f6a89fa470a24225d84ca36bc47ec47def779241a1becc89eb9376bf718e8365b05d7b9880e1dc7e3752c807bbad5686e25f16de35803cde14b32ed5de1243eaee80bdc0cdb622cf47c812fbd471b208198985a4e27857bb06370d3a93eebaecb7f864f2b272e458358b35a99b45d7a4dc0ba4a2fc274d52bd0676af193699b0b0f9c147d315e979bf31f213f7e032bdd0241aa91d4e7ae2d5db8eb1a39f8751bc96ef4f766d9316bf13568a9ea493883badb627f62b9a1513b31b1e2e158e8bd406602a2f878bf91c395ae4fa13e5c092c5c0b902b086132bd547f901ea0e8b2d995dfeb3d23fe16062ddf4d8aa622875f2de15a701de8d188b74d9d647c32f83071d5ae0c1f244ead057e623a516dbb6f41b133e82b1dd2b2edfb5aebf50fb45aaed9f1c5b8a738bc2b25681692dd170280603fcb409484bbc65f83edf14a7acf9267416a8ccd64894bd999df464a2a36ab8e54a5284f4dfc4cb842b89cd8f714bfe040a30cfbb0fb77f4277be0defe9406b251055719bbd7a70e9dae638377edce15b49b74114c8251458e2be5b49201eb374c43a4dc44d534fbaf34da13ac59ce5a05188c0aa01b95f43dd8e3da48dafcd448689fa66c6dda41647512e145cc4da42baace100fcba4841e18f520d2e49291c77469f0e71e411d2ff1df2107895300aff440424db9d73e78f4b8b19afb4534c27af791d411ab78b0e5085c8c54df7f644a050b7d75b32eaad9795e9d16dffd2d9a7f8b9ca4c885efe6f829c06aa4e30b22bfcbcef64854c85b9de3e140b16b8719bb1ffe752bb5487adfd6f1b57852990596cd0d9d3d77e7f20476743e901c6c1689313e103d5fc26e374335fee4a0993f77f9cb4dd58aa42d5c608b529dec6480ea270f7f289b304a9ac703aa3d7958e34e44b22d0e077bdfe2a89fa5f783448102194872f4f73ce0a95088ee8655a3eb8284c3b70f63b61731db7cd50011898d8391bddfa049520e6096d58094ad0d43252896011e7760102474823ec521489e0600eb719eab5b95d5f28698e601ed25edef319bcda58b36d8086c6c59b58ed0c2d6a5a3b864d4f0073cfbf28cf177ae0f335def8f63ec3e62ed951f9b078c2d60c76ce169233aa5f704d6277283e8d1c724ce8d7e36c73f110af01673c868a3068a57aba8bcb2a070aa297fbe2fc6083ec45d75108da58db9e4e0f8e8c3a6ad432e1c078578a693efca02504a34cb38854dd6272279966e6c7dd26e71ee10804048187ac650db0a2ff352e984cffe12e36d3efd0e44fc448e8b85471baa852e52c14819f7f1ec030bc63002b297ebd30bb5cde6f175455db23009ebadd41131c4a1a665fdcc57d74a05645f4a5bc29d7eecce033df31fcbaed87dfd780ed4e4b38fa603c4a0bef30ed735730b1ae09eecc59d64f9746aea84b0653fafe94b3ee764ae51084d55010c48ce4d4e23130cc525a1d75368965110825ed0e7f08ce3e97472eeb6f6dda359f617a32d1f3d5c6d82b6e281cd9d172cac970bdcc7f502a7a91396e3400ffa7aad14427a3a206a8e13a60a560aa5b648aacf010686ddefe8ff1ed07f427d1e5fda621403fa8e49a86b8d530930af8cf83a8389cf26796ee2fd1cec511d0e83610b2f55cde010b2f3145f425a2663fa7e9a3ea2280ad28960785464f61af27a2b43bbee9e96696be7c49b109e9bed412223bbffbf0d91ffa1b56791c3852814cedcc5aa80835ba9800c80d11a7c91c44be134ca2d2b1b7dd85cb86c62aaf8d80479012e6d1907f6101024736c05c82e998d47dff3e4c066b9816235a2985f7a13424812e70864e16d3c2c84c8dfec532e0e6f812cb1c94e4712725e560b868ebcf4ba904f30ff9bffbe5afc3031186eee9393bfbcca66ee01f445cb3ba187e02c2d1de7fd4f616034f8487907b5062061edf464a990127a18665540222d11b540b40964e6cd094886b56c99c8222e3faa277a48ac893b3631449902ab8d3ecadb54e1215558eb67f07d5afce29371f26740453255afa1b6740ca8577b9b1ab1a60bea0798676c76ad5dafe67fca76a4d54f0036752a39179cd1266631b13018e7a1488a055f18c364216e3f6ede61d03410d741128ba4644bdcd1b5e8e387aed8d4369cf6f4f1e9949c313eac516b625684202967065694411820dce9d4477a60b8ea4893ce4ba00bf363fc384284712580cddb642c8c5de4ccfb10778a0b803c232aad355a678abaf14fa24ed40b52bf2aa5b002a2f12d9a91eb79d98bc67fd1b3413bf413153e0f3dcafbaf470b256e9dca91d85215ce5882b5fa0aa5494322c69c8d383fd4ca8ea5685ac98e6b10e5434dfa6950229f979e4f78e288a915c90d42f0577c6a58788efe02b3058e3d702971fa66f436623293ca951a89e1f5d5699072c3c7fbd47f4f549c29e942e03714527d4ea1c186acb8fcbfc46ea5b0498c0b6f297af140c3f9d66b07d7badd4dc07338ddf8e83701c8a4649f91e1551f69e727b4a61e2b5ae9a1c5e2329dce76f1e414a8239ce96a820ed8f0a9809374f0393dd90561a1014a9921507d86b7b2e5ff97b4e290b92ce0ff4660c22ecb067b08f9f10c9eb8ce01e382a3a6b0bc0cf35f06003cd1eb67a87dbf6c02449c05a1750d791dbae0a67563ca9b71846009129a28222380180deeef460d0eb1d5f43a838f82a27f65cf09062e5c32a8a15fce1570505a25144132995f65427a81e6b4f84af0f0f7bd669db2a60edc0cd8f8e651fd63fa6f6447c9fc97fecced1dbbe6c6b876748812a4be90bf2bcf09794ea10180ee51297e6382379e2f2993f1855df7116d7a949b9a0819e859e1d3da6cc6813a023d31aa1bcb18745f114b14f44e6ac40fc09a390771bc64a8a5db4c31abb7489cf0f37c5f0a567dbbab9301709852cc736ce804bdfddc1b2765f1e0e47b89c9302b6f4415dfbe3dd1e890b949083ce5d34dc0e1ce99d880d6a286fc84abf68169165920e70e23d13f20f983599d681db3631a3af9b1fded9dee0e9d95899c24a8af795f7169816fd53ff85ff18f9436f8ddbf45af58282a26a3e7e2f40aee8fa96cd770e59c3bb61195983489a87ddbcc1742eaa4a1efeb7efe2ccfd58a2704f9d9130d4f0411735e322137aed721ad6d795a337fba3dbf0abbdf97fc225f18eeb5b1abedf3951da353ceb4cc3329a36c93e759af1ee68dee79c9fc750bd7052d96e387c6c023c00189f5bd4bc332881f54311ce5f8efa4feeb95241a27fd7d01c476b70c73f461de0f3619792536273d67b229f0d7d8bdd2b08ec4e229d8a09cef86492e96f51ecfb3b346cad3e80576d11dc7ca6db7c477b2b3aa096950c2b372a6e4df98c7e7533ce1b850ab9e8adffd698c95245e46d6cf519beac96633f37fde6e72422cfbfe9c4f34fc6915e517e9e95fec0e4024d83ecea31e7adc8c4c16ce2fceb009569400cbcd6acdf941f087e534c471566253ded24c5439f06b502edd4ba7fe9952d58419853d093fa36431b1795b4d44dbc5ff923e7198316c91452901c15273dc467fa1e483248140975e7815cab9a04b76a32f6f8899650669c72125d05e7cb1d4a5a0a9f0f13587156c528669fadc1f9ff7e6e60c875d2604403e8a3fc59181eb5ba854dde4bb323b41c2ac8f9c80890d156f0a7d26c08badd2ed42eeb6e8fdc13b278274f943063b8c4204ffed79e43dc1c00421f6cf9fa37cd09ae358ceaad7300a2690afd59b8d11a5475d8e3c233f3079506af3c070797d551023ac7ce55d34d607613897c0b6ececd98af916fc1a5078c44b8baa541a8bb80e95481d5775b76781106a112dcfb6cbb6d191a27c3f0dcc501d831a14027babfdbe5b3b80f96eed8bc2becdec15cf237e603874ef7b58d9d9cf5bbc0e674b6d84238f1e6fe52b5212f065cdfb1c615e4c679dca87dc4c49b0cd88a2ecefda6ac7fcb82d838a1f6111e866d21d4156f6e1e15c7d9f3a5d8c6d3c83d180a991fafa0f2311f2f03a287dccaf1e36b76c8ecbec84c62e838d82b3791960c9b05e09310796fb782960b1913e77654f95012a504f172ead78dfa69003f127861a38dfc2317f1208394f89de2b7a788be353eed4fd639ba1fd7e7aa4c34acf909a3b5bb34b5e89a661c31e64f892bd841a4717da9f1fb3b68ba7d486fed183157150314992cdbf761d575e5866b5e4811fa396a75768af40115781c0b8f4fd9ad547e283a61600d758a521ee5bc4f5bd42c5bd82e4edb655542b40cc032ab566b4169eabb93a51a624340070ff601ee4eab3a740977f61982ee776214e48153c5f8db054eaa234feddaf58855ac0c13e39cd62835968bfc1b031a7d15ad5b6fd426cd4bdf0aebf30708ae2eb016e88f8c355d4c1d3d85e96d7165b47370769afde99c6d6d760091ad1cbf86dba7c852b3a6c82b64813b2b53965d8e0bb8102443a54a606c997e4de91eb279b9dd498f9c4461004523602270e4b89e865a019fd422e1f88e81462caf831a871edbb2e25fdf0f2b2ae098a4abbca6e7eabed5f377f40b24898a113c4f3c859635d451f26132a63149e5445fcc0969f41ddc482721e7c677f08b79908b3776a512c7a43f6efc8570dd81e46dc515a5fd1811788cbd1764aa3680ded02f41785cede0200a67dc25e91489610d7ad1b7e5d64f0bb0fa43af9d15a325c6ff0ff762627611d5e1b83803ffe7b7548504a1746da2eb2a27310556657510ed03a5cf6ab54a4d68eb4f1bc67767df30fd9151ab0595a96395dfd3e0d83e20b056063dde3aed401bd0332c1747ad3ecfde4d729410b23bb50e4bf18c04f85a6c9786e08b051cc3372a06c2cc8fa07ca0ca15fa5779199a7db24f6c773bafca5dcb8a14a62efadc9c1c13581c38cc744fd0d0bc31af6c8918658a7f3ed46cd60b3376c134aaf728bc41daaafdc4facc6db2b6ab98c400cb895c2511725520b51722d468cd0bfbf66ed57bca0a526e2c7af746f4c745fa62c1521fdd6300e1eb41bbb0246733571390f1fdba0431f67eb64a5f54a8c73cd6b058a63782bc1d85c550f2aef2ed9357a4bf1fbfa9eeceddbb1a0c3595dcfef5780224aeaf712ff1f72c2455c10d3619699132e7b92afdba5a81609769723976465c0d9a32cba73aefc2797f80cfd2e05bb2871669f252925501f6cd3048a6ae889589d54fb85e24c196bc5d84325eb50687c7c544c9c0ea6029e7beacb1f2b4e76e61c9c9996df00dd73af930e609d57fad876882be30db4d6ee88c8fda50064549f509e7665ebec4afedb5403382c6f26c515cb89d391ed4ba8b03aba153f02bb5ae9a7e5f1c102c50ed7a6f4092fa92e62ddf778c7e56c93749af0b10c2196a8157a67186e428d32af69b12b55fe75e4d93a7ddb06c3ea87820e8df731e37bd5b9871e6db614a3eef0ca1f4f381dbd14407109e4de83735aa63b7cc6a9d99bd550e6b5dc64c424ca8c54cd32216aa1d5461451af0c08a3ab5b7497a84dbc11794739f1e61708ae0cb974d20d6f6151a3e93dcddb3087c144d1edca7d6631295c6a5595a87ac1a2bded77bca07dbf010be41300cb958f7022f5b5747e35f11286331c88d48051b63a02811827dd13d342fdf76a0fe75fee906cc0e59dd3f3736cbefdc0b34fa0fceafc1d8d7d0c0abe58885031e422ab8f37ab91c1dafc0bf155030c344aed2a7b21160a665fb24909fb7f9f8595fa50ae80da7b15723624bdd09edba1103efacd65fdaf87387e0e6f9e04699327b257602503ab14bc7ed97d2b2c2c6c5f2549eec77a10b92a3c3b435c1e7bb742d7bce5bb628363929615f6b61cbaaef048c836ad1d445c9c0e84dfce57448d86a2f5e3f083a18cd1ace64da65bc1909a1a9784d9bf2a6b9b02b67cca0f72cb59616c6667ca59e22bfdf22734ffc5ca7105175cf6e84745f75edae88e6adad96b327538f1ac13d4a44d65c9be3f67611cf5238046bfb827db55ad24db93f88631e10eaf673540e695531d396215749e773dd5ee58fde10da9761cbf2775486c85aa37bc3a593996fd1f05f6bff3cea9a3a70d0bb6bf03372997f973517aa29a96baa3a13a06fdfe3632f93c94073902f4f78fa616d356fb833b89ba1e5b248dfddfd87de0f5d5ed3f009942769d3bc5cad838d42a28f0fd1de14d75fcdf7e91af8afeda54df5913ecfa8e097e931bb23140ae68b550e69e0b4a24d40775555b3bb12083dcbd8d1db9f3374159623de42ba44be50777e2be47f66900a44f1ecf9d12e41add8d19a0f45a16f8ea6766a92759fa4ce752f1c32d48bea0c7b25d62839f74a672b4090b3a7b6caa4c0a7ebf3d824a16053c1dcb63873b5a24ee35c0cc6f8724c02b64aa99400040f7b5156671b01892b395b28cddc277e00c4cee323400e475fb45729cd34b8293b4c93a2960ab0249567b979aa630f712c368b03799e8ee8d7a3ffb2c65b7628e0af83033a15aaa91eaaa76792c52f56da75353a6ed00678d247e984e268a929ec55c51ba1f7bb7e0d5c47d249703410378e445c607030bcad46c73d6a0b516dcaf1896f38b509a62c49c5c003cbbdb4b8914ddb8d7f10fe6e7093c27a33722543bfd665975f8f6646b16fadc072b3401f4331de0c9e975bd78d5cd2ea7aa390be2a8e9af383ce38fee16e488847a2bd1d5df4d242fd29c3fad146e3e2a1a1f560e2ee6e962df3c5f7731cc5e07490d744236ed1ade85bcb1e2cc167aee1aed685d085e627953cd86b3e83b01bb8ee14a5224123904caee1e11636accabeb50c92f3b392f340368888be3ad474aa6772881ce38295f5bf5b27d53698fa135ed8dfb0f0d6dbde8e4e55d2ce91216d898f35ae00fd7b54361dd1e5ff2e8fc771f5b486f80dcaf772ddcb5fcbec04646e32c5328fd808673787451c5cb41a3bc8806e1852f0e336718985a2054807939e848864e92fe79a66f3ebdfac556c882569a8b61aa7b0425975802a1d50a485c7f051dfe665777fe2e31f3a83534521b3c8055d34d0860585fd125bc68f3e8ba04b803f554dd5e9b9049116e67fd1cbee1711383d63bedf0a0b31a4543a1bad9e0be5fe52b0e538fc9f9a5ab1136888d8e55034a53a764e9a1e0e625a1648f7c019bf46e39c2b43f6b1dc9307f70462ec2f219386c9bd921ced0c14589e9b8b1975736d336992e0a51af0712dc1051a706d3ae3664e8d07ed50b1320346f72a9e62044186fa346a99ebbc1c691628b3a21ac0e7f047c689f10e7271004e1b2b6aae01813e1db36177bcd80a552b17d2330a93b7c8cf98c93759d13549f5c4e0abc36619dca92aeaf4e1afb8c702110440a91e3ee6d1fed16c95933e07217c48d533a6711e8ce68f2cbb12cca287eb10541d7d75f33a40addf304efdb84c5403a3299570973fbeca9a452422c696c9a837b803f123a5fcdf35e1313deb832063baf306b87000fc09763f3e97d57d9b7e151cb4352e506d9e2455b5b53c5768020377e675bb93105b60cda3f44fa7d9216a6496f386481f34c17214d24c61e3f13ae60d8b8daad234d1a63b327a78fd279f9e08134636b74136f445a45d1abf37e3c204ff25c9949519f4e9f38e62180d44e42f156e46b1b10aeab1486728040c72b9dfb511887c62e965c998fd5eede2ab140ff613cf9c283cec67527d645fb50ca46a483d62f83081e4610835746f65820dd0b98e6b31b02067a2f1329027ce5afd107f8088db3049af647d5b2c8968d2930a5a6628dbca71b50b58dd6ad1f122693ea27e171d0f4d780acaf10a67148bafb7ee9a0625c8ff4db20b931e9edbeddb0e649d63d18b7b9bd7964a14252e78e075143ab5941c577d949dbe158959677cc125c3f35627c88a70372579e666619b98ad954005d7c18947a736edeafe56f502bc7882ba37749638e9173669f41934f091c380f842f56c7b49a612e5b77fc2ed47b992bc8c868751288ff58bc98785d77749b1f6396008876c2b5e3a35b2761196be07f7416d681dd18fffa8cc925b8256453bb621f86f384e4d38eccb66d8c7ed3dbef0df8136aefa597319d177370e0bfb7546fed6e1fe7cbcccff9cb88377e2497b08b27e692dcad02a51fef236d52771d70984c659190bff2a682eb1c0e0c68a506107b9d382086db3d64cf5d59be7b8e1fa338004c7582a0805c4fb24072857e6d78957a7379f8ab94a364d5e70c9941239f83ddc4a38be7cca365d525ba845a588b569aabf99d7758934bb41b507584f15ab83f9f0f1088648b6083e3397d577b3afac4af51a7059cf3166e2967c6425aa219800676dc287786a7bbc71b4bf602ee588ead14d9532004059a836d7e5dd2d10661fbb69cee9717b2fec9bae164c71dd11022288531958eb6bc6664ceb90ce1bbd28718a85f72d46a9f945b3349ae1a54c8a6959c071674c82629ad26d4bc0b26b99f1ea6b62ecae8374dd188aed40565527310a0698229a6323e2e581bc0d5cbdf798824f49522ae759d12c216f5291d188657e7f753883fae51c43f4b00cbb11426fdd55459db958335d8694f7b2414a8484b96acb8445d3d349b2426ed3f5b87a58bca5c96e9f506f93624223b64901065f35ffcda63df346fa6d94b96cc531a0225fb86470a626fc3b97e30e959675c191d09ab4ccabdceef155df207f121f869e597ce7b5dc5960d8cc6bb96e542978f4420ff3f0dfdde9f3e13df31cfb8594627de678ada845ef546984391572f86cdc9d89c66653a4b2a92c131d02f0b8d4f65cc076f60083992b16d273e7d4fe5acd8612cbe8712a942c10fd13bc05e91388fa60aaf7b444b74bbc232a45de3e7c1b8c88fb48544815e959b8538f61a1207c1df1f15f33f4797eeec784a6cbb55df091bad7306176fcd33ea4e1932a890de3a3569896006fed0bce0caad234113b5c751a24798078df6b9116626765b7a1d234a3dcac96d3a80f608851fc2076c70506ff3f4d02e8099ee32bfb823f13770bdfeb78b9e1684cf9e0e8fd9c16f22c9c6c310fb48586eafdf92352ebae480d8f1b298bc30da4f4269cfbffe49353ac1631e6649377533dbdd67f855dd565202e00bd4094fb4533e537d8a12d04abee01ef3ad1e2968fb85ed73458dbbd47724cb91535adb2f78eb89b82c9be573b5728ef96b4fad0187ace86b78719a61a35e769e2dcdb5c576161cafdc4d08fb07bfde2d78dcec3dafb0b778c84cce0eeadec95debbfe28e829a79c5f2de2d4128ccbae1301fcf9116150ed17d68095889a5b636b7d69966407b061a4bf180d1251a7f5334cb9a73737c9a5be47cf5727d48f6766ddf693da2d2d75861463f77022477839882bd1b4febc9e3df70248c98af271dc19a05b9e8999dd20b6a5caa0f089deea51eb0853305051af573b525a282cbd7e94234897867f758d6aed8db8a546f0d4801ef174c1a71295fae7ed64b749e374c0b44f40e8047b3b301b05c369810d4b8d17f42613ebff4a8892a6f45182e7f80faf56425806aee3cc483e3e3947167613ecfe905d83671e0282861cea5ed354aab49cffe157da8b0f018e36debce7a50900663784467fa74633c63fa9a8344452f51d8afadf70ceb4cebde01d65e159ed166e030c1dae4a2446c127313351f68a13979f98f0b63a703886d5055da8293d95ac1793ad6c69dcdf0829515ad671e8d333fd9cd45da9df01018e7705319f3d1ec0c7cb6cbcbcd726a89be1d434651e920af4eafc0c3b0071a3d988e975c3fbcbfdd511d4bd054b2893f91697a743f0fbff88b03241f3240653b258e3490ca043bfb1ef435f35659c6ee6b36e14232f7d1cb2fb43d62387bcbd804339bac27d31f9ba859b4e57bc6457705f98799639fa6beba569359bb772a7d4e73bb7752e3e81eee5b91887f07f9fbb707a198800d673e543451a43779cd03ba215b72a160da90fe6032f1b1e4dba8e229eab70febe742fd15f46e5b690fbb64cb9b351bde34d1ecb028b14ca4af65b82e893ecbf421179564f991768d57863dfaf8574b38448bfb918eff7cfc1bf8f284ba82f1f5753a93d0fc2ae1cc9ec2cdbf2645e8b500c6e90c4f268ebf73a508be40fa71bc074e0087e54eeaadcd359ce88515b238d9ac069e5df3fdff7e8e96d48c53b270d42362353be8932b2261bb079747f28ce8b574d83a92c7692e4e87eaaee0c3cf328575720a7207b86851e3482f5ffc631849c8bf6501e05bc52b072c3f33703e0c51d2195037e96d5ab0bd7eff06cc796f450c6e96a9dcaddf963e5d828d15fb12cb46e54ddc13e4155215415dba51ec86de19336c51e28580c60bfdb132ad2be8ed9ae97669001abe55f67119fb3349e5a3636312e67e84dfd064ac84641ae9dbbdc4fb96027a336ca1429618d1cc5ac68e1acd4ba3f729e329b737e76cb38e252e77c5ad23d4541f289a651d528d844f728a4926fd5c381b650b52dded33512db9f0c14ca3f7a65982166a2dd9b9e6da9c47aec83127213503d62d9815cec4a1b4cc514476eae5adcefc89999d7d8c0c04af79a50522e4994f57634cd4c60fd644cc807e275e94c59c5f05b41f9d1659dfd8b7117493ee282a6ab4dded35aede2b69cd211d3e2effa59a46a2d4217a6f74d0f438868b19be714f17b1559c71d11e2404a1799831f58bcdda99a013b3910ed1330847ff302c9ad9575ad1a5d341a1954644dd630e862067022eac9dfb220b05f5370636c277cc2f71091da6417b2ec746d38c662e074cf2b60ed5065a87268081e13bf182f818ce42f1659e575b7a93a7c832391479e542e0e840a4c58cd3f61fcf196f9d96ce8853c8e98e1cb8b1e90541806cbbb13c707114b7bc761fb2d77fb52e7453bfbf52d9a33d988f493721ee98777b75dff38b19cf8d671148e1905fd0822ffad061da932a9fd771212d18e96781b952a7a4f34d3447fe1cd753580f7db58b6c42c72c3102b7a9654d9b1c976cbb7dcf8605fac26e49d5dbe064c08e6eb4f640bdaf8706c62f42deca59e0e25c8b504b06e7c15b9118cb4ebafa849308e3de233263f54a22d4053b8116beb7499becf7e224195966f4ed55cfa32b05a6d67979c323e7fad1fc3376e02221affed023a6110bf1bb8f3ea7f52e419bb5346fda16cb00ffe6b7da54185a82c996e82f45830f98ad25b624000cdc581c737aead6c9b42447b351f9302e07aa679086b617af169230d26ac71af8279b459597bb59e2a34616787a5dc70c212af3ab75fec86eaabc4a186143cd569689127abeb903b2e83936c0ba334fb3b44edc0dd2b02cf0778c00c533487e50288a88481d9c456f541a1f8b29a26e1b0ae329838360fe54f24a4cf766e4a350472d9ce3407fa76eacf0f8ba1823efdfff00b67b46a129c4579d132268d69cffa6019b17ada0c4ddfbd91b51c93d67335b62279b6b77c66b397be0ff9ae08a708933fb128ed0f41e879a236d841ae3f1d155e8e028f5ab66cdc4e10500b31c7a6b7103c2a3621c5b8b23a2a6fb22c7a197fc9599e63d67f8823a039d0b712f3e053a43fb3cbfd126b1b92cc7a91afbbff835e4cb3161197a27556c13a361d93009703eadf3f199098d9c5071fe9b99ae6d4f0d1ab93352456fb8d30a8a4b22eca3548731b459bff6e9290be2cc24bc0b4a8f4a86d86d966db27006c41d83768bd3678e16c81f96c3d68e7854df4e5681cbbb551c0dc26702c6106541c3910885d7a6a621aa1b314f7846af1ebc4121df28322fb144bb0ff0eabebafe7f2ad590bc3b42f6293d6cb9be02a6abcfa06169785c86929ed80e0e12f644b8e25da8307ebf7ffed909aeced8af17011588292e3b3f1094d1236f65ba6f5d3454c9922b35bfb83cbbd75a765b55ec94145681b0d0cc4edb195d1734820f877052f497df66a42446e8ba32138f041ddb576f70de8fcf19d45f43e074b4a89ea716af10b553ef4aa0f68626d74e365aa88ea7357b1b077f42fd13d2262e049e8c97f75a62d7eb6411abadb1f26a16b0de48b0f341aa0531f8a28312851f48366b7e76df15b308ade9eea22d6044c986aab78ac2ff4282cde4b832539c6e737ae4499063caf80b1a3a556a60f8baa73eb8c9cb895f5fadab6ea54c2081e5f6bade49caf81030496c264cbac098a1feea98df78c06ec581bb25bc6b8dd41ee4f06533a877a55245f46171f42c373f0894520f1e7f05c7317806208072a65b96159ff4c1d008575328c5261a10d4f6efb58dbc5a4c5f24a2606bc5b55a5ebdc4b668d5e578783b1503dd0d940f1e49eaba176033ed58d5f085abe34b3edadec41d4b31b130eee5cf1bde2c4a6f71af59baa6a4eaa385c2070e45dab226b045be30e1fa136338517c5e9aad6bf1b50f319f9f246780c4c5c69742915e3ce03ce621722457a6a8392056e7ac7f13e2f37507d8bbf082514fbcccca53fb3f3a3d35a601d9d61de46f6b6ff7b41313f454c80b5eb2c90112b8d4b13ba16ca379c3ee0af70c464a1915c1f2c807206ed46f85d8bcb4fd5278e434182a0b7d5debdd599b9f2ded683f6f139cbd47281d40bf4ac5893b5aba7b02ad5de53c65d02d1a5fee30aa266aa85d34d5d9cabfcaa64d99df0199a357430c245f188ebc9cb4e24455363f05fbe4efc7ccc036438eb890bbf7417754b61c30b05148203e1ca9cc14916a7c141c18d7eba47f658b6d26ba3a51aebdbfe4b55f29641969245ee2eced56c551ee0474fc5987c9203008c2ceaec48a22e23b08854cd76209e9f62c2703b72031adf78ac6dc405117340f83c21e54b0c1e072f4df348b5f699025385741d409bd1fabce6cc431cc81371eb9caedafac3e594df78056a3d79c86ecf1ecac402c28938f0f9bf0d5da4ca70fef7ce90301a9a7c2e29222263cbfcef73218238e494b9571142f45be1802086b8cfad988468b1fb0386122f2442973df86fe650854ebf8c3e98b15899f3566fff42db8a5aa9eef8d044c8e91ee481a9e88c048d7af63e5de9089841a0b329aa299c3f52f09a5a1086a9e5f7bc5580c8a70359a12bafa8f7415a52e45a8d4a7836ca6a40c940e03742fb106d9528fa9067ce948d8a18e3fe837521d6bb4810c1c7e83c4e5d33916bf497164e41196bc98886e827173a5d1c3835146ef322e7e6bb457b9f7028bc95ff26996a1c719101b1862544402b80e2a70c4e3ba1c7d0fb2b72855d51de8b7702c1baafb94d1f469d8138020b8994c1b00a093074dab902d96a3093f47d8be1a68df30f45e2d766253f0c69f5e445222daaaf8fb0b032977836d450c2fefb107ce4af62d7d9715dd5756f1eb60fb62877e5f90d28e45d59459a1541202e7cdfaad63d3b0b64416ebafcecf21ced6ea0987fa10e86bd46fb70d74f736364089144c7f687587dd2c651b6088e7eba8c9f008887a1677d6c445dc966f6e4b4f2e8df684900ced74711a3f855bb495e8de159eca22f8ee3b644e657b9715521dfdb2df51003a935e8d06447ea08be49bd4c3534529d8d061b2ba5d07dcca9ab65f228a8c7991d402742f7a9fb57220b0155b12e23f7d1e4445cfe2732792efa7812f1ac6c9a327098ed74f5e537f7b98ff5c8baa6bf1d3f88da38b2dd5fb42faf0237c2df68c85ebd21b55b8fdb75507b50d46b23e5d5d8ef14c59fa48b50fad90a24cb31c581b791c0bedb834300fe4d5ecd75cea42531c27d74138f7203acc88b392e6cc14e95c54d73a89197191bbb09934fd25dfbf396ce24b2d6fbf1038427e407650649a4e9fb9fd590f2806111567d38a9dbabd85cb354fb3d09d30084b2cf4e8970a1ca1e977658b40cfde494cb2337ec60b722fa14dc8efdfb5e773f6dfc04559b88ddbca7720b095b9397e1ca4faa8043612091d02ad3949d7675939231897bb93756c9a4a8e5bc939aa4f0473cd67f4ca471e4c0d235d23e4ab4257dbc6f59e9bec8aed300e375279d8116cb38fac787cf649c810e28f1045d0cdcebd6b7a3567e4e276b38cb324513e856e0ae4a8ea07eaed915b400fc58308ffc9d25f0c55b0df473348978efa067329b23d2e1aa43509713d5ffd7f302fc11e2882f4cedbd509dbbb0008d41b1c600c9891b717a3ed7a58250cfc36aec0f4bc9be5ad1665c3a064fbf2e232d3efa3850c90793b4a22684a8a3ba719ffebf0130c333868e55910dfa22bcba17e5309b5cbbc9ddbe9ae30e86d15500e3833ddf2bf2958ba84456cfa7218aae79e9695079471eaa314383e658120","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
