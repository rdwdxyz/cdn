<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c5647b1ac8a2c20f39554b52e6277022a729d21787dc5bb7673b65bd73caba8a5da73a35b2e541a6866f07eaf0ce1b53d0ee00c6007e5ba1381649d188d27aa6548458efa620d55ce76fb3b776812a8fe570141de1335dc75a1c3b1b80dfd4a7d8c1c191d1b81579395ed8ee84753cdd10c56dea04a27af5445753b2f51f7d56e97937980fba2d3aee80de1d0bd7802491ff2f7f47b3c916e9a7dcccfd2fbcf78bce6a909e09c3967272118f05e19cdc85a9b8ac4a391bc3205e8867b2d1b7d789a7f2e1c5e12cf230a0d50f06d7bbf0a11f23e3d96cce1538be689f238ffb9a218c34f56ff95d2eba176e7c8771ce8d5e54d38b62e4bfbea623a73d75d58458ac31a856191768e04d7c4b509d14624c67c75f1ec9d4e575487ef7046b5f081e4a4f3080eabe5cb1ca8cfe198aabff36a5cedbb0a293ef7be5d450985cb9358611a409fb18985f08c67b5ca9871af5b1ecf15ed59728985f8ed17264cdd5b9ee35ba45d44ad02026fb74ad488c16b06e8875ff9e65fe49c60e519496e059983d69507c25a00db50811b67040d67a6f46eb94b9b14252ff7a0aa23504c527bfd013fe3e68fa164806da2d07aee5a2761bec5001299ef5cb3ed7072ceddea1bd16f101ea6c5fe4017d20f113a509c33c8a8aab3aad06b262f441bceebdf90bfdf7425cb4d7f9c6ea0fc529ad8d8fd77bac83a17dd74db993d9cce0223b2ee7d0e47ed84dacf1a36530a436b9088d0a315381c3d76fd9e44483e98c4ca943f32725910abebc1373498238c6cd56368103f43873c345fb9ed046c9e83ad83eda4c321c33e459ca9ca49446ff0fe4355d051d6e428294d7879ebc672193868eb9fd25bd7d40122621bb58d28119cc91bfde8905053fa83bea8cbf85a67e4fe225be8f5146f3af94417143302657a1055619f0e7f4910ac98019285685a2fa360541063b4db5768d70b39b0abe8e0a8350a2c95664502a198f9a550ef1472e370e45dc2b880722849edb98307c0a8de2dde91df9182711f79ca96174e395ba37a5b95e8485d2f1d8dd8c0f20fdaf3592477f3bbba4d459d87dec301f660e687651ffeef497f864004ac9fef0d67f7f1559ea8163f9e082f50d285a5331e911153f4be73ba6e4fef849518d0ff6bc24f1959976a97789795f339d916feaabcb9fc658ef0485b0e1f538a6597e1356bf631eb22ebe867a25feed6a00ebd9b1b1528540acca49977700d62f5bcad103ca7e0cc97ddf2e8499c66513b33354052898ee342fa0761a4cae74627b4f01b8a587ca8ddcdc5f3cfe7791b603ae680b1a90aab48afd4737786c9ce850b1791dad5d54552acbcae783b3fe6fbe944a997eed840b6cf0de8ce459f83b67b8dfcf5c3425e33e114f30430f441bfed7dd46dc4828b039a10bd69be8b9f5a77c83dcc3a29b934adbb6797857df4c18f2ef1d497a7c5820b4a13e459b18a7d445a10e3786b3ffad8d7f6ceac2a4b1f863da8bf112c4e14b7d285769556ec4c41740828a5b1de40fbd9fd8262820552c4bc11796626fb58d9c5f07ee3262f43cbc70eb1b6ad402884a5dd2511da94a9802be147028fa14907662b7a7d33144789a0e6fc8c836d7c3be6cb17fd231a4a09334ec300205169daa1a07a3f22fbc6fd3ca4bbd8b4c54800175b56cefeccf6e08a58869bd1987aac6f1852aa2d4f258348f746b730fb5a2b478995a2c9fb86c2b7649f9eb6e89e7bfd9b10d16f20f93a1d56a9f16592b42c34f06f62bec693989da387a4a191268d693973e7d23ee1da01f04b79193eba3fb5520516b593b8344e40f3efb96ebd4ad81c39f8bdcbaff8614f0982cfa76dda7b4dd6fee5a9a34b88dd35f549257fb70ef1659cec0932a9d62556e16d9642438f7098ab857cf6094a880b8fd1d9778e03608757084f2d85d7bd311441c1cd729a753632cf90afc53bdd2f64d1bc55cd546158f0811a57fac57a334b83dc4b6891e75ff0124f4ea4a2bdd48c6aa3520325d6f9433a04077005be8620c12d99afcee6051d4b2162e978e0f702decb8e79467c747955bb6ce5067a6a62e1c2562237ce395b56dd2119878b245cc3b9c3caaf28f432a99e4dc4eb1c6537c58244d5f38bc7ba9d7571b3831c1404ffe39d42bc22111ffcc063cdc6384af4cb4d13b0f966173e6cdce39f0313baa8bb1f89e4cc8bcfebf49129a5a2e91073baf3c58c95c699aff86a74b1abc8cc833e5aae8283edd5ac5bad539cb90fd97a261702d201af55e770ab1a115b2cf599d83dc1d8bd2d1510a2e56cf36f0073a49e9d033995fc58c9a3f7169b7884eb4eb3d8a510d5644df8a90b2b36e963005be5eb631bb0fbe1c8ce4232bfa7002f4d47c944c40a32ed146eb889630c62eb84db2897037af4956f320aee0a81f7bd291bc7be692aea39254e7b39617a65c0d8cb61942f0679dec65e85d2e6eb86b0f3c0d53c51a18cc88eb1d8e70485d5e308ce4d444208fcd73cf63e63708147ea4d12c57d1670a47c806339dc0cfb369d4cf479120baf6c9d5f9820b9243169f9c014c2ea61892f8f65b37f45ad249af1db80d996cf186aacb7c824778b2645c98ddc9a2d7854b381510464a6d87077fff98ac273f35ffbb387509f5fa5fc5847ba9f8f9f1c50e2bf37dcaa8401bb0f8dca067d1680c401ce9e989d80e2cf5c020d3914721127e6bcb04df7e7701a5eca84e9971666819431aa55454ef4da910351f76090751f625346ea3bd39eabafda94a818625e7af39222f10ab7d4df76a6958dae59ff308341eef771806596ce6dc8374b5998142775b99a2ccb401d64b9502117c5c56f50948de3d747c06ff5bebd567fc52bc937153e4c12442408addd6f9955a02da6fd12687c08103094d593c000352b6a20ee98fedb82964bb8c957298af631b253632524788cf6ab63415ec237a8f4f8e7ff3bc67d0222bfba45131dc4312eb05aa8eadb94b9235672bf0daa902118409633c6d91e2d7704516a875525d91f415ae6fb46b42de5e1de4dd8a661f74f21959a43d5d43b21d22afa38fc53b038e65f9636f02df5b3e6731e7bb1249db7e0b4a10ca65801780e33305f815187541b241aeefce3c917ac041f61c3996079c191d3a627df4d2a45e7d26f17cc6328951e30e0d5c5f48e9306f2921cef0609199dc116e2fd0d1a8298413ec3726d517d59c031d446cfc19ab16ee2bd8650b6c94b27f14e02ac01a9d48e1b65959ad0d4419022a34a4e2719145ff11f84f161fee1c56fb8374547c8e7d16d1954d4c640d2286d7f412476d512e2fa2c7cc3e292be5e9d07801f65c508214e34bd36e63856e7664ef10c260448937daa614fddaca4aeaa8cfc6ab858c23444de6e782635e22bd6d66af02f293ab1353b1db1f713fbfec714fb929a48867084cf4be3ab45700950e56721104a98c681ad059e9b7c8a879c054b36f5114a7a6c4ba7a4bf918a3a992a8b490cd74484fdf0bea48e161d0d6d43fb6027974aab74b05ee5666a10a9e5ad937105678ff6ab9c686ebbf3ca01c5d17631d23651e26be901d94f7d823f092a60d157e26d7294b63b964edb2bb7748f2fd95c7579ab9c3be33b17b4cf76d5c9b39d449129238df45c0049c0bf837198da2114d19c7c76cf39e0a055332426f66a3b963b3b01f58b38d08ecc44c78c447b2611deae3ea14e0aa312a31c16bb1759f99a0b4c3bfde446dc90bc905f863fabf8c987780a74f855fcdd3414f6b285b1006cc8fa9c36d1489215d024b13b81a6892e25666a273743295d57040311ce7948716f06f76ca3c8e923cc34b302be5d4c5f55913a0056cb13019cc23feb6a163f26485261de4ce68d616c84aff9d647fb51e31307a4cec41fc5b103aed48554febf2e7e805cd76dcb0550af3628ea220ab36b0c694ef05475e5ed0073e4ff5493d805e2df43aa3dc7c0f20198e03693fce482e604a7f1fc9cf1303193762936134e7be28915cbf22e82d2a2c58564e433f56c1e647c5a1ed79beaf22e5af6657318dccc1c868c82c5d49a244c0224808adda39f721ef8abe6d0cc1741bb325b02281359c8745aa03d388d182a06dc1af7b6022efa001de19c67b2b9675670cef8512ba653bcf59882bf33ee801007f6649fd1a212995a8d37367a9a919d61c229e61e00ce41349e80551db2650bcabd23a59793e46198e0cefa5e3eb4f84f3b4443bc9b34e94659af6790169b6e8cbcbc708d8bd7c8d4b989402f1f8d4e831e3b1827a7af3eaa85bd8a164eace738a12294e1a80239de1cd05f5b1c4337cafb012fcc656527664afd62b2400597235d70c8be6f33d7cee300af1076efe5db3acd7347cd63d78b3531d7f1e356a3340f24c8e2929b29d0c081392b87ef3882e23d81dbcd3d9edf22de5be88e062cbe781c02cccafa99f048e39e200d6714923bd654daf4273aa214e495d46ee44339ad08033e6fe14bcdd9837af6f48f91dbe19a5bfca83ffc5ea41906ebbad26a2241e32ec9b0d0eb09f1967f815a138f8e61f4ff7f83d42ce2ceae5af0da451a92473273a5767fecc12070b138869e7a1af354821fad6c49f866b4478c99ed9b17d957d26c43dbf2ad0af95ce1fc406857c06dc851e0d57f784fc2557c16580836a8b84780b4eedda4097d268c4fa76c2294f7d84cf3d9848e68d8feefbba79f2b7f110a56f6a4f3e3f537f5d167b40e50944638af69626307511f42508ffe3da02205a93f5de78125ab43c29b9c1f091b59cb3d96ade02379c91372b95384b42d3acdb73bcb44121abcd932cc6727a03a74dc3c033919d327ce03c964191b69e1c2fd5b70039f0aa6cdb5161763c0a96d3d9d94931116404b216d7d87dced6b082dc522bfcf930f37a4338e93df8f88dab3ee172f3e69f4a3d19ce0e2b4b7a4aaa77478448663ec9165c9ce6c7756ef0af9a388a6646a63f062800392ac14c65c3a814b70cea4da719b25ffbebff79f59eb0b71c9c2a3e4b85acc16377c4d4bf34ae81d5e167bf6bdc19f0e35a347ca8a66fd292c9d76bbc7787e96f88867b3f35303e857202e5a3ae6c0f7ff116fd20ccd958b464f9cd0fa06509d8d4a7f318ca9a465245888ba85b3ac01674123e2581bc33f9891b1b6304b32bef468058094f9f2ff5e0ae31d42c27a4473819b09b1ced261fde413fe3df32c589a829921531fe55debaa2072df5de90909aa92ba0d47232fce3dbb19d4bffa99628b51c036f9d5b6af2fca675a5692da6fc83e798c63fb64bae197e16602bd05199f8b79e96ccb0f36f2fa0744bd2440213e985b16e67532ccbe9e3f6dc4b8cfa77d6a6dabf4e460f116d8f4956f46c698a249c3b3c27b7421077877a0a1c5f26a92cb86f675606405468de4b02ff2efd89cb54f923a137b16cceeb3f1a063be2ee3e0fbcd85835e6711958848f20c59da68da57e6546c4120cc78a36a18037268f4dea8826a5acf72110fc4533cc3acf87b1b5c8891d8bc4d74fdd5b996d65e7748370af3ff0beb508e5325a23dc7b056a2ad1be585fc32f94bd7291508d9f42cd90ba360ea344f04a7d9e23fae7503e925205c29901e40e86600a8792129f272ed3228d840dcc6b0b86a2454de7386b3ad57a8c471aa1d6d95f3bed76a968c333f9f83a9e84aa04bb73437e494c54d6a7bb8389a77c8f28d04298de4511f330a7f5d4d77dfd825c4201cff6c6a3374b2efb6ef2404150ce47317265711089509f5aeed07262788c6aeefd99e88adafb45791875fb096b32b6a7bb58e0b6adad75f68f45842a028e6239ea67365e566e7ac650bba7bb61b63f9974f4ac4cf6eb9e3dbc2ba96bf85de095d692d36a20019611cd29a5f1474208ecf4584c09c269e850739dcfe59ceab0bf0e8a809f2bd177907c39405fb5fd04eb7aac9761a6966b201a8134c8d56c6ab6640136e340aa73128601ddeaef61445a7ef822455678e2dbe70fb4225582522f061d3a9846a833575e126dda5304eb5f5f4909820a1d8d5fd74bc07d2b9876a85a5bf81927c5c4d0ab27e11162fabec7b95ade5a1dad0bb68084072b17a9ff610adbaa24073c20d80d2594d20bd320a1791a8e73eca3492177f21b5f19a728d57cc0e718808e675171c8c77bc836ac7c753b99ba242d3609702353c0a30ead27b5978971c9c2ce488034846419025929783f1f981356edc37bf10e1b0e334eab2486b5266977d1d91141153228d0ad5e7c9f75972785cf347a3fca4fbfbc1c00877e1e1f6dad3108a5d5dbedbd1f71fcf9822e653f4913a2b5c10232960849c8dd0b5fc486bdc65d05d747662c1d70563e6d2bd740fb2c36f684cb37333651bf6ebfa32f2acd4ad4a06f4a94378f055bccac3a88661d515556e3d1361d89f575184d1ceff32b1a281320f5824cd7484d4d3f556b27ec89c7737d6a670e404728c1b15580412a5f8735f316047fa5f3bcd118bd6620710c663d123095ed05a034ab09aba66a6d9a40ca5e82d308551f9c4cd9f7f46ba6c6fe05a08afe789c3aa9e82fa622a0f023c7597c86d7d13f543a58e62587458414e7f1585d43233a0e2b598803649385a5bafb7c01c90f34df6cd1178573df9582ecf2e180c5492ffc7041c9f7b6409c55349a20f858038f63795d32eadf38fa2b0361dc78e470defebd07b21f8a9eab77f6f05700bac58f3858822ade488f8746a9c4c244558379860d7ff4bf46a2b28d094c3e4e80c5dfad8c1635eac400221b0b0c5d6b1af352fbf4637d08dd3265e2b5cce51bc3ab46f276ad2be52ee843a18272965388d42791b670210f17104f40a850a986051a13ae6ecf81bb29f8a7ba21c191cc1e333a4c0bf389416033a8daa27696693e4a359184e8971777a31277e026d0d9d1aba624f3135698bf89b3840f9eeef38d637a4c6ebda24d37b5cc43fd5dec77cdb6031c87f19925d584dcf20b3f1e6c2dfa233175ad3ce6ee6197ed3d001b95a89e567e5bc7f85fd2458315543e6499043b99819542a83d0c1d4472497a7a0bbb4a3d16d7cfd9d6941e1b863c6a8c362b27f82fd3c4ac7959543668ce0a2b0966cad1f38f3981d0416605cfa7b86fd801f570e98f190d93f59b8e1104c622915d7ef3b6af39eb6140ff0ca5623ec5176641b68161294a34073d813a9b1769f36c3af2c95e8392a2ce7c3379ecce096cc19e8bedc5b820ee43095031a48027a52d79b747bd0738173b1aa3e79a50ee04b87bc20d303fc7ccd7640d687e6dcfde699d97f1f16e12b1378e7154298873dea0bfe2dd43866b2de1bc5090c87e1805258aa0c3b68b97f50eb2802570a88864313582bc011dacc52f4dfb0123f13b47ec59ec0e2baf500e0c162e6ddf2be462085f3e8db8384b7cc5d3ed9c0dc9f900e70cc093afdaa97f631454639ead0997fd8bfbe12b0be0b5c49aebcdd0db41c629775ddfdfad8c40232c5243fe4800dd3483361233ccb6ff4984956d6cbbe52dccab40607efe06be17eaed447a4aaa96ac2778a2c5aa7a6aff6af4729e0e021ed8fbdc8d2cc1abafb5b3a6e6b57e9a73c092213102398d62b75c5822eae2e453496ae0be7049ddd3cf812e53c64165b49993f491b506439020cdf93742f772d2e4cb066741f649a7a49669dd0e176440f91f36cb465ca511fa7780c69135f5d83bd60b6b9aa18471bfbe43b163cd65291ba4558f0ebb918de2fec621f674b361f6146c9f5c9ad96cd32ec385b4a754c0458e310c62529784126925557084a4f9622c2f0230964f8d63b63eb6a8842faead67e045fa384215ca2fa762a1a90dc17cc6e8c24b1dd3905b76a0a645a68830993565c247f9d09a722fdfe2f22b6bf272fbb524f8f52052d359b671aa54b4f7e4f849b3378651ce2dd95ca282ce49986c6f7ffb8d2feb70e111baa1043ce73dcd17379163cc6d7edd7c5e4850c0a62b9deb6cb2f2b0b6735a54b1aaac514b2f2e41df3862ea6a81901245f8163c5cba5a97c118558de3ed43b422c4346e3111d6c9620e206d9b814d962877938b9308e4cdf124b46b0fb6cb27ffc2ab3596ec6c49801945ad9bbcdba9dd78216bf12f5d120505a24f925c571d38f7bdf6e780c517682380f766210250a6d68ead0a42f250ab41007b6b1d53ec4232c42039fc320c47d6c777eb8db12c9612cceb8c8958cbf22a73a07dc04e65667fbeb6c73a3a18f702365852c5c3bae94dbac6f334c330f64e2861d222408410d8ea7bd640dda8e54c313025ec1578abc0d17aff4573f71bcf5b6ee98e0a005e528cdc2287fe7fc220435d6edc8f92db8e349a2d1239f4df8152864fbb0f83f94473e47f9e312dbd36b161c1fe1d0559a160e2aef7dc74b7dd1da0978c1cbc6465de28fc3ff97579aafa557c1d5217bae30f800b84625cbb13dd2111b9eacf8032268e1471db6336b72e0a384a58bd8e0d3018db9ffd0197392d7438534bbb30d800ca1c9a1face442cdc5986f14fc86053a559777c8b85f9f4ea8ee700444754ecff1196e7bbe317b33b088e90c7f55f70f5328aabc1acf0c7ced13b94705defa70f7344edb2ad4650fb67080d4ea8cd2d45e7aaeb485f43b79e633aaffd5e82acff9dfa5336ac4a44b49abe00ab0164b19bca9c3ea84103332439d25977220dc7e3352ea064c5dc771eeedb94eeee512aa5b57e3cb08c29b9b3921f9b3d8dce3d8df653770d9a4838b81e8c4ad7351db14a911bfa7bcf29d7dc2b1f76be4aaf8b1bc107998066b11ba33d5a11298cf2519f3dad95d3840c6cd0f5174f89a297e59cdb5ca5ace992c2064d5c1fa1c0810feda0df24caa36c04add5c6690aba2a2ff50a3ab4ac450ebb4a9039d4cf038c6751a59a2ac11c714b8fefcd2dd8b5bd27409444afff291bdc5edce11bfee472eb7942255d5a102634260bb3728e420b618017c1d2e920dd202af26d6b76997788e831de575f09b8eaebfeb5cf66254f36fa811c8b84f1b9599b19f41cc6780e378548543c9936345022fd08945235c4613a57f462d8e186d25215c658b19702a2a49d5c66dfb7dd3c2dd7e07f21e7293e248693346cbe6ace6f45aa9b27fc9607b18f2cc798cb1a2e94422c9b75187c59a150d95f28222d05e271919ef268540a468e2670cbe90a51ec0426552d1deae77be5f993b14cbdee2f3144a09d2d1b2ed952134aff7df71ea3290a0e958fc1cd3773fa32a1ca56fe99b359af82f98f66da82dfc16b703eda51d00d3ef4c2ad5129fbaeaf38b89d7e5b44b7a9de0217bcdbef48a451291f889f1241fa841768309c3c1e3f2b28c4b784980ee89b899ff872a3f53beb36c2ae34dc01c0b3b35428124399b84529b96ad7580432369b597839c5381e28127dd5569d8dabea28daa253b4c51c2f9e873e481ce21f45a58c62171fbd5ca51a42432b1f145fa63318e25dff15d928a590fb864c2678064555b9d1fe77eb53da361658dee10649c1518bb6d01fe6b22705754ef74d3cbd9b1911bd5a84ec2565baaf475e2e9b645504418251d14f27844ff7cf4dc1fbf9f31ea732a85285bc9bed63ab614f5082e6392da31dc2777531dc163508d7aac29eca2a1e23cb65783744e23a1576e0a3670a85ca6802fc834eecb7777864f2d42988003e325fbc874685b9486b2ad442eaf5a9287045da329b6644186d80bc0e6b9d2e6e5b19fd1b46c4c22927b3d4e31868db55cb8bfaf49476c73d418acb1a86b7798491d00cf3a378b3024928a4cba2722a2aabd4a55e9ad1406fa40fd7d5cee3d8d1598e823051273e37228f4c5ba9bc81a11ac3a8b349e39f5cbf721f46bcd30b37fe140683bba1e56eba1b56b94b15ea4a732205df890229aa2d893b971d4f0bec11cf0b84264dc022b80b29a246b50248f932a69dbe4ff98d77658249d1ab7f5f3b7a99997bd7866fece3d65a66a2a0aa33142ce51916463cd1103f845407007976fe5fdaa1596106c04f4523e070eeeddc0fa5165305645972d0ff31b588d03b42ef3421cb95acaea5c76c1f19a5a34688ad7092f665fc250240c2d4821705b94189fbf3293e4881f7bdec137088ba39097fedac08c0b2e227e83972acbfb240d4c11240eafb40eb8d4566c86cdcc264502721adf86ffe9451c3d2c3259a74ddf79bdd83880c375ca87936ab76c9a48f2cc7f9afbab7f8bb58671b23113519a5faf06931caff383a1d13476284d3bbb2e464f6f77552b92d44ddd6a0605fb59bd0e89aea8a5fed1c58f5d88540ac94659ceac6124c75ab070c22e1c45ec83108fc743c8bc74422df601ab0b2fa6f22ce47a4e9556c36e2d4adef438dc16dde1078eaeba2bd75536e5aa37c703fba9630082ef7c3c916f73ed15cb77338f115a295a545ebf6ebebb0a0f29f658baf846ed154b74638de592f23ec2d0c0f47b5cd1204160e8664bb384046438cf41492cc4e66a85857aeeb5ec0d57808f0feabacdcdef45c3a4e7df8126483643ce3e33fdc35af6ec465e32c5016ded6b0f0d3baa43caf2ec14781ec2fbc74d4cb5261edf688e2b306fb0fa6c73ac6021724466daa9cc1c7295170ef4fe8c853384e1ec7bcb71fcfa0db9f5424760ccff600cd6bfc92c355994e49f9f2079f3c715f3048b66359de2f2bbddf61e1abd005839457f49ea782da92ccde22b06c818b329149ff71bdbf3e79409b7f4e8119a97995dfba95a4191f454bb63d34c343611d14ace6acd974a758a06f69d4622bbb111112a37cec1071e9e52b72f009a57fbd26378d929b8a7ff53a658e5f3a99bd88925da8b304f1faee1e99521eae49912a6397ecd662f39dbf7ac508f30492fc2d5e038d8047f24eff0dfcbc56332a34d92a21149d185ad3c6f2e847a9182126888e2142ce99b2b23ec42691a2e4c1fce58a42c98cf0f1730f127a6abeaa30f627e2c0b8bff70af1c00b28bf832617312c8bca6c323fadc7ae102fab266d2fa2a1cbd2505bb60a896ab7aaa94d8197e6f720c95aba0ac7bfc7650214ef79e1c413ae28a1064579474a55f77f382c4a6469ee150f68ced645b32b3313eee228c2593d9b851698da49bd225c71e7635786582329f387f095d524b9d284ce990fe386587561ed480f09a61a4f85667dbce5e616160ba8c4d4ea062ccf400984b8d6cf8520b17318b16a463393eaf7012a5802fb4fdc40dca63f2fae3845939c15daaf70c7eec259dd9f5525e480c9e7ae2bfe52513b4c8af96898abbf1792676787b297d923027d42704ba97f5a37b81ccc5bf0cb91b5c064a0424847e4ac7b34e16c6655eb41f5f968a5869bd0f6450ef8e88dbdabdb42ed207189df3d5a98cbd95e45b4402000dfec687468939c358ec1e755f8f1b2f07aefa5b28c2ce48cdfd34f8324c43c2d6099d18be0000c3b275a4a457810d422534cd2dfbf750f755a44d2b89cbada1130f3e0c8d5942c3874cb3a22e0032739cd5652082a065e69baa083ba719aac47c6f9924ce51d65a92d365db4490994d95a0518ad66843e4a9460bcf13fbc1b0a7d3a59e9205754ed43edf1da64838df484ffcb744d4a209f84e959fe373a5ec05a3b0731236f39c82fdad5c52f3145d9f3f689c2b8f758a8ca8b00535fef7a1747cc518ec5e6a7fe7f9077961b1701ae4daa708b58125bb0f164f1ab3d2b97c407a70318beda09c8e5228c1970e17997f68d501fff723be261bda186cfb4299ab25fd79d77c5c2c6231bcc6441914fbd690aa46e4c2c2990dc633ed35ebf82a961fa1346eea71a1db7c58c281a86d4065177822eaa265213d8f758dab7809342b09beab5b7db78553da3e96e4603d7bcca021a41ee80a1d7dc1d45459032df225bffc75dd20642be2e71820c1c135870ea06f5aef00b4975054f147534c990ad4834529b59cc2b15dffc2781d63d487bc674fb14bad66a1f6927958e4318e409889b543bb2e4ad17586af7b713f771c2df66d81a6abf8d3c350200f35c937383945b83eaf06a522ebf6ff1f3ec93cf97e18067a6a7ba8d65d4b2d6f1fba5187e6da2c2b52b3c8c46ffde345de10cca4fef79b3a8da91de6950a2c9f62323da34ba2c6dc9b1b683751f892ebf85ba66d5762096038ae71471e5931c4bab8934545e0aab52e19457153987c38bb72d515d224a8ef00095da351b2160605228a70504aaceab0a4f5f680e6efbfe415002a75d0ab28b5918eb70620255473146372b03d42f48e4e79415e3b14554f14200d4097eeba14c778872efaf74eaeac30618a4ddb8c72768bb1255afe3d16b48548459b33f5b0304678f7a7b323faa856081c2d15a93ce8e6a11a3bbaf81927683cb5ea2fe70e74c09cf5c54c9fdf11972c955c7183212a9a8cf64211169ab7074f51da30e3cdf326084ceaa02006f8045b97196535492e0be4a610f2808414aed5feb60f2ae24f2581542ddda8f3a3124f29430b28845f6551b167f4a3aa0e8eb55358c960ec2bfd04db725788b425270c8b01b204a4f5ab78b7c3cb9084a11ad3a812b8204b4312b62ce4fd73fa939cb3241bfd040a1fe6460959f31186a774191d9dbf0af85b504a9c44521cb9cd6ff304893280b68ed47f01c2aa9ab12ba29c995d47c74bc421eeea77c42bc06bebd182f670fb1b80b6d6fd4bc4853f514804bebdad3df7662a7444eb91f99afdd26c205bffc3d41d1d97eec1c76d11536081525a20816f2b0c3399d9a1327dc479acb1e957764bb69525df82a16bfaa53610ec05e3b7a823fca72466ef0b777aeb3c65159fa764b6e9edd5754355d0e60108695b5ce03068a36444e5acd24563d0395d68e333ee3fe0cc34fb792cd2dfb02c659cb28b8d26ed56b83ba59dfa0d1887ed39175ae812d270e30ab43fdbbd47b70021685ef7cf542ba09461c197fedff1fd4119d34d25aed9d14610ae4bb39553ed0b10b4d446559420f1ff8db7405e456006d96682510a2c9a65b87614b795e076b847c388ab4b5a425200039df9b5301a062f7612e9c5275b5a4ccb912155e6dbc91d6005c05a94598deb711739c9b408962d41b4b1c8e097b7b8f03863077f0a55889a70ffe32394db055a5cb9e6f6bf7142db460c5da37f603e25530eb42de0f6a43fa022561ebfdacd6bb0725b2d63f759b3d9649a654c2402c42043ac0e2b37bd62dbb7efd73ddd1a58f1e564e3885d19b39a3238fc5454f4f6717762998e372dd4ff2510bc04c565bccb04b1f7da67954e8909c97cc438aff9c502fe68ce1aa07f78d20d9dd4d9785fc080ab76a22a3c7a1069fda2250c42c445d151355711a5b5ccf0cd0a36ba715539fca80123f30bfbea293c3cb2209c50697974efbeff6d19e39807486acdb112a7994197c81fbaca85d2d3ed9491bfb1293dbd3da01734a8bc925cb3df165dd7dab28d0055cf1b70479a598776c89d4dba3170198d1375b089906378bd28ba12d29a2d32a2ff5345b2702dcf5f06edf06ad2fb7b3aed52eef28e6da6d309cdd7128971421abc573e070973db850e7bc91cf95b73cdd93e9b90af3a85434e107af22c77c17925c887e0d9519aa49660fd378afd14029dd5f15fc50e57ab52907328aeed350514af274b5be95daaef15caac1fd87a7203e4e7b6defc1db429b49df9fed053ea68a4044dd917ffdeeead6101c3d4730cd20accc2752ae255357a2d3c14d94d3513d18e5b18825a09dc13652a4a1ce97fd47a0a27c227ed3a381afc9f6bfbc7f68f17f799486cfd47669154da225fa27630e8ae66d021bb85e89e4e2611824a3e057efe1ec848d21c074a05ff2d92f5c914e66016b544f4c059c3925088bee7a138c195eb22c612384e67f8b9add9bbcfac4e69ea9ec16a6a191043dd0b2294ed992f5270e926389f79e89c4536b05be77337da76ee901b375c32f7ab35036a012079e5ccae92d46b67056fb43c35d2ec66ea2bce5ea5fb38407294317cd1981622bc51a1e0913b3d57be06d6a43df330c2652f9d9396d71b01aeccd3bd1959c6bbfb201aa9f1f115decef415fe30ed194f629530434690ea80525054d49b7353869f5fcd4caa9c7e8904ec23edf89bac245a23e8d428f683d65492c40298a8896074289997858a2f1f6de90833534dc083ea309cdea29df1d82c8cdf8a167e52b8c83068c51189b1e8664e563c98292f77105bbddf71ce94c50940d0a2a8443f04754001f06ef6636382a1e5ba0f0975cdbd0b2b05f2936f14e19352c03b1a339fbb8748bb5d6188c8602c315326dac995f052d84a407d89315911b60215b616668059a528d82ce833391b99cb588de5c45b7aaa1f4436297c3e2fd3c50ee10e4e4d770c5a27f84b965379001f3d30b17ac1ef697ddc7950a2b726241b07d2a414426c44852d50683754408b263850d5a5dec5ca10b0e5d6ab303db7a08a80c0e7516f97446f5f7a4f83f19c6795acc8170da5d5b472efaf8902de4533383d01b22567551b8c3dbaf9ce555d5073165f4de95fc78809250940df980b1bda941612c9fd324fe6ee0d93e640cf2e07a59e7f0956899ab1e70074f432aae7ab391e651c8074194ae1730070e96ef851c0a2a3c193d38220cb0fbb31443ac097e608fbc5a9e5ba7e72025f3246a2e36a2d1fa24b003a17fcd7ff671f0a49796b64baea9d33259e906b9745c26905ebc13bdc72289612e5a47cb18a482c51ceb384729edfa24da0b16e8a06fdff11dd6daa5a23539b8263af25faf4b694cbf8b9d4f36f3a2a6088094ee60ded324081b1769efa12a2814e39ff58d7d9d76379bef1f0ae052f31ae156db8ad674379e844455593538ea77d5488c02519c7149e011c34e5eaf86c8137a04930c2945924ac08563709518f6a66dad29d7c7dbca3f5e76e19ea150712c8bf7ae61a4e0188a015823bc32dc5aae6495944845b1ed876fcc65b5df92cd3de7a99e1484268863e8edd1d2bf9fc1a5208e9d297830985712cfe9e4eb2b1b54df7854cf4f1607dbbf9fce11ec6ffab5b39ccba61f0ae798c11b8effd31a46b506f0a09d5498a26a416ce0bc72393166d6324213024cb8833e9f511491e0778aa9d9dd129e45d0c64ee4b067bd4dd4982114153f229e58787ae77478276893a0327c436b2dbed77b6d622489192020956ad1032d7b16513702f3f3c2ab4cb53739db3d7f90fd64700b83a9dd301d4aea03be0d1d9c45b8337bfe05c11ea4b257370c714c414cdec3a23494763c5d51baf762aa8142e46be24e4bea81e4b36e818ee6b73dccf37bffdfbd4021022e6043ef190b102b5de3586e6910d7887cbfd31965837ae10cbc36dbd85bd913224a887e1ed180e70fa876fa4cf294773ad546e3cad8e8f345befe21dd5f5ba65842801f06a3b649ed064ecef6e79bf2198a2d9d23e3953aea4afe85d3255cdc7912d2c12339e019715791b749810760797b0f2fb4aa1a4d2e0941120d476cb2031a8a9d143bc25834e340850dc225c8ffbc7a7a418402190b8771d8c5d4367416a966af9040c24c9047a02bb6ff2b4915b3c8b4536fa44e7e4b97825b60136f3458e45e79f14f319a474c86657d0ad618515d603e0aebeec5ff6e6382baf7ea548d56c8717c33c7bd6aab5bda2224017ad1df201e474991e781fae0be306950e79e2979e3e683914eea52b64f376911e54d2ba65a5ac550dade909e41a9eb6f261fe1c8ed068a9acc2eba86599bf0ab0db85a64fb48a3c5240206b8386db8f0d82dd7bb6ba9782cecd85a720c547f1da1adc46ae9c04c9fe3b58646916c7bbe7c139ad0bb69ea5b4a6147759df491e1446e2640ad49a0e9e9a6f9a2b1d489093d894dcf606fb258ea3a1592bd9e313de67e407db6921443617e9906722d201c10eab6edb2fa9263156e7ff460d8fb268c82d162decfc51658aa693a8d9cf12d26cd549864e69c178335e154a29f1034620e7d96915915afb92a0afa0e184406b99cfd032b7ff6666372c154a0219b88b5256e922bf33890f4a035399af44d5526c0b8d7cd79a99575369d1b2f2e6faf26f04b5a17e27e71eb7835abe8324f186ab3018a4f481478f2a5ed0bd0daa1d8d5c25a1cf1de5b97ce462214439ece080e50d9b88f16f79e3e30a401ff0103e82238d8015c66e52d0f6b9a94b35d39cded0aab14be3105c5e4ff98e36f4d213e479a4ab4639a00dea0822ec3513c7ee7ac4bbb23bcfd4d91c85f76e529debf3fb28ad137e97c46a42b13739c8ca601e0d8eddfcd80fad3c7aea12655ca6b983bc19a65f4672fd01bb2a0b20edbfd155d69f8f47baf820d033c439f769c006f1643c1171c26c8627e3332dafbcbf5ff71e657e7f02c28f977e97472873c1c9d341058bea4d868e4ce2598b72276e4adbbcc4b76188611911e7e2b5d7546300384ab51dbb7a265175bb2839790b4a2ebb836d8090b3a450a83607dbf0e372ee282d5a40c63fa5e9fedbc6a5e1625de96e29a7109f893b735fe574b4d5475f173e0c1104bf032fba66df19e1178e7a8de9f35912032f290f6648d1689b1d6a7eba25c3acea01c327ab78e28ff0126128bce5f9af03cfc9e9647a7b9a9cb3e4bec259fbc544b9e99e684df0c12806a942214fcf72543e1e6685737d1f209a792332a4fbe9474bc1f86a370ba334ab691df3512f38da31d74539f06461889cf2b2c3b25e6716e7366cba5dcfe782ad06ff830b57509c90c6f944799eba662b89200265ad91a6babe5a2fcff4757f3a8ab856f899d519dfb39472fcf4eb7ee40afaf0dfcf142dc4fbc503041e4cabadaae42ac46f48a8aab98fba9af45bbb807900b73ce5452cddf6415b50928709b0e089a266402e79bea73442118fe0720502981f544ebe758c1e1616f1c29ae71315933f3348525c53e260871378ca69e92ba946ee651729b5c9e916463657f2a213a9aaa7da3e25147df7daad48a45eaae0a7730b322486d8f6c6f4516bcce546ef96a174c3650506108a0af04b207b8b7fe524062f8266b12188fa86db56adca6cfdd75564bc5f6dcb58b786ac4b193a56e3dcf64c3d3d42740b53c5a62585cebc95955c12217673c66243d5d20baa78211853deca429995ebde0c73dbdc5f3935234a399b5bb3619998570d78a2e9727067a5be51d824d6506dcce787e4d53484875295e497a7d5d1961257f80b8058a3f500511b2a7824475cd87cf94a8b099b0e1118294f591b514abd4ab5fea64eb24eb3555ad30c892f10cac31e516f0fbbed0c7729de34d1a6f605db49f9f23b0cd0c435e25addf251bcbb62979dddd5fddfc863886572b2d50cade8ab37a24a9010d27fe00c2b27eeb1554a2f116b50a2980be089e46e29a295d84e449cbad2873d9e6fc587cabd1c3f3dcac388033af37936fe5d05a0c10159b261fbf5b93ba304f301d558893fac231d283a4eb6acb2c0d14cb923c051dc058205376f929305b4c7c1ac796c23c1a6339d9c1a49e97c1779f5a72fb617c2b7761b6011e760439adfe3c43d6cddeb0f0a13f09d6ed0cb7e5f236b3865d4ca9115ed2ef76ff743bcd9ac459242f6aaed5804ec2a619b59e7cd144bd3c93f1d81b323bfd1ba75d5a8360934443348d5632e558668aee9be0a34d2e61c4432190bb152beca4d98443d4e762b396ea1782a964b84886edeb98e139742e787956057eee56f2c0897773064fbbc95795a0ad43793c37a022951b1d506d36049c71f90d4b9dcc47ed8e0f14efd44f9557f13be739963acfe60d4785d51f7cc0ecde703d6dafed113de2e7f76527c16ec76ce805bbe0f5ecc7076a3b2bd0ff7c61f27c587249580f92c834387e1b5f4cdc7c7a484a84294f8fe1bdd01648797c58f0eb7e5f8c127ca42f30d17763f41d16e4ddf444394cdb46b40379512ecfd7707794d97f1e5d99b5280607f214e3d99026a8ac43e84d8a32708eafb7a744241efd0ef3709be3c2eec83c4d4725c360b4644e5f4a13f1409c4427d4c7d9a3932f2bd648ed7c3ca264f5103d36ede8c4a281f829354080bb1e49482f64ae5636be1a0d2eb1a9d42a11bbe2fea0e5f86043aa048d3f153f1c4ac041197fbc27906d92398c2c22e9098616594326069a5725082105273055baccece6170ace706d71f9c64f554d03acfa9fe142878df5296946f9b29b654645e949a1e90d74975d91e7d0d704ea04073046ff15e4ee84b0dbb783a1a2ae97b45f781a1365c45cdf28045f5b1c8127d17723367edc798d3b384f9e5ab","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
