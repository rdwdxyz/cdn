<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2d0effbc679fa5500bbb7d97773e34695b05cd5594661267150ef3f5a8d14efae359cff03d0f09dc81e689c0172f9f58156fa542306f2c76a832e8bfe93753cddbbe9f2b483db5e2245e33cc82a2ca8e213d327c6a833c0e8bf961175f953b8fe65819cf8c18bc22ccbf7eebfccf814fc4902978bab5590ce077a8116d4968738df779fb7039b819becd53b1b3e9bea45b2054ac4f0269fe372eb51d5c40c0b4b99270f641d95f05c3909bf5595bbc60dee2a772be10b41032c79d285048ce083225a4f80996aa8379a7d6a7e31b35767da1bd4a4fcadcdee759165c59471f7653e14f482d459c642506de23cea7aad3198ac8a8aa0e71e012c37d7972e86636a1708b0e6cbf355140c6b9f795689f0b9c3a5478f01361b36d504fe80eecff5d5b2d018c30c340ef4b119c9ef319acb6c2f831b21a7df9471e026d9135a05bd9d71b37117cf437da61ebd1323d1565145cf0d08350c2fee0aeed273497c8b6a803359c24b1d655d45d3280e449bfdb191a426554436ecebe782fb9b8f697ff1b1fc7a7c3bdfe2e4c68dad5601ef3bab9d0ab7af9b0f6aa75edb9202e1db8a1550a04f29b685b408a3c0c2060a339b8f8545ce1319dcd2f3c9a1a7572ebe79d0a9290cd9ee8b14a89eb8377fe6a52ea76b4d9a8c3985dae171310b327a8278cf89771be0a742cdf68b1391b2f131817c51dae274c73b5b021087fcced719986e6628b610616ec3024d054a44b6d19d4c293af105c156b27b93fd097ea3e006cf390440c1f08ed1512eef7aae129c85a21d657e5a83c1401821b3ff83aab3ca9a53261a37f0cc8ba3cef7a50871424c4384f79f3e4e723b64ab4dcad4a8e9545cdc4f49bdd997894d0d6a25718d7f01b87f0f02af59e7fdbffa82e8de92bcb371b7e0852786e8d8b9e5ea2181d67d00ab691a58c269204cbcb29346438959fc6f8ad3f8bb429f970a730053fa6b40b1ff39e9dfdcd29725bd07bdcfceb463899ad8c3b288d49777aa7d8c323d803f89db63bc9ec2e2ce4b1abf0cc9e3ebfe4415cf121dea41c9323d80ff391d38cbaad14f09a62bbcd53040aa9014facb0bbbbf4f4b936589edb8b9280a5597e272cbbcbb13ff3265c794a54acb66cbec36e6887631936fae59f5d9812a8851bf9b4a22cf911715bf4cebc5759a8229418708af7059429acb49f3445ad74600b7a85a64804cafa1757fcf44ba2c3b7dce997a8541a664df3f4e9f13e5050cb35367aa0875ec31c1e1725d4c445b720bd282a7e958b27ab83ed1a13722f7ac72121e4e6952dc5efc0ec935b994430b4215b0e286f23f3e0cc1d0b5f4f9864afde51540afd690d253bc6fb47f6635c1ff144c4c653affb597dad32599504402d50f60f171dc76465d270316c574c3b0470e3a6d32afbfac9f7a5d9a5f14c7ce0bb5661af6bd126d30713899d85a441f393f4274090cd859ee764891838cae7f6cf96591b6406f678d9d7d922dd6fe35a231cd826d55d125b3ec35a59b3ce5d16c3387e3a421dde4e2341d3024586d1fd94e58fc5fba39e19af02a64fe3cc8c1d6979e08402a2b5c2e2232f9863b27fd380428b7951305bd9394551d83ded4e92299ac1a2d2df212ab23beb95144296d4388e6f38738fac6a111b1e2a5dd231caed728fba7b569331b8ef5b697d8597b412d36ac39cc4a3461dc560888dfb2e3c92f1f9c37f023707599daac50890e9771c70adb284fc2fc6b0f450ff8adaf972d969ce8cb35e7e2ccc788e7730be44ce02d49887027e321d9e0761b047601b182f63d4e159c0e6ad69b28bb01b61208936903349dd080489f7d87ef18d6c4aa6117c837627a46d357d0bb729f1db665e56b3294d00dbfb98ee99fff35732b2ab8e5fb9bba447febdbacb39420fd08d85c5c9490c1aca341c9b38ed60a7db8ebcacb7f34cbef283d1eefbd45de5f4d35849a364d57e5dabefe4831464b28f5d2b4d148d83c71a84e1ffd5e56fced29fc52387932677323f2bec147d0855b4bb3f1bcca66047ad74ff709c5aac54e388c3fab68f3f524d5dad3cb451e437264fdd8f2c36eeed401855eb31589fbe0a8aa04eb6645d4080220897b47e568a1e72441c4719b1b3babc61d9fc99e575829335f39525a0fdd2643514e2022ec569016fbe0a92e413949db75ef997df9681b4085d3587b6c1e1adc3f314fffa50b34c07992acd3a9b8280531a4fbac5a6e17f1a5ed7f46d0e6b0426907e4f3291742978d00f3b7604f1cecac72e049fee7a410ebc856bb2103ef3c92f8e52fdb82d8fa96520046498121f5f6bc81a5a6562bc1b06a38b2a04c18d19e8a2815cec345eae3d02406a228d693ac800da8e9e189f37be7ef42c426e3c1f735e22259bfa86a0099daab17e2b49a81204d565f5c516d324b81ea77e75a20babd5d86003396231bf702fd27ba454385bb65ab65f6b0075af1d557aa6b81d2df3a8a54a4ee91a8e6dc26f32c1409a7f362709b3dd0a076d90aa710c654a1f82ae8e2d0655fe7ba7e465294ae18c2da7ce1aa77ad9605bee89949210da4d40b1a6d7e638e26e929899af2c3b4282044a172a56156c666b87ac3f61b98ea602e55a891c3d32f9503d7d4d47a326caa0fb887835bae759f0400f0177eb3677d0a3e2d754c4fa697f20fb0139fda07d04dc7140886aa2650154c3e0795be81112388b1781b821e7fdbf54ef11330a60bb32a03434ad378931272ded9475d93b46d5d31bd9e7c7483d2241056cc772c238f63a7d1d4f77a2b409dd6980e5e677d86cfb39c81c6379b80ae963bea8936a854277e6ae356c84c090da263601bc8cd9894d2cba4c921ec9e701cff4b3802df4083ca1fc5765773489f23e929892fe4bfc1b72db010e24dbc2fe77ca0638ac905afb58ee78261db7b64b1a9f263bf3abbd3180c2f97ca5d19e11e789d4c770e5550fc7285da900b267d1d15aee637a33a475f9391bb95c91480144d06a35a728009a8ba10c85d0101ee85b40d79cd77c875207fd48277f88d75b988e88d7d9328d09f07fa8677f937c7ce33626f6b90573eb242db7110092f2a994fb7319d63a369b1bd826ee69eb55343b3085cf9cd09638422db24133431c7cc2feb9a96947d636bc83205f3c4eaec7f9aef5e40acd45b5b941d47912151b13ad8043050196accc30bbcd4f0e24fa98889877ee584e78c3cf62c21582572a378bb2ea8b8af30f69f8c9ceee090d8219a1e5aca1e126a2e9f6d8d9f730d5e545fa015b0e0e0708c147988bcb030d874a2d083405afb26260fc9435702360ab7239b832935acee6135c14180423e5b07c41d1f3733277011b708039778b75997d9252c711c20922d36ab9b6963e866174650c0ab6f45e51a9f221e9cd61c5a868773798af2f6d39ca9f3dcfee85710bd09c5929d87307e5c53cbc69835b743c8b326a858194d21e7d910515f99b3e5c439562e2f7a9da2c3d0726be10aae28ef333d9c9b4dbce4a032f212133ca488a5e4bfdefc6aa8ed90378842621bd2dd8c8511d3bcbc40f579751be8f6d96bf863c28f234aa225666a7e700fb6a934bbadaadfd9e41c7d1114ddeb47d49fc0b8d49fb3a04ef46fd5a47354120150adc18806408c70807d1098ee3f2663ada7f8612fbdae8cc09bbad7eac70f06fd966b28dfde6179c460c7f88714179bb80aa879f4931681c06c0d1bc004cafd2dd4eedc37f7d084144e56be2cfa5a8f4a50bd48716a5ce74d7cc83622faf1bcd6846e98e67e4b2bfc835cfd7a67e1f29f45b711ab9d4af3b6f0ee08ba50f84868cfbe09e320bc8674948a7d74a49148f9454e3f9b66d78579952e5fee858af1a0729bf3cc2b8e6c20f53eae9ca560f951e5cc9985b86a1e4cfdb0155f75f5fd683f80a1763c94a47541b3059f76034944f0f983f83fe35608adfaa4b04cc0960a9e736fd643590f37d46be9c1f520205d9ca7a3edfc0668305900b6617af10b37b9275f3bfd6574019b049f18ced5d6afd244b3f6db5e39c139de136708c812d21c9c638f2f6c8b4b3a571dec710dd2320ea8f83c879df095bb1c57429d11b2315178ba363d9d1f8cf876fb9d92289040da4c6d0f6e1b253dde994651ad6d0cfb19e91058dafd9314585a96174f8da83d128db4658b0ca458a7382ab4cafcefecadf47f446a64e7976cda7d45c422f037477b2ffa3062f6d3b0827d0383f47cfc2615eae546c77dca629f8ecec266c961014f8ecc2758e0b4fba717e0f4f1e629e90bcfe37e06a44877300508d68c3ef0c1eb974e6aa1fb32bbdc1a87e031c27b5626d892291adad8bd61600f7507e93b82e9a9b92b4b46b4e1417cb0f7db39e8c86168bc3e9741fd536f199b58630a8ea4a002fdc388406dd7a1a50d64836b31871abf076c10e16d91232f83c3e8825ac1a30ea481a39db2c811dcb2ab7430d13140b7b3436f6f6d7a11c31bb7c9946b72c5d5bd51e9cf5b086564c748a4fca15017da48527bda9d2a170c41600ee0ca3b3baeae33727b80c4ceb9dc53e9d7763624ae43a434bf39c2cd40cf968468afc509600cca8cafafd25abcfd5422ef74164b3f5522e55c1fea043e3f2e124eb12316d5aae597d346e5abe7893ee0e2d199a66a789a4d9d6097f70629e9d00a9d07bbc13863f6b3b039c8d920e408517e8ecee88541c919210e7cd64fb3ea8fa975839528d785e1ba6d72ffa363e9667c644dd8fce6b45b541d42d123c92d67752b1df8e7e987bc06db071c717560c90a6fe5624e866a16dadd7331898f401c2ac632d773a12f21ddc1d6c6848d49cd8e2cc7901f02d0b72b9df4fe81d696baa84939d4b2a068f818341933a02d6f41bac65878c4b1506fd22c2d8f076c3843eac29035d4e2bcad6fb8d6583efd3eff080dc2453ccc66034de1e8691ff25e534cec44f0ebb4b4dbb6c7a4b3060ced3ebc9d171f6dace641888e995d53d56e3343c030996a78399774690a9fdf447c229ed0706ff8989b162b64f3feba3ab162e642fee5a99b94cb1051c8375b99af72e58a336b1db3c8968b940163542955cbb3eb7aeb99fd6f2e004ce4a03a791d9e81bd648b7ab6683370aaba534d2d7e3da98a4d2df8597951a5f6a270ba58a1c66ac69eb3f676ecb741d7d8e2d325d915f0abdade9b43759fc32ddeef90e0917fa3dae3d9457233423825868abe6a09b0645c43b685c18d8eae4e097fc6d10cf11bc8f00d25a92c0363d6a88534b4da1dcf3d14f725fe8d834be86604e4566c3bcc81cbaa0a633dd8534c4ba2129f2e223bc845b123bb571828596605776d367d89f3bcf6ac475f463735e0fc52b50039969df628087942bed1cb845832583f9881f4316bbc3e21fcaa7a3785753918c295623f2039d55ec7d9abe0372ee38326c2652a91b7e28af8dd4566f6efab64f78f1f41cdb1710b7791edb8823c5c22751bc022883a841e346fc4bfbead0c25ca806ce060ccf1468f7151e9489d534df84f120811c6b5c13ab599772379d885e2a878f6787ecb8a0bc1f45d79ff2ed5eee90ee0947e5cba4e408f16cb874f1d2e002c1ebb5f0df7c315adcbe1bbd86bcb5a490b21506d4a1c7db139ba02983d415faecf212943b5fb1c46c09713ce97de7f1d50ad5a4c69396b991488a617242e6566a1ce285e77199cdedba6ed05999a141853338478c9fa74d852aa57c8e161f34f2a9ad0dd390ad7028373467e1ef7c79c014dbe66e3f27bdc0b83146306c8beee2e39a01487b240dc42df40a24c79c273c86d521dfec0857ad9fcb38b41ddbbbdd8b8da4f513bae891e1fd049037f9250f03023d7169461a2b151d677541af3d87d3e6ead3c40bf595177e92a91f70a36a3925685414fbab93b8a912533b59510fdbbe3cf06ec4e83abd41604d9e0b96f2f4f74f71a985017e3dbbb834633b80741e4baa342b20aa3e5588de08a22a7724db54ca2d308684577a6c9287914d763800a6bb3f0bf1f003f9f8e283e58a260b2b2b1ce03bf2237af60a952e635ad0c625cde3f59dd21f3d288962041fced455453385b42392b889912737b8da67ffd255aef19e0292b9dcb582217cd37728517680286b7ee79c2729cc48e344ea2f545846434f9345bcef2db6f4bd041e37d7de12ab2243f357083fe7597126e6439a04cc55089a03adcfe539e3c6e98c46acdb6ae4b3924d93f34b6ec19efbc989696a4378fb818d3dbfa219d516ad4bf58afaf8da30333bdacb0c0b30ea76a62372502504403ba6375a103d2043ebc062139adff744afc539041df0dca79647f88677635a131de096443d6758e1f103e904b4ba17e2bfd83a0f6a4e01c73077aecb64878b2711ee86fdcce3616c73e59824fee764404821a92845ccac83e27308e942caacdb075fb4b342bad0e5faf91db6f56dc2df8e6cf2e1230da7ea5a41627e4b3457f71fabf11c9a924c4db533b34293c5c2f85c5a00dd3a05b03e96b63b2e71b13d944f9c8b2c6e0e1aec4b70130d64f95de9b5fd555863101f1ab1fb9058e93d927986384f7cc14638c665c7173a47578fdfd52d096184e8622983a0cac300c6748fc74d895190336a05e8df6a86ca2d2a0ba2ef724d21df230e9c93e08894a3c099b6fec64e7843a133f305954dd35aac0d6e1f21cd9e453bd5da22843b8644cdf449d18f9a6a1ea15cccec1b400baee9728827634aaeda6a588ee438c1f38f29988cf2b8589dc3e21ba8efeb22a341c1c6f6eed1534e6636b1f2802688c3c78806f3e943affa0c06a2cb3195082b6d9e5f7c1fbbd959938b76add604a04012a2cd5b5e267c2e690ccf9c53495d354a54975221d3c21f286c597a3b8a820b460e0a3f6989050ed99ada87f2ca8f4b994621fbb53e48737b4153bdae25b6a1ef16a2539d7f02040e3581dce63e0d32a466b8c9a866968ed88477bd5d5e83f05644722c0e11c9f9f2a92aedd90ef8810e3319df4a95000f0021a89d2c9c60afce2326c77fe5dbe21563f2bf91a7d4adbbb97756874a46fd376b531c9202925a6c5f33a201e6a3a995008e9c439dc15dc3e22e9a2a535ff2c8b8085f0592af8331567b41fdbd2bc82caca86de6a19fbab301c92ce06493f0573572e48f55463d7cb01aee0ea7330d43e29d4b042a5408cba85b677ba5a8c59789325ad1fbb3b26803162153b306f0a241d5b38b193a3b64094a9641c24c660deb39dbe5d778775279062aa322a59970952a82ee9cf7da0b45cb7a0f693520674700a031026ddea0266672c249e0c626b8247631c9327db2046d9007b270b54dbd2a18a0eb6f3885a1f5bde4b816a6d95d10e22a1c0d4aa6a9f71a22e615dea610cb7d4027ea952ef01828ef0f9fb4f635a19da3da10720854d5f228d6d23a34eda6cfcff206052c734818baebee1c9434c7586c40a12c1ec4f1acb91a281057a9db8273344257602988cfcf5f233f60700d1c85f9d15088140d7cd6843585d53adca4b7bf2011b0d07fa0c97cd9099961c38590beeba364d1b2babc14bc3e9f2e911f15f45a0d520628ff6ead716b2beb59831f0efaef3f2c9f41cb182d5a9480ac4c9c27ad89d205999345a55f7ebbc1ce295b86be7bae434e85fff614d7a1ea900e3ae76adbaaefa96de9b2dbb1fca043d6d2d49dcfb37caef18d83cd7308a3a6912c709c89ba6e21228ea158ed874f9b6ec36bc276bb6a516806c67b155c857d8265e4693ce06a47609e788c8096982b01e13f51e4fa6ba29cb17e66eb867dd964b9d8d2ff44921c9c5a39a2e2911f0e484dbf27b6f1af6c13ac3ac8d10d96c7d78a6254a6496ea4088a85fc43620990d9067ec107a1079f0e454b8f492084e37826ccac2a0d9a1de3c9218e1f486c33e819e45612216a99512e8e56050408eefd9024261498376aa03c7130c06a352dae5f15ce40eae46719700ecaa0f383a31f61867273b19fbe83262587674c02b7b3c9a7b6da7ef4cf85847ea694f4919a2f70b7f4ca244b7bf05b934f567fc9128dc907d05ae1a0d2cc7dfcc7136364d2470b4376eba301d25912deca24928eae4ee28e3361a14e8381da3805b80ab827ac76365521146cd65a32f81d3f902fa3c85f515c5a3695233a96fb05fcc49a7616eca7d45cc834a3907e413c238ba176c4c0c9a017058ffbee2e558aa9dde5a72bea4067680fba221ae48cbc6591a89dd67a667a94ad601a480950fa14df001e10886cab95d050a19257a1d9daa555d0aa836c25f2b752105993a2f2d4c062154c8968015b61d30fcb04d89edaff3ab459f4bcf7b5e90706b42a59a6da5b70e487c41d6cb5fc7f15e575fd6fae225dc0b5321affa76cd6fd7285a7e92bc08d0506693c6e6b6c57c63fe479c069d170cd74af996b63a1b293f61aba6c748024744b56b51af76734ec945071d3b7d407625d0e6d9535da4b3af5cccb85b6078c94857735916c9bc09e4feab9a925e2c9385739c3485bd154540af855008cf7cda92ba2e77eab880da09bf5d63c1cfad82c692ae6d9206aa3ed682ae6a9de1dd58f57a84ea7b15b83db94cde4143fa0b90be5e7f4be904b030a053019c45d71093ce27b412e1ff9777922890710630cfd05d3caa58291e4ce62e00749d4916907443d280afdfc5d5e41ddb496f3ba6fb4c34a1ccc8dfdcae46a75de6e8e76a0bba06cdc5a285cf73305c265bc1b661640dd59e5381bdb55ac803f9ea9adf5039473c4367004cfb1e8a9a2ef0eaa44708593cf7f13434d2d80d5724497409ce07b8404bbb10cf5f9c0991a026e75aaa134a76528d6beb2e58eb12412e0496a3e768179d8fff87993f2b24b277c9ab4ade7a1cc15699077d0c9311dfdf5bf96553a0d50c3e76ce54f4bd8ebcd231cfd6b99177d82f71f971a0899ae97680b74746009fd84bcd4af8613e33040bda0b446437d89ba10b22c7130fec11aa047b6706c03ca31615e2f7942aad43b3f8583a3895c7c2563d032a44ae3ec01afa3367dd64865d9dd785b1b24adedf9146de03e0f507a93cb36bce78dfcc11d0a6e42108fd64b7b15cbe8667ca6404dfbc26e1cbeab066ddf1293677b4508f601da62a0f5cc60b2eabe0a0f868380569994f2e968487280e4efddedd9bf9c8745e71a20bcc99cfc0ba1de5372fb33015bebc594b27d69beb5e357501dd7e0ba975ea63983e65a37307793cd0d67b7bb399aae5d5357dffcf7440f6d5e0e9f16da76b0de11949311157ca32bae22940f7dbd31dfdc1759b09c1d583fdde03e9f78feeb5b2a4eef72480e054b7eda93fa30b47e4e2f7cf422fda39ec0c78ae78abd3becfecd9df4b1734438fdb734e96aa8c96105c12ec67b8c48c3259691f03f9e2f5b8d80064388d937e498bef42123abda1fff31cd571c6b06ac4ab82c3924e05e59d812527918e21a7e7e34ea5b0beaf1d4ac0b0c64066f568c397b44fc144f17f6c2569bba387feff99ea60450330df62ca9616a008d38b4a69017b2dbc8850dc18c53f725bdc10b4a9ba9ccf8daf1ff8b91b2d5f97161ddc702035436615b41ae4e0f71a0a7a1e5d732b3ac44edb4cd4789439c9c26f5667a34a6dbd0dd667be979ac87bd7142532509ea2cfc124479f232a1a46560979a104a6629b28e364e7e83726e8777dcbbbe5eacb7ece34fe004edce00ad35ed3352ef30704356ca3b74d0bf29af01ae4f62c8e860c50cba034f6e4b798f4826d9538d4833e8b2818ee5ba010332412177583e9971da3426ce73c4982da19204b002a044a5d6847292c5352ca991d90cd892f12b8e0f91862d5934a899cba7ad063090a3da50e9e8ea7f179ca249ee5c2c1ca690a5f904147a88112b36a0b1f459970e59ce0a676889ed0d12a792feece14b79c00a137a8a5755b9c62a767e4e6d68299af6a0cccf964b54692313ef02bcbc8260ba5d3db69f1afe378cec78923848125dd2de312bb4f75a4f4c178cbd4770f292ea1040ebfccacd141b23bfa0088cd313db94aeade00081c8e9dc3d2491b5c6a54765c28fee87a7aafd4aba52a2fd4bdd322c237903d6fc52bcc3397921154dac9dc8ecf515a93da08b077cd000fa5804b6002a9f5307cc715bb47c2fe50e00ccbd4c034c54bbbebe22232f783f5faa6a621960f2738833634aef423f49722b9524f9bcea0766e33ebf2d08175d9263e51b04f738a107823f5169f79a74d9eefe7c34172cd990087fd8881a4fdad3a1d6c0d86d856f707aae22424ff8a34f056b195b89887e8b48cbedb30513ee6690dfc33afdad89cd7c7697ab6ea399173e228e69b64bd7cacfa7735e3e738ecf1976d354255b840b6e08aaf24f0d4c1544e106ded2d507d772eb36d6974bac05d7dfb0ecdfef9826042e6e9cb38bcdfc054d5849a198a3d74cd8398609e8c0d0cf5ad034d54884266f44cc669d7b1c82a9233f1f6fcb403fd1b693a9ecd8d4c343d6d6b97b0061b31ab99e8c9d8aa3eac45970e7b72e464e80ee29d0bce60b80213842049eea8a5db894f6c9f01ad133edee1a0235abadfc928ab5874409bce039f61df30929b7ddbeb0d5c0c396bae800fedcd77a335653f8605032cb578eb749a7ced2090bb00755292cbe7f8d42576f15bea54195b9daefd8cafdc987e83f8dfeefaa12de54e7d46e23437e155961a89ec7802fbcd71e401bec1f28e0eefa815938dbc9df51497261a9362c55a7fc929ed593aed241445f65974a9cca6ba7a2f94fdee599a58cfd4a04c01125d134fcbb2f475a3b77b819716a1f54276de42f8245bf4238fa9d926605720299b128099554af7f08120c42a441ecb9fd0819a0e979141364744059194917d7e0a0ce69ae91a49ce5d81358e8f13db460790f00317c4aa20811a47dd1583d82045e7856f5c0e6a8b2dbc7276945c82a087d191ef664359fa28e1a655a67a2a8dd4a21329ad1baa7c53be6feac2c0563fdb493716e1c1d0357561ae750dd9ae86b3be9f95ff59258ff3a09928bc8853610b930d6da589cf975d057117dfd6fa64304a9f44c7781c20d594ecaea1288faaef606eaa57e8081d1c2ff20a6ef9514f2bd6aa0316556249d80f7a87ee804b34869d76b3b710996faf2d4ecd53639df2b81217fcc02603504b987b8e246e89c4622fc4849dbe0edcd531c3dcf13b256b8f31ebbeb070a517d6ad797e0ab078b9074c6bbefb74b82e35c34afffe859b060413934f5f62880dc4565711f24150c1c787d1cfee770af6c8d81c2068ee40205f248c7087fddd9797e9932fdddb0711f905ac41ce8628060a3a5e138a846e9d47b817e3535956f79d1b11c4f926c6cbbc9ffc0c267786e89a798af05daf78b83f7db0adc3a91e69016962643060d36ce1d13be776db2202729d03fc55e20c1bdc6e8a0e694c522f65762606ad39a05403e61894423874c6b3955feafa392d98130c6b96f43c74e63f1626e1caafc81cc6141dac38c65a1727e486bd62bfe6ad181e770223a4d95a1018a60fdeb1864e1165ae6943560a002133b9fd9e222c08308cb04f14a8f68c78af0d9a3e575a335aca1aea34a7ea50082ae1795d2dc7d59e8987533bb7aff11eca7409d57b94b28aca91f1a3cc391b15a786c45e26e6e8efe1bd1a1505c0c647b75739b414e756c5b903238d6ea48f87641fb6834a950d16fa002ea8717fa0cf2249c8993fc00d1c7680d04deeec8a93e696cb9a16c84c1064fd31588e63fb08bff2cb83790fd3d71eeb6c2eebc21d72461be180e6e00ffad0e63882b4be98f15ee06796a5fa4e6766595ba6dcfd46ea0765b70dfd956de942a43cd92994284e0f4647942906eccfa80cbdd4ecd582a893b26f778a7f6d0d3b8d64e1b9485fdd9ebc51d0e083ee3eb51abd6be28271e142990b413169f35688618c72eb1ef456adc53cdd91e7e2de02701e3301f04620c6cdef78ad977d31e7013c9aa16a3fdc1612d08de5656dbf1eb16dac943518c6c8180e789864f1cd24752ea894cd06f00bc6c17f05cd42900c13e9a56662b3b40ae1972743069857b40d47c9c821fd24c3de3f0d24ba48503637669cb5b326d372e42cc08a7a9ce6bb695028f5ecaa5a7b28caa10d4705ca1d4bdb1d992f5ba4eca3f9a5a42eb7ba70a7a22eeb40233ad4c8b2f6e535ee23e28d26751e462e83a609f92c80daf75bb55cd5d1f0131e297cab7fc3c0ad18e60ee7b545b7d2834cfcc50feb1c3034970d9af0a7c3ec81811efdc3b9f448ed3883bfaddc0cac5cc2d48c81df03373c97c1f84947b062ac4aa6bff6bf54da12588b7b78cd0cb24ef0d5a4d2480d22dc01820eb9e442da10811e8b9bf50735f1ef3234be01d0cee964ba2faa83de3c92cab8c95d2d7e5fac66dd5d917351cee9a0bec9c0799a4240e2bf965d4ad607ffbb4e3fbc2bd4eac95f166be9c6ead9521f0c1066d759e8053e0b67769350bca97842d55bcad383ebcfedb5afa0770bfb5c93e0b20d1640d8a657ddf3ed6638efddd70581eb42f9f3d22697ec8c7d611ccc161749434a9af379235e1fc2dd7692d24059da6fefce0a5bb6872974dfb688902762816f20d40da252f986a9c1d0052a5223f216b5290bbf2b78ce3eca9ab03757430bfc02f7008175d25f01574f225c7c195b468a2fbd5c1c72fba850648cf97971bdba655853f9600eeb7fa044adcc565200cdcb50de97e4e2d376a6c819b6f0632f2e5f339bc5fe43da8722af5f7be1e5b4982f7f32181f59e2961cd86d6feaf64efe15c595f5f14f539ec7e46212a59563fd6320879137d7c6ee5c03c90de93744648b514a03a3ab2c2218721319417db54b3b1ab1fbc405add1528cfd5a9b51b81676e6e52ceb69fcd913806bc4b1b056d00a5461443dc7d46e833384684ef3b668491ef872e64921a4e3714168f0825eaf769a2d83ab80597cabfc9b1c75838a44d8784de9de0574a784081845c87ff019ed1d14c1acee275c4a8e01607c0ad256432827b8f40b65ec4d4a0257693afa3a2950b78d65313c247be491455bd3f9e34049b4345e1a7497c70cdb486876459a9c41e648cd21739136e2908a95618e6e33f11c214bf305946edc3a440b9f3e36b7585ddc9edac0d81bd56d5a05462a252db557ddbcca306150296d34348bf9ce4a89bd9f16b7b81c72df4d02d0109f99fdeef4481434ee5b3b82f6aa3907f26212d4f16a60b78ece501411ac256f7231be30cd99d21341a42b2303648e94cc92af4c6e79a24140d89e422b9a41613566ae205beb1735a212ff468800f4f7c8b3788a2e6bd1896362b8f7708ff96be9a3c291f52929a24e73add2fbb52000a5afc318fb4776ba3ac7c23145f2a76e3ae485bdfa8d5b838539e00bd3bcbd4fd7d6ad8ac7039ec67972121f90c7bcdfa292ee989fadf337a0bad5a9578c1003d222ca99e8f719cf1ff4c2a8b74ef96069bc90680a95dccc9b175cfbba24654bd1764512318f9c90740eb449b00b11ebb62c7683a9e7868526ba5e1f5a0a9dcf836406273c46b5fdcbb9ef8269036b0778639a7579d7d81f80926a6d9fe272c102c936a0e4b7ec5626a3034390bfd0a2a27930015c3bd3fc716d3bb7e8073ecaa39c62eb309833da4379ef40291d558992016b1f5f70317007d28cd9dca4bf987be7f95e2cda4808401708a5bc2124cc124d44ff928a53706d018417660b2550af3bc7737ea054cd7443c3320507baa11062069c83bfba59d8e9139cebb6e921c3b4528fdf6b56ba14034b0b96ce66834654658ad85407a9e1502626ba27f35db75cbff334d495fe663c2325452fb88f1fdd941c62673b01461138ba271de8d417ef6d6ace3d4247086604d1828c002ef91c94cead3c8874646c261d8713242e9518e24bd5bc9b6f43afd35a168f21a6f75a270d59917c1874f8f74cfcbd47fd0d04ae3c26d2384fd8b6476bc19eb3e38e65bae30f29127a06e22deb8ba02510b69aa3d039e62d701115f899b3929d32fb3d5e9385bd71454a4556f1f334f5a7150e517af42c5b0e227e6d4bd38fdf0bb3f08242efa864aa4be0c61002e29dac0a2499a2d608dad4c67356f5f2617e5ce1a2ac25d01fb0d2f84aa2a923a7a882e68ee326aa69a5f8e4309048d797e196aad2da821e8ea1d09fa1c08dab6819f3a98aa3b8968bb78231f29ed74a7e41f6ac5820b5270cb0071c22857c5a561cbcac909e20ae1ae75703bc41515f7ee37b4a898b5e53b50debf3ca53dd20c103125a7f03d9572ab6c6606a504729f3e780d6bd54bb8bd952fb39e0956ebdbdca35acf8111290c34ef54ad5be68f1e24502582db63c9f4a1ca15da99476d083585969df5ca41359f4a4b9b12edabaea04fcefbb77c6b1f435d14b83f86d232f30aa640ab7a05559021bfe49d8326d84c406aac83cad229683cba845ff2294453d1e5aa46fae3a31522f8a26c597a7e7b3c2c248cd5886831ca56b00c2d2079d6112e2486e622157ad30bf5985fd16bcd4b736f4a69ad4269ab7743b6795648f59af66cb9a330a0f315e34d3e1961a16c8b80b284183d60777fec00bf4a8c215e80b2de9d46f9c672083d177f4048c43af941c969a8f53076702e8fd3767c6b1d465fe6e640aeb19c22b927b5f613b295ac262a0b6d38bb1b79ca30a9ba3913e63d8a38daa0c0af61b810d131a628f1ed7c089357ea4bdf038da1319d33f421f8e649eb7cc01d9d0a65a4bfbd339d6e0fba82372f049168f102f34fc7b152d452023446b0399e84eedc00343d5c4d96de7997245de63770c95007ad26631ee1f50193c2adeb272077d705ce1ea9a5d8e43537a7bb0fe3363586075ec219ec50c42f28892b6a6bb621f19c0dde9aa8b8c85e91ab168d1ce0854994cd0075b736f2b375bd961bd8690db1f6f11823fa0752855140d919444e8ec84e0d5658ec2b85ae821c61b2b4f7f650b8381935f8b304931784a929021c6b92ff6307e91a38ce2869b9abf67029a824e17384ed99729b1dc1dd87b0d680ab7b6e84c6dbbe98bf88f59b73d8b399da174875a3a4074f47b241c90930ceca8949d3d7a18012a54910d5b4a73c0e6c26d6ce8bb879ce62b66a5cdc9cbf2eb5233d1dfb190f019260c4f007ee2b01ad60399a16aa6df98a659f3c488de106d7583df5c33eae78140870520058018bf71545611fe8aeccb9fae9752b08184b5a791e6c7c6956f9d5f90fc935687a59b1d8a76894da5ca8e69e038c3507772098e5a0c40c0a5ba241a643e6f1fe3c3b54b4bb4d6b568ce80e9cce79faa168cc78419ae81194e74a14a7171e7282652ad518be5acfa9fe53eb0782aaebe71a4b9cfb4da71d4c28eed7e2a87a6b56fa1488d20cd3400148b89e8eeaaae4d0328ed36377932234d69ba685a9c43bb9b6fa5ff9ac108f364699a3d056d29f0dc0be64d28ac11ed16da8e306cc5bc2b66340c440880492f11f5a137e8c54e521345acfdf46fd13fb5a748f3caafe8f607473747c3e567480292b4947b095f6849d0c6528b973f6156bc793323fd883c434324a0c04a91b596f745a265d51dfcaec52b69f4dc29672ef236ee7094bfed514eb26e006439200a8ff781a1c35ef0d3130eab77cbfb686290b45afdff265e80c921328b9255c0ceb9ae0d368fd36cd347416b30f9e7b219d9902738a54496976d6cbdb1f590be774930543184b9eb3059b19a5875c792bb19e078f49f2dda191a20a10f8b4e4580f4c73d2c67b694bd63491f98c1ddfae3a526c7e26a0f7daf4db25420c29e2b63ab80939d7ee7a522727525f24102b54c3068cc590a4bc66379b1eb96793acd6c5d089557d9f7b98a6988fc97d16c25ed4f39a4c5bb11d4f1c49064ec5a931e1af420bc11e377f536591a67c4e6bbd295feea039cd4eb249ba940ecf969d54b2d37fd802937bd2f1208348c8c72589a247e5e4ed197c3de2b06e580e9476a4afc13fc05944b8dd112ba39f5f0e942a0086e35cb74760f197e3307b0d466d8137265e2ff879984eb272da655744fe94596bd5d8dcc38540383109ac2159cc90b25441071a81ce4eafa6a80088e68f1cfaee2dadb656f45a9b3b465b744724e57c57860dfd1f7cafbb89344379433acef6610511fb06fdacef74751f2b8f3ded9611d5be17c2c34cb5dc765ca1fd9cbbd1ba234926a7f228f8ba54fe9efd1ceee3c3c9001d1cb2ffc5ade1dcba0ee70d644b60310bf0d3b84c7b8a12d7260d016d4f569790c251e71aa690cec33775485fa2d86f09bb577934bbfcd650054881c963fd2cf485a9ff32ea4fdc071b429010dfa6be65bb276d4767fe1e15c9a9dc8c9b2d8bbbad7edfe0f7e66826785c23e2359593245f33627ba1a3732010756671f7127cccbcc03948017a40d28b5cd82dac720779e3aeaff377dc370f7ccb2283c8e33eba0df56a3dde27e63e68ef59ed6b8039c7ae09dadb46d46a84821ee4b49dee6d735dc3d074189283a4ffca861faf21218efd28ec90c35166c4ed3fbdc8397e9f1b31798ec7c8552db068e9c2a4f9e073b97b51141c08d6078bb50ea4e4da62d4dca93706817dd9860a25ec935f33d9287b1d54eb2e5fd972984a3c7eee8405c45f078d5f14392fca69050c7ea7ca164de79e6807929550bf5ad277ca17934926b608258c7292367e713ea46c5faa6dfadace00094f8fc7f774720807ddafe79f6b2af97a0bc2d6026f13fc8dde6eb1484d3fdf8245a06b9f312f29b2f0b62b9e4840af2d2c0356ffd00fd0adda6fb6abf2bdd414fc1c52bc981c1829e2f4310c21878cced9d1657d2cbf3fb3a8b37414bdc22f97ff5cf258a4ca102cd697821240d3129f288e1763b3e2b616043d187e2962c49c5cc795dfc2cc150bbdf49e8d4601a972908107380a44ef74f56f92e1cbe8697ecff1907012bd075ccf5bda8db6347ed2d5780c6fb20ec79c59accbeb4c9212e5cde7bd5c8d2e0b9ac4cd78995d726354e541b858fad975c0646a681d286f2b68e34f3fbb2255ca28d0731564eccb09009dcd89de0b6a836c37adafafff00acf389cc5e950c60717f6ef75fff04550717d2fcaa8c897cb257ad1ad8674c291dd4059419c59275546cc554c1ce7f0b18bb83b63ca16e156e563ceec93e5a5d5e6442498ad5734e6f4a875928c175e8b7a04b143bf38922e448616c8df63d313843ac940dcb986915f7e5fd7df5706867e1387d85b246c3b9c6c2f933e49d0dc21e0e151666704a77e96e5b352339deb93718c9f516554fea4692134a2112e33c967dc73a0a709ff4523b51efc3dd89d5ac2e752984cefb15242d306b90d14b8ccde60aaac90feed73f23d8dbe065d486fb32765d89bf2a549a9b2ed7a3a948390c6ef0ba99e8937a721040febb88380d984f9432a2aeb8f86e2558fd1e037dc4fbf5483356ae953cd9ff7887548b3e2e9deb1a9d18a5af6538bc3e40d72b01b74a38e10c9a8c2529b9231a9b506a2ec33f926a06d25e9e11ba6efbaa00c4182a2274344fac1e583f1f37aac67195f9bf3c968a14f1e05230bdfbfa9cfd23d4f0cbe0821bde7827adaa2e4d9c9738f08b9836baff1db2f1e767ebf24939cfe960a63b328689540cc892c76478c6c95a2574391d19ae868568d0cd95fa8d30a45b4e691301827bffd0be6821c02cfbcf47967052397fae6e47f03ac0f891f266c22cbe27c7e9dcabddb4a64439c60e552f58d548c780ed3b1611e0fa56c060215636beced0668123e51fc4ef72e330bfd28c82cb46668c7a5051ef8b1b0287daa87fc68a8750dc0f931b0ea802e5364f4b660f1d8abb97243b5e78992c954f9cf6772665dbe2e9dc71bb69fd6c2fc2f2294579222b66d286946287fcd1fa19f99bd88b1fd65c594f6156234f8256aadd06e4ead41bd6779f7f3fe25c35109008379d9cda7ac017fc54959dc99347cdc4a0cf796622b3731f69fc05bc32a5e5b289bfb7cd8e193ced1cb2504028030d5aea2c0ea6bf777da6ad25bd4eb56d806a0931f92b3315e4a2e629b9128c9be55a0e541bf26a280f67cd557183b5bca1d15248e4b3a0e1d001196fef12c6d19cea0f278285ee710e56fc92ec89be579a6a33c61dd3dc04883cf4e3edd8987362599b3fd4ffa2cd35ec9f5d9735a4e6068a8f00f5540e204debc4972d47fbc5ccedd2d8c04aa6e004cfefa257a9cfa5918dd862059966baa088427bb3ba222a69ab4aae000f0c31672e167e653274e33cb2e24f68fa47","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
