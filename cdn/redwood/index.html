<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ed86135566dc58341258ce047e0247f3d4320f583f9f94a26ed25e8674d77c4c8d67ee9ce8b92f1fe214f7ac4af8d9bb18a17936c236e23a02e1579a3da20770ae4bbfaa5b0e54cf1341ac56f6e72b4caefdda3e4ba8ed61d2842cac3a2f9f3ea1af546d373201e0da31d54dbc1b6820b17c5b097f996f4f1f1f44bf0daec14ed1170cb6d2bd8b914ab3892d42d106fe15a7c6e2139f84c4240d48a9bb3bbeaf077e747128cdfb47b71d40663a3c4e0707d9e971a6540273bd0554cc91f5ccb876e285abfd5d9e870a89409bb377370443b610d3f8f685460ae01974842dc6aa6840d0619fc87565ba828ad870dbe4901a3a60687fc51fe313915617edd2607c13c4ce181bc1d961fe66d989c516ede867ed671e3faa84d5e7e8c017a1ebf44714e6e27432904adb6b1e9fc239ad77b71ef27c556acc7d87251580b61bb61c78822ba246f3060a6180822c11eadaac6628763b1f1e4112bed0564cec8672c25c09d72fda263f7228d4bfecc1e70f12105c5d7cff95ded22d3428745459b2e52d59abc04e2bbc0af784544709bb332be494e171bbb69f21ceadeb2243f9e77de6d4c3821e27d71035eb1dc4da581b0bc53a8eb2fbfbed961db963ecd0de7a83d57e53d1cd28e348229dc4c81ffde1c612ba5011ab07da271db5cecc3d0ba0376e3d8e17188c0e612de920531cc5db154c9098dc08251a9e9bffe838a5bdc16f040f4f228db845d41493ea67c298e4e223eadbbf5d099720fed9b6ee81e32a6a3695d3e07584099938c606469281607d3e49741623067ce7da6a20cf9ed0e716af447e8733fd74793752df6abbbfd1f57a2db875c2b9b3677812b80297a24bc2416e28e3c5ad8d9f7117af4c466cb330d82a45525b3a86fc3b5f020000ef968e2565646a068373470088a124f0ade7dfc682447205b09fd9c6eaafd9bf7fd89579e1409518584a1ec3cb333c9038c3b557786d642d037eb8d2fffcd1143d07db8aac724bb3d91150630ec3c526662250fc582a7e788bc7a0049dbd3b9d9bfd59b208a26260558a43e609ea51e4ea756b1fd29af2a95d5ec69f89bcb9065ee6408a8d08889c9f121ddc995616f98f04a89448f6c8d2f6c792c34cd1861b8684962e0e0a56dc4b5fc0ceaa313f59eda6b52ab852cae8abcd7da450a03ae1137515ca7e1f6ba2461aa08ce152faf5099e92bd1964891f8fb4efa8aafc184aee5d9fad6a2964a3998a275d24f923029e8a1ada7fd4962e8992825bbe18e0fc2f983f7bbad19d55459fa83f3199029c7e01e101c73a107ef072dbf7fa48435735df965256983e5af02286211487551a10f13280b7a964c45709b30d47c3735e0238384618a17da0ab01a01bb0daa78cd52998171333c47003bddb9ac3efdba4f70b6855982c770cda9901dcb321c7e23b8e600334767d863c8b92091f6273eddf2bb5e258df1b1d7a5594e3715c87892db7e60162cbba15c45bd30d7080e0fcb9728d955cf54a81b3327729edd66d5de1b9a422aeb5602fe6aaccdbb5ef780f7da744ea8a0fb54ebbba9dfbde33152c9c408f8499dc8f645778531044fcad626b51154fe60e58f720f25d789854d94c6153bffe6f83bee55948423043f143268d1dbf6930a856b3c5d1b94e6fd42a68ad9a30f0014f05943f72a0ca8d5f47813d9b1490f1ed5442c1804a64ca28cec3dc6b966b96aa123b27c915d8e3d6d3f678a3e7ef44de15557a76d363cf67a2e5bdacc3fd8678eeba48a61c48fdd437e444eeb0d46fba9b4027b6abf1ca5b2b2c22acf08f2cb75c9ca12c73a88c2c96a549d43f3ef1cb9a4449de91065a1f4147737a980253b5f55a635329090ca06c6446c04a255de09f31315d94c1248d9d4ac94f5ed2c5113030ab9b74ec06128e81c4aa76f61e794e8400676770fb6c8b42216a430240fceb9a230478c8533eb65aa50b3b740b37e7cf07a8999130b5693276d1f900cfd4aa46416a7fbf8055b394b4dda41283d642efc8d53fec7c7884437b1f11d275beae6bf7e28b629bc49f5d26ca7def429046a4202a56e83a55b26a937fa704206120958a3e40e6edce79294f5671f34df2442f7628a4f8f2bd4b54be61bb76e1751add5e071d9dc763ef444f3eb79ab77b3d7d682f6b8d3f62ceae0bba862bfcb05e7194084cf17a1a8f6f276f2c58f1cdf4963925585d6fae6e08e27113396aacbb54f5199ae3f9a1afc7636dd1d20cd180a070ed76f9dd20c5c19d2032cd83af33c5c3f96716842e2fa2e863e8ac1a41fda23a9bf12a31f17bc3019ead265157792368fec28f5c5dc553d3ea863ff14298d44ee2242cd350739e2b1d4297865f4d9af7aa124704830d9ac150fa9f1630b471a3982323a0b80c7f4a49d7a99567f1aea3f22419ecb98b7647eec5ba3848dadaca06e997b3ede41bea5cc6a41f0585b945de53cff01884fd4783fb03b4a306958a4dab54de78b20666ec33075dbb2311f71058868f8049a034cb2e0d0d01570eec8ccdbcc84367ed415d923835cf1f472420ebaf8a8139d5da30ee04ff8e200c07366f1eefdf055797325c6cc564bfc57fba907842ce57eb2ca7b98d4565be839366dbb82a4101282fd570885357cd91f14f3ca3f06b47fe16a0c82d5bf20922ecf32fee4fab0015f41541cba8f8defe22480439d80607e98859c6c530d2391a3e53c0dda7fc70c4a6466b524d70abbdb053a0894d96e9beb1de01865d2de560519b152e7b6433754ec97486a12b8ed6e82e52b71d420ee791411ad46c8ef76cce41e2f0f39ce4af9aa384fc6676fe142213df622b9d1bd839ba71248abbb427cc05cef74c3a27dd196afbc0e059be74d2cf2fe4090878c423a62f8442c8e54381246bfbbec72dcac50ab1fd922a469f030cd3c2e92ae113a3f81279a0aa170f328a1203dcbc9e327b09db00d0f397cfcee39dac228d22197a70c2461dd8eee64553db2233ba8cb55aa027dcb53a3f19353949182a36bcee85c03fc26832df56f778110ac94d7ad6df6a6c899bea98867de63cacda7f8abbe644e32ac03d9060b93735011ff4a536c5d3d46900755f9979e0da18a952bcd3a4a4e814bc6f6f4e103b1b94a4453d100b7f53c6ad454a73b78e18e5156119ae0268a645cc6f19fbdc5be3b8f166548849d6fd16bb3437de1e4b7d041789091cb67072ab50dbb949f05fc3025952f00130be92b5e09f1b3f92cf574e2c1c45351c639613332fb11b4be45f136dc858e120f46f9114e961de5b517d638ad3a8bd0f911cbbf4bb38b9e07bf2698ddd0f337d9a1a103a06e11e1fdc654be7c706469e4e2e6ce7a53c226d09ff1b75d6ef258c9b6056aca6c36c2a54a0f3975c272b0e4949ac73fd09670eebd25aae586be555d1da41448c4b95ef3bcb931662942835d698ee5c3d3d806d320524c028a9f6ae4b0638aad44c19da16b6c40aaa2c238c2395096ce2ecd3367c24908235c0e76e61ab999cab5c42d69942a8fc20e4edfdf5305a6c010fa8ce72be5f1b47a0349a6e2ee6c309260d14a82c02471493c690694173fb81e2b487fefc64e3459199f8f509d2a2dacc0a9ac1e75d0a40ca5beddd2a0e50d645a0b7658665973d072db558f55d22208a1b0d307c1bba5e39f40dba0438180c7a14a0e0627d44da09a3764a514f7ac2be4d460b567f0013f8b8313490c8c93d78ef0e88b315442e09289b0d1fa213707e78d25699449bb2d0ee1645f1556035a51376867aebb43fbf79ee7f113bb94c527b3124f419c9727942ee7b80b7ca12ecbb1749c641312435fefd277e95f008b9fc06ee3633d3c2b3667ede81a6490f7f5f6fb31fca2a594ccf15db7348d083fadf3ced7f96fde35af98101c19cdd13be74533c730e75902b1a7c26d29e75927898b3329270b66df8ddd9392bac9f630706993d9e09922f2d2f6835a30e0fa9ebf4cc818817c779a564a725f535fe7b5175fbe55984ce8ace8837539eb0210a4b2f3a6f6e41d5691320ab4f4d8f416f9dfb8c9d69dc78c1efa63d843275bf1267d76e46d7a76a5c04cb0a97c3e3771ddf199dd2f8f1c1281a8b6df8c90134e9038db61b7d9d9442be82a245a9db72a1e64915ccc32d1406548dd1887efb607da6d8f0e1d18caeb63fb24de6ad18c4fc4da1eda1597bfe50aa1cc67bbfdbacdb6fcb8fd4d784e6dd11a111de94090e27d414453ceb8dc0fbf64fb5b76be551b491e66f280ca7a9521c902744927b72f4ff2f3c0f2930ca6e9a5e9bb371d25d3ce5a30661e6fbe5f91049a685994766f95ea86bec958791222fcc3a594a8886dbc326a7b87bcb787ccd5b532c8a39e25e89f1a88b52434d0834fba96f21f5cd37e30795a788c838772ee03e722353dcce748e56b636804ff7db9532229640f6c25376506ae128d804a202150e43c005cf495b7d0f21ad14a87ae13f169d759c4669227200508bbebd3edc57138391c8f3948fe1fc252d179b98180d8534d996e5da1f8af952f43d8c31622f5c2c9acdbe150fb34a52cf93a4e78ee49be87d5ef18e6ee5e60130fa6c207b3559a164b85b505ed7233e1b8adbc43eb6e7fe1a3d4fbc21c7ea6cc4cb482e9ee692d5a32beb9c4d99b81d7ce51db80178a833fb3cf820b082325333edb36cdd5c4ca4793fb1717e5a8eee8d434b82347cf085a73f9effb08cef33a141b3b78ff09150d7362f7b8f5f30c0b94ab70dca2de80ead1bf1839f7e601d18e12040775fdf402159db2190e6b763c20ebd7246d351df2dfa4d8d3fbc94da3a442b274441477a6b89dfb1c83a68fe82371391ab385b2c5915fe7192f2b9d51cc6970e888392098b78d26aa8428a14c63979ca26fe5c4e9d886b248177bacf94c01a6873ec81ca474eb2b2a3990ca1b3e20d55b000a94b1cadead8d36bb771ffca9ead387c848e709fb44606ba435385d881126266b0a794cab598b7346a92d47f39ea2070bffb3961e8b1a6636621db4dc2f24027df69063e70fae20c2259a1356ab20a72c8e9f4062efccef46eb152d84e3d9c249a16c265af536402d751aa5c5e2258bc8a5aad9ceb9a503f6872fb4bc7475e3503a0ea55a5db42020db33ea856cf9cd5dc955cbf6875645d5cff6705b76d70fad8b502428489c546185c49991718d8f34f0de87f9a9f1e5a0d0edf32fd66f68f15d3f6347b868362ca53848055422ecbbe606f5011c79b20d43e8061f86452d9ab0ebe13930b3246881aae41e8af38b883727e5ade83df2f5c9a3fa07432e9bbf314c2e91aaa4bf6fbf4ad8e1f5635326afa6e035458c8eae6794060d4706af5a6670d71333dae4b0bcf52e237e8aee9034b60f02a27234f935c348268e6655037f75718ae30d5cb959adb859a22cc680f3f97a1d416dcb10c63afeae3ef8fc9219b00ce0493c53beaeeec4136afa4b09e465dd066e35598d658834fd40fe2c63ccaf67fd47bbf5b6fb5d6fdd2abb8212cbd8a792796bbccccf6fc5d71af3e8fba2b6972bceb0ad36e8625b8864f8bc85726c47514b0acd2658d09d79fac8bac21f796ceb8815e5d8c320e57b7804929d5b8f00a3d3b21044a7582ddd04411aa31cf4afdcc745640f31faeff8da2e12c14b81b7b61c31e41732e356f138738ffea8f1400d9853717cbd64e8af8467b1a45bc6a09805847327944a49c0b6b55b1c95fa630a6bb6242f5de21d08dd447dc53417b2aa2d5f3af9345ab91961e004d355e62dd33d4f3eca5f0ed9863d23d0e1176fac7b4bdb85e6589877626f614385780f76e2f55203e88306cdb598f182d3663f916ed3768ff158fff66c56ed39a11b773e1f7b475f7125c2de1f332f631a24a0e097d5320da882b999410cc57369deaa238f48b5181c6f63729bcded4bde106e528bd0ac07fb58aba9ddfad3bb83b3e75e15b56e54217f8be5a1ada3ff4bdb66108ff42a28fa262a48d5e5c77d64d92b73ee404cd237a42f38de66e29fb7fecaa7e950f240581db26801a0690c86d004c0c12d67e3d39e70067adf3af8c3d0721c8c5d44e0362b1a7d51abf09643878f3e7824ddcf551b3daa3a6555e828632d57958e5b6237dee88a63729d08836592750d7dfa3a3162eee512985021c5a26f0b0665cda154e95f96b5f0003a956a8c00a67d692e350d4646237450588145d69382712b8fe0a850af30c24729c87e6dd0340b3316188afe1fd765a76d735a607d4b7783bf40656fc7206a64a22a3043066961014cf6c9b55fc6706edf45bf4f74075a1f66d3312c2cf58694ce6aed255856d12a287101a73d2d7c3745bf792a950e4451c3fdbb1192d10baf4b07854fcee42e0ca9ca64fdb4c03b1cc77d59989762e90e98721ac1e924b098b030e9c77c34e94ea9638537a46d5dc3bd0d289b5f63988ece9763c08040ebe767979d245691b59fd380429c7957adb262dad365c05ebc85185e7635eb2b2f4a65584413ef4118b5d881525b238ea9d771998aec7fd65414a169837bf3660e3469afcacbc216c9296a624cf3a196802b532cc6998510998100ebdc67a075cc9c09f7c167d1b865c4e7219eed9118a2b08af9684ed6f8db56f100cf9fc8590c23ec4c7a8edb422709ca254777c38cfa4f26e25053024684fb4d7a5304d2905b75a7956313ea44f8a8a27dcfd836050e88b5bb2d3e5fda75355f305767a36e93ce378d444e77c48909fcc372a69f25b866c4f4a18949b9e0f90df007833f5333bfdb86a40f3d1f8166ca828b36582b21898aef505189cf8a565ab623387debf0628b2e01532b8fa2982f02476b65be4a2577fe8006933a2025ce9b69b061aa8aa9fbdf0ce4b542b610eb42c3119e6a160fac07a6b566cc734ccbb4561f224b3cf433a54601690b52022799ce352b7cab8a6e2ca808c0f96b1d2a74823c84c88be42b14968343263580c72f00d91b0c09cba5d2d6b1252fad763f15466c6433422702e1f760e90e9c8989dbad3276e6ba256dbaa0da5da20b244753a2799589693fc9c5640e2d3c89413c1a69d33a6b9edd23a88e8ec3e2e5b57bd48be0b8bd7007e50877379f1af70cd33381b8699b58e938ab8e31a00cfdac234625df4c8e2d521074df10388dba75d880748eccd054138a373a0b8be700be0d3aee145e1741d23e8f1e2ed68442b732c52c4e61d107102d5be936c23169e2b091410c48e6d6a4667162d7893db84083cb83ca349731975e5497b7af97dbb44ebd5d7561fe038a12f6a4392c7f139e6086c0ec45ade13eb6c61e5b8bb9f59fcd5b6ef68f575a108aea1c34122823af5346b5369476465011f1ab6d35ad7ea7abdc98f9b7e0abb54ad57d69c80842e2c4a01dd58e041dbb2a4e2751ad7181f92e4d66d890938bb99fb1c564c283e2c48ee5154219c9e51937e04a048166a93b15625986dd1365fcb10b79f665027ce4c2ada37214f555f9e06cd362b25b312f75780dde67585bad9ac7f0ff0d2979c632ce31410284d11b0eee38a2df61076f94e86051096aa53b397f30593b9ed69205b3461d8d206b698caa2c7392e57421daf2dce3612a9ded4579f88daf9a2c13425030ef1577855d524ec468c472096e5993cb1f12c4317c3ec64c541fef0dab86c0c72d032a312304045264c0c374026ce3471fd323d9baf1691f54843043b4f7a98bab70bf638e4c76d8e82e83256a88fb3de614024f71968a00366b775c6f896453b8625534f8a0d504d602520f64dffed641ab08b95ccf0cf58556f85f33ace0fef8c62a0efa2d5f8333b91e1d6205573bd310ca3d975fbfaeb1213c77e5d821e11a68523796ae05fbc3b0ecc67136ac7cdeccef2e2e5c944c6213ddcdd54497004ad445b8c9cf8407e8dabee7a83c9f7d5a7af56291d8a793f8e28366c6832add113b5ce6b32cd5b99f30b2b2ed0c867606ca11de284154b21f7e4c83b7ff0636f417c0e03a608346b5bcfeea9841f4ceb102b4c40a9d4c36d906a9fa7731b3b4bd162aded347e1b2b2a3eedb6d33deeecc95e93f3f71c15d67d808b2c4a8634cc90f15ce7062993348073a20579aa4d7ccee2d54bbe8360ebb9f5232ddc73ead51ec6ba6f2dc765af5c87f3086de1c22ec1ee1c7ec1511b70d0f2c78d7a8c01794a82364437210efb24b5f5140cf4c4976ee394048e26f6a931e51de4aefeab3fbcd761170698fbb5b6026ccd74b0483967dec3a91c6e144bba9345e1f917da229ffabb5c578d88868bbe0d719789771519e76ea75f053fce1497435937fc1a067541e9b4ff7362a17edbf4f5a59f5a084d4675994a611d11899211526dd1f19c5cc520e24ea19c5637c29eda5895a49c5b262f8b99839d48410746610de686e2c7ac58f91cf1a855182b5c1cc312a90cbb2df086703b365471afd3dba49aaab38fbdc65a85e2f5d9e4a83bea6338cd7629505dcbd5366d8481d7024a82f9b2b1952fe750a17cc8ee8e4bb5f22998f4d52924f71dfa073907b7e21513700bba290c8751d73421b900c2dc712acba88f5d00a89118e27419866b5010f379ffecf70572567254e91f05df0f8b04e8cce1aac9fca054930cbc09a88150e82c16abdca67452e3dabd99b32d31a2934063d81575eaa81bdaf8837bf3fba1b75b184e59d1ec90fcec6c24a30f26a97be07c9f275857244cffeb8413af8e429203ca5d2a8a09aebaa50a19530856be56f2274e2c6e504ed6f16fde5f60f75fc5e42851c35468915d424b97de7c18b7e106ce3453070c3da642da06eb2f8e588c6d3f14c233698fe4fd86d90881eb05e003b96a240e48caa1976f41ba0566a2d83565b875357017e91b9f03b89ed523db67288e3efcfd58f30bb2f58e9d61c4cd1e103e864abdf5cd7497cfe3e4561a0a9ba684921a3dc5501701d268358de0f4dbfc7c3cce33bf7430090025fbda64c8d86ec83302098aaacdf1de0c6ab7531ec77e3fa3a183c29fdd5f7854ebf4a9a09d8376f1ee15c01342e221356770e68de466b1a92456d15b3d410f74617ef459f9f4ff65b33baf5e5c79c169277f6d2779d42f3d1e87b41725ab53e5af2a6cfaf52fd538cc95581d6300d99ff06cfc8e568a0eab6fde7005945acb164e4716bba82a2682235692fb597a9259d6b3ae6ed04f539574d19ba111c25c78b39e58ecfdb58f8bf52784e3064607a2f7dec124ac5f078b0ef6eefa990fca830b4f4db5050f45a93f9609703832c7c8faa99cded6b0a4387d2a8539adc90de8b4ed2b9fa8debab9117d2087e73422023fb995fb84b439e3d50e425018c67b51884de0236b46087d2594d9bc24acc89c936f01409523f70322907712f3b0638389af4e12c8e024890f94ff862c7cba6edba686a81de49bcd51c1e47c2c7d9ed02838258f238c05f650c2cb396eb2c1b5c9a0dbc25b23dcac63f08d149014bfd30bf3c500093f4b5123e0bf3cd8f26236fb0d30d46aeb1ef71c5e5fd470ccb4e1d161dee91b57e7a1ca4cfcf8678b2d043daf87abd2759b57e0c1f1739e32cf38cd1f9e746e9a63a4b223783c1af55ce9d9a09199f18ef979c003041ae119d4f1de99245b4820a51e41a18c8d5ef3c538232d374338063d482b66d05f12d43ca8517a1d37fe1c89bf858832352079002d95ca8ab7de530e3124522fbecd2eece1afa9369652f2c8a2ff6bc22d377a3aa2e88eb355ddd0fa6dd1d7facb010e9b7fddcd86ac1dfc61ec81c49db5b00edc739dfb46144d07a7adcb6c39cbc8c46ecd5ea247e58e2739783ab22d92ac1c2d3bcd504bbc0948884ae8679ed26ba4ec21707d5c23f756e89c508fd7ebef882fabd675d2cf2eef7b49a352e01d669c3ea36f3bae0a6c699b72f2b3bab7cc609425341277460bd99f104344f836842dc77f7530772afc09720099053bfe9f4eb40cfb02b80e7e4a21ed2a0e45c0e5c16972765b7f1087b9e71debcf520fd57ee922144f8e15a43920e3da933a888da0f2fc1ab4ba685346572f17d30d3e5af4c3e581071087df238dc8b95574d99a9cc31b24f8fc752969b8998874a567f26f9d5a0d0a4a9339fed5c8c19d88cc860c69736c88d2c39c97fbbfabf3f8c316cb8fcbdddde25a2f9bf8729039bc5eed3833b24acbef34f587cb0efa92965705ece9f8661d860f4fb0bb59efb239f8a9355933b26cfd605de03b6c8496ef5def0bb63fa0e49aedd3421ff637200fe15968466192670bdd3f2c2b230b39848fb9c616b0fc3334e06c7640dab2671f56ac14df500699c647906f3c8c052369897178779742bc4c4c536965aca93e7929a06f28a1b274aa2259b9c781e03f6f7609f4c767655c478fe84e2f3802f0a49e348461a4275f2fe79541b448d72b9fb00e8e872025df611b43141123c7e0d99bb3dae3ffca2a1bc91a49a7a82792ffe1fb034c589899c0dd95850159f154da9ca3ea72f4d5ef3d7f5adc823904097794a473a10f1342878aac303e8cd88473a27fdd6e458c920e990f7d7460196eedeba37110cb10da22e331d7f973c9cf93dfb29201156466b45979a73f18c86a1c7eb81735a4824c67ad7ce197c40ef1750fdde27f5b6394e167a0a97866df9e829337a535d3e7473ef12e81331eeb4409d98476e6c0b141ff4a4ef0a479df772b0a9ac3a33478d726cc30c7ff856dfb200ee48133de4efbe5f5a3ad2449c9abb7a0b3e343bfdac39d968ae7bb32473aab2ec39767e55a0ec717352f446db77ddb402226c3fc40a3db3f8cae1fd84cdbdff3f490b808c98b8e134fd0e262f32f7ca2ad4ecb2433a9fd2f40740ff1df3afc5551ad42e8159c53ec82116012fabe9cada10fa2e99d86715107a1d836dac5f8d21828d123190749d1026988b85386e4bc0d1efa84dd2a6dd9542c093c45b092b9517024e1c64345e2f7406673212dce7963953d870b3b3c9312661ccbbd0e2cc59ebf5b42ed1e1d57a601851d076625e67b6fbf1705afb8c562a3faa419d783f013ceabb61eec42cef753601958160076c6a638ed89cfd01ece671b442097ec1a52128ec69bd366b09c9ce6ff104e65fcfb5dbd92ce1d9e6ad8a898f64fa570868c085b8c2ac4d753ea9d7013b5825f8030016161c29972f0929f5ff3a574e09ae1731642d9c07f31f86ba904b08cca833faacf6b378021a426b525a161b46b984ed1e8357df8c9a142b54dd1fb3e553e9ab57bddda2996d19e0a0758fd7d0e08cc229a007412e3e1a7dd89e5865efb1021aac1088e98c78bd5e7eb95d07cf5eefaa27d98f201d88001c6c27df13aa7482b874f679c4d2047260f218211df4b54773589a1c4db3c9793fa6764b394a2f3a23c0ce87eb591944da9fc10ddaa48f9bc01c87398392779d81c76acd736efb5454074b29733db7689584d7bb0006ed45d0d62a1dee0eeebdd46b5141f03c2cb2070f4fdc2bfc727b378572b42c8634ff543312b59aeda2e3dcff8a6eccebd6b69dee1c04695da03df3af44cd1d6abe3887c276bf921137c671c54a72b38778d12c7a87f520dad0afad7b3d2ea9ee703ecfca4931468961c53cfa441d1df3af6d67aa25c702bfbf99d8092366e2f6021b05153805d815ba1eedbb3d6eceba79af2cbd203ac0a2960cd933762dae3662c587ca956ea9da435edc12168d0d9bfe383a35e0c5bc2e9ec154c6b3485ce61a64bcc2e976b53c96e7744f2919cd71d346ad5b71051e4112220d30649bb1976949c7af3d0247a2edb58791a434c9423060092572b9998bdef53b6469d124a5e85dae90b9fcea8d159a928bb13f6fbb45286daac2f9bfd1b2e51cbe6cad6f3e2255f5a3b26d5af509acd462ffe5e5c32c4bfad1b2e8ad538e116810ae43a2f3d09a0390c85a893a093530c18bc85f437121cfc5a41287c2ae1244a018635bc264b65c0938adc82605f350b8c845dd766a75856c15a90f91e14feddd174af96bb7180c07cc3df3643e2857442aa2b852b49525d1268c5ee90d7f5d5ec721def0497584e8ea2998292d325c412c6f05900edfafde66a85bc0c6937cf9e47e7bcb4e5d2436d5708e054039bc21f2890ee7aaece4e4227449241227ff30478c2b73145c366aa4ebb3672fe88ddc64f661b1ce9bfbe1c01188f92bddf1105425604810bd86ad1fd999372723876ef2222ccd48b2237d39a296772d62bf6fcb6ebe890d14dea3c6b4e5b274c8a7f1a1c1a0e9529b3e9e1b06dcf7b43fb7cbda9ee7301ca5ecdb03642f4cde1cd7c51220f2779971e9f65af68e0e542223aa3781cb2b761bf627c124932de3dbb3f819d1c2f0de7053a4861ae2ec9a31beeeba1acf7c4941ff7d4e409f0e83c3a71d3f81fed4760e509dbddab5cf975499091d57c8bd3f3a257de1f2242ecb44c4959ef654eb52efdba00da1458a9c6c984f7d5a689858db76a6de04b3472c181fb8dbc907543f15a98eb9668362f37dd2f6b74c364f714b031f352c57094c828c435d3b16a5681ef7044797b80fa91250145d5aa969d5484378c5aa3a664b68eb422155c39803fe91e855026b46e94beaaf6cf41adcce6171dc36f5c8c2c5337e5062bdf0302a63459a89358864cce70f51ea2f263f611559f598a8339e6daaf672b15e24ab762d603cac9069470aade11977d53fa90733a69fc531c70694391de88af2719e0793cf646f3bc1fa8f02d2e43c45a8c925b890eb5e66b44516822f537efc21398c3874e653951fe12c672b43c025bcb4a663c4222df7390bc04bf32ca62fccd5e47dbd41b42ec1d3d41fe3b4a7445d21e2e285c48218e2239f56b82d924fcd04c3fd1edc052e6f1c94511b89bfb500c8b221b6a54f6c9b2ada47f844eb160be3f6865ae55a4a6b144681cc8ce81c1d5fdcd3546fb9dfbb3b992cf1e5f76842ab58b8254c8b1b8f56abe1439c3805977a40e8a6cc206315e55d0c16c25df5f3e7869e2462220b5fd2627128fd04122793ec31c6e6658c5495152668aefaf941d33aea3582a094d9cb05f7fa850af4478dc2d41e5f03829a9e6f7a78ec2017dfbb6ba80087a608d63cdefc8d14e000e88bea1578437cb0da6930cec71ffe6f3fac3b57a6df284522d76e232783173fe71fd6649e8b62bb506b96c5311706df7f31e86524f57ca74827affaec712f2d6d3bebb202f29367f5ca6b3e51d01d70301afc63ad92e2bdec1e12d925e7f89262ba8f61c9e6eb9f660728b0f1d3e9113b37132ab4bc38ce260b80117a35c68e609c9852265d07b0c43a85862ff977a832810a685cb5bc0945c943ffacbdc6a2e9fe0afbc1168ce85fcba1bea8272bb74452bd4227534c6bad34f1c5a8d87c42f213f50fa83eb6455cece9cf8568afa20ae495206faa08a560453ef2a36d955b1117cceb6abbe0eecd6a84fdfb51dc1108313b9a13b8098ae5f0469e920b386f186d365cdb58fd6cec4f8082e877840c0423b83a44f13aa0feba190ea6d0e67315e34dd82fcd1470586e56a97843008bd2b520c9b9a8272d483b2d90364e4057dc0a7f084b4dcfc9084bb34ce7d142d1e97a62a7a4f305d387565d2aed0a11076876760664de6ab8246c09babe7c058b6edf123a1cf16573d06fc1ef0c0a4d7e86f4b6a9f941cb19f653f57490114d63122115e42d3ebc149fece2ecd198dcfc9565c74f8ae741a6f75f832133ee896332cfb027db8987b86791a255528235b3095c437f02dd0a02d49a88ae3a4f11530beec87c98b21ddd37c03984cbe5042a810f90b2f95363946459d9d126ff8a6db162423f82abc54dd53592b32886fe3a37b3016bee2cf70131223353117ef3bd5237b7395a2016a82d61134d7165de4db603bf6dcfd60458516b31f3877463112329b37e69835a4969bc7502876f531a24b1d05564d4105d928825d03712af417b7a06903567923c0a99548f98a5f44afe4e3e51248b409b4566dbcf95790b6c758e2d8ef41fc7c9d41673692466ec7d5dbb6f0ca75730943f70fc9fa368f776a42dc6051e4e51bc0438c8a11e435ae92488b3c07a68afc51fc1b080daf398a9d1845ee11426a0e20c510c6c480b64c10e8819b471852fc99c6e652aa44e7f88ea4375ec16b11aa46aa5b7e5afe529f9d1040083b5551299ec8672789b932f872524ca18db5341b966c1b2f0243764b4df34b98d1e743b590fa1532b2f4f78827d09744a1e3589da236d4ffb9f734b7a85cd78ea4a2daf90d0ca07f15c1539c590d7b160121b22cfb08e299b5199030bbdbb5a575c6bbd0e8548679553077beb7a0fa84b9673a00818e72f0571ee786a08861746f831786bc4c5107f42425a3b310570dd7b57ccef9726a628b78fbf10a66149c7bdacb2805788a559aa655b5afecc9e61c57cd706321d1281658d498c822ab31862940aed4d20a3ebdf4af0a519f42608e8e11abe91fb26d33476de8de780edfc5464e9736c177ecfbd89ddec413c69ef9580e5cda348ec4b9e968079a97f464a3b4bb9999a6742759c2fffc7920d025f276ee4e984fe84a8b9800baa3785dfc002f36c8d64fbf1b2c145112071afd22b01e7fd9c947e4649419aa6684df3de9e99a0b9a8d2a0148bc8a357ab4fde92244cd8e35d98dc3a051335c13759d14785fe0bcb45be734e47439e44bf812261b341c5d39326bbbd9c28b64060dae79dc7ac8c89bbfc6102de11696daad76df8dd2017725b08cc0df08112b25ea7fba79dea22774b327332d827671c78919de225648960e2820fddc51f1d12b2dd4f7be248aaa8c5d475fddd64a7c0bdea14e4ae6c7c573da5659fdf6aef2c5d25f8559b982f933ce5bf018652fcfcb80c59bd02adef30967b988bb7fdbae4acd58c8af4cfa5e24610b3b8661e92ea0d4594e1bbe792ff7b77dc1dbc1c033696e700d57d47ca7ef2fbbad4aa93f155408c3e058d45b63e3f1b484701e96bdde0773c8334cfb2ba282e83a8f1d525fb8c8a881a3afbfee9bb53e7440c91d2cb65b5239d7f896e2650f3616002633422e6250bc38b20c3bbc7e51d98a17833eaf6b7fcae995f9d497020a53f0e83cb4cffbc86ee644f282721fb65f2b5b6b37bd64bc975509e4c4d916d30de6fb901041e8ecdd43c16d96c786c4fa3f999228d40237db142737d25fe2e412c930aa6ff8757343bda95523887f92fd9871a28d7f86fb166fce60a614eefa767452b3b0c97abaef27b3b735eeeed0894e196634c786a14a129419b256f628cecc72be621b8f264499cd11c2f664041521301797525d6e6695a5cbea4c4fb280f87ac293e1f8c33ad1885748f09ec800675b3f4ef51ff22bf0908cf22d5f12b00c8b8c8251c2b9def4f93ca4239335b8ae626ce879a43342c54a0d854d92ccc05d7e9be52e829b0017528f53af89cffbe434c8a02acc22d727030eb09186b61699c77caf878bcf4d7ffff1846da53ba2a9ac3215ed27b0de6d59bedb36254145693bd25fd8321c0dae5b56830a24cf87d262733b1d2b9d73a8c05ea65bba043b00033504f08e2f004bbefe03fde150455f2d3cbe3a9a6801e6d3971f366b14b268f8e0d53db5314673a3f69250a647fee034c4a9630b8e084cfd7074c3f5a0241e46b5a53c85da45663156efde942470a162e2a7908b052d82e4c51c8f7cebba104040db41184ff5aa05cb03fb3e2853e85941eb12249855996f4d8b017a31c51c33b9601b996a95dc21ed62eea8bf24811a91d4ebafa0af894a930522f0d863d2de7496800b4df520ffa96dae912d4c4affc25bff753e666f44fd9fd98b695ebccc16a592f27f2795ba493a9ac0ebdf0a104e9d33fa764e0d31b6e3a4e52e0c7e2083c982f45c05fd21dda2aa8dfe66144790549da662d155b0f1b861375bcb5deebf506cbd2d39904fe0e759025668cd096eb65d225f6029f12b93bb563e57d7db05e225f76d2d25c43cd48150d41bae8166852d661e556488cb2f13d9e9f91c902009e51611ab0c578daf72c42c8509653cbf47f1cdfa264bd22acf9e6a9621ece1c55246f96a0e88f1beedd2cc4f41e1b235f214131f3c012153138430801a63d6b9132f179127b70169d3ae3a985e67b41d86dd282ca13e7612708c1bffd942add33008ebe851ea8debf7d7b03c11b19d101ebb242b31114482547ffe5a67f51afd16708d3c40d261a4a1343d7527dd4e8981257cdedfa748bcf0fc7b687eb65cad299f9431146335519bfbd7caed0ebb191be4241d3a60219493b03aa3cf7a7681bb1daa0510d8d0edf5e1d095d1b4da7cd3ac10de71ac4a5dac0c0641f832d01391816ed9354710cb5cd42c2421a57b921f866a62ed5814aa00940b63b36803283c44e80db824be6ab62bccdcabbb91179fa6fe20ba7bdd1745e5b47148cb029d211e6dd418c687a844558827ba1f5139e0712889ccdbfab4eb4ecaebc74955c98822a53ffedf7eed2456ea956764f652e0fd76722f4fc598c7c0d6fcaf52e81fa6a795fbec830a25ae3dc49d5f32aeffbf71a80dbf0c4a8c7dc49867493d6d08837b44c913501029bc489db40e48429c8c439bc1c8b39c81e7ff7029d8a8a92fbce3b7d0337e0275f3464445e7a51514794f53a7517a4fad330f9314130d649b1015d923a86d40ee13c831a7b32a9c9076c88d03e44cbf9a693cf8f6d16a30840865173c56dac1cb71742b12c3a18ee681bcbabd064d12cd148a055f352ac89c338b5c09803d6a07bd20643c68c180e9dd7acf49739ec07cd736e9cc0d246aa8031c5ba6584af6e107c5d780a30bbe5d05f86f216d3ab09760e215fe3c8eba072c1337477fe317a0114ff886823dad37418b232f44303d1cd205ec41d5efa046bd7bbd8d4135f4f0e59c8e36207d413ee65a4b3f64bf9b8d6075ae60eda9cf03334d422f01d401fa3c850d1fb1e01a8ee5dea079f131af4838553cb7659c05fb2a1dd8e124b209cd53bb207e9c07afb1a89b8f7caee3ad55b0f81d399465b2374081b8be593d0f93231fbcd1f842622309273115ef40dc89ba7f011d1096a7bfc65642c7b6c16ab31bd5f85a18db80da1de8c8a76100e99f870dcc5c9a8a4863385a35fc173dcbae6c0f7934d869ffcbea9dce4cda2fd904f2bbcd03baa900558a170afd5e324353b1757e1e01ea75b8f2c5355340c999d2d0eaa7df00e229c46352af54ae6368757b0a91342b012fa3f49c0353cc0079a745fe6a27f6fa91c88bd9f5ab4493cc135820f28a16e14c1c2285eb12effadb4a74d394660b4fd235cdce9ffe033bc6bb4f055ad3d609bbf3d402e2b48e151fbdaca98fb564b3836169660130650e87dfb8bda237562e574da42bc8ee86168bdd9dbb001df44c297d3fb97dfddba2e9e6e72e599311f5cc7490ea4ecf864502b61dfdbfa6ba3c977421ffc40a30d0de0f4f794896be955163c9b1296ddf033e1bb118c697a835b9124dde6d4bb10a30956f02687af59fb046f80f02042485a177d99ec4df9ca3a69ff17606d2029cf0e0f6728f5b5aaa4ec3ea0d3803a5c153d59fcdcbe4079bcd95ea36b08112578ff3734edddd586df3d03eedb5cdd63783ca52498fbf6b9755495c03e88e39463654070fecb22457d3003017b200ce9a307ac00f154122c3404ba3e10758d1414532dd839b83137c783897c302a7dd56e12b776e7f028158b17a0f9005a9409c7ca41999ce92bd92aa457cc1292ba3b6567ca9f454cee5b801a1523d099a2864e3018ce0789c4aaf34abe23cd63b2ff351692c329c98bd05c5f70ef74eaeae4b7dd69cc98d2ffd3f87b882879c3b9d145bbbbe3214bf955ad673bf581a5bfa4698f6866968a0e673487bb01f6b266c5885ceacbdc51c0e41aaff8bba3703a6df36f27cebac87c45f2e62547a286d68f677e4f4d6105f502ce1c40756774c0bf9a9feb9167d75d613d9294e6131da3970a609db416efc810f485b6c44f00edf27c6a9dbae8a7fea29368cd97ae33d08e1dbf6aa3fa1e155bbccf543aaa782ad05f7adc7f2a3ab13f96c539032a1d9cd5ab107b76fe22fe9b4f351c41538077be3e357b308aef8c68e0f31bb30e0d634ba045f7a6d56da517d61fc55395ee656c106b0900ea6b42ffb40219ff971ca8c2db23d03beb5940de1d57b30f27fde622f3cd98e632db4189d37f0ac91505515468c67265b1890fe65cdcc27c8df11c31d70f0468920dc0b71b05a833edc21059a52b3d68d9450817f98bfa8d40f3d425dfe0d97593722ce9b1d3848dde7ae2e026853c00e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
