<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5aac7a9c42417b867364b18020d5ca05e39493f45dcce6f689735b9688552dd9752b9ee30b8c87ca6b12830cb8cbc0cdeed5c1aef325e4266fc6b24c2abe7fe82cb75a63677acfc95828dbe13f656dd385bafe1b5924097acece72bb6914c308eed7667809f2b8a4637c9ff80022d5ee2f93887cf543823fdfcab380041f52c2e1d1e141b3d297bb3d8b427d11facdfb1ddef6fd81af37a903415d441442cd0902eada032fbabd05fb4352a47ba99f128e44f1165320bdd4d373650d74e3bab714fbd33e1fe29a2893fa4dcab2fab477733f0a86c5d5bf364d4a9ed0d99870cf331ffbe851758167e684163ed28a8954096635127e4f426ee4ec8f0deb00cd4eed8984c847d9061611bc06b2b1e89607720643fc19dfec0dc5f528ecaebe9720a7857d5933ab3e609058b4b59ddcfaef7a858b8320dcc36cb72e905ae038282ad72031cf2884e4facec2adc79dba3b2a6af910ff54bfbf13ce46770f948298c68cbc3fa253303da8a8f7b9e3914565106d5855ff81f012f5b0c2e3cfb647e0c0540bdb35e654bfe9af1c4f651f068c010b6a47033ae0a9f7ee6045cd40cf6e4946ae763465cc822395ae2d6455529c3ddd5adb52be5ca1635e50bd86a1d442836451b9b34c7a6fc644663778ec565378a9ba77941df467a1dd9c3eb4828daf9d43e706ce0e9ba6c971f53594b97030407efb72c4e1028d2929dc25294b9ddafd9d156748735cf20503bc54cba3cc4c8d2f18611b7ef0e7bf1b39b055b1c9e49cc194bf7bba781fc60f284e9f8a7ee1e99043a7da85adf7f329159fcc758ca1657964c90c100a58ddf4242e6c1f8179e548695601e8c195dc20d20b0504846ff155989ac28fae573826579db42a8b6521fe17b970f9fef5bcc7601f48e8c8dd1eab8e6d564a4d8175b57749a0bce0464d17796cd84503374f1bf21db898ad3091631737b7b9e69076fb04d9fa8063aa624bdb3a9052cf1246ac37a032267924542c5f35d4ee0bec48314da48902604056b85bf81905ffc342331c7156f9240fafc6b8b3bae15df42c21cdb77eea7f6f2b9fe56ff3fd025c717b7e63901ba9b71e3eef24921852de34377f781fab67084ec968dc2515158276a51ee6ec42ddef82d26b488b964d18b8eced9efc1bb0be6e003f8e5f6b09314a214fc34f03ac733863f7cebd321f7e223f5a51ec3b0f551ff4d71813dead18fdffe317eefae4b761854e072d21f2982889313b39f160b54ff25efec8a249552e1ca45403b2660f3ea06d828ce6943d5598a95e23b84c963b5d4bcedd3349387aa46e96dc08dac5a4e7ef1633b72626f95f5bf893a11e71e34363590fd1274c311a9bedc91da09c4385f7a2006f14570cd47fa8ae6389a16450eda6e0c2038574b3d1033ef1e98807eea3e6c71da5da89e27bf03ad201f59980464f4731a6fd69b218f20e7a67010e2d1de149b7279628a8500e457ceeefded47b6c132c33c417394c9abd28faea2fad7a56f60a9dbbe92acd30a1b553a8df1fc9b644e4989ea09164e4b54d4136b280cad5476865a0bf6512093788c1b506f9f2823115ea2b75bc07110b27c89c0b1a410b39ee3b71987071f8714f82f926d68e57883e9b4578f1e69c0cb328850f497283a1653546bafc91ca507c427b4f595be87c9e7bc39b86f3a22d28af5a8a4a66f5c1e7388132ef76eb7ee047a825cdd519a74f4789cf43f07e2ff7f88309648a4265158b9f89dd4342dbc24a181e7f34cd0f4a3da11f9e77d5f12dbd27ed49b81ca5e9da486463a9d83d2e8d50caf4d40c5e25e063d3f47d539fa83c67744ad8f70b3cc7952b37eaa873e7a78ac006f493e877f21dc25d4653e17a53656aeaf64ee1862592ca448561b3fc797e5e705008ba0a1bba4dc02bb876d5610868b6a63c1a82d01263a7c8fd41fe9cab3a130355da37e75e97c3ac0f055941ccc73275eb2969f46cfe27d888c41a3e0ffe6694dd08badb5fbc3a5a416102cb2808ebedae58e0d80808ad3c5c9efaf88e9b61398b84d91ff0725bf9461e412935b9ab5593f37f8b1f1ef8719f4e3c980ba6cc5f2042c5f78dbb417e9f42fbca45a3ffb17fe7189a7f7f9b33548852ed949b4cb3a92c2de90e337b95acc6ad9d434436baec73ca5c55407f9c162af10678da20640affcd7a5913499802293ed7105a9a41b0cd7eee6738edb585d13244e6418c53389c6550fc10727ba113b8e904781753b1650fb3205061df74eb1b530117f8502c5bfb802138948930a4d819ddbf18da51c151de492f431d0e2f8461c57e59eb8bf3efafdfe8499afbd9bba5f466856a67f703143396222b360a77edc644f1a1b2c6bab46b91d6aa5ac1422ba274a58677df529e1bb6a827ddd19fd27eb69e4514a2d257a6af762d30510ee0fdba91f4ef5ed5bec34527745ce8d709ae92f7052eb7b3baa8ef6da186750bee3917a9137171e62aa60ea6db4539552790c104f5b4999ae10aab322d9a666424b49c5aa5a68be505100c32fc43e6cd1832db223c4c782e1b36869c88c6929c47fab2b436cf0057dceb32d14e9cda453b1e16563cd41849b0378cde45fc926c18d67203a7a7d478982e4cd4684249a20846512c2f27ba5f5ad015aa64bbabc7aa97f2487c8f3f7623216281ff15a513e021d801f9737dc9090608f55b0ab012e419caf973d4f66a93936b3cd936308ffa20288a057c73e5ce0d8e8188c188c3131760e36f217aa23aee63fa8f436fb40d9cfad061af918e1909406710cf262eb98ae3cbb6739be25727b74b3e76bf23790f253e6ec4e3c2d9929a3f43c69f30da73baef550c858323141cbf0a970552fbb9a381508ba7786f9626c80d84866b1bc442c85bd0dbd63d89be952410454c21e3d3e70770b6dcd9ea3c16fd7e31de142364cb6d78f03134ba71579c1d3fc6c137d075cbb2297801853987e6c78cf0d96a09fc3af3a47ac24d57e962389d606b727ca9b15aeed130b37c58a8eaff3049ee07b1da4e41b1740e25be217ecc0ebc60017f05ca3b697d4c58c1731e68b5d59cf64ae61edeb88c47b05ff2aa1875c6b113a806215f01dc6e883cb2661c738ce0210aa6ea9e5d9bdf6653852aff0109bbce4d33d198c702c9175ef079c2a9c5cbf8d130e5528cc63dd8ba67c5a7efddc05d314cf9f8a0cdadf5dd2a2f2167e97f3d1e56a66ea99c4977523aba778afe90be68765594245296806fb470b1e057ae9b1dc01f8ba67e2af38d414dc8d6951343aa7706cd360d8acbcd37bf4576da926372cc9cde73603706d25d6868bd187a54730005b5b2420f7cbf66152a678684655b355dff69bda1ae7e3d202341d1df80f8da15fd1a165a5b7424af8c95a32bb9e443ec0b72cf9388c58be1ac6c66ae0464970d0f87f0eb3d14b453b3c2af0639d8684eea90295aefb7b7d49e50eecee9ea72ce4e639aaf9e79c197bd71c28b0b6a12f6a3e0ff4235f0419c62f46a5d7bd04ac7cc74b24f8d1e9b52c4ce37078eb9647b27bc3e04895fdbdf5c271c7e74e0f4ac71041f94f5844c342dbf5b34c6b2747801b4a1a2333feaada1589a981e7890a3c94b93f6c01b31f13fd1026085abbe3c58c935196822e9fc2afb251b05c1d5d898b3fa17278226f6277d06a651da91257a8154f0980936b7ec658d19f6c818203cd70a6bc09803fd74b80a1255b61e8022bb65234b0254016257aeddd311ad006ed94ef015f43f3c00195417933faf3707419402aeed32468fec0dd97a98f58eef3934fc7ed75f8c0d889f250ad238ae19a999e64f9c5c38d9c805ea6f47980740dbbb54a8d0ef359d6b5f381109087d75d43a1cbebc8bd7162a1518a81830f35b21d309cd747876c942a172ab1c19e116ec3661182d80b9a54ff5738938672217d0132756ddf992ea63ed355985e58f8323559f1ac4adf26e08456875c7edc9122a99898dd0a29e009e95fe94ea82204f78d3dc9004685dfe22a991a027f5fa8e8b94ad13d7353b49011f0c0ce20e0556563cff030230350cd7c19b2bd7607dd18acfd78242424e09957ef1ecc1f1321f7e2cbc0d52d4f30aeffca73eb9b98e7b305cc36d20ed5e5ab549a57fd69f50aea874ecc60c0f746168feaed617bbd30db18dd96251db70e93661d822f37ac3fdf9237d7b2890ed065fd2e5d286a59bd1c2b9dd4d1c73f6101d063b93aeb91d838c0c9c5650f39c3ee873ace3ec1f7f33951198cc64d96f124aa00f170c237190628374030989736b339551f856c9a9639d1e8e12a04c54b39f5858e1a2e3c3718a7759e7aa539e7d13b4a8a3904faa45225f116e5af972d77c659bb25f690a423877e069e258407a0fd2f70d3e64dcda2021cb410d3bf1e799dbdcdf82b62fa91e3e88d4712b0f3f673d5d9803274dc15e40e0d7587d465a1795d71262bd66babe2f80be7fa3558410c8e684f62b1f77062793e638784d400a72273d003b18134c6a1b124ff7c34f3bb2ded2739171ee072a392e6d933d7557c37d2f4363ae4db39c2544ec8d40e2d0ba924c4679c8a3e0b19fed951ee944d7186d429d2dae94e50950b569fbbec3d1719b37d343dbd9bf0dd88a6c6ef75cbca6db81e4e81c2655ba2520ccab56ef1a87a47a89862829e7a0e94c249802905a3436aabb9c399ceed8578e502f1bcd2e5712fa84f07ddff41d7f723e54b189179a01fff22d7a43b27dfe9c0d6a5556903656589abc86de77017ee77db432bfeda6a870236199afadea79fcbc837518b9640f60d5a060ca16cb5192c474c8990a8c5cd7595e8c6735917942a307d14039762b331d0f47805687347bfcc109aad597883f9d9cd7a92a112e5060180dd8d0726c1c40bc213a2c238f139de3bd116c7e69398c458bbc66e8157acad5a304d9c4354c52ec006ba5b64e2bba63a2144963da7c8e2e9fef5fcfee775dcb1ba2aeeb6d3bebc9703594bd5995eb32ba6400074aaf43bb4ad7f8a0b1c283abd794cd38043bf9df6863ce6d8990889694b42218b7572191d14cb68ffbcdaddb11a10a34d856c219131b809b5f4a066057fa0afeaaa3a1bca1edb7b3366595f1c26076eb273c7fd6e09119205267183568f32ef3808c27277b84d51cd0ffeb98eb7e5e024fee59ebed75bd151c2e60c836116274289e5bfbbeec52875730e94c635e5a106ec60cd5178e5f99dee5f485e88cbc8110981c372b21d33e7e062b5f8262d825f9f815e82537833352f5c43c3f0d4ab541eda66ad72a2c55f81d5c39ec35f2149914569bfd71359d14655515ef8edd06ede373d0ec26ce18936d939be9fcf706d733b1a39cb34db77f2275587c56a4f279f6a9855053da299306254f861d7aefdced1c97a8c9ef15187a8de05a24a39ddd09e4c940852afc146eb803aba933885985f29d1441be3bc9d0a41d1d08f3ca1aad19730d3776d8be35028f88de514de15283f364f19307713f5c0038358a25ebd67359e220b2bfd3ee3787c997cb7a80d8c5fdcc8eb05c29cd92fd1233b97d60e9a4ec705c4375952091af6057915d2b57ea052fcf6334dd47d70746234a657787c6cdc2ccdf1f08fce3d0de40a05562aefd411cd551ee2c950fb31fe10d07cf5bc2d99de7e907c5a4ab8c4426348b473bca5baefc0fb0b05600e7a74202314ba13bdb2188186d6cbd0c1e44c004e91e31d5a4414cde70d8f8f57937e2f634c2b8adfa80177247dd62ef10ea1c7d851c8012a1ec2fe3bf9d4bdfa4fc8d78c610a2afa87916d1fd3895d8c4c7ae4322d58855c75dac512a50ae37245373a6efd08de7df30765fbfd41436210ed87f3e8f771fdb257665005bb0231dedce4ea0fed224cea60e15ddf2ceb77d77e20e69278d37aec7dc405645dfee62c10587cb600a6aaee4cf0d52a6cd099a5614af252021cbdf9fb45932cfc173e47bcd5d6b14bcc31c5a12683e526fdf64ad47fcc08a1d216d59f8e5d1d109ab09895c06d22896c9d7ea63bd75e6ad13dfbec41172b352612b8fa4082e9967afe30e231be4cb89d8f37166cd534b947385c3d3cae0dc82d15b97fb4680119e45b50fc1e340a79f00b9021019a6898c1c6b48cc2992f81dea2e6b45b6150d0c562189a737c90528968062834e40ddb2092400ed9f7b3b9e6865cdd9dca4298fd5409c488e02533c9ea92ba605ddbfaf10e00bd65146c5507a2eb4eb0a501616fd9188d16568ced76c25b5f6bc4626893fefec15698372ad7094ce8cc5736deb87dcff209f3d315bb1c9b2625cc13a4d4197c05c70d4b37d1e296c1829607e7a7c42bebf5d3c70d3fc98172dad9135287d1c100855d2c3bed27cb226dfc8e11e91db5b456a60a00ec059c370d0d38e005f2f98dce6c300d4fe4241c88d3604de713ee9c826708339688690321b40b36b9761069844091840f4344100bb0db66f148c37036ab972e857ac0cd64114718af43043385ea25a28158a0ae38feb53914c3e873c78efffa684fefb24d048c9f671059bd8abdc5a214b58f97fe97b912b8033446f0977460c11c1b16b15873efde0e9a16f048164a2e499da308b760e9e849145693bc2b0e0271bdf0f21ae599277e9d8b68b1c76698de5c70c9426ee9bb74551a8aa9528853fd540d3d77b3ff93d40945eb640b13c42952662b5f037d48a2b1a688499e8ba1714a487a71d499f1596cf9204a0839239f2f9c9d8dbf9abedf141485759047be779d8de99ed94c1082c09a67c5ed848e27f780d036dce00d7b62e6f9fe7655ac12eab1dc19e4460ffb3c99f5210107db36aec62a72b743e15bc32b7eae516d8a6ef8cdbb9c7f54041415d867bda6e3a5eb789915d43d36022a71b1acbb549e6d6927d6c96d08229a9cd7147ba69c531bb3746fea9cb2f74aa056ddf379b2ae730f2a9ab40c04c8abce825a7516da7f992150d0900356d248e81595c344a3f9ea76dbeea3a9e2560c16c5e639adfa44693f0ee2138ad5b2ef142c51767dae01d2b1fd75744995692f6d382005173e799dbf53c8bd11d141102819dfc65061fc1db17d7f8b7bc40cd768dfba81a095f475bf1012433e498e04be076ef71a0974464431d294265294a26275cfa9638db2866428e9040b49d692dc188965af7aa3dfa3569d577454b151943ba33c84cf9ac164e4263cfe8f4b85da242b5bcebf853ee95c636f2d05afa76d08fb3681a8989228d7a387490ba5d5a477c3127f883ba1193c1438f388868ec831235d41e720426809e2a3105234e29865aa85fa3c592bccd438790e39870cc6c6acbc039d83597195490295f6e16922007d2e44753a655b9ed0241197c1efca41af82173dbb89f04f3393cd2a7dbfe3dd2808a23592ba54c0928ce30f86807b9b3fbc02ee27cf2c6495ab84eb4fa42091d1b615e94b66553d8dc6308ce9bfb53d7115801219f267ba261a66e5da29ad314aa5112aa964dc19e99b226dc712b62453dae9bc353ec3b2606e7b88e85d752d8704e24f52636cd1606558192258ff396bc49e49136152d8ca97291acef69c76c1f1bd7e8d6673ddc35fc9254991fef4017519e7ba43015a1e2bb5f1010cb2e776ed521dede8809b1a5a74fd3aad5a04a08d907f323024ef89337225fd9ec6b6b27b157e9118816d162a353054295c732910547b4dc02fd3cbc3b6b5336e2a6351e9b76ed15c6963188421dad4bd9384462e3a066c490793879f867e6bd411b47384203766768c906206f5c0d531282cec6cec317d1fefdb4c7a4ec41affc670be24d1faa8e201676339bf9275856bfc8b8cef2f2edfa0b51fb8d23ebf6f14069526a73b0efeb5e7e4d9ecd1ee5aef9a980ae38a462419b250442b34df8ff6b56caaad6573915c09bc8319bce6c2c84ccd6e8b6ee1a21808ff480bbe038e9ab34872f1a71ae120a56ce6089e32e341f761819d7253ed0125491b14d572f7a649b43c39a10ff74496d7745166431eb9c824b88b4a4dd80ba10db7bc0325fba47c3d47b485f4284e561dc6ca38e4ea85b1b3163d36d7b1376dd5dd242a9afc60ba8aae422859eb66ef50a8340474266d572792c63160d90ccaf17b37188bc9a89d911d8a0de0caac9ca94e1350af0c9f4eb48bc2b261745222f4ebcf889fdc539aaeba40a101cf6df8c7002853e9ba04661d09579f26e4a8271c441aa174abd10c1648cc6a1bb634e12895261f989b2a207fa7b89df19c826bf4b5b90304ab8fe87d1959142a156e4b1aab91519679cf14b57b3e9d937cdf4bdfe7e56237f5aa450c1c6b9b7dd6c7a97c008c0b52d22ec9a927be7678bc743c873772698cf75b8d73f6baf3aa379412314d479d888875fe46f1e47afae23ea718849fe64f7a2354f7e82b864906c9b0bc2b379c31070fe7a5f1d628b7f8a57a81bfaa1c6e630598cf5b1d7e35459ccff57fc78d3080b6fe54428ca898165f39f63e1698e06b17e189ca4e2e729d9366e9b80b6d41eb3595d6ca9743f854d4e6171c407c4af008505c696e6836a38ba1c5dc2421ae2e50189e23066235a3d386cdfebbdc908cefa7d8e1d2838a9605ae101500b30f2b786315a6e379ddc0871e89a990615d86882de8fa033872be4f65b77d4f7eb393807526179c706bd5516db64e3715e181e355cd661f074b8b8bbf88029ae7c3622ce0e901bbfa0dd6cad6302c41c5e8e8cac7ea35faadcfd51e33c9ccc4767043fc7c6089ef739947b561ad1183c84a012c2059381b293157621ec45ab135e39e771be52e9a67a0e212d8b402437fd8aac06ab733b7a99d750058c7a225e3867a4ddb3ac264503153972dc7c35f9427acdeb4e2dd990c2cb28d49964259e8dc4a23c99ff77eb7866f2e27b96b87f28e5262b4f76665183dd3d016f22dde261c19631b99b70df2c13056d17a4ff9c2755b5c68cf94b5d78c7d4bf19a8bf7920c7c14a18c25448c92747c4d36ce41c5d11ed1aa6360a9d28f947b0879e937c317c884b5dd9283ba767384d9deb7bf2542f781f26e42248efe386b4079d981eeccabb4c2425ab6fd0c13f3ebfed779acb0c034b6ac9d2501b2faf80c6b53787b9d3ab00ce76741244baf5a5afbae8355764767711abdca48353746d26bee2d7f9d6f5e7d0783da11bf981905862c6f39a6ac9cc9958975d6899a3a02400c91565a766a56829033cab97647b6a3690611a5050ab35b7be044054046a5ec680eb139a4add4f227da86f486a9a168685b571fffc10ce7198c2846e7cea4a76bff7a2b88790dd97678f4869518a6cfe39b39f79f9d8d61de6193ead56d86004e70f88ef43eaaadafae2a4e3b6e53055a0cb091cd15d0effffb75d4520fb5176725b0b32a43a7943325e536eb74bb59bde2d3c3f1c97ee1a95d9f55b4c67e3a656617b6c6d1cc6190100be4a21d0b6b5d01ff28855eb17fb5a0504e36b2b1e82844b9eecadae0c2accaf6e1d416fad66a1791ecc1221bce54ebf5d3119f7e9967cb9d228334ef8694f4a11a0990ae1eca11383afac0d83f6d09d1d0cceb3bf03bca32d43e7a50c159357cc737aae2db770e172f7bd20fdf7dde8b3c0666a59cb6abbdafeeff202441612281639606f3082a9fe6597dd890e3f2e4a01c18e084bb73cd5dfa945b80b67e5798cf34227a90a9ff4aecc4ee7d8bd57e1173d33cd4356ec150bbd745010fa57aeedcfedbf2fb335379b8e5cb96f1e84a53b07e34fde182e4d77d8f31b0491a0fcc181178b3cdb8f2827108060d4b0862c16c3b94ad52a45f233055a4c97e58784b19252b48fca5df36851e17499c1ff875de3e793f7fc3b4da0aefc469c69182c5814d0c51cc350d7f880ef0653a581ce15169106bb5821373b268c850ccd6e47147c67073f13ce68be1785df0828f2e2e4fb651797782f64e009bed93cb14a8c70de2628f59c5070fb18c99c55b8b997df9b9ee7b4df55478f26e48ddb603e6d786954eacb1afaeec6c0a4442580679e06267d5726810f70aed61e741ec289a00e08695e87b9adcf87816b80e1141df08e96e47fcd4a594775ca852e39232e0b884e50271519822e27f74f5a7a85c7319d4b062976c7caff4da5da965bd36c10137d2957c26e9e9f147e720b9eb035c0babf51e7dc28f1809fde080ce125a4f3126ff027e991840780ca3e858c48c6d95a7b43d1874c06319d3c9f7d37fa5aa8f13810eb302c603b26daa43eac51b3984b4d4d5fd133e3919fb791f94c310e211a0104bafd818f8e7b1933fd6fcaf1fe9e310319275bbd61ac7a5c973d12c6d1e2b5057e3bff8be19c2e1368652c8f10e0b251a547ef0ba6c9315ba8cdc1dcd7ea33c11504f14ed089d47ec0d7942dc21280fedbac2ae45dfb0f0b8e3ea6020f51e09933ea9fcf710ef61d59067bf6e557055b95c9e8a01fd72b5487157a320b0d9780681e7704df0f5a3364c8251a6c67206bf8b4742718a7d1e412b43f7bc280704eeac8bcbdee987083d90ee759d30d2f209b66839eb0254e870cfc4aab3b77aa86276751f3423d2f477c0719645ee5a90760fa76c226f74bc0fc994abd78783ef4c425f8b1f555b28755a9e7cd07f7691daf83da80ef1a8535f3e0fcf3c5b5ad46101ab069e5d5903cdf7802cf49a0bc473331e3dc40d4fac099ed412acaca8a143dd3f654ce09c0c16ce156752c1ebfc35db7e17b9349328a688c20876d058f0daf86f954d1bdffdbde829b80d5560a6d15bb3115429f1702a218dd971ea1075b9a74983434a74dac15e922bad35be50bdd4b3e33f27befbde6dac39a3e1f6269d5a77e428b559665a2d85e3144cadc93de84aa9ebee9a6d0634438e6a9bede321ad7de9ed7a130fe7deba9ec0afc9f16c468e35aa0ca4b76ced4395cd834f0d2bc680ab468edd6208720e123c6cda26cbcd73f1962027ea5b94bffe9bb70506cfa98c2b6e25070cfdb9de703d981d61cad45ddb964fbd9751b31b61f6279dd7c28ff3bb0522455b901a38a94da45654962dac24e67594431f8bc934d284b7acf47e034f0714452112f347788e15ee73667b8bc8c80fa5d18bc14609ac60af1ed4c244c89073f374755d1a70b64189cf1cfdc8e8474fe492a3f68f874b04204d338dd860da0ee877d3b342cd076c2fcae3d3d1cb4dc530b80daa5e55bcc4f2ef2a25b2436e9c6262d79abcd08adb9e01428e2e07c313439150493ee9c9381deb783f64443e42de1e1956c2548e2f972ef59ee9429c21ec723ac3c9729362d9bd077fbc3b76451d99e9d66b80d50ac6a003002c8e13b2e17b06438b04fddb0b92f87a62846e431c1f432a2e9c5742a5f44d99d7b5485138c9df154f43b8c62faff31cf9d75d41d3140946a9ee6095928f5243d28489a5ad51733861b16ee8184ac83dc57bcaffc13bb242fb8c6cc5b0ac3596b21ea6ee9fbf7c7feee6ac48b5c1cccac63e587bf2140ff95449da531e647d3d3ead8304602c741e883ad9d2801b735677002ee163949d039f551c4d79cd266beee9cdb64945edaa3d9ab5c43ff022d2131fe0899bbdc5c63c9519ba0730ba7c2667a999f9a1cf5cafd1fceba89c232f550c795b0e8c9f0bf3b9a69738c2d3976dd87274867fd5276f6b2b213216cfdd5e850163457d98c3ac57ee9947c0193066302bf2de3393c44eb33d24fe22001447f7e7a11987d0213eab9eb243a239659cc0c05982ef8264bb4bb945faffa301f787119677a7aad53f5320aa99e0f39734332e556f0716911eafad796ff66aee36070928abac4f1bfc9c65f3b2066b1084efd0b2739aa3bbaa2c5fa03828e8761637b946a66ef5e2f14f4f8dfc2f1353e23bf8f76d54ad8a09696c3639d94bf4b85261709e9b1a36bbcd02ba02376a3f49b60def943aa64190cb23e390c8ac9fb23a1fd386810bcc282142308a28efb38727c8de758e5ee417aab40d5e065716bb925bc905126b1b31e2f40931428a94957da2ed516c893a579e0be06b458d0ea24188ebebe3491dcb032a6f0e193f2d70230442c281d1d469735e875b673f83d5762b9a05f5ab06056880086e182a23e1a124c14b243a3f544ded1aab4aeb574873645d249628759569cfd7a562929a589309f57f8dbbd394a9d837448209d70fdfcfd331003d1dde99aea414d7eb8942751038d579b3400470f9ba55f66646108cabdf47ee08fae9d3c8e34f62503ed221d0a4df9bfbac5b4135656b501812a3d6dda725d07853f18e19ad6043c846f79907c179f3ff3c54ec18be9cd2cf2b96c3903a4f8e517f5fc7a45f7cfdbb35721b855e2d2f684265d02370c2e750080c82b28a59b89d07a0247c24c7166542678ff7af7aa943b2843a08314be8aacfe59a7f25e9cdfbe4cc0093844bc3a1fcb5c6b49822f8dfe0712c8b1c75a7fe275e82c0f95c16aeb55af951bc535e517b9052a522b8d3e997a4b33d5b0195527f0451441d34a315f66e95f417993d6c13c303303e947d76f39bda1cf0a2fc35c0fbf23091165bbc21b6e1c55ca53b79055b1b48bdef9da8685ffd555ed950d56e0a90d904796e0c4fba4d46ad38aed10bfbaa081d37a632a629b682e61973b458fce6e3ec2e134e426687aebf7de68281a30114a0bf9c908456bf948d74f78e5deb4e8fc95d43f8d8afe846048f9031cc10a286e3a35cf5c8c549cba769916cd28b0505316d65ec50abac7f24ccd576ce9e4e1b56ee96d45d244f7a362c31ec683ca501292155975f67cf311c45e25bee5b07535256b2847a79502ec372e19efe0010de345a6c53c2fe8baa7e9b8b1ac1e501b8ef96f983f603f246e54ea1df4179c730dfc70c36a2d79c475f1808f09ba501089867095b184cf2b303b4304fb5daccbbfc7f6b0561650305c3ec09f9e6ca9d6cac160a83e9384fb6e865f0736a30bcc14f5d84b17c8747aa074a4d59d8dac0adb047ee1015c9a66b4aad9768bb143f6a7bc49f2a61548c1118948b9453605b27dde78ce450bbf685eb64ed218c83fed23754af7a71332ccd4949b97bd9b6ebd92d976b9b4c8c59b0f027cf17af46f327eef3d41a89d2226e4ba09b8b36c955dfb3511514ff962133a3de4072ae355d2396feeb3022225a809389ebb27eb66417ed9fa103a9ec7f5f5ce966458509b9b3a07624563c808d41ba1f29cf0a5c506462d13fab8071eefe24f21027e1f2fca2923a21960fa1ba70bd528aff287d07c4e899d9114dbc7f56b404c5ba5d006bdb8499205c392bf152e660ea1753c97561a62aa5f967742c01f4b2f1afb17b48438cbf1a69800ed56be115d9bb239bed0169a39fc89237dadc90e454b9b232407bfd10db95dd792f52c96c7b81cc8f94b538a438bff29522f4773f874bf5c668de8355ccb569af7c88cc5f43dce299570903bdbf76f529ea763ea0b87b4bc9bacf8caabfa0a4d7a9cf692ae476586a6c1f957ea7050f9089ff3b0116f5cce0a605e89093d9b565f1ad2321ccaf5c4cf62c2c0376082924db3d8d3ecd77c6e4a0496310b5cc1b28dc04de847aac2974c753725b7facdb0aaa637748484246fba1ee3244baf18467274e33c1a399be6196e7860b2571e794b4a6b21185f2721a46ea05bf26efb96e7051c277d2e5b8e95387417d8ea5ca50d8dfd0d6d6d7f6896a0008a1965e88f4dafbdb5ccd600a92427b6c8689c2b88e5fe39763317bb0bd6b6f9f9eb1893253070beecb67c00e86583aaca2763c9345964c75ccac7bda5517f4af9805b839963b44e5c4ba8534eba46dd24cc5d66d34823178bb3f3cbcaf35ee01b3e71b63746961f3c3706c01d780964c793c69023a37d84e2e05404ce4cc7ba1df16a9751721c207893b7cff98140a63a46f438aaf161b52437ddca3f88eb62ac1eb82fa4ef0a8e9e9ea4e5a05b9cd8287755c9fa9d480ed5f57ae768049f7ad20c1cf7674bff4c2af2ba8ddf2342b0127e62e63306f81fb9d338d5815c0917b8719e5b51d3ee680a40a22b6f6f7d0184df89227146b2f94e34144ba29c16ab0284a57cda3cdb809c1209e956db657b1fa3c10062ed8f64f0ee454a10b49c763b4c5b0e3bac9144358e106d292d02d3eb147b1e069a344fa0da66119ed950d9e449d3e0332e321d57f45d7ff742abf31fa779878daecee358878a1bf49214e1f1d22ae0b20707f4559b5708c09b3ba0f60d6302213aa609e1eee802a879e568d355aef22cb5a544c5282f8a139996b816e1ce25a2ba96cd32fdd45996779dd42104aaa6c9cb2f0fca8fa5f1e9dce6246e27f432b5dd08473b4d0f2d32a283dfb7ce0377157d13d956c51b92df476a04e2f8b72662e1ea3b53e54a9365fc227ea8471542d99d34021f92159b3f9c5cda3c554b88268bb74582e29bab8c100ecf0ed8fb2580b5bc87859410560de3592628f9b2b3540373363a3233c0ed11ccee5ad8c487e85e6de73f7f033d025d060dfa132ab01699d921ca8ad1c920f81c38ccf7239e0222317af79d75c8bd5f4770ebf449be0ab762b118c988c9265c74a84f584f4e25710d528e0901239df32dd028a650412d515d4f9aee3ca429732e1b8e17611633b35e1f6c0ae963c1bc3f0cf4ec57f00a05010fd79249088caa4084d3b537eb15562af462c45aef8ad3e6f1f070d9fe2b8ccbba6a2d36290e4707b0140a2611a2deaa168ff2946a25a7d5b1110c20458ea9140ebd8f27aec278723792c0e511c875497fc694e8e8d7306a50f0fda8fbbdc07baed76d53b1046cd7b012cdf438f397e43d0eeb2d86ad33e1887978f8e7caeb98c8f4538f66a3f743d07b91423dd7a88389c6d5583511f7cc60a223ce87c455de126ccc5728d24f72ec4b3c00030cc231a7e2bc802a03b89cfc4ae4f2e7edadc626e8b4a0e6feddd91c06e5124f49580831c92d65c30987000663c0d6cd0b3c74852c9bd78c2365798bd6dda457eb3ef078b168e72ba87e4f74b9ea36612eaf2afab4ec028fa190570a813f6af28dbdfb740ce57a8a48050f426dba01b360c90e2d544e189b420aa9b697e389bb9a542fc279aad472e30a441f60b535468f4a4b0d817d3b33479bcb9bb0c241f172ec7c6001a29cf373431ac1cc13665614259168a33c811297414f0f5d2a919a48079b1823fa090dd8fc9f3c1616d0fc39ddef2025d401c7848d25f7e6f3a0582045a94080ab5332c30d4d0c560be18d68644955be5f11741fc47b803cedd704071853cee3326ef848e1914ee3cb58a7885b2b3d38e311fa012be18e4a61571711eda03b81f544fcca24352b7c39ee583a5c689279","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
