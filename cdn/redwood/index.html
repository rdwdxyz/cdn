<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"bb88b0476c8efd84cf7dca69db8bcdbe2514ff714bfffba1fb2bbe0e4ce189281d0fdf29c8ac47bdcb4dff9ea4311acca17315381c78c18d425829588dbf2d419035e16c1160367e54f55adc14a7d6b58ad85be1c2b53d510c45f5744dd78b4af3177c9925179462daedfd28f6ef0c8d9a5d04536cd851ab6623147ccfcfbe2a5a21e668bc534e4d50c85948852a0c586d282745ef3d2e1f8a367bbeedccf0cf5579609ffe89eeb9f315ec5cf3bdec06fbd27166023a978e65281609a2bb6b891ab96a58b7fb890f32a31dacaa4a539e80921f6ebc290e4f68c004eefaed4a7c481f44f72d71231f5c9e494a963d50e70179c472ea3426ea7d9eaeb463922c292860c4aca13a7a8847ec90cf356a63c4bd7d40650514b08b869b235b3b0d87c7cb8819c146ddcbb1eb5c0006528cc7f4798a560575a254f79a3273509c45a621f2e8de8a7e675bb7bdbe534bc6511e3a7bc4a10cfac14ee6899a4f364ba7826952c35fab4e97b9343a6b7ce39aa71806b562a5df68000338f0cbe05b928afa7adcd5dad1a4ef1cd4080f1d93d4be6e44f728b501b09c237a1ccbfb8232aaeeb7984f33d215d7e43ed107cbff56ec5ada45a4068e036b4c2734246b6200c0e543d2378ee5f55cec3056112473134c2459f685b3219f0db40cb8008aee59929dc32de306021d1997eb6fda5475161e622116a15b36bada79d568161befa583d061270e1775971961e3344e172f935be87711a27bc0c3ec9ba5dd49470a23561e77727cc1e3e8bddeceb0b73f3cfdfc608a5037f376afe98224fde4e6cfb942e1e601e56f1b8ff10bacfae05c566efcdef2754146dadec961821d97826ca5257b0ab28103cc563285e66234f0d0a92a1a422b7b3705525aa9f1b1768850fbcfe92036ab0f00b512219e87a7c21cf0269de7b766ec9aa6ed170a3f4ff97e488314f331404bf26367d357ea68c3d928d9f457af0c034db840de69a6bee32f72d7dbb6c27b1d4529fed4989a4085b057caf59f1d32b86226d1a2605b38438e3b7f0c7f4c76c9ecfaa465b66370816ebb2e1a076094d1056eadbe5c3882ab788c4cf005cc1aeea7464117b739dc6154c2133a3457bc9eed4b2e63659e45b6d2a3b0d99dbc3dd6667009c208c25aeb4184b556a1431ad6547703c254b521379dfbc33f5ce3db8fc4f58fed201bb3dfa267b8dac6a5e2bdc090fa7971741239911175b33e3d4eeb8f7ec1fbab2dc21399803ba57117ac547b6a5e0373f82a486d72b0fd45d4f9168b116f8225fbc880698285c50fca9634b9f9245a138394bfaa3766033c7b81177620f698c4ea602b2fa4c0f7e254df62d6a94bc11e50f866325f0383141efad9d7766823dbd777006d8d62ba6f1023b93b382304906cfc82072252ac5ea60ca65b1ec9e0183232ca04a9783572b7f1b8cd40b869fb6d79d9660b281faf822b2f75a5a24ca4552738d848d50da0f92f20d370e2f4295ce37554648ca7eb48e11b492a27aaac26ff0eed70d3c1c103aaa0d44fd641032642914a20497f631a5620bc8e2c50dc72228b59fda7d79c3f93b8a23a88cc5c2000bb0ce19ea6081bcc508805d45d8eb53f32d6fd5322250d678278855c2999752ff6ad46c116d651cfa671e907dfb716ebce6e7e0edf82ba333f709929f14eb8bffe6598c443b2e08242da2d8e0a9568e26b98ca32241d0f6bd05d83c41e48c3c19af14038aca20819dcab1c97dd0fb101ee38df84503903ed2b68aef4cda25d606ffaffbf7fb4127a74d76bc52f368020a4d413637fe4d96a0193512b2acff184811e321730725c6e0b37f154c2564ccb03d50712dbf7ed3901a4b06cb8596a3f3cc6b89a23469edb21ad0a1bb980ce8d14202e546462d317dcefa1d6bd27b4f1fcee1623a8277a480521ae3fe3d8e4c4375c8910d8d172f9c9820ef4680969d6217721939cb7ef3392d89ed902310cf782c73b88adc188a0e7619586be9dbb1edfa40e59fdb927191b996bd7c420c32a314ff9e164cea1ee79a6587abe82996537baecb586780a047fae86cc4c2e84859f8bb20a41f0e4c7aac8e1e8c8ee894393215ac12e35fd2a4d0bbff78e5350dd0db961ba2a4c41851c71b1db18de104b1cb21b967465fd78763be2175a647a91c47e4fe975f18b43a3118d91ec2fd870d43812fae92d4888b41efb19969213cc205eed92d7f64f4abf1ab7f1dca1bf481929acf595801a124be60031aeee436253318dc9eb45e5138db89f9cdb9e3744783e805dbf7ff7d1b225236c7dc1a05d88ed572d4c71b87ab5c74fb28127479362ff2d2d718045ad440236efbc3dbd389baa00e45ef00492e2be4429a56d7217879e7c786a0714824a21f57bde109173bf5b549f14da6a8090debcead55758e392d75bab888c6ea68776c53b41a9ffbfe2485e456bfc93ada5655c9e597a4484b7befa0ad70f413fc8376594a1a6bad7230244e5b5cdbaee7b168d4f3b989b7674fbc383d42a5cb70ade2b5d5e1831bb0aa59c2ee0b870c5aa89b5a398b1d882cd50bb4cce06e5cb0320349e5a0a3bbf40bb7c1a325a7951fd9548196b89793cef5a4b6d024a9638335f52b5075b53ebbadd7faf5d88ddf1f74a4a532e32f0232792b5bdd77e5b2b6caf3d33635d45687566910d01e8231f45764c03b965d7f01dfce3055c91dadccc2a9e384a4bac38246e119b143d358de217b2d1a90fbf9199e37f3766e259832d2b066782bf454fd3afd2e3e18a2faf1179d4c3896d060da08465dba38b1a88172d41dd5e4f490683fdcf65c590dd59e002e3d63eae430814f1088755058edbd58efa5051d4a0410072d69879ff05429af7545a4aebf36674e0fa972ec2da3e0b860316e4727778b7712129a8f59ad13684f0e2378d8b999204d58205acf1574f9341c9bca6e515bf071a42e4ac01a1f3709c44152c1d349132e1c122add59c94bed600eae7c137c8b3954c992e43cc22978c7dd903cf07b07d0ba953ae27c72a9603c08bdc313312795e212fb6168efd539ca098c2251bf74c052ac2903199d5ce50c816d8b85572b2e1177d3928eba43bd58abde0e8e850a89a960b6c641eee788e8fed5363e3320174c0915873195176a6eeb4f45e29ec35c4f003cdcdc7a15a879f8af1782c9649bee1996160418406b4afca14c65949b7c160926ebb3d4bba1dcc3c964f3d4d142c438a63f58903ad68141dee1a04dca22ff2a052b1f91f89f531a44ba9ec9486f87d5df262d50dfc5431d1af6f1b4c5dfd7b21c3d827463ebc0e867667846320aef286190bb4417efc5303df447462d994cb59356f8c3d7726b37a05ef0d59045cb0f45101b25b212e0299c3f40484a69ea8707b452686bc803c8fc7b8ad63414946d0e929a62499ec09c1557f73539882b29f5395face24e20f5416065950d8a96f948efd8ab497abb58345732ad739f18c041bbedb7f5a096e997e50f15393dc1e841e7d37321185926c8e830ded657b1148f6a38378b15124c9aff0aefcfb6f6ba65281d2ab8b9fa069a7918cfdce4282126a941ee13cfc6eb5cdb7bcf585f9fa64bae34c5d1131a05055d8861d854ac39f0e20d57c659b63e85baf9d499d5eb816c36f1683adbda59195c691a4a926317f8454883fe3783979180352b3912f3663be911a69711748a0817ed9855c5f3eeb9a200cf606f5a27b7a447e35376de644b946041d3d547231a946d3816a0ac239e27771e6c5f973b978fb96f27db7a6f89c8a2196df4f08458022e845c2c15c8bfc5b5c52ba26e52951ad9125a23cbd2ec62ea4b5ca365f171e0b6f11d66172ce6eac91788d7740b178cf3d45e08f8726b792503c0557f03264f0e5573e012ff76b14765eb00c7c0ad927da7c96a387e92c9f0fdc545e8a787cdcd797f282f514208fef09b7155be5712d89dbb97e860ad238cd1eb8811f06aec8613f170bfdd92fa2c983f8585f6599266dda7bd4aa3cc8aaa92e3baae64ab5b06e67518c4efd0f962f065bfd1338530765ee086417832a06ddf5488477b4a8033d3213137b910fc6a6364d13fbc3feda3c44e32f669eed28be9ff5f7b6820ab112eb3569f2bd9437941fdce66f6907cfe6724e9424f57cc7f1b5974b08a7e3b0ce510ee055af3abaa9a7f73152798d67e4f643f91e53ff682e38384f999f93e6d45a63ce8fa03837e1f4dd861e8221dd9504aa18541cfbd788af2d60c3c4a79c42d8fb4b5c1f6a6f3008244421c3d8468dda493f446af713d4b14b08020b5c7a1e5866b8935d5679ffb56dcdc3517feb51205fce94a9e093106ab8d12e7aaf38d31e36ca65620a4458fdb18455cca4d22335f2fca0aa4d60e25ce24ecf8050de4780304cdd4f7e7df3ec9e62a0000fb9485671e7fc79d0094c5fbfc5c9f1e712ced9ca7633830d31480a2a3619241add11ee09fa3e9d35c6b02f7a4242d068e107cab57ab8c72143156892d5870cbab3b80cf3d74072f2bd3ed9355badc0100d977b89ff571ab315dc3812ea38f75e27eb5a9f39afe84909885473c31bdd87365d03d613d1d4ee301b846f55661fab1ed6194584be451291bfbbd705186a6db4796648da47c780c39000a1899205fdfe92596e277221b768ed4f7ee2c2d2fd2a162d371a58612405c648d5a54795a11b6d003164440713e89d276730010ad236a69f40ef852dcf0d4556880c4c3c5ab44a0c9eb6c3a0cdd20c4fbf6891a64a2a782b1aa6ce5703eae8a059e6c18d40832ac990ee915d259103cf795440384b00bd4821b02a4724e1c13fc5a0f829f2be65c300339d40b2881bf98185d8a6a5286adafe5e176518510b19b6a85f11dc6a3946937e7919ead0212f9e56c6fc76bb36fa2a5c3f2095bae50bd9c4163e23600bd9e2a322d5934fe90846d26e483cac57909e2b7b4b07943f319d2669734d4b01da5ccfc8affc93c10ae791396bd2d6d2e5e31b58c7d5cfb289f05bd386596b1c391e0647957330f6ed69f609106cf0e3c0e3923983de6fbad8043c1b2922d33c34a59a3db1e5912358daeb62c130dd5d10d7c8203d1dc47aa5d7ce1f7b7cce692671cb76a3b25df59c0cc800785bbb86ea3352f4d027d4633854d3a121f17081e0793469b4c2178980bb2d644a1fe7e1ff6277977d6d6300ebb7957afd92a952f4ee88137904dff9b10fa46f1b696ec2d70c86c0e1c751ac0088dcc7631884935ae9d998c3c93e634816431204a5edacb5d230aa79eafb26ac9ba88a047bda3db0e51d5dff4dbd20d0b5f2b0f0696c70342cceaf13928499bccac3a23637ebe9c0338a023af1547fc64d9e33a0f6dea7d21f8e341566a7cd13566565683b29de0845633141accaa81bc0d180fbbf5a6147cf80b2be41a06db1e1b4d8f535a98196b214e61eeee4c826d05a5142fc836324cbf2cabbb69d194339413b20ac56189be04dac52a9bdb9a084fbd7048a279e84116125697745ed18e9b3ebc25ef5299dd7ff0963794dbae8c3a648952cb028750029ed24f3ecef202ba7b854dd8f72e63d3b2845ab671c7959e3415f261861b0728871299e8e55cc7eaed5fa231d1bef8be355282b8c05ad34bd673ca3be1fcecc71ba78ebd2031bba0b72b379d4bbc5ceaf4f757fb77adeb9bd7720a543e637690227ce5b44f6b18660c243bd1833aab5a5cd9a5c60f1149f4df835f2a045f23355d0c2a36edc14b139973519c68a1d9b248ebcf8fc4d91f58f0083896eb62bf54bd90f21ceefc5430508964641f45b12234f05a107f33629f1f325a394656ba4e8c7cd53c190082bf34522642b81407bf48b5abd88ab00598533582fdb8e98912ee75cd7f3883fb5ba7d220d904282072c5e6481c006082e870bf6948d3065e132000e5c0ccd29345a0b375d3fa887574baea2de6694c39add1e72450f6185f76eddce9ebc57cb0a2d17c0158bbfe5b1f48793d2761adfd40f733de46b898029e5bfd53bd37dd1a6749d23a1bfbe2516dedef1ad0f1f094732063be2b354606aea3034867f3b6b0d0cd32d7274d2f51601b0eb8068405d2c3939196ff8effd3d2a44f581263b13f0c79df061d499121e1e8bb531f153ada8ef651cd5303fa159a589c0135495ea2559c75c86377193d798634e73ac2f3c3f41387b506e29aa1d70a5efe21f5631eb31a00478d369d90d8f7f52c7a9e2efe4d552d1f204dbf000f191890a5da78239bb54ee6e193bc8242cd40f2fd29e595410ed823e69d9360c367d2b3c7aaa915ea40064f77ba025ab090e40954190e8d0a862fc1bdf31c75770eea65cae2086c308d209ba8e8513083da4d1cc47bee74fc1e3213b4450e2b8d575e8711fa405ab4661b4832b2368f54ecf6df9af955c66506047dd5f651385ffeadfee288521882c3e104007f517c911417c9982d39e7de5009b45afdd4d42e9ad89ca0405b5b8a8176e03f3b8010233c2fa62b6cbdb292cb8daf2a0599bb7c32ff1eed0a84fbe81da370dfb4b37743f8974d6f30747fbd8505ec23971da76a8b8e20ebd3ada53dc8dac637abdf569b96897ef26958c9b33e560163f1d7476cbe92fa8d14d32a048c9fbbec96f52481d289848f568c829881abb98e797e5ff028e0787cf2d8053f534ae92585207ce071884e59f11b773c0db5d7d2e1c6e5fcad4fc85aed0ce302d390f4f10d4031743e7681ba04a109e78f3216a742f861192a2e589a32e51c602e76ef906157dd83187e7cbcf24daeca4343dd17833896ff427444fb9e748001ae86a835ef12a7d9c428649996584ab59ce7ff7afd5772bc402dcd8a3cb7e2b8a998df3553e2cf831063938ac31c8f0018ecc36bf7faac83713a6e2e4a3e823d6c9a1702f38f6f368d3ee7a528f9d7acae754ba87fc8cfc3cac29e684f5ef864686322cfdf57ce5a842c6d29ca84a415dd52dde736c773f1f84a3d1116de1e8f1a843071923371f986523661b17ea5f930fef1fced66e950657e694b4565a1b5f3c53ae1241d883af983b007bececf90e2fe736de453d427418069a14613b92bae9b28f4a87a279942ca5cff0dd569d91c9d701290472164d6790d96639ac07fee3a18ebfc35e72605d8297ef0727258089c75d19093280c10b8fb8ee70f92e0234963df51395049d3a1427224f6bfedc4f79fe8bba3ff7dc10b9bd17e701d1b7015e35c4bcd929cc027aba1b93c9b136a8efece241892f4cd22734c85516216f56fcefec1867fb42d1ad7cadd25327054cff0aa985f831909e091f24da37f69f997f491f20a4ba44921798ee094a649120202613d7339292705cb3bd04bec26fd10fb63b9b5d5050dcaeb5dc2700d0a13d742d0e1c12240116822f2f2fd579e369d6bf109769b59ef175530fde3773b7ba0103a8f97de8cf034a449ef6b4916e4d3e07c4858406d65d837c017f7f1e2855d13a370950981ddbbcf6178c65b59d721e2f1beec221585c66d8d394c7adc20603bf85302cd7cccda8c37dee2332dd8e9ad24bcfe6ab06c6106428f0e0a60b02510ab784f8c954ef1887139688fbda17fd0d2d9b7de06170a8c4c4b302862c38bca964213c4335aba5767500acbf5d0f4158a3de10259aefbdccc11de39e38d883c464ec901c23bfeed40f6f92134794a94f2dead41c4c563790549a5b119aacf3e1a47a02a900ffd5817fbcd4327777fde7b5df692a72276f53e628f783e7c9b9f3bfc7ba5013e4fcb2bc8c22e611f77bee4f8357c83dd8d86884fc268166a47e77ecd45bd3029de9520d9166702eadccc6720eacf032f4221b0b3af06c454300364cde828c430f1c141e5cb1f6f9bb1f24f5330ec4f36a57fc012995268cefbe070055101e3fcad54ee352ec6ee6e842a108d2df4aebe54c1e9fb4f6efd7748c4745528b4f5380ed6485c8b354477547c3ddcc5de8c34db2cf5266a48b4ab22f0e58727bb16a9062a85469f7d45bdf3068bcc76208cf3a0b8eba8b14f05a4ced876e7903d4fcf4a4e51da46963b460f9cfe4912e732b0716fb326effc8bfe4c97d6403c6344f75134a66b1ff8856cfad246ad40e53a49959482300f7c4058f9ef9ce64aefe54ca954fcca9939d24652cce5ab4d0489a7234c5ab861e7abb8e86665f20bba4197f390c0d45749b2cff28117d441ac03a7caa9c0c47486bf365846b6cbace9f76e03176fc8e1b9b313c7bc6922f4174b67e28c943c0c30e54dfaf04df279da4ca1d37bc59d2f6e534c47e5dd5ad7e06d10abde2d42a5a5091b4667daff938dff9aace9cef68766a051e42353649b8bbb59b2660f6f15fd57cbff142ce892ba306871735589c0515acf9573121c97207e59824b37f73a2f48d426738bbc61a6eabb1178a754912c942a3efff3c826365f48d806cbfd60c568e2f09d65be1d2f363cf66e995751c618f986cc8adca33915958835dc5f898f43cfd39cae257b7efaa433d8f3ef0cbae94c9c1fd67cf36d6b92e8b4a77453b1cb8f1decf64ca0d226ef90c03ed7eb81effd6ae3cd019569262b4f6086d15b8cf726da5f80507cf2e90f88d081062cebe1bda197561a2152a5025c6b2b17d87f180042c3ff928a62a9234aa509e102a9b87647e914bdcf3d1b3e190d1c4e0a204faa713a709143e65d2e086c175e43e32690e06b7f34e1c15680ae372c84bb9732a7838b56aeece2c146ca8dd13b4a8b5f59a917cd9be9fd074253e7e6a0ce97cce9543a65780913490afe9fd876e9f9fb8a6b8b8369cab65080477374b17b214f1118f19bac7ab6daf4281e562152b261005ebebd1e89789d3fb131f749cbfb7b057d39269fa93ae109e4c23a2bddd763b8290d1b89757c06aea7903d51784ad4d4949f0ee367392a532c0cdf8770808fd72f2981229079131711459c874d1c7c48a03c0024732a580f197227b988cdd830d2674e34f72b74ff8e733606f61cffb7db1ba715ac53ec974c2c34c128024a38533d77bf380e1d0fe9c765b0b2eddac07fd38e92121baafb74b93e6c1de62c5c3a26916f24aa8afad637db9ff3b2066be25f4c505d49eaf7f206ddd763ec55a7fddf1b7d02677208ed19fdac5b4e59d765f0bb13d8496ed89d838229235b73352b1b6aa6a849bc91aea693cc576e1043c244dd2d01d5438d19c2119877abd4b5432bd110b1b4a164b0e3a4274fe754206f629bd9a6d5dc3d20a7729ad6588d240495a71a8b4d019cf4b03e65af4a4cd01c97af2c1245976e5a90f30931839a8327ce9a77c791a861075e549042cc04dacec260cba67232ef9328b5e8a2c76a3832f4c691fb6e719c54c39662673298556dc62b0f0642e1e34e6222b84cf64d74852d7855aee3af3c797774a86d8699bd5ac92d94e7d950bb6cbf3d78f901b97420561a9b948763beff15807139d0391b35a58e74bd70545844309ad45ae609b925647568434e221d3b98a25155bd209f1ff4e48c742c8f37567822ef7568c887f70d911756e0a3c7bfe1237b29e18f648f1f0ca7f54b14752987c30abbbf4d47a67af5ee9eea1561b4dfd258d5f26015b9a55192afceded385d08702843f0b9462378870cfaa7aefe9d1f564284b0707f186d5e1bef3e018e1cc38055f3c33e058e834cc89e3c16519e7e5de1e9c0ea901ad92d62c25c294d6dbf3da7c688415a8048c031483a33b80cd75ab9561475a5d2cd60da3c93ac010d41efed03c11cbc793e8e17e0efc5d195896b6a4d96361e79b999d35a16ba4ab8b9491737783bcc14712465715462cb9525f2f9b667b02a9da5f466e6f6a85bcdeec9543ee1b418bf29495dc6be77ef2551ac6667db776b47f36c0f4ebe8ad5a98c446e585ac7f45b347481a68995fcbc79a5ab49e4612af7cefcd3e1ee235f54a6c18367f5eeee7003e4158512b3b6c03efcc50f5b3d596df579a79043abc1652ca583aa9e14974be659e1c0be4ea5bdb32f5398ca04ea564bd2b3c57d46e239c6901d976f1b66fd511f521be904c94d587c595eb1bd834f12a3a8fc9905e4f2e131658f606c8046af3dd7cad673ea94fc7b10d766fcc1bde3cf4c6a9b9d4a35d459fa5b204d63462848d2fd06b610b4a77c1a776a94af62af9ddd5a42b9dfc2bd588060fef11b39ac7147a4c29a4261b4a0ef4b2064856c9e5914f843a5b8816bb6fbd604a43b4fa028606cc57a3b430159785682a1f016cb5571ae0104e5b93b9839d6712e620f60f40e8083c54cb52d7299fbd50316eb0e4846193db40a5e5795720247dab89d0c6843effadd2d40b20b1b02c13423c254ad9b659fc94028338f0fc67947ef9e8bc0b3e4694c6cccc70601ae16f7e3a4cf7492413ac1f106b730a1c034bfff87045b8c4c52d749a3edf26d8cf70312ce62af9d1f442ce06450d72349a3c17a84cd9f368de320b80455da166960fb803d619d96ca3da7ce89950214f046899c02a8c965a4ccb3e6410af8c9ced4af7d5cfc54f1e6f04ae38262205a8cf7054d5405bcfc3b33e58f8d24a7ad0ae53c9064004c0a324d8a34f2f51d78125d1ca2a7809b1088deb6a1f763768c11afc7329bf948e6ec5b096adc38a563e4b083ed91cc5916343416df4e8fd8d410be68f5476e9175e8663848f0df8276e660ab7f7d458f1d291d91cd2245d32a76e544c59706560b8bcdb2ee8a3ac5aca7acbf86c066352170b2e189c7c9b54b88d8ff825851609c77b03d9197c9c79ab52dc95edf05fecd53d11bbad0178ab73788263ec4c7019e89a6390afd3531c366dedb66182de1d312eb118907c5ae70f1c9c1c686d95ad6ce01b8aa311c50d1ebc8716241730d4bf14cf40853280355270663f5fbc54b3b8cfa6da55f2531fb6e158837036e7e411b559b9d74064fdf19df22537dec249e43d62a53a95fd7501e82e7cdbf3f225ee753eb56dc4c100d196a31260fe0437ea3efaa9001f6e1e8fe9e38d70d5e26b9cf26c0e60527822ce0f4f6eb574cdbab0ab30161aed7ee421e10b6688e0f0073e6ed965c7d3f57eed57ea01ebcc44fd906d317ce4363c54fe5b6ded6217daceda201ee4450396b318fe4fe1e3aa5b9c7ba73cbb5301fcf5a297180d039a6047fe6444f372a09a8b8a888b6b005c575d218ad0bf2025dd48a5b26628dfcaed184e8b1b95ebfa90cc922516ede52ee34dfb66c25ac4e263484b93c7d0724393070bf2fe1eff00bcd4fc97175732c762a790db025acfbb8d8494060acb6e321835392c7fcc602f3780d3e19d11ae9aefd70390ef3318d9e3c4c556e4a32835e640868c2b3cc7702402d7efdbaa9c9abf72387f03ba49385800ea26139bcbffacec343332a86df15004c99c1ab88b140391b2e9dceabd5ed83cfe95c09b5f4ed756c441936b47af6564a15635e81193934c82d57a8b6bd0bcface75a996cd56e9ec9515f9207fed0ae1ca2978247315e7ee3e4d0c81260f102235381557b489d90621a3dd351f701aaf2bd0254e82b2a64163e90a0ca135abbe7771622dc502a86392dba01cca04365a3ecc101146d6c9cc282cb35c4a60e599f4febe9da95998d8275c57a63fb70f59e92a4c358cab3cd5992a37917ca4259c32505d6bfff08cb88878adb4d58b24dfc4a8a401315b89b94c1ce8d4837bd5fa7c0258604614ce9b536864289b892ff8c9300635886b79d1b49cd6776ac5a5669a760aad244858c794082576a99312a9267fd96ea5b6aa2e471ed98d9443e586b50080a186e7a2df369470d81fc560cc03ac21b6fff279fa596d3c0828bce629da7ee730f146b9158e6943f86116e827d59e990b32fe24140aa7af50a34e5040b6ad9573e7003f19935ed95af3843b6dd6644bbc1de699c6452ecc64652398fbb8fcb59b73a9ea5184d406770ad09a8a357e75b7f23bb438b57ddca4f7b839d0e2cd12902b94ca6eff3f239d56e6255e299f7d2aaebed10c0445a386776cc8602ef919719b13c8136438bc47ebe39fb27a24d27bc1d6e3c44179e3857044b172a52378387e23731783b3998a8d266149aca74f0da37f201b451aea874538a2ab6865d36f3f72fc72eb19365b24c40171509634d3949381fb0149e567c908eb67388ccd59b1fc35fddbcbc57ed4d46afcb31d80eef714f41147ddfd6106e1e8adb76e672463f677767a2bac653d1109b2f9ab8d8d522713051ed1bc2a49a2a5f55733c7aa960e002a995b5cabc6c075d2877270985861834b1db87d93cd7cc1061efe3f3a1c73c758b443546bf503e53f8228a9187b22b2973d52246dc1e6c88b3ec28b4fb34e676db7fd4e002ee18ab3ccfe6f6ffe60c3b37778fb30a658b1ac6be6b2eee8046e8bcf08576fc1b09c6f1fde0eb90e0e288d7733a6134864ab9d5acb2f5a3cc83124921151b5121d3e0ae7e2ef4358d9ae8ee7f0d6d4d833f5d8942ff4c0b2a0570f35e5abae9cddc4eed939e6e31a0cd4dffe35a8388cf2a52198f7321945712d4da7854d2109f9646925c14915ce3fabc4829447225951c394215f8a18fbfffff4c1bddf2f021c9214bc0e5e0cb3974d89a5c49de993e2f0f3dd9b8f97ed173f80d195b257cff22c4e6130f92df12ee83f47e297e14da16bdf1c5b93e363547c8ece10a1cabff659513368d867cca963541b8818ac323312336abba4d3c5e74d982440478e39a451ab813405f0c153b8b6f1d6e7a928ce432b239ad2ca84a71be9caead51019e0282b2a9dfd87702e409f029d2b5467725649c091148e2dcc61390abaa112fc03856fb827e99d01b5eb21ced0db5575a3fd8ad6eefd52248470f0d97ea4950da467e11d865eaa291e65c6dab3dfc4d71870c9a867fbdb65913f8fffc65e13103c08c8b9cd32a2ba647f2c07f13766fe5a36c012994c6720ab2530d97579d4cdd87f73eafc0f56a14fa91d0f6bf0375b765e2cec18f26576525a7d9cb6ab8db1ee7f34a4c718beae2b3cbeb310a159ee1cb92943376c5b37e688c7df2feaab4890b1717f9d00bdcf64ed0ef21883205a1464ce7c3f429c9d6f65149c016bb00755c66a1c3f0737a0ea2912366eb4bae1c6d7a8530d5c708b2dcac8737e041a9c6a31a1f7c90d95dd6bab2b61394827aee105f6ce3627a47e352132fc17fd5a42c0b2c8b1d202c790500788bef37b2625a7dfd7e9839bcdd2925f3ad12ca96b3943dd537e8890a99a024181a23a7c1cc6c35238ca2c3490c62b4bfd4b29f92a5e3ea70e3096011e359f7175cc31e17b2a146b0c3aa1a4879d632a2d6d5ef5d2dbf4f947902c5ad5c2f194b8f0f5f32aaa3d90603eaafe22d0c000c5fc045eaa49ff6e4ead2741cb3fa2891724a7ea29f3ec08561ba681718a52846bd553e1c8091244b8e642595b5319f33140dc8ecfaccf865d9c203f234c8d3fb082e8fc97f8ed95539db144370ad22d4e23ae943891bc1e32e715dac92ab426749c5ddbb36b86dc2bc95d21808984815eb5df15a4644d0db8902eb49aa9555ac94cc99fa688410cfdc9bb4f3da369133e8f25acdc2da68ac13da452ca59d7a6c19a2cf9dd2b33a08dcde7f1fffefe446b048e9c0bf679ae769b5f22071ae0b4c8fbf3f9eed30dcffa180b2415caa64efc57af5c39ed40e6e3637546bdade66de2290fc5a6d62df23f1eb13b7934c2148beec87bceb6cf5a38f952cbaa1d222314526f35f1a19621ea0bf4ba4c00cea345209cd5ebbd94ae4e9a4c6b74dfd6abfa6df6da6862ca1d895a86476c4d2d587506052de200ab1c65f847bc80fdfe6ed2787187a7aa108eb584e9ac9c187da5303a509a4984df4884bed226a29c5777ec6e42687845f4c07fdae90fb02b4adb59644fd5e9f04676abafcffebf9e918d8ea324fd2c43f3cb35f6513f36fad60fcf95f9480894c2b9baf7f1417ac9c4c9f4c4f6d7e543d82f8341228b88a9fd076052030ca0514874a0def7045b22f8ae6442cd2ad8a159794bf3b9216979d05a774d1b4fb35d670ff2c89f6334dd79217124c552e4164d391c2c2c62ee2e482fa45fd794d53f01a53a40b0c6a475cb77489d17671ce1f1db02273c5dacc871522ba71ad74c982f42b36e816e3e104dad641110728ee8abae7d852d91401ec686ac00412ffde80517eda350583fef6d278b8ed1a636af60183d32205be44e0b2d661844ffe6ec056bf04ec6962c92ae64a4ed0321e9bef488022d0748cd2d85d107c6313348962869975aa93f604c8ef52af46406a5cb65daddf5283721d35fb4d10fb3f524425e10b39682cebcfd5262db32b4accf7709f4520269e41b1742898c05c97ee25b02384d56568028b394683738dc5a971fa445d5f0b109e7e9f88fd5881e729c5c662f461fe182d59da2f5171edf14f903152afbb294d547e32701068051ab416c010ed04fdcbc2cb5ddfc0d419923f999bd6e060080267f2c0a2080b2034992fc43cc6dd1903d2310344bfd2d1ca1f694c083ddb1bf29a02cade679423f483379509f1b2a1ddf6c297783b2454ce104b279399605acd2082aa58db3b67526db51f83fa9fc55b7903a9c358d6462fe4b071da7c0ed28789688d7d3871fb4c81e8c50ae6e947d4ef1ebbbfe481a4c9ee6f593e058c2d18f50f957b074a5f69e6050abf6035823bb5e36fa9de9ce4165ab0d5a1fecb1470f1721812d37cc136ff5e7d7e781b2dea19abb66152a6bf3cda5e9023f8a07c38973761121f94d74c80459ea5ecc096e00e7175a39f7afbe63447d2b2a92b146ba396fdc06c5acaf74b32cf12e405fed09cee2d126c1b16e10825d7273befa70b98bec2dc550723b4193b67c27d0b08ec9c33f0c32f115da8f6b303f7d69647758e2829ffed3b4e1f3f9f9affa675f86cfc05543ae41a69084f15b9fe09b4542c6a9bf16968e42d4bcfffc7151c9aad42f09be42ebda3b991cca6832e20a0dfa5553229e1921210216f3e46f29b8a8c744e0c6eeec09b826aa6da1d9adcf929c159e7c76032347b30f500d3a012c387b7ec01577ce12c75bdc7233bc54aaf79845fd2fdd2cdba4ea51fab373e893a5de27de218fd11511b09d642e5e047cb14aa07bf79ec1fd5398782c1efc8b86df7b5bc5d66e3785274e3f68f51f779a1f6d261dd5c0aceb07859bf81c229b7c0b48b85e94c570891c10824682835c72ad9ca86e49dde5034f9d23bfd33436b2f93b298cbd3221c9567c31e9cf692091b85acbe8efd7c4646c3aa734ea7f2a88952b4d45a523f4fe333f9a4b96d6d4f93a4124e79d5949c3656a3c7d68c1a94f6b2ee7f8f5a7be96525d82249920191fb6e45536b552c9496258407de71990173b91fb98a159d5e77e7ba4d6b1960d6a3d454658d31bfcc3f0170aa571e3015e29c7857d142c0f24a414cef041d4c778585719c726bbe617c616d375b25f1f633d4ddbccb9ac63a7848c15d0c66e0623bf2dcff54eda35d2897411634d8d3f60a7cba42e16eaa96a09cf80a757285832bad8013e6f33f6b87ac1cdead4d44c3f9b61ed2dc4f40a9393d3055b2bd720f02a0be2fc5f5f568873a305966151ae7c08b5292455dbceda972c12f901a5861f2131a8ce0cb5333e73a038f5b75758690ef192ec44622be07eaa94d97ef1455dbe39c0d33eaee391421c6eb26a94f73a6ad36ff90a8a74bd8887963cb71f478c3f21910a6f1c8fc0dcfc784194c6c5363f524c66d8b45482694ddca454395c06a0bc31f56b1bb485dad5c6cfbd20e620004409699c1088e35f51492ecb1a260b6d1dcca16a3b9254759d2fbe33b01f59598d630da23429763f0538db002d70001050475c90ace36c0038fc7ce7260a835a1ef9b8e6790cb2159430b3f1c3bbee244e2455c7d24a672a091082fef9f3338bb6185e34c945ecddb16582bf6ebf28fcbfb63648fc85062c2716a5a9b65c5d39603ed0e3a937a2327c667ddf936b5dab2ce77d740f61ce91f860ca0252f133af8e550445a7df361b0887205e3a31171d1ac958a8d629d4a099203e7c53a6a682d207f45ae125c87ae0eed234bef42adc357476b33548bc22d7e08f11cf2032de2cac5f6284aff0447b104c0febbb5fccd741d6d5b793601bd2afc4fda7ed11619862850cf813f2a0048c168b59daa4a05b7ac977d2c772d8e13d780a1818fe469f3bd18579ea907a5019bba157bc8f1ad4a5702ab4a83ccbc01312f17cfd701600eb776049f4274b39a307528276bd51426906f33d66b8a799c050cfadd5f9204edb81fbb6a6ab2451575884c2ff319359855343bd0a9761a5402e7bcc966041f008f7decab60e4af6f980ea936dff1b470aa9c97d30fa4a8a2e53389a7e087ca4aa7c75b118c715719a6c5bdd7117ea0f4d3ebed76ccaa300ada13a7071275f54cafb232dcbd46b8fe325056e33856a3bbf2613b5746656e32ad3c55021a0ffdbc1380f7405909511695e5eaaf9d505fcf997184c841f462e7858042d8aa54a117a3b394171887911f2b92bca289c7fd7db0e7923cafd7a5c6215ff7a6854497a33733000ffbca40dade99067c919aa17a9aa5cb48715e18411888dd40bbea6df9bb942d98fca8ed1092468352d15ad01bc43c6f3f80e2a300694d0ddf1db8246b368b8bf539c419d8e003689f42575f827a7d4416055a19612bbeba28901f30378b38d63f62f3204204f3e35626d3987d65c414fe119d49ffe08d6e20274a74e3b4b58a858b5c1ee49c965d3ffd3ecd11bb20a3c0422881c9c3d7e646dfd5178acbd4266854f285adf8e8cbd9b15acb4dfe5bc553c4537fbf2632e222fc3107bde41a26a6cb70cc82ece05b8b75d9a5484dc034c1d2a039a9528dc9304d29ece75637284f56a854821691fc7f94032ea3a9c55b7d579955974c1f24488df6914aa42bee3de6d62603c39234747517398880335ae296681c9905106ece873aaa6bc10558bad6dd263585dfda4b5ada557ce2d44d79ab526acd2218b42ed60999f31fbf1dd49c5dd002744f63aa5d14d0f6d36642875d95124dfd37e7233eb74c99134e95a68439440aa592ccdebdae84cd75d6397a591c851dc2e78df70f6c17c7cdbbaa95e6f8e3325472ff13aa603f82e7da72204b8ff2e7721f9c6fb0d6e842e1f7f061615203901afc04805c9e51b857c00bac74028a8968305a4ac62c736ffbf266fa67c8bfe29c10cfeca25776f75ab78f8f8fa5d144e4f2ffce89200fe9810ba74b9908e6296920a30e02751672622b93466a0476dda237de050ccbfb76cd602b12ced0c4684500e3459cf22b323891b3b417516de19b96d60da0e1f4236ee682b2f41604185f14cb63d0e8fde7c980ed476bd139882c3eb87e1657841c01a1a0ea07ecf52b7c28d80480adc09bd57955541abb77b574e6ed192e49d6a2d39a1fc647e97ad0345f286ea17239989b087816421fd9b22cd472fe5b006ac03c500d6b8eef4bba605313e045d52e09e114191bcfbbfa3fb6a8d6e74ef6c21934addb490b1f1b134c929bd33648c8b5b792d00e61a85f172d1edc7c38e985d3d999f21aa07f2741fcd119e342494cba71d93464684ebd4f58091ab1885a031f92d5e98aa4f7859b72f82bbb0dd22115a00311078b27eef5543772fda1b82a05d226e57022d755e12b1d43900ff99c533aea0fe33b1c8a89b4c2bd0444eec068908c3a9dc1a1913e3248b3213c54371b538bf4dc43bad11c735c984366e845eb5c808cdde090ec23e8f48d72c227d043baed63dc86bc03ba370c07b0a2c72ef8745233f86cfacbceac42849e6322749114d2f4bffd7dbc4c5b35bc75db272577e677701e7e577303f6ade4eb6f69e1a14da6365ab5d163ea9152439eb88c9b6f1beb4f726584110a1a251f9cbb10acbffea2f24eaeba0bb2003dd2b4552875ecbb9636e33351c7ca86b99c788db2e42ff312fd92a8684e6c54d5886fe752e10c672eb4d221477c38535dc79daa766d8e2e80338ec8bdcc16d44beef9108ab80da66933b6751f72ef8f3615878047fdf6bf9f4161b95ffc321bacdd257683924dce3f2f850af6b53a9673224b97f411b337c933e3c8a190cb586dbef455f84222f4e26845aab61af88eed946a1a0247f8558fd44815cceb495b27a2ddcd6469863891af91c26aedb6f9900fce8d4d948b5f3a78e4d4a84ffc6d3fe00956973605b45129d5be7f9e682cdbb8f977cbab45274dd73e63f80f77c619c2fe4110e3332142fcd381ba3f2698e6547ff3a3a48860c5daad59a194177d7f8e61","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
