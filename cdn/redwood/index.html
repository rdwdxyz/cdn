<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ccdca74989d5958fb31d170d22ab5c4657322eedd47ef153ebe4749872e6ead7138de982a60ea909a33007e76484981bd0af52542f1d464c2926092f2e04968729c09c126ba1b3295ceab13b8c569270a1c42151190b3f3e19e11509749fcecc19b76c1347ab27fe1fd181d33c00d7ac994354b14d80f96b2cdd2761adac76cab9e181d70e150152d0d0c5de9b607bcbed878d5c235db48c98562f9d030bd43df2592dc8ddf4383013a440dfbbe515288dac190a94428da85211f6c225fb4b5dcf81a5642ceb5b737d208029d9d426b5e20674960649031a1c93bb2d2eed2e98edc691a0150a4bbb07520678868fe88272869d068d70f4ce9d148cfa15a2ed66609e88f1b001d79ec827b4eed534bc983cc861fae9ff09b4fd50866c0cbea8307277d1709076ec6042ba0367fac2e37f4ef292af4f5230fb5d14520f63756f4407a5494ca69273dea616e5c8ad28b06efad11d059f1d04f382c986112f108fc5e630ad82a4f1dc049a7ff9cbe2a3caedc11c2b5dce7c2f383b7d0cea6f5ad8637f8f6947267953de8eda8977280bf45ce02cb277fcd19c7bd30ce3b1252cebcaa52537f110dcda4936d4d2bcac3a30dc1580a92fd4282e3a045516253b10de8710a468f76f0ee359258031e15aeb7a71e929790e2b835f876f51d6c7ea2ff90694b6f2ae27bed73da5981f51dca51c726150ad07a269daf3241069d29a1231c9c355b771072c493917cfbbe1906cfd35e12945489a96b3d640fb19ad4355e56a3a543ae3aec8e659f3688f2aea7b43fb18e45dcc2bfb254df54d7813233c8837024248761d4354fc9f14b951c8d91e0ea7b59da0272f17fa09bbe1ce58b605cffdcc21a35463673194353365ef03168e0ec1c00d65f4760610f950ccd46c492eefe8a433785e3bc5b4da7b7a915ae3af7faa83fc1d305efcef1289c589ce4eecb281930b9ccf11228273fecdde161dfcd4c139fdb5afa86502438336c418e7ab11462278ccc3fe8842ed8d91aa2031649133a0209b8abd5be07719a7a12aaa02e041069aa3c3aafa3550f8a48a97bc6b1f8a02bcb8a1ee65ff39aa9ecb70a95ad709570269a217f35faa67f5581739a0b9e10965e2c39982c1788f5f29ab0e2d5b7e9f3d70c51c269ecdd4b9270cdcd5066211a2a26661a8c852357d48665ae54b07331eb04e18643fd35992767116c7471044ce44eaaa836c843469a2910092f49b0e25170a279d70b913e30601aa68fc4920dd0ac6bf78e214034c5858a719b839ad15692e93d2c226d2db817317183e09b5d07e640a9a16aba02d336232d1da8c9bd2abc2d1182a0bc3f375380b80426792bcf853c92f8528f964515bb5e3e1c90d86ce63f3ea1dfe21c1d7c7fbecb58ee83bc80144d57edb5b1b3b511e6c82fba834f46e0610101bd67b03c105ba4707363f05b4fbb006cc9ab7cd39227fec5979ff058c5ba0e52d25d1dc3a92551f57636e4bc9922d7149804bb5c2712ee83bb5ddf357c34623e84366100d654e3ecf8dfa9e33c4dfd1ba029b2f13fcd165f32dd56a95708d35bd4b50df294d74a3bba3850fb806c6caf4520091e8e04f8ffc79b442a9e4f8c07b59e46e3b55aef9d7d55cf745f7ba15ac90b44b0e146e310513a0ad2c9d80d100efeb7baad634e7034b80415a3412efbc11d7cd2a4cc3ab9d2a827cea14166f97446cb84ce65a21a97fcac795033f5f687be5957f68ec97afa2df03073aee038b1330b8abb6b392fcacc3348cdfd2ab2b9598ad6a0af2dc9be32eaf5bb3bdd9b2cb3d7b0509f74afb1d182e07865cb4a2c4d185d747bafd81bf2b7672208468cdaf6d4a1f1d0555f0c541b3bfdacb43eb327c08527bf5d5e83d710055ac5ac7668f7e1f24d38c14f75bfa4f0dbc6cf2b701e153a5229eabbf5c5a3f071eff683b212b79eb8d5db1ed0cc16da8cb50b62195dbb417d609e4fd858106669d9bc2b792bb127374094aa5d404ec6e935c0d76f38fb93972dc00bedaa969b4e518be03ddcdd03f13b5bbf1b0ae76fccf526233aaf7d8951610671ae5a0df9459ad9aca31354f96e0247f50081f77e18cc4c7141c29e46eccc38fee1c6242fd6d2a6c4c7d13941d848be8cf22ef8efd723daae188ad2ceef2aee59caa304aefba0509e226db5b9fac5c3ae2441cdb0f49582d823afa1ccf69368fc77d5178f7d952871fe9920a3fb25d599abce8854b32437e46a52df470039246a05bb6beab3de74b1b14be8985b69f5cab96be2bc2b5f4d335d3f610740a82a1beef67deaea775d4880fb6b906dddf46b548069be2155d2495f38ec6beac5109b2eefc9f587c404b8b97a0cc8f2ba7d6033f713fe0b4d3d791688a3287f9bb69667ec48b47adaf469016b968cc580e984dbf3411d17891ba188a394a73c300cc7a7c110a8656ffc2823bd2ae7ffed0e08f61e7c27ffce61d7872190ea558b4b645e0fc12959482adbec43b989d822864b9cdf576cf83f2ea6b9fc86fddd6a9789ee744fe473e4d2562dedbae01a379f4cc302da3c1e685cb8592952e5cf3aef36d198b5e9f44481faa0d35dc832f40729b5ca8a272f5e8702b7cdde08d59bbc7e7e267903e4063c7cf1f283e32239ec4bbd2a9b10a20c55833d4cea5eb479f5a4b5a101236e5d8c1426b9e1161310b713e469b0c89ee5acd873b0ec071279651b5e752ef755b43a3a1965c212496a2f5fed7cdda995b2342135fe4ded3e67d9adf201d55d298ea5238664137cce6966fd1ef0af7c1faab359288cfe59f719f89457c5de2a3a9b9b279bef1876e4ea359ded2f7e055fbd163de7cbb2e49d027cf2923f449cb1e987cc7b3701d97022cc64b2cecb2e5b1bd23aa349a41b7d0931699ddf1dd0dac031190bc4f68cde7907f439119975c8841dcce49697bc8564b08e04c6363e15455b27db6eb94e93b90dc54d9f713598884c4053a9a409c98bca120f73cee6505273f0d91b81a8ae68d46693ba54aa3772834e133af95a3e360ea958b313170c9bea390249a59f0498ab6c3d41ee688f9b7663532750c1359d428dc0cd50d51d01b12075c94beb3905d98a7316cfdd7496f7b640564ab52f309a526948112ad0b8fb11a151c0575b4a552d1f7cf089a56ad5512741e391793e8402c269100a84cf0678069025c188d72b6b06c48e80940f3783b46bfe647d1b4da7688edd4a3ff40338ba8e7b262b092364e697c9bdbaf06c19a956b746f8ca3fc18866b4499fcd43a640436a7bf02f2d3bd54353d900d8d3185cf0d25c71b8dc0a895d6e6dac876eefeede65e6467ebfd5b2b40e38c8dd6b0b7f5566ead4ee08cbb0ddc23002d7841b51136ba4494912d50feb88f80e2116d8153113b50bb4fd646e36d5c01cfba498ce23f6326731ecdcb67e6a8795ab6cfcdf35e26f8707e87f3c9e1636a4895476329daf29b3242e950604caf3f563a10cd6419563166e846e814a9e174bb91c831a8c193f684d7b4928e0389efddda249486b3254d32e55bfcc43c945d5b15520c4a7d5bafa265e5f3664e7acf52293bc0d4f028780ce17217cff8ac6a2e2d5f6659390a24f16bcc8618c81bf8a1bcf12648a581e86b0516d97fbb612b323be730b199e65ee71145d9c118fb98f8c858a5ce78b4a62090c6c8cb465b8b35bc7c399052408a3825d2226feee8c9d6db20d01fd310bdafc7829a6100241c88a240a29aaa61517ab996d3dfa2d8e5e023373b9f7fa75b5330d592702cd084bd122b8ccd59cbcc84a658abff46f4eb35d76ad13e50a3ef82d19fb817b784fec4b2d21e2321dd062480c470e72fc10041e1de4be7fdf011a10da72a8ce62ac9ec64354e0f1d178504dd5f8a8ea667eb1c0c3315d9e310aaa0c23b55120bd873933b1f607c3bce377aabe8960596f152d56746e35ebc4508280036738b3b926da071ad83c3a1dd6c672481892c3314a853442c16afd0f5c8f730ee14027154fa4a93cde8bcabb39767d46779cb92542c02cac61842b242d4da546ca6f16dd5975ef543e4aafbf2b5f3c3fe0f22d58b01f05387c4c2fd7e46b85e1824513677e32f0497c60fab5df1c18d1299683079f6d6c9b8bcd7862be0836b3555b2c0469ec2103a5861573526daf6160193375d5070f1dbd968b2e9eeb9eea85151385361de10ed9ea12cc9e1841157842511e117bb1f02a28d96b19c3904f14e4921046fc5bf7a9e6ea11d87f9b9476b98bb466bdbfd363f0e13dc7e004af5f13f5cde3dbc8516c04074d00cc35b1f2a7d538eb8d45efd9fe2ab325ed2f41ec6c7eb1002ecbe148231c81515307649c9c760904fa39e6bb6bb09701b1971b534be3664fffa2401e828dcc740573c0bb8b332ff3163270e25d98589b2d7a3b9f045dd72ab04e6f4952c25e68c373fa7e7e61609da578b0a17808756cf7ebfdc7aa4c3db66085dfbdb6483a06f64ef399c74f35a0ee4c2f257f242f492ae63c56f5b180c1f2c37c7b6088f324fd85884d445f56606ccc6a3decf396bd2dc9eedbd6f318372d337911cd7f8bcb73f89672566c3f419f596599616b2bc67e4a234def77a37f94e0237c8e048d7e4839addd1e832ea01ee533fc9222d53ddc015a761387b297895f8b5af49ea159f4c1ee1ac9d0527b80923d61e5df6ab2e6fe89188bacca2ce11da686b4bad093cf80d8c05ca5b53a89fcd284c64e375d329656a0e80c7c71145ccc99db0f083edea436707ab71b4a34caca3690b3d872a7cdb5ea7f8c9c7e10f146d6c1dfb6347976758aff98a6f44a9fd6457555585cf1dc3f966208dfcb6846ad54eed78b23a44cbfb061360236231912c879dce68975c8bbf830ccb1c4e9d7b45285b97336902e43f3ec59e14b16d0cf7f4d8f2e1bbd556b83ce16e4d6699cbd2d37ff4a415990997635075ee63aff58f9937f235a4079ec17d9f4d512ee4168b46e36529978d555e9edad1577e7dcb928fc145d849dd81b8b9c5b2c5766c63f51c0074d10b5852f06168e0f2f31a85001777e3dcce94e3da7d1739cc43cfa710f99977e97ef41607bef9f789998dd8fe4c97ec547ebad39050e1d43de3943c67afce51c56bfc28153c61978f2e8873bb5eff5991dc2f77ba272b672de124a0bf74b6d7a9cc948050179c0f045c60095c37dfddabd693f59fe89675b97e30d41cf173a39eadbddc67e1ce4ae6f1bc325a8c889f5989fdc185cbc44ed6bc9814ee0132030f319be12a6d9f29caab76b404486127a4ba0c8674da1ce1275f905bebf8f840bcb9ce5a77934a21a3b2bf2925f5fedec13e8644f88ff8fa397149a593c91a41c42710e52064f3f71d9fa0517d17a70b66f1fbfa53e12e25823f30cd884630065c23bb36332935d2501bb734f0280881ae8245a34f6f3a77cea82f5ee37e7765b17431ceffbd5cf304e85eefad5b2681a52891cfaf0c1f9c7cc39d9962bc7cda07c78908b7d4258d592283c3fa037ef6b16c9ab820c45fc3ce95ff2280d4c989b43a12ebbab5edcc538f2baa64aa2572645fe28ecf54eb678ea9b230a9de7495271496a12cd65b5be3ec8f47b808a859a2e79170ac8145805d6bc5c338cd0469452b2aec2a0f26a112cf5cb5a83b57bbc9bbad50b13b6a92add69851d5f34b36874547602ad9127d9d3051bd37b19763fa2c12e2738bbaa9a458b46d73774bb6bf795ede6e043cccd26945490f17b4d5e1b13d84d3f36c28336702504b24b4498eac67806b1606d2b01b2213d634fa63af17a0bcbef24a6d9daeb3a040617a69ca445880223ee631fc14271b23e396522a3a55006b69f09688110ab6303648f8460347ecd082e4d7360e2250fb44128687cb6a72020cfc80d75786e2f72c9eec520575a2e2fa8a438a20259e79d3200d863cd4a3d5fe6ee14be4c2f8e45a051316c0f65c525240d9be949d6e6305f71a02f0353b99267786052d40ee80c9ae9a2e1d00a7f844a6ae1bda73ccfaadb11141767fdccde38b709ba08f07c2e9ba4dea6e1d770d78854d3135e212919c360d68108a66e974e8a1597626e2cd206a2f3bd73401eb15d71fb3685be8e8a1d682907986184f583c25f3ab34627a1bd415df97ac2e9b24c3243479e4954b2a32faaa94e7bf81b2602f5d033d11228a61b298d9ce555658c095e386ffadaf147d22c53b3e45e940535442c966dd3a3bbe8e47d0869b7ea280698096d54185e8e1aea45be794bb51bd93be5ad2128f1209a12a0a7f4d944ab6732eefa54de5cbc6fb910cfcb5917281aabf9186f3a5a21e433a5ee07c905d4152a28cf84ee3eff75a46a081b829f81093fb47d96d29a1fa598766fba76710dbcbd305e78828fd076f35775c00c39d4fd6c31b67ce8065cabe3ec7213e923eed2957cd20571e0729cd671d7dd3b9f509d5e4dcc5a02d452eeb9682b5088463cec1603d496cc6779723ba23c417c004303aa95c54abe408e50535437ff0977cf64b560e8e77682ad56edc64b28f45bd384ca4e437f958bd8e165e0813a7a6a191c2fdda5cff25386f48389985899626c82c01cdbfdf843808f246201413d2bb727fc0695aa970892bddd65b903d778a2888bce504318a39d00dc828d8ade9b1470787fbc3f97534d781df36aed105e5f771cac6e464b6f5a65dae465dbe7d58644ba97cd07d59194a98e43fb92d774f5f3da1fe1ede3b76511cb84eaeb10317a35b7c66bb6714dbbb1790f33b65f3f5055fea885ef27b79609c43d17b4a0f9fb337059959aa7b2fb375ed6ba6e591563c5afd509787d439335301bf1bd9ed37cbdb5b091cb97d4cc0c5be824ae9d55314025ae6b64f721a470696cff4e8ee54a020093381ff1de6d2d9266b64ae9b55134915cc5aa5276512b2fb58753d3e691188b3f2be5bb72117dd5b6b53098bc55fc594c80bca95919f1bdc71daddba30d311f61d8bf06928926ccaec9097c148abe50999d76312302a337ac31248d78199218dc4fb8491d9eaefc6b0fa79d07f55a38b64ddc3b40e6cb1863af2a1f51277e9ea1af98711b66292805be32cd4229ee01ac1711740faf2ccc48e11c71c8d40b202b77f8cd0d36a5ba6a28a27805d5c069eb6b287e749df3a20a8fcb0a673bb69004942511a3f696e00117b8f57b9e94b1c688370acde84ba0434a797f9daafcb45749a1e975d587acf7593e484e8195a897902fff641a486e724521aa1229d9c1e4c858e10c5c9e7f1ec22bdce9f7988772bd71f09a0daa848845e101683e449594d43c35b6f0c9610b84b6298d39db730e15fed7889b9d2b4124cef01bf7c87fe37351560f0bb6bbe3d13252bbbdd5c7da09b89491cc14c6494c44307381c3806cfeddf74db6e6d90ea2c1b419b2d0d03fe8071e8c86b7fa3bd56bf0301a7abe3c92610ee184b75c28ebd074207b429bb804634399052d184b3c6049442dcb19b77bf19cb7d19097f51a3d29b90b7f3a819b79d085e76e9e1f888b0e88450f95e1f61283c766518dcc8a495b1bc714e4fe0326ffa21e255f141e1e773efa64eb69e28df042e818d9a4f205f33f138e5fc11355bd285bf05e2832804991e2582443b43dcffeaf1cd3cfd21a87a87d2d6d60ba660dae21fef66f3971a1e56ffab3be6b754465b51af66c13c81bdaa29a81af8846a328a2f49277cc7102cf75397d1d269e7a1de86cdb84c8885c72aaec3e717b6381e7b5680c369c1a1997ac0c9812ace824eafe33d9e5015556345c2b262845e48c22c9218252c58004675e76d4e890f31991430377e71ffae485d188525595570c4e096911190bc123c2075d8362b5992c003a1f29aa6975307565dcb9eb06e6f2eabc8bc66230acf2ccbf035c9beaee6d1b763b28ac3e9528f1759e6975dee28411f96cca79e5f69aada19477083143f4926fcc9f610b582c4b968561bbb9edcfd2a4a5e3c84c858cb4270312a949a2e4dc5ca082f52407c32f32a467c753c2c5c904c0135990d03a1804de17a23589fea512184317de88f4271cf541947db4583d101baabd066bfdf22b135a2a28724358e19e7d537789e14817637702b295c29669405b630a427d31c60736fc86f910f15747d2dc1ed7f651d0ba66fababf5171b202539a16a260e9339b1c33d66b7e566f1e79c1f5b82aa4c5e30810c2ccf7f59e7934ed507f919dc2d8f24fcb9aaa9ad62d83a1e00f3346acea52f983d9780c77e6a7930a581179d949081a7cf7981e6fc203476f719b3221dc0ff355ab4c23b33a44e6a5f84d81f26cdc439373925f4f4df4f41d66b93edf8d142f98f8c8383976928f0385fcd7263c6ba7ab435747469ceb91ed154bb70e4ea6841c78d797dc0d56715e97ab7570e53045ccf3ec74460494458c2b242652873fcffb5e8941ae32448f898994c3d2c7c4ff5944632804063fa52b04af62e5fd547fd834a2291919a265834a0a29e6b3f18a1beade62fff3c18ff42b694ce227cec7e1fee3461c2fb697221fef187261966ba38d778cc0eab50afa8bed7ef1cbc278962940f41b6bc31d939f5e89cbc77fef4ddd70b7bd6207ce175e338c4bad02c98846642521825ca286b8e5c5e4af8eae82f8ba9d28b6cb55515cf731c0168f2a8b3406cfc108813bfefcdf1f55651dcf68ce460057c3fcb3be0d17ab016e014b0438cf13e11a63fda90a726c836c9b45790f9df2a64c58f6e49e55529b52f1fbeb9f90d52212004893e4fa1c84fa7885083e5b7e3220828fbffa35c8f891f208fdc86d6afd45cf30f2b2eae4a2f1832d7d4cee1f27bc0b08a72150dce002cabf99b6f5457c5c250ca1b81b467e1711a68c252342787a178c66e7252e56c5409ae5b78e1115d084b2aefbdddaeb07f3c1730cabb2ccbbd84be31f63f2c2910053b3ef00a3e47aa120789c7692db3a10a1a36ab376323ba173661077d4ed3052319fe0136f8b22ad12ff9fbbb823a2851dd95234649a3bcdcc1d366b715cdf5544f794ba0d87ed4bf852f82c03789a9b86a643df64c3a013f3ed609145573c5abbf11e506640dcedf9dce8903b2a2a4581a361c7ad880a760fd11a72268cc95e289bf2bbcca56317766652dff24df3402fd6c2347499255eec85ee597aaae175b273907cb7fcaad9e316e91d21ac0bf2b5989c7051c3fb30cc7d1f7f4980ad6a158cccadc3ad35c13cc2b75fa2ce47a85e78cd3c59a19746dd591107d0355dc47adb4db64587ad24f25960c33099a30bfb377856da7f688fd51de598fa303ed2402032f1156d33c35c6e809d1090420cde0fc58800f108ea5f9e19ebee49cde4970676efa67cbc145ba49114e8e0eb8149e6913c4c541caa1472a450270e5af8389a1bee4ac1e70453cdf4ced7c208af8a5428e29a531b9061a3e974522ccaf91623a653bf489555e6decdaa9c7a9ae9864d2d36c0284bb060b33a161fc3215f2a579d12d73d88faf217397fd3f201c04928e2b0fbd6a0fbf111dfbece44c9eae3bd83e7d91bf9372370dde4e6baf39c83cfa7578a1386471ea9efd450dcfafe8ca52672da0c7725e88b45cc13247626ec68f2c0e33ea3fa40e113975ff52e74a68bca7ec394c2b664de6849f72034e08f793f6b951f5cc575568ce04e918f2f99c80e83044d519aac0ab024d8872602fc293638ea93308eaac2e571defb1dafbd8654707a0ce8e475dce27adc31f1559d63cd5c62d710e1381fe9cad75339c9ff7c9126edd1ef080ab96879dd8aac80ffbdac1e4854adead4d7c5388b2ba7ae55a8de33ca02cb0ac6ece5d803a10bb5605c49906851846e7a8cbc1addb190864fba9bd6240787cd1cf742cc206e9d69aa01a87261805c6def87fbdcdc97ff235d28e8d9c83b380c203c62aa214b0c4e1919252e0157317a96600fc2a843a19cf8d67613e912c0a18d6ac6490bfade99ff990facd8eb06b23b2de6d42270af681b8ce5f76899a98c8adf0575f2a616d6ade48b928568fce7c9a1a4cf6d145349afef47257117891b243b230e35735928a1045e4214ff633acf0b4e488e758e31fa6bf27dfe04ea81db9dd5aab30618dd314c2d2e3c2441d524e55407ee1e54edc63de16b9c8fe5bf6ed4bc17a655fc1161898bac056f185f9b00e6d8f70a4b9d137e604fb988481489fa268c261400abb08196ff75d1c362874439100600e767ee7035524472393d21ab95edfe501323823062806100bea2989d4e4d1b4ad5b4519e7b19980cf29337f47f96288f160b149d6c2f3b30303e2555c5716b5223d11778d86f0da2aa9bd32d87882bebae19801d59171a766414957d44ad49a2d3c6a465e26efa6eea823f1b7872a24ee6d49a16d0c1b46cb729be0c916bdf32f5f7b37f093c3087d07fa93b0df69b5e4523967f1c318ce96b60f8122e998829f816e494f468e06488f3387e691a35e757962e4fc061fdaf3afcc5b52ae72f28cda75ae1a17ce935ee2cfec68e26c8afd273babfe855bbdf027648195015516a0841fcb0272eb5d1d615951c4010f42e289d30754ac287c315a6a864c61f5024ef0313bda782a728111d61e1106463175d4657c6e5bd8453935b541d3f72e862d70cfe0cf2295c67c72693c29d922a75537604f9e4c36586e9a668f9f0c3807e25724f27bec9e2e94055f871f43afe6448cc4a1ccd1b86073b105b92d4750ca0af1e6ccc7e826650517828a699a6d5c0ea7a1c93f197f9dbae1c5a3880e4d60270f62119d77cd410916b1cf86ca6a09a9a353904a078ee03d683379706fd50737daf2b14bfc6ac25651a161e1e2537d212306c7fe656ed631a9bc41655b3d6bcbb1ae352d8db320e2a88b3792538417d82d4de383153dd931ca3a2120e859454c0db6c2eeb67ef100cac70d111507510609a54546683c15966ebaaa136212441f39449321c45efb2e91d65422271cd9db938bc5b7c663b47bd625ecbf4ed8a7dfa7fc90234ac2d02f9d8595b09eff919a324ca49dfbc0b88aa65d53a5012c199727932a27c667f609a77ccc7960895c1141249a2a21640931b215c72caf62c7fa4c46cb1b987429ec017b85664f6aa3528ffb12393e1fb944ba7ba2bb242c50f33862f3d4c30590675a68a5dd87f33b94e80c77ca45e7a1cdb563d323e73b8abe84b0367273a4cc775c2e010bbfec5b9628f93df8c7fbd505df0d54634b34bf575e4478e3cceabb26d27d6ddc5291de3e4f742db663b94090ec7e8aa5aa036db6037f6b311c362ed0a959c4ba6027607256f0666c6b55c8cddb446c96aa158b068c3d33e037b0c874769dad548699c0e75453bb11b37c4dd375c146e78bbfa74a1ad1aa04e27ff6baeb0cd0040fbc31c9d07ac1ba64bd12c8206d30c2b30cc11167fecdbde4f246c6c1cca3fed090b6393947be2709dd47c4ec9c0853d4ea785b70ab1047d67f94625b8d665a6c707f164a8325c9ebde457a3d4010f8cee1777143bdf2c64a85208f883d954aa679fa6b61709efc4c1d31bff6f23d7f42b5fa340ce03dc94f2914cc9318e664f97a645b55348c26803f034f5321ba48e954bc7432dd7a1cdd30a195f290f135fb2a1c53b55b439cec09bf93a9fc79347681fa0c8e0b8aee6ba0013bd6211cb8494833d33b8d4a7d7b71c07aa7e9e4d63d8d6b8699e1a2bfaa99a81add881d74b8b8b9b8e0c47db17d60eb4cf8f8e11366638a308370c4e2f31429538a08e18981fe415b45774eaba35c3319556064bed0f583018d19ed8fd7646b3a6f9e8483f3003a6d6381891e9ed4dfced0cc3be8d2658c142b8da864b0ffb8f51c1c9b68d57dbcd6fbbef9e6ea7a4d8338f6ff713e5f55c2febc7828bc6ac9e4c672e9db1018a05d63af5d7883ab335df84599f5d4bd77ed7fa0955b5b486233c62a8de62dea0fb00a19f8efacbcdbd39e5487348d2e33c35e72f8113bdbe84e663ef60ff3b6649a43f760304f5424fcd147a342a0477bc17030d80edf240a7a51641cb1703883f22a6e1fcd8976dc2c9f007412a333518ff193ff55531e881fcc9819765cfad7a3bc74aad7be88263103dea996a3309503f5256ccd4ee86c4e98aae57968c7b9cc38d06d6b684291fa9934cca0e387a2c1531b565cdf73648965edd57592e80a9f475adf7d4747907825e75573f58c5122d3251e143e0085552f30efc8d7f24958c834607c1b87a6990fd86f128956db5892fbb8f70642431367d5febd4e1029a991126bdb92b5ef0e6a77a932a5b740d958b914211c7c569aaab8b5f7b1de633b163e355653501b98da3ed95ae9d928e8c05627a490e0a8e19409b2813cbcb7ac2f11b0296e5ca158416e45424db5b9d6c23065faafe2b228843bffa15d7d1839898589da79590b559a63013bad1d1e02520d8044a68573c7e78a10bca05ec196e775e6e0c152aa41ebda37f64880b62c965df7618c9aae69c9f9fe491abb1e9c42bb0b16370d427145562523462a8dbb7f41beb8f85d8e4af14c82121f319525e33ce9b6aacc68c07995f40d86e2618f7a78eb2d2a214f75e0f229f6fd6102b066971b3e57a4fc9b757a57121acedd1cc5472c3a96666e9f6caf05ca0f8bfaf0643b48b7b91ab18694e7a6729c159b3b6cfe60dc70f820f2a9b127898a044cb45b728db64928f46c1bf7a5f71650ba196e49126ae434362a9e665d9886057026f5bcf23e9c3d3a68819b41cd4a1b6a6e30cd7e224db646e32911d262c477bc07ba0f8173ad2019c7e80f3a20eafd732e5f67fa9435cf7d07dddf36529ed79188b043424f7afd5bb0753ceab258a2fde02c66ac68d524073e892fe2554af83903238c460d77600905abe7f57ff8b0d4a15a030bacc9780979e060944b8e513f447e2b7acd97ca0adf0fad22ce9181510f264d0ddf9035c28ec781afacecd1964443853892f4c60b815467a958fc78820f2567eddbe6ead75ad94b0eee130ee7fbe2f477465e3a7a513cdf9e86c72f6563cd9f92e9d625a006f6af85d3c3e774e2c052f8e03c0de4d605a89e593ad66dc13489d5d435bf39e18927533051b18395f8b1282646d31f1ea60dee7f53b581b95bdae9b635b95c5e7007644694557ede17981febcf442ce566b7900681e18d40f4e92470b3f86a3b48f50ac1562e6c164f39df2218a26ed06b07205c127a6c44b7ef2494d0a2a0963e64ae8ca6a0b8717c3760df517afb1ccc8f53630c1e822c9dee27d951f976699103e33a5b20f97dbd6fe343dafa36973e6d0fd938eb99a71affdff01b4c773aa7c44ac2e837ddb26a0dda5ab29f13c9acaa78d9fbb58faf58a1267a310d08d90702744343748725d0057b258bfe6355df032f0ffbde35561996019c162acfa0d6688cb18ebfd51fa8a322def8d5703c3133d89bfd76f49144c36576bd5f91fbc7469a8257b70f6202062dc0091217a1c3bd4f2ff55bed9233a40eeace592f1c04b4afd419642dcecac83321787eadf097b4115a73dd551a4a2cd68556fae18e1a73e4c7820b31ae179a3f41a0f93105a8d18e1de1276aedb5743acff11d409c7e7dbf216185c54eaecac7c7afec72dc7848034c205fa5faf20f52a32b54e2a9dc07dd855fad1d37761adf8a4fd4ca61f8ccf94b58892853513500e34edee9e2c41b1fa93d8dda98ba94865adf582a7ac23526a2fde5d1a32f03eddefe1546f53561bbc2c7b2f6776ff34acc4278dbcc9cf657087f14916665798875bc6831aa9e6a74db47ba2b7d8b16c082cc12b08c2afcccac59e3368e2890d0575914dc6fc8a34ce2f5d1a3ef70d0bb752f24f9fb29946dd4a2bc1daddb80ee4f9e2002e838eac8de65e83e310565e58965c57eac45552d37db12edf0e4bdba7f6d5d0a06ce78a5bef0fa880e9fd902377ba20ae445fce9e69026ca0c19b2364d984eeb8b5a8b53973fa823d9a06bd487a856c184e8272176c1b25d8907d3b3414e52a110e9e55ff17290c82f710d8a558d3d28f54b867c160180e563f3b2a2728e400408cc3dc1ed23513930bfedbd228a4d08a23e2682f9fd625928c00ca204c58d989fecc5ad93ebea4552aab350a218d30ce9039dcf01e623d7cfb76b17e978fd7acd4a882f1da4d5c38c63727af4f9284f5792e28a5cdded55c4a52348ea806605476d13eb5aa995ff927d8cedc2014bcc0d58bc7439db08fc26155f39b5f804521322f8a6344bca191269cc574d1abf40683784bf2c011eb6708e1bfd5eb530c11cfdce30b69d6b88cd2e0669757e31d64bbe9ba74434f69a5c68f301979ccb2c04a448fb933d8e39f5f7c915a0a6d54d1e89b15837d8909e11422a2f32d5fe8876246ce87bc4d08324c571a11727c2a0a358f16d24570d2e866feb7dccc710c34c9dd1959900e06e05407b7de38c4f116b6dc9342b90d408b78831c2727310ac009814d97b1488c609048d4312102e798aca78076e080d050ce2c8a821007be3a4f2ed776c0196699ea3a5f16e81461e5353995fcb22559880897c60c49eaab2da9f95c1ca1e3b9e615d902083ab3207310153fc54e3f665f1ca203f11450d2c70bdb68cf69a60c5b2ee6e8ef8184a5356cbf46f498a2d4a5f3c60be83585e5ffef9ec50707bb58773c0957810bc86c5570a03f893beb826ee60786e1f518b41d0e41c91ac6d079344ee96f892fd61b962874673a9e158daef8d962e34edcee0908ed88ab7d30a1db3c4a4ee37f5bb4829e34f0b896d5991ce6538a07d755dba27f6e7f39f8ff046fea95405a76428264f5fdd00ccd2c8eb4ae708a7baf4949463541d5b061508956731d8fa16de35d1e2da3f76abe91d696dca27852bb147beff629a7bd6d3b0e9ea39513755c11eee0903313b4693c97edf4124cf6cb2065f3523982edf21257e354aaa08d64362a201d03070f5378aa9740d078e868af73f5d5eff39fbc0e1610a0dad42b8f87db63b2e9b4df95eb6c03b8c23f683b440e9518a93494a3a1de11927f60e2e0b08831c74b595f136a4427820eebd74a037f7e79775d6443489f47be6e6bb6f4244c5fe439d8022c8e4c1e7b090b342f9bca4d02377e71fcca57fa777aeffc73da27d757bb513b560dbc7742110cb9ca40fe9fab48af44ab51d595f0c3ebb1e2e1c9fce5c92b89c9b66a58284042a3e0b7ea92c2dc9f9d3662610da3273a16b235385eed9b70cf15426da7b5d3a294ba01aab2ef624e3fecc0c8d6b802d51344a2f2b755b7f149451327245c19149d841117e3cfc2713fac6fa3c253bc1e9ef39a8a525122173adbea8f70314b575c092b84313caf2333f8f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
