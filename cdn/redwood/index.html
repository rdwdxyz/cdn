<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ace414428865d014298a0f4388787cb6d7448278ee98c6d7a9ed105bf136ebbcdedd85398d89b373befad178687040e4670f88ebfc88860cb0202bdcecb0d11704ecadc631f6534fb07758cf3980b2ebcf7163fa939f8d739c2f08feab1ea3277cdcca5a783c9265d200fb0db988411092fd35a519030f13ee941ed59a1b2aa779d37fe4ebd9af652d9bef0bd8f84577a48eea4b1cdf76ab94e7efe840a534181d42f7ed45592a0028c3cb81655cee76f17e05cf1f113310f39a66f6851946780adff98b5aa3c92cbd681230d9bc6c79912407adeb1a3603a1d3c405f4a890c9322ec33425c7ad4861612fbb91b8ebbad42d86cebf98f479ff3599237f40631e80d4b09fd7fedba55398cfbf904062c00868e898b5f2dfb837fd1f3ce38f0ff5dd7685b05bf75abd15f30042c7dd7115ca512334ae692ef5b7c62cd8a1939a99878ec9a927166aaff4925c95e472d9afd55a2c193f6a5acc38f2d43196e0b15dbe76377d66716cab4458a59a754e7d7710301af17a5aa08378ed79aaa7d9aa4a99adfe4909d010433103992f29c056f34251e6fd5e391508c88363ef8ec7ba7eac7d3d9ad8ddee6eeb10c87e3e9f61b1ec49a7ca92f06852aad17ffb4adb5bd83011122b5abb749fd040cc4cea912b84413ff16c3c4d75dfd08c82ac38a8d4d0f2e708eb09557325d71d1daaa895538c2d3b2686406947afc055ba02d19e11f9e16368487b62fd2d089cfa6a9a135d5720beb6620ea9f53c161895075a6e5e016a6005c1f8ae3025ab49cc44f9caf0f3a2873ced5d09f23afb46b73747a9af373254edd85aa9cf7264fda5c61a10bf4553d807f4a22e6b1371422f13d60bd0e81e9d0b30fa663af3d68bb365544753816f03a55ec180eb1db99b208e78a20ae7704cf825ad4c5a07ca3c7cbe925459ed2858aa55f4498f75ef3e9af05a1bfadb6d45078d71396eb3b81c97d76afa5f8819028f680b6308fc945c3e523f6b34abe6d142f4df7d4b8c900d86cca07d75cbd4239433ca8c2c89dddd1223799c7bcd6a98eff5b8c084201d7b21c2f84385cf19621f3c56780ba5587724d6f65e37f0ccca25f34267bca9846bcd87481765fec95eda4c85283afb70782d53e1002fac92a01b09042530ffe5de49307271b1ef4d54482b6c789c0119e70bd671d5f212838749574e3dd4dd5a75256a3ce6e2865e63853f7ece46a07be187be383365d7dea8fe6331cd61cc101665734af95c03609f01878596d1d6d275bbfb8ad697feb84e1f4a80bc9fd93573356cc9b8dc7685d83f2b98493b96b592e308a7524db426fe7fffc731850f288518184ca1dca2babb0ac4e2c119cb2e76d8a44d17fd0da501a2407d50c52c7d6ee42e3fc205cab382af2d3fe1f010730bcd2ffaf2d78b02c6d643ebfc73a7ce456802896679331ba871c0f7505b8ea9905014ccd945c473d7245bad12d3d846ed08c3b2ed20058fb9163a2e58a169c7bd96ed64d208a9321e7e25da2c818b60e1c677b89fab5919ea6e6b177fead0580b2f36bd4a0f657d4a475faa124dad1fa146e2dfc6e5a92a25382c54142e1dcaecfe83ac747669efbb0d0a2802022bd99c5251640386082fbcb7250027c53d547d7e13ebfe2f91ed860319796386e1ef8fe9e1d6736a67644f61efb11b347a4239911c76afc864a937afe8b4d942b63843ece5b301f949c2fb8d301206a1b4617ebdf0cdb41dfd94a9080b671da2236f53f79f1d76d03dd7c43c735c532f0efbb7b37769ecfc7d487213e72f3a7b61dc2a158835ded2265d92bfad26dc26a249649e639a695e430f176610d4bbd8971b3fc6b3aea99771710f20d590a0214acb68049750d7703ce7ff26883207d9be81f1059bba1614167c64920e323062de52e4c48a43ea0633615339ea0c1072403651f84b5517c18fae46852f8b7856b69a8e6e52697ffbb03d84c26640fdbaa9547a33293442e1ef62c9f0089bc6720d975c5ec564f3bde7e193eb9fbc04e707153e5ee05454576086d7e285053383edbbbbfdfcb7359f996355903404227419c122b11926788eea97c9d4e232a0363db6d5dccd9841e48c0b0a66d54deca51cf6ed64080919dfe0e7fec9ca83907172f8adaefde0d69be74105c8fd76f8824c988b5206d64898bc3927d5a74680234577f8d7f5f3232e3067c3f0717246e1ae0235395883897b591e8564141b4cf0f052e67276ccf7e87a79fa61b0317c5b99fb95a966ada7ed8053dcf145bd60d08538138272e37c4b3abf0bbf4ae76aa8e3c36ae7cb347b9267e1da74aa9b2c8155114eb3e6503871978b5ea38712aeb42e005eabf1e163d565407896e57cb625bf9c5ea1ddc3d3b822c741198f704cb8d39684f9e4383b9f8aa8c8a853e0399af245d12189648764c20fe0647bdfcff345f5e5314d34a9d5dd0e2081b30ef73794de4501ae0fe582a3136f4e283c2e5e910328be5f7a9c28b64a79773fc97967a4388fe4e8b45b75778d8afef42bbcb8435e1d9692421710e83feab6b5f0fb225f60de7dbea50f1c0f10c95a103c17a9f1096c97c8917e9aa86581ea5da85f348ad2a179fe9bc84bb2fdeae585905e3beaf87fe8daa09a94cc8699ebe1aea82d0387fc6678543777a4b5a8869ec6516ff10ad99b8befbe4283b516c686cabd6f8df690b138e7edb29b19a71310af12bd3432b3ffd8c86981429321c86d4a4e0392831e01dc5657e16fac3e8a639d55534a08ddd1842455e4eb9758da6559e3f1f588c38845fa10a1a8a9cc8595f1f8880ef89aa89e457e88d92ca14e67d08c16ded5df2182bd55cd28a7eca8fbdf8dc23bd16f8974b006a0301bf1e6666378054c121d5307aeda1fd0e6b725e4a941a93e47dff6f5a83290f3593a4df7216965b577ecb09eae1324e8619c66b9635efbdc210eb796cf7d9d89c9656a1933cdbb6bc5140b67b05a288bd15ac5f89a954851519ef2ba65423824d9be57fe12fef726848276cb3ebdf8a22110c402c9b5a6f599fcb5834741119978b2a58b40b1d01e03245debd59b4ad72ece0869baf9b81c88e3a552358a6cf1059ffb13f195876903ee1d105d8dd8e2193accc5db3d9f39a66cd6b79dd67f799b74d481507a66db8417e3d6e31177ece076c1d6c0d068e10ac9262b419b82404e37ac466a0c7a4e934f78ae40f3d5e086b6d65d8ff13bb0925b435a5129376f98d228e87212e54e8d784f24a2070dca9fefbca508d0c1a6ca2dbe33a649b660739980d49aa99fe08d2a8cfc3474122cf182155a73da5104d2b096bcf8e089ba584f2a6bdc05c32dad3361b2f61406c4b598289cd48428727f9ca82372b2f6ef7e2597f824eedb3e0a9b64de5e8f24605680bebff75a866875e8156f008190dfca201aaab4dd928343001ef2602e874dda6d5963302bbbebd6c0b26512a5dcf25a88fb7c871215d342e4bd44dd112ef85dee5ef1b10bbb1ca163f7d672ba003252b8940b6a2c038f9e495f43296d7f494d3a2f0133155873b684751afebe7b6288adadb0c88073749f214e70ac8f2aebff2d6910305e73b17a0ab3628c0cdd6d61489b168c6567f85cdba0694515fae14a23d1fcba7839749eeb085f2879e91b90dbbc6313e0ebe87bf2bc396ab915197175250d3356c9e553126e6f680025c03cbc8d2585f335a28cb25d2415fe3f01390b708ad3cd6b68002387739fee1975aff2e597cecf51304a8efad0ce5071b5d9ca94c77663c2574772372a2379f053533723edb94a27b8a5d4fa755e065b5e51d871cb59d5f3511eeb919e03c146ca7d6454fe08a606ee71f43c643dd50400d209f20bcda95d2ad1732911b80c46a3266a3d6195a5b9964c18621c856cdcf192a6e084d799d956796f1704c65f7a2573ea2e9102e777531e4c9189e8924c7b08f78219abf9172481e96b4e4dfddc2181e137803a1d36777a6d0ce3f20f241423da12c56a2db3c976dd831e4c924d978f0018621ea9837a1282b952cd30065dd5f530a0b98428aa7946272bdd55712b2d30c53fb0433f87ed18bc80faad313acb192c149362a77c6b45a3c4d24c6af5fa420a7162b8966a297b11771c0ec5972699ecf990cc6846542d5d6a2a123820da7217af29534aa65a46bdb044db2ad90ceee44a497b7989543663c32ca1caf93870a0856498676603ead45a62716accc06c83625aee97067d1be35b21f8efdfa200148698799f70dff090bf175c14e885ff8c40b42069768cae6004b9c0f48826e95c4952b6ff0fa37c112ab43795b38ae00358dd0004e2f7921136906dba8dbde56a3225937f7b41a04f95638a4e1b2cd21be272dec5dfb2ad66ea5542e79a8dfca6a539e7e31d9cefde5c1bcd67e903a6d43927ddaa85c19e5cb48bfb8a12994ffae2826c9defe7a774cc7e6886517c1d06aa0e12c481d0e1d2451d86c4403198704a69e7db4281b599ff893c999ee6482b865e50cde57dbe4ac9060058f4ee495bcf35c9e8de2b9f23cf06e505e630f8be2c151f89d009e02c6e2b44a4bb50799a85dffd6aeeb9869fce2136f8c09d54ba6def8b8f03aa65bf282eb6c2e0aa17a562a9f82f53c0ba57c47500cf999a0d4fc13f65a0991fedb5a8843a0cf5a9123e9f63f5643d91394c2e3512da63c852147f4747575dc5658705223f0822ad8e8ee93531ba3d276596df8ed41fc2df869a53ba34d3d43858a0885dd797df7d84be9112d208f4021258e7401accd530263c84649131ca83bb413c35a97e7e0523a09d83f120b18bb91aea6319b1a6c863c3d2f50d18f439f171e9fbce03b49b7e568975839911a1bc8c6d2f7e34d759535b7c4f034a9dfc13abfdf11d5a4a821d79b2636edec75bdc93fd773a10b9691852a88e9f7e72d65691206832964e5c496b731a9c64bb5c0bf054304898773222645eef064f01d3dc050ff4a4a673c4434d3f4a54249e2f2306be3817aff57c48afe2602f13e09c0d1e7a0fac46b94be7061362b66bc0aa7778675802303d59707b8460c1a5ed40f4d3f3631ca9e6eb5943fab711915dc1383a261aa86a6ba7c8a683a8a0864cc84ec578666d3fa06b6326933f39cc8bcfe3b6ebfa1bc1f50b089f347363349a57cbb6b2121e5332f3d218270ca2245ca34d0415a54155ec70a792a17a74503862d99ff93e9147ad4038ceb927beab001ca5a9613dec7add62821aaa782177e638fa749e444341ab6d83cb28af969043b954c5e3a8d37f0713dd7a1304101881e4e73706054ab5cbd73fc19d065488abe9805323a95d2635867896c02e0a45f729eeaa86c0b34101473bdf40df92b7b60fb0069817f442774a266569a7ec937d8b35740eee331078e6d0a65ce1e1d811284f02cb16c101be0e2c1cb6a2f4a6eacf998661ab4a2f30e717a6d621021d10b0f49c8b34c58e57cf16396901ef5805f5454e12c7adfe015645f02bce693b5bccc6eaacb2ac1c2c666f8110354334b281fd633cdc7c1483fd08b53e4570adadc1b2d66f9eaeba977cff0a9a50076385eeb6016ea803b7d500b41024fce2cc098244ddffbd174bf93c7ded0bd9bbfcc04301e0a496b390b998c3f02cf24bc09c7e8594d20923515f2d64b76836d58046711f3f7c151c1ef24b6540ec7a0a6b38daab7cf0a61d8bd8e69c0dfdef4cde546b5a8714dd94829aca2f750c7d0745d1c2e50ca7eb78505f31928f2d25c6506742cb68a81b1aea1d3be26ea13504dfe3bc16eceae8c2f1f6687f0e0d86a5eb21cfb667de5dbdab459c7ade2b76ec1325e156f1fbc8d70c6808bfec727514f1d34046cb2ad450009feb35cd71466576a5be6aef00a5974433cf8c9af21a2cac6cebc4e8d5c1028257f1022c7267fdb303fce8705f4be5e55560c150dff615c336e0194fb5586d8eeeb67e59cbbe7cad422573914ea62c0a22e84b7d054b8c1e429dc908253d26dcdbefa895104e54bd476ae1a5351d4af0df6aab4e36f65b7feaa90779ae037bf20ceea81a40fb5bd8388a2e53643939709f46faa10c2b2533a967089cf90692422e0d7d174dedb50a687170fafd72d2dbfbab4678eb01c275e012e26ffe98ad581dc27ac794267c9324cd6feeb3959f0977506ade2d003cfaa596e3df1c9e8a20a2d1937f2b55825c086b4aec1accd6b79e49a8c74e446c6d7cfbf67744c9a4a28a8f6cf909fca646da7e21ede7c817f78fb1e4bce8cacf8964f0ce5a4fa28e0dd726cdee24af967f9e7b545dd6d43bdc74010dfea50c65b602f6880486153e5e978936e21d56d93904128cdd3f43f49c81f91b62210c030a99dc4653d95f9dd56aa92f161622580cb0e9ed7920c890a591b7813c03ad4ef2a3d051b292f16f178a55fca53c7ebce916efa064a1c0015a6763a6f1cb31bb613a220096fb21d18e2f1183f831fab698e5eeae99aaacf491f474f253bc99bf6f0b752b67b239658388fca6819a9d768519c7268c853d3e1b5058985d92e201ef05bec4f2bd1f4486759f814ffc871cdcc1e6571bc52c2655f6bdd3e3c060de26bc0ec7bc1cec7d67e22bf149b04d20ffeab82859a40d1edea6e1524f5f63e858be35114b7587b304d4493c82c385afec6ffe4d3cb0ed6468460446cd6cb4c2d15d95602b632a4a6746272e976e39e87ada0408ba0fb1676a62a4b2a12f318155a651ccaef3aaa34829859de456743d8eb2b9316b0798d398b821ba65e7e624ed7cdcbbc6e4bf22e7bc891fb39a74d1382d485494a5538e1946449772c10a531c3dcfb1266485a169e4bd49b1b4e744918793cbd66d42f28686c12b5711deb1692758b58b2b3da56ee0725817b4d5694c6f4e73b0351fa5f2d4dd940e846d7e3410f76ec60469ee204908b48e3647abc2df58ed6910c5bf42087975af7cb0f83e2e0b6a4ab13128aaa3d82a164fc042a421284d703c61bc8d3d84ed75428612b084fb9d59c7288aa2929627100aa83334f8a4ab7eb2862a294492af9bb17407f86b8e87a00403b0e5076636a367b99d2a5182a46560952fcac850d775ad46c9286d51a38ba21720c43a9428e3a900ef7c6562edc2ff6dfd5fd164ae5e019452acb2db5a2673fecc6c3cec34644f14cb10aa7af0041da829ea9dd71141a583385234a7c4ade12ad85db5997cabcc6db246751f4814cfaac0f73e85915245885e534acff4c763b314899b6a2abf2c86369eb6f1e327b8ab23de130a8a847b83376a7109a59c9c878a0d7a0b90e7adf845b4f734e243bd8c2a1781932563f9c19d51e5646fb1f9e81b19427c129695d40da87d066aad88654dc22aefcd8bdfc5426e2100efefd0851314132b4d60798f60b61b68711770b2f92b612c2c01d4e82d715e55d80c0d7cf449d7f0f218f5afd2e051479d34680a98007abac803b51f70b05392bbd372f99b35335bb9c44b31039751f084e67e56d53fb2484b8bcd1ef35546997a2a8753eb161075430212200a783cde1bc8f7e142de77ceb70a7d2cceb8b31c9986f4ead9acf15204cfaf371da54ef9e804e7fa6554f2ea270f47ab3e99f8e5a36207f20d724cbe5f045df3d29dad5fdaa621fa803f9c9aa799828563af8e1f35b6f546a455c740bfa960ec90c7394da623dff19b4ac5b09ed469522033e43371871b5ff9130f88adcd62f508338d55fed9c37a97f0245a8944b6bff5c48dc7a5de20377dccffd13f2677e6092f6a0f5c8e2bd7e76c5461f58c1622d43b781a3666de92ec0248938178a8c17dc293263749b1c685bf22c08e93bac2fd7cc67b259ebb803e51ca81bef13db50ed82e2ff7db60c5fef26ec7aafbaa245dd1cda92d6b2469739fa0d71d02e4d6b13dde710a5e15c8d95b2eef45e1601e1477742b7575a1eb038779888ed6ac4b60505d797c1e93894b02a558b520893c57823b9786299a39c75be93cc07710ce4a38c467d20473ac3bf43f929dd8301f07d266c0ef3b8e6ca8d6ff16e40b3545a113def38bbe28bf38684db62cb411176949873241661eb79927b4033baa2227cb8f6c430acc4ecd7f09c588877899409730cfefab11dce90541514eaee7e5dbaac4532a974f287d5cdfe835f92b828e1fd2d20fa8cfdbadc99887068bc4de56aef7b867528bb112c9d33c2748d766d301134e228580878c264986fc887ab19879b2bbdf67032781b33b3797a849f02fc5537b63d0e3f8ed8723d362d00bdafe95e060987d91ce7b627dd14d2dbdb29b9b62babfadc23d1eedb75c26aeeae5486dada195b6b72fb4f31707c31653339b7d5919c075424b4e765f55daa86516ef5745a2c8e17679d069909422aa1d52560868e76b9a9d73856f5e66948aa0715e619c980aef50ee8e63e56582436f843c4fadd41d7039b95b54330c84e64ad4092aa37c14c4ee288268d11b6159e294b9c2214525a01b267ae1021f10a039ad6166cc7231ef3c2b88eb28489acd7857d8fc06153236f68ac7584b71ecfa3f5e6f8ca765914b11c60b80a3373405213a8d788cbf7e282723c226922c5dddedc392d362c222faa44d2905e69632ec1c7a9a9ff5640f9758db83fc9ea35a7e19108ec526ea692c4f82540fb3c3383713b139d44c6f743d60c7e211b557e6a47942deca1a7ae5653a069bc07f6992d87e4d687ec6647c700994a385c89d5c4128217c4347d68dfc698176dcab8edb02f2f41d9d414eb2cca624cba2d297d57a8c77d99e8c336b02012e1598fad7b570de7246efe18e4c36471c5fbb90ce557892030213e86218c19a22addbf29e20cd2710a8dc8f4d1bf5968431eb94346b8112f5f7de51ebc101d4281dcae4ab04171737d6c9ffd915e00e63f7080c7e0ae738d9b5ec3860cc22e8cbd4695ee9275533ee94a5aa321c960df4c9d4ce5d6a45498131432682bdf00b6d349f968998ec70bd57c0373339bed3f59967591f1c81ba57c969ecffcfcfbb9c4dd4113f62354df0eb5925503aabff26d894a54cf7e66221316337cc212d3fdcf77b0c6af19b0cde08a51ce051f0a1fa716121d39975810d1003068a68279a997b398c0d55cd60e22600223551318a58b3d519583cb7ebe344f5dcc8f20667cd4bb39e2d9b20d9a843239cf182fd1f71740a7adf2aea9d4a18b91ef26ded5bb697ae680a437ebd590d458abf18abb6fbda914ba6a06ffaa1cbb9dde6be6bfcd7c4d34c04294c544025f2162eb58140ba5dfe79a217c66c4e370feba9a54144bbca2ea3cd494cc730caee897a314c323b565e41ce6dff121b9f0b1ce8c90c65bff01eb5acac1f42f32aa85ffcc51ae2897ea3c62ad718873943a28dd11b37165720b97c60855af14c84dd7b9067c497d36cf516365c655243a5627ac31ac66f82187b991a0df8b8ec024eb82f8d7f47fc75e070a616e43cd1429a86ab189d61e7f9e1dd2a2639dd8dc59ff44d7b83e6884dceb1eba9a109adce5cabafa8b65302cddc0d479d4829071ab88dd78f9bfc833adc9e2b2d9f74eb880788f2457ddd4ddea08a13bffb3dc5c4654456e8e42e6be0e702e0c838cffae58076917d896dc93fbead4a4c3447c5d1629c0369c607b5f4cd41ce56013404cf365bbfbf79980aa0fd256e932faaaa87c46dff66b12a4fefadb2c071deae6197fd29992ea7fe1efebf0b84375522cf1d39f6c2fd3f75dfd2907f15940f66b06d225d1df6367344faa459f3989e6f12da6a0eebd2369540454dfeac2acd53c5e49ef629499ffc0c11aa733d7c5f844983e6d5a18f21c0405c0ebc0a409f4e8499aa2c36df6280fd332b66e741d31ca58d2ed6915edd1859b828e4ef9fd93eaa6a9b5eb428f41df6ae4e562e94883ab0c871663cb5298db9c6ac8132c6d6509442b8b3bd23e2392f05e787e9e3adf8b5db6d9d0f8d9c100dbbb81f9839a5fcf486c0c0718b1a78c33a11500b8bf5ce7acce61661158bac07adbf52a34a8e9f5f94d9c0c4edbb8b730372ad978ce557ecd3d04c3af7665744df933ed4616cd9e7998dbe223e121eae97596527d79b2ddf0b29cef101b134928b2214fc9ca81281728cf50a5156dd4272a8ff3abc12f1600b61babf46ce57cf2acadb822def47fe31e682f559c9c7249338fb1f7dd398596600637cfac8702a3c227b8ef52061219e55043f75d2202d774402c92023bb03ab2dfd78aa81af361ec63e72dc5d1396b4ef6f7e03c3202da4c828f75a008902776d359e661f9ab6519ccb426e4dabb21d441de7827f4d7b7318846e4938cee5f8a7510950e19d9811e14d7a8555396b6f505941a5fb226a9882591c6f4fa9783595eb7c0fa18051368227f9c48b60f8b51638ca2ee168847f367f31728030105c3d885c915977f0fce6d0374a22f752f26a421df4aff9416f21fb185b25ca82690fbfee97d37b2fe96008e7db25fb2431c6d5823d86110e19a698cc9b94352a297cdf8f5ef636d6f72784b77bc50dfa83b164ccf8b1fe2b7588655d2942e9ba8e95912135c6aaace4ed8d3f47390679409b50ce12d59777086ec58c42a98bb0d12905418205151f0fc037c692040d86ed92f1a1696b0ea7712fcd829f54967bc533717cf0c99859ea807f6fb1503c230a079d5d643c2d066ff057f6ef9b62bf42b69991016382768886610365a8781cb18a85b16b19ee76f8ef15c30f8c96453fa249d7078717cc9d428a279980fb9c4495e9c6d13770bc4fb330ca8063756f0598b08309bfc5d4192ce0195a4fe5e13947f77e03d90200d794f4e0142ede395eb3f05bdc071cf98a1b3b091cae610456da4830fad9d1427ed6dde228ab8607670353a1980fa43e912a6f5a4986b124c1ddc4ce5b252d43e7f221989de26e9e01fbc0254f51a1469e226c0772fed9e92fb7e7095efa4ba31069f4f82276e6d1a71c509ccc5efeef47e2b0653e439fabf437796938e27118fd8616271ea57a01ed05184789c78b43b93036fbca23a330aed948f5f45d3871567360f83548eec46ab3d0e6e01904ccb25159de5ac5243662ff5194461e228a95c6bd1b4045f760f2c537313a0b1cee712429beb12edf5e746e66356e39e0823706bc2665a0fc21c923ae39620aa0b0afd9635427af565ee82c5b4194e3ff375d84d97cba0940068393127070495916b8f56858b1bf5fd219ed4b71712c32d989ce872159a156697dfceea23873bf56873e908e1b62b1e5dd6f1281400819385555b956510981f8d89b320b0287efd750a17c17ca42434ff21db25343e37bfda249bdde6841d14fc0cc59d35beb00c5322c21b01e6be98e924350bbbe1a56ae5da89a1a70ee535acbb68b610b060add9c8915ddbfcb3b4f0ab4ab3eb1683600d9dd1cb40580b7a4fda5a629f7a8b1bbdbe481e0e2b47ef77e15f12501e33ecc0d444a7af24d0ebc6016a626e3a672436d85d288782123fd2fec314a28077f6ae4d6a76f083fe1888f1b7ade08d26ae7700af92a3b9131cfb3a16bebffff9036861f22c1050180e50fce4eb77dd5c7463756aed3f5056bf9c69ebc7ce3286bf31ab877fb7e64224e74285f7ab6ea1da7f6341999e11ef070b43b2e12e9d5cb3a0422e3610ff6ba4c39b58645b09145548d0c49197fdded805871d22e4f5a1201ea8463f34d63b037bda62334db7dd12a7f7d45d67f5653c40c19381b36b0f23bab42c6f22fea3e4b5a439fc5b1b3093d93ef99bb219c3cbf4ea24b8e3ffa96c260bba00ba01333c8b1ba6252eafc34eccfc414dde04bbd559720caba96a43b61ffae774151000b7970d92c255d50f6af52ff224468755e8a241589712e9bd7950ccaf69bbbed64ab50acbdc12e259a79768ca26a8262ab22802932b4fcbc9f8b85e0bd0be8f66b9948fa1313a1ab2b434ea239226ed34785f89904a2267b6ecc6f4daec9b347c06168bb09206049b3ab0452c3485336472fdebad5def8b78afbf6f28bb250461c53f9e1a357bb135e98420f0705bfed76bf8e5d43ffc73b30504808193948790d242c95c901959259685f64fe0563a7992548c81133c49e5628e853f2634bbc7728f1cd67a3d80455b82701550679052182c1a7b9458b2046c5501488083dcf003106fc8eb717dd4d70a3b195cc5549df9e5f2acec5571524abfc720f8ea8e11af3d7803d2b3d26795d37871762c5ca2a4c476e3d62f29f251b34ddaace1d523de26fb73d437de372666eca542b34c6ac0ef56680cffa0ee56ede283383a5047b4a91eca1b76a3f6e5e668071895432118f7bcb8835a7dbabec818176688e881bbb996368cda907fb53b11728008076c65cbaa212719951e9fc66a0f529fc8495f0e0cac8dae2ed44fafea4d880b0b5f5e6303afd9342cfeca05f7efb92c1106026de4c8c8567d829b3ff0f3a91de34913847f699f5eddb455d05bfb8a430794736d9765db4b84ef224048263c240ada4b77903e0513840b855f518c664941f2f8aaf1df3f4f6599e3255d493edcead7f1f74df26629a957780dd96df532dce0e2606b7a275de579d2697a9441b1c6bc8c7d1896e2adec299f42bb0263c6144b4bebb7fbf7e902b1814119327868a13b2c8fc61c33fc418a757dc5bccfff777efa13bb5bd058b565985c2507484d32bc1332b15e3fbc2f7daf239930dc847422af0a90ff5bee1ad5a7c3fb90443695da4b3a236fc1b655576acabd917e8bda61c85d9054bbaca747a7888ee81811735f6c80d76af23be9dbff3c5a3ac8f732ad14d5e3b58c95f1e31821290c4f2c8be7f9ff442d54afaad05c0d7a2c342285b0b99391d609d31af34abe93221ea5df0f1b5f591cd43ff9db1cfb5cc0182408da43b21bea5e07fa8c4d421d4a083b4a915c99c70c8f0d90d14360cea3cdb3582701af3194030a1e7ea2176d84169c25e8c8dd9d745cbb97b9c0a2a869220df13216d5b3971287a11e9d5ccea0ec4d3cc7b5b8ce8ba2c370473898bb08531150886137cb05bc56152bb56ddfa2fd9b362ea4fede06ea74135a8bcdf92ce205f3b1343926bc56a3a5667a703764919fab845aea545c5263e3b775b93071104127a55afbd133b4f73f6d9dbfa7ea2be60ea50419444c5f481f4b031f046e906e50ac15fc38bae1f0178a1ff72b8542ececd71f528a6ba1260ac2095bd121f273e1dd129b5efaa2478446f9b2cd0fab5f175e55376cea84f15a779fa64d45dc9e14d6201b24577e5e77cbc1b4e40e83e2b2385d1d9331b034f9284332bc7d685d250db23d08b7e6f7bd44506b5872b8f1a469af7fddd188b953240d879ad9c019c49c231ff32ac547f326faf4f230ff8e9e556f063aac9877abd0bcca9555cd9b9e066fa98272170f4da480a6805a51c5bbdc95ff6c2b504ab085a4d21f0b4e1e3eb7ab78952835ee7faa59baadee59c3424561ad2283994d8a30abe940190f637d08629bbf745e4e1f4b664b79a1b09c97830fd047153a21597089a8065cb1c8fddda914ea7756cdf3e5165460dda6fb7f7f55de439f1cfaba3b1c8cd2a1bf73d7d6f0df62cc927273792f9f01ac456387b9b666da2b2eb1c174368f56083629a02b3c311f6c45dbcfa2580e5eeda09b45a84db5a264b9f96973abd12af049afa9b8a5058f6c713a72e799d7059a84906bea0daf184951574318478111fcef86e3e45b0fbcd237b5805e9958f828f76fe7b3d06ba9314fc27f8dfbd059eead675d927bca71c14f090537205bade98b7f99cea7bffd7c8442c14452795c626f8a51e0218fb31347f07e9729ef5273b195a859630e5fdcfd79c55232631735bc510e07b663f3cf71f9f91f3b230b93946e541e9442db4788fdfbcb10346a5956bb75029c5fadb658522bfe52ef465f4a3eb2fe1314b71aada9ff0854fd3c9f95d6e1d814b6070d3baddaa72f08a199853cfd4fa47ef5a02511e3e50494f901ef90dfce6ed66dd9cb98b6a3e911cd6531703f7d7f9901dcfdb3b11735212403ea3401d96dc0a8561c695a6a51071e72cd2efc27d9440136a0eae75ea986a76a21cd6fc52e9eb4441f770a8b6d05cf721c5b3d560f0bb27024655aa558ea67a1e336b99e815575bce17b7e7dec8e1dc3bf556393471ff8a4ecbdaf178b8a509e5f525decfb41995e864371b643f9c7d18a92db4c1e9b7cf6c4b42d2371d0d42b6d49edd3c19da2544ee91d70593f33d3cf672db69560a7dabc47e88db7023b353fe1b712f561a71586df82e96acf16ea83ce1d61cf8110289f64f4b0af139e7d76193be4c9c15fa855ad78465184af582836b37ea9954fa58fbf0a8ee7e5c016df9e7ffef689b3f8e7bae98dbf56ef02afbdd87ba458d90b0561862e1761501f1516ff54984eb4b490d3b8d328e3e6eb93dce336d13e68d0ae5e7d42fa3dd87cbdf6d4ea40355307b8a66afc5c5c6328382d6de55abf8ee74d1fcdcf9707c8118b888dee00937e24d721bfe99546b14d108ab8b9048f13d7ce2cf28182cbe7f2e4a88ae496ca1d765a1006bf14993a582bd220405ce15abfd377f756cdbe15417c4bbca6557f160d1533db260f9e2efb409f0624c99906ad37b9d24563f75fe6984e265af0ccba12771d9d3416881a8673026d45ad4b5ed226414e2d08255b80c378ca4897cbd3f0e2fae81a0ca1c1353832b1031fe1dbc91ab3b5cf7ee5296969ef06ba61659dbb421edc93039ac1293f0cb8ea9d88b445cc036f5f5574445fadf453fea266876ee759f098c9e7912dbe961ee7c16d8d31678ab3862829dcaf33dc9745fc3fe4c794889b3302c9d7b92e2a7f8bffaf2a75bc6f67b0fdbe9ab5530a7dc6cff4c2322f70158f2d0ad41effb21fc9500255c129e70ffdcc4720bd4ebb2f938a3867be6f25cf0596e861b8550642249cdb3639e288cc57196e6411e54b89157b2aeb6686a4a3f16721e4c5d21166d0b0cf6c3f6b158b59abc78d5df6bb37f0fc267ce487c63ea86eace4e72cdc3702bebfac95e1c94795205065d2bc74e82d5cba3c05a91419a3bc5f8060ee3bac41ac554de19de9745333aaed47cce06cd60c0ea4e9ef423d68f937f03079294a72e9734c2475608aef1a003e9aceafd3f70524bbe852f4dbe06748bd2ee7d2717ccd4a3ba79a3b3bf346bdaffd31e7a0cae713236ace7f2bec070e30b13728f2f0631d0b5e0bb5ed265a619bbdd54722c2f7430e694fd9612af8134d036a120aab2fb171a04970627e7fe6a64b0be094e322b48c79b18656e0605f5539742713f77f21beda847fa9ac1edb3138a6b20e4f5f79995edf46e4c3e4dcfec453ab5e43f6259004dfbf3b856ede60f03b140538ec42f5e9cb56a6e8cf60ef4817969beb3b4073881871c920c247c0b0f6eeccf880b636dfcd25ce22f3c041fe0ca70e2245ad68066565382d4f8775837ecb127dcdd4cb5481e94653f50c9e9423d34e21388f0310b69aadcd66ff3bb370f506e1aeb6ba9b8e710ac15c1e799500821963023f92fa9dd8ab171280a4a8d99d0236672037d35a5299e3775d4bf45c06b50e923f3cd82546123ca8ae6a4eedad987c33badadcb641b5b4b24e1e7da55913638c1b22c9d796f68b4ac4b7e2fd7f0ea924d44111f69145b580b74923ce390f9e8c35b2f9e837a723566e5a893c32bb69d42f2139521fc86f76bca44b4bdb05f172616c60f7d0eed96763eefb3007b6eb7cd8c983bd495c2dd0cd44ab49d35e6806f4c40d7ff7c808cbaba01b7cab0f792be646119acbbe53e23ce44329db2e439b16924ddf9c9edf2181680365d0961388da705aff9c346ac892422266260aa7455475b0c64e015d7c2acd26934de28a91f86de4972a712dc7239afaa7d74ae2bcc4c44556284740cad9438dd8df0397c471fe70726908c4179e192a98f7073d02cf2e342037feb9e7fdf5969feda32ada6739d02c97ab321149fa2e8f21b81c970ec5fc9e679aa6fb8a5650d55db00760b15cd2193aeba0654033d35d35ceb374521e590d62cca7f2de09adb34d71096b46512803b06c8bc3145c868e4f70e7f57821e5135ea8004be3f242082ec346b1c73b4b67e95e2f118415a9b671d252c6de027f452b70d1b568ebca5ae99fb8c100054be7a445990357bc5d60851f4dab141b210d39ebe2ab20040b261f3edb43e3bf00f47fcee9eccc189c09b7c07331bdc9e165eb1e726536a53bb51ba3aaccf86baf55c3f7da5fbcdbe3839bb728a6ced0fde2abc3a3732e3fcf27f38a0a56d59f281dd70acc8e72a941ba6c60493dda567bb260cbff72db74c0d45940157f0b73a6ab7a73bf63d6d278fb0e9088977c88d47c8509d2386b52d3a7ad64f14881edfeda2c842a25589f9d7b96b5759d0bf40f340d7f697951835f0abc1d4970cb36a1c7b9b79d5f8a6601f8c34c2c8222d42149666ecb9822cfa9db423cd19db5e96b4fd2659dbfd76cf0a02a09a397e704afeb7290dc0d57ca5d6640c3847861cb26d090adb903f234612c0c26d53e0c7e8d008339d52f8fe80648f019b524acb9444bf4c04ce70b8f75fc03f05687891b2483d7a501c44fb9c476b9e7116dfcaac2dd3429572ec60742abfe740ccb062bd579bcc601f5cefd44d410b3a47fe0432c2957f90ab40e98e0817c5b9673d24c4c2dc0fc113ebcd8834f3273c3d95ea80a2aa6a02b82474e92062e1bb4b19a8b2d75d7dcf38a01494bd4ddf5ba39f95bf5fbdf0440b5216317aaca66be42c21c67ac430a0e328f62ee1ebf0ae2bfdcb5c75b9a90fe39f1feb6bc61c99cc3469f9514693591817778da1e1760ca3f1df5dfab8c4d1e7c78f50e651a4c4179988cbf6bb4e3037e6fa8334b439aad13d68b93e4517cc8d21794e1a0c6f68191bf24294f4ec2efac70e967a365bff741e1129a08043972d22a245f3e9854f77ddc785659e71408a92eafd4ec6ef672f403d6fd9bfe4295c3d7b5b8f9cabe778ed2db7d2d87cfb45a1c346f5b1844ae7db34c39b237fd6a555cc63be30c11da2b631e745522f248013d2a952e1d1b60f4cd26cc6d4701ad43c0c12d8dc613f02fe4f40b17fa9fab5c71360055d71cfab3d63ba968254b21dff85c76412495f5e68b43faef9a51c93ebb4a4efabc348b98e70cafdd9088b9706045966826154caffaa7cd0ec9c5b3e7798c64bbf0fa2e8f00c640245b43530948317af3304ad24f20979a61f21ad3fa735fd4471d6c2091533ec8690eed0704953e68071d35714c8994cd45f0bc614e292912c997c670ddad9e26dc073bf67d744f26d96b1ce64af5c622855dc32ce8b65438042425a5195fd5518967ddb34799d2049896df17dbb070a56ce3f43a43ada54dff99c47b7e38ce3f5aa4b4309700f55a836d5a0eba8b7da966d49694987403f13ce0091a9e266a68ec14184f316a50ec1fe1446cc5a1d14f6fbbfe8b6b5c83b11308985bf831fe4d6208de7a002031b077c1b3ad5fdb85b8517318efe67b4224b7d7aed7f629ed86334abc68addec49512884e3430565b415d8ab310d4c92e5df3aff9073e35579eede4de0df460e17f7dedbcc35d94f8d0e41758a68103d04e952ed9c6a6f0f06ba2adbae4660b12a1e88db603287a516fd0bf6df20d154e93fe01ad48fcecb8a81cea6995e896eaae8ef8f9901c88b41d36e24b3b15848c5787489e0cea673d0225b3816f58f05f20d76854c4d9df627523ff5537325573560ed3e402e184904bb2f5907bd10ef5d98f009a7ac9d4439c9bc1d09b31c2655b85cdf4528924763fb5e92b0bd56006418c543ec2bc79c19d4730deb5784ca237f8d6acad2ddde1f05f244c9d02219481221769950f9cbe50c4f156dacd90aa2c83c78e4ed5d967af456702a623364f89759d650d60fcd0c0996e69016f9507a367fe2fe9116e34a37677c078ae3bb87821d9ab92f35d6b45e7462c81ebcb5a068366c7102a93bd222e7bbe72298580d2094d90d4825531f82a3723c372a17da3673bca6359b24601fadf287e3534d4c257cd36986103c491f7355a243bbcaf0d8bc086a2ebd8c9fec4276ebc6a95a330914aa3ed649247f525e49b3ab2abd4501decb6da1f050d250b9ad5394e85a50ed4dd644cd321bc7a7821f7641b91e9db67f42656dfb34bc5d1f29912bf844ca210e7b577fb3786adde433b81ac5a2b2142a0da98f8229aab206d4bb659fe42c388f7aa00ef89dd5904a4032f3b5cbd0dbdacb44f88d62991370e8e8fee862196ebada63690a7de5700fd0d946a81bbc786a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
