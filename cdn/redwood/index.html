<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"65128e0af7cc3396ff43fb42d83292dc1fc4b5b8377f1508c9947693cd72232a1e7f79e89675fb792fdee02114f05d342ddeea2f4df363e071e15af500ff9f6f320e7e3d62befec814562b89539946b26bcec070effaa5781e859193813c9e6793648ca68eab4360471d048db02351e1436afe35fb36fd0d9ee1493bc43c860ec5edf4134e16c51bb32a1ff3b5fe6af05667bbd63620029efd89de6a45fd7d70528a7116c1a96799b42c70f2e39c8de1b864574efe69ddd216bc64c3ecef53a1b25542a4765637bd21fa2965d9f5ac24dbf15e1fb47ad2716873a0f9b6f51b1b00be7eda146fd65b55fd46875427adefccf1361ea4960abf8b92b88a68cf9946143bd127956bc1c251deed583920a05add84e9babb48669955ac53db200a9135d3142385be593d9ce7627089f8772630a3456511c943edaa3bcd68030808973e6e51d884961cdcfbdb406933c2d4511ac57a52b675c98b57e807a505bb058e8a898d1270229fef361713cbebf0660cacba769964f69f989e15f043494592e7fb0d8eff90f72617ac2eedd26e959e98f3143956f2bbc743d0e4d3575d38b4db693d57e513aabd8596ce538365748774726ab2f72fdaccc8862447947e5a9c137d0c10ee3d8d73ecb0aa81f49ade9dbd19c1cc46cc197c36cbda41f4b63bd5d418d3298e75e25e467e126a68ce9df8a7eb8acbadda1ddb35f245a40e800a91f4156765432d78175ccdd90fca28e942690a42e55c5df2ffa53bc105c1686f25cd8402f823a38156048bf634eaebdfc1b4e19ae7203e60dc90c302b46b5a6bcf5304435121603fed00dae9474d4f2a68df04f8646aca1a3061580382eb2876b420c2c64555ba434655cec4e04dddaea902093423a9ef6bcac594625fdb22d47ea1697562a8cb7d716f7e540f97d188dbbcdc2c183318102a3131fabffb22e061b4915828c07677d529e4039f51b9be583957fe973baa9cb5de4681fbb84740067063d0e4a355c5b771fdd0c4fed14fa888d3cdf0d8aa6413e7a07ea3b991f56fbe8d20ad58f47af90b6d22e9d7759bcf78ae8d0ff7dfcee506ee56de399a9facc7605d4f9ab255b6e454f320308ad91656b46a607cb7d3413654afe1a669eb8fa4d47fd058e9ff8c9e3cee6fc17ffc20fec0e69b6bc57b91c7fb06a8493321d27767a7ae318267601a12dfad99d84da628f3006846c6ec4f26fb532ca4b26b3ffc27bd5d58738dca0abbd92f5f359ce36eb6e59333fff9cea524d4ad0f9685afe82510b415773a9e738ccd519dc15fa03f41a667cd664e4ae40bb88be06ef8dc6d6b5b777c598c54b5463c3740ae303322958d7163846c0e20588ca89e471e155ea7f9de2f88667805e6dbeb0c071090076022e6aeef7fbef4e1f1cd7720975bc40ff210829b0fc113ab1df83d6aa3396465ff97255c0d0c1481f71b8c8b387c8998b3fa67f05a1fcd684b3de68fe55489e54a98f221a8d7fc5b41f3bd2253776b6cd1f2269dbbe9c398f9c66234040caa7869857587f2e8641031fe5355178917d29e2f70d304430851dd8fb0e0b594a7b9f38d694970d9cfd753f6065e37f596c8f8b281f3d6b0b8b054bddbee9bdf7acedca994244ab8a67d53e04af45025ac56199bf055770336e2719deafe805a1b0c2d99a9ddeff6126ee5496e7c86399091d60678644ddc661e05ca62e24a4a43d379efdd59c85712f350d5b63bee94b81989816f1ee9fc8693a195410e1d26f4b69317d7dd4e03fce7230b0a6cf3d9845ba923155a47ef9ab31ef59ef10bd7be6f2ea17d38231eba74f2219f41eebb2759bcd61379d672575ce1fb270fa5920e161d13f1a458498142699e820c002a838b38f4354516d9195917148af7e1353a3f26978462858ab63b42e8002b5c7f877a88c4011ec873090df5cb2d422aa067bc85831341f49b3cba19e53a0ef50795ce5f24bb3562a255d5a9ef0eeb6ae0c3cf9893ef081f26f1a5951bacf02c64d69659d44dad72d7075a0930dc84b264b035953a2e0b1cf8aab75a877373bfcdd2f5c4a1f64f4902354a4248e666533e0a9b2c442f74b0581db2f31f3e63ecb9ea3c0a9e87ebf3f6fbdef9407b2ba2cdd79c0ea57b061c3e132223990c31930213425eb1f84690487681d095ad4e9ab63189379a16077a8a8d8e99cb6437c7bba54502309e262d9eddd25f71e9bdb7663a65e10cbd21f842a32f1eac36a8e1dfb980e3694c7cae8156ad460308afcbda8fa7ac522b4c5d65f4c55ce5d73b915ec131bfd09be096a9b7309a2a0e298a3b8e9b778ed290ba73a0e082920b55d12d9eb99d3d7f733b99b0d08187f7333ce1ebda078ce72e5d2b0a93d902703e0992d8ace17395a8a75295ab0ef2fca99453210f8912777de44bc56b7eb5a447e365275caf1322701af0b6d58ab7b4f7183331025ee5ae98c507adb36c9c9daf938237f2ec212b23ef619a7e33bc0f686eb18ad1b547199b607e646f449771a0b55b0f6de1e76edde667dc5f22aac12dce82db7e50c6d71c26ca7f1c415d43a8ee90b5ad63836a842a6bc5d3ffd2cbd24ef66c12d3b9e30e3bd8daeca8e77154ab644a4e0c1084d26498916d9446116658dbc21b3b55ff2e65b8929e347b322bd6016e2134912294628e89fbc7a15339563659aee47500020138fb0a735ae59cf6838620057d1b6ab05e843f56e21195b0fdb6d35edda59c2c6b9996fad67ad1a0d6a4b2d8cb79408acd5c9a6f2990c763a077b7864ba53375e38a012d8719fd33b97ae0b6ffa0ba5a7f0ea1b11452d0920e5ef3194df01a033150f3104e36ce532db6607d3763a386dfe377fd6c3ced99e093adbed17c42abf08c179dcb6fec9f93da3711309915481eede1c041c02d4fd1cb3939b125645419d756beeeca7bd2ce50768540ba372b2d8c94921dfb4419894726aa116acdf378e1bd4cbfe4119a7459a44394d9ea25d532aceb020d8d3d8fda6f2e13519ae57008cf4c1f37dce33d5b72361533cf254ac8368974588f75cfc631a69079d0ecb2b9e9a8b6eeb9dcdc5cb3ebce91160b096fc6e5e3788c7a7912315f244bd8550f743f90ea747544147c924fe6a45d04cebb2ff06fda57f43156b4e54e4224a916c54570959892d46a4d1da3e1d77b6efbaa546751c27fb050b9ac999926566f31d2c6bcda2fd361b6d3e84a0f194043b918b8140885d9c5137aa12dcb04ec3918b96d5b73d931df8de085eec1b19aa997d32f160bb66e883710b801d806dde35f1b5d5b16d144c38978e969e28effebe46ab7c00003b76ecad9ed29f93e8e947c3fbd65e41f06b32c12486d2dffc7cb2df8d3ecdae435ff64cc468b268ddd5aab1dcd1223b1b1ae1887f47db4603cf943daebd162a308b6e74a5a5c35c1e1f079a1beac152d6f10f8cffd8728ed2f64e06fc7c2c588082ee2f31f46f8d789b54e9c316e91d403f8ece631e6c2ec9ae0be120494ca04f92b7f06f3f01784baa249dd9a9bbae74b36f9771a5a9fee134e5e4982a70695c70c3df0cb653050b1696bd02922531f4a0911a456efc055f07f2d10dd5aae930c17d74e9d108f4630e072d02a40b3f314b9f5818b792d357505895fab6f6d5c38b1318674a561f9438864fe1b9092c096ec1d4da323ce294307acd8db6fc97b48adc34589ebd791548a96c9e45d01721daf57d5735dd43a99dd4e36025aca44cafe54ed1c0655cf440d00da4abb29d9f35caeee300bb68933a9e07a6282ac19b15e58645d38c4542d48b56ee2626f40ea8604057bc61b80314d8441dcb7c48c753ab66be0315d3d85bac24c770b4d92ac4bf617264e2d292e7f6a9d67f0047247a1ec62c3847aeb1a3b56f48aebfd8bbfe23d5c7d1b589b5be854892b67ca9a8757d5485173a723a8a72959faee9a7c423fe5c186bf8992af89ee2f42c070b0c1fc9b4039025d427df400deb1ae9563cd0fd17552ade1f5f4cf573e1bc8d73747960c7eee6609f037d670bb808a69f584d6f9f91363875a9ff1074b56a558a90c9c65a660ae17e66b09be7c2cc93c7724641b4fb8ac6549039d9a4219faa1a5b99d52f94a595d7e0e6c200c88fce6ac67f5fa6fe5a7b62ea4e8da5d1bbc48ee9593f7624de1b1bc53a307d4b5ed1fa4457b6566f5cd185f697a4349957de65045360e345622835d28f81496aca9b43f7df87fd4e457b2762baf4b60bf7d602fa42748304cd5a5c20f96d9cd2762e73a2c1b5df33552934b8af4ea72d988d73ff1cfc69f79eff4947722dd8c80059d259345966560f923a0b25df87e76d85848dacdd8d4a892798540050a4d77f018b09bfb064366532d2c6f12457b2d6cea9f5c6ce4e8f5e890dcb865c2ba97a91c7f7dbd95f9e540cbdd4b2dbc52e9faacfb12bb8c82d703cd2137e5fc67695fa4a31a4d0c53bc7f602eccb58b6323dd07861da87371ec1b57c93ab9a20d219938cae5a7d0a0635263f09992aa8f2f00182b1bd7258ee018b8d0f7178e1e86cddabeb0fcb50717fdb51780c325894ad22e861df4fe46fdd2928985d01b57cff954d62552e777218268c62b99baae6dab30d159fd6c7954d65efebe0e1b814b0f1db8242032d94965346a7257e52cb2ef4e53b6281314deb9e46ae94a2d6790ea6fba1042fc0f05d6f884ce4a7383b2e33bf75df1a89934946cacbe7783e701ffb6028901d2270deabd1634a9f77dbe47be8d0f9b6fb6ab27db40220375185cd62038ad6e85bc740e048fea982a4716adbd872f60494df65521f31a2849526a4120583e11e1c09045f759a06a5ef0f2b4530fbd90242b746054730c9f8f40214f928d68d0e013b001176967f0445013f9e9e048bb93e00d0b9ecb84ea395c4720db8d6b362735562de33262669e0378abc8d75b0657a87f7fcdbdf18eec9189db9a05c4b458f6e8bc8b1b49820091b5e0e8545e4cc124f033f62f7b864a7ae0dbb6b02caa5765cf8bf97272b43d1dee0a3a54df438f7c2fff16fba1970a4dfe24e67e6ac4429469bade6443fb9f82687d08cc1b318060c3cf77d8fb60e481c5f2fd4b0eae67cab80874f760c981f436af5207356121c3407aa7a59f486852be63fcdde4a34ecfb186b85ca4737080ec3af151337e6aed0b88746b7e4dc5654d98645625b60718dd2637ded4739439b397a5704ddda9d1fa7ccd04637dd8741ff3a5d586c8b8773e141fde09649b141b601917333962f7f45103ca652c2bde6f7999970cb047a665011617960e3eaa320a8fb3a2a80451c7e8bd405a86faa9b098c1bdf697df0f903098d653b33f02f1af9ae167cf1f23ea06ef12ddf5d09eb54f46cf026a22795309c468b7944ad294a2a1c64f307a7bbd6ce9aea6c545320d0b78af2d7e0b82cb61bb918d49221ebcc2a1e9c45ac03b87aae2803935b1ef9865f6f95c720a9399ccae7dfdb9523791f36612a52a731c834ec69402d2af21602fda635ec9eeb79df742bdc649c9e769d5763052046b4a4a4e32175307133f59dce4b239d0e7d205556c02d80784ee3701cdc59d83cc3d11ff8ea1ec48ac4a1efa943b1a70882ad08bea54a6693ad7e764aa09ee551c8bb17f05286311dadd1583aa71f2909a64ee56f2f2c0cb1cf9f771fb51828a4bfd60d2c015cf2d0cb71b5fae0e66aac68c5003508b8663f6df01b37c4e2efbb04f4a094b403cff7e30438adb83403a356699a1d0de2ed210ea6ad474526c96cc817e6adf05d27fbaf7c34b5ceb49290dd6f2cee5653bdd7ffde576bdb759892c7d7857d42eadfc482d25398a0014905fcc5b41ef85d0edc42e199cb5e9791d24f4a01886dc4b3625b5ff557d19b9df9b3838d532b8c0ddb96ce692ac27e0cf230d279eeef971c467476e7b1812ecbb43992f63ab0733b66ea764a41c08eb3a17b36407393e327564f968a591aa8f6874e44aa1e9e48ca8394eea8f172b7415274d23949c8c5960345a2f712d9bfea8b32adb033151ddfcfe9dd7f70148c3d8987f5e3e5f5fdcd0c05494da982a5ce17b76cde2a6cc0ddd7eace84a839708ad4dc417566e778a89bf71affa2f52f75c4a6b69d93eeeecab8ed1ca160b3415326d347abfef936be521c2e912abcd1e75cdc07f0ed508c180b545ffcf7264577f04758c7ac91f4a8f9d085bc9bf2e27e26b901644a0197b7df76e061b88f6e3a4592b88d9932106e422b6c5e45ed1c18cd337b89a2198d518ff7816317e69665d834296c2232f94149dd64406a1c35f2fb7757f8db0bca4c60e2ef229eb50bad1e677c08a8e12446d5fcb71a7d22e723c8cc7589be2fe4553cfb9103f32139a29b0f7365256b0a39db940f77cde56c5b1718e7290d0e5516f346da1f2ec728bcff1e79722bbedc5f92acb46917f752d5f7a4e74062213baeae830a9c71d706d3345b107c1c85f1b5a34b45f5dce8d958a7619a7d72287314e97695d13ee15dcd7e4de2844484948708a7af1579c040b6b963e67185dbb8a4febc2b23d8e7340286f62485c434ddb527cf9db6c55997af68d45b46f34bf7b6d9b37c7b2b3b29cde4fd4e75eaaa897d548d9184132e4735f1767ad07eec1a29acb6a34fed31d558e7a9e4703f1a9610c7a1702b142f52719cecc35ac64a4f29639ee6433f933ea930e20e614fd86d22f12304c0fab50c085df2307d17f1ba75518b46dd87793eb957e29b42c24fcae3bb5674c261058f2167a7c7d1583d5cba9de862a14cce6a91a76f899cdadeb681c825d08fd5b73bd10aca13aa7770bb67a114b7992a72a4d89674e9c8c66f15e16b957158d78a8faf845c4cbbc0bc3818b4e33a706ece1ee2bc3c988a13380f3405ccd3fdeba254a523ddd9389556965d5c40263f3acd85b5a645f4da143451b0849466abd106c6565afb468f2be6c3cb0aa4761678102409ce4822b56601ab00381d7c2ed39b553d70e9df628fba0a9aad09965bdc82ecd5907fd1acbcce4f06bb3247e74912845747777459a15ec504fc0d8acd1aabadc9b5942adf1bb8eaec9e92224128fea8b66a9495245b52b8e19e3e304006f7d8d5c2e4bbe3f201dc4e7390681c2ae58f34ef39dd7f3bf248f56f5b7eb09fc799dbc4310e9732ecb12abb5cb9cca3869b733179fe69c051370df05a2370109432fca4c7a0b8d0b90ed9417f32150006ec8ed3ef69fa1bfb548f50ca8eba894f431d8ca1647d1a5beb4a3a25a54a830baebd01e544cebdb5de544330df4ee760a20f604d977e74212b4f0643da91b4e1aea9610541517cbca1f14d5b76b83c00283d6cf5dedf072f4d4525a73d4720d001f37dac2c1c52abbe6c531693448e341eb4e0307b3523bf9afe1cfb348171ff5ed17ef5b6345203e555ce5a594544efda9564d85fca8a3b01fb23ad3bad4541f8dac7166095d112f852b4ae22fdad097e67874e9054de22477148d9371554a9cc30ff01761ccbf8e95706dec0d90dd63234b8f91e60b3dae67792aa5a60a1b4833681f4896b08e9f0e4e5cd010853daccacd325be43de873d88fc67ed8b0edcf832f1935ab8d358f2e3e946c662366b15dc103ebebbcd8481ee4313c195a7f5eca4f21040eb9c67cb492d027738d9accc1b4ef50da4b4c509df39c76951a3c71231ff899f3bbe3418885907d8220e479ab52fc9902f3fda48419d18821a665cc3010a1d5adbd283ce0ffa532d2f1fe76434e5cc2225fb0d1acee292df425d86bd1d6a733972f68bfc7cc113f44b1e8919a54f6b63a2d306e5ea82647f6a7f0717feec4dfde6a4172761df71b535b804a3aff79ef67033c760584ce92e68eb087706c55babb6f4a34118e7d3a0b4bd0078d7a174a573f524fb8e3ff7314bf654e42f6590d278c9861bf8040ccf04435d4fcbf92e989070775d1cc60cbd7506bc49cb420f2c518a6bcdb87f71b34042a4b9a9d056c20fa6644788239a50e93576f1ff02b6d5c1ebc6c1dae2a326bc1391dadb2443ea6f46be67262b005a6fd1f02d9f186c6f76d69699e5448196b63b422429752535ef99ad7c86e429704dd00686ccf084f105ec04c1e65dd6bb004803c13b8b65b76e252c2398dd43cd9df8599f717448011452c038f2fd4407e535ca6d8257972daf3b2b67dd6e3598c3fe9255a44481e6752e9b4249ce1eb8014acdddd479366456cfe8a29383196dab4abed1d71b090dc806a6d294a82657a71e55d0fbaea4d8ed12e2c40985961e5a770b81fd0228410496431ff7790ebf324682942fe290aa2692969270fcc607550ba3d3b8ed0036312ec5d895116b1af8672b02a3767f45151059edcdc1eeb0edfdf52e452866b5d8109bb133bff2cbfdac842a24e4ec6aafc02416c084c020093d161726b2063b6ac72811ff274d95fd575ea49cae28c5c5a3d3e1526f395ed5337d2b0095cae27803c5c5e28ea1c7f24400c5b414bf48885094726e03d747c6626d9967e7460f70baa53825c0192166580af9f84fd17cd14ea7d794f99ab496d066ee1738c8524f129bf745cf5360e3d3cff78d27a7829bde860e6d9a3f6020c82a15804b30bcb500d04d29d4d10eaa3d7e37c09b9753bfee27193147df5fe1f8feed7d2c04531869e2c7dd840820a3d3c7df4a7a2e6fab5e5b4d285789bf6a189e8843ae9486b26336334d0ef8f102fbf093361ca2984162c117152f76df0460a92fda599be16a169461b70201a1c6425669aa54f91e521fd2589c1522e6c0790e34542777c77b27c2644de59af8c9b53f7b30463c8cad48cb778c9badaa228c6d499bcb0e3a7c33ed43c9a2a1010770524ae11f1594c25ddb1626b02e7878a448e292a31d8af17cb03b4443605f0546d88bc69635706e7d020ff5672d7c0119a80b94705a61d1bf8bc344b7848c31dd333caf6d0234ea1f2bf594809f6c8bc2a9d7575181de3b4495be697ac7c83af3c2b6c6e52e4df491578b8db81cf4b29aadf112ca44cde2c39d02824bc7ba36fd6a4bef511bc428a5d3f71c7f32205b27767e49f4855e641fcdff6d8332cc77fd452d1f04ce92db788a2576afd1688e95243d51a78ff1b6fbd6b9373ed718f3dd3ff3b3e19277c1ce036981eebbeb5b9328f3339e6c8912079b1a4afec8b8f4af02fb6a49e192e1614e5e5b8ea8b1ca42d6433f1e4dfbf7df3ba0741ba62e3f4799f8e0c88ba042114070ffb1a7c516998eb6f705b3eed0ef4a5f0161e90b0975ad72a04dd8bd9f59a17e75a03965541be31552cc3c566b3123c30db6ed0f963e4a360228e54eba1f15cf54e8756cea1984aa0275b5ff4a6b25aaf8684e1e7abd849e629dc03f305cb4a05e9f8b14979b1e42d5cde922608026dff8f4be77dfd0acd94a5aaeedeaeef0e554e66d7f4efd40b34ee73e7ce7f09b714246dca0f3bdeb1d49812347650a07a79dddc4bd2455d0fc7c3d602d9d0dbeef4f0dad8c7f2cbb06d50bb07992b6b43cd9f5cc4098a702b181074dd73b55f28f995318baddadd33b3ab021cdb4b1fae0098cbdef06b0748d39cb471b7ddfb9b348d98b0364741bc23b4494150ce2338c41bc0397096769aa4d3dc22d6e42e2e9f5aae720fe2d78e76315243b336d0ae3478b93524836ef6518070c76c3fcd7b9cfe3730df0ab085b5e21e9ea7ca3f62b67a86175563fbeaa4881d34591b1502775314076d568c666bc5d4b9ff93f0353b3cce52a5b680965463ae624bc00955c6f9a3500c052c62fd6c2bcade78dbf956ee55d9244c252d046561eac0ccc7745e8451626f7dd01d5cc6c12968d965a0af1933b4e9fdc97a6ebdc99dc4ae3642c8eb2920cee4ec5e1f00e369e081b3b7e1df2bf87b536f0ca86e26aec5f7ca3cb37a82d1fa20879fb37306cea7be448ec81a54deb3add4c5e64d46caf7c6a9912c45a251cfc8ad2e5b73d8ec7bec665ac2296fe5228ab91a287deaf74c023aa36e06c2d7fc7a55fbc5afc96abb800bd8ae6867f89df8a5df4b0050b313e0facb2aaecc7651ab27dcf947c553b764ca97d08c01e9fecae840eb306fcdfe5a32ba2c4f41f83520478bca7fa7059ad7d0939b25e851e01870bb3bcfdf98f75b966b808a46bbdb0d706f9c602214ff0beb4049e6db604fc024cecf3a5550f2ee1a05accff32d797b1c33bd15b41a06fe8b59c21a7b7058e86c384bf71d787bfaaf0e6c1b755cb801e4a76aca6f3b32f34ea73645df99ea3a079d9808d489a8c24bb99800888fa793fbaf235c48496fa288b2087b8cb6eb34f479566384dede084b50e1c4bd44c06bb469bceebb65a80d9aec46bdc1a189f55343812566c9ee06354654d76d4c03056da75e20d0bfdfef9c1506c78baefc147996d5ad7c4ee87af79bb605b4660ee24675efba1c212737a740bbc27714ec8f3f9be0a935e387296d69c3c483b173b9ab1bc2273baa00f3218cde1548bc900e44d67bf81fdbbd1566b9f41d06106112a47fa94e8960754f41ab16ab56525721d848c9fa71f10083aa88c347106867c8abc47a418abe086b2460c07a8bc5990ae1070084deddbcb572949dbbf90800ecbdae3778e58f8129c08c996b27087999790fb03515fc5e4861cf0453a00ee026fdece044eb718867a7bc996b10e6c63a5cb3ef4aaf73ff74e9b1f2238c5d61c1a2951f5e4fd48c04bb2264b3bff1af75bf3dcf78486bfd4f76e0c34ba762d579f059384c64dbf28501e9ec98c819a653d0fa24d1482041b78fd5608fa69e9616e4d35e954e0f4b9b3e758469ec50bc67e61d0b9114782cef8e1c89cee9c4eff5310b3b431298b5a14da0f57820d1dc132319c24e9770cd53cbd4559d9ff5d919ba01ad371e228aac7050219d2d1c573e40475178e7b1cd84e3ca918d22847116488834c1c2e0f7213c391aae408fe1e165b44fa1f3f8ca8c2842c6b1495dc780e995cd76d9d5b33770edafce2c59d6715a478b7b4d765d07e32fe295681b86d4fd12b1ed249865b2b5df258eab817e293e75d9686ef990f17888baca36c7aeab9f70d5d75f310d33dcda2bca97a7640c5f16de18cd32d4781ebf02f30607af1349e936ba65dc86477e4dc282a2d3f64d19481b6e1016566b6b3771502d6b0e5a5986a27c250117180b505d65737ef44509f23aac86d627b560894e7f6fefe70a3fad256b256407e043e7ce8f9f8526820b7b9c63c992d26b9c57d8492b13db7fe41f356424e4cfdceefd7cd256adb208a1b6865ff340aa60a67e05e0be5de2979ddabafc959ba8952c000fd4e11aea8dd4174fd43908784008a525e5988e221ed9c42293cc1a21c8f63a0552703f72b167e22e688f7e40945055427f65edd56058d44623ac75c11dd1e91372dfabe05c24a3dd5de1b396fd1d56442f1695ba146a0c58a2a01b2e789fa642f00e04d23afe5a3a7b235081decd8a1136505ef038655fe8e48fe0a2ed3b0e09081eca9e5cd2fbb04bd18e555f942c73403aafa8f38c875b45e71b331b92ce9e4f74583feaf058a62f18d72d6e2da9ccaf77dbdee2a396d49b68f073b8bb06317a272e99b8120e567544c6368e8935b22e1754a3ed0f445c80c751b4456a3ad29eb15831b8b9db73b098c0ca0ec16bf2c1a5b25e70eb8ca9db2343bed76c9871d415ab39e141e39df65d45a107e7ac59e22b63f76371239aab49d2fcfd2ec5388ef721e24843aed39f06cd61660ea580c6e3fc3080fdfeaa9d5748225ac9835f823f8c7921fa626e898f8f5999a211af9666b7795762f5a4777bec9bc98f048f4c5aac123cac7ef418f3a52ebe75592185a5d1f398b6fecff0885000cdf713123cb4606d7af2fdf9788845f6cdd1d8e96326794fe28f51954a22f269431fa783d9d0854aa6244d443190d1015f37e26c2716554290094b3668ecbf2050463708bb1716e2e52b04c31ed723518d29d631c58d45ef1a8b1b1955e26c2e50d14684c2d9dd0f696ec45890ccb4d8d53ed70f189954523d3a84940deccb8dc74ca0f1dc43a60a2f8774f8278a151d8d403a747d99d2bd7f47c0fbf026efc07648d8b17fc0fb511efc833eab931978e799bdaf054393c809a5b64e301a67cf7611d5c9c1beaa61b442e1b9ac671e5a815b92323c034f4382a14547b3a8efdc05decc0e01a3720c5b7670cf7aeb48ad468b8a511caac93c2ef659dd08539dc97fa45b1a07653c495ec1fdf5cc35cb3e86c168bec3829c2dd7fc4d478396a66d6ede327922fd46d14e62fe31e328b28c638ce67660c61ddfaa66199243ef94eab0d16f0370b65fb1c75da587dc437036d7ee1c3a81d12b4f3b2941fc76c5bbbdeee2fae00ec911b2deb236a5b399487070867b2f5a20f7f4ae091aaba41cb66592106af88e3e43edb2a4c454ff8089006d4c7bf4bc6671beae24013ff1df7c2853faa50dae76afaf3b0d6808021655c696a9fc5fc999b5f3a566f20c7a2400934fad7cb8caa9e62386248f2bdc5eabb8132e38ba6ff14f4ef16c4edfcd243b50027a2aa51c80319740eac2bab4044ef94ae029c49519a227c6c52c38a2f9a6853487258b5317023b33f4fc22ab316095d5db2db1842708add8e371fa014b4d8fc7a275698d4710166821c5f20951d17f78e795baf6b97a1c897570ea8c2447c6e469d24f2c39bddf00567e37480cae5a1c5db3672319e257958b0cff5fd3be4da3a9d78092116f8ba002346126dfebd950c37caf9fdcce7d153b3b903b14fc0edc9eeeaf02127ea84b334578cdbd34a7f9bfc2b239600d901611d984d308e3853bd7ebbccb06dd1fdf24b2793fbd461733dcba369bf65b6cc0de853a76e6eef4b186e9a19b29a0cd9a2a30462bc20c87d0da27f0295e061d817a6461dff043ae3c91e798c084319e6826efa52bc82d38f91d29ac481d9f17bd3fb4decf4108c7910f040da9b3b1f9816ba5fe28a33ebbf87772f6dbef41f20cacbb55292ca45a215f420cfe8502f173e4803edb683e7347adcc883eb3d9be8764cf9c0ed5e0c87e0a04ba4ea9d0fdf27d1ec58b1c868b6e90a5adc071223ca53f3b664a7a6698cf7c196cef9709610da1f6d38cabbd40f613e9471eefb2e016ddd1cdf9f9d3c0911ac4e3f89a20c96c5aaec3ff5d3812ff37ac3a0d0725e9ce7b19b9e2ab234bea0628b248148da321d750deabe12de6b03d6cb5636fae84d2e7f9198d17d1cb2489b3c21fab78ee0abfd961de22a7b4d08e42cd7f735f64783668df2edfba5316f8d104fd39da953c0bfe972f343f8ca06d376d9b0a779dbbcfd68d8099502ebf57d16458f5c18cbdf53fe54dd7e84458fc76dfe06e67406ca468d9a778f69759a02ccddba86d1014b7096bf7b9b6377130cbb9ff154eee18641821a7ef82c291abdbb9a232abf77b097a80b342823d5b137b76d8c1a8fb7bd165d59075563b9cdff967a15f5ee9c6a0ecb167db9d2749d37633310a3b57b9c73e584f620d9c3ceaf36e6e585d466984d06a44adb18f83add9107f6878cb575d27979e641667c5c31df268310e962cb6cbf3402b258d5490653743b5de292bf7d8d9a89c1ade59ff984e983699886bbe65ab14082002cd83a684f95e8feb152bff494dc80a225ec0194539a21899066e174eeb7a9876608461ca041c785de08cd32a3edb2db99e53ebe621dfd570172fa7f2cf57951d0adb4b04b63251125b54c1c0ef659fb2d8b1be0d1987473e254c8726d1e3259c393dd0b61aaaf10c5398abd6fcafb9eb80aa151bf220810cdcd49437011b3c868bb4cc36173cd022ce30f68af1137a40dcf07b7420af2e7c5461e925a67767fe5ae5994e948fa807a3fb68a678cffcd13ebf9c0bf7d36b3699f59b72eec0a55821f2a560ec428ef9b69917e04f9b9f43d2f5dff587896c95ef99a904c85176e770c9a642edb0b1df1fc0874bc423509fdb10430506f4176ee9eb2c1b3dc1ab30c354051f2c5db94cada524d33bf66b2a502913b00e90be3eda5b93c8757e4a24fb09fcf65243ed67abb777033149f6a482e97a538afd950585e380d5892ccf35a56c87d44d07dc90d53f5c2d116d0f742971d333860bb8c1328de7b81722114cad5ddb384706f9cdfe49681f3c7f2385a77bcdfd14cd25a5481a0f4948ff8e506c49ae442cc498a35374074081c69b632f12f8eee731f6081e2cced9a8cd0ea1acc0389f201dafe3cfbcbeeb2e56ec7b8a565e5f96cd7d999e27cafaedf7498781b61b17a0d4b17b6c5ffae80f61f74bc8f2b7da818cc32cbbd7896b999f928d88e48ba9cb452d73e10d8bf44dada41262bf75ccf849ac6970d5ba3313458cd6f1cd3a2bd0bee5ff21d4e0b9f684dc7edcd4f2b8752275e2af6887396e8eeb9c9b53e5841deddfccb1d6b4843ade1e7994cc5c94ef41ff8a81bd2e1290b4e7188722dec531b031bd9934dffc7bc5334f373f71bac727ca3f41cdf3f3eb004f1c4e844edbe96516776149de77508129aec4868055115c560975b9f1e3737df8e10ce99005e65ecfb1fca59f861b5162b71968d20ee3ef9771a1bacca93d17e5e19fcb7fb28ab7b1436dcbe0d3aaa7ca762636f8c499d68ac42da77f667493aef9ec52284b8f2cbadc0662de0fb63e9a77b28cfdc2cdeeffc52561a02a43f3a415680dc539ec1e89bd872279ee38c5c60c4b12f662253058fb52b7c513a440cb68ff4e9e2bc5f7baf206116756ccb8bebe385a72a98a37b7600ab7786a4d1c8e7a735d10a8b27274819cd1fbf06ab18c1152926a0ec9087fbb6df398dc8795200108899a4022a4a720a599ed70633a1b3319276842a0537abe613874d8e592c73a965e05316fe392533f486f6a32cb324856056d658a145999fae2381c3b1d9aafedf33b522d7f02e42ec7748656efb5cd7cb745698253d32a8eb36390e9a89fa2875466eea4c4dc55cbb7bf2f044da235c3f33ad01661d28b6a839d9438c4930221c62efc8f11efb579c40400221fd04e445126ebb7488cae415ad995eefe12ae734bdc1294edfc317f700aadd1246371c337b01b938b6b5e9c5ae42e109063587381f8ca0e7a361a8c129500f5506417ebad7ae8fc4e1ad13f085b17b5946cc1a2db72b6a4ab8bc716a7a0a464ea7739d4723f573ab3e774bb62e6513b487f10a2a7d9070079999eada3c297288d0248488acd0ceea2d73311931ca4fd87fa899b19d12b97bbf8bc79c06660a5035345956b3019cffecc02054d37ad0a5452dcc2d3d0e9857c67c9c1dc8fe47dcfc82adbff20728018f33ea5c3aac7c6db0488a0f68b8e7982364ba0f7b72e94d81c9ed3f85a075a1e50b73e4567aab5411a07195348fba4dcd6172e13eae4282ab2be565fc1b9500687de80be32b5138dd3e6ef8dfcddb9397586ae49415bf31524187b811c77ec02cb568874bdaaee6cf2fdd37dafe6f4c206e7c6adb722c66d2299a4833f778214598960ec015a7f6b436759afb926c0b0010f1110a9f733dfd1075afb412be07bade99bf1c9e8394197189773eb193590151953974937b2712a3db3465cc85044808488596973c5d432a5d04367f0f735d8d407f8ad3ae7e78e9c8fa85f02a7864d02155e8f616457df081534680b4c264c6185d15e3ff4bdc33c823cd81a3f7cbdb2947e40ee1fb8ca0759dd3a4c2b9975db5e0c4c385d5908b333f9207de29eca00cae7843ab172b6f8466238d20c640bef65ab6831cebf38d3c4abe381b16b14ebcef585849fed54fe7fdb5bf885548be12ab8beb218c6939edfe00efc827ec4d0060e0f3d76ac6359a7f525e8eeb67d404af355c0a205cf9f01d38908ab554764c731372de530ed163cc74d4b105b693e52d82d67638b0f2daa52accf1e85289dddf83516b02eb98555f62f1023496f1a43f14364b017b797b138f1a578c8e39b47552102e1d0575c27a31701730b774f57bea7baa619a801727d09cbb5d05a4b595ef398b3aa6d144cc977e321a48f6e286249c2b91c6b24019b87a320e8b42bc770faa9790935c42b608b0aa961de45a4eb0f5b79ae4f677be8389f5108115a9fcd634ce72ddd7a558e6b1e889fe2eb564d68f8422176480da5fc97f704e54ec54e55aec073c5da11c694ad78f4d5bc93d860350769c035aea8fd57abc745bd7540aa6058f90b0fee4f4e99ba8d4e7763f8545905a34abb568a4c0e67ecf2bf67fe01db5615eaa103d927f9fb30bf01b8dd7e6edc9e8c09afb7fd71348b282b804861011d2856316f9dc9f02d26d5c7321e4b060eee37a5548442dc7046e0b01f831775205b2c787fccb0fccdb31c396dfa1472519afc8d4f4ae446174dca5d03a9b725757f927463cb121a81b7428963a814efde3e3806183d8d77edd1eddc3db8154276e86b2d09bdeb51fcd47d1de3eafa7889313fe7498bbbb3f40f9c9113e809be3b8e4d0242244251c009972f1edddba2f7910a76419bd08f9e81516195eeb53d860c3f74ce2cff5ad7226468f73961916eb6e4fa93833cae0b55c7b673f6319562e680cdf8bd68ddade6b106f9a601833b647bf5a2f2733977a830c154466bae455d0e2c27ef6ff6d1c034e5c58754f6157243207bf381df616fc66f2257362adf9762ae804dbb03876c96592b50184e987edacaa949971790f626fafddbf607517209dd7046b1e5acfcf23863aaf00d377827af01dbcbcf62917169d9a2d373c895ff482366bd7e15a83da10f617804bb1cd66c46405d611ed3e62234ab15624bb6c8eed471dfa217de0a5dbb228855cd20a2e6321ff0004bd7da6c11f4641ed554b2edce194be33293bc8f518c8a50881a9337dbec846844975dce9f199a8b4619e1d186d3a72094f78aba6f133f404c5583ed90d6f43207490d2cfa847bd76322890e1c70648355f776de9f257ae0edadaa48d4f399fbcb398bec3dfb5945a3ded7840c63a10378eb2766617e81ba56c81561a1bec394f61e49dbb87c7e1f971296211461d402cf5d308dc19c8933dde67cdf8058b2773eb4a56bc82efb73dfca6dd82bf18e1998f44336756dabd4a384c9cb93e3dba4f6f6c4f7f78dae2f110b7e79eba68e34f4c634d06de27a4e821de6b122533a588910fd9eb5b33ee97f259413714421e117736bed332df0b4d7a81a16a4f7b67d9397603dde0189e0bee857625ba221d683ae112f4367b92c3900a1a02dc5e265d0bdfc116e79a4d17bc4d298b3e1364730601e63c6f20f58493f174d9c0ee33663130d1242380d3bbb1f4097d078260abdfe9ea17062633aeaaf93a50420b6469bda8b8e955cfc0b34f974fc5b22287767924734f4c8b4430b2bfa038add7612f4dc874b41e4a553337de2c810f24ec01fa7a52dd769cc4fe8199f88a906b215b6a64200c4f7eed8e2b381dbd8e0d508d11dcf89b5f63bd5677f5c51fec7668cda3c9c67638b2096647cbfe6f9cc6c3f6e4138b83aaf30595160e4ba7906855f9ab5f7e87cbdf6d3a007512119bc48b3848703445a198d22e657554c84c700603cda236be1a7f9b4c7e11bc051e0ce2e6976a19a6175f5b01c5d1139511a483c79fa32a80e23588119b5f21c374664ca5b63a1f92c61c14f5b3fc96204c471545dd0401fa5159162d60cadc9441984bfb259965884b5077240d2f507f1c4c62c549d89005eb6d06bc46a46c23bf6b9216c29a59b2c646aa4278256c06cc23aef21b6d8dd5cd2b04c97470a217b39af3227f5eec0bbc22f2f00ff2b7ff83026ef8ac0cfb231fe9af0c56154a048cb7adc7c26f67d1ee3a44458bd9493094aade9ad112fdd53011f4609978069e0d882b9a3c998df8cd079d0516a31f8a3447a6f9e9042cd0549cef9c1472451410e07d5b3b6bbcc6dcfd5b36c77c482b157a8a8f21272361802f39f608d53b080b6baf20546af0a0f14b0eef45dbbb163417b3a7b24f84e9de0d8f0d02e95ca62e82c14a6ec55aa0da42e709b119fd7e682365a362d7b90583b4b624c738f109756e69c15538df7fcd79e19d09d4283718c583e7c13bb45feafee9fc9249e406f18c35caf066152886304cd662f63a2bc0fb69f105cf236581c1c18372ab2014025817a617a2cb53d67bff249be4e8d2c75970ad5bdbd71bac3ea8f33274661257fa0743e8f20dccb78bb15d15b89233d868dd5aef1dc227fc7c41f0d480498be5899150c092e8eb772d0f92bc11d4d526acd4605b0d799dde9db296b8d219b41e85202598add4dc5340e47ab5c618b6f69105d6eec87ca50258816f3f2bb24","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
