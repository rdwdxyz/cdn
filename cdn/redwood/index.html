<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5bc97a2b739df2f3a6d68b274421adefba6d4c09bac3bcac21489c773f4d17f031464a19de8be88e2a606463c41124078ae532807e144ab0659a1a81d405fe35c70fd47661ff6f232f0de8c2ab669e91bba9f19975ed14037f1ecd4c38377589d6af1f45663826fdfb95d3e6febe39fa8a69b99f1647a159c076058719c700f6e3ed52eb05efb550d3bf839778e2845404dd451f3e44fcd24ff6450e23dbac21fc6bf1cfccbe7ea42edce4e694050cb9ba3a8e488190087dc7f9f6dfffe1eea44edf4e5db0da5d1923b9aaba2c3b45a9baa4e14f518a7dafd4225bad04f645db6cafdcf503d429dbf067d5bb35fc730f038e6770b31cecb35290dd763b3ca515c303cb1658804fa460ff70e5cd9d720a8326b107979ca8bf01fdfb7418d18400870d3d4986f53cf15dac6fabc4fbc90c6af7dd1a4a4076a77e3bc542e49f90047e44dd597d08cae29701afd5002f21e2ae533b28863a50747077de17a1928935dacf8a78ecc2baba05c7d9d38c49fdf25238dbde41f7e69915252384291e4ca6ff51fdf7d4ef25ac63f697d4f19d1630a04cf7a86dce13f4c4eb6ac7a64a63a9ed9d3a3f82dfde18472106b9d1a48e62e98c80dfca7042045e856f28493155e11ff3f9b64480ca8e295cf166b4cfe26401d72cb07206bf1169cbc73b6a09cd6447a1fe7935a6c02bfc0ba6bbc42f95183d5beedc08bd92b3f88a12bb25e30876edb21bf0bf5a589fe7f1ad3a48fc599b03fc7152e107fc97db98d43f8dc073836b17ab72327b6759527d994703df39a8eb3014cb04fe6330c9a22c2eefc4fe3cbdc65eceaf0e59c8deef74d887486613ad939eefd7106e3817f7d0891f41e1d3d83587dc82ae8927ae91acde0a38794d110ef6ef526af45b3a9f5b15b6beb904e3ea4641c6e3c47ea0db285871fd8227e53a043b55dd196551d206b9b42096d062e073e74660855d2a7264ad53e2330ff02a6eb23d18dd8bf39317c7a62a8e556ac788adb7e6b632383c4636a8bcb7293aedaf882c9ca3bc8385fd8f90b15c3aeb0070d177649e3a8a18f12d9a477fe76968af8e3f85bea793d476c481aa5e321a7a1f48181cad4f618251cf0c2c073be8b7065b85639c41ada63643600f9407b4c1e6b6f127f9ed88fd1c9c61cb98dfe49bbda14b2a52d67aa233f4322e8f8b8c589b51a3201ae6ef6a68dbd5bf4e23d74b3ce2f5cb000499abc31cf5bb53a981753a0728b84a75798d8fa403862d1623d7b3243b7361cdad70764cde8a06f70f77ffc3ff56520ee17109959ce2a3149efd53fed2685892f5acc96c41671ad81c0d133fa4cba6c4967aa2e56b1e3c8e7768e430673fbea34eee73818f75fb24d414b21ffcd6fb38bca6c452af66be42352a17714149799e2e5c1918bd68763d530de008dfe0938e17bbc99ef2de80513905d22b57091fd1b605f2c36271dded71cda61b3b0ac545e32caf5f71b1a4d841d7e23c0e34acbda734c23c855aa1300bc95cd07fff6f3851f0056c7d578121c497bfff6b8f7156098305df120222005583489703edf178e8413f1c4b867e4077f39d232d84624cec284d21e5ee4cd43cf66be570cabe5cfacb6593fafb00d512c1ec1c89dfd7174277a8a97e70c019eeb5c8f600f3e641b44093b64d4676ab02813cb911e16b016e41779159c67675e78434e545c655b16e1f031f9d592e98bf250a5cca376a8132257ab8fbd5350bf7aae2fb3196050feaadaf102191a2c9eba47069e266f72be30649f4f26a5e8e45246290777f73cb87b3b3917ea343b48b9f9d234afb2e79909f816a0c66e271da602966f424002ca41f4058aa3e1672e3dd8f5ba3ef999ce71fadab1ffaaecf8d0e5457e149fc49644b64ade6ce1fee1e7267500cc158ca6c21d390d65bc4d7478762738f924162bb7ebd64414f43b334753a55c557495beb7f465c66226f5cb2eb94ed7d1f4f971ab598ad2a5f441a7440ceb14253b9cb90d7a527b098151373e9f765a166665d1a49ec89e970b13e2944487f4b015a85fea3df9e2ac0620f39facf69f3e9d4328e6a1c88fedb271863e280ca4e1d855f5ca49802ceb8f06931cb75fd7a173f9db45fd456cb9e6e7d8e5941a562db09bf5741fcb3ed6521dff162e42c89d953e384292e1c74295a7120dfcba18d80076c534f5458a23d12765520d9e0983f7e145885bc114b88ae608e6fcd1d81bd2267011999cd8a5306e2711ad4a84b338659dabe1a05e8352cd502708410503ce9952580d71df32808160f3e448b2d7fec8cd9a2515e18a6c99eda5679e9bde0d7074d848d86e6412f89edf47edc0ddc4f647dbcdf34a8c8ca4ed93fabf14cad0b431b0f58b5c227e133f77c7a78cee55fd68c4886267f2061842599ae01cf9cac25f00346a65e24000a881d866791c695a39e21da5d4107b2a2997dcfa192a7c06a149ba4f4695326b43614be38d1e089d3e27e94264c2bfea1597b82ba6d556efc10bb8d4c9cc29e0f78675f6f18014d193176bdd8b052f0f86d9ed3671597b83ef74532c3877c508666a85dbe633e42b93fefcbcd5c420bc6af023b79edc079100240b337f1f539705441bccc26898db3dc895f96a6be77475c90403c3ee8a0648e7e3cab98850d204e71013aedb2ed0e5cfe2b6b971ab3ef0260ed31fda3d83e9b769d9445b3bd0d18641c527ced741f265fe920078e9276059db67f0f356ee4beef266bf2bd8af00e34092438e5bfcb23c321b0994df0e3e34ed2bbd6728a73d104418ea2767eb03d84f3f9c0550754f2536c2292c6fa62b36e36efe48249edbca0d4dc0c73055fa1a5075ed20f496cf8e2e5d0d8b790d1e10196fc627bbbb8315ea2f402352a1dcd34d57447b00cabf43c5111c5c4db0157e6d7fd5397e0532e9985986a7cf42713c08861295f0c1d56c564d83337083bd9ddbe01c4bff7b51000d698befc5efebacabcc6b95ae428ff3939fb64dca3ece27292d0907302f7a2b0397dfa79cc2f7a7d314937f9b6e1431c67c4c6d88bd776a87c0024f41cb408ab76232ad93a5f89aab56e8be60b330a927f9941641e0dc98c3b290e987722b47547964494f6290719efa9f440a534a678e08a02a5cf908a32aab7ca12e9a776dda756b6d30663730b9c6b5c5131dcdaf83e66ce0edab7862a2cd0b984b45989016adec480f13ff31c46ece7e0b4dc76c669c889597bf017c1d81300274d7adf4b84b3157f73c18f5e81e0e31a7cd716fbf7d877cb8e1675233bd407920e5324d3f0d81040cae34e99203e15272423e1a654d36f82acdace07119f2881954c592192529e754fb3050fb13a4c7d2c52d3854634943178892935b878cb6071c35b51dbccb25845444568fe857cf2b3757ddd99c07ecb75f360972a2c4a0782f3acb60fe9ebd0530ec3a3e001e846c3a7dd4c0b0a0ced56ff3f1ac91f9e1303aaabce25fb85c5b5a03de1ccc36bbdc6e574aba9ac5886757310f6adacea4421eeb3b1a52c6b5b3a85612ebe1268dbf7c3ee4be8eece0012353e50e867219078a1a2b1ad14b79d4162dd5e1fc479660d28b4972b2609e15ecfbc5996cc4c8f7e499c82cc82df75ac31c92222a6a5d0d91f7636a6ec6d982c0292cb911549ca0770fbe318bdadc299effdfd388f64f238e4a19779de1d63fa9e49ae0de16ac52a5ff5367e1208d57591defb1e9aab2e25828d41708e40a3f6f8a256c7198683e4b3da3a64e90872db4af6bba818620fc39ef9f51efd02229d401af925f56a84ff0a2146262dfc2cef938c3768f5230fc72a8fb6454a79d8a04e2bc82c9c2bca70a189a8ce0a1c0a87537decbec265133caeccced6b4f122c0237bf8d7d75b2e79fad525a9c601b9c987dd2d94593a23b0238ddffb53b82cdaea32a8957e9cab98ab5994482b71684f67bad6a30c6cafb32ea71e155f426a8f7fbf92316f6c4df4a17f6782a93d3c6b9b522b90df0cd6cf4ac54ad8674107b3f28e53f6bfe138121b91882fcf49af8ddfcbe5bb12744fab071fe0e86fde955a4f476a99c92d80eb8d525a979b2790668be4525471d575997945116f4f124dcd39e6c6fa288b1e931953dd58557a5d8f4fbdf2c1476ecbd2e354d2a2d5e062afc286a76ba6a5f173b0c7623463ebf3b1dbc26b1e949249b06f74aa6a28c1124ce7f7cf4ea2f3890b840044c2afd9746cb2c19290bbc4cf6962641715c30fbbab51380051a153b056e5f8fbfd93e65f5c73021288914c8a9410893f4030296ab7e0c16bd28c5026d772db8c3e8e53b08b97862c46984916d9a6dbf28b2b10267dab7d1e03059bd76ce4dd0afcd28c660a24a95230e67ee820916932a0a726c829ed90bd0f665f9daebf5b370de9c392c9600bfe28bdc81cefcbcbe13922715e94456fc1fc4ac91551a555f283436a7fcc7bea784798231ec2b078b7969ab3a0b21f59eb5e963e9c47cd382afb3728ee9e6743a31c8bb780d32e13e8ea75d8dd445f065473bf70969256fdccb6d8e6cce0dd20aa9eab498c96f769893f492cf1b7c2e61fbb073cf8bb02a952e9e29c02e2f30f6120c2af996af67dfc6a830dc6beeaa5f360e3798e937b56fd505ded993aa9958c247ecbfb04c62c604ab928f3e8cc7033daa1d7a4e6d7d532d8bdd679b733a6f0a37eacb5a6868de41ac4afdaff7bdc83cbc3aec79f91fc4801de9e9801b116b5c48b62871b46123b865a4d80f545a7313cac586a620b3d0b833b76bccf58fad0135257300d66f5cd0f901e1186312d67bfb5c3a122fda378d87d2b52324cb55381c33ee7386b08be6d3484a72f31dd8b57abf58f2d5c446a5cbf4f1df69fca53e874ecb4eb475ced8162dc36664bfb0164f9221ea823b600b8fe3ff850bbfbd64bf1212a47fae1def4a65dd239157715b0c014629b4d150cd8ce7df3bceea22ffb4a919b7e00c7881405f58ee6645c567a60b23a7677c6db335b64d7ee6916f13f304e9d675a8c6f16720bfca5a731887894230f5ef7406dcff27749e78c399aef1e3fa5e64b7e38a49f19e62701f1ca73156c1cc486b03528234a10362c45242f7faf9e13f141d1a856fbd104491a63f6ac20686ea1e344d8838b9f728b9e90ead3acf1def9341a484c207d2913075433c3cbf81f659385b4c93571c784ab1a56579d3c84af0d11c69d960f71a97a307df55ce7955b2d5ce503cc94424b4e963e8b9f0bf952a4a2646418f9ae447cc40619967ab32324fe188119cad978e333ef27d77056e6384c0fd7fd042b6c7e9053de141d811d23a9c41010ae3bbd3ba72b4be8324af7d932f229adbf7524a864232fc024cc3e6f5b59cc3184650d2298c611f42ed61407ebdf75f3933e712c964b93b52d49ea12a9ebb761bbf39e22ed2cb18a94a8e29cdc68bf4f59ca3667ce5284ee60dca86f7a4888d875082d50b26f8c9dcc732acc8765b5c5fbab16e85f8446d8583161cdc3fcfe74f13da1dc40b5af2cc4e40c68e978b776f8859e37b876a0bc78490e89e9106442dfcfad7acf9e074414aac8e2f0c49707c22e8b8649c6c4ad748f6de204c0bf60e9a57dd1c458a6177ea260adb97ee768332347dff305fb2099a19c304d7a1f8114785327784268cca62d6b75f6e012e61c375dc23ced185b551bbdddbf0be04f4e1068393ec36cdb4794daf8aea8f8e33014874b33c20e4cec44da90ff7a89266e47f5a3ce46548977cf5f0710b4897a1743d377fcfb8b67444bd6d2adebc538cb142f0a3b05eca025dc3639ef07771d3fee1c116b321f6173d86b8b9eadb2f37126ed1fc2ac7b03eb93ecc1d67471ff886b284a391235c26a69ec155444308b7cf55fc746d79f181e07dd240803397c6ba579a6271be4c9b2dc427269a55441fc15acb47b24afacf67c0e7732b41832f9d52ec109e920e8d3f4976b0571f31bf9290fdc662dd85137fcf1fdf512743843b8526584b3c2b5c499f57c49b264b7c550199efb8c99a731390adf0b3f9b8ac178ec1fdf98ab49f12d7504cae8bd552cbc1e021dec81b5f8e2d1eef6f724e8b15b03182f2a90ed4a60f8541a53364dcb4449c55e2474ae5af38c927e0843bf5fd9ffa317db629e10149cc28822cfb6eccc44d9dc5a95ee2f6848964ec33e8cb8d72272ec3097b87b884b9af058dc2553304384ee96f00cac29f583bf7a33ab07b88e67125dd1c31812e541c56725d8902a7719ab7210201cb8212b04424e97b28907ff4559aa7e118c628c840577daa7fe94e2b1359b28dcebad13532e557089c6e407f28e8ef0a0a5863ad2d6b5f1cf70d96863c9da3c445c7d325c8cdd2c50e6d4e299cb57bd7c0fe18dd7a5dced24f12147a58cc28389c9ad56d18a9cd68ce6b5aff961864a0fdff1015dacbf0c2cb921a53d78f5f5a545b5663e57ba2b3b247d0641a66785aa4892134c2045dbe1c1936846e6dc18453e9774e01d4481002d1e72fc97ae7aa8f940c782e0fcea544d1009f7c1d4d541689aaa6abea3eabf49a3369c15d8047362e16de7568ed8c32acdf275e704fa3e48d2c164d4c3f0895d2b01e38aa46dc37cdf8061c444cccece8b9925c76ff65568033adcef06725f86346efe0e206eded18436e77b61f07f178828777a93c8074412ed0935bd3425c1814c675ec964fe561f4bb493a98dbbfa40d0e54dd41669cc95e42f862b4bab183071d3890362d041aec343f9344ae7eddb5934bbdabca19ccb7bc645eedaf5ac511031697da785d30bae9b32d31e3ca05faa6deb1c44cb1f417671f83aa2ae157676e059f3a110f9246d6dea765a662552e8048735aa16476f6eaec776261ea9e0d4ddd5080f0ba240bcef91ead0b84194a66304273936c5fefca837573fa2ee685e0f307c30463ca67937b8f6aa09200d17296d3b9336e8d3ee72edcdbf3db3ada4d8dfc70b04f93a9de60d760c9cf5619b012ce7f7218b61d6beee990b9c174df4669f4e5f66e8347bb83cf4b8709b76e21f2711ca79e0bfbb198b667cccfce3c1a563f404d8742a833e28d6d6357c1cf129dd783dfaa72538ee03a253adb4118c386ea2e3f38af636ec1810269383a1964faa8e3efbaba443edecc144229ba6e8794b2b45228b97fd352c8ad4f710fec00f272328d1d938c0ae44ef776569510d238422b7370eda0ea6036a95ba0d773df162907d7fe3ef978e712b768d33600df97e34712707b09f60a6f5caed3f520fa1b2fcc4faad93e80db24935b364f53c530d820d42c44f75d23904b5a23c81e10c9d88dae52be77ca4ceee1841d91724847ca29f608ffba395e72a46ef2ff7cfbf1d9f4e2311d455635b2b6e49a517a77850bcc54b96820dd43fe83efd902c61b873e05e9d090e2aca8503c20f673ac05756145827cf5aa9dc779eb463e748a4165e041ff81adefb5a3f23b5f41a7a336319dc29a4e656d745dba0c8acbed6a3a49c46c580c0466b16f0c4b247ef58c3b7dfc5e52573ba02129411fa97c4edd718b4de37c38e9c61ccedf069b38e61ec363d033a3231aaccc10292a500182a5a94afa46b99c68c2715b600b9c4df22f3ba73f0a61a5cf72b32908042424acf0897408ff77dc948c181568cb7f5eeb5f22052639f995604ff64e0e6baa88869a05b25d8faea2f65c91f5dd59650f6f97970251363b00e6e55e002a1eeab0103294f42c83c07a312778f8b4490a6482e7df3b9824c7a48b0c1c18862dda5dc236926c6fc130aef1d31330cfbce9c63322bc5512b3a7a60bce879098f6130a5a49473ba6296027ef3ce53922d23d0b66a377d6031809b380d724b8b63d2830ca46fb383fb510c3d6f185798df0ad9180234f0e9c3f96d9d6e0cc30760d127adfc2340b9a5417cedd90dd2e57ca778d87586c68ac8ec2e4ed3c2f4296a238d829c3866479d50d978da5e478a79a6b513c194d024ef743515b73cc40bb4f73f6a9ba87207167731597cecbf8347a78a293dc932df09137e4484551f29e589bbd9b10f1e22ef16f40dd08cd5662302873d32bb1ee60dff260d8dfffa6b9ce6b6c6d2e40eb0788d2e0307a27fafb0290da0bc273d769dd8b15e22720db9c153381cea37212205b64c323e0e40340e84bb9f2d371d1ae34f4fec177b3d3b93de84140117b146279df35cde618556e3ff917a6cced042908671493e0986e65b8d2ce6bd25d5406da8bbf988e1189730e7dab956776c31f24c02cedff9a1cc8c05093a51a7891bb8f5fc3f46cf9ba68c4a21b1234caad98b0c682ecf387c854b7bb281a7abc24f4487c6b9b9d8ea22f44f0f63e3db5be46d3616b016c6c6894129500cd97d58b4ec5e3016d4d70863c781143c8c405ccf0f42ff566057f4228e690d15131a5d6925eb4aa39b0ca05476af3bbf7eb4fcfe01db16a07eddb76f0805d148472787e7debe06fb769ca618fc548aa4153e7185520bb63ee2877fb8cae6161e45a7baf0ce74bde0b007452a9ed5e9500141f9a2be82bffe36fc4ab7041417d02bbdffd3d0cf67c15b6c3a0f8f10d29439271869200c7284e93c0431e7b0e3009bc99f45c5e3917bc7bd6d762141c3384561267b6d6b8055370300c6529b4e9dfa31ecfb190415d8ea95b05b88dfce240786f93a37f00b26391b62f76fa66cb305a94353d935a329a4c27df8bd92e980498322a4c298558c82c1e7d4e42f76f2820bbfa96abcab30568702cdcece89eb53ede7bda45d7f6861619f780d946bc4efee55a2b6a0f3a4b57fe7650b948c270b56de6b4e51ba1bb89664f66090b19a31c75ea8b3d2a653fa84a9411c8dd714c6bc048cb5502a6efd4c089a7a3454f46a7018aea98a44fa90293110fb4bb9d105ae45440c82dd85728aa1200fd75d6c68c0534efe36f9b6cd15f6f58f5c4d992c4d174460a8f39140e1e362b26c787ea1fa5da850571ca90ee9cdb73188981fd3378b3aa4532efdd5b6c851711a21fab26aa20621023eb633b2e8d72987d93d628523ca269e5b874fc53cb4c107f7b54a8aaa6a4a7162c04a10ce43151e6c0c5f0c410d007401843a3e8eba0bfbe675a462a501fa4981ce33a1ffe9157b2f9a03b4012e0afbf1ab6f02418b68a13ec9228dfe4bcb3abfa67ce5babd0041e28c93b062366a10a6153b5301305c621f294256a9130f83fac66559e521d588de665a98dfc4fca3d32801f0fca50c018feeea1368625425778a399cbccb1dab37ed24dd3d2642c2a953172f75739453842824e8a9c6856826c5623b3fb8b706ef473a08a6727cc3e16813c5288b0eadcd06ad7f1b9657c274d5b2d90af5d4c99a7dd59fa57bc4a94392ec1bd8a0aedbcb6225588de895d1761dab37e1c9ec2ab243fd6797d06f157d39d6fac6d071f38db958524910c9869c1f09168fc999144862c038aaddf76b2c3cb789f399af04f5d5dfb08a405aa01bf540b19425c7a5e02b6f2412a6da6903b5f3ddbd9e0afc281a3c58e72c763e7a6713014147f91e84c96493e94bc8002b1d9973d1316643deb3587e18eb1df1a6dae4be1da8bf5136db9ea4d1b10656490bba166e49668757a0fb447ec18f94b2085ed356f7586311af1343934712890f92f37ef456f8439eb175a2f1d194d92cd7b17507fd43f8b878160e3cda9b00b352327b2810f904e866e9d5b46ebb8f50ff0c92d8e62132fcded7126d3c51f1ab40751d31bede41296621a400287d8406cedd385b0353892d7050b381d923330601f52a975db2749adaf57aec5f2a2706151e5c1eacb80bcc2f270e4b41ef62cd6a53c9da4f307f973918584be58b627b2125ac58979bc27c44ebce48e58e79a90de351f06e9b250b09c5e58d9e8f13b87b67f28b37b299136fba6eab969f6c07f94260ae9489104291ed1eef04de8d261e3633559fd6d464bd2f45e01551f59dcdc8a2f13d87cb876911ea2ca5f39c97e9c6db1d1ab54611ebe098cd3878193486b660436dbb7658c80a3d2b64396dff2d24700af95ca960509b52f28b9668c5d62de2e61536b7e406e418322032ad9b5960901e91420477ca4f8e1217f6be56fd0cac14a810048aeee442e2eb6cb7213d76666afd2c632676db7c5070fff02017384614696d55a5a058dc9360b5753b8548c04ed413bfd27d1df37844a52f4d0850aaf0aadd76b5dc10dca97dba2a46ff4cceeea35091353dca59116d23a39e2d5ef868bc6395e796609fc8cdc3b1e0518d299dc91971246e66fc21a4fb1531a8937214fd5abf949f30728478f0272bbfd91e467c8574126a0f2e791a4d504310cb002b19eadc65f2a6288a0e84135babf79d830dc1786cc09e77f38791c5144994d6f957fd8703ce0160c19107da8cc51fdfedb5811f0c85eb67aa81fa457317cced4f3df44949038f150c7a71ce6a0eb9d6072340a6063bbec784332c0655bb4f8ba1ba3656db5c82583d8104a5483622eff1367c530975cbe173bf4017ee82ecbee3b9e08308ed888c6412db9198ca58b1b38d8abf7c0cf3e086be48a9aa994ee780a3c56576793a91b5a6df1c3845c77e3980b4e4a28d8c09c8ff9c7e4df8d69cc367ae72fcde8ba5aed1004f2de4b14e59963ba90d27cc081ba6abd97e50126991ea6b4496ad706b695bbcb105fc0d4c37c87af1fbf66fac0a939c20956cc028064da94b2fae548330d578a67ba2ba6582f765820c7ae18e1fbf20dc1570f142aeca65fb62959e512527f1858a84892f5deba5ea251ebd63c891ae60c2ebab88d6734b399d210cd961585693bbc82da3ff1b90d80079fbf3773ac104883ab7fcc1bee74c6e3fe3f21202934c4023b12433b4b6bd6234da5fea3accb4c66573220895ccd91939360015738dedeff9a8524aa2d3f2bedf026664cecf30db69781db41c2f06f31ed89a8ec4b6e910151cce39ecafc108184fd61902ad211c8ffe7b5af3396f0f694bb7aeb8e4a51193a2ac865fe59be449129f5908a085f9c6ed058a04de200035f51f22818a8ead9b90484b56176938a7aab196c3c56e2c386b7ce7270ced34f5d465f6a0a9fc09b100af497557f2aba4e24475b94ab9497e4014a2f50a2e7bb0b389d1cb2c077920fb4453be776b0b8805fa47eacf278429d768d54d9277a66efb7f35c8ddabc752181e71110850ca023aabfcb2b9ee9582052a746a9c4a483fdb4a629d80626a5aad50e988ed9159e65c09956fbc49cab4b1b676ee6fe8b349f01e8b2ac207f8b1aa6b2a537f3372cc7c33ca6c751a3e969a1f8cb8efc9b4683ca7aa5fc3cc4bd708e6c1fdb166471a75bd5aae60bbb597fe24027eea85eeb77bec1118f37e0db6bc48f135342f33e753ef3241fcf772ca1dca555493c68b68924b061c9e6b02807a1f0c0c57df899f4662cc07de4d5e8562cc32d4b94bd240f27280ca6d90979107e30d1cf0019c5e6c4008ff0e433227124b0c530ea033c1bf6c00d59e4c745a728b2d3a2ed724ff9fb789762952e6181e958c2018beb623fcffe650ba95a0f215e85c9a3e608e93623c6a4d43e676d6ee47244106a638bb4139eed6f9cc18558cf82f7850a1c52fa36f1ad19c8a1ef09f642edccc040b7459c8afe9f34215ea8e07f7522b7abcc90a0dab9fb332cdeda763219f03c33bd28983df7bdece954c04fa0f0266aa57e601aaa1f5819b175b6f2978033c07ca837d36bddf5726b1e8acc873bdcb11263ed52e26d5544c395b548f28793b5135ec4a61a06052ae37699de3dfab7fa62e76767e9bfeac5c5ba955c51ce143c9a379f43ff7379024375b34c8d5c475468d661053899e6a3bb242823795ce2f34fc310fda7b8e7ffa9d6e0e0931922c63509ce41a11c6e2bd7ebf3a20acf69075ad3275b8bd651e713998cfb9b170a06b4cbc3c4bda6ace5885ac134e09901f22bd005365717ddf82b5b4af8f76bc98824d9c93ba82cd9e8dd46ce7b454a01c45035df2e7a303519daba1237f7f172171e4f21c7ad5408508896a63b1784c2b6cb148598702ac3936f1a5aa30ca13baee0407920e580d6703a9b8a976054982be118e7676ffe05a41a1a2da9b638c2fd3589e5b91a26968dc2ecd77db1062072190094750b583c35eb04ef8b43cc69e498ec4b51eac7562054366f4595d05cfce574fec40026d16bd957ecab0760db8cd78bdc9ac969f6e4a0b33b8819fc6ad925772c55df27e5578598989e6270a1de6f2616dec36c364ecc435e4ac91bdb79e625906cc52764611d9e4ba4856962c6d48b911117688bc56a23f191d6f78c2fb3ed4987a5fc64c7348bef5a0181ae0a6d0d272ded357de2c10f12b0857c5f51d2653f0ac41d30208f6cf4a41e9c022e979c63f8caca027dbcac0f9b6b4560fe58904a50ca56ac368fae41f6f55ae1fe8e79baa9ab042c233f067ed6206b4aa80bd23a608e8fe830de200160543cec74082f28fd9394961c455022dbc3829d04a40b841c370d465805af8ab8c7700c6abc3b35021058af458ae9fcdab6d0f11b8b27e2c89767bc8a4d82779aa9c7b746719e475f37fc51efcafd06024713b0699f904ac8a045fc7a970b7d66a47c13de33cf63de178a24f09729229e5a87b158cf974a4d519e71ec9ac04f0d012e3d7a1a1e747d0d542966ccedd2b17e4880800d80fda3994d36476a630bbf0d968c3b4b531ea2e17618c8b2a3368f6d59f960b6df51fdd015686882e0eeae562cfcffad5507c20ad08185be4ffad84cc456c9bea3a94eba44c7e981315e042899564e6e25e21cb5a971c452669eb101014e39e49238d0248324eaaf3e0d26eb4f5b2ee807c906923ec4f2b44765edece393794bd7a86f0e310f9cc04318ec04352db71e20a5c03069da2778cef539306cce6d8514225dc499ed7d4034cebe9ed889b524cf01ce1381db28025dc743144b9763dae2a95d743b19a3cd4c85165b2c89d2bb279a584e56fa6b34c5be2c85862ca8e05b4b13b94edee50f5fea9c6bc5f7bceb03ebee1aae9fc0dc290df914af5ae8db5dfcffc7347cc95e16f4a9172768ebe2a9394236ebb9be230e3fe24594364e0ccabc4e3d69d2cf01cdce8e6e9de2a2630dc19d062374421cb94d9017271caf63b34c2c557caa3de67b150b87790171e3e800fbe537b8309b7b6373bf2e40943ba8afca340b6526929dbee6903b2cf1c105d799fb32341f8add19e22d4e63e32b152dbb83ba7d81f6d45aa9709edf31f5572ec4b8bf6190bbe50b111cdf51f91ae2971fa302b23fe469541b0511fefd84ce21a4e5bbb7de89f0a2e357e81b5930e22f0388d5fb6b573c147041b048c6aacb6b4a8a94145b3e8fb9a36ef50c9de59ea2bca2fee3ddb00fb5484a09e01b1697d195f2c3b60179184f191180ae7bcb801b9c6ab375f02157db169a123606e8bd722ff130a81bc2457aff2409504f54c7540401452beaf76561d139529e958b47f6bb3a09a225ac68328c123ce4edfb0c1d901d168465ca620b1c2d5482c08a07994643986d0d90aa32b4cc4af49869cda4af4a3f150379442dbb449aa5e6176ce184f447d575fdc25c28b5a1d259115bbcb7c8ae6918e09768e95737bcc450939973b6f9860f28f64cb6dba59247e1bb5186f0761452f40037c164cc7d46efa8604bcd0e2a146a18227afd299b69632850922930f60836736bf80e982a1008f1ea21296531e23010e84331992551a9acd0885771f1b352fa699f986579a2542c3b6b5e7061d6cdfcb0a6870d5718ec6b1b8f6db035d39a39a64bcf496f7112ed8b718d4336d8adf6b73eef75e2a75168e84ab4f8a0d5bc12fa922e994df9ad318fc955d4cb9c23731cf59d1b82f4fa2bf7d1600ef42e053b3e14c4ae5affeb7b59a95085ff0b6fc736400a55f69db77e4283c9a0decee92cb27a67ead22aa50477381b0877909ca232696f176daef71fb7133561c2a06b77861bebcdd923656636ef0e28498385f97baa3a32636de15453a773d4de8d9f24138e30ffda3c128c21256c502e4c30caec228a83acc845662657f491a51ea9048414777b05a204e9faef2b0bd9bd05a4a6b230eb4a3852f1b3827b36840a0287f757b850aa09a538ca8f633391b682aaae45f1d86f060e604f7d3496a25b39eabbef2735dd650fe869bc4d3218000b57f16e5c9beba10337ee6f8859ddfc21918cf91311f0c887fdf1abc7ad6030eb6f8b171a8cef55eb35e4935231642f6ca4a99dcc9cc1d907ea780db3c1038c1a8d5177dedb14f5ee786a29ec71ce7c2b858093241f22dd2de9321b633af1d158d588998618477432fc395e182d6e66bab363179f7dc109f11b222d60514d75f86992dbf4326506c5aca179826d5426214b3e9cfdd90676add6fbc78fe6e709aa4e77bbc564e1a31df8622b3f99284b7417719a440a69c52ca344f31443b37ce5822cb67ac542db88a3ce3d1c4480be4723caa3473f61faec316a173d6930bcf8ad52d7e04d32d5026ed9089c607d0ff22b855dc2290fab50fe0832309f4e66d9a0d9ea27bde2f32640773c9bb3418dedc7d016054606dedaa4e8e26e146c04dc0f6cf7fbbeeda6cd79290633e131dee1528aa50637d37a599779e2c5fe44db1e60861426891bcdb24e1a5f693a45747e914dc7fd8bbbbc9cbb837db166327d56ce902f5d68b16958972a62d4fd6197aa1be38daf555b88813de0ca7c61abf119d10318ab1c334af578d03d1fc19ece0f046e6c0f524bc1c84312bb4cc83efc5e1f6d36efa50d5fa53ebac17cee98f0859801b27e4b24928f755f1fcdbe574efb145a243ca79cf443d4ec3914e3dd3c95f33ae664c43a462f51982055f90e52961d7ca5c8dde3d1603e379d682da3bfabaf023b98095f6cdc6509191e1a03941d773177a5794183d549569b942494b4ca71f68936c51c2cf1ea4eff6d5e252558d82b96b7de9a65a45eb254890e23627052df236565d074895872a923563207fd163baf22ce478a396a76aec507fae41af1c4801c0507aa1d6bcdc051f66f094f675a522624759f102a641881d312a1c5b1a9c7060f19daab6b8da2d0a1ea4f1fe4e89279dc02cc7379f99a9763211fa9633497249cdbe220cbbc6b4c578ba59f5a59198fb7c8ab9362d1f38f5215a8cc26faaebb2104407f76f7feb7e8e36261d0dd8a8d8a0a81414f67cde74410b1ff72c1f89fa47a61ceaadb5b1d865cfb2ad5e51c00bf3356a9528c194767522a89c2ff27349fbe1d717f52661ebd88cfaa1cab210b5d87a9954bcd06c17a805225bee43d923e87727e71afbd5ca6d284c60f76a7865390fd65b2324ff39dd0a551e3ef2519981dc5d681c0d50fa2dbd1cf41c726cc484e07fc09aac961612c8c6e84f12ebf9ba2d06d3f51c063cbb2c1accac34bc0d1c5ed456862b953c06f1213973212e206469a291b4fbf5178d7a88ee023e054615cacd5a9af379c0613d6d4b7518d142adc58ae7bbe5cc09b53f907bb2a9ad1343b31ef32f3653006748fcc2388a1ce54dcc3014fcb0d8f87c259f3162970219568323c0a96eb2c6f5bd8f4a29a730617342fe93ba5c5f33201e9781f64b88a6792c821bbc3a88c579e70856656baaff565cfd4e41ca2f5b4c863d33588527b743ff53c976ad950b2f62cc631ec79c789c5ee676e6e50def396978a320b910f1d1412f46107508fc1f26f862b93eca4e9cc1dc16443bb693f01d508a83ddfeb1b375023352a2d6824f2793c6fcb25fcc3f77822be4d1ceb177f1f7931109c4e54b696f96085aea08a9b69321102889cfad95cfc7a738f9135c52066576965c3c1610c3e857cac7555a8ad8684b37dfbcc494f50435c76488699ef8333be2cc4b69d11c2a435751058a57f213702bce02a88c5953e4ab575e8330cd8b01ad81a2c3152cf3e48ac1b23f3c6024f921f7bdd6a3f070ad4474e6abe7ad558dad8c29c23b2bbc8040942fb77b0f57d2e38d9b95e3efb71039a1c3b95aa4c8f58124538f185407325e0e10e3501f6bd6ab895fb537f5cfac2756357337583931364edceb135b4b6ef97dfe7e3c93f9cd6e58fd1d7b722cfb29330a7df0620da7f3d2208449deb99e62c92dab783266b44f8aaf521ce05c69e9af2fff5988f015fa4ac8832e4e269914c9b2cd6054d7d886f74cde65c140184164ead4d526af0da779afbfb45cfe539e8f6c501230fe7db42b4b44792d7ae360ead63772084ed1d49b4e182084453fe2ff5202d0c5605ee02d68bbe611885d9890e33cbae86190ce37a2827801220a171637eae5a9152998cdadb13cea554d4e6f49647a8ded5ba787450b869e69fc77b52f182b4932a8b91bc935e11a4216289aeb976b226846c9f9fb78c6f52b22a2f0248d613859ae0604c25a79b7406d912808c499c2a7f7b6187dc9e26de9817715341e17de722f941fb6d9782e92516e3bda7e675db009bb87ce722cb6a5279617d2daf03b98233e116706da4ab857ca350d40446a94c56d887667e63da83c7862bb199d730e7afa2e2185fefeb69f4286354da8e0c6ac38094c282a7b1c3b6035a34917e6154e45d71e3eeaa26a13706ce1b7d84a258953e17381d78e4c1f8b4bae103ab3a989af661bc1eaa0c91a2ca7ff35bf90fd3df380aebc9204db22d3731e35f1fa753c0a238994b7c879590397f2802e8fe85296c4fb04aad6cdc66245e90decdaaeacbe763aeb22abae53a8725eb286374558d1ed6f5c22f2a51672b1f40b433febe888768d9b585f212e51b820d42c326f0deba153346b999a7b142330576445ef90d39000d0ef1c5ee2f95ad79d92e5dfe2ed6400748718143e754435f23ae4c25cc8ed55493cc9b49215de47becf1b4a6740bf560c7b3f10a160ffe391800be11a4978beeb15d53ae9b7bd4e0857c835b3df654c43b5b07450209120d2366c8e72b42f04b9afcabf23f1f59a71223d6806449688cdd8e56bc4df774721465916726b78c6c62bfe230c6c98a7bd3394fbc7b914a0a2287d963c27a11b1cb36bc31deef3ea99651e2faa01c1c6b59bca2af412bdf76fd0b0501997ddd5e6299c6d31d04d0876d70e98e056eb47747381a7595d89b28450f9c08df8e78a72d23570afd6f2f4b7edc97b015476ade78dce5e3070cf9f23cf74899e4d495f20c0aa3b137d1657a6b207857b69ce015f30a8ca9ee342c3bbac4378efe13c8fdc5fcd6b686dfd474f343604fdbdedc6abf8f745d227f65fd74bc6710bb4ba1bd0d04f0ba51f5748b40d3405b90c47727f02eb2b230ac575e6703d200a04477c5c9b30f81ade11b1d0368a8bbdd31d93965baff4a62e947a73f8e59516bd60596ed87685e0ffd311d2dacbd38677a0a66a6edbf36054489d315d5a346b0db965db37755f81354d75d65c5c53d23fa576e8214c0fe3de7255a289875e109b61743b53a257d414f7509c240cbc8396858816e6aa24d7567cee53d4acfb90ac1d7ddbfecbcd3cbfa1b879c02fbef86d575e05bb9f1a007794f9b158fb1bfd44486e5aa61c2cffab9bd9613a51476f6b81f984e15b01ac2865fc2772749ce31b36e554c471c71b0a41a1996e0f04997f53d9bc453ea5650f49e3d0b1984b3ca318f68f6529e100213b7194a7d703a3a5a4570f8ec1ee17e38205e8504cbb669a5e10450c300bd40e050c9ccd592c4c21860eedae8e5a49ee77e5293974b07524e788d1dacd1767f2945c67b45dee82f391af9d224fa3d7f16cd0fecd751a7b4b534cae5ea76475da3132b7d2ba7e41711a8ce0a679e730919238e54f309f71fb64e869d4ba7ab0868954f3294726c62fe02de5ed7c9f96cec93bd77928b014197aef93a970470d3a3fcd5b9d7a76e818b042fbfd7727119dc53218d1aa36b450a0a56806c3972f15cddbe15cfbcde2fde13ddc99d95b10b30e4d7255ea0af623ba4d78fcbce4a9b0133acaf405f92b69bb23df8316698be0f70a3c87a88f8f0c44e7f9533c8e1f83b43104d6cc536ff15e32016540b691ff91a1b198d4c874f8350e631d19b0147d1f2bb2292fe0cf3ce0160198ec054d1c59489ff8009d2e45afba5d213c2d1227ace431c1a03db84c7850a42487e001d09e8dc2b696f27ca819931c21351b216055f5bbbbfc5bc343a509e53d9d9352922870f7712eddb67ddef132980c1fce8f68aa6a07a954eb97de1381e599fb982f644c2228cc5fe0a4117e96cc26b2ac8ac009f049b1b841c787921835fe98fa147d81d0babcc8205a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
