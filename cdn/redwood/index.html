<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"439b7795d77fad1a41d42b3278591d12714171feeba5278be367df7436bb8bfdd218823f5b3b8fa62f23b930b7541a148e36e2eb37765b859dca7699fed3efe477dffbf0351e6510efbaffe00e28debea99a830c4f7c319462a68e7e8f14076976331a0a270f1ac277861a8e185ced9b5a3fdf1ef3723f523efa918a0674ae1a29f0cd6feca0544e1a4d5e1bbf65eee8e2f07bf8fa8c2a44f039ae18103696e62a4b883a18644f0c70e75206a1c2f5b7b95a9d52e3c159aa9a6dfbc6e4e19020f3e252e46e508ffb3eea7fcd166c5cda4b9142cfa86dd4eaea7acdbd1c8830ead4480fdcbcdae79b32238fc2f54ebc9c9970a2e5ba8cd87106919adaae8d068ec90c1d04dbefe28389d528c7a363a3056e63898f2a5a8dbe893750b6db9e609a065d6c8ca02431c69a8f87925852dd26df299c8db50433146990e75a30128757dfd51aab436b9b772eec54826baf1a3a665ed510e87f92b2f09a21a719c525c97c815b09fce8fdecd2b1852dfaa071eafda8e30e94154f962b0072984ec5d70e15b4edc57eeb781249db7623466558d5ad9db02c504e6492dae0a83629123d5033c07a07356f3fbfc439dde5cf877da851070743336fca5544152e044acd078602c61f41beb0bf0a62a05d4bacf41c46a6f3629c0da3b55620f753fd985465ee559a9d8db15172c4c87d44e4b202e6b45c5398de78eaced75275f2dea3170a3b1c4690059fde41f074bc8d8196279489072123c9791f8e9e5a962159daf6701b0ccfd3c67fbccdc3a0d8456aeaca4ee7d8d0997c29478001c5b49e94306aa5c37e1f49df575936d371d1bf11148dccab6a8d63ee684d7a2632d204d573cd9abde0e0a95bce009cae7ed22307ca6ae547118cf723eada1d07327fd64ddf2087d3c2321d5698c8004530bfb950a97a7982bece570e2b2bd11df597fcfdf102050b4da9a31d7af385089071335355f7825919a92e7789abc5f4618b97ee1d8bd76af57c07175e3d8f862cc8a40dadbab42fdcb55105d6262c56edc1b814951909c702c7a24e791b28f25df9916c17d20f3721f412c4954a0be009c54001e561b3c68245209f8e8e6c34014dcb7e7faffa00a27e964243220beeafe19818f77d4ddea1e95e26e5a97c503a5f6547c2df37527653fa27442d5a6fc0ac740fca7649b470e7661260bdafa12becb9d92ca372a9fe6a6975d341537fd1bbcee94933c3409381180a8f0c7bae15aa68034dc46406444cbf90f0c1c3d6f4bcf0596bee38aaa5868e52d2e2279cc3f0cf6e3669d41c765049d33403ed8f5ae1e0c484e875378af59a7b3ca2eeb321d2f85d0426ef7b0d4278a540a3404914ad2f2c88d23d288d2d7e2992c3a595fffc005527e0c7116f3ee2293b0ec3a561f1dc83acf09b69f2829fe6c36c2c56956ac22c32fdb22e80186fe3ceca945cc7704f729ca0d59122f1ac3804b3f2f056a98f6e77388c14a3e3fda7f50f3f2eb15a78322109f6b8a3965bc6b89feb977ce245424713913ec356e6da806ede060e276f1468ec20ee5690d7684f95dced7408a12be49d191308a08163b98b065636ed600e6897f89df01faa76294a0788bf4b6038ceea064baba06919efa646f91871f0531d6875b6c4ae4b95094e6d826ccf0e9cf525d088fb187c49d1caa252ed522cc43b784a8c881fd277570e54fc4daa6443610089d649985841f9db5b1a71419671d20183983b3726aeb183e870c6b5d5924952c8b0b6fbec2b9bd4d3c3312cd929f1d579f99cf382dee49a94f623ea1967fbd9e1ddd61883d14e64d332a0494f0eedd257127bf122baa5eac5b24b5d25c98dafcd70ccf789cc92034f527c5a843589cbd4adb1bbc7b7c16cb0e90652f02fece6f46ca3033f304a86dcf0897e72978943a09c82c0868a90843cf1bc3482eb385d210748eec61f41a4df6016e8c6c223b8d68ecf4f7437b7b59e70f1e7a4ad19179ffb6bf3692561640ba463ef4d6a9a912f11c7f613dabd922368ed988f1f7251623fdfbe57dd44ce70a83c0b2a7fab4678cf68888d0e02b26c5c6b0505a17d22559c08e9c59b049c1bd3b7125b21bc7ec5fc84a982778e65d73cc9c4ffbe71f3b234dd24073308f2d0e1b718a9303a25f9c187f5b363d508b96f0a0dd51492b32031ce5e985dfc750f95a8d17e175720c46ea45701cde5fd84c4c45fb4d85c7da8ad8ffc64d56b1e3fb73510b226c13dfec42ebadd18b25e289cd2e0b45907b4a1eabc352ede0e21f6954181360619dc6f7f7dc7521866c0802b441beb1c9dad7046a3c46cbcf176582d31448834f7254d965cd18661f9ac121b6ab9f5cf838c86446d7bab8dc8b57b33efe828271f726c3cd5294e788d3979f9c65d478cb301c842a93ff7ca39757e9529fe3200f1a867f19beee1a77178b0498bb4e504c71987975d7177e411fc0a755cf6c90c8f7432632028118fb5e40f3213534f45894df992c0d85d2c30361ab283de54b246a21a0b8bf1e43875d5e54aa242277a1c953a6d1f10cd99396e91ce86106058750bc3b7d1454f1473863bd6a3281e1b7f8c221db864282f665e67ef1d9ca202ed10f30c92eac1afff0207d36d98ec2e537330a491c0d991c26a88e13a52f6d9d9149257688a8bdfb967ed96be04a0d455b57569f83326df8bd54e702943f3dbda2ab04bdefc5c432594b397adbe0827403a06bd360c831208094dc58e0d0ee4dafa7e90d2b42addd9b45876bcc5fe853c223b9b4c9131103dd198c40ed622fb7da88342d136288bf56fbaac1b1beb9b8e9686ad8fdc6c99e2b8abfc26931605efb980d2159166ff03a4faa43caa8ff367bad3e32a49990d888d4d3269b5c16469f61b6cd2f5ac47c15399151b6e4b22809773907bb68700dac8dca64e8e0132471db7a69c0ae7960ca8712d3f827c28cad11b11a2e85b9fa6eaea2ed206a7f178edc0df041692be9afd4eb7ca1b151a6201d6b2bb50a8ae2f281330d69d1c06e1e05a02875e9399d02d73a757e82568086e80f9761eafad6bed45540fe2714f19cdff854a846db11a1ef0be35205bb695ebb89505fbb4ae745b175f8d9a139979503fccf698a374f7b3d0bf50cf6441d3940ac09c13cc9f3fd2961787e2e36a7df7b895b759a3d8a85dddb38e82051393df5ce7b1144124049253c45aff758510357f050e25f4799c557f96c0bce305af30f261988eec86e941ecdf15992f7eb2c471f44918755c0b20d7490f69401a711fcdf38573573138bd64f2af2be316daf01669383afc3f9b46bff16446adf283e607c90ef1bf90c5ebc8a6c7be5d8fda46f1a877239a749b67dc9ed53d5d34cb7c21bc6d2606bd73d34761e115dc124ea2a8a76a5012e2e02101abcf15066c9467bd8a0f5db3b359427e9309c9c50c5d977d31903ce0f4cbf99701a5daebaecc78a037ffc3f00ab958acf60b4d280fcbaebe4025d8b7282cceffb59e55641dbfd98db6ab7ba537a25e86efb9bd59e9ff7bf8a6d6a1cd3c3020105a5122a7b3960d2de581890fdf408d7201a405b9413b207e0fd1189390a42c746e78b7c1722e3cc6a53c9a5e3fec3099ebcfb68722118e611e99405194d1641f27b0960417055927f9138b2e225b80aef603ed2d7726b08dd712bf3589fcc94168e0c7e030dfe2dce01ea2f995e0ac37426b058871f2f9eb4e5c53a2257067b62ab4c9491030022afd2a508ab9dcce23b2f1c4c05fe970487b5035e3959597cfb18a8d928b83ea43769059107df0aad2e2b795e9ebb56e79ad637f203af8fd8eb5fc31c1c6536535a8118b36e29aaff8cce18cefa777301ee3732bb12c77c1d9f71c205ad32ffafce19bb7dc6bf8b3cf5df303db2fe0b592417bcabc91a85cb641b9b2da9e42d079db34be498de94e3b45040b511619f7f83ad3eec283028c0a30e5e29ffac09c142585f123e53e23c005177574f191b6bcbd76fb31aa5e49387bfd01e61c3b285bdd285c8db90aefca2432c180dccb629aedfd4df7bc911dccbdfe398a8ce1296a5c5f599f2da7ea5f7ccf48d4b713c857b4c373d202de4e37f09ac3d1b6157cc5323627ce3c6133f66eaf5cf58b8fa5305fad125df6f2c9295a9b4a75110224b1be2fc17fce7eafe109b65a1796a6b9712df86e88eae569d26c09ff9f36d4cffcad6b75713c745af4cab1d29e30bb42d9a34d321cf2f064eff7385f4a384f410696290a702dba30215a4f079489990abfa3ca6e6f5a60c42ccd3d60d67b2568325531fb5fc1ee92a4b1311fc8cc41ff6fea97458ec0236ba585dc9d5cb28c82b608c3c789eda96e147d3bb45e7efc619a74acb4c7b2343cf0352b61a6bec15ee6b2292f749bd00c1425e2210775fa824e84cad82f9c15eec8a9d045ddba2db4df47c6b02e255a957b0e4e651b1ec83e600fb11eed625927abf9d0d78e3aba4e93a58d822fe07ddb6ec9ae24ed5796c1bb14ac54ba4d88e9c4747e7f52ebc5cfb6b7cfe5fb9a034ee11f12641693009468e3ca176f03476897a9b617f3ea99a1ecf498a79964e8842c95ce2bc839121810602dee32193c6de287fa9b3298595e6c3ff31fd6aef4238c414768566e9558959acd5508758bfd007c445c2ccdef50d8d309c1df68a1d18c349aa1022f6fb587935d5171cde2a83320ddb1fe55ae7556dda26d08f20d3957cf7c7942c581bcdc983af37928be13eda9deef7b8f9ec786075ff3d2717b9007d5d5295e94c1f9be02c32da42000ab272643729acba0288d5a79a8b2533a26857ccfc2781af9ce667891cca4ee66e12b3f47b584ca178500f258564cedf4c2048113af4df0abdbedcfbff9a006e5c9674391f0afed773d2850e95346cdee2fbf6c1d4147920248f350ac3c576c166fe301ee54f1b5808b7a54ef0c365840cd2756a0d900756f05ecad440b6516141858e1de86771af201dbdebf7a6394032e0e68205a13950fdad0cbcd87175bffe38a476f1d357cf0d10c3238e0743b528d6f9a9fad0ab39334c35257cb4e41ff8be3dc206b08c0d255d8e0e250d0bbb95c8042afbc7ff7e58aa6911a23d2be241effc073f2d06d6072daf5ab8ffbe2e7eb5f0106ce321a11c3fc927d90e9f49cff85a7457d72cbb923f6bc0c3e0af2581370b5007943f8da8fd4b179dbd53a21d85d421752cd7e1cef73bb88f06a1b04100450c9e6dd732a8dc2844ea34dc33759331dce03514b4284153bfc202b922c4a28a75a3cfad0b0865439a6416706716b21572845e946c3a9c951900183d38306d09e225aab90ace09fcefb7be6d9912c59b231c575c755e25dc5925c95facce597a7555a0f3ca21ac1607a0177c49cfb075fb4e4d97ad5aeb7c4af2c42f6ed3c05f51985bde4655e2d5e617dc6f8958762cbd1a30ce995bb3093445439b56ccc452d13521196668ff16afda6d010efb3f730d270b47707288a9f87c421076dddd89cd1255432da5444ead9aea82d25316d162462ba78825213151d436f45b1425725f5eea2fc4f534d8147263a7e1630633b4eaf5c3d08a0b191ac208fa6e0c45d58c6203c67a8354a87f8a7fe952d9c32641fcbfb94e8558f10856268e11b903aff1fdc7d21efdd06bb9bf3d9f27b3321bc5f4837ccbb24e32863e1926a120b62ae579198ace79e394ea2ccac6c7ef3a29434275a0d2bf36c8816959ad03e661277bf390d65f2ceedddbd1929b35aa67c38ebdecff3f3e1c8d8ad33dbd64b4c64f0ac569bd3f138a9eda6791f71ada9348e493a0d43dbd54912d5805add236b5e43cd72b2dbdc56bf352069199db7b63c9e784bbbafe94dfc83435f44069e38f1aa756af0fe02234e096ffb18acec2564e70865eb5a6f92243258c0ba053b9fd6978ba1401116791cb710c59f5df82a916f3caaeb80fe343cc106b86b418241d509ecdeb51d10017677cc7f4c10853d3508ace7417be9ca40c37e025803a91008f63aa1e365563e153ded32a9a805d3c1ce43cbeca5416af1adccbcedbd490e100ff4084202dbf38fe007b4eca826167ccc20aa214279027c81b830218fbb2d27d88831b85c464c73117db48d836451ed46976f8fa766a1719ed06496b3b2f555036be246b79d60b7446854ed274c1ed71e95df6bfed915e1586e278dc54a01b429907899385880599a2e591d83b584b8c0c54f15417227ecf5bcfcd991679e03e031ba2ec8005654f526559fd0791dae28bd9a105e7f5a93da1b323b23ce401e1de72080086302c0d07617a990e5b21b03d14fceb0c953d249ca962326b4f0c728d8f2a72cef7b496f7371795f1efb345f0423c8e696b0f9b0537c16bd54dd67fb980a06ad56a3eafad86f440ce0835f2c1b2e0f3b71afbf6c48e03daab791375e1449c363fbe3a6c2966fb938df96f01281ff8e8818b486458e081a71c1f6de047e7dcc13a6cf555cfab8e107289225b62ba75e3215d032dd73941379b558da402e207b4948cdc8c48eaca03a35621bfe06be963c075da0125c272ac96ee79ed91b63788819cc12935adbe710e6d97f88cbef3ac5a9f51394ba72cc7b5784e12808c1a5c1bfcaa2774e6a62d1d1166d79b2214a92d3822f2e1ef174e2b606f197a8896dfb69bca60a8d8b8b3b25e0d767d374260d997c89fb77f8c014fdeb6a0df5da847ba88f381511b948630f9986a19ee290d2589e0d120e756dc2ff0ffd1b49c4d070e922ca8b8dd42c3a719b4be8f63d95c86b164157bde3af168091135fe6696cb8577b3c79ad5fb3d508d147a6971d3d5589f6e4525d9341ceb0fe0e298526826541b1219c4884e0285162e26b3952cac6391a0ab279c8d14d99a9de23752fdeb42242c46b2f6b4adc76d6f39b1e19a1997b65efc7660dda1e91a047ec967e8afdb7f8a6e560d0331dddf1383e7ecb5659661a06cab4d77d63de2138efce1217d0812f0648c9c0dfa14c5871273474212778d5474a3cd847e136b635f0d745c09a582ab44696f78b2c7ad914a7aaa8dba056ccdb48b647256098a8980e0dc24723ccaa22d60b3e134fe6e6b2b810dac6aa437664a9595ce53b641448a61021aff8df598dd7f8f2a75c7a23a257d15993541c3b34b0df4f194b136332936c74ed573a6e3878a7dfd67ade337c8ed34842b0571fc1e45817517458c1fbeb93e3aa3d2008e434e8a2eeb6368774bf2f9e8ed73cfba1937675ed3a608ba1fc9986c568aa17ac65a2d17f195f23c5935f4e5e3fce877a8e5bcf7646f6d8273df68f16bbb4e27e5d2cdbc20b1fb22811393c5a851f7e71aa798942557f5fdbf84bc7bff3e1fbe4f5e161d5360b5bb1e88c5ff7418ac0e221c511e9886b1474a4530d114a9658669b5383aa8f42d196a8b700d6a1aafc5230d8b2be9ff7d0e39809def9063b55569dd10af2d24ff140cef81f704267fed534b2725e4922c52f82882c75a2dc3e1824be38b45a569135476ad31826681a79f609394c7c20645c0d1422943a17fd5a49c1a4f73934c9b39eb53ca9634beb60c2f49c586962bb3004777e66427a614695ac8241eba68fe98a777db3a4315d3fdb6be42213d25f26e64c8efdd75703ff90f0733e630480cdf54e70fe22f969c57c0e13310d2727e21db6e83c10c47fa8a2ea45ef2ee51827b0bf99863f2d1b784dfae75cfdf40a52443ed348561834696f8898a8a9f18dc1ca72bad9b4665dda20e6b8068593bcd3f04d2f84153b59a702dd6ddc21ceba31a187b4d7b69d7c4aaccc6bd8e30d2b12beab4d6a5e6b35d46db6b0f22b4985895f03ac4ed9be3cef116db10d215691f98b0903382f1a07f740044ded8b97f9b9fdeb3e07233d9073d2261d7302e2970fb912f63da889122ba31acafd17a67aa7dff13e9c0a81fb89342669ebaa04ff57ff63e75b666953c598da508eb2b30b6e100695b2d1fcbdeecf7adec933ab7700615feabd06bd7977002ae92c3491595c0fdc3b3f50eb06d15c4cd865a19ef96c6de7889c8e848ff759663d7fddee03b27efdbf272c38fb0dee900c957ea650eae7958596568d67ee9c0c42c48c2b28810ff9175a360d90d48116be37b2d51e74fef1e1fe75aae90b2957d51d9f59b81665e5ac027e354f6a4ed7529d0a0114d4214aca511cc4519ccb2f864f0b0417b0704ac49e8cd8282c6df9dc751001aad34fa970005c602b7de7db30117d8f016cb6f8a91395a1bd76cc726229b20963eb218886949c101c70cf630faf690b906c9fdbf22cb4c6931e10f8558a0f75ae58437b45469f4ca6a566a479de2d047154df5ef1e18e84c0a4fede26a500154e71b1200c77e81c6337fe756b3609d53ce438b2a21eef2053cf9cfb111d998018f02e0692500459977d9312bb147885fa77ffeef996a26eef5e6b351227080967d3f045d6018285a932dbcfcbf80b296693229899cb967f02d61c47af111837572cf0068a46de6c8b1bc6f898813983eddd5d63c42c41d6bd1a1afcfdca98c34a354561d5a569cc32fa88e2c48b207b4a98a16285df9ecbf3cec47ac57934911fe8ee2f751694b6561a1dc1e382890881e253c89a16f5c3ff18192a776d0911f8406da455d1079bdc33ecf284982020149c41cb6bbf650e1f9f431bfe0fadea1d4ae918300efaad60d1d018f4a08b9e694e2deb8a423f1f79026a14448e2bc2013dc09799bfd390f965f01c75fb6379163e8a7242749c5f437da41c537e13097e80543b0c6f6d66c31a8f7cf46ed34a4b97fda18b9500c08d65f8a27e3785084549754a485e71e4d636de6f036671b17cbb3b9ad64b9d2fa488a101a6f004580134f1ebf5344d5abcaec905254acf8617e9a399127faea2b83097218dd1124d3785c903ddf4816d352a34d3c8a31f94b44675036c5c02f69f9d2351ae827354365afb6ac24060d766a3726b8d725413c763ff4cd600f0d6d51def8595211bb02afc979aa61c294483812813f2c5d50be5b69f4f6f583e367c3d577d853b8c73e2348a22c308362870a9751b6532c966ccb165321e63c863e2ca759ca721a32cfe1a81a352b24297d94115753c05321a29b09cb9975b219d8d3d6069c5a2d814354226926ad7dde351f8284cf012b129228329710f4b7a75fe7892b1a32a473744e21cfb07aa86aa052c3891b7a3d69dae600a5bdb9ace0f4d37986f23d9d95805f85e03bc4cc772b9e64aeba994c671994b80c4199e4b2d794b6cb65ebd9368e488fca5954211b35a311d3909fc0d893f35656fdcaa4f3dd3ecd5c5a53f4038645a60cd4f650403a199230c3f2919d9672ea8d9b83db39d693df90f47e2f571ef881f571e595e123aa51eb80dd5c59a6834846091d61ae4a3272d9dbd598df38ef10a9deb5a91ece8c2458e373c487d631c9786e4056dbe36583288d2876610eb19b5ffc0f833469080f1da29d86eec289beeaf3af7e1b08948c08c277ebb38824bfc3efe2b61189314e36f7a0ca10c425e60b99d4361413ee6f9eaa38a291140c49e5b273226f03210c5578b436f1c2c296c5f66b85b6bdf38010cdd28fce701826c30949db314aa957ea0abed179ff949bc5021c9b742d5c792b16d26d521a60d3cd9a87f3378e78bbe37a0885b1dd28847e52edbdae8dd186cefde9b08898b6028bef97851ac33a47cf3997d70e26636717fcdeae38c48a17834e2e3e711fc5a2c0d73560f9d1bc8ae04877b4ebc980e88cd863d08372f009628f3d48bc43d98a85b070066293ecd2597450099e1ec065bfd58e3d9ca789f4ec8548f8555bcfcea5ccb06a38d8fcec40058f5500124acd616f318aac88af98ad0095a39037494db41e1986ffddb4aba7c0b858091d172614a0f746a47250f76b3b960b5f2f226f8c7a50fbc049bad113478b9b2c81da409373190b0e84b53edc6cb21b510ec83ee00f73f8c53bbe7df16f64a5dd4b79d8bf382f1f6bc1822cb4252cb99053f9316a919af71e9942175a1e57bcd24a9ed916e266b9d09831c8ce8a6e8b028e4e700e798c83ccb4d9ea92d4a3301776136a03eee4db86ff921ad918f35cade9bac3b4f788d771e912e558fc979ab543d6ec44434156e5ce3f036d182ef71d08d115c532131d0b6caa64d39578535f355e289eabaf63e057564e3ae1bcb405dca781f68558d9815e9907c9696141cb620be892225d80c7e195ea3c240a87409d17f59ea941fca7c777a2d38c3a5d29e854121889958c3aa1d36bce65bd53e0bc6a570cabdf4786f74f1adf5b74fefc8f7ed156b2b611163432cc57120499086c32e40bd92f7d17044ba77912c06a9c3f2d4351793059715dd1a922b9883723d5904283f43fc6df32951a40b96d54c05e10c536f6756f29707fa64982d1a7d18f5578c44e70b05260a098edb24003b4c1d8bf6c9052ac21a314998e3548cd81561538f34b4dd2ce00e0dfc1b7bd0966f5dc9aa6e1fa175a85111c44413cb9ffc6a0290ffbdb849203d26622efc0888195e5c8c0b251398512b13fb3a55501530570c026bd664e98da9075ff0f84063913a0bc8018a10946bbd0a775434f502979d773f0bd073285766346d9b270cb98c15ffb76f3cae8ec357fd6120f8887e6f8154bd6990efc7845ec337f049bbdb901c33004f048ff3aa35eb70008fc6446311be4d7ae3eb55416862b95f5bf45997363cf8e9c7ea2b9927ea8436801089d47641a2b8b99d4322cde4fb8687ced66494ba45cbed0cf7aba8c15e4d44568c6b4f08cb7e78fedab3253fab779754aa0ae5b113cef45f8a7849e4a1f55e077aec7ec97394c892f68627c51e7172991ccaed4826210054013043c851d3f632e8609665b0f90c29bf075d7e53a2512219b6782e4eaf65f36416cd2c0c263416ac56dd94a256e56339ffcade64311d52a8c0fd5129b39e473547e6bc1bb4a05f527ff5f2f4dccfbd6fb2a5f09009e2684e9b15cfdefd37ebe3420e6fbda9aa77947f8206cd8e40ff68a878994f585a0d1bfdab7aca0514a9550ca5fdeb560f0bedd62ea26457a1fe85ba80a6e71b313d45f3a663cd065c827920d7bf7e55fe849af0d8c4a2d742dec7c5718a98940830c7e69e0c6a28b5c3dd0f67ac360f5489c3b00d56f9fd74a41ff400839478d41ceef596be312282c637db2393453a93e6df7d698ebb1506b8afdb1ad89bfc448644e7b0f7ca9c2736d8aa5e51d20b57b0c47fcf5d2cb12b96e44c8757bfd8ee8d7dbd8cf375a8ee637977229c6011a088e450da9a6a13d0c59e896e94ec0a46b7b656498f301e29fcfe3e8d219dccf8102d65aa16e1273cfd32985bd7a9b2b91ab63f71c7691781199b1d129929a44c2264db1ca38449ac91253f007589f178685ef9fd60fc8df5c52cf8e856b81c3850d9b38b96499a424c692645b87b8e1ebee36bb959d21385be80b7a84c4267561abf82bd9030b1dcfb7d86d8d073c3e6d0e5c68b8752ef0b269ecac810eb1c54b9351d78127e81e76375098127b36bb96c569a52458c1fc1ef2f5a606351f16d4ae3fed3f79a477658c5648a9917ff43b55c1dcf3e55a791d8eb932cda02a71ebde4237abd34967ae1b194c893acd7f4ac889466aec467eb64943a3665c61f7db258a527fe0f774911d7dee56bdad4deef25d4a4473a77c4376b35e58a0574b001d9300269a7c0e7402afb4a8eaac62a35b5dcddce24d12de48a5536bb1b3a69c55ed4d8aeb82dd38a7782c28924099eb38d07fe7b6555b36bfba23ec9a740ff0c9bff14c54d3fcaef6b73abef255d656c4d2898d54dd4d2a53050c5e8284e65b86cde8266c03eea19e450b84c0a7d9bdc7529f0c3bb6b7ef59efce6854e4b07ba85bba41a4b82dbe8c0d81ddfd0553d41f48083385b23d1ceba064d3baadb8031586b87b4a273c9f141be9083736e3fab1bd2279d7da05135630d1ff618ca58e790a77726de80590aef66355ba7d03ca8d2effa9951090a22b6d6e3a07d3f5c0a6f3271f52bfe3e64aa93c40f35eb944624e1bc1e8b1a97677a4424cefcaaeac5b5d28c85498ae8d46b101f85493bea725f7b8d0e570d2cf0d3d7a286796a16d8cccb005e0d58723fbcbecf56b8dbfa9e0ea6144bdd60bd3d8987ff6582c02bb467c777eee5f601e7a7281ad68fb954bd6a2a2db0673116f01338ad337fd62565dd6f27c3b02f0f514dc5e5e4e9ec6179d6f285e53a348c5ed2780ec4f06210e51a2945f7e41c7ba7e5bb96f40d2c2727bcb2dcbd853091dd01ac3d6ec34786dc7a87ff8df6255b255713cb48f93f7fbede6d087b2634ca5f0128c09e279bb33584435f6a86abc0e396c9b4f2ba4c0a7c8e5a5568ff9324437d0f37bfa304c1b19be527d15fd99fa9e50ab8357283113e13462a3aec107b5c416b4b2bc4f6ea9aea3755b4f62178f5e325ae8bba99c9cd83e3cbd3e1bd755d968be4d09be3d6bfed3686175d338b6f21a9d3ae138ed165a6874a99cf9d552fcac6c7a1534d87bf6d313855f33d086cf04fcff5c0aa2664b2b2ddc24e4255760b9c199b134a7104357fb0fd0a7f0d735ed867583a3abce7166b7e0586b5db99fa5c5a34137cc01ba37b83519d6fb1091406f07839bd3086becd6fa68806b5d7dee40dcab23824bcb92004f034cd9b399381ae8a53963c2c6197c404e6470b2f49ed30bea4084cea70e8c6daf566759109d03fd8111d6dee4c562e6692717f01f66bb4c6a7a618cfddff0ebce5375134f8be0c8556d84e4febc90b823560a74f34396b6c55fb32656ad0b08215f505dc7240541499cc8dd1b64b673cbf7d3f31c05d4500135a56a362c6fbd0727cb5c171392786e65365d41350ee592894c0c2f6b8e59ccc0b2e6331034e5763c116920ae4eef4d62818dc8615ad56439eb9a8f5eedd0bf444d3b21c62b555b9adb400711b4992e931eca361394f47685d91f9bce666307cdd10d072b3c4f23497fb5598bd19e5e530525e0c55215d55fda774d5e9a5a93f69eb85d426ae8b955b7a058bc97634aa602b11e9967d293eafd6558b975b7b53a616468b2df842be696b65a53e8c8eb795415a9b2461284fdf24f5fc97ee267271c3189305123832b9980e41ff76608e8ed159d3d2df874dc365aed8619d5c3affd1038c4c6d5bd7d92328bb052817839a584e369d839c09979de542d1bc784cf4f0ed84bd663825b12868a503c439720a7f31cba173f79c755346f448eddf657dc10348e5e12faa8239c9da3acbce4dc26e6561888a9353316a518a288014240e90c0d5fccb8f9d22b631111c36c0984e10f5a59fe9e2c37837ab03461c6e980fc2f0961758d0fe46755dbe5f95c0b31a48ce9977049d5c53408498ebfaee0ca6133ac6f3434fc3c47ad1b4ec1a268d4b87d2731873f66171b762708a61d8d194750bbff0fe9c3c0cbc3fd5ccfc5401cb8ab764b390027d1f12c35e273af06407dcff50d3f2ad366de74b49e05d64f7e09f1596daf94ee5849fc4bbd3508c41ea186d0f568bf9af77ad3930ab8099752976f77dd162f367754a8220218949d87ad5828948b92459cd1d4ca96a6f8e2a1617a96c7d7ab88a4412a058da833a27afbc98ee24044e7b997c0df439466f44564a06fb94c65e7cec337c6acee302a95dc6a4447f3881d87f7dcddf27a4b8a96b97667a2152a65ca207869802e4840fd0260d6fd79aecd366967c7416c575a46900a21f9c0f90cbe7c8374cd4102a5581782f7e592dab1f8ca3aeee5d73c1a7d60ccab2cc82310021387d82e095544a43e66c262e9f65d50c29a2d2254634234fa643c622a3abda8c85171a4c63aaac5c192b47a4dfa3b665e1158c5ab9c0703212d39ca37caf5a6f2a2710fbbe79db91718f5176a769af1b0221ad5ae60c7b4b584caa376d74d5b7d267ff0e93b7f88c80bad44627aa2f2a3338b34327db6d7c8efed5c16a398ca2d88d53c00b95063376612e7e4c870f5a62f4cd86e0f396467b8175d7efdf26f03547da968eda1a237b3d2de045a273d59fdbee68e26482a8681dd728f5d3bc53997fb0b3ba73e337e3229acb64766d12f746f24142cac64f851bdef9d8a56dc6872b56d83f345bcfeb5226c68d389661e4899461692c82afd9e63559f9e42a13e0071f40fd11a4acb9e052f43e9f7cb98b665ade9cbe00dd83d85392f35b82a2c71aa56d18e786a08416121074469f023a91139c74f465874e447a0e0affbba8f4962356da7752150bfa547e7bd23e7edb740980f2e32f6d2e31b56c27d1f8e4cfec00f39e69d5b83b1e09689fb021a8c7235eea1efc4babe6695ab927ace2afc33343ebc47a0ed9ae072a458c4804286d20c273892779ca62cf1b36a92f6df6e5a01ab1d2075e001f34a4cb04ba60fdf1385828d033d4e5fd94ad8208a059ea17f36549320c17e8bf01ea77f986b74f2281fcf4bde08234440b67f05d33ab9f273c873fbb2a4e56de9c6bfb1fd06dc8b99c01679302cb7edc3b1e83dc14d97d38f6f28a30c38f1c185e1711e2056b1b72c22daab002f80700c69a9ecdf05711a7b0264af93016bcf4a650838417fb9f1af0f30075cfc1838f57d473cc1f95436572d9ae49d96b026decafa8dd8bf257ae24a6690ce1e2cd58d1dc9936afeba73fa78a9b58f2f75e4713d578fa3c4ebf3ce71ccb2dade8947f53317f65b7e070fc5502f4a02cbd9aacb4250c6c1b58184c8117b0e406f9f9142a4f5961d269748c9af3f98196cd37d04470f1a59dfad1d26b8ca75d434881e8742bbab89d71b8bc0273ad89632cce9c1b4f764f98caf9f33cced97a4f0ecd423bef7e5a80c86da2323dc88a9e4bf764e145b616e94389bec4e2b549307c1690d67eb6b48f57fff13af95f689dbe72028134c4b64cac80dd27841834480925d5018ec1e3b5709f8c27979ae6cb98bec174eae52d2659c33a941ae60cddc9b4ed9d5cb07c61d6053ed1c4e0019fa9dcf704134b275b5c9213461b2cc4677134b43922775bef6aad240ee5176af607dcdcb2480f18c10840bb76f4623aeac3161db04846d2c6abc74c4725e93ebbb39137e1390e489ad821a7ffc1ca4c51267803fc1caa002667aa80ab798e779369e837094cc16742f58dacbbb692f06ec7562f34644c3e82d84143fe74a03fda162f7f6f0ae2d688fae520a318f276af22fc0cae47058fa2a292ea779159d2329f9ddfe160491e639af57b49145819de89aa56bf3cb587898285cdeee25a3bf63d45005e5da1a5caaaad9d0b3cfc3a1a57484d9e83f425c3295727ece87ce09c72ba31657766db86a782674111f5da1a76","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
