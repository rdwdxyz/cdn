<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5ac0a0b9161481bfa5f2e5d3fec4481f3047be436360f4d9d6aed00a473d6128f57b59ca8c7cefa52993e69ed760d20910979ba7c7dd2cd7b68658be72561f2530f6b47e5c298fa8a6a664c4b5f3fd7755987fc9d1b6c60ed07ee7b64ad2629f37bc8a27b476dc4a1737d1bdf1c4ee7812a391ea85d9863bfca348115b7944680a1ef718428a92ea74f4e67d0adf7535ccd951659564987fdf4aac88f0e3071127ca5d6d303542fd11f54f410c491600513564a97edc4c5838a924dd41e849610a7f95cf2634dd26a4ca14b31df0ea263e84b139fab628cc5c9847ecf65fcd2624d2175869399ae7035cea10628e821a5b04d9b2071d7256134198afd04e6267051a2ee3f5ff8c0fce29c224cb24dcde27c11435e104674ae00b3c393d89691b2eca88ad473dbad6201a72a9ccc508162cf1ba77f1d8f9961e9b049381dc096b6eefe4ab2dd9dddfc189183396cabb4e54da4b9e8710bf8e14507f248336e0b75ab10ab31ca31fc9040ccc8253dc5206ff0fb0f568c37d8e78616997848cea3be2f9ffc8ee23aa3f5613146d0392cf91aa366f2fe49ca6b12a1c3d004f970d28bb0054080ecf4dede4c7481cd575ccc34bc7aa90009c77f5905038cf280d64777fa56c37159b12982ab94b8f0d7d515484e9a92c6110fa00a1b4a891ebc07064d2ec128731ece281b218e09c3ed383c8dedf667dc110da759bc35834f22b784c769f99fb9f3992e4a8840b59252d1daecab5fffb26dc38d442ce88f5ebe398fc8fa6ce52f02d62fe6d278e1b85729e8b67f42324d49e3fd35b03a4618b065ea1be90bf1e6cbd8614aba763e628ffed8a311b4b0c7174b2de6870b15a012dad9333e09e6bb35916adfd8893c48239a6e21ce31490b3dc7104e388fab91e79cb1206778df87a060b815348985fe84f23c986e3201cf0ad9f2af357b0c295ae9c3ba611835313c25a799737de75ae41fc7f453e4ea943d664d58cb868e826e8401240dc33bf7c16c51fd3eea9ccb24b2361492e72b0cf59e2077b94b874ee15d6e33933f8c132e97dc5696c7692012bbffed2a1ba9b9ec8c4f947d4c6807bb5c281ef7d6da0d684e593441f4bcf601db38bd67152c31d93e87dacdc2ef3c0dd3560b32c54f412b35a7a74b58f9d4ed75114444032fd84440fada773a9c7e32b8ebc14a9d2fe0c08a1f120d0160f9706f3aa882f4b245fd239f337ad63c76f91bddf3ff0394461023055748e1edff4a531e2bc1d46ba08eab1fdd68eb7b962f9d47e8a9c484e8de87c93e2c70eab3826556814c018980c492880d45545852a943989497f11bd91d563cf087dfaa35e5aec7416b5245edc48eaa61583bd2c56402670cfd5fbf128106ddfe64c87c1fb9005c1897538c9e68d78a33ead14125fceb4358c3007692644318127ac47809bfd65d68dc20d07d16c4eef6668537a81e7ea8fe054c3f1c9917a4c89dd60c9f57d0f5fbf488213e67d7a9130af99adb6d44b1331bef50fc747169c9654b1ad165138d60bcc55ecebf477b483a19c4580f3bd00fce01a450bfb91d809c7c986a8a1d9cc294d20ec499a4a738b889e9c7675adaf4e736b3297ce3ce7d1ad70ee28178f615560102d8c651c19ff2d2483fc56d1291dfad2b734c1ec6073c468f60d2012d03a64fb37f79d1b6943a792e10ea7dddf6ecb65c9d49079dfd2adcb03ed76833629f0855b8ad3228b5d87b6d9f2835ccbffa628eee041bb251b558d407f554d1fee030a194d3498200b8fd6ebad83c8b51a8290253c5f562f9a074a38e698acfdc977bb1d7fdb4d39d267bd05ec972360b71624b10a6147c96734342dbd3590985a495363903d2b46d2c64925de4e53ed7c90af31649905a34e0d5c09af9b128799e915743e090ea9c4d95636800ee7ce5ee7d94f82c6b68634eb6e5d7b521d8773d78154f12f6b02c756bf24cda1975dd23a6f956dfe2bc12d0114addc3d24746e0b94b5a1a987c99a8f82bffcc4bee35e4010b9b69dba2a534f454704949be50d86f5f97b5dcc73eba76a57555ec4321f68ce1990ede21f3091f2b98ede4cb782e322afaf104a8ff9d754b2876630d33ce657c0faf503829aa179a1685361b2f2c88bf0e587315cc91482497f7f1dd70966705c470fa433fae7c304608a8953d22fd6514484a5ef88b656c58909956fffb4396ff5b6948736b81b6b70205557a530687493236741ef0813432fd0028eaef8aed009feab518b92121fe46c7188c0f9759850b60c82a3eda03e0a1176cd51a2ef77ee1202b7eb704243d074ef9c7d5251a382c643872bfce1bd553eb0b31c9c8ecc30e0070d3b0edf36402f9e5747c47e12397362d470a575ae2a7723c9df3582ed28e6b3219c61af4654f356552f3d4a05ca9e1c7825f9a8d0a5bcdd0ce52a43d565390c12161515349bc47cca525ab61f4d99747edc796b1902b1e9c09422c2896345062ca235e1792c6ab7a1d2eca4b075a0b00ee3b022b7222a2ee862402103e86ddb87af1b899c7fbee8ad7053182c60bf0b4e57766e4127797fff1a8f96d21f8a61968b3fa27f2dd30cf21ac429961e88ab3bfaaf57b78dd8789b262e5a766c6906a1163160a1f557c2cb6ae4a639fa80ad809d13cc9cca5e9f5c327ebe8b0bf38fa296f8b07d0306911ff6d602b1687786078ac9848b6b5f6c45f29b47eae463893b8a16a782b684caa5a679336e343237216941a2a4e4cddaa0fbd2b3fa855b1c32f97d233edc61e1a90aa6b2ed8d39e65a1b4c771d90e025bb85d51e5b66355367b3c928a29c79aee208e7eb0ec2894525b82dca36a57d1b9c37ae1b05be1696cb7603c572e88431aebbad5bbffedd9cc698127abf04958833f1ca83c43095b484999d14ab7d50598f55b6e4ba58be5ed5894214d3813ccbbd9f84f6792447a5aa9c0a64a103773b39716dd0a8200f057ee149d0e32bb3bc6e35d3bce3a4c049194531b65a9e83b5a9fb4feed3cc704c82dab6f341424e71b30df2200ecfe629cdbc9c4a910847151ebea0a072bb6f364f4f0e2ddcfe3dfb82c28f43a09024071b38e8071bfcb8c731d05b55727c346c0c4635785a666e26648bb52413f7edbfefa88d673eafae735759a68dd148b8c2baaa33ba4fda787fb38d7b8c4702ba8ed5459c560dfcb4f559ce609072d9863bca8507a9ed3c1fa6e16e4a933e3a8e7795d24da15cfe931e6d7f7afb4b61231694390df67df8db65b343ebc635fa12102da1e2ee5376a587f2df750a365126da9934d464957baea157ac1e73e3b0d6aa883d1cce86b40a4158d89f8babb2220cc1c19b44e1294d649a749cfc2f3eeba178fa219a9286107e3a275cbe854babed12ffa6c724ba6eaad31eef1b30710c13ad831f3287966360e57a2ae4cf98c94163a02778d93d77f23aade5498acd960ab49d94ee59f41c38ac9719cfd52fead37ca30d5c023a26870159d4cd143bee28f8151057a951e1f00b842767ef1c42bb0bb2a759873ff91c2cd6098246cdf69a55c1f79eb6f4d3e413a67a595a8c1de915ac26cbecb83a3f2c150664fb02af4de9112deeef3e8139b65a5b9824304975be028c1988abd7bd0cdf3c58bff0c60e8a4e411cf6933367f37f5b2001afd0d094ef58c2adaccfe330a74a1cc1e7f5af9ef64c3e4d20b03ecb80a05b591f9ecebad8a70d48d09dc37df4935867c58e29bd5bcbfdd5eb7b8ce1aa97b2edc035adf2a14b4ecb9390b00de5499d6443bf8a376f8e87bc18724d9f060e492340466bdc8cd822882c38e703183a0a1c57eb23a89bf999a77bf8a663078ba638bba089001534a8cb539b8bf48544ca8d2b4ee11734dee1e9613194b94d070be7548ba6ce482f41860dbadd7db97cd24ce1f9170b1baffc62a83da736e690dd174facf90f867a01c777d529aefd446db342fd16f8273312ba88158463a799c5ed7b6816c7630317e0be4def530d082a07e4ea31380e6c0a3a5bfbdf0e63133c4474970b9296432d3502fcf6eb7d83d7b79b7adfad67a6549b31c024b4b2b9a5f50b45bd7ae52a64878144efc495377cbf201a059de304f174279e2b5be7099a058c1abb48b80fb3714ece3ddfa87c102aad386056ff121b66b6dd5b3e3d5170982871286cfcf055d4ab888d740ce3b33aeb4ea730e8386f5c77f135817af85999283aa6c7cb5000137c6e41524ff03681b597094848d169c8493cf2a05676d0c050159d2d623f05a65ed4f9ed6933cbd3326fc13fa6bc1dc6b6e9522bab0dd834d6a7621c2cbc518778dd61615b1b8b8d4df0f24883a37e8ad60b62c2f56777895354af3bbb64bda7f5be9c5f98117ba00eb251034200970042064b4daa6b695c343f5556f0e02e03f7751d545094987ebfcb1df87c37aa847011cca855e31d5556604e49012da6477b590318d382c9a5bf1281aa08c28732a5b691be84bac971ec76207f3b8fe3166bb2c2e2a838703d60a528168920f6c10c687ed02c1419fc57dc51024ab1c88363551aeaaebfb4459b943a71a0a3fe9ea14769b23e1191876f3a57f8ea615e2b6fe35190912348167b6b0e7ce4c6d02950b16861c543f873a584edda93c4454560e40918c1b96fbe2cfd9825e4b70ac1f7f5804bbfcb2a5753b01c5ec817f02310fd456c70ad018d377b4c08e9b72720b76b8a3dc920e40d5916331b050ed51ef11ceaaee49cfa18638e94868956dcc7ddeb14ec01a6765e66eab9dc8e958e3cad1277a0c3f5bf3db56a3f90c47ca87182f065ce43b80ec7c884bd9e4804ceb10b05aec27178bc56be15dc469bb04a81395314e6156cbc4a62dafdae8934386d05982c9fc667fe06301379410dcfa1bac7157364dea419b2142abd61eb79f9c960864859d3415fb745514db1f7a6ff8840bcaa405483b70db993998e22de997eda57ed1ae8505432e4dc442af0bd7396268ee7cc3f89d3091010149243a9b03915b5d6e59afd3048b1191809bd98c8f9c28b28d3388fa1af50330ff3beb358c178e810d9c311312fe53d6f932b46c5d8ba777eaacc9fa6ef0489feda5251b000664daa582d269729525e8365b7b9e57c814ecca595cb8d038c5d762b85b776c0f59d3fd7ee73e0bbd9aecd304242a096a432b6022002462a153d845204a8873ee651866f6fa960b0c4bfae70f93a64696aa563dea9fa1fcf6525f385a7d00d0a0fed75681b0e5fede82302c31157a4bf14256a94e2902e5fcd5579fefb935ba2a4ea8b4204f7e51d1633b4038ff92ccbe40511b31cf62176fbda8a4b28e8635763d0e14a071321031a061665fab1c6da607afb33a8c57fd7bca56846959a148c821903558fdc9d1724e17b725397f0479e938b5b9c75bbe4059926ea9a64f82a0005b71398ac27597e50d7ecfb164f4b8ddca5d506a06c9d824c9115afaf8bacbe05d721eee9c2fe1b0f8858c96547200a89a581603429bf1d3a9d8bcfca38b40e78a002e2af3348390bf7f3365b19daa2161f3294b13ada0d71c54d751c4178ad4666dd8b3701091f7d232bc66860e3ea502fb7f8a1c8c29828a435fa4406ca90bb644b48e8678474ab2209c2222183bba0f956118c99a227d56ffed3e17240703610ed8f205396a4be80d2a41d83d2e5c970622323e5e824a10bcb7e73cca3f080a03ea749c474bf07223e88cdf7fa0cf498308dc704f4a244069ec6c37af243977fa02894a916d92aeb09d5a16e810fdf18c19cf5cf7b0e2949eb4ce4d00fd6f7e91bc07dd87f5107dacfdbfa18a5148ef7b5468a38f5a31a0eafff4bc4df5404e5ba0480792f8464e0dadbf53cbacdfbe7754d1047e3d3a7e8ba76040479f106112aae795f26db00186c5643d9e0aac05543377d6f7d707f1f5b1c76dba1d0de878a7900a6c34d5e8d64d569face4fdcde854718e2ddb2fa7e069247067198fed9b1953b653871e340147e524296900a84ba27be931750814b9d373cb60b85899f19ede19845080bf96db63b4d5fbb1b01df4efe188c87dba338a942563c0e473f6edc36e652e29fddb4178c84f7baec6948c6087f671a5878ad6843328c18c09e317b9283fac09ae3645c55d96a3171fe9a514b3180450a83e6a56601629aa3da1351b1160ba8ef85be98cbc4b1b0c10caaab3ae4bdb3ad4c598d3805b7cce497c2e3d1b586b4b0996f1724bfd43df4f3b1837e7bbea4f034c77189d1114b756a6d4e5bcefd7ae2f47ccf36b3d45a4fda2c80ee42f6454f770b208cea519338157e054ccc53b7577160ac40ca1499e096ad16c6570c36876deaca92db01169919b7f55cbc20ef50bddab52121e095290c2208c45ab64d18803577feb08243832553edf640ec4b73aa06ff8d27a160219eee8e0a7e3e4ca400376a145091a0458c2f79538e62e52a228032c05086d75f250e1adf1819bf3f499ffa0bab8b5e9fac70662f816bc274b88fe8a0d93c308bc48b8eadda55f38feece4f2dceaf45c5dd9973eedb1b70350d4baec79999072a8884a0f1ad685e840d08692d815f6fcf5d76dd593cdac30de763e9e27eb77d9e3ef3154008bd08dfaa29f599a1bb49264a2109b0f48ac47386800dbd85be072343c43e8b4dca958f00a5651a037f33168f490a8e72cbd6e34a9a186497e009de83e9b783aaf25a127c8ee13f96c7cb6d6e679f144b1629fb780dd4ac4d4f42301d2cd2a6dd8ebc08e7f3772a7ad7560b79c3e983982f830f9e1fa18fecc00f15e3849b680432338630ba9c9b639b21b9644cd7dfd4f8b5a0fdb6c95341ab25ab3d1cab5bd29dd67fd4d2fb21328290615ebc431f1f166f574dd9297f8e4e43e1e3037f9bae4602b89f53d309c274af75f2cfa8a66ec4b08b19b49094469e3c38fd408bec39e6fbe43cacec3bfa69a417f37ee41a2a738816d7958505c30174ddd8e65b462072ab43eaaf4d78cba21c2d1fadaa11b703fdd6a126a1fdc88f728f22d7d777143fe94091dd9361262b4d3c4446c7c9e48d342d7555f5c1709e3fa73d8c87acdabbb13d4eb7988945ee012706cf2e0a13d6586b2ea94e28d73ab75f51ed84f1f8c8f483b6c506480681c38f8200349de1ed172132442b6992bf810832061abb018a595a06848125c9d170cb758c2126cda80fe7489a301649702e8693219105bf71915731fe1f26a02f10c7483e587b89580fc677fa31bfcea3c7faa4c69c320c8b7d12d2493dd9bf9c9c26e5ee74b8403b873543715988a4d152efe46a12e9c58d206dea850fae1c56a649dce7eb498c7ba6fb9eaa382fa39f1ce79edf3e0dbdcdb0ed354ebb84f00ed7c910e625e62fc17ff2a1cdcb31175e67c37421afd370356a29077bc804d9bbcb8137e0a0fdbe534468b9dabcbeac0fac939c030e47ec01a9fb1b80f628479a65792373279397beb6ca4935e9ca221455726a8daa135ab2272042cca73850ccf1878bb3b2e91bec78266408d9b981a1331b785e03ba7faf4d0acdd007e11331115515e2be418995518ef9ba7d3e2c09c957b6e212adf981f578a71aab5c949a46914c90654d6a87a53df1168b2382bbcda6f8d6805938b665dd4f3a5dfc4e1ea089e4a3677309ab9c73ec2aa1a8047981b1087099a2097500d886aa0a4c9960b629d091ffe2a020d8fbd2874d44069050da7526422bd77a97ae507d8dd0826a5cd35e3bf96469ab2c8124c6a53b42c4a060259b5cff32862cd380927c10ee0efc87d5a8d6d4e329c3a19fcbdf8e9110fbc684b9e997e6e9964b8fd6f775c123a3ab3b820e6465463c14e9c2cacc0e88e1a3f44242de314c53eb10ac12f6c05e59548a938034ba20c992e662090ed127dc4ad11ca6788eae643f275ea695dd977e417b2dbc68447d73108b8e031b271fbd08af159b69eca54a8cba1b7dd8d8629692df28d3bc7a07ff6b3ed69c1f775fe20ddbfe6a2dabb1b1e755d4a4b15681f9682065393d160d771a87f9912d1488ad0687ecb3dcb51bcec94b44beef3a381bf12a29cad553a06150071cc6e57463b135b0bb7980a3fecf0c97530017eceb97b20b6d9f2a42a60c1b1362aaad9ad3875d01c32abfca5133c8a50776622dd543d929eead3b3821b90f755fa994c0bf3260ab5d514acde291ae004098364c6f4f9f0b29994df849d94b5261339c79478de0244d2634de8e554bceffe31e7dd7151f3bd8654ca7b1579b66aabd047bc273b6fea53d121333587026a221c08e41737c8cddf30daf58b2d51a8e36cbbf6e8dcd4a5600d4a0399094c1282235a54f1d95a8d37642f3fd8dec81e35022dcae974844f1eda90e6dcf928eed2e0bf1c257a018696314dcc24d044048018710e47cb4d624c77ed33434f504038664347155a56bb8ecd61e6b5488d47f9840eaa4998fa969e27f89e0499dbc3ba97ffa35ee30909c50915f32b7babcfe4baadcc356d2ef0c748eebaeb16671741269758925f54507ff3e340513b1f6d5383d173a159081f481db2e131b648925ddce574b50719e00c25f39d593b8a67f985ee9470fe2f0a2f4383d1fb61f7ba46c58940987f020eaa8f2fb78e6759b5beac6216849f9555bb8c34e5404be0114b3a88d584ed9b27be269472fbecb5a1ecddca29366b45476b0074f48f9c4d87580b3e8a87c1ceedbc70372dbb677c5f3dcdfa2ed13204ad4878e2bb5c80313f8681e17c50ee839e5ea947033e8e890da5c4c2398319d26336c7cd734a7e2787e3afc70335b990fd78578ba613479a775a7ddf06e6ddb6ef72a814bad29fac67e20d5a31728ab2a65ee02750c1e034cec65e04edd6462d2f181a07d7828cd83aa47d7f369f963fb5190ae1435bc85fdba25a8f572e42bbb89854c9c2aa1d6ae8743b0a05eabb100eb0bc80c31301bf2e16de6a3bc257cc495d99faf55b83e5d205acfaaffb57bc1c6f799e050c1dc4b3f02e3c92dc523f0c62d2502ca32a01dfe31fdd5b2437176e87648c42f3b55a26962d1108fcb466d2511ff5644df766f36f7210ac4a11449096ad8f139e12d3dd4f6791ee806565559bbfbec7ccf10224180c633eb7a20afdac4de884c924ac8ec1725ce7d86490a9c10e8125f1efdfdcf47c79cb7feed13dbc297434139c71ca59c678c70009e1fd97cc77d61ab0ee1a00c5254706df31eed2c845d9d534dfa47b19cfe7deb96b529d8d4c0c6909bcf7329ebec0f5f23f9927f53248108f72dab51b91cd0c119c69c11cd3fee54839f2c3bde7b5b394b1a9f6392a572af93af2d688f06b4b6d4ddf15cc8c0756baabea0fd9c5ddefe28f5b855531074277c4ee7d00c899c679b446ff52fc39f2876836e1fdd051e6b9483314c1740fd3f94dd073a91f740b650be738bfb3776753afbf995b308cc5dd975b4406f5e75d0260e8af6e27eb2059f3a103e9d8b0262d60317dad8eefdd8011fc163d04e5aaf4d20e5c4a0fa34394b57f847c97471133aca8e10b2c71aaab3fe2c0e1bf3a589cd2bca24e9d0c2698e90e80efaae8a9455bf64369237f72ca9b2633cfb5a80101523e71efb5b82597f560521b897a1fc08032ea2ce51506354d506208157e96d918df07b9df96d0edcf89fd1cb26ad83fad25d1e4cdb396daffc00a87e50d716e0c9793cdbc20f2f716feff134a80da2adfdb3b1b233ed8fb067cdf283b7be6c90dd6e00fe18dc1ee98cd6e621bfcb985879088e88906fd7a90ba8e157a7aefa64fa009eda956120894ba1d304d1ce3276deab09df8c360aac484506d65b553313e841c11088c79972af22acf6edea510be7e0ec937a5be66a2004148eb93d1ad9fa9fe45be8ec1d02ee1cfa5048bfdc6e1232673cddc5e7d83b6b2aa2dd484185e17e06645969638a3646e65329c159c4374b6af5aa22c19023e192501927bde859f6253f89b07db66e636f8fd459e42752f99ccbc63a7e1cb27e1f2b1374a6fc8bf899997e28387a732c5e4584d93e2441c462b137f83daad42ce4b39ee99fe5031690ad4b8ef212d454e4cbf11e6cda80f1eab8ac5c075502e559b9c4f51176646035ef9e009dac07b6d2cbf7d7d8d7d66744bca5db427440f5674c4dadd92b9e0bed4f80bccd48e78e827ef66f7ca8665d824bc44a2fa5498ca2a43923608ab24784235b03aa87b2c6e010b5e77b597612534f071f9da6696a517b7d663849a5e85cc079592d9a132fac1945a376554bdd23c2a8612ffe3475f9cecc895a16af3c2e57566118fb54dcb9ad541cf7bfff3ca291bf22f2b54628e496fd8eb5e6dd485ead16c60e120ba778973dc254b1f2cdd20fd8228c66c1f61515ceee9dcd301e37917e3b2bf79d6a1012e039988aa29ce888a4d6996d8cbb43e38e50bd2ae8f447b3b2e9772650bf8ae537b38b0891e812fa87f45c56cc77aa00efb18dc6a9efa9997288484d2f0cfe636bb97c81f4447ee41a53c29607e05347ada97fb67ce7abf91b5047db28c991692670dfcaf5fa932b635afe131c9693a7e91c2a3e2afad6b3a9e8933d3e9142102527ed0785da53057faeba28e5977daef63db4d999d6f1d425ebd5343d6b9432668427dec52c1d47f3ff743a9aa9186697800f1fb3c354ef6152e18c7b2e3c885b722b5ceaf6b759d3dfc3c82b7137c11e6fa43adfe60d42b75bd15731947e1a32a9f771eb72592ec8567ffb75e582176aedf4a7c2d51c9ff4e49309fac9016604817da247297297c202d1f7e7725dd24363fabf04cc3c66bbd339ec3dd8f18888440ff5ea6b83fe236e3fb26a4d7b0e4b2e9acfdf266ddabba6efeaff4fcc31a665cd8f039e507fa9b068b489f3356d3b959c429c61ee9f6d719cae3dbeede072f69f31ae01052e4a4440707ca8e7b76a7921779d3d0bcd2c3517a4e6ccd16205222c058cb704bfffc0a7d7c4392461abc4628e59c8d1dbb17fc5eb845371ae663790727bbe2bfc685e6f00b3d27da9b3eb7e2dd3eb0573e2ac8589998b5b8d96b975c61a50c91a3a688fd4b3264d11d7e8f48a940f1cd0449164084ff0c52b908e7455f1cc5362f81f7cd2d3fa8154986602b1062a7cc5e20fd3e4a183f085cd42bb9719335669c882ef99662abaff1dda845c0fbaa7120165fdca537c3946e9c18a7d707fb740e83d2333d457f73aae71f6814050a370c58718caf2f495c11d1ec0b866109131316664eebccb67694f0a95dd8c6efe778c22d9b5976935054c67000f0205028dd2d6bbea5bb7234164edbd2ff3dbd2f74b3d4c3ecb48564826b5a9b246348037ba7a50f1b674715fe8880e7fd6670c9d199cc154f24805f91f2d96aad90682f7305f9f1b7c9a8e4560c53f708f37809829ccf900198f0fde39f5a5097885dc6af57ff4c7906d713a4f5d60a76eda796e2e6bc0cc5f1d4c497572688b79d2eaa8dafa04df8f73dcaade6c82e83d5f3946e18a4de9109a5e96be36f5e8258a3f4842266b40fce61f9552ce65c786335c22b4168d78140bc9dba1cd54640ea9de22e3c09c9e64ffe1aadf1a83bbd8388f42d27873edc1ad6b1c3563f5edbf0cee04fcdb90cc67e10ce3f8e4d0fe9ebfed879865e63807852f2d64a220414dc98c8a4384ba89f4d30e0614b06a4bcff826ee628e4bfaeb469401ba62048182af1f79cee10a247f1939d3ead9df5abbe958027fddd9e5c263a251c7831fbdc8c395bceddeebf4e81efb31ef879e16c1adba22b430b4a3dc3e158bccd4379d5a155e82553f0e57bab3ab5448f7d286aa9473f67383875bff4127d0487e5479d4e6945dfcc0716088f29a1a00bbd456bfcd9a225c4fe6759ff32677975da706739cf103c9c5afa4461ca9965f13b779651d14e3752515e19fab9aa13bc9af268f4826ccdb4a0645971159713fa8bb49def68a19b6d9af3051f5fc71bfef58e1a7ee53e900a72bee4e95f913913925cd993c43bf2d21a86f0433eccccb3acb215ab7566b176d03f3382791a399795f0da48d19373f961f82f4ddd34e628acab3eb1f53fb9b373e211336a3293cbc6ca035788dfd18fdc8122b4cd5a6086ec4da457833ed251f481bfbe222fce0eb95be6ff9741a478a967ef872b164d1e85cb20dd39ff89920b0682ee91a98f4b21b2c705ac18d20df98a5334ca3791fb2ea254ffda7472b3b59942aa73227f83d50c3d4d115df1f725f047be017d00df5724af1a55776f17a3f8ca3733cc4ec761609fae5de298e8a004baf05e5de5af563687303eb6239dc31d7a2f93f3b163e00c2a496326e4bea05be74d187c4a3836cbcdf5a65650b2deb8a11843cc51109d6ab4de58c4ed95a7fc01db12620da86cbc9586356fe127d5bd739de1d912cc0c91b4f10764e0fa0aa6e65d87ff78e489dbe73d6f4346ff81d18086834f46b039f6e7da5bff480c37d9aaadfd8395efc86e807d7ae7f011d9d0a16ed1fe6066f1530bfa349fe9d768482afe59abd783273af8247cf8149f5950ec1bfb22d3295e6a0ac5cb2605ce162721ed0a045a2e66b5dc8dd7a573ffde0eec280a52e55291d9c29e893d8c61fddfb16d4421433da4455f23ebe5a4c22a91fbcf542c01c3c75a42772233558a36200d75ca6b088f511aad437fbcb1b7db1c474726493dd8b9e0b5eb77a25b65b35d959dead4aeec9af74cd8aa70db93ab30f9bf098f2eeb36b17ca8c788d651628194877a7c476f5ca67810401dd95d8275ac8a7d47801168af29926f5f5ec5084a411606ceac48b7e396bfbced65af0541d2a685d3d21a3ba6eaa045f6229e75d6719303e0fa844b4ababfaa0d6bd7fb66cb6c0900b0de81ed93f6dfd7ed4c935729bd44d18db7d5593acdb2d013de6b74b82cec21c2b3896dc9e79225c17398a130f591e3921f245a4b8c2291606b1cbf98cee2aaef946a3f1a60e85b2e40f262094a4811be210fb9139ce1181c91f6338339b694d20b2b4c160ef8420761f9e5bf9fa2913c99bebed0ee670678537f89df8adb849e123052ab3613a153e175953548826d315380cdb03d98cc64403843f1ee2aa59350717becf2a8299518c7e974b18bab00d9d38972e2fcfdd63c6605f2316138996e82822ae6849af164dded8a7d9a6ec5172399f6992b97e7b40452f6eb9a7baa9fcdfb333eded3a3e090e0aacc0d70f74d3698e5c75428457ce20442c808bf037021a285c5fb3d2ab11c30d28088ffb79d2552cf81c3d46d5b346d4a377344f91d37fddb52968b06b6991cb0d860ff8481999f126db03c29046d7eb61ab398038ba5d2e73e0624ed87d7f8794482bcfe58afaa843c88380721d1c03123c09a69a1959ae6405f0ce9d792d8c6f06f06036617ce605577724c46ee5db1242022b8e15b434a53fba5223989a35fe03c9aa99c08a32e91254d72e2212031766badf9063539f8e5b3121aef9bd55fb1b856920060f4ddb2b3094d8e75dd28d7c59d35a5f45b0890b962812b1ae940fa95299387b737debfbfa709aae0e223e2e764df8d4b3b4e680471b58230f4669d0cba4746ea7631ae68691f04494d244b9e0d0223c1b427e979824186a4e2984d4fa587defb9b84867fca7e36dfb6e5712bc159db0d99d08a301d9fdb438176f8e14685ca501b409121056650ad231fc9602c55b3f01d3a84ed0d16ef1445e1f2c16128bfd6c463d2d91d4b140306b0a2772a3f2d603b20bf1ae80d2ce62b11fbbb4a89a27a3f18f52af3cc057d4ee909da8f3f25c95ad2ff6ce384bfa5c8d821f470d8ec269a4f1815430ed0a07c3d68365d5a43fbb1d96eea0f57c9935e955933275a35f23d42d267174f9265ec4b44791f21df5ba803f155e58ab6ea7378cf314ed648471223a6187208304a9091b3696488ef7536220f5d0c3ccac775bedad251427ea577772526dfbc8873a0af04032ff6111035ae4d624ab3fa11a933a4513b52a69afb68f4c53090bcde3d82a2d99febc6b4bafa12eada366d4e1b2fb1e6a48b70c1def134bd7cdc809ef8e29e48b9f95dde1df78df565a61c9b85ee8e2490a32fb6312d2a98d5068a1a7122c4d0b901ef5d453d36125ba59ee013f94991abf2bc20f7c9f9bc5a5a920ee298f71be76b57fece919871cf87a8e4e78a27dfaf58f0570c902f1e5201fddef8c67c8b1045fb502072852f77bdce244a0229df8b8cfcf1c67032e71c78a3c733d6d0e8d55053c08ce23caaaf9ea040100c320bdfb51d76756cca09ff36c843e0be015aa21576452364e166bcab543ed97e59272eda9a44554e76ea4c903f649b45bbdef55fd413639421c087062c0579d900df19b9a9f112236f5d90133670b14cc11bae58921351ea384f46fc04c992403909e6a42fdb7f4f087fc597f4a730e1d276b224117960322ba91b508f918b61ed4fd09b00bdc140acfc80c9f7a48b2c00e1e4bce35f40cb1ebe13489cbac5d7476f5b4ab1e669d2b9a3a497168dce4f81139bcb20d9b00b05421ad846dadc8fb29a0a706223c0637c3f24a5bc37562e682a4adace644413ac934c9f76094b489a4b1d09bda3de01a77b5ebc0b7c08007919bca0ac9ca7f1db0229f578f33b9275fe39433f34e67f4aeb23cf23a7d445eefbf21c72b7c506f59e3bc1b8f8b121c5795829ac22794087aff7337e0e0a50397a35bdc5792488b69e9744dbe054ebaeb54269146f1d967a9334c079c726b6cd946a09249aa11320bf47ffeadc4e16cbf5193b07936117e10734075a7e6f53cea484684b1636b976bcf887849de1e6a17642745476b856984074ebbffb9159edfddd93b1a70093fd94511e2e9e443bb82e4ddd110303b833e07af5e8da390c5cd2b524404ffbd88b682b2ec69bc8662ea92a7907d8b06770acd573de0af6006023de0465f054fe25009763bfde1689e5f03e7a8e0365a2734dc7dc4439adef0a99871ba110a5f5369557bd448f0419af5410820e9768da264316f26121ef7147edc3758c7976f23c99a0a45d23fe45b1c82878a262ceda4dcfdfb2c5eed76e60f18a0cca5c083f892018bb3e6889b97a80fba883d616d3234096352c81064637fc0f8962b764083c78469761d94b23ecec133c690efe4a10867800e77d66129b0ff360b7f2ccc8f9e3243e61bd0317da52e64abc4948533e51b75163c68d34e41d040703ff03183a107f31fea415b2dcb6dd117bffe1d089e2606f4739832189ac6afb4be7e030588c0fd543f2ebf9bef19631259af0844466055d769f800b0e3fe20865bc09e5f18ec8b9226dac88b5dbaf7287dfa0af4da514d654ff0f61c92d8b3b0b28c2859416f43fc83c5863c2ba12f8f19066635530b16f3049a6ea1c966c1140477f5ddb034e08b071c2f446b5b381969ef729221cad7e2fa3ad6fa47a8a68c5159e33314b6fbee69b49cc7ad4a4ee728823fe5127bb747b3b4ea422dfacd062f73de67242bc4ba4b4c1478d7e1bd91e03cacaa6087f781dc950d7eaa4a430fbf47d9b250f679af310d2a07649af575e3c844a525b22da93d013c9cd9c4ab5f1016bd5b9410c47452376d5e3a4c47596e9c0245dc653899da2051ad9a688f2c03e4eecf6a53b613dcde1c7d9b5133f55cc9b37097975a26f18ce696a0e5aa59e5097c342236552d06b62ef3610dbc55b8d794c01d4879a346db0678a9cc344aef00d1a4921cdf83be575522a54097f804c79c8b4b5a2237a26e6b2cb85b4eacc71dd8fd26e52e9b99f2a9bfdd02eaf628ee45eb5149e42c83eed1f9a7d91dc5dc012d2c4fb7d885961bbbb1721d11fed0dca60a677653f1fec023097544c13b1628b7cedc42f2e17a3ca2689035383659f9cb89413a0157412e7713139275fc86839230c5e03b7fb0b36ee9820a9d492cc10b9dbd1f55e7a615f186c4a9fcf43d5f9bda15e9bfec6b47b77a20ea05997f62d23d6196604614cb2c3d26ed17a54ba155a9200000df5be657960b8387ccc53b895fd4c61bc23d89400b92edf2feb0b036e780e914179206a53fe1bfe60e7c18159e51d1d11e07d717fc857c8aa3620cc1c44b8dae33116bb443911121de41b87f338631725bc3298ed6c82bd5a4cae328fd503c9bfcf9a4260af38ca31fc9adeef0d48c99ef8a67f2f690e26f23c3c98a4c534b89deda0ffe0b4ec817c68a889f7de879a0928662e993281b17f15e1f02ebaf51f6e49267bf2280af8d6a6db71e970066d6a8bc8b90119e5b7747221a4b206761633c300aaaced688192ac5bdc9329176ed0b469318a64087aa574dbab1829fe9c6441be8d8bdc7bbb536518e5cf0c1d36c262d6668ff1ef9752cc4caab4ff3f4dc6a2955627494c25f1e32fb0f7279d3b53dec7778d496853b745040fcb3aaa1e4f6eac6667b700462e0d3b788a7e12d3434b36e2aee4a4a5d26aa4777ba9d8e6b34e6efd7df4baef5f5ca6f9e443943768d58bc3b8a28638badae31dd5ba6c4854704330c124f3f4a2a4f74bae2447b4923cce8546cf0abd0c44fa958a18781ac63aff99a109a0d1fe1cd40ef110856c3bbcd0dac63d52c2bed24733c083b807c0b614262010a60094b52d3e81621748e1acf3ad7827e59d2631ddf942efa20d957d81465ae34ecf485aa1ef529c53b9a823d8da778fa3e5c3731df7e9fd9de56332482b02986d85fc38f22da435ed11d9884d75ba7d2a9fa172a5bb74db420910e8cc024c2ab51b681ff567daa21734115d07ea568e40dc4737aa1cdfddd4181d14faa613d42d01c6303cbec39bf589841bc5f10bb46595f10bec081a5f06c8e5b978db43885b18b812d3772573293c533a1b821f0fe0451e30501310210f37e549a7395130e9cda3b32e7c5163085cc67ae98cea3a744011e90c8dc8c4211b0779b8887177d90d59eb4ad60a52e90d91d8e1dde4a51e3c2627f2ae2fe3930d1600b02e3f42c607b836ab21ebeef22de590805419881794fdfe1be1ff4245b05a8a6568d7c5eb6223c29cddd224983686e4d97c3570b229a3e0aa23e5a34846c0fd8a52be0b6b228c4794374c7f4826e7ee91d22d1381b7382c887667430b63ca48db174d8fc51bdfaeaa2061a13bb9632e4934ba3bba3376f77134d85f7541bff95ca953dd348034e44698bbaa949c5c62b404afe325c7d2f4aefbe57f3286fc3d0d784763635752f2226b19b5542edb50e354ef8542bd613c13f872625146b519d55e437f220a0fec9511ad24e4ae321ad687c69588d9758dc4b43454d1db8f599b6b3df762fd18be77556b4be62bc759fd079487efc0efa479405a9df6cb47f86fba2fd96746af2cb2329358e5fa444f596cb387c5004c4db0ae926e51a210a1c3e44d24cdd370cbcadd7a5be726c530f4f24816ff1fd9b944be3cbd1a8dbe519e4d6e3355088e8f075889975e83fab13b82c517c7fa3ffdf2cc2478ede673bdc4453dbc5fcb04f756c239a72f0019274163b37c425b952eeae2eaff2a16c0b3bca8c1599fba6c0a43c86686f7eee1d863a1dff34e0d1b6d7701fccf1a8ea8def56469170d4060c03a123e2a9692d70d7b133503f6f89bac271fbf647282811d3acd5d6dec5f5694b75c75d1ffcc5c9c66343c7fdf920df3c1df4c56f42d31d9c3cbb4369963dc6c9ce5948c27bc1fdba0a34b18f5a020a67a0f3f9cf17757e07f8b61e5023bee43f6b14cab6b9e7f06a37725b4ca6c1fc09803f094406db95c0f3d307bff87fa7e9e5774efc597d9558a843296cfd77babe0e5df4dcc16cf083676993e0466fe1bf26f454f5476d381006545a90acb6c99d8060c87a3aa6999dd5ed15125f56e905935e1ad4ff668b302de62f2048c57c4cdb6c2c38c81b654a5ffc2934277f29c2e615e0a5484d95ebe6c3b0f6b277d5aa92dace967ba483cbe7d2ba61b609adfdb8548159db15d03b510e7cd7d56f2c29f58536367cfcc25cfaddb528489f115821d60c61f27836b882a4a9d206ae9a6158a1503eeb9b81ab7e5108a64fb21191d68c1565465fb1dd69915a38f1d63f16fb30cf1ed21a8cc8b49fba5d0b7f1d68aa6b51701b1b9a842c6e3d0fabee25fb16ac55da33a00c9612be436cd18ec4a5d06166ac85d27e65d1c1374595c2245125f1a0b545c4ce18b86305a082840290ff4e6e5a429f5c358330693abc930a849e7d0e443911b4aa35cdaf3ce379e482053483fe1aeb3032d003ec973f99b334e18ac59fc252e38ce5ecf1195ad5a658fce1b0e8944bf15d04a48684fbf1c9968015e67432ab32e405b02c92ac568f79adb12d9dd314fa253d8a7176","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
