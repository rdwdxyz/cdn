<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e9f25719761fe27294b88bcbac61346fba6b7e271de6ebc9f41a6f027ae46fbe9c293066a5fef71fb2e3d341d9d456cf5a314da2477d8f8a02182b7322230d262485e16fdb3e637857a88a47b4a17fbc723676eb2f36d34a49bad51015c7f218683bdddd64417f37d7193cbb29c07314ba8ad9b2825828c952a61e8fa7beb55381c3507a676e61efb2e304b405fdbbd2478197db92084efb585268059fa117b8c5c78f74767ebf115cb18b998064db8d285307cf379960af355b814f89fc7c9e682ed52c199b2f27446aa3d27a1d0b49d381e677ace9959172acddc67436e159c8d27c8116b5f74493e3b419407dee7e9549281e75f9ad2a2ed37ab021b7e25311e4aa7a3bc6fb9050ea946519da1f029b3f197b15540c67f2cb8e4e3f256db701524a8fdb3f903be5f0f360fc30f616a4217c93e68b2e8dd8fa6b246ff0bda227a30686ea890e105d433fa991c63d3bd3551f6139ade1be140a86fcf86a12a239eedb5bf8685ce268839a9ec91ce6a9c6f5df0a20d23739b62e7170ee5513d831d0b5cb27b06892d4bcc7e501ef468a004178f5eb4d2c3f8ddeb69f1c026d20d97eb7bf126bb7b4722887b15350154a8bc77184161554f532e26eed83a6c53c1a9b4ae6c6d9c03ed17adf3550c861d493ed3a29f32e409bb7d02f263ab6bc11016952a970cdfe8e2927581b0435b6d90a3bbd7745e0f60557f2c5d8edd06b112ea13fb4648e5ab0243fe95775821d3864410f3982ddbc5a04afe995bf44ee20ec98506c6c0d4426e79a4b1b470e62bfcf29887c0a23b292464933762a5a64197495365feeac95436f339bd548fd64990ff4e2aa615adaf0e2079eb4a8007c35134b3b190f07590a72c28e1556022cc54ee36cf4ea057549b93cbc9f5a7a4d40eac751c398edde05c912530d21597f6de220f3deac042bc2d93bcc495fe8bbaa84efa27f6cae1efec795f010aa4922884bb0b53de46b35970a85ebacb89a294719853ae3cc5aef425a2fa11d2125f39ef6b064ab86c0a5b9993039531ce79e3c59e627ea5c9e23d941e873a7619ac41f7149a93fabee765d60f49245a1b666a793b45e5b2bc346c0decbe592bc17cfd9314662a69f37ab862e42a596f12067378297940188de868cd50abab9224988e8c4873e38bd9f79c635b0bfd1eb8eeab4c97892dd7f2f850139a559cfbac689ea7312d1ebf0f639950bd2668e107399b803dfa03f2ae5a8315bfcf0f66a7e035cc6ff35c76b1eff3ab92848b7110052684e2c83fd9362d71393206afd5fba207615cab680c8c1602b0c8756a77e1a46dfb9b48cc37dbc7d121af16fa6448bb2d517c651c65292f44f4b92e8c646a11a736bae97b749029ecbb5e4200cfe8bbe20cc9d2cce0c434d95e15dc2b63104245bafba80eb3e31d98b17e7f50322ef7aaac31c2a876fb4612dbaba6d858388fe431f185480c78b0bfb3abb075c368cc47cc2fc2ac37ba75f0cc7309aa4ab7a1a2f6bfefb1af38a73f4631c33cc6d0047764cba7219c3c8894e43a1dd9c61dbc72e7cbc20acf7e77904c58a365a7a8df28ffafe9623c8047fb6d1dda7ffff768c87097407e7fabe7f50020c0cce7ffef873c0f6c774f28e14da0b181d00adb422bf6e814a5bd0bbd1682063f7a4f535eb0fe166866d61aa3f37d2a221f71179e4f577f60a2fe0d8b6f3dd4a6f65e84b26046cd7747c3251eb551bbbceb2af10b65947e6da203258be19553b6e83b6bf9c934eef162bf6b1f6b70993fdf03b36b4fc8a78419501abf4e3994b356e72737a81ec7febdd2ce6878fedf57403e88b4af1c125f6db0941993c3d10015ce2076b45bcbfccd671a5a1fed7ee06dee6934ce4ebedeaa38f8bb8bf1e0e55dd29576835f5dadbd471c19e40db8040ac533b434c48d251235f0b7b07285a1c549743e44f40078b92dba766981a648f8680ee1c6e179c39592606ebbeea93a61dd0a3a0ca409c003d34460d526a9abdccbd83d8c8965ce40ba7730f943e7f73b6232c6248895c0dbeb8872e4907a1f4a2cef97eb76c157cb39a01a8f188357428f6a8a1bc4a308f5ecc87215bc1a9ee2ab4bb1d96e90374447b922b4d0cb3b5ab0bce7c0ba91959156f6c674602488d5818933768d3ce9e76bff905fecab482647e9d65cdc2bf4a102d36024d677bc3b6b70b3828c06ccb9c38700c1f34a8676d02e05d6ab095bfc09787cd60b74bac89a7ddb1809c1b9559c2e1ac7a45185d39e0d1f0fefda7b6c075f56d8c31aef3989a2d65bc9d4a7ab322207dbdbbb71dc8c5d098fb142c463790b9af5d18df07b7a68412817ce1791d282e6d2033839012f7c05e97dfada9ca49cf5a0d65249133e45f7c1d7fdb30fc947303417d6fd782dbce4c177988779d81827c36cf159c2d8cc6e4470f2d64fe4c69788c3e3bde3b676553da0e3ca627433409012a30f31345fa7a95655d03ba13d4d5c0001d5549c05ac5e0142094bea7e010a16b94342ba338854ac5b4aed1379a5204fb01c0641a9281ab9418b5dbbbfc594811c6e87b0c84957d430cb72163b57ccddd564f6268d3eadcd14b83204804d74edd0c292eba71766407eb6dbf7444553715d5f076908041fb832c975d85f9d28db48f8ed9d7a6341faf9f8e8cd664b0e3d024763d3d35e79de53d70697bff7baa9fad1c058fee1dce94572dfa6d839f5b790534138acb6caa6200e21955366d103e997a237b25a5b05b848394b3e692a378717880eb14a3d5a2a51e977e0943941d05e160cbf6efd22a85ffee3799eae97fb2099991c04d16dbf087abf9227db3e770bbb71cbd8e8779000b0414014e5ff0bda8d5a17501352197539291fd1fdebf8b2aeea780ae73d1f41ee43e0a6e2f57ea2ccecf5d29a915554685a94fff1555497a52f0a28cf9ca87ec2505f900fb7614139b3f8e890cfd03925d1d087f101c94f54019f8002176dccbe71a9be72df731b3fa0a405b37e045fbc30b195f72c5458987807e4da1b7769255bc1d63cbec5ef5c3e11a17a7c2fb216f299627bab244ee3135e335e0b9d858068d4538c2349c934d656a1a511f03c70e42f79b3474a9f2922b9a9c5de6afd88ee2c8957e803348b09e60dec3604cc3dba47d3b26e4c48a8a5942e486e20ea9130ebbba78319d770ea48dfcaa00aaae7815fbe1d64697579fba8d80ce382cd9fa9d1195c484514bab9a0463b32a85af4a4eeebb206ceeb6a1a981a2ef13907912e745d333604badcc7299cae50dd1d835eac914427045f5031b3a81c960a13c0d204e9cbf52685a4a3dbdefa8d52b54f3efd97e526394662a3f89156d6a06541db268907f652a25f0e4e18a3794339f662805672299a75183637ce2c2af4128a1e232355cb1850b5c9de29c9127d75d349645e48b0b35b2c1d583a5af82e63f0b44048c3522d96c7b2405b64967c480c2b293415af2a5b605abe14c5013348d4535fc620c927d365c1aa3f5de9610506ab6bf56d673c068b40cd73cb0420005ce050f4866cc03f13f450c9d937a30f8bda932dc7c08e79980d1b8fdf4f045cfe491638e840602a8c1601c64655b262e7fe94affe64e3b293f768927be1debaf203f1d18af8d3726281f51a20fcb7d035095a03a22432b471a9de5f9d73eeade3191bc2acf39d74625b66973f9e0085cf735d9d09c04e481a4fae292a7c150ebcc06dbfd19356e88a8c2631349a3e2058807c5933c769f41776b745b853ab2b798b85a613e43ed974940fdeff559234e840fd27ece168e252910243a38d8dc2305da8e96411d1af1bd1e42d343ff9684c6feb94fe5bfbf8a50d594060332caf9cfd66878e526f0dda8f9ef33a4c6319c18ce90efaef3a2d0990cc3daa067a19a03efc31bf78e1c9a41dc8c938d8ee23b00fe4875ece4d52f6e2b523d3582d4fb25a56a92412c5a27abcad72dc4e52a90484ba2cbd87cc93b0ceee66849269c8b5af2871e534f3f0e633ac08f680c7dda4d617c767ddae75956ff51cb499ff7ddd0d2c508eb5f8df65994e451a0f6b6efb04ee017e42ce59362189826f60d8db00d0b8f7d75edb3fc64c8acb865ccd2083b6c9e86a90a172a56e1ae9c042b6c62a787c68509dfff3122c3d67a890f63107c1358992438b142c52760cda2d44c8cfafcc70efd96afe4e214d368ea2756b8b8804d0987196a9e8e5e56bc3413fbfa9aead69a69d4e82c8a86a85df9056c69a421144ddacfffde41d864435fe6a46961c6d89dd0a8affa18afa576af02c40dd3eed8dd7e8c7d8a3c24209a47c78647f848fdbc98956b678d371bfde888d61033a212f094b91cbc93ca136bcc2ff532626f878002bc1239efd35b9d9bf159c1f0fb1f47eef1d731c0a822eca872092dd82b482db135bbb6b1ffddd8a6dc44f02f27adbcf430465c77fa753a720ca0b940b2d3d2b72ee1144fa2e4c7989fffb1a664a8d7253560799275207c8c5936e9349ce393fe8c1db09d9dddc50cb61f9b0d6cb28d9decd9851d1a22a4115f5a8a079ab860a8cda0ee6121820bef2e49c9d1890b62df4f442c6e57eecc966e4707b0eea91f5310b7c734fdd79f2c67a2a8dc2e43e920ad3705bf15d2c3f5618751837d347a0df19a6147958f63878b5ec1ff799085bf023549a7b521e6f700648b49881b2b949f1f3b3715afec94b79f1ecd4dc919a26ee2094a57ec0fa28d991f0657356909e4f91c49a4698230d75ed7534932d41be2d0289ff9d68ef4aaf57e73b079231147a910c6e2c1ad4393ae3d6330501b635c535e68795086122ca90a279aaac47738c7bffdd880e14c3f70ef8f3b3486f482fedf96a9b082c14b2526ac3ddc8703dcd2ca11b2d71650ca4ab6ad8c7d518b4f065a35b7f5f26e86bbd76f61f3fe57c96374a53073ae9eee98310e50a34ed7ca61916e0c990b261d4ff47f8e4651aff9d2d9120baecc0f86a076300e00845be3da65b75c88abb5fe5c4106d9fd8e72d65e3cead70eaeb7a60014f9bed45f1f444d22fd78236bae4387bbc6c6fa9508f175ddced460c13649bacb0a8a9f8aa8aa71c22876cc83a2a90fe2b68493ee090c031ae57d198c876f4455bae02cbdfe997171ff25bb990e6fc601736f180968e0471266653f01042f1b585fe3b63814ebda6616cfeef2884c0410b2636b8672bb1afc2a39d3058eaed88f7510e279cf94875e99ad2881b992f0f13b8e0c801af658f87581053df49aabdd1f2dcee02d5b5a16559a6b7097a639ca2a0197056ba18bc52d8aaf9d3a34192f6f50797c9e835a2c3eac61c8c0f8615923260db312edd44f7e4e4f0b395c99932c0cf3a685044053bbf4f57c060a355cd2d2b715ef5b8200145bc69fe7e8f34b75609ebbaa027a6dc58c66dcd36321cb85d6e3be1b1096cddc6d6b190ae10f5e7bf0a8459e3eddf125c4f63373637863b846e208afce39be70d0cd675d6455c5fcc6b6d9d7d16f01bd13609c9376b8170fa02448a5f494d8d79ca933251ab804fcbab061faa0b0efbdc592cb78e52d15879c7576765a48f5a7b641160a8f8be16cef9156d1e8f2ebabc631551f5e6f9965a6d7fce79d7974f442466e3870a639fa3088f5e90dda9a1e7be1c2c76894177651444499999a48c6c67aa288979bdbfb6bbd98b617ce44c557a0d66b02711e41236dbcb3224ce2be1eb67e718913c467538dd746ced761e64a21e3f41cef7ceb01198c085bced84ce950de33cb9336e3c13a43649c6c0beef5aa6da9eed555f730d81a338aa82c7e4858dceda0a38a8856952b6553249573eb083afeb6d9379b302dd5ecee468c1378b5d16557d9cab5ed7e4702b7dbd372b5eaab2b0927da790bfcc3c6619371bf7e7cb4c1d75f240789890e574a4c956a2da6a5c848abf9060c3d889c1db4cc907b5c6452930863aa81dfbddd3e47047e584041915fed5166a7d09c85126621a0888adc1d223afe1f73b7cf735f8b87444ef1d8b4d353392e1210bd70381c4a11fa89b690c43b80cd84f3314573853ba9366e62de26f8d661e424aa739c413599226cac33a44e0684d82dc380a556c7f5b37f750447b70658711278f99647283ad437c5de13a1e0e64bfa63b39d735223819b936442e99f3eebb8b770445a6a671c8f4b47792e001d4ec7f53df3492cecf4072211ab4a7a47e13e87a81ca7a748ac4e32719d4edd234867a49ea99b0c1cac474db34661cf8ba151a1d6dc2e6356fe1268bb6827c2aaf5dba84d2211c8f39055a37e96e47b062ac539472b787b62b54d8feda97212afff85065503e1ce74a006a1e200c4e730e753531818e8af7e4a6bc461dacdc99abbb0995cf0409ad39c35f5eb34994fbd98c1f8a8fa7ca289e92572993061b7d3604e06fd584c58ba4827480a318647ee2a6e82cf026f1b5c9b60a48f3be0ae1894e25a1001cfdc95d5309f87b29e57951702a0ecbae41e96b906622bda02c3f2aadff0f5669975bb9247fc94fa0498da4ca00656d8f4e2f119f0a79cc97a968c1d0aed4e0f43bad9951c09c80111c95168f43e68f946430dc8630400767d97a8f730d5f083efad7329ff9000ad3f3309c6c77e3c2696dcbd00ab1bf7188e9fcc31fc2034fcd9273530b3c53bebfde5b7a3a85a830bca34e047df90b176ef3e6077688312b88feff2ef6db0bd444891233a03f3459983017fc975e0420fd669d0efd4348b1f0370bb1b1f3029ad64030f1e61e9f443e683766747e292f50bff8857771c4285fdab06163e53c34f369e17132ba006dd381083060551d7f30cf733ae48ba0f04f523a06727329e3b5d30715659c431ce6ab1fda1e437b8a6ed23b027b4484d92e753962151a48dbaad7028a1e21012294c8fb901813614ba0d7a7cc8c1849f69b19793fba1f6093b8f7a0732a519c89f03a7016d3af0c30e6f5bca7dd287c904f51dfe0fdbf389e78bc792ccbb732b1bcd998188f967a0343354f6ee90a0afb479836a023da75117f1c8d4066096e28821da262ea8cec05b9a965e022f96d9b300895068d199cfccc6d2f685a708a36f51e09a9ad039e3c1abab0d45b54cc6e7a044be1d9fd701f481c2125b6400673426277eff76860ef0c431ef7b4deaf8f01b764ef970cb784f9d050d5f0f95bd0321e95913483bfd10c4da5735c357d7ced8f5f0acd5dc38e9b8355e7dc425d26b8f8c2302ea17311d29609861b66330609646b7e1f83678a167846d85fd102de8bb0cbf12427fc4cc7c41c325e653ffb1a7e73807d6d19123f36ea1e50fc2c6f680371fe60452bc3accfa7380e93070305dce5e8c2d4e6e8b0d099484184016ecd929773eddebfaf1bcafda149d5a47dc9700e8ea2d5569145cfb9db78587cfdea644f0c4731e36733f2c33d1b70620bcf014c601f61b7a68d18067c6027bf2bc8c321c9c45193b6edfbb85c34e8400fc66f243f1dec6caa3f7fcc50f3854c8c26725ba0b3b99f4cd7a2c6b5e7e739a3f3cd2b471b19d5d1f8677e8348032bbc090a6adaca1967845c25f946bfc0678d0464ef7844e8a0be9c390b1bed103d8604b636665cdb01b1b053798053e6025a0592df133f673c99013323e5538c9ba84400cada23eb290f958f9a70395d3904fb8c5adec28b9edb109194b720f148449b48b67341b0dd38f1954e131f46388f9293394ce3919eba1166e3d5ec088236a3883713762cbe7ea8d4145872c09216bf67abf7d1e0d43362888fd04817251e615d9749a130749fb33b339907d52c60c5f6279c8d40c8adfdbb9bc4fc4e918ab1019d1c2d00299de6255c9069b86e9bc6236b958c241258da5976d7803b26e4b7e288b6370c4ba41c8be07956acfb7d14c58e6d9263beac528fb6b957368e10d3e66abdbdd78131082242fb572052f109a28d069fee2233c4306f08a79483a2c4df2dd8cca540ecf93adbbc3e8ee0dd1b1c2881d1fead924654526b5a4d4054dd6c0153d892c432742cd08bf568fcb43079e2b176305c11269a58a221565f35e3e1b3717d16d369d9681c44eed796723249d53acd2d6c0fc135765883c822423833e67758822f9e474d613a2c5a6fbdb6275f1087300b80f989353a13e9ca9112ba41ce1652af4621c3f122541671d2c490f08b8a83b76ea21b77407d1bd4b9993a1c1f6b22d74c992f6027678dbc13fa198fd64000572f002925563354277f94fca0b1b9674fec2c508fad638a93494b9bdca69e1e039eef5041d2e9dce19820f86f328152209e201a50989baad7541d61045e88e94e3d80f55f28701481bbe90aa40c533a07b5d4682dce06fd64ea8865c11d5498f290cb5c953f12bf9372ffd4c8fcdf6e6e5de9aa98f8c645450945b15265b96cbd4e05eb2913b9a546da70abe754589eb7fd0dd38bf9bd358090be54238a5a8211ba866578f542bb558bb6aa4c025fc2c10d4ec41737f72ea26ff5cb806627ccc619fd7a9ec345dd0f74a95e2b110db4bc09de21f55d4e05489f69b4311c550e3e31f7e1ea351b1fbc2f20fe2c65206e0d1bab0395b4509042057f21714cb1d864a462ac357d761c93f172b215e70552042c0c8ff7628af0e84547d0094eb82c1082de7268a185fd6e2387dde42612bfd8ab702b4cb39e93f855b9fea2fa42040d7fdb7b62f9fdd5dd207db3a0154f0e7052432f26fb9aabe589a0bfb07a6e6333cd027e533c3937e2f32f6f93495b52d4298f4427fcfb62f3b2149e5e1b741a8473d2966fc82bfa0edb6f7635de3a870cfe4365c2725312ee57e3378fb9c73edb05b8f07eb5275cd788826c4848ffe688784decb8aecb1ebc3a2fefd8fe895954a26d565cc600e3f53be70db075d7be8f0d08ecacd547e508bf9f92e4eb5b3d95995313d5b16c1c118f020639b4cd5b1afaa6e02d5188250b8c0f26be0529d80febd0285330482c0c1e37079bf34b45c0e0d89accb334cd6417d620c77866e01bc90bc7c741c607ac578c1658152a99ce086add0bb20d75e193e65e4378db7061b373ed84d196beb25a4662f542e9342ac1cbc2fa35adafebab3c3bb4abac42dd17bbb275c629476e7e1d99c8658ee88fe978f23337e5b37e670ba14e36290be27ef321e9f7b1c1288a259f5453e95dec7268d0945a35b12fe6e8e32b30b5f8acb953a153b7f265c1d1b73568d3718ec4d047cdd6a738f7638e9c7df6cf5333da11ad45fea2eba9455c149b52e23555dfc72d735d2a1bb5111e26a028b4989fefeeec0f64daaabe4e5ce5d1a2980c9b2efcf71f30015ddf3057083416ad18c04b144b572b219425651b8a5fcc1e4e07260e4f03917849bd0937897ceee79d148b0694687fe8aa40094a4913daefb09ca9de6696a1bef6a47c8978ff000f010332754333ef7f42c100ef4d8c06092a77c87df5297c24c226429f8695bd8c024bf46bbb81662035a7c28a59d28760061ffa82a3782be3b553a57408266c98885c5d265678038371e7fe943e1372b401dc23e5c2ed3a15d2a7db615cbd208c89818a5ec2b8c656edd6edd96507861f52e3a18369065e534f3bed9f5e299333c5653d6b45fa39ae937b112aec90c434f9bd6c4586b40e6605c465dbfea884256f56504fc77d024863303451a988600da7959bd13300788e7df4ca6b11886c6b46dc1dad83b6dce78e2fbb29f2a5d4f9f42c9cb41204f7638fad9719291bbda3b666d083d7507039b5d221d12cc70ca3fdefb68261a70fa8ed7cb4bc367fd463a93d9edc3e1e3f20961c9d04ad9a206408061f7eca4724b7c3ab514525bbf0b92a45efb3fb697f2b52d1688e3a6c36de5e4b977d0d5ce5b665855c848c20e49e58dabb903c1b759baf4844bc81e7cf8b30079656eeb5a869f87ddb7a66fce29076f04956ad583bf931135102e6d48e44f23751294dbc989e20af2438ee0d0ec960b94111563ffcd2db45748a1a72ac1e1a6d92bd555abb2a01681ec22b62c7a55620ac63d767181f9053afe85f1176d58327633e6a3d285cb6cb69ac9b999955de4227b889890a1cbb2b172647330970cd03bd599f62d6f9f90c297f7ee8b160bb84862310a932e7b6a9ce7f6ad86d54bd952bf13a8e005966d4226675f95632437069cc71a9222098dda7788329e4576c33b8f91f864476fb344ff937f4e60e575c1d374c1d0c257a0122e7157ed5d7bde9c8c4e9dbc855ececcc41a751348b23c38c028e3bf865090aa92df96bf6b181d83d51e34a3c9974176afe284767b568f7abf6b94dcf46ac191ddb1d4d98e48742856b286f6b5a2b597fe3a6945394be11ff16da723751839b526222f305165c72c7249bb266214ecd0e4a96e0c6721e62344bf0931cfaddd33c976312e3498167188a5964bb6ac5c1b8de143a56ea7d3cc9826811fda65f5175526b6e3d7c3f0526c019d90d8cd94fcfc4441851eeac3af792bd8fb48e943354926eca37efa8a77e7a96a7aacfb6c1fd251bd39e46715aaf2201f0ff0286a237f6d2fc6cbb4475222581e1d60d4914cd8704f8a9d11109623db7020ee1c92bec863a105ed822520ba9bdb5ee61542da8356687923233ffd175d3bf2fc3f8bbb280b7aa3844e227a7c7e9b0dbaaf543ff6e069729496ccab9cf52758adeb154058b2becbf443348717bfbb83b70c0312f4bd8222a3d64ebc510b9c704e6194ce9fcb99fc8649872c7b1567225ce4864d83936194dc5040e08957d8d0fa19b7647015222c53dcf86ceb44ca678a8f34faba5071dd8ca50043d9a295ea3f6fe22d2c54b54aa9f90bb44f90e87c50929d77665624b1530c5d1740922a400a381befdfe99c1bd437fd88923b8bdc869e97cc026ec49e2c820ac7f7b261c03c0a4a1a772f6f43fb5cba59c75328aeac7678d4026362d9a5ffcf1e9d5d9173c1ccdf9f6ebb2e75cd540f0c012a8f846239927c3ca579db7fd1504ff9e787c7097800360442937c1f3628a38d8327f6786720d79ddaf58349f77eb1b097f859bdabd74249e2aaf337e1640f13e900534bf5298c4d05eb2eabe77b6bef3b3a51efabeebe0185179ed04bd5b0767174f51f1b73ed41180bb627bbe86fb639799ba475431e25839e3461a282f498c6a9c923db72b0e91ebb28faec5e2263c5254a8b7543ba9f6623c6c55cdca48844c7b611600b645d35328985abb9537cbffdd57003b54a962671b6d37fd043baf14ad6a5525e0d8105b7521620f958ae7e0ff9355dc32de04d6410bb9d3e4ff18659d5436f8cf32055ec9173d32f26942246ae4b903dc90c29cd6d2921b3b10ed6109af4b708259d6d257d943d9e8838ef1b295a714cc9d8900b9e21675896d206e85ad7adae18ee69e95c6ee4312d0411700b1b3fcf2a4e192b4b777fc8a009baac2cddae849eb985e9d635ac9436fd65287e38870b61dce0dab55d8e4ad08d3606309a4eadacac788bdeb14a2f83e138433ddc894af583edc18ccc9b0a6597a14777b2a59200187e6aecf071afdbf4a2a9705268c94f39489286b524a3c5f14b1a1660eeb1810a9cc3e484977e93fe283349ecf04cad20808d71b15ed5a96a033b2b136d87969725fc59411ef8692a2fdd8233348e215b1f1be403ece3fb8af22b77eabe365b7f60bff557143da4c65abc675a2c0cedf9210ee70522d634d956a0a20ead3db7b11641e166ed8fc7b20dcea4204fb69daac45189f6a485f0eed2c40e5f431193d2bb465db4c5c08e5cea79df8b922e1d216091f765dffa31915f38a33a81f10b8f770edec36f4855534bf9729881d9e7260bcd7846d71cf0e829e6277a836c2608e7292c25f1f9d749d7059249bbd41481c066537b628d79d55ca142c4d571cc01332c4e4e1541c710d767f3d98dd7b580232085da8e359e9d1e0fe5c254bd666bb12cfe12697e247c3d6edc2df2539d0ae898c6cc1ea4274c2560cadbb0d14eea20f1f2beaff19aecaa75e55535caab145afb0047ee3c4d2c50e9f2a385e8ee6d6da1ad6fc7e99728d2423dd47cb64c070ecacaf8a1deb9a6b8c4ed9a4e8f0bb47abf3ea281b6fa3a9392cf983b61eeb562f794282cf90a2e5f596c9332b8b8fab0b6b85de663333dbfebb0715deca5485c89f9181e572dfe292aa0f66b71603a97f02aa9312d191bb7a19bc55d7dcd7058ff0d11e0b9ef982b6d8e8465baa39dc36acce808bfb1470410e03c93412be0522b04b813d01df86004588d563560030888ae698acf8eda6f3a8c52499b470d2ea1682f3e4972cdd7d3ed684c4494324f5b39db73c713b30215e8f66ce67f20270b0e69268fd87f32110e7a9a8066478ae0421b9cb3706d097aaa28f769d9c57d57c70388f4b08a2b5fa1e6bd6d92d37cc2e62e536603810f55e41573b4e8ff2767b6a237c3936ef9a00fa65bfd550fb7d8c8ddf09bb64380bd4c689a39da688ebca1e4347f5a72cacd0e45fc0f5f7e80dc21b0217d780ad888f25999033fb3ee1f505147d6cfd0b16510ca4af1f0c6a5091150606156f64baffb66af74f03b619813b9ada098a180af1f8421b98542a875b7f410237926bddc4773c1e57a78d97237883bce7a620e5ac4e5c666490392937930b704588fa9e95ca9c7dad679fcade8e0fc882f5296d48b7666d02a232182fda07ba0f8386ad57b8dbbb3bbc2d5282f794bf81222b35987ffc9b14c3c80b8f36e38d0eefb0841ecbc8227977e547f241e4483a37ac22b347609b7a1ca497c525cbd820575591b01c5c83432505f72699e3d6a2b22fdd2aac95ba1be163cc9ae8c1d2989eb384c20a33f0a208c1ef60f302cf81240eb467871b00e1a09ccb5fe7ccf666e02dda68db63e32bcc1c37a640f4cffc350a3bda30554b9ca9722cdb5e58490e8bb21c67f53f2adf0b7ac87538978460a1fd382dc118609ff6ef427ca2cb5bfd4c1174e1c91e6eadd45b42559db5f8936e9faa640fa9ed4f9fd2bb201431c0696d255f7a6880afa81621a1c332c05e865c316faaa514888233f6ca8bc314c0c1ad5cd20008375747c14bb21f2969273b3df8b77992613a2f4ca726ee09d532b2e21cbaf7619e3035ccbd3a6fcd58b6a43a56051fdee16c23fb408fb67c6c48d77639d5612fb4308c8c3f6adb5916d7ddb46b485c0af76bc530096707a313a3d96d963d031b619fadd483c2650d08d4af5c744952be0e2488818728a03632bd8a203504fe8d58d38af9d14f191476f3fd5e0d75675eedab75c7b0541c5f2e6f3542bae55088bbd6e96fcaafe9d696aba83558f7222494ae9746d0703d8f7cd3d97667ad9dcee58dc2b902ef86abc0484e7ec7fa71a5afd9603b5dc70a2a6bf7ec0eeb09467bd42b0a61af385c6441706beadce378548783b8be83ac609cc543d8436ed806046610cabb1003ae3ff102d1ce0b5716a7a0088b22f70fc4c8ce9b7aeb221d3b2b44f4d3c7c35aa93f8809d0e5b75463f9d681eb4672fd646a64c4ba744a86ccc950b591de99c4f6b57a81184dbba9cf0b6a5e82e90509ae9ac622ad5122760235e2efc5da0eaff1e05327f037ec17cc8e231c06e9d44b1e7a68f1227d2e12a03aaef7134564fc91d196accacf907a6efe5ac22db5c013e4f8fe3076055d56b653a9b611320ec78ef5acb8c770e1bc831dd18d83ae6fde2572812ac471bc696b6c1e5c0af5cbe879e5f683dc4b31490747322e769b7680b3860c809b166aea78262bb39c50cdbe2ba69ea05d71681a44ff542364dd68b03a976193135047cabeb9dc2d20df7c969e26633fc964973be0b7abbadf19a5dd2eb5fc7ff89ad62522dd9982fdd628618fd7976915f64f2e79c7dfe1686c0853387d36f1e1530193cc532f5a751717fb1561ba494c234d714ec32bf96437424b6fdd5f22c8d4a735a7f9ee1dee61974e47c680fe7492b60278068242e5542de8d65884d3c5ad92da0ef45ad858fca2bb8b1eb4535917a18a23729a51fa394d295c1b021a17ccf75eb324ba99394523862252a8637bfd709738d9fd1aa78ca0ef0b62eaf2fd123bd75d41e8eca7e28ff082095f82702aa852d0fac6f12f26ad35a263ab3571043b7138e4047354e187ee54206693a9cf34453e9ebfaf7f32fd95fb7fe1cdb49c3099ad117e122e1cef64d72a701c401d503c934205930c60142150f96d501171f13b350e7de539047a93f84bb8b59ff6c0daf9c3be3970a8655c65e7fb4284cd96f25ab79316110553b02f3f43f085943b1f97735038b616503c696881810c22b4d1fdd60e8902e967b3ee4547437b98cf4e179bc9d0b4a837a55bb7ece1c31313457daa5517dbc5bbf496336249dcfbf1b5ae24fcd2f542899341f1268a68447f24e26b37b7584dbf3267623641c571a05142898b5ebbcb206fef624a21328583bf797b09693d4fa081e5060ac981feeae86bf3df8ec7dac8916d7c30b538b86f3b85d1e11f66152a34670ca75abb0a380a7e78c35b3314224a0df1a7d40b2ea9dd529e1246b392a7afa357e589a95a93f03eccb0d5138672ae22481717b5163cb7a3196e91ce049d7b232d8ff6d79e023333c974a88de5219be43da0b7bcff79f462123195eaf4cf7fa15a5b3d3a3f1d5ffaa7eaf3f59943792c99ffb57d35444d77e904bba15dbd55e4156c82e19080b400937c00cdd2e75eadda80575d5dbf54c0829b0e5cb4f78ceef69b194466385cbfebde1dfda0f1a5cc0cca3e27120926d970fd1418c862f56924c196963fb6cc68465fd9fb3b82cc2bd84a6d6a6dab873fb762f967dcfae43d1189075698f3c3ff2d5b2f9fbe5318b7355aebfcf319f701eab4257be92a6ac0ab27e5c7f9ef8fb8ebe6d3e487772f298b0c4d67d4a417023bb4abbb1eb8e7298a9f5e7ed36fa27c2af68ade05af840a83ba2995aae96a0b33d14eeb1e60f61f9745e10f10b104e48fa249b19553669c62feb000ae84c21b4bc9bfc0a7b56ba91b49c0fd51146a1a225b3e68e47466163450c2539b098f8c43bd7fa0d1c43682388b2746103a19bbd9ba3dafcae45639cf3a5c2cbc2c281c3e9a3ff106574a6b3c225b9f0e877abb85c2bd662a461cab4b441f0f59a4d95e336b8c938e1282c9f8ff5e6eab7584340c498a23fb4651ca3b17b7a294b9a11c058be1af1fb095baeeaafcea113dfc1441ac37fa75498faccf2ee2dc06fa684808882a99356663250fbda821674770e977e518a4d5e0099f3516fa7891d46129876d25e94855af7202fb55504b621679f47a0caa2acabfcf1c00352cd565f778243c0947962c5e1102459d808be31d3b9f4b622486682c36eb183cf0969a24c3fd0ea68923add9ddaa05a804aae9b5adc58db9c99c27d2396cd15e17ce38c512d9a2dfec03bbd641b8f0c1dd369259baad62dca2cccfb52c709b4b13579d7d0de6fade605fb244c985e432c8e3e247110221fc2141e92c3b86e29746db9bb6ba101eb2002200824cd9df3714e3d0a8b8e9017ee2b16ae59758a7efb56195ef3717a39e4715d36f5a0f78e06eb6bf0e1055a0d874e468202b4e226c09647b5ee31915f2466e5fbed0005f79161569205546dbd70d8bda9cad631b39cc9e44b3cc70517aaeed673806c614381077e2c8a531f40d6cf6c97157477af3910e857a159b0baba5fa0c6817d5d280ac8c850e26ff669b6f47c2832af68f5660f6b308ab9b91f09208f640a7101bbe9393cb959443669e2d62b3f3f1e591333a52e5404dd2b6ac181295a26e2a2964e72123800b7e1f2392032f3bc40f40f10ea03741cab10e44d66ff4ab34dfbf91c07390639f3f92ef5fca9b8e05f7fc53a619a4ff9d742af1511c1a4cf3d2445974858f00b3a4bcf954b1155bb2fd0db46f75056c8593de67825d31b45160f5ac6d39083ecccbefcdeda4c5d1970f43cf0bb438c93662007cf403d7e09f193afcbc8785934a256fb299adb5c0a048d2cad6be8c4b3b3d12eaf2ed2df7fd93545e2553f7d7a19d2e3ec339c3a415e888e8c28689d15c6eeb4620c547c564d25ecc62267ed0db2fde6bdcb445ca0aa9ba50f5d5bbcc73010999116fb4b215caad1678db2462d701619a1fb4226b4222bf4a756ad956e2f535fc9faf209f72159364a44e6438f8c4bd7ce3c85980315ddb35013486f5c7c31172f89d97ce3dc9c3311e7f1336431d1e1b2a315a429a6f29570160ae816cae978a9ffc8aec9ac2a5b5b2427895d78f6ede45e0130c40cdfad971996ad8200f8be86c7f6a83f10cb6d096729cb4e21ca8ce94ec5fdd9e953e0811b787ea3af1a8c490ec40880d930f95395b1680dc0b133a6cf521156f3d8ecc73bf7d94a139c64a1ff978e704026e33ae1f6e3c94dbdba54ca72431cbc645a065e4b84a3cc02efc2bc9373c10636c974017afa87a8fa0e3b148d349510e250adaccfd8273a9e2eeb097fd8313028becd41062d8a57927de58db0ba21d5fd4a77cd0390e4f462b4cb54f4e358b7a51580d52249a221f8792960413eebbcfb810cb87e979ab4cff855618ac9e51339a390794d0edbfd99e66b341770a5e7ae574998b85c7de0c10f468d3ca2d1ba41767d342ef70b7b3ce58c1589ecc34bc1aaeefb1b7aac689e3b2c007b43fc61c0e9a4ca74253950852a9bbe80f00bb13bd5502c44ac8b3f3cfede9da0d4cf8250c809a141f87a91e09158dc3278c09e441d71e187b45158c4a475226d9ebd01bea4f3af45ccb0e4ec30f8aec95ac2f23a97fad73b47dd18773a790036d1bb9e855326057c2bc8c401bed0dc19c3ae1683d38184b85229498ee100ec65067a6df13f6120c6eade2a071b4746cc2d3b5267a5d6b1e9daa26e17180a7c06cab62cf2a593b590b6fb40e7c1fc9bbc00441260a2d479c3816a025e534afa27d29ccd166e4c567befca606f3bc06bce138e67455cfa397dd3901a9459f63d27e23d8886de2ffb893a3f00b2752e63e15774a74291a04698a035276146837d93c81871761286408eb385fea38d54afa7d4f85ceb76c55b80af165dc14fe126d638b972c3a5e935ac7306df6249da468d7f4d6383372bfd357b6b5e56ae4a63a7ef040a1ec44f7a5c04dc4ea1f4b674069772295f5d7fa7737e4765e5879db68c4c181465605a2b870f93cc81f340c8967123f6670952e4aa9647c9b4b761e30dfd857ff5c49356421bd918c92a1704e17a97b8c2064f991f0f445cc4c10b7bec96229f310dfd1cd908e55feeef9fbf590a25568bc52d80052d633506cf72af942a40464bbbb1be52b1af4960f39cb8c16d71f4fe634de37aed4d553301944aa5a3933400737c749327a460af43b88f13057e8801dfc4bf401a12eeb7b78c560666e5f210d3d3757ef78cfac635098c5c65cf12d3c94aa3c8ea393c32f1e959b58ccfb272b7cc46a2ac12c792aba8d3c042a72789c62049c97407bcf3bd36b4a1f277f8cb035d5e8aade959fcf5b0f0be37e8577972a02d4a7a2895f9cd1fb80ff745d86fd37091bd208d6dbc85c275efef047e2134e7f90d1035c2b056b90e0b876cb273cd9535e3970182073b0478f243f919175372d539317d117e35f287fc1b2ca12658db36b2bc01aa92104611c62a52460471bd9e33f216071f051961a3cc8f0359199d3195a20c9b1957be7994e47799d3f365eb4cef2a3ce32eac5e3e26691786a677c314ff4f81c7d42d282d881e45688eea927e0a01d4484919dddee51cbe01f2a15d7da5151eedd8fbafe5f8b2a9b23ca9ffa81f86fda9f512c99b536f773f59a6754feb588c041ba0aa6cd7a514b60d797680de529e60b26ab42f167d0d7c7d496b8c189664e649ff55e6480a73470b64480ba4b260ad3fa8b01354536761ae3a9f5226f2691e24b9ae1dce2ba663ac70d38cf8036714cab2fd10525640ebcdebb67b428feb27ba6844b708317ee05bb72e2c6a55c466f77d1d03111d1f0a039dd05970aaba98f67504d3f787d79222fa3cd7150fd73734a6ea69c1b24fcc9db1f092028e6fc382c7b8871335a9c511039c884f8aa7ed1731b8331ab99e1ac5d1e7926bc0143149df69265e35e72c667f92d63699efc74267887383d3c9d3b612b97170b81dc2ea9424fd9149309eb7e2e99e9177bb6b1aeb5bd9022ef446b6fdc71536b5359361385fbe6700b9edd2a45897d2c728d00367976b089551a4e797934f35ff7e83a0c56af2e25540e4530e91dcd283c01e4a5754b98c6e867634edd103476bac2c36077cf810902be101aa68b2","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
