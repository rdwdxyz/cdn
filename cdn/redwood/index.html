<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"3773dd7a2dcb45a29a6c3d30f753ed4167d544edad233ac4e21364e88d8d8be6d3c3d90653751aa1ce4d4ad8739ca240e1d77f46653ad33f8f8133a31f839508aeb6f2a54ca0c00c08e31d21ac5d2414e910f8b72e80659d6724e7e6b152fb8e85e5e5efe1f52c41c0b00bb8e01081f58e605a012bcc6a3a36844c851166e067ca5154c4c219edde3b3fc25d92409c7f6417e164f4ea24d1e6a2160526f89063082f37aa8c17ddadff42e884ec892fea7f581a75e06c2a8fc6fbeb1e5fd8cf82ce50fcd2c2748b10bc74d714ba32a35c93b52bef5d653dd1a13cd73f5d8f3ecfc73823d219f19d603d7bd929c5473bce9b1fa936ee25c9e8c3d3b364a47ea2445dc3f5b9e7c2299db8f6829f85b6cadffd3e2f1b31c5694961326658cb2411344e091f5790e3ab2ef70fa6ef971035217bd7ca05fcb295c51941a9d579ca42e1bd8f1d83aa798506832f5074db8cd491f35a93697537857a8dc826878bff6713ca155bf42540d3bcb4485a6954387eb41fe7a8d7bc464e16c8ffeaa8b4495edd638f1b7d9932846faae997a8d3bbdc58b1684d3e10931b935049ad8cb9e161d5c4b5b8af852b408cec96a1e681275ed289690d8e12b456f520cebaac238170035e4b81b1b04c694c5b42e88e4f5ea8f14bafb9f7ab6f88ca3931152c3b6a28b7c802a38bd62e406e6f087a99a922bfca41f60b7c4523609c6bae6ab4e8b1afb0551c3da02d0f5d3bd4eb298c533ebc1f7cb50ab50862e1a213823032c656d48c2c11ec5904239077d15331fbf22c487392bcceb3eb33fb4138d6b553a5fb2fbc11c758e5102c435dbb8cc667121eab3e0a3d12faaca087f7c33948138495cad201441b9b627b7547a37d309804de035d568001696620900c482e3d2ba0681d65f7eb0263b24d1fedf52d434012644882ecffbea1c01cff2cdc6138baa613d83d0096991032711d575d7f346585a0e027cbc66b022c6cf2eab546b1521a1f58fd21966468bb1119510e9b94dc4e6cfdc06770cad507e4abfa162cf3b3836a1921e9548989d93da3e851bf127827501a53eb5854a630fead33ffe8a946f4db0719e6c198fa74e109b06385c7f9ff12d5446535b966c6019c6047ac365a1fab88dcdd204b72ab4fe6edb78341c6d09aa8b38e94b0232ef4666d7221cf0fa7f51c2d1a49f3e2fdf6c6112465858fc598c033611e54c3cbdb5ec4e812d5469f7fd41b56cc6197697d88efb575d9f26ed6d1a3090aabab00b007bfac22a01a3ec12fbef7995df628dfae445a1aa15345d46bafeee2b54d8c09dd2dcd18d8d6c71a812e09901af55a9fdb8783a1af5803e7f405ed157285a2dfa23e1f10631783b574ba2160392675d169e09efca358c2b325f5c1a737d47f2a450f4e3b377b63e36503ace448b6abb4d7bd0c5323f88520e169dad230d5c9107d496ba697c608f8f4235dc6ee5f80978871eaea708a47d23719cf7ba4b0e9b6a24733b687bd57b84798fd0379366e32533ecc0b2016d3518f26f09787d776b687c0aa211494ee0cba95ff87ed4e7409615508228d2caee57492bbd8604f569582077f1f82fbe7af44a59c3e20b1e8afd0429dfe0a965cd797d85e09034b710e7cef1adb56a56a47d35ea3deb78be363c89eec5fc34febb705f69ebf60e574da403cf774edb29de827044aba92b21b64152bc29e46745ebd645597b93994d957ec9f88c6a3efd14a5337f0ba74d7b5af4579667bfad2617d619786cff7991ec9f29547d531ff0eddcf1c8d1eb1797572436d96c1323781b37e4b8120723e5f2c605dbe447f6de2ab6087088c590093992a76d3fcbde0e5383905f390b126c5a48ec8cd724331f5bbe048aecd2ae7b6cc4c86aaaa816185b1d98d844c2f2be4ac97dab9763a3c4d0d92a4fadd1a7187df6a443a250e6a1bfef230b5b9710421db4147e314f6a998aa49dc2878eec910fb58768b319422ece1428439bd4a705cde486f87d5239c27687ef42a6127b1f5bce8743600f4bf5fbc29de2b7035dd51bf97d0e026ecbf4947015fad98bb60cdd16e017ad47c482a45213a70295e3ac891dd83149fa98b7050e815bf7703936a7c9bf8668e3143f4c1852d795b517cdb567c0420c18dc43ea0e5125ec73f59d447fb8abccfae794ac97f33a939d298c7242717ee9273aa03a764772e0fa4b3b817d050ed2fc86868daa6745537fff045b6ac69b1457d9638be16cc9254bbd8f973e93cb9d4af74cf9a1e37035e8e152087218b64927a1b7bf5431e1d0c7b14ef63e57e1b98d2c6bb066aeb849808e393bc1b30cacd04480ba6a4dd4effc806e7ff1907a92ee653af0c4fa137d7ab71ab8d2e902e98daab1f9f715d2c38bd1671d7a4302587c12e0d8ab3677dd6f7b39d774e83dc81ff31c248f0b639e0047a16255ce36a1f8ddddcc8dce420dff61240da9e0913f1775de2be9745129480227ef67db1e058cc6145db1ff4827251e5a4ad4fa75018c516eb0f0679acfab1f6442f16a0cae0089d0db79fc3bf7523ab2cf4d6578265567556194bba5d7d5d1d16b86ec35d4259ac7e5210437b536e676d98f73f65bce9a32861c34ff4b95b805e6e8a46a0d3cd32f8027865089f1596d80615c70ea0fa54a53e26bccda1a303f7c6db1245400cfa57e99e28655f383cb2cef111212899e4bf871f76ff7b81bfc590ed5b7bcd7be92f600a4b2719f540f99eab991f1b68fffd8248f487a2a34594486c34bfc233e845cbcee3c0e760b25f91217019910cd20e620ba9f4b5f387262e43677e55f81ad2bf78735031f43ca54c8cf1a3af90a54550cb24c6cc64a07eb1010b2e5c45e160f96f5032cdb2fcc10da7713141602a3918cf3d7da809ccd7f4067bc231121c3632815331e72525960a8fdcd305c75719262c97864be6a0c0ef8c5c5bfef05034a242cc8265c29f68f5bfd468bb5b250b8b0653d14bd845d0bea69cd105448c95c8078b9d863062c42bd6383a7b59c2d2c640370e11349df38007e624615185241342db64f58a2af62afefbbd3a4c2be94e69b096dbae74f1dad4d551a91e84beb14a8664c495c74c6d2553a24e8329b6b89bad636ac12c0bc1778c1d67874bbe7ea899961a95bc812dddb19fe99aae7b962e585a619b3cdc2cafa2e8eb4244a21a407b0ca3a3231436d2da659fbe823e1ee9f4952ea30107b82c56c790f5db4a0be0b949c7107e836ab5e6fe3e8f0fc9bdfe05a1c2022d19c8a9d33ccb72a959747a1992f74ddd0a2f37ad318a4ab4ece28bd82b19b575a48fd099c05dda9568b56d5af36a52ca4d1660350a545aac7e4231fa5a72d328bd9bf2f285712e829bad7a1caa7b7d73f47c432cf5e59ed38af3539cf24a4b60c0216a94adb481c291172bd22485c11b24ece9f5db4266728637d7eeedff1651149c060294672762c2132043578b28ad6c95198377285db97f7a0f4c2b31c8983f3dccb003d4e12022f1bfbd53a74fae082c2448008a074f39a1cf123fbc8b3b8b06265b55e32b2bd5d8d99372172d01e3a35ca93166c8b68ff64d879e655b0897157c8b428a56a53bee7304e1e18b112fa535200f1e4b6d90730d7f676270060f913bddb7a156f05ab7502cc11a53f673853ad76b05f34592526dd325637e18c56d304d8832cbe9325fb368df10b54214e1017bb8a92c70150c3f1972ea1bf9ffbb77c7bdbd08d0b83009b05614c1275c3a610cd6d0a48b4a288ed30f46d8e963bd118a95e6f271478a9d8cb2248d95708b87284b55305ee6b67a5c7246f0e7df26e451c937a21ea70f7f3a1726e6df14d932df1f8ed47edb541bfe495c9958c76fc74f754b2b5fc8f4b35f115966147188adb5b89b0cfe8f0efd537c97732d7172d0a8b1007936b9c9afebb9094f6d235fe322d3143f779c03b01ca782373715c0b6d801a505f74fce98121535c56960dbf5f42432915b57c2fdbd55a928989c37f57574da87a0c97ca8a12c9ecf306dc020862555b74e830b2bf035697bc648f73d7340966fc5aaa442f31efa7f6d591a1276eee869dd752c161a09a3f94f9a056857e02a456349f911c0b59b33d08c65b817c79d419e89fdce820ffadaa602f2dd88cac4b2e36a6b643286a4d43cc7f916cc0ee5064cb9732c0ed80fad2aa24bdd8f5167e1ac9e7578021aa747e806406598fab5aac7716a71b99976c4b0a1b6ea6be74a2e941be0971bfdc735fa4fad22aab23043c00d387f898bca16282ee8d203d5088ee5f2173d995663813d7b39d9a1fee212badeaa5cdcb34c3479293a259c757ab4401442e533199264dfdfb6dacb75eb83d251401d3391447ac2825c30dd8def4c2437a3c5466ec5401b27724cd64d032f6bde21fefafc7160b2a9986d32531d4aa9f6bbf1b75b95dea10f7cc9bc6da7a62918b75f26e8d8786f0412ebfa02bde047977a2625b0ea006021e2fc70deee4687505d6e98a25a44bf3b8f5fa0796a2a50da003295aec5fd93a26e4ffc7a2a25858b1279faf9de72409219411c7a785ecc78faff6f61ca134fba551e0a938ce37b2f84820db42c0a45e81b2776a4a02ea813d69fa338204369be76032c56379be2261e949af320fa16b859e549d4e02ae2fd234c02587292f9ec4aa3edeb5f3ecd5c75799161c905ee073876533304250166ba5fba1792c65bd22854957cca35e33d6129a9882c2e8e5db5e3cb56710a524db4201db232e6f152478ab9955d8b5678b032d4b7bf2c1a9a88bf63a856ae6029fdbe9b117bbbe8d23f3e72f6e23b1e5dcd667d6879346e173955f5ed287d697f36f1e88e88efdcc8ea8b4b0026ccbc3d7e937462425d8ea717a64ad7b19ed586deadacc3f9f175fb159aff14179653fc25934a0986f3d68f4d38c2cdbd53d2e4afc4b7be0e0bbc201257761ccee80febf036b3c72c2282451e195ce9d252ed19c10cf9306ca5120160b0140bb728be4d0588b15d716763a7a34e2aa7aaf5222dfe710ec6fe5e7188373b571eddbb60671aca11ed879a9f683d45253621537998691d718245c0d36bc2afed3e91f3a3a46fc63a045b3f0aa0c79b04d3c2c33675895c4f5b39a8ff959228b7b62dfb7a1adedc205a0243f1c29b5839565321f53f2d3b759f3a4a4a54c536c130c12d73442ab3c40c19939914f937c3665963e6df6958165355e1cc5f68e49093e79bc1dc9d2f2b42bd5c591712f1fe19659c0a3fd1b6c139b32e74ba8f6cd97e7b425b9ce0d01562d3653bda67df5bea91602cc35bb5f7c981208130b3c307f59c63bcd26c252e7acd41954519912df0e7a264753daa6e5ab17e65550e2ccb2fac8d1e16f7094d4e4f84e4ccab7e7029d5037299e18e34a2912a0119adb0b631f00bf928de569979764f7e823b006df771cf12acb1517e6e66cfba03bd4856d821f0e4c7a5884710c4cdd54d08d40a811b126556fb237d4f65c4f2b14834a6fda814fffaaae2a560946dc95bd6bc40a40de1f78f45247ebd646b3e318a2e9230e4bd2176e868569524da40d0f3c423870997ee9be6fc08d7910a53a4bf7b1226b4fd590409d927c2d6535d764a123a2e0dcc802ffb7486ffd1c64433ce2d91985d4b28f9dc54179646f574307519fe79699a1cb76291108f2c3b76a5089e2a653bbf4cd62b35c44885ed3c981d2b03ca9370dda972db0fbbcb3a2cb348a3edda1d8b10b136dd14bae4d64292ee56df7bd6089601b2e9b78cb237e9bf9e0ab8aa5919e0619e29c6149908d623d574b1a6cf183f20c95a0b1bc15d674eb5f7eed0b6fb1781b1dca5a81bedf55834ef1feb6e481e9aea8ff1e82f3bf04711742a0772769ebd8316e183bc1eadd4558410f619652835243b436d14dcc22e5aa5b9ab28f6144618e0816079e47cf8a1d02679e9f85d137ff654f5909fe9891d2712bf194496708343402cace21877280079b1c1ca7fe5b3ed46f8aa234b06499d10c65693542dd4e5de159487ace276889fb7421abe71b5edc2a75b28395903ce637cb34241fcc618571317edcc1b897d6c0a74beb2ab76f09caec2e1aa1b21faf65c0be8b31166ae3888ec37dae7eba91c4c27b6ab8b1d79214796dbe9534269c5977e372677732145ac2c1335efd2e7c847bda9dfcb4facdf29ddb1ea6ce3cb516444c10bbbd701db1236644a3956221a4c5dd078ea746e997b30b5b7a46181912b8c4362860244f513474ead6f9579542eef006cb2617fb2c38682f02255a10f5c3756c752718dfe49d41f0a83e0ad40969b049bb60d3481c58f648db53a9b197170793a3d99a260f3cf6f5aca92b2ddbd9830e51d99eb6c1ecdbd6367c71024cde7f0f2c040ecd37805fea891f7cb8c85fdededacf3751d2bc2e8b2a311a28f1fb71b1d7aba7bd6ef53c8b793742ed3c965ad0993d51a6640f1cd47f5fafa62641c315e9760b629792d045c7c88a3dfaa73927bbf1a4f830ded87277279ec709947d539dd1eb8845125131949f7f41109ca37d64d7dc57d738fe221fa07f841c7f15ee6b21bd446e186a835d00a5d51d4bf9e18693a4c616740525a569737eb067f1911829d3462b63d6d5880372bed240a156968bb13df3595022e02026c9b6cadb6199a578072e8ca527232e043b3391a0fef92c0c4093753e92564b1a05e00d35e9c9337263a9aae2fdf5adfcec54f37cb7ea2feab9083bb7ce9b1f6fc548becb7dda5422a3701f01e09f2612ebbd1ce5040e93dd8081a8d0e9d96a0e770a8ae3f2478b64c0d2ac42dbdc3b2954e09436ceb485d59c2080ee4c77f92072f2afe8afeddabcc12bc105f0db3a2659d956b3433683514648ad2b5b57919005d27a9a91777366291cbd73803d871602444f162217080f322469ae5870d94d437cddd9f95e00d4fabb188da1851f2fdf24ac4a92bb4cb2debe90fb7be86d4b756d708010d99f141a3e5108e1b45e31281eee33def23415ebce26b56e8873601d09d8a9cabf4bc86cfb84abf9ff8bafe8b4e8029f2aa68742e1b0a8ae9643ba8657ef8afd9cdf1cb0b79c6d6e10386caebde4b069f34f6c6094c1dffbe403bf9aa91838f5061c11333b635afdbd7224225ae0b76f81752e71c93fd63940a839a230a4bc85754b3c5d64442e9fd76b810c231d597c443bb19a4f4b4f7051855228e189d93dfc51f4a8416290d8350310174ee2589c0e139bcb01b0c7c0870ba456e22f92b730b196d84e516faf6ad07bdeb5bf2ac4092e32680731fbb764e7523d543c38e6b335190aa0096fdcd6c7c7cf025f2708acfa60632e946a9df7f3c574c11536a7f752c8033cc62ff6121a57a4124211af62d32f4e1748ce8ebcd0026188b4be4d6fb7abbae184a1527d9bae2f533b151b5a3645f0879126440cdbc260e9c43fd11acc1ca0be217609de93a807f4adb60658c5d69d2479acd38a5f1f4817f06f46b265a68ce72189fa025a25e7195b3b3e58d838f3c1bb0a2227702ea4f206daea72d1de08989718940c41cfcf1126cc5e73fca29f48d8907c8fbce8b3c36fc18da6edd4c89edcbae3187ad05d1efe019a7bbfb1d03e0c0c640cbbd03e0ae48dc6db2f656c436e8451a5a8a637cc37c6ad72eb03c01044f762315a3f6e1fc8f0e521fec80309e8ff0f391af16186a5af5031646604dc42973f908bbf4e1fc75ec86c787231aab48889e0502bec9b4d618fa838e847d2616cfb301c99c14113c376768053729de0273cb3413ecd499bc357607104fd35f9dbc2dedcba55d4f303e9a495ccfcf254507f93c67bc34d1a87d72050ab9613aec85f378f25080298fb44f45a572548e2bd9e38651d33b5e2bcb0547f09461e09f78fc415fb11a59f0a277a337a26ba069f1bceb9b512afe2e1aaf2cedd78c3545978853a4e0d9fcc4db7a51eea5b9fe83d2bb73aacad5fcb1d2d4a1d45b9ca7d571e65e135733f04a320e2b2fc95a47ced1adb66d1a97732b0bb8d0dc6b7038b14dd870c41d39c9bc1e7dcff22ecfd7458bba4914719b4afaabbeacba8668cd62fedda31266ab7f42b67a787199ee82cc3d2d3cd428172bb520367c8a46520134652c0bb858906c331361f28e2b8c3d38b3ce1ee9f453675b2d945562daf30b00a84f7a96b8e4b5e780885b36d9422a7525d5e47532ab7c4e14bbce183c18119bd367a7d62488d3b3c91fdd7cf56b4bfb3c9ada20fcffb7a1d6a2ebd391b7b0ead57beffc387f9b1eef054226d17b2d6a578e80ffd1cb5691ef1377f058ec3b31337524da40cbf6b9ab717ae9ebb1619bea8bae1f90912b8d22a1177ce064be934aebea5f9f8c8190a626c7687c7c90a31b3761c3bb497365740b14b1c9239d4e947bd77f560f69c5ea11bee617872d97bc29a24771f47497c80e9a8cf85edc2054aaa629e56dd41b3f92bac25d9404022cce04aec183ec5456b3a36ebac403017bff9e423297774908f933c14e7c1a16a4fccec9fcd99e0c39fce42ad586fc7ec2abec90df30ee74a4632eede905d974e1e43d6fc5804fbec30de8375f609e579fe7bbf8771c79f353a6933d9bb6e44029d260db27f378483b5fe1b664afe8453c275069f0d17c3da5cd3250ad1b85bd57659b01e4e087fdaa179dbd0c0fddf307c65adec1e52da83cc76ac9ed00050a0de65a4686990afb20e8b253cb7a4f585e134d4ee80a2cd97cf0aa9fea04dbcb0555bd11c4cdca8d41ef8e6ec24a9e55a85bf97afdcddcbe706431df6b4c14b8a8ed4cc1eea29281e8dc8871bb8f74d76ecbdc3a514938001a8deb27bf267f41bb305b86a8a678deff7fd6abde2939f605305de980f77921e71b159351f33d1da4e4ef6b98c6ab6dd065114f63400b878f22275ce7fedb00beb84442a1a9ed96ed80c968111910701f50f21d9aa9e372c8373f5bcad2f9086210a225ac6d5cc89d40202fe88b5a90da40db30b30d0b59a348bb4a978e32d8216bec11843f7272c07f42118784b912dcbadea791a022d5904402d434544827ea2079ffdef3d3e1d5ce08e76f73c0c615f9cb38dac62827be35c2dbd3ddd9ae9799546a48251cb7fbc9dc6f0e72c05cfe18866b55b0b87f185d6845584e66bd2fc8a4aac373bc44617dbb62b1e69b589abd45de88d8791414317b6b599c30cab6090c402e70b96454316da8775bd09dd14f8d90379dcdf49926ca595c6cc9da145a5266b824198350f294db9e540bcf1cc782ff395a0caa9760a53f9156bc87028236a8c75d34bb8082df66e4847e0dd92017154503dddf6200abef0143ae009666714c7624ab928faa22ad6d3e00de669afdb70aa2d7d3aec04d1e4c3d3627797c55d7759e9f465b86c63f6c0d7f49d6afe3c1e24cbd80e309a087b17f6d7cef6ad4f16db680566697040d8a6315419e744719953b0d510b29b77cde92adccde5bfac83154a2d23e590c6fff7b7becf527302b2ed4b271cd7d7aab285de15bbd687942786b4366b8fd660b3d66e49b518986a9e63fa43109a27d9bdc4da811875fad6c29e440079024f3317959cf4a1db6f6e0b344d9c14fa3959031259fd3ae1d6612d2d70b99df7eb939bf47430842e0803474e717b46744f1f867822299f055a3bf983d4d3fc47f65e108f69ec99ab9b9b200d9e0dd33b43ff0369a5e675375372a9c4b56f1331f23445b1c7d1290c834ff1f10b68b9d9565ae24dfb21da002f037d9c452470b4b600ed848a10606f9cb8c3a10748acbd50e7354cc3e7cff1903cee87b73ac844e4b6eabbc691ff519e7cfa7ef21e7536ee1ba862c580c39e656bf4477177aea0531854badd0ccb6bb48eebf96bd1afc09dd37947baec6b5acb8dc242920b0f5ae8f53b667537b111af37970a10779fb91b4169616b3383d1f99e513f2d2837b0bfd9b24fc03538fcba1920cfe886d49ca25a2113a0ec9f330f1d03c2bbcaefbbbf2a4a394236d8ac1984f768269d94338b771f50bf6b0221cb0afc484b1894e3083602cbaa2cc280fafb53d932fdd7edee89fd19f0580427fc53dc3417f4163f767770480c7f45b8166ea1a9beeb6d3d32c84ab834ef8aa45a3a06695c505536f3230e08914327d63a5b5afc9871e58547dde9ce43fc8e9951f6a7a95925631ec7b90b6024d32a2586eea4dcc2ec589a72a957104d08d192879cc11edd78417683ae9e35d6d3a69c8fea947729f7b30904fa854a695ab2c4fbb8a8bebee89a4720fb1dd30d309be877e47eaa65bfb6d9726a36ca4be5fc08c864e37350fa9c6d5044bc7fa4a41a2d87f96cc28357aabe74ba9f758c3f8e6aab1338cf8283be828c0f64326bc2d7b52a71703f91faa53ed2e051320740eeedd50f500582388ba4263670ca19225f10ab8be77ebd3a5a6dccffe978d1fdceebfec735cad1320dd1820292b59518d4b0f9eee6a75481b12fd3d001406af4f6ca59ab4eb0c1427068dfb91d68f2988cdc2df865b386e6f366c79b1a84c88fbfcf8a3efb6fb2b8c2bfb1114a4a044d47b93fce47f973bf2c6187131d197f38fca5cdfd55fa1dfcdfcc979e41a52e2117aa7f1f9194e35e474eb0baee48147420765b904e95e380c3020f936fd7b6bf9695e965fa2cc03b0e127c6876343f5e340615adafbeab02cc24e4bc9e56004b63c18d57ac3aff0c197000c795b2d5bb0a121890846ef408eed66bdfb47e198c915fdc894834cfcb2fea6afe4f41273de24364b027638d49b153a12928627b91ef711ec9762212325eed51d4d7bb4808939573500c9384d477ee6344ef4eafa13eb0d52e02362bb1a8e0442163afd57358fcb6c229e831ac8a6a4e43fdc2a60611b413d12c9660853c8a0351f2202a46406f40a02893bea76ff9bf6573ef2f5ed17b0eeb500651c6334afe53a9a8f9d19114aebda3672d4f1a4d92bb619840bc6b6a37db2d180a3f93836a87c1dfaa5d1cef8372762b2c2f812d0fe834d539df48d75b20e768386555a9ba80fcedf2b599a1eae48abc636082f18da25da7d77ba7679378940754b31b2bb165c15ead917e98342618cfb55bfc9a75498b493671d2a2e51c46761d22c91f8efed78881ebdf2ad0eff0ce4d39025607894e472186f4b8053641b634d57bf3dfa011b16972c886d0989a17927a5a8b39f06a9e9be80cf41df3b30d3394fcbb53e61af4188faf47466d96960c0dd2b5e85f368c68ea625edbda31745a76b87b910bd19ad0848f8f12cd83fb3837f406e1990c6dbf6820a50c03bc39f2e4369450651599d3ac00b7864677893c2aeebad69fc910c39176884043173d6ca51c774fa2b7f7c7c8ec9d955b24c2b03a40e6b3b80dd1480040a46455165ca6b2cc15cc6577b9544ca3ee7e6d8cb1501909ae27795ce5579100ee24efa4dbc39a40904684f5ee59ca98f91c5ee295c215c2d96285ec202c1f22268dac6ea04489e6b17820e30c6334332a1cff892b31a6884414ac1e75e45285a990c517a3a952b38f9da23fafc56ad15dc590657e4d3f42842958445546c63cf7baf8b7d2ebe4b34e3e30ce0a7e4911b826cba954ed9eb2d832e899c6a4033069d49cf208e8d44a045ccec63cd565cbb82e5f27bd0a2dcbfff23bd89ea5226ebd0912471bb3d956fe65b31da2d2000ffd5f6c586772841f11c7f1a57c3368fb82258c978313a9f85ba8d7e99533200dab43e61792eeb9c76f5d8fcb8861850ba682ab882f521f5749a4a377bd2ef4ed9c4a9b213b00d6f50cf1232adbb05bdc8e46cc78c28aca0b247bb61a4ace3a1d3a4abf3818b4c329310d795bc103f7df32e87194dc37e444ffcfcb7096353133a81a74cf5dd2758bc7803ffa80e371ed93d595a7558a2468c033bada900070156d850a33446a7a63fb5c1e8875a0dfabae7e36d4222b8ba6329f31ae9d2c5b2a07b9dc109451e40ea449a8ad7696138b5f8316669e25b895f23aeed35017e0d96c25aa3a50d9d4983f2183092870618325b8f0546b79c17116f5badf05415d59826a49de73366d2608a7ee68595f28175850b9aef048540450b87e8efb46ba443bfacc3532e212a528b41fc449fef9297d6c40b4954d5e3375937f4a6a85a83d838c2c5a3b40b0adc5b54d5604ea2542eaf33c3bf9da0b24c84225a9969bf5e2aa309d6cb36eee9d060db3f34e4a4089dd665820453bb7dcaf20de7470b23262a852746b185e2d3759b9aaeb68e5158a9e2012ae6b13bebac8cd88b0b4941cea79b3ec457f3d2bb5406a781efffb3099f16cf4a93b4adc8d913855cf5b2af4c8653831d614ffa401c95443687c9cdb47b1069c850fc6f1edabe0afec885c1b7889db19c70bf59447db8273568caf426756c72fa4df61add0133516f5a3bf5274352376f724d0bb7d19babe54a075b0f0ade17bb57bda61b561af23861c00fb781753868b6b385125f8fb7812e1fd943ee5ae0f7d643aea425fd0c8b2a1b00260546f588f9b8a0829fac681d03a86d937f75ae0590f51f340272300e06020a72bb874d09febcd5e255f2b02b21c3f06c056e02c2f7f572a80554228884918c145ef25a44f55b9ffa22ecb7cdfadaee84164ccea5c5e73a0760c7632afe2b9dff5f10ed6e6f7a19b790260d07908082a6e0066677b20302af4d7e0a9d0e8a495fdc17ee79cd428564a2a5f545e7401d1083e6ddeddc27be1a29660653ad89d717b62ed2c4721bd570392ab5abc63a303624ecbe94d9ab2df5f6a53e6078fc2bc4d653385019a2403db82e29ab396726c3847093c5ab4cb93ff7025cc1cacd835225456601a2cc27f544b776fadcc625afca17127d87a0707833c06e3a7c7aba722587983c115b257ff02ab32a5142637ee0f1a73382027e056397b3a472e6bffb2e48d8aa5dd7a14f7fa7ac6bee19523b1166005e929e27a2770b6c64d3627867586363fccff843400dcf943ebe92ea519756bb660ab362066b5f05b3c7dc2e6bed904ffdfb25896796ee35de86d35277ea2df8664f962dd02b9588325222a61a0abea5857bef2e565531398a8e40793357772f5b86a88c4e07a3c53ca2a8b386e78e0ad12694dcc5e7c03c6edc697ab5ebc2039543b12ae92251b4d9e974fa3d0f65f1bb992a06b98ad43e9bb835daddaf0e67cdf09c743b24c7ad4eeb5f11bab816e259fdeeb537c2d443a0cb5a1384e96d3add6f1563ff20cb72fc2b850201e13e344f83e4c75f277a8ab7bb1835f47af97785e6cdd6751be437a49da0bfb3c075c2a409ea31dc737527c519440b61e5480e7b3f606cbf0ed6f321f759ae0a1faa094fb90d82bf24641ee82dfc05770debb29cc017c68243d9732ea12e87869474b708f7a198e4bdb53189c1aaf28d8d6df537903147af502c78ff20791f34c7b749b0d1c3efa843854231ad5503cacb9d46f2301f84995775f60fd70a8012070dce1abdcea10e1e8bdd48e57dbaf3efe0f5c181511921961997e39ae9dd83f368a117cb642ed7d2edc34996004d2783cee97e33b9e43033a9239f40e0e0210f0c12e22ca7ca5b66ade9934fbff7436b795e21d3449881c29ba46ec389d222ba395509aa77ba93264e4f6ddbf37c2d0e6ecff9ba49f1c37c1d9b5250356a3fdf059a3e0e212153aa05bf6f38f3295346ed7bbdcef619be097e017f27b6dc87c04917cc1df13e1ef52b846954c0b1ce32728cfb9f94358d134ba9097bc2b0b29d0088e94fe10f35449540b2bff1eef080140d21bab1b052740580d576d0269719de329f6f03b63243060868afd3619cab59431ece5dafb18c09afa4cfd22b1b2c621529cf74adcb5e9d32915e8c393eabd3d3d761ca7ce0a2349430a6a9ebea1f0c0a68306cea307faf5f6b2a864f5d390ae1967423f3ba3b9eb5aea86952d399de5f9d014ec29d8ca03eeb6e54dfb326d936ad5d02cd64085554e3faccdedc47bc2d0e5e45369ae43677cbb46e2c60d0e4b3603d829619d5ba97b0ca9df74570a33f4c371010cf6836a55bd849c28727bd853ab88b146576ca9475044146a5444dfca12dffc9d07c1c3199f0fb2a3e3a571f93a8d1b833f5d9e8732ed022550bfd716c3cd0b3f9d86af7a0fce397e0bb989e798de9a100f1d3ca1b30faa98382c09c592b4f74beaf64393488b2d845da020a6b53243e8adfe12b957808a897a2ca75d9bad59d8ec5c6c2303db42d3ce761d290ffa38943d52656d5a43ff309abc3f0a54579fb7d2dc4035da652483e3b509f0ceb44eb2425a2463da51ddd1dbdfdd5fe65f1ff41142c078c3a809ec59097f5dac5541e4e150eaefaf63b8946fb29db1ee5d1bb7089f37ef1d44958c0f9438a45b5004955fc4ab46952b4cff2755e626bf5d20b70f3a7ee2159c1366b117b62a38c02412b71756d1c94b6476d7e8ef9ed12be0fca4022ad4aca5a8850c9ee6dff231dc142efe3370c56c65f74cc2e1f3b01520687b501dcaf880755962fbdcddab001b5cbf05025a5458c46e060479011b30794537e3f9bbbbc6465db9ce75de0f04bcb3703579a5b461e69cb225ca21ec397bd976182c40a5879381064b78ad172802fab9342345cf9a0dfc305c9dbe1ca2c06789f2af76e009156e87bc4055b10b6774a60e8fbf382874c0c65887dea411293e51809719a6a40a097851804ab3e204bf307be1949343a1b8fd8f4991158b77fe43baf18a0dca608b4965d51c460458c4f1c132cacadb97e1a3d2d5663d7b46f0bd18cda1564dd66e7837c69e29afab9f3b2dad90681ebad460c48e80ab329d46c8b44a1e7d1db37e17d5f9969af6eee513a9f72031f4932925826ea97c1529f3a1aa29b9cfd9a0d27d99a2f3322fb5953a14a5e5a80a211958b26071359c48738226ed7aadb645f21d46fa5472dc684d0cef7cf236eff3750534cf8febcca7575d31a2dd800f504ad10e0d0822aeea4deea14e5bb535c27323d2c2f6f03bdc77ff8ff6bd63b1feabdf463e2f4101f436ecbec811fde29f08fd91c428a413e50e583b2da60ced7b491f046afd4c29c4165c0a1a378dd8ed41a39131a712676201c2f5794ef6ecd245de589b2567c062c4062fbb2bfa5064d339538dac71b70f15968953b33b7f01107b54243fa1e41c73c606178e5a9eb4676dbf48209bb416ee85d536f5870696e2f511bc1516339f7ff479d0b37d5b06536006671a854404957d81f61ae0d63f419d116064e9e7277c4c56fc0762f55b3a7fae8b2d6d942f9df68547be7e30d75088016be99dea46c7cfcfa12cf78a4b1840b31325365a3b8cb313b74d4f8745b303f1a1d65d91c4ecf406d0a70be76c99f88e14b153130edff08865de98130534ccd28c44efab8b4959f5a267243c10e278efab1826906d1837858ba177af9248215e6a10463dccc4f0473341e7c432cc049730ff0b79f44fc69af53b0794315f22fd729090123f04ea383574af4516d087329752cc1a89068f39e5b16ccdf71c8f6dc99f907e2b3576a1e888144c6e26a67d2b99e083d8380bd5879d43bc89ef9e0274f9aaaf51b257e652080dd641f55a08263e245c7f9b24c8511cf9486fc1b51f05129ad2506945d0e7434760777e79c30bb46acb13ed8ebe53e2c74a8cbadf8354e09f6dda0ca0bb5f5c0fe642684856fc5278120a6e9b57b95e9b55e39b9bc2a293ebf71115a1c05f315cb07ab99b2181ee50991f4dca4a5bcc8038efbadcc91307bb8e3b511751d843981864ceba73ebf57a844c24fccc20b93dc2ca2b085d8687006a5a1a1c7db653f7ad010790c0a150f1755d86905663431f47706517db0fe4789d7b99073a95aa9abadddaf7723245418adcdd314936b2edb499a4fd307588eda71564fa04e1b9377076cce9545d078fbb17cbed00a957345047141e3533adae9621571f19dbc74eff7318816ab41284669564483b80b7da9d41f4ecd6e3727307917502913c3589ab690b6f28814e9c22cc254399c542cf8d9098c05d0cfe680ea5a30a97e2b605b267056229894099749b1197c19207983ea96fed21adba3efd9d9f26797ef789a5cbb8f3848e966efe6bc9bde9f95b6741fb042773d498f47f880f49cefcc7c2aa2ab42a4cc33c7c45c7220463151361aa268900f91e24d70dec11ce75611700035d2a34ec30835452cf7be931dbcf2b0e7799ddf2077a356bf5a52b49d54cfbdbff05b4c812b6f493254ec96da12ce2fcf3f7de123cfe99ad9b5f7c88fdead7401196f69e10bde7fd4bad7c3a1de6f7be539ec858580be70f5db30b64f11e78f56ccb20c3e3f4ea1f4605e72537daa480725e9a2d689552b08bfcbb7067fdf0eec5cc95f005bd79fe120ee8f0ba93deb1954e270771ae805648b2e6516a659f0f421fcf75f83560233b65cad0908fdd2a7959c098eb6c54e47acb0959e6b044046d5f6d7d48a0ed821872e32466bb2a21a0dc6d80d3e1565403da8db7447398faf680b1272ca03273d1d40b72e4f45daef627cf4f375bc7cb925ca283e7499e15de26d87ff849f676911e050333510523333cec7c86195836904132e3deccfe59539e86ba14700963aaf10862df370313acb765761256e5bc4b6d5d8a31935a955fdc8f2bea7875db11961814b22d4f64a9ba14366f04c2209dc0c7b9cbe245f3264248850578ab0133316bb16d9f5392ce1f12f8cbbad799013ae85d400d6daacd5cbe0007355d00eb5c3f0058d9f3bb6306c39e117ea5436c662d0f304c41e9f4297a62cdc87114e408d839f61779f366ca3d4dcf472a294d97ff0bc02afef96d65621c731de1d3779ea791edf63959fc4caef361405e6597c05d61fe5175f174508bff698cb126477c92187a59c2a07ab39963a152026c09c23d87789004aeef57c2d62fedd3de5edae8572489034c662b79fa1796de3475c05a58dab168a5852f92a00093b39dfbf4bef776b591aecedf1951313d7e61ff2ac6fc1aba6655082b8b1df90703a72ba484360d70bb392bb43d248af2392062d6234b99334dc5801b7b8217e922c58ea7d4160f7ca7378ca743529bb780605ad0f4b36a392b7aadc6bf882f08d0d62d2c35b69e5d0cea63af26cee22f6cb822162a6e9f4e7c30cca69804b02d73b4b736fee761f780a03bcadce07e48fa28f0327c31d5897e297c7783ca6c2dc115d53500f077760fd373cb078f749348e28c135952f48ccfb67cd3d9fed4969a8e86c033be3c39a9ead1a0e9de7fde939f4185c668b35ac888564681ec1ccb0446477963550b8e3f2ff3049f6056691fe0466f40377cd2d036fe80ea43018527088b66f9bfdb64fec5010e6070b1329dab211bbca975abd328e42690e8337ab7287da18bfe9414c0941cbcb80765f56642fd9cdf09fb4e256ea1f664b4c58f0c92dba8f92387cfe5946e8d5fba5ba02645a644efe4d02dbe2791506b84234d845b0a4b91955cb42f7eb85a233508e394de237f8ea6a0134724b2fc6c33ff4efb04b4ee651c5248fb74da533c7cb49a2cea2e97fcfbfcf8c150fe6a7ec18a3a0cc7b3b938760a64121a34193e53b36211ea077ff57667c741ccedf5ceda8e79bbc030b58d68efefe22801c9cea19f1ce88317aa2a80b6af419401c974ed5f045f5e8c43e16178d949977725882a6646f0f2087b34acd5bc973e3c381eae0857392a8623287cb85fbed92d890390f99a612f8e4bf0c986adaa50cf5ec612420e3544a737bcaa60c467a9a036c769c17e3e39798a0939de53623916e2a67f56041377991e5bfe0740f368c2f07bffb5ce92e30fe0e5d359b54fc2b9df939dc79962cb6d1c3d1f45c3c2bd3e55d372a0fe02e641c8d3338f06a5e09004cffa668e28e27b367d5e873d6589791c75d4c192ff7a65f8395f1c13e9912e4b23cd359fd29d6784b09a8cb3ad8c4bedd8e1144cbc28fe56ea4cf0725ced972cdff9bba467bcfd4c13f4aa1c69eeae8d34c07ed9e6b2e7213c3beb8518ad0e1765c8dc3f8eacf881a1e93912a7569bc2a979748b8ef417e5d372c1220dec799cc49ea0d0436d6b7467d29fcbe4ee4fe15ef89a9bd7d6a6c5de2b79c5842764e5fe954cbbbc9b71367ccf3fc5425868e5a1d5fd62b8ff604e1a44468b6c1e094452694aa474ee2ece1e0e8ad7e154bd62a2a23403df8e19451dbd043f7abfdd303349b8b110d948a86eeca2ccf734e5421ebf730da40c43a9ac4f22148c13504668f19f7d022027ab711f2e3c02cab0881a855d87038b9949b0dfb464706ba011ad2eafcc64439","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
