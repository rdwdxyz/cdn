<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1ea7ede17530e45663eb0a4157514efb1c4c799d166de4d22dfd8ebac2aded1423217cc35e89dbd75caed304420730203a9154c12fa1132ec827dcba5b65ae39e5b4512d70bacaed92c7373c564a6ce7ef0b4c1fc61483514a3a6cc9ece14f2a7cc532a48d280fb0ca55e277eeaf6d98d59c21ebfcdcba515a51ec6588e0026282552b4e2f59f78a1f528bf2c8e6c99eeb4389486b9385bf4a16ce848847bfe25ccc16b17ba34b3eef7bba2c6c3eb6714ed579301c959af812962f1bb4cccac5de1573a065289e94a4e3f70e57bed3202ae96bbabed715de4ce992928db4a591925bbdc7e4f1183c64bac583cb92075b64b542a7fac27524f241c2e639be291156da180e99c78ab1d4f15352060ebb058df3b5c8168c6fede875ddb80c2dcb827ea19aa33dbcda6213f1aad5737b5f7132927ca73ad34e1cdc95002ceecaaff457f3bfe62df0f2335596b16e0e7910b6100fb4aa902901b95cc584195a52b7abbbe98a5f907993d74d276126d0ebb8c819d3714192c83dd09dbc2098315051a576cfc11e116e32b1bcca9b1145acc9b37d3ea84525f35ee9bef9375e6ef73efb8c6be08c6f4812bd81f5770dabc4f9814e3585f625fc45acbcfa4a55c11a0eff1cc17affd68ec6aeb4a190662849af7f040b7e72381e284ae49abbd9ac0640c21ff8b817da93f62a927ea485a10128234cf703375c23b3fbe603f0d3ee41fb9d9507f69722c5c01cfa6f8c768630e459f0029f2c78658c85d9a61b8d6f347f4d831e80d8eb2243b3621c0db748b4ab205f009ef77a27147c5dd89769cac67e8066a6d54e438976f977536ee4b0c5a2309ac1a234518f171096e038f3a7e5183adb44396e378951d522dd399080f790359e1ae53c52beedaad15a152326a213850b8626e884396e854170356f3fbd0ef0b4a07028b2808cefacd554fc48181872411c1edb0a57305954e3c8006908a6208d1e3e72e3ab75836c32bb027d609692d4994b8dc6f1c63b9b99d01142e75137dca0f0f4b42daffb391ced6ec165a4edd6cb7381bb105b393a0aec48b6331b13b950895c75bfadbe8129d9b6cc8d4a0894818ed85ca9f80b86f032334532c28b1af00d037b7979f89e360304bfbb6f4082045490d2051f30a3f7e76cad417cab72cc9ce542222702d16a96356095982f6151b1922507c8b2b778a813f652b80b1c83a12886fba4435ebb9dc0b196eeec1e8dacc7d2212dc33f6b97ac0756b4730fbd59ade29cfc8006e2699569c97b3820b903805d5638eb3bb96c79dc1fbac8a6fc47014a91f855a6387dc1147b78c63b977f98f4420a23d97e089082a326ff55e5503fefe2e385372b01361bde70a8819b0ece04525ea1671d1aeecf016cd43466ae9986dbe16ff86be38ed58edbcc213503baa94b52765bb39e0636f30b1d4bf416ed1beb422437d52c96dfe1b42c7aa43126a6d62d24c345ae35eefe89cc7ac99d5374111e310f8cac3662a440a99247859ceaf99dba3ae17cc47e5a1801a982603811976fc6f92f54114e52f01fa1bfed04b7208835ac28244c2d731147bc3047dad4ea45c57491644f1dcea3a5bfc4c22e0885983e60ccf5e239522802d6aab13c71f3d911fc82ccdaf7319710e3f8da6b4da6dab681dd05405ed8cd47517bdf14d5aca81a494c5c95bbd20fec31acf36a1a03ec7c6efee6017de0aba297c24e8af670f92c352a51c237afd12968e848a25092169c2a2ed4ade2022123225599cd80d3f69b79bd4debdf85da4eaf8591a06e4164fe1e2799f82ff2bb0925a6cb765529cf752bd81cd2cff2f156024ba1f294d7200ff106e1d45047a82579ea61e74a7bb7c985d63fcb82685adbd3a0d17b7f802792bddf5e55c95547f498a2b77ef447c5f9e0428c1360948c9cf8c53950645f26233dcf6f98220a2e99a434d71a1408390ac8cc249aea2ac3abde27d66008e770e05863977e62328ad0f0b9ae30e1eb79e5522a5eaa2b1636570992fae83b32bc63f10dc58fe2e52fbbee76e59d684922514ea8dad51d1b696432d56c632f0074452edd0280245178de896482722a326b04a4e94aa706b8b3dacce95f6b303546694e779c7e36800ceb251144a98fdce136b7846520cea206f04362d69eb6abbb59bbb20d9ca6ab601440ec35437ab112f7373536f0f32d614be978f5030180bcb0511a2dbd8db85fb2fbeaedda406a0be7e472b78ada8d51b41cfcff431c5f455bb142aedac573adb3188761d252c62de004072bf2a0e2b6a2f4d98eb198d3d70cdcb97708d633c991a969d2bbe95b31bcd6cc3c66c4ddbf8a3e67213265cd2ab529cd635b32c8e9513778e332c90d8afe6d2ecce1b60c9c2a685a4aafbac9a7967ab08f6f84bcdca57c2db7e2c4df07198cfd7240f69f72fa0077ab480bdecafd13f2611c605fc68a938bd17acdf720c30b01839cabee963a72a628723168bbc46ca509cfc33d24bc34b8aabfdb971437bcf10c2a2ed30d003a8f6ebe884b13ae968cd72b6d065da2224c4a9b1f75227e3e4387fb77ccfaae1d38c92cffe0cefd3ef1deaf0b14a400350c0b37346ae9f1d821c870a57aaa8cc94cf15ce62f5ffcc1ca226700661608ba8598b9e8e6597524f1076e56b591072b267017bb9caaf86bb94e04a325d9353be6cbaacb956ec4f78fbdac3ce68d3d1e927d347d827a0b40ffc896acee3d6c99576da18152aebe503af9a4fcb01b764b067e2e2966a66abc159c8cad4ae5df1f587959efe07207c7ff35b67b8571e615fd641f270fc0b06274d73c2a9450f1c2544a569291dd8834d334eb6c5e4836a4adf35695b1a8401f8e4802cc5f3c627994d5fc1e77cc5d977cfd8b9c4b69404ebda49ef8fc8a60507ddbe5fcab498a657742c24e26fe82b9be48bc93a848f5f124b93ff69617728bd766f64cf49a364b3b411043feae1195004818800a1db8c67e22eefd76f2e41f5ad417e7767a1a6692db359f8b6f5831ff6e14118fddf2904c497a3e367d59a4ed50fd300ce9294c1a23a4bf71ea9cd630568f01878ff5a7034b19e4198fb3b6486564c89478208274d113a726e1ba9047e2fb6299e72644f7dc5424ee8acf4797748fea15ed29c21f4e6293c874ba6ea6beb03afa282049698f06af9a91158b26bfe5d39789d38bb23d45e2a53b96be90b42abf90fdb093662d591a59060f0d57193b809b986a43765c9b0f5bde47882c1f760be56bedbc7289eb6478b02efbe9b400d5b47c7ac246cf67b4039e7e376016d6f2d614c373b46173c46bcdf41ffcb78f56528a04922e2a8a9a73f094463531fb6e73fa1348480ba77fbf46c70256f536eede3d8a79524ef1d74548646a6f6a395bfeca4f1623d57d98dc3ec4ded69a13aa0433f152673483eeec4a330ff34c702966aa605bc1c9ff789dc6d7367013508136e773a8cd1a11aa0fb844caf03c6174e4d2268a2c474e3a50d96f4a8953a5e79061792f1b4e2312cdd78f3c214eec52b49d9a61311d379f565cb98bc08f3a07c0f4b2a38ab636858cfd013f27a50b7b68523731f7252ed3a08ae3a11c7e974a74346242f5db55f61e02ce6b374fc4b37fe6846650f8d0b1e7c802d77e9a252ccfbcb66d92249598c6e1615d70db1cbc6b53d0e93a2ee8d9a20486de03078d8683be2de300d12dc852918b073673a56f45042849188305617fee1fe609c487fd6c943f0c53c3e3ad25d9d5ba19422e1999c412f7cc012221b5558d4ffc89a09e23328d6250569e48540e0d854449d752079f0d0f2e4c1f8bcf0bcc7c8d74014ffb89d5ac8afa10cb89e47c5078be1b3e8da335cafd6e09f27e8162ebaeef7df53e0cf8997774836f85b256fe390b67d041e451bc271baa4807577407f3c9a9ad88853f57639a76ecc3cd46fcfa9fb4d644afdb9ad88a72dfc00859c12a6a85c7b97f29d72827c4f7e33fbbfebf25fbec945108b3b608f46f4951a3176d8b916f9e330979282e3cc5c5ea1b41f2d2e87ebb251088036c7554a766870da41e812f61202ac916bbd7b08f658177830e14e4487f3a01817345c7269089d922c126d6d836ed94ae5352d372491ff7b09601bf091bdca8838b65cc591af026121bae6210f3138bdca4d8d1070ddf314d7f1237d6e0fd4392fb985596ba727b9f80f7341513eb482e70897f7f93c7ecf8191a9a0aa542ecad88d320be2604fd0a781a2adbb2696cac7d169fe1dfeb2723108721e93fa815a6901614eaecd35a321230c0847e8ac3117f6dfc7bb4a99969ba2ebf2bdd401c851dc694d24cff8a66c1eafacbbcd1f9b845d8ae45cba1d4747e1d28f3f1b8717373b697b76348f47e40855bdf01baf4993f30cb6f358af96c6ef4931f38edd049b7f272d8fc7ea91ba40352187dffcb765981b82fa4281eadd7c668efc099b995b22e9acebed2f05a208cf0dd72238aab313d89f0a0861552d5b0fbc22b6cb69731e572515c917c8b2203a95bb253e723a91d813f6bc182e1606527d037c465372ed803be891487bf8fc31a0c4fd37ca36d16ee404020ef4d573c729fb94d30521fc54b90c148c36dcfd3224bbc4f7c57c09c9d82deedfbc63b3a9e5cf430922e9269d9cf536d411f1b27b29eaecd1fb53e7a4616a85cc08969f2166484dfbd2b904f1bd3fc05500d9e9443d74bc47fda6b510935e705eae48442098469ee239b191f54d288c024d7425bfe5c6368719a15549a3414aadc0e4573884f5cc57f83635bc5701493fac6abdb98941edc047852b709a7e713abaeab18adeb5d257c071bea3e5ad245cc545eda1a77bf65f26781fa949a766613b6496ea337a28af3e78361010442d938e9391656ed66eceb87f948b64ce8d33592e841f7dcb992c0a066b90b3c392ec68630af8bf3729a668833209f2e4852d486f1534376341040737817c9e759ace2eaae77ccc403a4c9e23b8ba4ee51e37a8f7c29c006f21054a121bb28067270542662d09d865c0de7ab0dae4a3ffa7cb5db318d9243370dd81bf78d614ef4f9dc86bb6d99439ecb65623a7eab83c5476a40283d9d4f4cb04017fd799f79d701793cc13f1404f3b56bfc196465c79bee90a0e274107bc742bbf4d0b71fd39f0bbdf562e841f54b696d90b1d4a73ae6848b52d3848fa9f8f5642a8137d640598b4f57a21507d873d13bda93b507b35de9df7722a4dcb73a884ba9453c73510eca0df4a246ac0058ddda45435a465fc6d30a59fa46cfcf3c212ad3c3b1491c77db14d35b3f0d6333c139c9adb85aae56d49ea0dcbe4302ee2a5b74551961e18656272ded0a471725bff36a7801c6e051c0b520341ebecc9049c61ba4d290fe205a23e98f93d29467768c21f5f3f30f6a05e6206df40110e81bdb9b56b73729ee8b18435a63e10b6220f9bc0f1a24bb7deb03892964e703d922ca60b6b35aa7e7e097830fa10d43c7260e1f7dd33a919f7ee7c92574af28a34e6ca0192b6bff6d3c9142c5c4ba93671cf7154cc486385c5b298bfc9dd24aeb4f098a5342fa04ac2c0c650e27d19f90f3314cb815a548dccaf629ab9c27ed2da864d4cd4a0fad350c292a57d5ddf50398ebee9b7bbb6eb3051c2044d03b6b15330db3118166d42a8431ffdf35e42ada96eedf66e2ee04021dcdbdfa1f3f7feeab6f65b9132387770869cebb24b4754ee15794acde98ab9c2fadb0f086040e1260e917f52793b41b4b49a747e4c77d7eeb425b22975d0cbf20c84176ef2cdb8be05bee386c28e478face47baa7d7e83a68ae9887c86d4067973d863bc94d4c0925f47764ba680e2c8334ad54cd0ecc5b61687885539d3e50091f94107799b6e75f27ad3b56aee4136a6c6ffabb3be83184dff28286234acf95e34ae497c8d09744cfb7d4c7e1f06d79b3f80aff838d1c9a2d06fbb9e338b3787722a5f0d38bb4385514793f0e5c016705acbae2deacacc610c4945120925cdb37c5d7437bb6e9a7e4182d856188ec65ca58b6d1e397294eb412ee6766b27e8494484e438e88c5ad969046513e067041db0734d31df265b751af734e380702a3bc38499371f069f571d95f9edf1ef50cd85290bf42764520753553f4b3bbd2b527eef542ea61031b935f461b7697404a4da98e4946442137462de2f72af9f9764deba38b6a462106147058045116dffae5abb142b0de8f7270638851e67626685eb319ee857ad1785701aacf0a465d02461dbd1a8b7cd1b93ad2739138f32eea589e183ec33f4b2b4a7ca99a3d39f7dd5c615064ea7472425097a9f418a01c84812df1991bf7852afc4de2bff7f4b686e0514a413efb6f580503ab133d169bcd74277e4efa60c2b5de24c6efc514081de30fa5f2d4685f3186e86a26c773f2cafa4540ad6fd4bdcd18b21826052c981c90cc583ae08ccdb68273dbfda3820a79797008b42b140ff7cd650249cbb47d8c84e2718f7f3f6db62728017887ffa5a786950751bbedb59ed1c47c0f0059c5842e81d5970aa15a45deb7b8448f73b5ab0b88ef828594fe5517b77ec1bcae5054059613dc52abb90ebc1eda0f91d1d5970070df963e4c38345abb99fb7b7e8b2c18109c66132505b6b0de506d5fba2286a07c5ea7aae6011740d6a0f3c73e276537d66c1a640ded8ca712c6c15e702f3e6b697bbde6cae21ccfa72fecd8f8ca0e6ffaeec535a5310fde89506c867d8d92bd32fa3298c2d66ba9dfc21443c3969eca954bf8f1799c1f98f52aa3e632bc76b577ca1d123d840fb74ed91f639011b06738caaea42cabe45d02824e9ee5d5fa007f5fc711471729124da50af8dfb7a3d21cf92f9c1618cda5051a3b5fcb020d535c2b0d1b1627241702ec9479fc3d30e38d2732597020205b495c6b755756febb4121dfd525ea3fd67c113bc2a2f5a9c2e693295ca9a58d9c86f7f5cf8876a319375d788aebac0615f06c8aace6df9982cf9cd71fe772bb0daa786f994420ba3b0313a4fcc346eb8e634f8c26af4c0871ebe93374d2f6474df65857f1ae6453a6b2204fdd24a64912567a5a7a6817755c053b4933cc2439f44229fb0ae2d89cbf59b34d1da964330bc8d27cbad58a32db85289536a6c57d8b6f565e9b50646eb7e36d8a489df4b65d28cd5041ac89e61f3af872b2a7a18a636a41c463b9f8bd4c431085e32d7c8cc560bca28ce7ae2efcb1f5c0857a1da11abe3d29d93923541fb680cfa55c69fe2ab81b8b489dc1892c5efdb48c0ae877775a69c068a2050213a1eb17293d7242f34825fc5f87985721f2a1357023b5ac0f927156c7c1d32ddaede4dc5a7dac5728f1fc67ccabf92c7066b47f2bf9a0fedcb98270367629f2a2ccd672a27c2d317cc0cc7f344bd5e12760f2f63e93d4b25ca515e837833aba128b24334f503b390c29c721f1b1ef2a1404f8f6b3be9d81f9fe189eda5c2e7fc18fcefc15ddfc9eab8e7abbb307f47106f6c89420ba6b8c14c7acf7b46464f2516d64cb2ce6d8a9a9e4e813b879a45802bd72407d91807dbbcedac149247ab188934883f2abc33c3e7f7d589eb99180dc6b87091cdfb038c26911287b2f356c325d27f49fcc59b25b47405e278754214d0fcafe5f5225da7e7ca63907d64439b09e7f61f90189e8d3e15f63da55a9481307ce7235373ff4a7534eff39d773dcee6f623861a1240e127ee819432edc493dbdc56aab7d042927bcfb708681e7d230f1a334afb7ae745f5de8add0b27e44e672dd33aa181c79d88d06d74454699b7b7d48cdcc9d50bce6847fd7f930a52322b8ca622d97b537710f0db211d564259ad342b4da95def5aa54992de34581967a83dab6e6203c5760f2b0d09766955bc0abb78cbcefc617dce2b0b3b494b178989dbed6e5b18dd69ac4ff576a4cc01a448d11f9434ff3e3879430d440bc1fefc6935a3c9edf289ad2e69ad55c1854f05f0f6c1b03c9c0428b579a34828b2d788c3a2bb81436891e15625ad8934d4220a692fd9436c7133f2884d2e7c90c0e0c06de7c47a32186ef8868cb2da1a8f2487c6bd481e59d28f3e52c7c51a46b484b5553e7a9b4bf221e1b1463803eef3c3fab7e2cbb1ec2c85bfbee0c5830b90c24d3e22af7081e480d0efa3e8d3fc6dd93aad4933601b87eb16c78c874c9565378620952dd5d09927be399ca58a6fee3f0107790da3e3c61d2da42fb748b42a7596ddabe84924eddf2e5e9887622fda53ebbda1bd4fa925cefe5f6141863209eb2faaa2bafea1aa0fdc831ec8cd8a773d6eca70017ba04b070f7cdf22bf81de019e1059fbf5f23657404dafaa2b286e57a2f5f2bf1462fec7c8b074b5988395d84b5f5a1558fb549d4bcad10c986a51d42487c08b620f638555dc27c0febd1111f55136a69a0236640d95a3ad660ba57bd92e31265909c99bbf9ba3eada05acf2bb55b30e645301b30264ad64bc4a85041e24aa4ec05ed98a611de143ef43ddc28d4001aac1d29ecb00f9b6034cf54354349d388841deba7aa25cd4086a88722831814936b7a981f2deab3f71c763adec36ab40807d521392f7111a3aeb37c80438cec440b997ec13c99f1cc2c015b31e864c9f9809baaa6426f831885c924d4f45ee094d1066562581e76017d1d01cd3ef6dc4b35bdc5b8a108afdf3d0577dfd3c653d0d1db188e868e09b3e93fd1f6b50b1fcf3d024b0aae4068e96e5d1e15bb547fe50768d60f3acceee3df90c7aca8d24a6b3c6377028cd72116d90bca70aaf2b08d4ed0b2fb366f3b67e26f0b36ccf7e9175c30c436fedae5c4239d926ad880d30d07b94473ae0581171ed499e8a4ecaddfe94e6a7b30ab0678a0183b6f0f942f539324d00c6a28c07e14556a89f79329d3042ec317fd8a6dc63a6cb36abe29027b2a19fec21bd1a6133d8e43b395289d156f767e7accb5ca27854d09259bf33733d0aa04a0d9aa0fb8c6c9e0afc23b87f2d2836da2c00e2b09b4e1c5674bea19aa4ff5561d9a9ed252e171978eb420e551fc7b09c1e3a69f40868ad26dc5f3f1adbdd16c8ef7a8ba54a61176f00db1a1a035b5fcbaefe81051068fb6307f92d9176c0a3ba50aa560afd34347bbec2351c3814081488512793410e1b0c1eb84c91ead04014008b9679f85f31832c8b0d38720f8468b509edfae3cd82478949064a58bb987aea1ab6b149053f09f68ae6617c1697d99e3c2b44ec72e7a966a01f1074e1ef935da32af81afdbbc6b176ce80b43e8a0b446d5955c9fb92fd8ac8ec0fbfb2dbe265567191e4999d76c3f40c09477942f664596045d445e1b3f947315af3cfc988b1abe31a15fcb66d9bd319e34c40726c7d3cd964962100927a9af32c1ec062ff2012335334df0aac04adf3ad0976bfc8f42270db4ed63a4e00e5aba50e004de2a9ea5baa2eff0b27fb6cddae39cdec028b64572e178ee7675ec17e7a3374afc3befb551fdea6f4759a5434bc737c20692b15d0234f6da25bfc636ca9ff7bcaf78630e6a939329e119c7117e614b6829c1b1840dcd41b6c5f0ae91fea78c41d7b721f340c7c26bfed47fff5ceeeb5f4492866d33d1ff75192cd47e1f50db985a1c8286454abb45e3ea8a29f64f4b354ad56093fcc28f668bdd1ec44c56c8d34cd38675ac8bcb2beb5c1a527bf0c9c11736a3a7da7f3883e25629c3974a7a25e803393bb7868c99b82b3523eca6f378792b36b0808421eaae3608779ef32adeb78e9f717d316b153b077c8ccd4a4b4590751b0999453da8cf1b8f8e0236e2fb90a9d6efff7ed30fbb393025b7c44fc12c133d77abc1765741ba91d43725db3fcfbb0b780fd3d8207dc2efdeacd234f4e8a6313161740452af05c36624a07fc733d00810f8c803f0fc45dd7b0e81b304176db761d9754b021ea911837751851f507e756a3cb32d4933b124fd1ae31386530577aa261e38c8d3b017532ebb3a2d1d4b8c0b1bf1cb9c5f16fde5eadf779127a6b79b547742708e1641f99716f15790638cef7b386745f6a87094fcee1375b830f0fe39c244f0566c8b1f279b815e1f5ef6f8b72a91fec260b3f82607ec8a2e0eab73bcf91af1e355ad5506ad33f7b11045e6c6f1fa83806d4fa7eacae4de558ab5a7495724c953b5a6436dde7b1023cea4ea1863fde713e9a19e3502ca71b912ac49fad28878ac9abbcd453a4c687805add4b8b6c76d6e565cb31138f7efc8ed0a4b5bac550658d3113d566861e23a16eb6c9ff7413a3bd6741ae4b5bff89667fa22a36dd372b0cfe57e2836c1180e661fe3fe1e2d6dc402319481a44b81b025be3df842fbb24d56e83fe2e4223c3448308535a33a61f1011ccb1194d7f9346cf93396e18ff3c15e2e7d0fef63cc75a3591af6c0e6ace3de9b2064f1e2837e4a16efcccb67954d531842e0bc3b313a7cf50ed1a1ac124509a06fa0ee31110cc22aa061c9efe709f11176f6031b83c1800197b1d5f4ce1d174d9b068878cd4b40b484587786c336724cfa8d6264510af44f47b15c703ff75617b28b0aaa12694f48968892d685c4b367e5a22200f3c57e0d343c7c5959aaeeafcb359b78c7714ae72b223e344bd25f07ade0bde62132760a68abdfb112ef777e25ecb5ad439baed84557fc3051cd65867c8f97629ba225c378ba3bc38cf8f9e24944cd04e11024fd6820ad17d0d39a0b483a3df186e2fb809b554c7fd6da397430d7262414d46b81577128c86c4eb62fd5773bc1c5e9a65764a70e2e21638047357532e06e1af00ea0f4667c8f57d1db8074c2733c3a10ba9dc7f85d1c046da603630c056f434f783a6dfb8d11772747e9e66b1d1dc32e51d84f59edb770dc1470c830a2f5fa6b06b31be962eda7ae2df2b10ea2666f4e1ca7a07dadf9de620bff75c6ff9bb299a32f4a2cfcf7c412d3b10d2af29c598ec0d0476b889fef01131201a75155f271c0d2fd0c6bf748a14835827d560b6d38e770027708c5cff9882d73bf69c92e8b330e38cfd58f1458c5f912a7174b700f34c12b93188d5dbc3f82faaef70c09fb09510ef5a20a62eda3fb7f350d801e048c220036db450f80661a31434eef1086c7e91ce563fa72d00c1c304def76a574b4dd9d206bf51e1422bdd1143f93bc498a1aafa14f11606d0a937e4a3553acb311c4225fdef67a6f6759ca0c960ae28c4b3f5c99f531993d092baf3ef0da0e7ca84d98eb8635eb5e4d1691907da781ec44a6e5f2b717c168e199fe1402d23e7605d59095032f5aeae99c6e14881751e7abd444b65d0db7a6ac686e111cfe2a03541de5b73481422892e55c1007d729e558e503d5f2076ca42f62a022b3fe48f9ae5e5da649892bb49ddf67da46307eda13ad10c36d77d2d54e443584d2ebbbd1293ead3ffbc8995454eec2984c26e8627f6ae1f0559ac5a0cd43e01f80b7639ccc72fef3da6c9f9d487b1fb548c62d600ffdb2e10a129ba479e872c54d85ce804bb52fb3893ca35b4a40de50b6b42ebf115c7efe9744c978cbe394f9d408e6b0e09b219a6b41fa0e0ec9565bcf14ffecd88d0a3caed64c2ba9b0b59210a6d6a1ca3c33c7ce12f1991c703261f614d647cc6f81442c900207cefd652326e0005409ce640ed1b50185bf30c3895e63320773c3bfbee4932ba9f2a641708d62e084db8905d4059260ac279e7b8be0af74a7022af98ba5f873325666624706c217d3984f2e40a307c5093ed7d6eab8aaa2e6adfb7fa7c6a8cb31b0a5a829e87c780f6e7affad03de0fd731c9a00c571641cfae8c9130a7a35223eb36736f64ff8f61e1cf27ce039bc7361dc80c43b3a2703fc64b03c83df276d9e179f09f8ba2ad9a6b56a040ae42a80b420ec10a701c72a82c58d436b53b83140cf20eecf791684185fd716e267cf0b86f7db78a94f23a44d460e8b2fc4400f18686512a9d27caf4cacccecfed3a9398ba9b07f722c8e4d57c2da038da8a4d478fc63b3463e65cc6df8dc60db1c800f96e91c7cf13eb1e10350ef8d170631f2f38b185f0f1111cdc566fe5cf2e52af810e04b6fa5eb2f834cab36a87b22e012a21f9a71279c2e4dcc8096e007765677664e3e579ce440827dbdd8a644dafb94a37295843c012dddba8fb73a9603a84006db8584717d52bf2b1e44974578f7641e0e9eee640d34b955e60d5008e2c7a3f672efb96406f1c07b92369720c462919de02f33010a221b1c706dc86c1f1e78005b71e6435a1270e2d7ecc67f281602748a0673fdbdc520e521df045539e82f7248efb8d4511c01c8a6eabff2fa05f46adbda35be7d838a63c959c0da4867d42a3d917fcbec9dec4c2783b75c52d47ef7f7f120caa80f9bc129330a38444d1918c7b83f00264555a66e43170b53e0331a02ae034e30ae142bed80feee16d54eef5e6ec704f70b256b7f10d59b6c756a0d5f3a21cfc193596b39e9a8f9979202d876289a1faf8adedc4bfb1b4035f241c0b1c99e0398f8ef5c4c40df78da0b7842534d4a4b876b9492fbc4182891be5a32f9e1a17cb5dfb063520f22b4c44d4b7d3a2c3cfad216c1f2239bef92d2e780adc16faea783d85f955d6621568e199777de534c1a638478ab4ab73481d540fb4cd564b1651d9aa384e9043898150b10fa8b8534574b32805f5e418b30db9b3ab33ff33d390f5f9ffaa0f7d9eeda096db59eb58880a1177c35f0695b2c0f0898fab2b2c28728825c942d8a9a25be8b10bb28c23b199d92d4ea294f9eb18158209565a35fe1b555bdb783bfcf72d9fb44897e2f49b07c4c9b3a6a1a0ea15cd3cefd2c416fbed6d75b26950c004c1ae0788d0f21841aa42d0fff437622bd64931c583e9d5fc24d71cf43fea372e33eb8e888eaed5b60798ab9ebdbfa47954a6894eb85e754503022f0a16690fd13de91167a3f71fdd67c2d6c3f06068e86aae21cbc2a75605c813374aa54e67e6349014a0b49cb2438b43982f7873c5eb35b6e66d10bd27dd8320ad74c1ce329ca9044b76e83d6e25091aa09ad581d000651b1a912a5f28d5b4df77e7f958bc51ef85307d834c0bd6c5a2888c4016d1a484de57c941836bec05f4ade780f958f3f1020a5c42545794cd854084006ebc8389d85dbab0982ebee87ff012792c28e0bd654269f60f3ba31af3d5bc017f532460c856759ffcdd807268085adf0e23429e25e2ea2b40a02caff44276973b416f9c4305a04bd4a0d1c455306a4f107eba225399a8e6775e92ee7582b2e06fc9b3b2eeeaaead3a760f03320f2431c1680e1a6ecdab041e83aab170941fde638cbdbdf4f15c776fcd0f604f1c1ba3ee4840dafe8a1fb96f179c729f4aa2bbf59817a78ab0a77a5ed5d0bbd22e4c344f72ef2c241b70bd63aa694ada9163d4ab8423eea7607dbe5061bba800cdc47a83350a9d08938eea9222c749d275c544c6d541fe6277089b674214b12cc0174e39bb09d733bfbce99e3e5786da42d84c53e47a3f294d56cfb8ea12788ef88ff644cb5d3f3b52c39ec67f0a35f751673affccab57772bc958a559cace0bf00c5ec192a99359d29a14e0f6ba8c0cdd397b6dccf67c4f7e6ec9157d12bd16d8cd0595b139ff801357dd863cbc4b0c253a6b65a13086b5b0e169b6554699ba37335bd52a6f8b08fabd489c5734fdd5832981749f9d4058ca02cf565b11628fa2ae9a89b24fc4cf455ed0e113f484cf9d7381fb282e39d5d9ec3fb62cc8b639d370c5baf65e7799214b46f317de73f36083735dc1ca7bdc1a64c53ff93b0a6aa33bdb18ef72b2281ec64624174c5019034a90cd6dbbdfd906f284a463c1f4b27d09b5fc41a0c40efd4a64867adfa3f9f8c2abcd3b7f8c438a919913c52bdb168914fd83336c1a7387ad76ad1bbd619e682ea12366add55e77d77ccc8cd32982568a601f0ee7ca0aa82e7229475e337aa3d5ed9b234257eeeca2aa134609b9a1f43c11a53d665178c68a952b53de0bf37865aa71200b7d8ecb8489c1a9a2cc0dc39ae4790da6f6cc8116e53250656b9a87b5efadfb0cca8008e053c20f4b66336bf2b0b33498fa20536a7afae631b5135df66a156999d1133db41ec635a54b4cb3eb8dac57531ce65f4e2180d49885b885460adce22ad213e2f5cb230403c03f8d168ec4e7f2ddbce7e3fdb5820ae4018f5ff17cef11fdd6c68c81e9fb316cc5c3c3c200590c6f073ca86728985538fd2c0008c886cda34d3f5a038c006ac6fd77d01af9c416df3c0740169dbbb2cd9cb1abfdd55446be448f99f20df43bdbc95838a33287f62e987779c2568df2a13ff8e76acadcb8778e33c0e89b8d1983e7c7b1e44cf8a0504000fcb3a82950e5bb1f53ff88a779606865fef8c01e986b8c9b7f5b886c39e81de3695ee9f58d75c34c502d71f2f2d2817f370c315c55580c217ec11d3aeea639173ec957d0ca74d2a42c86bc1d899978f13f768502f22e062508d991bd4c256c8c5cab3fbb56038d9bb67bdd81007c66784e7ea2a9256aa4585f364aa3f31dc95b272b032bbc58ad89f97f30b9fdb922feec887fbc076d5c19616c068c3559a1ad6953b622629988b6dc8dc5762f691ddace105ea1fc29bb8858cfba6bcd079e43833d134e6cf9eabf5b846e8a7eb82f8838fe28f798d69366c06785580aea93b5b1e7b4b6ee41f02c2ca572996bcdc791e2c337f27787d4c23c10f481aeda61e725df0560591eefa2c9c920854d28562267437390265e27e6ac19cc65c72b569a2bba39d6c726c8382e973b10aba138c4fa5eaca0f9ad448ef3cfa87cae0e06da0762ebe352436b098535982c02c1c36f73528d133763f2f512bc88e55835d0c1b17775d4c864963cefc637809081a313b67d1482a952f5845b9d5298e569ea0e65ca21bc97b5053ec2a682afb9146c80bc02cf94cb980972e746b0f478a90f5e16b27318a62c99f34612d1d83ba78b761d7d686eb94a50ab40e793c4a1d1192dd6783dbedca7aa67628fb4c61a88c5cb176b0275c88b5fcb2d261918661a00aa270eab160ede16fdf26679e2f2bc58416a1b5445d3fb92df8866ab0b18dace57f0baacd56aa86a2f1a3ffcc6ba01ac102c9015d877195db7bbb939c91ca853224c13cde1e2f89878d7d3bdd936ca3c5764f4b19921d4d96e4b7a238890e7bfdc19c9183d6c8c0c5b13a0ef6f28f95e4137c04fb8bf07c7f000c5da72f7a152ff25fb16369ad228219f7b8f4b633ac4cc6efe6cc8fe70b7b63862e9977bf3dc6cc1449a4cf071af8b1b2d29bcb9acdc3ffb08601d234aba5510f339d80b0d0ebca11a6ba77dc523e5e53c54312319e18b8f7da2c3ac126a08ecca1154cb6d9170b740ce2c60f23335642ca5d2bccc8ceeba83f774d53b00ff434bb3193a4e5e9bf188963bc1eda4dd62ba3d4ff0ba1c8382f99b442fa5808bad44102864ef588a39e8d55af49fc0b6574965fb53d062b3c24aa7775dd01f899560364cfff09f7660f1e7c0d8b1f74d427879dc8713027d58feae88e8b13f8b5d651d7c5773436147bc5c25a4d9bed90b13db92718c01fec9175f4fa2c20145c89d0eea0a56d696551fb31180a3dac8ab59096a3aeacfec3894bcb545af72084d0a0e95df40baec3ae74e71b6015d07aadf2d32a9df5e1f48c9ec3b33a51a2adf834bc58ff5e5cbfd1b3943793c69e6172f3947f50ab65435f66f2caccbefa7e7e5fcd8a820703fd7d00526be37b237927f0ed848eb67bba6cd1cd3788bf0c0988b91f57441ed74e9d36aa6a0fb4b551a572f6d182dd313ebf12598bf5d3b4e33e5cc4dc564ffd22cfebf5dae2740b8929c5852efcf91ae1f982690ad9e42480cd4c0a1052c8aba4fd8ad4839693b65ccc8e8061cd0d632b5758836ae6228a09dce90b4d90d1e80ae9f0bebb042978017a86a8798b582f25dd30f2c79d2b94e65ad6b398817045a797ae514c8061aa2db623a57c5dd24a4b8e1e941ab944bc9dc19e4b9b24f4bc51403db4e7ea7670dceebd6e6486a3b88e139c8a919a4984153dcd7137d0f209550367a099cbb9653ae5d9c5e825eb7340bc54cad2212625e7dafd76e42336b6890c11f1aa693bf7d7ad17a826cc715c550a5f354ac516785c99f1148d5aaf195791125488e6c517023561617e03c7c662714e6a462eece711851412f40ce36cd989ce6b8b6b417257b7ebfe6d257ec91b80a41e29a107db740811f583711d4f394d51c77e19b8a3c64851f3a0e082335d82aa68cff57448b443d368961b672a15e0cb9fb001c5da71b2c5eee1e6e0f6579ef14a0ef6dd6bb11ea2539dacfea66389fa9f6f4822935cea20d2148d3815a72735126056f445dc2c2b60445ee23e9af653658a08fb2699c149e1f55936f9613b2e458546b4a90421e3a5220427fb8619d362be61ac2b5ac5cbabbcb186c4f965ae49c8bc622783409ace80e4f620a56d479cceb3c66852ae51950b1dc66fd44c2169f1867e658391700a2ab155916ed926f8a7f71489fe96bb74e1940d6d38db280044c6096cd327043e1ca8f4c5ad1b3636614c06a36ef2f59927512e6374fa467c22753cb3c50d59ce3fff23c8553150d3122659214df0db4522b96f6221d769599b97043b37f3e13993fe5c1b8c18b8f33130d38c0a5903881c16022ad6af8e60e2fc91834c03e1c9ab05cda5b9640f0ae2980a071b104b72b5aee363f1fc7fb9676fdd72b55cf4c94db2bc1887536b5aff5a3607fa1d0e3ae283067bb33083005d88c057e213b18f04fa23efe8a2e86c7b360ef96d29c03813d34d2e81de37865d01644db28850c3669ede74a1094e4ebc0525771c3364cadda0c65bc6dfe863a1ed3da907f8b93d1673e09ba1130d311e49a988803d740c89789319e67f1f3ea0889d4986845a994887f3080a5e6cc7aead69ad59313104136062ee54a295c676806d019342d6a9ef9821cfdfd500f584fd8237a56004b3baebf935af5aa000d938b1b6d0a4d978e53ce5c3a932ffda6acf624018c21348671eac2da0ad05b6c22653094128e71b1c7b815eb6825f5b4e5b65baac2be8fa0d7fe2dacc19cf5d7e481be9500abff6d2fc193a9afed861409f4c6c91508e78ba93f469305831548a5c2b6e3cde7bbef93946d50347b2f3b70afb2ee009591e6375ad6b524606cf054accd18c5b509070df4f159eea5cfdfebf777be207216f135dc2b6208a050c0661d7452cfe715e587818eb49b4718d6391ead12d71d5e0afb06b9d920aae99a8aa76b26f7dc3da44b002ebd4d8ea4463120f2201577dbfe7c8d39937c30ad9a4f03729064efc20fdfe6b926db0d3b9b13bdf1bd4d5c8cd21b07c4f58768f0a6938fdf6d59cd3d0a07cf1bf547f7ddb28b2ec7339ed24ff2940fc07723f94fc2cbec4a981bc24b6ba86d04df6d78a1b66e08ee23b1a391a05f66ff94f376e187e6be52640dc9594f8eb76e6b051e1f26e0052fd245f53801d9bd7ef6ccb606e707ab51097d3332e907040e58e5a58930a8115a03869854347fa3add5da737c07e6a2a036917f36c42fab8a4c5e4afdc26e6ce6e0c117b4ee5a9372ad3d85d3b73187543711d823ed08f83516794137356be8bb965c84e9102e5ba8b9dd4fc814e5a22254ae3d59ba05a788036cbdf4b4070ea9c1157fdc70a229eb71bc5135c09461de6d2c44a9e15edb08e14428a84fd404bd0f8f84b24498b6801545ac353a333e79e7d18038f6eab2163403c84aea578f3171a2ecc701fed25cc31bd59550aeaf92f7eb023e9a6b4a2574d9666f3966638debb69020617b97426dbb5b79f06c2d572de066cbb170fcfa4af4a1bbdc8a35443e1e3571256df3d0fbf9ad51d779ea236182e29a238a4e4e01e23f219fc0084df88b8c1f7e273540d8ffa89b8c49a98250767d61d2e344edd00d304462762e0ec75d95838a8a6afd3abd0146eeeb6a338d0bba2158ae22e651fe225403e39375aa1de79fa5f616dab6c8fb1ac78ce8f3e2434722036c77a068899e36a48ed89b3471952a936f7cbae7d76ed238874a12a05659f0b4d315ef2f56a7e68d20128531e2219b2436035e8bdf093c91906f1e253ac8d4d9a41f5ad12b392b8fef3f4bbf8092b8f414241df5f1dd733857cd133d5288d0d2e940f13126c1f6eca9ea01b07bf94e9a4bf311895c75feda7305acd4b1b99e4f53b1f8e2d6a0a8009c1a9d1e6d36c1664908c567f58f42f01c50794413ec90a9d79aeeae12d9c2d7d4fabe016d25","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
