<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"53990f4d5d3651ad527162ae907ca5d9eec2d194330989f9e8b82aea6ade5097dc339db9d4b1010c72f12573ce32f98cac91ea31454ccc590654c74cba5106671258ee0af72c791a5bf709ef7b853fdec17ae2dfb6b252f3bc1848b9d6d08bde4ba5b107b1a7ec1734bd96f98aab51b38b5ef9c1a941a4fbce163c4ecc640b1b262d0acfb0a94f8cbaa60bbc73a49f73609bd25fe234cefa791260b7f8c8b33447dc855a868cca0a74be6cc9677ecee0ed513a6891cc43d03a3b9909492c2c9ecc94c3cb2d73fde0d48abebe4f8320eaa73e472a89322edd5b377f4d88be59cafdc6f32c7ccf9e0885a4c1ab5414b7949a1a9c0bc3c9f00b4636fdae4e27427736417c531e08c3227cd139847901d095a370565f975e11b52a9f81a48b919792b542c0c3964806117060ddb6f0ac1d585fb8e4a51f708f2a6c5c2eeee737a0f6b3dc36b74eef893d6d06b202bda4aa1f65d7b202058431bae931195a1d67c236cf1d57eef6357f572d73fce030422663815d9181b7ecb9ac8da6e1940db08e05de36659745d852b51592ff9319cb50bd233d206368a39d52c5773222073a560b618914728d06344871318f8e1015450f1acf4ba5ef5c05ac22c531c22c1aa4444758f5ba30ac444266f83ee6085b2036b9da688f14194812066e9ffb3e24498f7842e08006924ce9936e77438575a8f031a4fea4bbb9e25bac47d62e71ca0d5a27041f5ba936128dfdfc2876cbab0f584820a931935e08bac88f807b4401dbbd98d409919945c060061cb6b75119bc5c0ecc172dd0f4bbd8b93b204710de7c7dba26da8ed636289a9ea988ca754503a394321022fde1cdb7e55cebc3faa9ff8411a1661e8f1ab6fe85bcc894e0b3dd4beaaeaa6bf5626cb2b249963b00e6556c905ef7f47ded30d218f9542b156840ff6b3ef1ac8b92004f48d3c053951ca2e10cd353c7fc612ffee42f320c7b5201c4130d60e2d3967d194d69cf1e8bc1f7b62a943707c5bfe3b242dac4ec96c54d7a2fe3ad293a75bf6b14b72cb5ab88276008c0e8cecf54026889213a822372bf74c02d2239b4d0f47aac71996b8735dcafc771981f842d5739f2384c7250a424dc34ea23d28820376b45f785a630862eddada97ac49294f2a5c4e8dfe8558e25ee4bb8f850ddd5bfdd1ac410c63362de961f6c52103f388e8e6f022c732316eb90c099f036688fe8650feabd6586bc1b3ea6ddf4400d6948ec493cb12159ba15db4e7da49bd48319755778e9e3ded4b7e3629d610908e1b26c246bb3b55860128bdb2a97227a2bcecee9fc9bcbfe305bd977a281eee0880b69f5419f35460726bde2cf4a32439ab74b2d8d3a2d7395acfe3487c6cb7fadaed1308c7b6c878ea2f0023adb0008e8d014fe09a7e0702cda697b707362b16773cf4c5e3d357c64b318c8b1c71c266e98c3bb6769fe9ea66a48e7ae2a0b151cd3512e919795ad5f0929d7b9733fce36a67aa2358cd2d2062d28f57057a80d1b2146f84e0ece5f69c74b9fc48bb206056faf4837f47645a78d43de5a1bc59b6b056d6fc2eb0da3e6e4b1b00160e8fed682c5dcd71f40eb97f13a8208380691a38bb60ad1b0d921bad9b162d9faef338404f50e62294568967a801a0d0bfa3f73b14b46b4c75761bc6fb33b102c0c2a737385c01b2337e1cd764f17f8a2fe64082a5fd8f3511aff97ea3c47dcec56cf3cb31be2b8dcd12d14248de3e034fcbc1a5ddfa5ee67ed59bf6709bbebbaf2a85f06a691e3382dbfdcb5be8b8c935d27f5fd593c4f0395fa987c6dc70b401a5293adfb6a90f85cb53bb47fe517bbd7f2a54ccc88635d53c07ae980affa715a37a4bc12209a705bdf22f48d9a33f985715eff192dc2f56137a1fd3e68d747c65d794846814951d2b3197d94df518cacb3e82fbdef5d251453c1eea4930b888a65dee9061f4411096573d2e274c78be18fb305c34e8652243ca5f4d458caf5ef3fcf57b3ba91c8d87f710fa8304b0769bf2e2d76557a7f89615345cc15854eedc900c850cac975a5bd03e79a0484b8c57f4bd275f68b133928b8bf7514ab3585edbd76928e86cb0b5b073511c3bfe1e14d91f71f8838ae1864b23158066d28d1192ca9b75cee6651551610102bf32f846f32b912901230dac28c94427e20a73270cd42704ab2c12abcb01be6da55d9e7f2b47bb735bbf066e197095cb85161ba9ac692ee18d9e50953f84d16cbc427ed4a91fce16ee5fde0ae90d62bff7249f41e00ab52cfcf0edcddba2b63e6014146226f40aec50f5b3439381b4223db496e935c27cbe01095d917850b30a041c8c70bfbebcb923b7db074347c227209688b6d9a178139c6a9aca899ac1f810d173ff799f6c09e528c3205b58ff075e922533734206a5103bddbb0cea3f40a75a76a93217396c34fd993e5b2aba1c5892f927b100d12dac9ef077e7a66aaa838fdc00986649e5a57e7b24fa5bfa4dd170bcd23827e100a50b67db72ba4efb0602dd2e74fe1b0cf934c38dbafa833abe57cdc7641c63e489648873346a2d936ca940997c8c7bc7d7e1cf8fdb60d59f0cb74140e165fc78c873114a4bcc22449cfc68d9ce4e2c328ea325712ef95dbe8dff90c4685305981ba9939f784957d7fea8562de6e3ac4f2028351e5227cea3a6abf6dce6c2098121d88c3fd476afd097522d0773d6f9f36b7790a8a8fea048bef7301df6b019a565a36a05ab58613b86ee2ea4947363cdc2d3a6ea4fd47c62448ce2591fc1e9db67c78e511eb5819445f48ba0beaf2099d9db746f844a1d65a6f7400d950475e9ad0f7ff49ea33767c0a35165d53e731a52e8c130dfec0ed5fd11e2f2686d6f8e18738c5ab6858a79140c86785f88e321526695d83b4992a9027e46d52cf44437067d4a55dc967fb7df671143e0f9555f33a61fc4e34d21634298d80c1ce2c91f009f65669313cb8b5bf2439f13344f9b0873d6aacf06bbdfb17c6288c075be377122bf4b92b83e07394217dca1be68b8fab7345906d9bc1bb7b8985d1d085ecec22858c91b3930ab0bc59a54d57dc411ed68881c96dca48b01e6733b6fa36e2a4f54f8390c12ef3b8ba0899e20142f801ee9d7ed478fc8954b362d2cbc6edecbc304f9ed3a8045a429bf881c0cef0a59479aaab4fecb3835da6aaaf827a630a107be64f5cfc51843be57b86ae5cc73bd3787e68feb6054ad773f1322685d5007d43f53b8b37a49683f5366ead01cc3f97905b9404ee92c1637095e24d9d6ce930ce8ac1eb73817332149ef403685e6c7260c0090361f8c5107951ab19f3d5ddbf012dab2b9508aa64f130f44eaba1a1ac87870b31ac30dfc0c47b30cc2585ff5a5f285ef3e65e0a08eabf3bd8b6ee18b734b12d49a5d3ffff99a72c9fa3da59b92493841b1c674a86b48842708acb3c7e89ae85bb22036378a636b70666e2b03e1dc65a3b6b451a72ff8f1fb0161b32e05ea50f6627f4ff620e5eae9ddc8e35c119ecc65ac9c29986e52ec6cdcf2ad74ae769b53add9ba6c1a9d01b1a10a9013f68ae532b53be8a15946acfe36f1a61c0d73dd8e01af4dee447ea88331f09cfa833a7382294a0406faf095858b9c694d46cdf7d20f47c46b2507ee3878868b2f0e6d64cba6ea2feb55df29721054f9e9fd566b57e17e1b999f93fae216ce7d5b5a11a775102822851c588481f3b8de283ffb69db44436d3ee344fde541f0aa1a445a797e48e2abe1d26a5b98cd06225ed16cb535ba43b3658ec852d0fa9026c10fd435d2f692ab30d2fbe91a8ba5d216473a11b712c67f62713d3332f82e127362062590eab363316c506025ff8a1bc2ac664665e1c975c019fc053a7ee053461881e1c560dda71adb9a995f5eea6ce2f678962ca9f515dcc5851474e63101d105904a0a5559b80f6102d1741e255c36af33e57154fb6fae232e217256c996df6b4410508103f372aca1fc9afc36b6aef65cb95d7cb7c1675255cf0a52e8bda960d329a40a01f1f3eb443ad571ff52ad779461bcebb92f4c6e83457eca04d21c94760a6f026b77477b0c31381c7c574e2df6eeebec7d43639d34ff1d9b80d6f3b37067303b0fc4dc79956d8a90809a322829b78e5e9cadadea06f87b14de25f7e84b86df0b4737686c993f34c0373451867ab79df6466231c67df7baa731731d45ecbc56d0f74bc678b20fff4f140250d52eb1eb0d2f37d5190ea468e86d590bf3fc8146d1d1acefce13a093d206e70415aed45b9427b4873d88e1ecd9ef57c98f508e13fbaafb8fae257ec348ff1ee54e4ece094869f2dd85252e23bef59317bd5299b9ca6f27da0f9c6fec5f857101382535a682e61a35e2d1202741ab0fccc0442f5665d1b04c0afa7d233ede6dc2406a8cede76cc998ea0ae573233542e6910d8b7537f317bdc1cf64aed05581e4ef2b44e4ea4182eab7bd1daaf1c310d3a0dc59e15b4ccec440cc06d0bd44e4c8208d2a6cb8823dac5d50a83962a446a1802d0cb1880a437cf6993616c5ed145af7df3ac0a9d94d42fd06bfa727ecbb64e7804e67a136942eab934a4908add6ad510d6e0879ae4cd9c1e3914c3110d654829955ff6a9e4859ee5fc66c969b672dc8f11576b528e8373197736f0d2e5d8499c2f0a0f8034f6db8a16b1da7fa377063461b5a1bcc7a9d7c89b11e08e40b2a41ce818ccf65a34cdd60703852672bf47b247fee94e48bedda0588652565b786a0bc1fe978ef0eba31b5090b418c5e3e8764b31ec6fa9068ef8731eb1d4fecd34dd5c68cfe178c08dfc87238e19c9ae0dc5c51a28cb46fa42e940beca1ccb97b9c42ef4f5cd525276e4959ab14a53a9b31deb6c4414d27db2e41f7deb8e4bca6ed3c50ed3d7dd3f0e86e9c8236fa9428e74b7fedcc859a85e480cf4c0723cf79833f0429683005045f42e1efc77820e2fb35fb1b8fcd97d64b1e669209a8b992797e774ed8bab0d35a2a8b617ffd9ea251dcb70537630d53427afdddb770f941aada428a4b697b7716d124fbfa59edf85b397ad62a4a8f921fc2f3425e1f9a13330cfe25f0eaf5e0907de4a283b0ff72da1457e84a06fd2b664ea67232345cef9a1f751842f34838c0c3b11f8660fdd7b34868e3857dbe925dbd8b6a315d0624dc6a0c8dfc7d40b035a8beb63e7ef642d7926933fd7cbb45946a6e27ada1c6c379203914b049d5e9dc83e6103c830bbe022983f162ac283b2e63f27eccaa4783336a1a8de5f1a7927c8765d6155448c2649eb9b0f60d79499a2cb83315b86580b0b337a5f202eddb648e80c68500af0a8cea8f4e29b20d1311efea6c635da863f9176fe17c44139010a5f8ab97a7158464790199891f8af556e71df6d4a8a6f5aadf05cd2de2c216ac3a8d039a55c38c0ba65006245b5db99793e7c094f8c51324f264847eddfa28bb3ba44356dd9bfb609acf4012a5b5496b2302d4ea2da0fe8f610cf04c65a0c8e0cf4e17ac8b63cef5670a785d6e530fdae212036aee8b85b2abbc2a16a5f7b2097b7b9d101bf358ea92b06d4f294219a33b14394089aa5dc26be17c889459e98ac3bd4f1fd36087085808ca2d8b5885db7ef4ba76ce3ae57e0350c248f6b05469185329954deb784e4758bbbf7ce067ab1955890b1c429821e5aa97b62842ad8c69b284b9edc7259c9536f3facb838319931bc5d0590207e1c6bd9744b2c156e309a0040e039e339ef61e0b053b4b7ef79eb2531e66834183629c61d32fbdde2e475c701c8e5e567aaa9037638d6a46af4bee3c12c0875393d6e3b05b5c07b38d631796bc9abb3a174d37d8ccae2d71572211b00bf421839275bcf2d32cedba6d49021a8109e22bfecd591884da983bfbe7e757fd08dc344f84a81ca2915ee9c2147a0c6b6997a531baf786cc12e504a96497750e55f68499d5c365e5e0ee5065694ce678969380daf9e021251b1d51d367f5ab10b71cae1a8b1cb23d64778ad02c0992852c61be8353f5d977d87e8f7106db4b1be7c726ccfeb5e0bb2965560ecc7c2a329f0aeed352e6f4ecaa8c5a1bb3751877d03b132ebfb09757d5e9cb97e15098c996ef054d7edd32d833a77371f9a9af31eaf7f7ed73d9059089e775c07a17b97681dc19c3a34521546b7ebf9c76ccad17b008007f85df023d6a0fff69c2dc807754c00478656bc621edcefa1b0339931ff82e6779af87c46d84802a51bdfff70b921adb3607956c4dd89ab0d9b5fe8af2027daa9b032aa218114f63b8c9a61f338f8cd8cb8d93273def9ad5bd8c32bfe62a2ae87d56634c6dfe0dc5b7c082d2ca18a72978dd515de6a4bcd3e59746bf1f372cd2db90e1a1a6a6a255f9840e6dafe32b8a206746d450dce6816e3863659b1db481ac447b583c7bb8eaaa3e67eec44e4d8473b00a6535c4da5aee757a062d4c15fdd97e3aec1788dc0ef2bb8f76cc12663f8110ce8df822b8a10bb49576246ffe3e30dc3070ccf96b38bc91b9ae1f18fed7b5075fdb0366fbead902f3b5091a75830946895c78591ed118d3d63591c28074288503cc37cbe19b49406d18cc4e877970fad2945d6670ec1fc4fbdc63b9965c86826a5d8401ccdcff3cd73d91f8296fe850fdf75ef74ee4fdecd8f80fabf4f91a1f0bb75d70477231e52d067a5ec3ba28d8422218e85fdd75ad4fe3c6a1757682ccb1953ee46c790987ab6d3f318928559a1c83cec02336c65e5bab748e1f2ae3425eac80a8a26711a544ea57ab240c6590f0dfcdfb14de119824689c0aaf09de2a83c201c0bb3e5d515f235e9c819ef43356a09fb5db156c7072b60b1553a1ef542463c0cd11ba79c42cb3fbd43974a45fe9987ba4a4424754862154359fb8638a07fe2588de72e0d275fd485a688f69d55f188585d61d09a3d59ee0df6ea83b565586334550c6c62b7633625334c0f12608cf29f8e9ec8d07f3ebbb1daaed7424b4aebf3ece1f82933117309d96897c8434dea4778aaec799b9eb99f14503102d08a1feee2ca9901d0c747e5373fdab2655984d52c8209a922a511d421f33364ee406e5a04f166ec2428760ab315fc680b7dccb67ecb2dd48a7977f25181d5392c1825ef034767446edcddb4c1a38be1a4791b33b0cf888ae7ded1d20ff045f562fc3ef62c4baac7fc685b49d6eac9263e314acc11356fa5751a4d9cf90f6cf7f0ae4301637b31d7e6b7484e9c4d78b6e83f5fda96057ff379ed45387f74a552758808b911f0ab7ceb708cd8361100779f62eb4e4fdff38f735458eb692632ee6b6cce827e9a596273ed68b07b27f8cec82254b5964772174e0b53ef1bb63da6416c61ef70f9a2547b285f60e7c83653258c390e1b9ca274c66093fe18f2e2ea0be7c6ae5c016a1dffe2b8225216eb928f9f4a3530e81195c7ef05f50c8c19c325d789cb6c4b87439f6b8caf86f942f0c4af2673ac5f89f35f8881617822f46c8eef268c714e381884abab89418c358e417ddfac42c6226791938e2a4c94800ad566e9018e2dc649efa6c663b7bb172bb9ed5eaba64c32839dbad4d28f03acc074f073dbcd91497570c314c93c513d198cd6b3e324cafcee4f6fc831804c0c9b30456c6e803a94904e723e388638c7f0cd288e34bb634a1e0a15ce0bce343ea289534bf0356829c38f16fa9b56b8b8187275a6eaee1407b94c8640d9ef897eb59845b35b9118fc1a31f5d77107cccb591791b28f05e26605a5a057ca5db5604874ba69a0a725a013665fb6e0d40834bd8af5fd2f1894ab014fc90da39e6ebf6a2791642fef5775236e8db9420ad8c3a897b51ab4ae879e6c5be29ffb2a524d79512937b4aecf5fcfd14e56f003aab9180c39beac04989a62eac689ce81634c36cfc61158437c1cb3caaa6998e4a107d5d746e5c77535ecbbec448be07dc8de32d59f8620fe7735b17398a283eeece481de696582a5667ca74bb25738170048f35f6c4de89084bd6f038fca03a9c8f152fca9648728cc5ba77c93f2aace9fc68bf495adb76edf83567125f03217caec634ee127e017d19d7f20b4845aafed014a9a2de7fbff07c1374ffa9d31030070f1e813b5ab089be7589bbc0e1f803b37d37dd3cafb089a0f1c0daf07f6fc606aae0d8a8463dd7693c163f86dda8de344a9cba990d80fdb144c82628e631c8232a11cd247c4bf444f0423f19399f6afe403369811956ea737f1df71e3a5a9f40705f3ef037aad1e3d6dcf43878e921d05e3461f6a2f951e45406be1eea73295cd4f9d0c1aafdc4f038264087d5b1a17d13b6d75ce4a0041feccd24e0d5d8623177d99351cb718c108453bf178d39a8dbcc88d25d820a426728bd1539a80941f17b7f4c56c5716020e09b69fa7273d41c3295527cd633f40653610ebac1d9242932dc3d6335dc08697990d4241f5be242bf77fb4b9cc59fe00de68d53a7429d172aca04a85d351d98e9002cd1bb3113e03fedc3c26c2e514bf667f5c4487439e7ef8e59cd24d57d995383c7d60edd4ba1674ec663f9e904cd32fa28c1cdd3fede49841db84233a02797f952c8d48051c1ede7064f4a091e47522150b3a3109226690283740d219f78fe9c333d91d79ad528b3d66842750827982de3323b297aed06fd163d91b30112f8d45d4ed46b184e5f26ddd2f6235277d569c4751de3697ec65d346a03cc20e9aab08d8ccad7c797868e9a47e6a53c94c7fe5da75484144cee56df041245e4d4e0ef773a7c25afa7946f0572dd668b86a30dbbf3368901d7fd01a2a48912057fc8a0ac04b16307f9b14fb1e1d9e22aa46dab6df0e54433ecdacfb4cceb85eaa848f9f1ffb619dd62f608ec03b880ab7d234d935549a8657f12d399b8f5d3e9db01a005ad74b0d3688de3ab2c6e5963b97c459da45646f71524312b73831d16dddf0e82abdcd67a408d432037ccbf5edeffc868dde2a25345efae8e5023bc0ef2e07da41ef8597cc0abbbebe3bee702b0345d6cf08f9a02981e68aacdeef25a70559f0d72005023cb36badb28a39096aef83d347f32eab95c3951f9e9255321a1eba6957b5e1821dfb1cc4fd238a90029bf97bdf1f02944cd37fc16cb912a0cfb93a45379176ced793e2466d4f2abe496b0fe8441b2c0507866badb5e4bd82f9d2ca40f11ca977da908246b57b277bc888e15b381ac830f5398c7e2d576083d43b72e969947b9488581079109fd7e2fc2f3f882c29997fe8f22d10bff9157028a6d7098d5f8061f5d858fb7201dbbecf96b72d2aa219dccd5d5a17580312807492a701084ed8ab9b16da3a289eb0ab161cd4e4b4d1842909eec6cd9a08763ee68a5abd70f2268edff9cd661630492b54939fae0d1dba906ef7bc2aea36a75423944833e9913d6a53a02c7238afa7fed50f0d76dfdcf74b43f534e6e7223917d7b92724d467807ace2708a156fb3808f2e738f4b6c2b762b709740028705d7e24a90d9310f4974666036b7fdb7f8e1569e02be5dbc0e813960edad47838df81114080dd174f52e47ba9d24d46829d9d9ec9673f8c928812a840a9aa6afa33536bbefa19ed7c0bd8006b6ee22eeeb092f3372f65e9b36018c924f3d9b01154686357011e1df13ad0467cd7617ae09495bbcb0e452fde73cf5888909d13b57b99c45a8d7f834abb1c012d641c5ab63446775123a46de25f5de6727a6c94e909e163b5050838858cb26228dc482a4e67cd671292896eecba9bbb80790eb2c44492614d61953cb5c9456549bcfbbebafd19c8446b313d8605ce09fe42515e683e537601e33295b5881f5b07c1fbc7d183da1d743ee7ed2b9885befc0129f0d96fe5f554e528e027bc424be6f3b35ef16e67156e084709d144995a6f6e226a3e0040ff0bb9524327f867aeff0b735b7e90dd51de10d688deb148b31aedef9e5c047ccb112b46f323e4fb0aeacee134d8b53bb481adc71cf24a299dae7d95fea074251ad251e16ef0aaea9b7c4bc63acac853189b4f05dc1cea432f7176d1e91b55ce4ad9a074b38d86e32e08a0aad5a44bf3fa779ae5a1145d74fb0523aeca03f54823e9f9c5c2bf62044ba4e0247c0dee97f2c66b377a1df0167e02dd36cc677bd2c17dc9c3cdcafd5db4421681fce80b756f67cecbf0fe892d0bbc6deefba5d7e7c94e4b1ee3881a61f2098644e6610f8e46bf399922f98bab292f14afdc02052e9f6c67547c83254e5252ddbfa9af75288210af83adcddab30740c7207c4297c16c1d6ce34bfc2d2fb05d21faefdace78c2d13cd73fa8cd5ad1fbb477e81e77688669b1998be4673e8fe7cee7d5942d63335595f889e29762dfe9a753e19925beab43fd101e069197c7482827b4a693cdea11e2277916e2ec25df1a5fa170f1ebc5b5dd0348cf8b382b8d183a95b0d07a0b12d5bcce83de923d94224d7616de74906aa1979a40d6f452775d941adbac74f32e8b0cb61233953e2f1cd2430b43aa0ea1cc8cd632f8068bf95b18c6752091d3c1078976cfda29f0420ea5f75355593c54ee764eb6da5f797688cd3fe60aa8f109953b7b4d139ca9766391a74eb1c366ac40f789e5d4f0780f83b570995ab817cc0306940d89290d2179aca8e31b6d1726be0723b134b0398d7abf00804b6a6c8c22d99bd343156e8c7b6e1128917778c84048dbd45b03643f7801717fe240b41660bd37b6dc0efbf8f4043d8f639488e6fc67eb77990463706dbb752012013ad5109291b436c245c6746a5a7a265c919825826b780e303be7d1cd75e817c869a03c7d8f9950fe65a61d8a16d897a8671488ae2660872ded1d93b89eb47c649dbe8b992b29c4480b180662216ac99ef88f41a7428829305dc1675e79d3ffaa125cc6567aed1b0367a3a7b07ee858ea224ee6a6666c71dddd943736ec8d4979b59920f11ed3f94bfa184ce602fe2a99c4c6deacd0bb9ed5b00414ca480cbbf0f57c0fb17f7554f29d1852fd34e899361ce39e3f4ed1b928cc3332b4d86fe803aa5b6d557550125c2995aa4b2f180bff7ec9e1104609c93cbb3a19e4d758a3053cba459e2d93b73fc50dc13120de00f59c9074542577e6a5cc493050bb0a4b71bf1e4203365c90131ef01159173eb4a98d769ae65b80e21185d0e919b1ad2473145f7be1f713aec327c3168c291e88af240bf3690416692474db7b4eeff8d745777ee9d028df4adf78f5ee13383cdd3b368a4e8dbdeb152a0a05f0bb1c2707c446f613df0daa4d00a09cb5da9ee9e0002e87914e807aa3ab0823066e93b65c003069fcde7abd191e241af30927a46a8fcd962c8c7d8f8335f636f2b4a611261fdface0d131c7906682915f9654007bb78d2e02208c0888e3a7b404bf3f7ce98af73aa24bddb79de3731e0a171483fd6ebce054b00bdc6a38b63eb5fcd72b51a92c7bafcb85373582fae7517ee5b34e324799a5d31697d98225aa5018c6fc2b989588f3ac466ea5f174b765fcd3d653392f1de365d3237f4389572fc666b9a1f02fe7c76520c1bc101b9e6563a37d86c83060c399f4d4656e8e187b53910b800e125d310c975fea3a4f0a46a9523c5a9db9270848b80ed28101c50e9699ebc7e4662eb7c03a29cc029639de79ea45dcad0841221e87ef9f06be28c46918f65244861f993a8375421a64c4d3ce48cbb6af2ad291373f0378aa41ab5aacde8b612976147d78b38678c59da9f2f47c3dacb7c0bcae4a4da40e9bd8b82594a8f2f7e3246a946db69372ec03edf185f6ca7454862ebb90af8c04d8d16cd6d36fdf6a1d088daa19ddb194147fcfa50b7308f96713c5ea83908f66da5a4e10b4d9aaa980d794bcb06dd34a88ee0bc6a42eb8e11740cb5574ca3716186cb7f8229cf7185798b51325ea08060f64c07a240be7cc34eca81adfae2b48d36b10a4f8df6dfdd44c1268e4931e10b03711a9a92500bf9286ad3ad3fe5e546e741a8f119b11a9b63e249314646d6de3cbf8cd2da140c137f68fdc1eebe4323bde56dc68f1c06f00c3320c180d2105a7651d284697357facbdbbbad3777ee5aae2b9355e180b70f4f87a009fb6e8d8e381c6394e676001e5062bfe9ff5284c1b03401438e591c172461e1584b53a26eede856fd2bf8e047027f5ef4df7abdf9004eac41ffc6d113edda23f3c17be4edb931ccee62ed609dda1497d77355df1e0453616db3015539f47c1b9001aa9568e2ceb1968ff65e459867197a1c82539da4af9fb601e30fb7dcd7b1a744323191850880be549b8af0f0a2fc51b3321ecfc2354ac25e64fe24eed6b9ad1a356683d0a3aa6c02aebcb9e7c814ef9e7c7d0fc8b7b3c88a6318a09d7715f61d52139f2bb9bf10a5199535319e3d39a2ba826d08501a5be331d3b17e55847636acfac372de3ac852aba9405ad5a486565b63a92892dd03a6081b8bda3f02f183917259015accdc3791e42843ad85dd75c16e7cc1eea43d1b55a3afde49e399bf2b12e3fa620c4637cd72eac29c1ed599cf7fc8d4eab8f46e1cba45efe343b47a61d51d09dc02746ad301201d3a1f0e6cebc41dbdab448187271cba689722505bd020ca0ecaf0a0ab9d7852508dc828caf13d48ef328c622a42e200c8e94852c092c1811a40fbe95688475912a145a5da2472cb2b10b02400d2919dfcee818ec4a01680413b02585aa19301fdbc3d6b949c0c96c7c702e3036132ed62e917e839a62f3df415b242eded4ff44b9f0c6edb308633fd54165c20ce352304f4ad31d645fd508525cb24d9023ed601275a5a9833057a2b5b92acf57267c5125b69b6d00247d487ec503e0dfd5136d47a850814d540b270d5b06ddf0f02a799ae3b1acd1a4a47d5efc048342881b66e9b33409817ecf4f2831fd006bd416430879fd7fc6e33192fb3f3397216bee8e5afd03aae13157422db6c1b27098705c0b1aa1afd046ba9e652c506ff76b4667b608ea6240a0aaf122826c6d1b4993a31ce2265318a02d7c33ff6b0f99eb60e89df9f9611b31459f3b0208dfff48bf65f8c7e76630746293c1a8ed73ab41e8ce12cbbd4b86bf515cc454ee46e60e4201f6142b1ac37e1537b5fe9def1c1989b404c7afccb08be151e776f8209ae53b8a7583bc965f28ccbbba40aff013572529101eaf776d23a8a2c88fd0a7fe59dc1b21ca5adf17084d2146e613a7927c8565d6e629f92d0cb045221d7722226fd09093bbd8b5d819d53a31afbfbbcb86a6958cde8eb14e6232d067c37f3b6ff26763c1d2eda33f13a0f1b65e2688d6085ae612198b90103336589637f632bf21c0c6d36a7dc23fb85b41e1b225113d0af846815e120e910d6d8b31639ed971bef9d0f40b9a5087161b979c87933236f8235392dc7aa66133464767659b16c753082dc1fbd9a79b889f761f19474ff7d8effe73acf4a9804f8c6993b81b72a015c9ced8672121b2e30eb1f7c53b3862996f0dfbcf7a5a9d26c497c36377d87bbeebcff9de0b01c8ce76cfa66a1bc0df03fc474fcb725a316579105dc0228362249398b800307bfdce68602a3576f6d4ebfc8ec8f2832c4b9ce88b3fd4c3251c26a0ac72002cca70b6ef8b3401e80a6943878879779d9de448ebb28363f4dbfac238efee45d4e333f8fe8037ce9ff00b0d8fb9a74ceabbaf7729e61d0d02652930eae2251ae2ad29000ad26189ff5ef03cc932ba0c3c536ae78b5061472076baab1e116b39752db95843230e701efaa3fe0042b7e2064f0ab86591cb1b3cb3e6b7f4d8af7857eddbfcb05b18b1acddce0e04f97bcad7524b24e3180f669fc954495fd4c2249867971bd807078a978a1140d9d7c5873eabda63518ae4bdbf3913e4e5dfd0d32fcae97348590791cc5a2d6fa41d27b82d048aa48a2a7a02ba5b3e8452abdbefc308ef31a8181b7f7461984325889112c78ee3ef83487cdc5b827d10e407bcd5be6bc7d4aa447d9f9f08ea479f73f149a7e61a368c6ebf3784949bb24bc1b17e2142be4db417bfb371c005a5f0e7a348f659e3a608b30e5fce867652430103c631fb9e201a21647e089f4dfe1815b7c4b93be3a9b8b9162873365f6bc8651a961fea8b6e55de5b433542b751ce4f26e893e80dd5cba2193fb68eae4c0a8b2b6307b6b14beded7d724998537727d9d1f4fbd262135265dfaecde136349f54c616bbf4279f002d03de43836448add6f6c9b88a81fd65b1e90eb3c9ff9527400e73aab9cb2abb8a2b7d6cffb747f3d68fe10a3daa2ccbae56b9d6b2346a631c37fd6da4ab253b6c5449ddf576a14dd1e06da4df9aacd71b42fd7d92923af9ce10550eb86243ab40c68492b1862a55224ed426090ac32faa312ba214c27343413c4d65ebd53fedd963354b7368817995950faaa95c299ce2687f31cb274a78a3a58b344775f0f55726fe61e62643dadbf88a380165f7bdcbf1ac48e15983bd7492082ef10846fad8e91481a29cd534df1dac5fcbcd1771fd93652ed5a205ed0e987a0ee61f79138eff46b6b74bb69d95d46fc3562d3d378edbab6de7df32e9cb503d59448bd101327e806e0fa057c02a9266bbd47e866240cf84ff5fe3e31c7804ad084d6656c17acb9335d98eaa1312238dc13c44e37bb0d92a252a1221bfd3ca3a55f3c6f8589333c1ec834aea1d7dff539cbb2e7b4dd288a11e3824ecd5a7964313edc2660234949e00874cf9d45cd8e68db24a8291e32bd96d3116afab89659aed4e887b252ef71e0b5838d6ba95e693e73151223025ae9f8f34ecb67d7edece3a5a30ece9afb67e91e07f72b5047d9b9d1f34a8280520c1341421b5560c9d9844772177c750df517437df0eb2083721bac21f76f09a4cf2842b5907866ec18c05ca982a760ea81c9a1003bef1ae82edfa878981973258abb0549ce7a452c6f48c0d6bfc32f3c2f094bbf9c6f0eb7ac3ee757c989421d35da30fb97ed4a9eb2d9a051525cf65a761bc3bc834409e816241ad6fcd5665f6eed62d3a482cb78b27262003e2a143b9ff92b4dc536dae89e07d3f3e9e68f01225e5b8fdd4e654467eca085e7c9f0fb2d98a7acbbd7b32699f9ddbf4903b8b3ebbc995913b115eeb0c82a1f5f28307c79271a469771dec0e4d387c5711caa57f13ef80b7e7aa239dc1c4634763cc917a2278443899fb7b8ea19c273bc9f8825de5ab53933b1175cdf878de8945199eee39515da3ccf0f5406370c5909f40a54b2f1b75ee357dc42a2bb2520849192b0fdfb9c70901a4b14df27831452f74d7cf94ccf4d2439020668adb95a15d2d3ac8a43723e9075b42a9","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
