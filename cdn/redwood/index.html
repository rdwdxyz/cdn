<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"8d65b50e0a72bc8e338f52ae2dd04e495dfac81221e96dd4c8846a29c0b826069ad8e50080d52dad8359237908bf8c6b06f68a84c8efb863849e1988183bec84995f7489248e2f7f6887fad650a70b688c54ae5e423b6403be9f9bcc9e0f430a475d15227f10a2f2c7315e175a2fe78ee3145c3d03d91c33b737939a0316fdf17700fe046ffc8ee2401185f3a443bdf42a6c46e9a632d2977ac4f3091261eb2689d7db65237c294c825660e52bfec74f7d02772482a7d53d023670f2656c86d478c311cf905c8511d47a6d84972d71e7f137951ef612a14614eb58a2cae2048518003bf0aef2796d45b0bc2b9de899834624832472a536fe6d67984275ed646e2d91a11f842388c0cff20252cb57789e4069449c31666f935fed4a8afca0a323d80edfeb49c68fd28cf0656276e63258b3026dedd1cc87db797725dd1acbf08f39c62a27f45af68aadb777647e65bdcae97768dae187fc490b64456133d90645071f81fb517f8609feedb02ae7faf3387d32fc04e3f80d7c5a656374b2b94ead47e872e094646d27c450011bbfceb078e1521b45df92d71e48ed35cf898baac33da44dba5ff004c6a39486da583e060d58534094647b316405a773a0583804568a5d5ecbfb5ead61868b83ad17c4b374293f50c5cb681d5299ff2d959bcb5bfbbe5b08c75ef128210462549b7b438a8d6b9eeff6f4ebd4d718015507f7c3fd06777c8a3276257bee77c95640e6837d8efef8b50fa5491eaa2ff08a50ab286255c222ee7e6d48c9bf3e52913ca7d4a43b2d58c2e791eed999b64a4e3d46ade263dd6dfcbcc386310469468ddb6c3dbdb32e238047e6eab20bc41fc85b5666db3b692a8fe0cb4481713564a4478e7d8dbfb4d0fb938147045a969b49aaeda880cb5d447b89b00c9a39b7053c980c953032898a953a11a19576e26511bd29da622294448efcbe1e9bf61ea600e1b593df2da17f1356b2cd5fb4aa4c560829196472e3954b3dc4e8ef6ae2b70bfd5ff6c45cc79dd7f5339d4d382c068708be0b1b62878bc09cb64ad45fb492a2dbeab3aa0ceceedab5142b60a39a4d86fcaa3c51a7415dbd080c1f43d1457ce8996d29bef9a17c72329cb59a37205993758b091914d5f77f28682084a4c18dbff82af9ca0dddf75239117fb51a849a777b6960d611e2d7898e5597a83cbc715548ef0e1fe622d9c0b36e4422c5ca62e56d0bd93635409d8bd2167d2e1337e9a72f92e9d8021b8f0fa7922266afbb4d448eec8890509a53e637465b3d935d573627eb5c471b0ea09adb1d76cddf4a17d76236b26bedee19e84d1cedbfcb56f9b74d3589daa96eceff7bd8ee96108a20e305e0c36309e0f31f0bd691f14d77010976568edb532cc6add6854f88e1583b934dd15f4161d5a23d0a3fb1fbd2c429e28b8a7d062134d4aab1dca305813e45d517455935d699893d48762843f40c4739a0b123c7e053c23d01ff7792ab1a71e17004251429a267be97289c96de17e0ffafdc12da914449048fe666dc238ea3571799ffbb10e60449e9b685b64f098b237ab40844c78c16fdedcdded1ee0db4072f4b2716d3d16fe3a4b5aa05d5de5679965a85a433505e8dd3a0ded919aff0c98fd61238d22955d693c807cd9ebaf94fc2e32f14fa56d7f91ab33c9cfea023785b7cdb1396068ad1a6abe90ac3aa86552b5a5cd352be710950036e7c05cf41aa018cf730addac9ecbfd6f84ede8e08f3d8e09af6a52c138fca09679623cc8339380f8043ada004c3a71ddd9919da894a01b64372d3464cd64703ddf379801522ba46dcc606bb71d4b29dafc33b9f81171ccb9264dbb9c231c79d08038297f02bb4e9c61789d3bf76a5ece764cf8c141b71cae01de1add81caaffe6b33e47f2870d260a7c88f6faadd06b8385e5e06c1bd3de354a31bcd7e56533fa94236d7b01000404d1a711064e884d161b92a886a756578c21f398077bdc5b31db54748e76cde484654de6afcffa3c8a0afc3078afad77b64a6dcc01792ae69c39f002f316f30e73f3a02750ab2cb490325bca7c902f22a6918f17420dd04f286edd7265309b5c557c442ea37d14d7e48efe6217e755c51de97a7f6a5afc26dc00c83e46f8a9259a203f6392d9feaad854e08138cf97147bd7f9574189739060837e15a2afb5c43786a05fd0599abab57f354973883e9027f247c3d180d17cc6e8cea9a84912400ce9f3fdf34e8a74b2ca36125d729c2b2db3aeaf3267fbfc9e25a40a7aa81221c67d3f064b37da56a382f895618fbc817a355da0dceecdb28b958fcc21bfe44b7bb4e6faebbc6daf8ddd89c6184b9a07b77fb8adb6be0414ad3685b8494c437e7baa4f1ea3e40e2f4faa15824d6f1e6363f7070e72e15ff8e8d9a1601f5cb44a41beccbf097673673eddf1679e4eccd3fd0d5f8e9dfaa68dc1dcc5b5b7dd98f5f33dbcbbc7fd5287bf2251378329d7c9f2ce561173f24dcd525ae3ebfd734cb4abf73cec5bf89bf3fd013e80ddb5ef123e440737cf419adadc6435c60351659e60ed97c8f2e81339378674be7ad0133622b1174da9ec90e61295b46fcf618eb83ede79b676e6ebf3851ebf47261d8a1e4a34f1383a70b2b67ac30c2f6d843bf88ee846760aafa56d18e14724b9e7d8408b759ae01f72b08bdbd24488b786f29bebc115a08c8fed25dc00bf2e00db5f2d4d5fedca0cdbe6b54ea64092c35bd65c51925a65ba91ebd794ba970986b0a1e30084fa184e8df3347ea8806cbf5e66dfcde216224f65f922eac148de4fd5d2d286f55bdf45adff23daf12d9dac3c4da3ead05cf157cf3ae51cf1483953b982b3c0599cd64af433e8e9b5c867bdd20d5dcbe9e306d543ed2c7920b2f494c6cc857b345b4fc8884979d432b30b0695c610f3a6e0b77206a28bf7f8e8c69fd6804056d842182c4f2ed830095f86099833d27b6759a99d44507b66cb01730887df22c563ce1114f779e2e3c9eb73843dde4227f0cf8c3039dce6aa1033e62bc4ea45d109d42615750cd0c42b26627196c1e84cb2de208b1581d63933f80d374d551cea061b099d0de6c9e4dae6e067a41db40bbd453e0c87edcd4326cd362b4790c638bc9f23c2c44d9574fc5c6ecc581159ad58c94802e6065e712d814c30a96e016c48ab7fac51dfcf3ce43fde13ec9a33f731c97a6cf35d367933cf1917bc8c296ee6505478f07815be8b237c8b1675d763a609bd599652d1f9b1c029078590c93945070252a7810bbc9e81aa63b3bec544e0556c180f6b8bea127c87b6b7080945531f5ed9f628d0746bc28077d2689fbd0366db027756cdc7df938ea68536becea83edc38b76f65c04893232d91a94fee8ab929d3aa0627220cc6541357c385814ab63673fe32665d1bfb45d3ca0705350ecd79ab31c9d6272addf217261709415c497e4d9ba19cf67665be427c9562d483cfa1ca575efacb66f22c34329ea81c279ce9841704989f2f1fdb157e309b7979e7bfe5c5f2771b81930d07ae73e5fcef980905358329819bf624017ae6e2aa7c8b5e795a961955b94ff576bc7155cb488755713c2f4eb295e004987f654539f2f8056318fc782b5c6eaf90710cdc59e2a61d2c89ff6677d621adef4783563dde091c35ba25b2dd1d4f8584bc05cea84b430a7b54a4cb50f786ef39cfc33335814ac23348d187923b8fdf8e7fd84cbfa9b27f6527b6ae30af05d5397308125b4cb25c1aaf1ee8125e3dc6dcd675ac111c5e58d288f150bc6e62ea4ef1b885a7a966802af9990079f98001d45a13b5df97aceb6a9f24f75bc8599812a462a984b2f7f44a9655469a5384a633ca7d32eeed014d4b3b2d8297cd5d01b535f6795db7b1327acc8f5660c41452d89097355345d17b7240d5b4c354bca7845e213285fe9ce82476044e68563d618bdf28e8eae026b5c973999de850ce5e741caaf7ceb588b07823b1cbb630e15d7a0a1b72f865fbb4c1547a3f13de8167f927a3bb746bb9b7b3b2f5dbd79ff3c844046103d09cf8e4221e9a348e59e6e537990f32917ab3dd37115a127f1a3bfbd48078d5f91c9c443ec0c71c2e5309fae2730157220f91db812d30e0cb51d673a3300a096524e00e83c81e86206a538ead2fe6d99fb6bc39f3e3149ba3cf9d12de359beeafcf541be2e378972fb390214593b816a138771eae8097e3319c61654a923b6478fc25916954d930be38f9a94c5321573d6cec3a5091260cd5e802fd5a78218408b0c82e96460c624a16b213036995d71aed7a3e21b3380b9318177959cae4bfe6216432e4725c873e8bcbe502e9f5ace0ed823bcfe8252c197dee21aa00880c57cbb8365d00ec96d4d19d8d46815fccb5ff99e8c19f6fcf85ee8e0a7f574025042a1073f020c7d327c6528ceed64db4d4c78b338133312e760dc8a2311fa83e1ee712d77faeb5c95414b5858e0e6d3ac136d8c05e481ea73dc4f94fd7b4e12dd2f8bebb67a53a753dd7740a0f8ec692ad1e249b452bd80da7ec34ed732d256afdf98de4acc6fb117032d6d7ec091b91715f6569f0f105cb30d8493381f24f7c58362e1e725f4d3abc289dbcfb40f2eea449f6035e5da819b1ad078c9461b29c18e66ff6b371f1ee3ac192e4e4a92c24388148350039438dcd3c220b58915f1b64f33966840dd560e85b6e3ef739c4da4346fc2dc1ad9ef671ff02b15398dad352bfa1c8bca7bb5400979d7e1fb4e7a32b58180d2f426e7d2d06c8062cef9a66e72dc4b5d4d11598628861fc3412289e0ebae707e2b3c53b5710b79e381dcd4bf417771c2f805d6f857e996677a8553028edf14953fcbf924a39e35028374d687156f5ccda7f18dc5aff958ccf38684bec35ca51e6fc3a094010df1f122edad16bd967962b6522f572d3eb3e5b77020aa158509fe1bcdb30618f051586b0beb07aa2dcebec7efec484762d6e8c4672d52032ce520eda496212cae7bdbcf09bb7bc721d09bf00b7f2f2df16397258a6c211771395da381f702185c0dd6cbc66244f65f72b704b1c66aecc8735cfc1377a8d92e0e45b06e1a4823bfe26895065efb4421675219617ed168170dde044cbb628c05b9a5b7da915818c30184c93213580669c0a408dae310c46c91ad27e48f7a6ca582b3223f59f5a581883cd5bb3a24427725ba61653c959fdc6e6bfb577b14d2a846919a5c37d50d62b8cc58879b640a369da29930f61cda9979eac008c98ec9c65b58df4d14edeaef51b56610255e69e3f0f286cce94e17f29dd40c25e1a3f9be9b38a4297903f0239a5cf18809b2436f6d4463f338066b27f5dbcf7d89c32ba6867f5d0382db777eb2c47688e5a43fd076e7105f190a54f5f6af43b476761094dd24a084c0ca95111f558e7f105a05b432eb38f8502844db096da9e4e69bf83a718b9175b91ae10650b35eafd8ec73ece3eedcffa4fc0cfd1e5c9a42daa7b82d96b77f47456c11795075a20c227bd0331aaa18f6b6897bc2e42f8b842ea0f1adba64cf06b2dd7d0c89fd4305a07c8ab1deb52958adfb266b4f34ab36c8660d7a95ec73b5db5332a1723b9cdb7c1731220b1cee178c80d8ca6d2a1432fb2dd26520720d05c856cab449d9fe201e24f88f3e9d9841d9b9d0832b84351353e2e3b2ddc45611ed9f7d3d7a7b8895dd0134279dc111b967e4147854917148282bb779e0702cde9e8c1dda7ef70a7851a1b8360fc6963cf874480a97a8e4d911d5a398306bb0cde96df0057023db1f387ea2d780b40a3da6710aee9330dfff2d217b52fed8865c5ce39202e4f25757aeff209f8d3f5bca17ecbd2a0a42b310376f413462a031bf711e1af87846fecada8872b4c23da355d5765b90e85176ab413fbc44f545af6a50c86cbbe0f73d1f6014092ed2567651ab93cc72855a23e997396863995c0d9c936dc0d5ea4c60a7d5fab22455f31e6edc2ede11f362c2b623506da5ec8275903217d57bd90c91a978b5e5a6895489f0fdc3babc6c9ae1258f6b98e1e6a44d7e29959a749d4ec034ed8acc59f694db264b1b9012f14508a46b3af94ec858b6bbf761e90427569d6b1dd2dbbc7c4077aae5602e13c3619787eeb304bb4e6a7cd76f644b69d6d5b0043d2ecc03f014c6e31daf8a8a81cff9dc1f70ef3727ad0b349315590c3c09c11ef01cbbd3eb17544b63e93a335bb7aafb91c29f84338ac4cb2db938656a20ed57a7a6414a19922537fe8e0b26d1ec5d0c3370f5c83674a1e5d59240dbaa01e2acafca386c8ee8694cdd210355d67a5a2337e6def809bc3413638f890bc413db70722b663c51864e181d167debd053626f02bc31b6c0775e5ec4c55000244ade71e65679ec7a6b4d94743a87515fac5b1484aa6004f27f24c5d5878e6b5a75d20f292332bc3cfa41f26b955f4bdec61197fac18c36467a9992597a532cd78a25f576746773f02b8aee4d5afb37de5c04117876eafc9be072f7ee6e670012993362fb550d84ae1dfa55894c931a3dced7d9c701a2b1d3741dda2024750a2136fd4123cdb07ab98282fbd905422473aa4a655c9d91b869b31238dc01ed1bd2c500f7625272b08dbe4c3ba63620d7c60a516a1a7920027128f50143eba7d5f465ced9529397719c51c743d4cc716a475ba2126b478842fc29dd298c30e04d6da114492e2b09e828c8ec71b3c951c03b65c7b7f5991ab3cee369a27d8dbc858f8288cdb01cbb1dbffd0bb8221ec4279ab22e3c68d1438d3fe7a7bd693ef9d954eaa377bcf6f052c300c4b065d5736cf8fa6484329e4c840185a911e5a67e0ca28fd6a3b373d718a30b23f459bcef8290cac44fcc11abe309194576153bc04a87f9ec9458be9e8801625c4ad8e843b165fa1eb04b5a9b40ab5a301bbf249bf864aea8444fe1039cc83c5823b5a01907c4f889ed35712a73350dd0f61daf2c130441683a214c2328601281e391d1aed8bee4ad938e85df1f46cfc8fdd54a02f55fd99d000f1bdab7fa6cfc2edd470e5f046b83b6018de7c4dfbb8d806cb295519798d689df37f91887c7c7427c0cc17fcbc1b2d6c5c017c743d7644546246ce746be0251757958dddcf7eb67cba15c027ce0f64bb10b1d453cbd4ec2dab0ab215e4b264e7ea83b0274d68fc3f4eb5f84e3bd73030a110c456d6fa3c1659bac4840d733c3fcc00ebe28c92892ca7eb66f5ee96e5e4d3021f2188420a8560851de8010bb48a73acab53770823f38f46a89a7552c476ff90b1dbd0fe5a777a814561f3067eba0e0eca2cdabd06405a432a922fffeb70d234fb82bbb517ed4bd11c0f751c0413e0f3808a0b96ce7edc4208c3ea9550be264baa45f3b68cc7eebb72cfa18eee40a67e5a57442af1920cd02a94071eec192aaf8d104e51b7767671c87309e5dea8a24c6ef512ea3571c683327e1dbf3a8f0e00bd9f40edc13bef0db6600c4bc25c6e8b4a6b87c4a9ac530d21a09b56b42828ea0050f7a2235992beedb86d91dfb53cd5682572d3ba0abd4a6b92b8a241d7b4892999829468abeef342d217fe1c6f77e19040620af18037702a20eb9c85208feef96ee394fae29e393697e156eb0411fae217c95c981e69b5f8bb2211f8c3fa72eb83833531d406f97aaec3f5454473f7df1413cb72bac9e88135f4bba2385491dce525631095239529a62ca7910eda9b657b557b40514d2035e6967c2a01f163e3860799c170d8439af77640b9388cdd52a00018760568f9f29ffb880eef7bb734ace3335254b6051fc0f823d7af5ebe17fc63ac0834f6d75f92e3647837b8fcd1801998df3308669c03e4cf4be5d701c9f829643831dce28677ddb6eac0c71fe3f58528fdbff0e3f39ee9502b1c74d64bc74984dcf39a236a1df35cd702e0ba735fd71de39e2d664a4a372257d9054643d02f0e851769b9fa1e0f2a2dc400e03f5d951368f84639766264c82f4f15359d9e6dd5e693aba1cfbec628f5fa2d0039ce8b11cf66ca3b76df82c4f9ae435f4d6c79dcc3b0b9e37caf93889d307cf0c9ae5eb2bac1c2f6221c961cc810e9d5d25f91341f2f5bee43ab99e659772acde10df7bce8447d8f25b9e25d31e0b28d62a411a59a82bbee02b269661f26ffe0f3a9701f5cadc6ab79cd6644f4c255784b477fe1912ea66feec3df1ef6270867a0683080035ef2dbe9930a6d20b40f35618917cdcde586ff6f76e8d76acacc17e6c978e156c62d676b5192acb9f8f3f3a3a2174bc680328b91cb11965102ae1c9e78b516c5b84250b1500db1e1a56eb3bf98f0fe0f44260a166288f46bacaf6dc3998f9bd7f85cb791a71c567a81a1c0ade7f347e665b374e9b5ed5a0f935e6ab7d5fec9234c94ece9d624a245e456caa095933275755e483b56bd51492f5b8ce49912196113c2db7605062ef6df878aacad22eb36e193e5a69f2f62f945fb532b960746edfa99cd5b3a224dbedf5aa6d2bc1f457595e11a0386564d626bcb1ec31303c6b841fa07bc35b5c6bba41f1baf22d102a046d5e6aacf4cad79a851b5c76a8edb3b287215ab4645ad339359ab386a2fab65bbdddd4b2cbfc612dc2a481cf936381fb185bef51009140bdb7469c00cc117bf832fa4b7861a5d31547a464398a7100dea765c37d1e882bd9ba60115206b3664764fdc261f805b0e1149f0053d69a0ef0bad5f014d5798ddb66497f9c4f0d8b95e59ed8f69f0b9347c8526735c15e6979e97d17a0e1dfc31dbd6271783bbd070f17927dfab946cebae4d680e47838afc7cce7fd1e1710c948bc464cd71be61983422727b0a03d0e2636426b7bcf6b83e98145544b13e9684f3acfe99ee824436832f10575829c3825d57ae355cc05112966d8ff6a4d6a556446dc93f6e8deeb72cd136922f078423ef0f0dced9ffee6628e7fab4daa199c6f7fa0ca2a74b2947ad311d09b6ca494ca8fc1d5f6d6c4aa6a222e06913253011c56da05c7ee24dd5c06a0daafb6d4ff044d1e86e8b46037a98123070cc1dcbb453c6005bb1bbf6a34ee2d5c32d672d56946d041cd0078b4a91e6d20133d7af309453c6e399844843c5316fb37edb77b82de5a342a2e658fa95d1cd6afe0ad09c3ac7f22b841a27f28a06e756d7f6b971a9700f5f85a0d8a6e8476a27647071e1b4319ff0f8965d89c1bdcf3adbcc80c6d8db44fafa9961e887b37f574dbb5c42351bc234b34fde9525df9185074c18330c37990219965f7c0060ceeaf3ffa3a2b47ffb12636a404dcf48af48ebf4acddca24d59adecb7180705d7f6a91bbdc34edd8423589120311b839243605ca25c294d5dcb14621b0c479df1d0068f9aa58d4f40cbff29c455d07197a728c020443a579904095ff2d6936496c3c191ccd7b75cbfd1d3089ce67f996c3aba1a7cc1fa846024ec2c1ec9ac07a7f5201578673590aab05c3627afce602e85a2f67b2f34b628c441b28eda11dc95ecc00939a0a99eb09ba555d431744056eb7f2333fd81c45f11c1ff892633253cf21f61b3954481cf4d9b13bed0aae1175a51a7cec8211b9d93df87c42d209c62a79eaf4545d39680e368d5b923be4b6bda2076a735be2935419d330dc3990160d0a52f562ef5422080ea5905f8b106db75bfaa364bf9a64e11376ca32d218052200bd08b1fa45ae01556ab91500d37eaaacff22fc9c94f2271e411790fd8478c6907bd0c889130ad88cc894dd88989dbc3008e462776cc051ce6a7f2787604076a82266460558bc68ad4ab1aeeeeb7b6f608533860eef658f2530c67c7ec4f89e244b4dfb84285422accda7122b5b5ad80f460a292bb949f60af5bc5dda8a88a348f44e7218be2969710534ca49c3a3819bf0f8709aa2dca04964e5f851d803155d6b33cb39597f917fe4add1026ef58638d1cd20b2c7e0f2c46e72c95794e31fc17217d2dd586c83856918b026a67a981d7b025ad6047486860ef4531b868a2232fdcca028338d73939430405e184ed3a11ec21ca95d47d48dd884174c2a139ac9e6609a3b4e5cf55bd9caa088e7187dd81f17b1b01fcd67ba3719686de4c19d66b2320ccf038c4b189672f5717ee9419507dede416430a1d5389fe3f772f7ec789dbe29b0198a36f8190a12108e281a83a23781fd9030ad708e7e6e2605126a7ba85e5b466ab4104d66b7096d972be06fc1431b00d2fbf1944a2e1095b24dfe37935f7a1e681ae220123d8625064a028f11dee67ec57b6718da752dbf9df5495595fe738f2ee853923d9fcbb14f035328573c73dc558621cc1a031afcaefc6cfa0814fea82334b2a3cfcebf5a68b6a46f063c442cde954540c3bcc01d7b091b5f333839f57f347b3eac69245dcc7691bcf5a37423680e3bcc0146b5e211dc1fea2250c79a133b0003ae56d69b6f54c222f4ff4f6d346513d543c8e3ce36a646e3761a9423b0fa5036b613da4c989f7531e92edc44d8ea0a9a4b02500fdad13c699bdb04a1e422a6fb408bcbc8b0f2cb9ec1d0ed1bcd029ef396877ff6fc7b2bd0d2f32e5129a53e07ace520dd7c750500965496118c0ba2e224ce57ba8fdde71b9feb1178e0f429cbb9fa6d1d260427dcf2976e45f778bc03e9475e5b780c9f25e543c5e2d7190f695e7fea1412620e88470597c0c5e7ce5469348946615cb41b79ed00ead0fba025bffbab9b2521112027cb084799fa13f1ed7fad93e1abe54a669b657d7d44d92f90b232839062e19af010a57459874bedd2f8fa1d1191181c0ecb010c08c9661671ec7b31239e8c4718b577c3a59edee4a7b3b9b4d435b30c23881d64c9901104c731a889b47f510c8b5fb6042ec519a0b340406faaba20f6b2c0ec15743aba7b4f1e3288cd3e97ec14fa5a381b6cf7c3dbd7381cb2ae8cf0c58721b209493f17b2fe869599a445f8d82804a62c1f585394d362109ff7ceb371f671be71bb40e0c64b8ea8ae55f0b1e90ebdb8324e24651461b93a782f8bf4c0447b160dabd357e57cbaa9ee59a754da080025f90f3f76d21ceedcdac780a1f6efc9e423757178b526c65e4b575bf0c669b640d434f19922db303c9c27cb8d3de4309dde8c15e22de638a464a8cf2b062b95001553c7ac4b5b7d108ae648ea5a4cb2bad43056e6669da4eb6fec7ebb79d8aaff8b9f485aedad5c7449f5804e77ba90d0f6de9085df18f070df30c8b4bde2be8d052a414fe6ddfdb7ae5b42b12a63aefd8ce4e6b8cf1504e79710647fff65d9fe564b01275f4143d7b3082fb029157df889ddf20c634d5f4c24c90701b1a35c5941e1747b8c959b1e69637592545af668f83513686fb02363bc231f80aaf430e7a210d7881cecbe548569d22c47a4f7d5ae531896e970c199275af87227137fd4fdd6c60a696bef1ccbe9e0866adc27f3fa1ad44b1f88b2a7025b4fa81633b6c19552fe1a59029137a7d921501cbe554d61d6c404916ff1c683b04d9bbadacaa04c3efb9c3be7bfedaa539e27776035faf6d19f15ca233fb670d9e6e80b7303a06f931e23f3c5cbb8a82dfab511e29671eaef6cdd43d4961c42627fdfbba20cfadb6ae8bbb4e0de6b4ae6198eaf90d81502597554504bf715cfb8b1559b8b6e63969fa55f2647957287493bc6ae69fe9ae95f2961344da6e367713bb13c6b00e8fe1fa591c1d80c30459181dc3579e9b8044dab08bc148641bc25298de9364f6876c6f2e2d2086f2c4a8daccbf48ba26724921cf921a965a40e645f588a22603a3ad9d23186bcf6b524253be06039cc50655ae9f9effa6b65d4526191eef9d5de8090f61aa386a58666473384b02986f0f31ef624287dd0802d42ea77ba64ba303e9d4446806e76f3f47a7d0688b5bb47ec113cf8117caea7e1120e1bb92497bc025aa3831c1b6e035938e34b4c48b6780cd5afabace94eae1d99aece20284746ad7d5aa601c94981f6693daf99aa49efa096883f81027fd6d41ae7fa0391e5d87c680a89a887e335b727a6da99b15067b471c453fc65790214a70aa86f44b6882abef263a5897470fdc262bfb134fdbe374cef8fac74438aafd848a6cc5a02825235dc633649869be9609d1d4751bccc59145ed09d82b10ed21ccc1c2f7e63b99f4c19bc3564ba2478e75e8ca79cf447615e46268cc0c7a30c4ca5e0396cb32452e0877647dbfc2987500365961e9b2c70244dd284d133cd7ee46442f5a6823ab25a0487c6237aabd8f9e55a862c33962a329e9a69551b4f53280229e3557e79f3d1479909ccbe76e1544c107f7955048d6ec25295292d15b136823643eb619c2cf7789504eb4d1fd7e63ded1b263688faa641f971939ff99ae9ad8b85f8fa98282c94a9fa650689e9893e9b217d0bc35306359da73e7981eb2f1a03bac87fb9108c6fe28edee58bd314a08bb5cde75157adab82bbac69b52c05ed7c2eafac00f29e5184e8e06c83eb56984021b97a786c9a93ba24a9758a5477be8d19b7e34bec71ca07c89a2dad9377c2ed763cc1a57df3c4fb684510e7e59ac716a631d487c250cdb41667296c7e7ceaf71c03a45c26020f5d0f0b27ffbf36581e783726ce99e7c4dcc4d411e606cbcc4f6092fd7104122c69ef2673228372b4a44e72b758e3e811a7666d3ec982e35676c510e7c5a13a76fbf2b7ab1ef537229ebe79b593e2435091b7418b75b1e0d44ebc3f7bd9f356447f582bf5b61b314905c2c89f5c917818a912db3217079970395ce5b89ef3a6ff0d9ccc99cbfea240e1cd7b3912843d051a246e41aae4e1247dc842ea5d6365a8b5283dd2a56f194a3b386b4b059e2a998a55ec8dc075fb205e5c48d6dd9dabbb5911b859da75095fee0557e6f3a5cd532de0c360f8bc25991b3b5ca4e561e359209b71be562898e8e2d5f0ccafa455d4f74e46faadb9e2aecd7b4b57b18c3a098c4b7d2d72762a776b5db571f67884842121835df1f8a24bc8013f6b536b428bd54b58d109e5367e30b492506f65e2c6a4eb0ace68d04469e2df0368977e571827c2070b75e4953e8dfc917d66974c990a1ccf866ea5a1b3ce72c4f0a1d16a06335b2e3a253a70bf1e74d6a8c6f191ba9551c61fa10c2270995986052bee64d217e59d282b7b1fb1535e3e25dae59ebe3357a223226a14ee2cac4ec8e334284e78d2e5c09115410a197d88b94a5be87b4b443bc50b2842f58fa24941e4a581111d0562d4177cd8be6dc754b6b0723a6a338481af9b39e4c662f5e11f2e14292d7aa0d954bcfb6106165ed8b87d5934e7d7f3b7bc02d6ee8d987d9769862fad86cad154fe01bf61f43df571f6213e429dc7b4920101454f6c2e57b9d0b4597b880f671edb57a7a747b4c4acbbb9e16048384c9ea39cc700440eae7a82c153a3445e7ad811140ad19abedeff825a2c7db92adcbb5d2cfa4a7a905ae0283769973343966d36c7aff3d1b0d7b01fe5d72c3b957d21e1ba11ffe40864f79b02014152eaa8e317d5d26a08e518f98ea801ecda5bfcb12752780bc4f861853100afd6107c57fe2e8daa36c8d1d8b1ca99c97b93442c63447b8a151e167fa37e9694707951fa222bf5736ad7335b8aeae72d17455f9bf050aa048a3f28dc35ee7ad67a867dc045aadca8451eaac226b6e516a136633f6e467a30ff6a6043626019178c2423b571e6bf181858b2e0780aa6d5191ea5423f67c3e9e1c8064e3130157ef871671b9ae7aafaef1c65d0072646db34025a3b60a0f9d8f1727e6d1df56867fdfd709680c2c1ae022647c6709581483f6453e56fa857efc73ca7b00c70574c33fa26349cae0f367bc768be65ce6c8e26c79c9765e6239014eaf096cb722cd5dae631c85e5ee98fc3d401220dce7fad73b526b724febfaa046727f29512c695815358d3a2bcee5ce6dbdad6b0eaafae3963d77902da3073e1739376dd25621d9805d6e5fd2f17d6d85e21b5fc9d6ef5ef82facca6eafe712b3a99ccd7359cfd88448bb3b28d55eda8e530dae65246d9150a1b48175f4133f3897b64a74cfce6a4d35e79b01576f2be30ec2daf172877cc0e296c9850e89f88b8794da56b287b11dd455a011c059df30c61e943142ed73c2b12dcc119cbc7e2278e3b2e93c2372fc3e6f2f24b21db6a319bc23a3f6d1db446e21b06f61f44648e47f25b375a995a64886d99bef9d058ca1aa245e34c4cd8a306173a37c45dd233e3c01d4235ec0f32bfb4e53c9348dc94c75ad8b8295523088f298a76fc141e601ab54639d15c08477d6fc37aacaba2451d126d629fcdb0384380080dcaac6de6b8d9d6c7bcbcdd66e3a0c370bc89a29c8b4eaf2f3ef0aa34a727a903db59e7b1244a1b0932d8f2a9c008ceb76891cfd52ce3bbe2662bd3a75d7237ab42e2fbd5a5bb5fb1c4eb3babfe940c69f098c0560a056b7daf55de773e5c033bb0921404afd17384aa2f8676241b76a6663caf4be8292c1552390869ffe70177c436a5ce9d25273287b203ff239544ee99f54fd36d3f7d1f569f4509417eda91e00c207ba1eb0c3fa31c174e34b3b5e23122fa08e0f568f53d103529f1c1b8f26b63670899324100f46b20cc2c2e87c147d102fe12c72fdef8964c66b5954e4b9d0a3ad4e1d5f669a50d8de963d6f9f464b6b85eeab989470aabcb62cc0d389da82e514e0b74734c7c35a9668f3829ccb1116cc27ad18227ae52256256b7adb07aed74f098a25f5f92558d654e0a828fb49206e5d10a487de3c0efea923e0a75892f2c5fd0dae968d124767fcecb59e8370f6cfbd23864aa2c7cc25832f0ceed48945f01bebeb7ff56fca9c3590665eb2f9c96ec3fed6fbcc31c8f3a9372e80da6b8437f03074ff64892020a1e712b6e25082926da1b97b067d62f1464243548fa85f00621b18c469fcbb413ffaed07959bae458c98626c385d9e3ba8ed21024b2677d768b00d62d42ab29329e8b1d58f44519be49cc435e58bed35271057a33aca8b148afc6fe7d5c5cb00b0c6664fc2c1f41eacaee4aa2ddf48f02ec80bddf8fe6f5fd38510f2b7e5ffce840d0657fd7d34e1f7a9925ac33193b6eae6244b7aefe593b6a4f86c2986cf7c0ca4396f5182cb1e607b2dae62349b239e213db0a7e30f0f7f8e8398691839cfc8dea674e142cce523805146d81989cdfb750b694b9a02c1703433b1e2571902118ef07c8fc86f4c2285585fa3cd9dbca4b0a3d625052643b1e63c421090bf76d5c170cb2c61c1db381ef5d98481e3d973e2c69ab0c231e37e5e0cdf7c637c96556368169a7acee55ccc8708a7ebc668f4625898bb9b2f98b872639a564c1c5d348ed6b06600b97de08b5d12de2a0e3501167e1fb59d20297cdb7279abdbf6d6947573960a94c4d50fab7d04f41ce065b3ada28ae26b18c9f3d3449814a82e1ef00a86ffb36a49f8e49601c7f22b7698b7add6059989e315735beb13a364b7148d8ec4009f871f0bbc77d3d9a66d69a5f66d2aa04975afc5acf8d0b9cd0a23b563e7b174e21da3c06e6aa841c2529e3fac27a3ce63eddc5fa4113805ba747cb22f08cf29c72f1bc3162e34805a0cdbe75270701d20bd7e5f3012897bb1e198572cdb7c498937c6219de302a0f105de040f4e85d2acd5752942eca9a621b0694f7a27466a0efc55214b0ddaa325056344ac84167efd1e6eda31d5a4a8cf1554f09ec16d79acf57a0ae3c804b4a78f4243763e921d635e7d20dd8efad9c8b87f571c41ff5c1d9d7507afd95d7c23f6295e97b8c1ea63c9a3f7f6f98497c391289a72a1bd65dc153db33b30a7d2649322987ed8dff20cff91695fde0cc59022e063b5b171c1420d9745b14c43b25a14acbcaac86c6a8b162e333c8327095ff84ef6dc226535a58036260fd747685eac6a230d79b824bb56a885f7016bc9ddc1b50b726a04ff5662441cb7d5841cb9e7d2ecc712317095b6f38996f0faf94966af190504329927dab61f5363b94d711639e19477df1a1fdb870028c7e9642d1c30156d92ddcec733fb4a6eb2fff33a280622594f0044ec9d86dfb92b8cca5eb703dcc852afdcadd99b9e3d5dd498399f1c7454e751eb2c4b2b7886346e9d6b78f3aeb096bc11216d2baa916c46b64738e8bb6b2397e8be4fa57591e860d07509330115fb67aa7b208e5621eae69e0907900a18908ca91620a529db7350f82d013ce7bdea1860627c2846044edb51fadc68b53c9482f81f3d86c3d3763b4d0757ec28c881614cecfdced3c0a6d25ffd5dcebdc1a0fe468738a5fbbf5224538572ab694d25a76714f496da7220e538a0cb5f71467c616e2a1c8bd8b6c2cc7a68ae709884f10c1e895839b75ad7d39da8a39f689011cc303326f35947e37b623e2fffcce6aa97f0760d90b1b6cd8b3eb8ad5bcc0ef8dbc00529bc9340808176e99ed594d214574b1d3c402e5ee70557f413818c2be03a4da3795c099ab8c88b70f567bbd7363084f8fc607495deeb40cfca5e0b6f6f09733ef223edf87a174d7521b6a79ab4ddb676fa83c2144f9a1043392f1dfce517d7cee51005d521267ea74f8758a7c0a5c926e8a6d86d0dd6ad4c3401781a54f752526451f5327a839480e63530f462d35b04dffc83a9c5a550fda681cc8ffd0c473aa7729faa8b892188f42d070097e72a585ec94bd1c0a3fa2804cb934ae2b8f83d07398c5004a9227005e16890d102733c116f11ba45960db3c04c692d17f237e4bb6da308a220c35345104584fa5ab869e9f9c264098c05becceb56b28a8f143fe953016a27b5f85d7a98d578a7e77ef29defb259ca089ca3e5c56e9a1caabd18efa301b9a9dfa53a9b8d62113b5fb0923813d91e4cd68761d98fa59df8a5ba7ab2d8da05a47b33f191fce9f8719b8d864632a578ebe1e6b16a8fb38113f874b0cfb2f591fdbecb5d07750473e22d06d0ef57f35d7cf7d63b5beb4d82c8f44d483ef6f76c7946a49ee58d1c92a1293bfda043423e86156933160f86d79284d205715e633eed94670a6413165fceb1b4c2a919964ee16be7c6d234d7af65887b0a073bd3fee3379f950a2fd20247ef1eb45897459938537685ab41af4bfe3dbe85b3b6ae803a5589b97c48c7b5b59967f42f10ef525791cbc223bf40143d838cf28edbfb02365cb8a3ba82fdcd35bc6caaf008d2e6d5db78b0f94dd6e2e4689484cdd03f6b488d174b3eb5acb5901fa72bb84ab637557d3faf87b6d235e2ef17dfbebb5433d6c395d1ab943b0df3cd5e5d823c044601c9dac1da8c4cdca3535b06f02498b32b7ada774b3e9563ea82b37407515cd2df57eae510de9e2eaae189a6ec27fbfcbd2bedaff58cf35c87ca9423056cc1ec8874e47ad59ea5f4e01957705364c6a76d1a5ebbda52fd45b89b7e8c9ed09a890f14008e42997277265bb79c4ac81d25b9e2cdf2b0f67bb5cda21349be68705a5b661ca55c8362da6a9658aef3e19a4ac241c700da8f35044ed6efeb721024de6045fc52469b8848325cc2a42b567bf69596089d1469f79c230d004baed725676ea8cae1947eaa49d4466ecf1a7e2aa527518eb56eff6273be50962e1e33d82295767f4db2499b218c016b85b9fded8db16a075568a0d482487181558bef083aa4a4d19806a16748738b560f732d5d06f8e68c882ed7d4307fcaf623eacf4d0febe55f967e522f9bad27ad448844a0a931ee9efc2eefb4a51973f776719ed8d152a3e7116953290d161cdf82368ff978674cdfc0fa8aaab5e73fd1e099f9c248dc463b6f294fd0c75fd59c7c50938123184cf8d35692486334d13ef8faa82266c04a9b791416d1b410deb926ab94b2ccaaee42e0f3f5f6db76c85194905d7696a53c1650030674a07a9efce8027907d11ad82af8137c058e06c423318d7b2786eb1a6ea3ac37f9b36a934ba46bac4a6958e984cfa11f2f61875f6766e8c5c8d4fbf18174d44e66731e0f9f735e1257d3e0fc5822ba3661dea5eabc8d3e9755eb950e2051e1936d23ae0b6c8eded4f5c6736fd0d613bb2ce57f08a479fc055bed065d097fd0db80aab82c5234902e07dfbe0ddc41ed6b5afa4cc160d75493e22804a5b52224e132f78544cfd711bf102b426ca1002b2456432f7d904c2c07f1337d4cdb8281c40d13004cfa386a3bdbb4444fb76cc664b9d622bf03f9dd0e50e2775d5b5c7f15520494d7a52563c3098ddb3fdadb258a6c0e5cc1931da6b3dbee1f1b23afc1a7989e553","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
