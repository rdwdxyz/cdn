<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e124f33c99399ade61bbf0e08bcf34695ab31e719710423572deeec0c1f48c784003f64aec8b4419c63ce0ded9dbe42bba46157cbe605d903c05b6f6571781bec71bf89a9f8995bb501f5e0caa5d079370b561dafec33dfbd62d2ddde836edc22841b17a2e932dbd22e626a71f89003448c1207f85af618b26389e1bee976e9658be77301a5c4e13e3cd576fddde60a182029e0d889325e8cf6e71f820cdb30735aa64e7c14c0957734479aae22d473d8297bf7402ae1ac124b2713f7b92068bdfeed53ea8f8c5893e821a2e132b3963eca4d9c713e186a7454a449868f2b89086e9eb59710155d4637d7d679b13e153698b46485468499d98ee881c46410d5dc7c5bd8f26d0c4ffd890a297772cc4cc20eacc381162b81fbd9b14c4c6e696a035cf799147e33fae01d75e6cc54381f024416f69b635f238db13ba3e460a31b58299c9086f5230942657623216257634fca47e0ec4bfca00a4330aa77d7a249355620be7170b4d0431ef6ae48d23f731feda192992e7e5d3c4bc1e4f95cf50c215b0caa508e4c9ad3112da37e0398dba74907415407372904059f0af98c06539cfe5dac165e83440cce32d4ba9779b34715388ac9c65d321d0f8d4b3587d055cdee2c15c0ed6c3abcb3cb376cf26e8b70042ed0ed44c1a07a99acbe727c1b61ea0b20e77b56dee7ef2425eb54f4ec759e2afa598c086d69768a2ac0141e19148a4dc1f47ec7f08ab0a617ec6ee545775f8170c78b563bcd62701e191d7302e6c70a72f73f73e3ddbf9eaed4a63e49387c0d2f855dfb94a922ae8e59d416f3ec9e335e3d2ef5e3f64df509259b8e2d7e36f340a4a5c0b2635278de7b898fe204500a74e07bcbec22d2c96d6e655a13d90daecfcc2b699255e70dfae6497c79cdb0e2fc64d4b8bc8f3e59736bf785ef57c3016af83e48a8f5c93fdb06d1c088b9b5b77a13fffcc4a91339f2f8cd985a8e590e93da7f3e2fde268f8dff70a44b775736a7211ce3b2c55b4f249ed594430e1208136429a79a23e131ea1df0c993fd733a72f88172d95bbe8fc7a9e666f992a20f721080df459aec87a5c92d9cac5d1032cff4c2d64ffdaf252a66cdca1ba0f5bd3f52f1980a013055072c7200df590562d20615f0b1fe9d3c8a7252e8009a5549f07cb25eddeb56968835e4ee227a025c9ee304101c7216b8957c4b8925955eb6e20b513712ddfaa36bf759405064df2f5b138c870f970cbeda0a9591664a5a0b8eebaa8daada81453abff8dba26bb9b7ff9c4c2a3b6db1dbe13148d9367bd7382cde7e94a1ebe048fa4758b4ded27c4e3aa406765b915299b337f607fbd1586f3dffa2bb3abd6d0977ca3cdd72ed6160fac7fbd336f0f8ffb8b84fd6bcd87038d2f43b60861f4cc7f9011c9adadca890c437ce83921814d4f1f2460b1fee2a3570d27989bb249b4fb66bd5f3463e7a83cf822fdb90d48ce0c5cdd18267cebe270b2c5f4ccab35f2dff175ba8db1b09622bf2bf676f660b02c27736c9a7158c6f5d6c338f87fe50675d6c8593f6de82f2ef77402da3605868742a22723fc569d0375d518a0c6d4124e4a78dc6a9662f9d1adcab91212e03326c36a3c39004e8e3b3fd8f0d1a8f5c185a937d8f0892b4985ffb9d10b5b310f6abe1ef3adec906c3c1a8c995d7215749f71389eea21b8cfa4486accd98d9756760f1f59b88db1f1ee55d857c857706bf674ab8325e781af13825b48e5c8020ce748a823f332945a16880190ef970152aec58ac3fe6015105bbff5dea082ece778fe20296cde6bed9ba36fa41abdf80c7c5bc6cecec9660b69096bb693b1a8ca4175f842497a20528d3dbbab4f4d52d25be253605b019347f5fd4bb19bc09f102ebc50ba247d41e89d3b980f65bc3cbfc0f22b3b429d85ce8ba316a2cb93aad442dfe93a2b721f5bd6bb4c8d08698a9afabb6fd52aa0cfddde5074a71ba7665131ad636d5f51383030bc224e536d28d012ad27746b229cdbc494aed0b2fcb676dfdd019037b84a6425ba1785a1cfc5edcee7b87a487997445659712bc798e7ad11df0c412dd2c6601790859d592b422ad6f61b6792b8552861b11662f41a16247c06740476cdd9697918e957b35d483159ef7f7f376a88549fbf5f8295f3ccb15cb7e92cd63ecf232f726478adfb61044e66649ef41fad7c12965d24dd3569011be9e001ec13906afe81b39f68e0fc747551f02ed11ecace180e12ee74b8d0af2681ed66c4b81004788f94c75da27061f7ca58333eb4383df252442df2936925aa6c7a1ca749d0c7e60d7c442b419251bc976755500ada0e6ca360e9273ea57bbea430e8d94fc4c8d3e04b10f971970ca50999a2defd46fe78e11dad34515b01fb746e5107b95ec4a002a9519688f7a106eeae0a9ee273fae9c57296ffa346f219db9bd95cc72dc3b075ba583f68bf41646c54474c34021c62d9b1fc4f4ea61fcc12ab6621c00ffb230ba3a27f296089efcf61744a9b408620fdf36ec856f026f0e5e2af514df5d6f73976bae73a3c0b709b76868a9fb619f9bf6bb961883fa92768d5f6ef09c49d84a91fcf34658ed45ef496d9339b48be2c44f54573d31d0cc48e4c9de3b5b426bf868c4603f7c58a46262af83a51a1546b42ff74c91145c5acc642a1f8951319c600a7044c79a7fe24458652555420be22e4315af262f08379c64144cf6d34535423c51de1e9d4cf0a2af454ee365d9963622cbefd0796e7f9a1d6d090019236fd419501afc7d933458722e603a0edbdccee34fb70110e7163db0d9b903285e7f11686b68473e2f3ab70b9cdab7e68fb87be5af74349669dcd328efbb31f85b9f8648f2d8c4212e70294fb3d73b9050c7c3f5c5358f3ce89c0d89903556eea47db4bd3ae8671eebd933b11720d83ed130fd6902e89b8f4bffd16ddf272c324179e50f8ce47b0128b011e8d793e163e6c7668f5c97ca47391204ec777a81476b3bdcf1eab4ae0a975a48bfac1ff15e6d5084735c9314d2c63235c63c7d7771e722ce413a9d255f9c668c110e077cb6798b4b740bf067d304f5a3a5f198088d2ea2f0b93497402135400e81fbed5a1896f6d737bf47daf620eb0a5f752974c894cf67a0a1d2f603fe152bfb928fa4b19b4f01e8b727cb23b7231f43117b43796ee82136601bd55c8c83b96c5a159ca36d859d2c3db7d9202d89cab69ab4845f7ec2d5700f9518708bc437455f12a43ab0bd87a7116c07d21980a4a7c08afbdf3f3bf9038e1dabdf169d628106d53c1927237a3f9302571bbb814a8c8a7d7fe9e5dd7d469d49405defd846d3b0b8c19fc8ea63b4cd3f686e6d47c348087223e3cab7ed8ffb013bcf2c295da9e320ea4e751dac628f175c820b29899ab77193ce61e34e738ba2be6a3b92859cd176c2415f6e4fa3e76b96ac9c219c2f51ea603b3dcee2b175981cdadb52f3f9d4ce2cce39a487b1f6417b60dc2ede65f7e01bc3a477ef7fc9cb8707c50758033e0b2c7cffe73c0c3cbe6d7a03c0058d75732a5287e64faa28e06f521a88a8ace6f3555089fcb49bbda1526cc1f0454f464e13fb85275a5a3a53f977dc3f6653e7fb9e6dd5c5d139b4f5184ae0cd518bbe1e40dc92d561a06337c49253e308fe2d934723a4969180b0476f717d65d80793334a35e470b17ed365d7b4c5a82360e1deb88b9fc3eb88cc147478417f1c1ae31c0100a33e9546e87d868fdd8221815ce329fd99f5aedd994bcd388a17ff8e1fc8e939fd17cef2a515f1aae83f57fdfce70f24c44efd7a68385c03005dae63aee759e174c3198fc0026022c2f39c521926e7afb279962837e8575422f6925aa999f99656c3b7827748226d2897815e1c253e878f50cfde3f815023eb16b9b72db5c009066c30247c3e2c5aa2e3f35ae7febd36c4cde4fc425e6492402b7aff12c508204517f16e0d4c6379daace281b478f9f1137979a79a50817822302ecf1057c25f05e73f015ac1bf3e6d286afb5a36f12a1a6637dc6576194f55a5cb267d73980994e2e14c415b043f3b0fec8f7f85bd19c1cb05df614d5f56d5f2e14b9d4ff08524bcbd8d29ab8f34ba8ae1d4f62fce3fe2831733c1771d46f57071a662606309dae5b1434f66820f0e715cc404176c1e69de54b33a85dbfc5168d3cab6e8866cf319dfe2e947a5bd5e13f40c7534004582aca3909367380179e8d06d3dc60de07e4768071934f11696b8f6690e0db7ccbfa87e7f6e5c9a4360a68d6d6adc2d0931b4821e7eee78e653c053576320743e70d1625ae1bc505a09b2ae8ecb40f0b57e5859a06b6ed82a7e3c1ffbf3cab2395860c19c3da5143749aa2badd1e86714679926908dc81c03cc646488642a3db3df528b46612976036d65b81a5987e3e1a3256dee88028d8adf5f22a9bec2cbc02918353c84d73ab656c2a21bad8e9765a330d16fd85844b10bca7680a316bbc315b3dce6bb3a54924f9369e6ca98365b8733c3d9690dee71b306ade55c9296700b9d9fc6ae7bb571f4896200ac5e8ea7814720e6745954a199a6a7ea7412e9b349edb29f809bea1dbe7ab69d98709b232ba424e3671b10d62714bc935407cbff7fe0220bfbd03b5ec9e2a09b139d4ff18019e44f29479ebdae243b3d9d591d3f82efbfb5a95a3019b946dd375707744dd6a4790427528014643364189658198e4b89cdbd71e90d8a07d1e9486525b24eaf4c647c4c4ac17cf7fca0df7267ae928df5c7c2405256f36cb32efe8693d153d0e6e5ea3d714b2ea627a9977bc01e5db12e753a697571dddecdff314f0f98bf312f63151ba6d2701d5a3237f9af582ad1810f7d0d1c96bc76b412fc49a8cf37af7402348671af03f5c3e37cfe221a8aff5060885165c1abf15e51ed15d8996b54bc505d3b8478ab23b72c5be1ee2caa624828c0adb608a17069458816601fe2f5821571c29ae0673a86754c2dedfb0d3f1614a0cb4debc96adef5930b7863f6c393c8889aa879ce4423ffbde1c49428ce0f0fab5741e11cbb368e13fe19861c9adb40130683146a5c82cbbd098275284fe45a55f1a72418f4ce7acf840c04a09eae99b3d820a1c8c85fe96a2449356f4f287c62c3e609105e67b89e0fe7924f79fe340fa03d7f4c16c2661bf6acac58e73dbebe2133dc0dfca87e7b70d3ca2985cafe2621080a2503f1ce7f9e933283a19c71c72dee955df89dd55016acdd46f4808550561ac29a1b6b593594f5d66468bf3cac1086e76f8131e2bbc027f4138c45610e0cc1cad09204938c1a2b7ac31b07fa2b890320ee3b79168ca8224bbc657c8f393d1caffe0fcc9f64662fac5695d457b1cdedffd9f293d4af56a246aeedddf809e3579ac710a2490dd9b9745a35bb98ed3926827ce88a7865dc8773fa6af845639c9bc91791ca86aa41de96a90c171159d323f6426cd805039eaa3f8dc342caa5deff08ac2d95829b69b0b7ac6ceedaf41e57d4f264c7965b7f3449d22dd6252b3a203c83e34647fc116c71574f1e2ff8373fe3cc609b4a7f405da1c488529eaec815a496fbfe59495e26a331abca92f47e883b6ea0e368185a25c14e9e989a8d58f76575741b757adc25a7366b70e1bfd3fd1f93abf72b410b78e0fec31fac1bea4e600639e5116b4781e6aacfbc55ae89607cd117b2525468b48365862384ab1c37cbd1db4130cd3741052d20c696f0c13f409d3ea5e29c3486ce882dd2fb2302f6396cf4e2a785412adc306382cf39fa5aba545c7604cf9adb5f971d63a42333f6de3887fb1bce1650d2ab9dbcbb57129d10a9c9465797eba07768b2956d680e46b4759f1ac43ed843d8b003330e1b8f72f6597d03953934005f12dda3956e4c6b666e4699034cd4119a8c6d28139e58e6d7177d00a6e8d3f374f858cb46055166d742c00b7bc7eb9a2f50a609934cdb41fd9a9c346cafc83c4c1165a48615efed4d320969bc11ac113c6e7c1feadbd0337b8d22283028bec7dffd143113df69b0d58ccc9fae584ec60a20d24bf4a7569f819b067b856aeba4cf3002eb2620948557520ecb08d055712ce29b01528d157b39f95166bffb55cad1f1f32381fb942c0f2cc495c093da3ca6c9d82c5b6c01c737c125765fede304707b67f35fb25b99e67238cbad2732e5118ef97797c0d21a4c77ef982f990d0b83bae1fb43307e12492ca06a573073fb84dc272da9c22d3cbf6b2176addaf60c2b63e29d4a8e794143d2076979bc6e793c4b252ee9e9b225d624be1f60e265059558ad61ec9e773b69dc2625bc3a6cb5d2e92edcca874811e65e1bc31046c91b0dcd4af3cff8daca5cefbbcb8598982c2c179f673a3ddad90f23be71acee4a9a13a71e21455324271ab90476d599d6af4d69d703d69edee3a0c6767bb21908ad883b8e5f64f4f7c003a622c796a8c705487b83290e23b7d1f99ec2a57371f65c1e20c2165ddfad5dbdc0b79c8ceef86b63a8337d989a863253a6937e58e0b965c202fcf3a4c13721b037b3d81c52f79af91ea191d1399320bebe936c5519ad1f2afb15f0cda653d26e5c92acccd612ee9730f6fa4b5c61d701a7ff6e10eb134f9783f7fa20c4a2277342c9fb80996efe5b4373250086bcd229ab87b7d90d06e48546e8aab0e7c14109ee59afdab18f4fc3e39c57557180166134f292354bdbe1d6839dca0aa5d37606502dd6735377cfac7be9fb77baafc9ffa360c352a3e1c945a74fccd81d94718ad17fdbd7d6e019fa2a4eea4c57eb15865d96f3436251b9ff7e7f577b34c91eebadcf6cd0db778a83b487af8ad851545ce59d9d4347793c113bd967567e1394a0568b539b87ac8c6ae4b3de3729652559d98b9385f22c98cd1d1750aeb41b45c939d4505b8f8a6cca1cd9c61cd5424fdf4337a67dfa4e500066324db8cf27cdfcd1432be5d2159347c1b35546f6f36ac0ce4200f1219ef3373fd4b87fa3593a7800a0b52d13f8ebd91f2a96316a9edf2fe9184e69adb8130a1e5e270deb6011ce4b70b8989524491cbbfaba6bfb55fb0bfb18825517a1b7bfece532cc564180ec4bea32afa0db18bc0664cd7d0f1a5579e4882c89373e66ce88db8a6220512f76d2176eaae4b4e58dba6a2a7a383caabdd1e32a9b091576536e8579896011deafce83cb61d02ad7fcb20000b24f6392f879255529ed51764575d3cecd1c63fce16925b788173c11da0c2ad91a0ac2d9739427ad15016137299e35534fdcef04f0a861ae081811aae72ee3c677ded31e0743339d6b0e06c4c4f441f62a1dca75c0316887c79af326eb77d75f4a6cc1d3c6e394637d46492d66992e156b857099652f19a24d4d0348415bdbf9b0ee3e4edd8852c0326cc1edb1057a280044467cd56296c645f3b83eba078e6aef9c6654b251f542edb1635dbcd366c9414dcf25d146aa6d4196cef0dc695814d0a712d098bc53457baaf9738a3691ddd6681d2c1c8eeb4b85767401e2fd0b94654173742dcd5a8a9703f2005df543095a0cdda1716f1053a1d368e1a3c9c0b82e663b833b8149d67f471d030f71d35a1d58890faf276c92c5c489c1299d3b784a83b66d537a63ff99cdf87290536cec1121a8c51bbe89fd3afbad0cca78849dcb56721dac90eb7243e3ff84677ac5a6712c97f593aca4684905ab4a08e047ffc8146c48cf12e615aabc882593ee230408775bb5539890e7ca86b543efd2e3777d1b39ba55355067ee08b36ece9b22609ad62c11bc3294baa4cd5a0c905cd9de843df7eaba19fc2bcd0016b1d4d60bd8761bc07ace69ab47e16436c0f2dfb55c9742902bc0bb4be7c6a803557a0c362d3a115f41c9bad8a73a84ab1fbae05776712ea62fb6f8843bc819c314e4be708847a7b64ad818938b3b2a35de0f1198a8aa416c0d39063f17c7eeda9ace4d3f06c2646a1b22cb7c60c266106c95cd161f1ea0ed0d124bfa6bb63dd56eca1d5670712d0d9e84cb21ad2f33d9e640da8e4283b12483d8affcecaad2eeaca0193ca595908136363bc3ab82c2cc8d2e0f994717d97a01948957f9b165f00c74450977e3f3706098d3037bcebf15d609da42881ac3c73cd49f6b8bfa43d5612f5c0754eff62f7d0e1a5501e173e160f498e7b25640b54d19aa07979c608a75bbe8f1116b8c4f61eeecafecbb6370c2e6b782039c12f2c1c8ee270cd42cdc176c25195ce70bb6c1448407de4de1aefc69792009a347d8fee9bb61dc2b03702a92256045ae4f7ae2d14551ab4b1ff054ca6bbca37e4b230f41d511f20ea1ec385528a93af336f2bdce3df5f00e31f75cf878d20097230cac0c008338abcd8ff9b5ff0a9c4b3b2f52132ba2231a5c9cbdc98d50b615ff56f559fbfb3642b447f61d0636dde49b0151344b933556296dbbc58e09ac26f83e8e7ce60451a0426a48860aea4fc115fdcb293b9dae7fdc0874f371581ee810741c3cd8b9614b83e9f80a2c458eec4d0bfb6c0f19ae25698f71dbe1a1fe214e54e9343b6ae746a78798cf809a5fc5fb87ba0d5958bda5960d9c2ec092ee84c8204c2350c286ae9ada83d57c29d407c2a9e4dc4bcbc9b7d81d8bf35a1b0eb17b5b81f76a015eee3721e165a34f307834adaa22df0c3c78f0b0d3ca2ca97743e06be154e106f47f49dd54b0408f19fe07b1b6898943d673c8b1bf1da1b3c5a320783b7c6eacbfcbd7596b00a915893d8480d3e48fe8b0047a3f55a0235a4b40ce6d9911b6de2b3232dfee26254b3068a62d2cc6b065969a7eab06c1cb46a434909806946bd861692bb2a2bd0b736b267003c5605a7d13e158b5f643e4688bf5aaf8fed492442e46838771b637339c4b0521a52cb3824e3991195d0fa25b22076ae338149bd89e6e94862d0cb01add54ec94c06ef72a368508b92e6e2aca10312bf26e627e5657416247ea4bfbdab5a15800a4964f3554123e1ad874ce571425d9bc07c3df6f420af9dce8ce1f6bea9aa6c1983cf35335db6f2cb0d76a40624a9681478c3d4ab2b5226d8a4bb88e0a8fe0db20ac3e56bfac2e241fd3a4c3df14f2bf08e7069216936d83f3dbe561823fa42a05614c0cd15316570a356bb887eca8afc6d30ecaf06950f690a06293965aee4354de49a47cd44966a054dccb1195c8ddef2e9328cbfcb041f82915144b2dc4bf91e750813cd993022d0a9ec256920c1d139c5154bef7fd35d97a1b0d5771ba47db62b90330e00e5f13dd1569084cc5efd687a0d50352f4caf414620dfc6d58281476190cf4031a23df7741cd91cbe6447eb58afccd67b02d8237ec91b80513473059297eb885fe96abed9854c25cbc114349ce3651fd8503ccb9794aea0dd7b7825bfef5f12f094f7ace4e1a317590e2d1cefdebe2aa3fc9d6097ea12413d142760f2d9a176fa0d00ac405715aeb5c78b725235dd7799c0152eccef13ee72fe8fac5bc07163df967923643196df1b272fd94a5514b49800dc32853565f4b9b701976ab3955732be7870a31277f736ba43267d2b551bfcd0ecc495c0fe017db999ff52a5383603410dc4bf9365beb3abeca37eafcc1db76e7d89e52aa9c62f9a35bf8094f3253ce14ca62bb8aeec192a961c026c773dbd2d445ec0283597c293edf07ff53c5b333858c5e4812f19ee60ae9a9fc79c7ef4a552ae16abbd3b1dc7e030b7ffe8ad87cb407e5bfc7c823c3358be7c7d8e2eafa7364d77572b63ff3cae1b0a200a01fbe0a70f326175d304129ccd26925617ea5fad5fab2445992c6b63481969477c264dc0ff15da09dde91cf24cfc69f7e4cdd78f6f2da8778c92a355d07bf55b1affffd13158d0c79cbb3ae340cd3b55717f5fd563494cc5a91fd3f30666a55c7a1e3f598203236ccfb4508bc07d3f2c126e3d5c36476404daf0957365873614dc41d186a8f43722b70cdfe943d0347d30bde97db342b25b58f46dc815263e18a84c04d43590b122f85434b407944dba64bfc49ce1825bfc5a07024678815b4527d3bc198550fe37ff331c85fdc839b7549e5d5f97627947db0b393d515d5c6b218d2423eeb254b726e5340863ab5c314aad9006479d81d9c3ae7a3a8a7aaccaabcdcc64399369c2b5004186b7ce145c26ca3532c585e9e68349bc4b868a0e5d4736e9c114f7db9798d13570478c8493be3868effc2471398daa4caf52411b48ef6945886fdcb65ee965a02356bcf573a5690c6e65eb15f3a90574dbb0aaff01459920e1d6c892641694edd6d7e18334b4d0dbb6851986cca0e011d7f52c8e439b98aaa0e67bd75e2f7b94bd65cb2b27b32c8f44b1e78bb87fe3633bc2e890cfc96dff8c737d5184fd381f04d080fb41130c52759202996bc4d79859765060598ba689203c5581ff33b0c0cf424edb1202f93c1dec8361b1504b6bfcecdd31fe7fd5659ac3ae4eb2246d521de25c502b0506de6dcdc53b2548a79e08020f93a2670e0a5be9e44f5e921fef140fbc7614d459577c9ddd786ffc52e4c68a1391adae680b55e9a0a1a3a92f4b7d809c532614d077ab781379ac511ddd10c1479ae2436649b7788a1af3619ee9a502f739883181b37c8eda352d6061108fbc4359510413d7b8cce2c7878dc60b875c90549a24bf293a706ac6d0946394a0fbba840f01776263e0f0306afaa91eac283639e3f4db2f4e8b781bf1487a5f32c38dc058e8886238fb43552ba6c5696762f11d847efb346239db073fc68e3a41e94ac05b70a0532c034ff2316566d69a4993ed31e27e1386076d3c6e8be33dcbba7db7f99eb2c5bdfbb82a3d7b325fbf0f1e1c904cd8e6b2d78e8adfdc22672682211963ffa14140be849ca600d85441b731ccd613274e1de3a0ecb500b52ca29bc00e4bf74592e09d22beb7813a1ab40d164a2d78b80eb964bc2c8bf596101edd3dd05bfe915f94093f8a30e49318e6e525df440756fd061c2bd9aabfe6d5dffba2d132c3ee2a3260c9639a124c7e0b892d8c64dece50668367e200d16d6aef5c37d13f657c44eb9d2c57ac1f09a0a51967ddadfc4f17cde380137be7b6e550ade86685644f378d8e8d4da0a22678f783d93fcd8221be8404777f6384c960df4b6a775a87351cbb5b6064d0ea236ea0c7a4a071e37b1f7c2e48ce6f1206792767d43dc058ed06aa3ac95d4d0e7c78a3cb62d3ed676dcf3a6a33f5cc7fafd83764df2e39f36bb878d526109d9ad43dc27998342405666a39a240dab04dbf8293e4e95bd47cdaae79fe579da0788069bf78a800438023c8f49e6dccaf9c97423081eb3650a352252679d2bb04cf9710c314f6a9ef280c5deb61f937ec3fc6fa0c4ae7d7e120b5be1190f5f1a5a088ffd1f2d5670e958ac2c691e4c7feac877668b7cc1e4bed52bf01bb492f08cb17e7cd2ab73efa0ac638a94066b3a91ba361459091ba313d55ff0cbda76474ff2bd78f36e03fc903f20771b25a9d73a3d10f45cfbeba2d74afd42c1ff163721fc634123202fe03da6374873d2184287d5f17a0a24e5a14f07ba635bd031df179a5e6e23a2ecc7cde639d190730ce694f0117406f9bc8e4cf5b011f9b4c40fbe4bb0ecf1f771b96748fd7d1d7233b87eec2632319174f78e45aa9051346e279e3067ce6b1c008b2da73d5adf512efeb45b28e6b305a2e41a09ef911d20d1d0989ccf9cc140f3201320588a6e09f9df601efd32c603011f2a4fbbe4b6b14b22a6cac765f7b2f388aa0e6b10ac0f33e36052cb785e6db2faea35c157dafd99f5661413e88f1e399c16473aabe60ed82d9337033dd1cd38cb2b55be567dcd0c6c034a1bc7e9cbb667861bf1e0d6f10b1f02ea277056664dbd3146f8b404e0e6cbc6ea754c6693bfae9e3d4a217a48d6ff5fe978b4c40bf83bb0579cf8e9e6814eb67c829a52f4e0f92b979fa33a0b1c08833733660ac0bc5e6c0fb61b643036b61436568172cc56b6ddcbfde44c060c116615c2b1635e12c869b55834f0298c8287e9e0231cb08bdae9267fa0d13ce4ea1a10ee266353ff8291ec55182659ef88d72331cd54e6f7fd19eb3d426b16785a7a6e667070d5ab9c81223887f552d48519e286c9f943d8ce930e31466aee5099fab596e50b59e536f3f457eab09d035ae9df3ae4e6e7aa3e9e190badae24076a74452634bfbf726dcac00fb30953b019823d96331e4792116eaa663b83b32ff30da181cdac865681b575cab59764951b6da5898dc95eccad5c2c0193c5944fcad532a6f246995bd652d22f0d3f5a8ae91c1763a9d2e467fdfee1c51d74b43a988465d5d7a885b2e02191323e806e03483d6c641faa8eebb3f9fe095b975576cf3e971aae15b6257010b5c90d40e28ab6427d9df000f67b090692c1ea8f3487f17bad9bf7861119fe4198f06c48ab85d79994628d37e6c985cd28d354c7d1d5975eead6afcc954a803a65081f8ad2818874e112655646b9c516e95648c1506cf0f456672317c973d8fece62b757a237064d947810e2f6d7b023a129cbf371fabeb4e03478997e1c40874a129fa73fe2d3e848897dd9cf32d97b7fdee98ce3672917e8c78afb9746662a1713a46e2f4184c4f701848a907f0be370a96a656ad5aa8e6648857e6251fc3fed55fb303411be06add20a37ed18283a5c644edf6a962b5ae37b1ace5b31c25d81badb2449d61aa79629de73068b3516a8177dbce9d64eb7f6402977434adc21f9915cbd17cf77988f1120fed7298271b74bd8b1392faf2a4993b7b6cc93374d1e9444e48d536e7b4f2e6e4792076d04133e4636b9bd0c998709f1198602e50b16edaf3a802ee936e418ca157aa2c4ca76cc2a47e8911ceef97e920f0bdac36b3738b09898f63c8221b918fcd86585e9d437d71cd19dbeaa846604c2d28712d87adaedffd7ed498442c479aad88e8e9d7f60a7ef286fd0367772ca82a0a21835647693ddc58331b57d7b53245586f3701b4e40d391c01cce0d58222651e7777d7e1728315d0d9405d896369619d19dddde4d2aa2a401516cacf2b23aee94b5e3942b0f176179e01759ad9afddc965526bfb84cca3a9b889c7fbc3cf73a79e0bd0a2e797e1a550683bebac5b3a3fd5d0498ee2b0eefdd32b9625f0f3c3e67902ec0019705b6b8ae986be5aebede3db5acdcafeb1f16aecaf33015287fe07c892d8f126232c2dfcfaa81f22130753f23936479be5345ae607d5bca1d8319be20d52058f5770c167dcd147bcbf12fbff01c64486ce61eae354fac6e7bdcfcf33d856f739fad7a93ecfa61c78dbce4a27b6a1610903b4d710d5bf4586959b9135e239113e07375dffdaf24502f367776adb2ea3bc392d763d07ee746be58a2f531c908dc17616f345eb57705c4c7275f3e48168bf192d9c36cce68e7e91d9d9e68c69d7c42c863bd334a45e06af7e8219ca9dfbb4a666272f6b3fd254425579371f2c1c30528f29d74ef048badabbcaacf465151b1b40fb21e84ca2ad998f5edc9aa9b4f248a57faa18fc110fc4d40ed9c5acd58bbbfe915454ab1e5454f381dff994a2638e6164a02dc8ac13c80463cfee5fb71468fdb25c69115ac8e308ad258e20b89c77523645c9dc99b81157a2b3465ec09fc006912f4d1fc464d77df87708dd7dc819d4cfa4d4de5645f61d72527225dfe97aea07c8cc67517568c5f3d9fb4bed2ca3404889aeaf49e2e8e9ec95f63b702a73cf566966d80675cc846b4dd12102e5f46fe2f7be2196d6687e2ee5c536688bb24d39792dd2a55797e0c842f293dc4ab21da1129e6a7094dd43f30ae270a7b7d1c6373b9d3449c077f881724dc4a57566e7e3c12474d7bc57453e59e4abb50ad3340f72081556a8af0e61f11b1460cc9ff9c06f33c06bf1b7e4283276654c489d72702077d07091c015c3df99430ab2195a501b9e36f78ceb3954d486510d1667382ec37ce63d8902025fc717470805af677e4af7fed52f2dcb098949b91e8dab53a516909a07275fb840a8184aeed2f3341d254774b578e4a694e738447decd362186118cc4736a8644fa699e9bdc93e9d589d56b93aa3228258c7bcd26cc6772a2359395aedc0fbbe0fb5b360611f90d4e7d5668b098a13098b7cc88ce4583b24f25b39e3d8654ded23e02b86a04263534b99688597600f29d03a1c89c6355e1954464a521fe67f656c75b58703c2fa117529d18a078f5ecbf031859ef43642885a53d11440e90c34a6d7e6fa7f9b2dcc8a1023eec22614eeeddd2e5159ab41f269e4688ae18becfd2d85f844274a15887c10c137c186511120ab16d68d43f69e2d541cbdfba7a6f5485033d949c10a1c408164ae46b9e4f6d264ff4198576732ca56436eab5fe04e4dfe7709f173ad20435cdc64d0216afa9431c5e3524b7a9f5ffdca293e53946a2a25e4591e370dc1c5e7c83dae72b22f933369b6f4509e869a5490e9c823f95072ceef4a517dff02fff42a3677ffe66f9060540c47ef63cf643dca019b8296825aee33a4afe4eacafc7737dd8de2cc95607d8cdcfcc6d431fa93d8e851199d39fec192f5255c2f911f7c908b5dc81068e2abc4f81e724d144c82f3e1d024b5404909e5f8c7f007f7de510c84e6ab2274940592b803a3af6fd832f216565a15a8e5494dde2e44e1e632eafad55b181f00f659f56b159382916ad596baa584d1f5140edcb5ff4c186a24b754e034dbf82941a9c716cec5ca8493c5c9f17147183ebc0b3098eaa556dbbfe0bca730f0e1654123017d86424741ef64d4e3d2d9ce5fd4513915489ccb685df22a2073240f5c798b001218d1fef81b6d0fb01593403f48b1b6796e143e732ae62bedde01502c8732078e8361b431a65dd6aef095a97b9102ecdec259e9cdaf5a79cbc81159c0f421f35b99209914181d3d3211124b0f59603c4b0207d8567956d3f285bf8820d912e7cf293913f9de88d25df7b286fde5c079a74a7988d2d1a0df9295bbd3652f36a04b9811ca9a5407ecc07ecd5463c5ef803dcb8c272a4b5b583d337e6155d870b0d211a67a13386a938f29ab17c34e468eae0de2e3113e06972a275ccd28bb47a32840ca414af70b2bc8b8de273fea35b16fcba6290457c5d9d5ce62d21414ce91f7c52aca22c5b15de0e1c55e549b90620089b37935ffdd7c510c814c8a742fecce7a6b16fa3ae16de14ea8471879e619274561e00b8feb7f4361ea5329741d729fb0ff68c0d38fbdaa8ccc1b8faf5ca829bf4fa7328e1dace0e4462bb86045b39c17837159546f321112be23a66f76b700e47327a5f14c7e46d75e171ed8adeb4ca9b80f8a4de685c5b5b331a57b5a23304661dcfe660ca6fc0b91ea71d51d33c5efcc57b3c28373f9b6190d71118903e9e8cd2dcfe630180b8516e4efb4f932849907439b6a8556696fea226a10194cedbf33f0798f0849dcfaff59f9d5206a72578f67029dee947820b4c6583a371c89e270390043498c2da2e1b33e7a5242d287e2fa3d7f18e156284f03537309e41fc2822c4c36b09118946f53cf624bec8a0c7ff05b2222e4632edfd1ef0a4f3626b7b09e1d94c7ea811155936a9250836026c32e022d3554fa7ae314bd30ef42ac8a252289f826ba190584604bc9ce25b2330e43b0dfacfad5ff07cadd4559e80c74d5d5624c7e392c5a934bf403a4c74192393c543ed7d5ca14f74226f5227016d5edb0cec995c42ae5b403891e1f0ba44508295faea9af10c22ea367a23972c6285bd34c12c421d41592307c485e6b78b2b0d5a663b22242e28db15f58fa47427b9c1928b8911fa7d9e09bcba0c928dd687949ab5bbcaaab71eb21ecc987e85b3ecce3661549153c5635b3aa95f2a43703b9f168f4b3e822b444ec405b9e4fef1b0bb39dd5f0579338318ce77ae3f18a3400a12e7704bd96664fa7c51a89fc1c5650de8049e5a6c5893c243644b55cd8f4972b12f12c9d162084d610d9d018861cbfce0217f17c622c1b7b2d5b1e4f60fc0e7e5ad5e8a9404bf9eb902190a3c69f025ef99eb0e87176a7ef5aa611b322e1fc71b74507ff53f7174cfd085d73b015bc7df94da8118066b0cd9878c48db554b462a38c60656b215ba0829281737810887b4d6287dd05708621a95564c8976cfdae96c53c0859ba07b1adca907f4c9315e8ec78a2aa45c74b2164ed10811152000a51765548ba6718b058e3999a01594db1dd3eb5a95cee70d204cd391642b72a6601c36c5022e9fdccb77c876b837ecd29e06ed56230d8c8d72b515d6b94a2ed9faa71996521af15aeeb2b0d107dd3db7f55da9a1db014d400229be86e6d2ecdcc843c136d74395abaf9fe7599a596c19a5dd4185730270ffed4fcc162007973d8b40159228ccc123465058ab03705f05b64c983a1d2b76de064c177bbfdeb83d9b27d28444cef18db053a3e3f6e86d0be6f3ec67378e9c744d492d95de068114aeb4b0898873adf906aca17ae23f8161e62e1acfb1ce82ca337fad21dad04d84c4c1cbc43f39b806b69838eb261da6cb2edf70222e8c99bc3fd36bf6a269ed0a9cfcf192145fe89a71ef6999f1f8dedaccf21584da8ea69dff7797900018b04d1c4f4e6168ec0cd7f0ce0271fa0967bbb3436a0e0498eef365e343b34b8efd51f78359f413d5fa695b1adbf95151050a897ec38b379938877a83f1e5bd981556334dcc86d36d8f8a01af71094db72581027083b555f49288d4ff1ff84ccb716e5348de91b752a0fb63ddbdc8cee8bc81bcb24d6109e2dd787bed5efae2d7400a1304fa7f2440882af2aec8c9e22b3dcd8a60a7cb8d7710dc248f4c2e3e9793848566f727615c9525801805cd45ab9ef7f501c4ac91fbd3491516f9f109de0011f471ab496f1545966c85be685fbbca7dbe1a4bdf072acd7abf03be56987b24fc5ff457fe2ce538d2ff64013fd8b55a2d17f1d58990c2df7fd718d8996dc60297555e1e1745ead7aec1b06c6fbb61ba73067a14266cb67e30144f2516736e46ec589e741541d8110f07b8e6d63fd2cddccb7f62410b24290c0a667e2675ac4ba4e60260ece81b9c716169b62bbcb3d1e92c89d9cef1e21cfa0c79a415ba3892899b991d6d1cd53283bbc20f05ad82b8d57b36af0c34d3dd3a0fddfc79f9ff15cedc7735f191fa0e0fca62dc5f62500048f954862d6f0e3e3a30d1a96a9f6cfe3ec2e2960d3fdbd75d49bcce351a6eccc7e38bf0a25773a522378c896f9f36142d6886138afdb8b5b9f4e00f34f3d3a38d0d88e6b96cbc11e5cf73489e3334ec6b2253d08f76a0744a896657ffbacc04e8d4e8d2aa3c647a6ea30ec62589cb8360034b7ad95d318cb5806353c4839fbe2a609fba88543b73e5b97f1ac8ff1de34af01801d9a511670ef667a695eb6536352de679d9d3c096a8675b71463250e81c87e7d551435fbcf52b2351e25900a9424a56be54a064dc975aff8b8a7f4f1da8e50aec3542322d660ad1494654dd88e7c173021ebc4a529a2023735ea09d24d40056401622766a99ebe4ff0b189e05c4276fc3c977450cb26303bdc6cf8d5cdb44455eb20a5d731413c025b7ef2786ef1bd1cf75380d63be7fd2bc6b3bdcd4d550d1b05c8404f97e3284841abfb5ff7a767b09630a1bea74ca626d08229c497c7f70f247a3da1b7e91bd42e99c3748ee15f623185497fbd56dd6468c6ffc8f764afbd57c2a9b99b10f325960c1c27e6b1f82881147b1d4d9a4733f85389026cd2512e1b3d7e1e990443e0c718ff5951fafc4d30e699077787cc827a60607dc07c90d7e1590112f7a096531c4b28bf81e21f4f4cd767219d40e2cd982c039d63dc5e4ae3be3a4fe73003f46f54fe3ba0664c82320c72328f83798b5a728fcb6b8b507fe0a9ad0412b2fbde31bb1d208a0c605e271870e25979b5bc5d4abe7f35b65879ecc25d88ef74b2bdf53fd3265219b0c53f1bbdb19b0102a90a3490b1a02507a3206475b20fbc84a422310822896ecfa33fb272501b8833cd4feceb2a800d7009b1fe1f954d302b16af5fb531faf94b827c1636bd33b5ad8f4b1165a0a0d38f2382e67b76461ede1e5288d3053958172cacec801b9a2bd33dc5d965321ead0d3df49051357ea74974922543620c37a3a2c8b11700bcae987ea2203fad7b1394788c8e1000a780b2811c4a4ae2a685847da36e8c69952de734bf10cb22f2df3d2c9b5f4339127c2f6f3e8a4fa8034b0d35ab","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
