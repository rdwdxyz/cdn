<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"8cb5390851cc1f534726e985d4ecc268e380aa7f1ca89cf8c31e9418c7e50a141c529dd0cb6d197051356705892e20c627188e96f8f6176351fbaf86ec9482bf0ac872adde75105299cf9a855754fc718b44238a4bf312cc58a932ec5eb228302714a10b74e79fc35a7626095381ba9b3c183295bd69f765f33f30917e469328f1325aac0f419eaa4ad4b0c82688e2025495faaae11156a1784358dc37d4f4523d611a2b2fd160896b960366ff65704da0f18203fbbb4a382a3354cc59d63d827c31e97a3878d882939f508debe32affe4e7aca3ef90b50a61f70224ead491e72e0f98982a665f0d2c5b6b2367e7665fabe7c14ae3dc5c93361bf5f7748438b0dd45334daea387b834a6eb86d7a0defe62feacad630464debe32a37048ce59829ad4b3f3a7104e696600d8b6d54d55eb269551a7bce0c44b84754878ea1c183324c1fb1a293895014fd7ed4323d36e2eb6389176bc1c2cabb5c84d95ec247eb9576b034433e3a46294e5f0ff1a9daf8507acef8167ddb6373c4c8238f50a227bf79e758c4d353b49819d3a7a9eabf9ae584a44b98c55bc0a410b55d745dc9ab26596c420b634f3381fe9bcf79de029ce599efc07afbafed21f8d8c1374858dd3dc803146cce759c204d27c48db4759f8ca5746baa2e34b32d0e92e0f5bb94cf58f1c23407c29052bd6acc6fe740cfafd7f416f55790d450c6879fd754e827c6cc3c8a14ffc07064f96bc3ca3104b07a3efc3b61c265d07299e9ad665ee256de09f37bc7cb60947024bdd7ceb4b1aca5c41a3c9bd0e07fee71018a3a0d8130c35489e88bddabdf06d9db9f17ecd6c43032595110923f65b3e4f2edaae40f937728290d3b3def4961a343e613e10d9aff7ba922791179e4a801d60094d46522f211a28d073b349c884d2f9aace05c73e83f6b82297676b8cb0370a1d566cbe47605b3f6f5ff29cce0b2a9809e1560674aa60c5355239ae11ce026381df41651f92b28ae5d1b19469959149afe676a617a1a367a5e46e1c7aa9623a61410af854ea3278b7712f0a78a6a4d0ae5b53105ae7456598747b38cc7a80af47d8f07bbbd78b5e8fb119272e7acad1426cfdf1c919bf4bba4b3bd93b2d014fcf5e29cd82145cdcd5ead99b1fda3b6f1a338d4f90d2f4c2eeba42a8d8ea50c7ea14d197d3fc989776d760688c8832a719b82d229da729960c6bcd5089901b237f14b359f27965431e459bb568e48b9d14226626de51eb919535a4551e67d2524418ed5a6f1d442d7aca3f8f093587b715a519ed4191c7794b8cad681e77eedd95ba3b071d11436fd6f634dfbc384ef29971331902be8a9d06a2727d15c3d171e652dc9efc30d0b6308863491ab5ba4f985991120e06550645234fbc81e842925205f3613b48651cd0f6f66c6351992a1983106358f158a36738ca8efe186a7835178e76a1d07319c4089ee147ed628fe56a2ba0798fc944e6abee0d9421fad5acfcf61b4b25aafd3d8f28c88162170fc427c7b3ec2086b6dfc8b418b4049da038cfb1b7799b3f32332aa6135e20279245935085d039ce24d0a63ff63fe0835c35c2f78ad187583b3eafb1635bfdddd68f2bd27cfaa6180e7aa83af9aa3649fd42745e1943feba7cac76d24cfce7760b3bcfbec1fd4589f39bfa6abdd8d779a9779388cc87397e7580e1913b774d88a35f4f64dc7a7f0ac70fd009bc4c5ee11958c4b71e6265aeca32b4fb290cb26ef57b2a7f1904cafcc0ef282d6b0bce5225a36917650befd97bcddcd47434341916d78852e1fc50701502bc279aef7d1e30a11c6ddc01bcfdf73867990099dbf885bcd130cc599a07a1eaf18c125a8a72c7641d993ee83b64ff61b501a16c709f395d41f969dbacfbe6197d53148a9288a94bf0388cc1a801ed286c439e7ea01ffcb0e9728aff5848bfa4afe5f87df4b6c2d76c9fd1046520c7166491f240d9b927f8c741d4a768eac7e93c723304b7751c63afccdc0bfd18f2caf2c351cd3b523816f305dff4f9ea2ccd5a170de11fb7e317fb35981ecf0c8a58cdf9bcb171a25b29caa1a0bc1995c6b0152d50b7d1c89d50e75d939bb3340db03565b98b11432f3f3c9077472e6eeea80706ee6ce1834d22c3a45c424fc020ba323c1da3ade908b536c8a7d9e8d8f211a0ace2728b96cc97b2b12a575bc46ef419ffb205968daf85914e634c6c232238fa8456422b36f86a1f2941922851681f41284c814834b2da9689c9c49200c107ee7f2107b4ad937fff390571498288b8e30725957179c326c8dc03bbf8a446f90d46bed8c35764653c09ee42d324a0efdb31d2df0ebb5df4d220c2e949da28181816b1adc6eb95c35fe00cacb97574669a28e11fe62fd8e30573a198e9312d70eb0a7b36d540a24e7253edf5c2fce9627bf1ab08feb377907885331718ff5709ce80e07e4c09f765ddab99fc8ee0331c47d43e8211cdb482a35f8716e7f4321835ebc3a9c62a3d86b2b7e3b0f352e4e09b6739248337ded8096d3ea16d85b29559bf54b3849d44c5d63ba3c6d755ea9f0f2b293ab9e0ee243bfb951392435d11bb005482646ef30bab61946d7d752b8311634c446a4d5c30700eb716d0876a17a1c0f3b242cb561228aeb78417a0740c4b2ac3f4176b57c9c544b03763487a1ddea96d577ab458be1bdc9bbfab73da7f0c579ccccb309b4d1b0eca97f2dd1f586076577c53cc23ff7a7f121c82d8eb7c5e1bd9829d0e1f72d9cee5aa6e9c6e5ca163d4ef584ad6ea740b68aa1f1fcd4d5a5158523e746a2762c0a8a07c7a781d12ddc9bcfd977d5490ff6f2100b302b31261296411a3454aff418533a04c42b9f21634be37e478843e4e36d83d14ffa8af0a725bf90e5b583b79444cc32e9021b923d8267cc0678e710712c2f9ddd356200336cf63ea6c19ab2bdf38f88a1c6457dfca73c9c70609b10b3ce483a8eab4c7e45c0a65c22e96ec0c2a831d816406bef99fbe91d1f470b00961ee04672eb5d3cf2eec4e225fa1785b4c28479619a9c8fd2824c314e98aca68ece69b063d1645b4e5b726b61e57154dfac7f19246208149c05213bcfdeb8c62c7b3b54ef39e742872c22ebb9429fc79a3291c837828083c7e79304aa00888e79bd938e3c581946c90cd96c628255dd8e49272d556cdfb37dc99e9ffd41ec415ab20579ceacd1764dbb9d8a58178bcc32bc5da0aff2b42374326ea733dae4caef55ed17d9a9b50e9faa1fdb63da9e1f55be155c4797feb4cb94a2e98c3e39d4ce3f4405f2b6d382f7b40e3c765ccbf25d908ce3b59f8048933338c864ccbc12cd2f8f32b75f5cfecf7d9fe1e973681b9bbe31ce44e65812fb00a6b761324e2712f4cf50aec5ab012a4107810a89c1d76b579d765c98740640461b4b1a2fd27ffe74386663f0f9cb77377746d6d9693820edd4f94c0d684879d7b7f3bac61a41918c1efdcdca86c6df882324c9bb82bc9c48db411f596c94a6ded0d5355987f1e6e3edd216b9cadcbe5dbaf22c4574f10e8b772cbba5d25f585562e51916dab4b420a2888e92c552fcadef38246ca8291b37effa5409418f94fa655ab06eca0465304890b9933d8a8062abf02ad939a605e348521fa8241bb377d70b0c39bde1fcbda7872247f4d4bf36bc6b84fd584013fbae8edf82b796e5b97eed05bd12c3482df608b42a7ef20481126474309178fbb762593f85f84e5b8321cbb5e7c5af460a575504a6f9c8c84ba090049fc6577244da9b85c6b2cf375341552c57db32daade337af3f9dfa574a59910df5c0759c003d0883ffc0c6f86b8274c57ed0be4a3540ba2c147f105747c76f308393da7234d51e95b0fe1d2cced7805c3bd2cf291f732712d707114f2f02af19e4a2aface7ff18799da4d3919ae39d5826c5f291d2ce4b5fc7baeedaaa56266db791b60823bcc248676bd4f644f9c01b2996e8e75ece91666f46cd3f48c0b3446603d6a414618458bee00851add3cee650ebb8445c54558bde69ba99df3f1a4920fcd846bb1463f97cc865be6b1a06aa1712982d56e3d371a3489ce03f72564e91f9179e401eb90776a92824cf24239857a81ab7954e904599974d3ac86fb7f5d43430120088e8a1f87e8e80836606a9055f6017d43b75553e0ca533bc62d4421f99292abfbff93c149361f4df071a9dbd51cdba7d66c6cc6f518de5918a34e2cd74c94fb1e85d254a01d45d692976571dc1442c1df56b4a7edaa2a5d6d9cfe7cb1cb8cfd7c4d4b54acf72287dcc165d3ecc30a6a4ac224a69a3f232bfe711e368e09f3cf884a7b00b59dc9d55b66632e183b4153d2d9322dfcedb16105a224fa820d69990c65f680c89dcd03e5ab1fcc012cdb1f70efc70b432e5886fad4420fc908dd1c9d245af13ed980151623c8b7affd553974969d0eaa91cf7a99e09840ec1fca6d766d5e3410e7df45629b798e46c014c94b52505a0a4967dd8b110382308104cd098d42e72e22a962dbc524f23dd646bf4e32330e6acf7fcda62848fcd1c0ec1c195ff4bca394781b3cc14e5eaf59110d54070ebf7ccf4fdc5ac77077d0cffe0889ee3320317584b931f990c41de9842473f7e28718bac17defbe40e5bcfaaf55e5de381513fdda6e459c3098f7eccb9b7564dfdb90d28ad6dc555392520613b2916fb6da6cf69a31975d5d534b2e869bf97759873485e96e8dc5b68efe175f1dae659023cb76b34386188515bc97feb65448ea4513208e763cc6db154cdb65642e597f88fc075fa6686b5ce72252b48e23a356c602a9800b10df696da509824383ff0459e8aec7d515e322b916ed768195a73eede3362e09b51b6bb494ff9f292a8fa9c46cd4c918aa4b2c0a921e9c9bf8acfa268fb997589384f67e12c5f93f69caf963d44e58d0acc2ded02f874a369c1773256c40d89ac99a90eea3e6dd7a14e60f13684fbbecde3ac32e0193325d7e453b09048d10a86351db360a0807d7230bde8e5172446af5805d6deedc1876f9d78078baa4f2113ce4143210c74bdfd05c7aaa0e0a9dc8ab371a6f5049c33a8b221a0b5d3e1a1d3d9ab6a31fab8f74a14135ec5317886f0566793b8776737082eac1538283c64babeeb4a41be7e595a488b7101f2cc1ba702f733047163be2c89339cf1a9472f4d907cd30df00a44cbdc8aa56f1963eac9fdc90b5597ac32e1acd87f0aac6dba8ba9028094a1bb6fcc466e879561b77866ccae985e5c5c6ff90e27c6e1ac6d95729155c9cb8b5aee9884216ace8872722bcf81a68c208e86eb32c44f2907ce059459d2f6b71992f8fe87d47cf778281e6c9cc19f10f913d139feaa8ae7ceba4a16fb043dbb6536ff8d3b49e4771611ad02eeb52f4f0302078a0b17f32e47d0737d6bfa0fcac099f2a47bdc0360e57dfc49b74bab25656bb1f46c89881729ad735baf38b3409f421a5d7a4bc5978139232a155c8321f031fbb6dc75c1848ee8232d6e759b5a9399639624e2df807d045ff9290f1f8fd6b5828f5d94b4e7c778a17cefa3344bfaf3cd4600bc5ddcedce4554c239f44fd55a54cc1cf5b7da52291d56ad32142c1107de330a9b0bba59bc340fe8b0d094585d84568b78e1de09fec20cf76086edfe830ae5426bbed1eac285a60889f4ae867e12bbbdef3a546fe8012ae3555a2ba8414c658014c6230736c86ed4ededdd342e592df6d94763e4801835f71c585ef5b8b821031ef186a9a6e546c06c9939a966526f04e5ff5fc0228f718d3e4f12a8e2158ab0f9b00c5112e9cc8a681329c548f6f512b9d6dba112e6f8dc9c108965ef6f119b9952f66a15710df8c4c8a9aba3d1161b123903ec2873df1097ccd616a39804e56c389b2698261946b814a8d9d428582b72501926eaf533015b0b6f30c5d2f4b40c0eb0bd7b446e9e936ebaa8761998ed36b32f60ec4b3b094834d48e82ece21248bfaa7ac2badf9cae9171aa5efe1c4af1ee57235912bf1f677c849865a91dbec8d90c4ac7a3229306f2879c98b874ec874d7bba24e4a65f91ea77e81b10edbce0cbf46331d0c8b6f2ccd1a01467eb36fc50ee9f64cdf41a0ab69c623a85ce8a6b395ca6d4084dbee45c94b79ef788fdc65d607dadcec5ed0f2719130638b7bed24da46d10cc4b2dfb97be71179348b3a8eed35e4034a5b4d1d41b261f227196e817a6672ef366485ba25542ebe4abf65bafad705ff86c26ec08c35355af5b74f46a4a757939081987dfc01ea91f331bc663891c4619f66c2c1b9455d9da9efb693e6d2a39f7eb0ef5ace59eb202a4369fb8ca7d0f2b1428a627b53ae955bdc731b760ca35d2d82b2928e6a2cb6128205f7be9d6603d9672189826c1ae715eaa7d9b8a7d6268ef9192bd58db2da183adc3740e710fdf869b1bee3051a066122b59ab1c6b67725e1979c3c4766e54bdb69f6aae37f475043fd73fdbf132725503c86eef714908f4e057f586e16b889371802337eff02162226b5dcceef89d31c0b19ff21a5bbd6daf6d3cf8eadb1e445336c50ca74be6529223e0a93055b3509d80f9975b1df98086993c1c560f1384e3fa089dfa2a03a1c5fd8cc7a65f7653552856830f24b1eab6acaf670008b81700cc30f9ab7af453043d401c3eb8f55423fc4cc26d94f956525d1c8607711745213043b1ffedfa363bf481d798eecca6937c833fa8a897a86ac8555542484e3edb66c3a55f50930336f844928dcc5ac1c12ffc389d751ea66d0ff5adea5958ca9c509e88590ea14627e3cad425115d1db4a4f0f0de753c537d52ef4cce4a12657f64e4e5c2d1f50ae9a49eb83894eecba9790789ecceda31d23114fae35b0d1e85100564d75cb9404fd96b34a41d90452a4f4015856ff89adf41b75451e0d2ba43425002cf7d9d9c4fd8e29bfc4b9d6d7b3bda91ebd8b88b7ab08642cc2782783b0f6255c6e668d1f0fc15832c03c4332b964d5506e7ef57d8142b116e5d5e1a7742f23f367fdfc5e2888ffe0d9a509a886d7b2b80562c67eaf4ee8d48c02076f4e84c5f28439a38a2f64f8a34a396725ba485bddea8bc3c4db99e9539d35d467e5585f1ccc1311ad83621000bfe2f7aacc8280228c0f801167b95ee216423581b537a9ae6378f916d1341d1200a5803d6426bf77434c295d91fab2a1f207f3b477dd16cb0e5beeccb63c288e8bc41d69cd7216ed985eabd81598cf847805b5c8ee0bd1ac73cb4a72674cf2bf55a2a5ecf79714754673d74f7c67f48862ca03bd1273b40ce9fcfbdf8a08747f935839c1ee5467755ab67dc30b035cf0072344c3736ad9c2f32d60265ecdaaaa24a7561a270b37460c2e6d2e6d881a3a331cffb0f4de2897750d6db8f38c5a8704befd9583f8a6514f98af01fcd6a1b5fd505898e8f4e32f591220962a2d091f7cf013e0875692359a782f22172d584055ae52245df8e03bb6395eb4875665546bf7feb07625985b7bad9f2189d53a1e31f1bc14bb1fe833a68b1131b0bdb66c0036a4dc1b94f4d109dbb7db860d055eecf6a87211848ba1c785c7f025c1f3768a72d97d15e32328bb8f15de96667d02f05eec7f204bdc94037850c9399a34f7ddba5bd0fec612f69cafbdd71a7da46c0f63ca68460367a3c9044fe81e604dcb5a76743e444f3700a16b7852acee377e3d065b241e75431c0bce898d6432058afd1d60f9a91e05c28d9a663bc76aebb8fa7b0c813273c52b21ddb29c78055de3801c14f2fb9d65db93337974254d841bc5f7d4a5532a45410420d74647d9a94fa84005024680bdacad7da17ffabcfd574ada03d64410d54266accdce6977c30cecfd8c74d582de8e422b931207b78d1d9b89b4bf97d97766482fe75f2c25c768b3446fa618d27d6203f4d2b16b4dac9c967f4c49125b0184665d554617d88584ac0c14553fc9622c4f970185b3b397852d91be29b57c97aa385bd3099ad7e1dad47f32061059f04cd96368ce768b5203d4801bea40280df0d2ea4074f7331a768249d64a779b9ca91a85c4f69bbd5ce7c57d0b45e7b16ccd1f305807b73f619cc91b627674816807de1b65587d95ace34e337f91c1c68854f11260a8b76d74e69f829079fbc8f72a703ba6ef406b863832debf53d8eb4a0c9260878d535c472a701407689b233af47368fcd46be6540fe14533dcca9e80a5f9a34b4d56e744c04069718cfd9e4df6b6b2837fc5754e41bbc78db27490206c3fc7746677e56d85442e729c64af0e7f9b4d5f1cfbd800d223826bb1e9122b9176a8418ecb08f25f4066e022bfbc427a3f2e429336d0820ef44803e421e20fc17ba5b90b1c1678faf78a54e8eac6352728f74c11af72154b835f0aa48f49cbda7d226a045ca246390b688a5a9ded4ae07b6c143b88fedf8b253f7dec8c35acacf98519d82116c52124f25b35c44464b6de9c73da92d2486a27d00720131a801ba3196f700b84d616ece07e06900daa1ea53988bd822147727e89270a146dd0a41af065f7e0cc3e64abaa1c76f596efd5deb6b3b80b59a165e08fd3ffe5302b659a1eb44c22452d2e4c4cdd4712a0fcfa003948bb700aa62f1f97305d3574b5084f0e97c1b1c2a304c9eb59ccd1300a7582adef4b0be2b208dc425538ff3f0ba90210f07b62399ac3043c47fa2b502f3f58ee6e225ffa7186afa402f5846a0c638131d18116fbff9825142b334b866ea74ae0ec132a7b643ad375c8e999b40dbac278f211a97cd8f723e6cda81e22ff70e5c56dbf4ad40315d27d9e0560af52484f0368deb944d347bef1be4a200c42b491283e3598f5f8d37ad62cad9f048c98babb900d65437eba9e6331cd0a020b415115c0a3206c32d3aa89808b33d55acb6bd92647e8842f46457418d2917b3578a8213866a90ce2b6aa30175bc9c1a014d8f141927897862f6285dcc2056135d8f194cb953d183f2126119473cf19195980ca5cc229b6b5af67900fefc59d8cbb9295bb52b67ce0c1d7ca800923771b5c7848df11ef0ec79a7e0a1a9c938bf8c97f10f444fe133a87bed384dd05bbd3a473c9ef4c47b854be9f28c722e738356d0553f37058a0a696cab5e986d1ad76b609e34746a880f2799d6733d8da262dc9d28a85d7f695d02665ddea41f0330c064a50efca68a2fcefbc73b63d9feb72ce46b1a38bbed1716ae31c49ff365e161d5d214ce05ae28dae24b95c7d3ca207508b1f167930568fbb85925b796c425f0d02d3bb28dd6f1af4d19b847fb0822267ce9ec0407a04310dd13f77b3bdcaf0da1ea67b52417f5b55fddbf671f063b0fab0c0472d919916af3cf9f27a5d790cd69d694be57c443e42c4c42ea087b92e121a4d8ae78f4edb819c4d0f58f2b2ec3491d5a6193b64a49aabfea270645072184f3fd83516fcbfb2a286c2f3dbe666f3d381984aa29c328ce41b48c9754e1aa5ec7bf332c48825329c7f82cae0fcac2f73896fb8ffc97cb3051fafa945ef7e2536c267a75d34a183914b04c559525cd6984b6db1e522cbfb1303f51b24fc2b850000682f4034f1cc8884a8b051ac4714c861ac36f1e7300f2ff78ec0c7e8f683dab6f94f58b7ea099017af0606da0545ebb174bb2b72e08d96bc01fd3e292ec2860764364283074a5a9f0cb584bd3ec6e19ece1adc91319f00fe8f44f14fd93b8e6e3b92e2302fceaa5aa3d8d5875f981493f4b380b56d999e106fcec2c80ab89087081f34a9dab9a2d894b240812af5e3c0675f8f497faca9b72ab434c7579e47fe01eeea8ce94da16625eadb329348cd36258f7f63cf4914106a48e083753d9d4d9be356176a4033fb0f9bd6833cdbc9c3eb3e03c6226f695f61d41637f211473fd94d797b6bd7352e43a4239bceab7a14935c01243e144ed628b674b2219662a95d5914700458164c62a85c8ffd8ec4bab769e7379f2c1947193afb05308119e8606d1cf8dbd7ad5415d015649b5d126df783c13988cb1fcbfbdf6ab317a5ddad4ee05396814aba425959d364fa8557f2a0e960889f3383ae1d746209455d5e66dd0daddd335556d08410974dcb49f0dbe4099f1801953cdd3121b9ca9044766e813de8b9e86ea43ac51bee55d06157cc4594a1c045095d3123d6dcd88d16eda99c6cb5c148056aa0dd6c51df632ed56011bbe89ff5b0f80aed85c7e90dac2eb5d73612338c2f1ad2d6b3b9ce191b3b77dc9cd2cc0f873ea6452695f812e7f8a88f674cd2c5a3a06ac3e082a424a644a8b68df5ebff225389315acc3b614187d55d052ce8d2e32b4bcea42813c9d1ce1af4643de5c36c45250358877abb5a40de2e01b7afd42438af63e66ec4e94de25eb6a5492dd15c3677dbbef0359e0f8d8d9f14c19eedc63427882975e7b36f5d107d49797f3e78f9ece948700a9838721a2bc93ff94b1ac5bc24148896d8383b56343833d60112b4be1b4188c0cd7824df76121ed6e43f21b09131bec4026fa6151f603ecff1427b81b184056f59a9c60ce2143b488aacaa515b2447848f8bc222a468d1c0bd51cac66dde772955f0740da150fb610c0262f3c9c67095af1fd60806e52d3f71e222690f88e97f27cf2256ded1a372378563cbdf17620f90b1c0008642bc10054a15c154628f57c265865bfa076ffe7177d848df73bb5a6b2e22482fb6513f23539d134597e984d7aaf10391c26695686620c290c34b7bfc048450402ff91b5bb30d25d957bf8d8ce09865d42c1afb8c6199e592cd36c18f78451e950203898201ff08da539b1f2d67daf74d5578430fb96b10c740e2c30c9d489821edbf507f4096f5c5de1ef611f49756013ee2b219ce0a1c42d1e00792a8f1d203635f0d199aee25bf271414d921278994cb4fa97f6f64adc27ec12a89414ad544db29210f758ee970aea18280fa9094a65802daa679dd997e8f102546b821c812bd7b8e08876b9f9265b4db8128929857af280dd2f289f0c85e11124d69c9be8160d9beb0c188862fe2cd23e719597549473675ebf0478b64c2eca9b4623c5540812db0c5e792d6e1e0db621dce77bee716b87150f42dea9f09c1358fb7d3d1740782388cd1ea8d009c6a151c7a61acbecb2e85e69099d050be3c29acd3bb4492309895775d4a5c815122d150c2007540acf12b74949c9ca0e3ea2706203bdd5294e8bd9bebd5ce5ab317ebf60172bbfdd77e7d9f4acea1e55c6354ac64626abf05685a3be8fe315d15a34adf269fe70c8a19ef703a7bad48b96d14f16cdf90eeb497c089b340a2e9aef6498fc0a21a6340a4ff62fe5f8104afd142fb5a06ac30e94aa0584a52801e63a165c2328508c86e06fe7f0cf1b5790128e972d134ca26833c8a1256d4685bd2e92377da42858ec350db1f8895d15b5d3c7065c6bfb050fd1968e9174057a021c08c4d77538530eb13b9db16eae752c52517dba44d8af137ab23cb665764b6c294bf6ecc6939555c057c3c1c1a38640a30a9f7580e18520116e9b0203509e2b8457cc09d541cef6894ce4ad6be2da7336567008d5c1894b8f4bbf1fc13d305e5744c2fbdd7deb606fb3f02e69b6f0a81d0d7b19a4a6068a628ac8a779b19be5ee59133702839b97edb456d8524783cbf27fcc8010bc93d0560ef7ea0a289a2d803f0589832fed96cc83a18bee18d0413337e468e5003019d1073aa1cd7ad6ba3b7d0efc436dfed539a4a3915a1b4fbc07fe5408f2bae454fa43799868bc7f0cb5590735a1088977c28df8ec6cf56806a9dfde0ae7a80b150921e165e5b9d073f95408404cbab6a1c119f917ff5a04869ac8ec1de20e0f9d977191f0d38c4094abb9b049bb6406be317f53e7f5494e4662ed1ef4ab9cb3c174342d1b6904ef5a6db54af073570164377d0c094f5602652325eab15482cfeaa7c8de2d597993af4cc3e8d7d25d2d40f4496afbb3aac204ea9767b2a83fe74d0d989ed23cd0dc17d573402e8bbfff8e8ade7a198c33dc02201e008658ab482618e023349d2bcd939652d5f141d71432e17f2b1407f138276978212582e71f86d12f7889857d864b324721d60d984271f4836112abf38e9a6fd5f613770851832a31780062f84bf18107fbe6adf3caaf29d9077c3214f10aaf439b27a6ff9af0c8758e50374be646ffb2beb7f711a14eb28e7aada8419b2d80de31bcf913210f1632c9659cd94d1ad1e61ecc1149e218c419b0e2dee42de54e569fda3f64de4abb1d240618125390ca73c12faa602794fc6c8898d758c9563cdc0a8329e459c9f80726cafcbd86bbd5f62f10c1ac72f2bd93f9c06de0ad54f60859145709acb7ac7c55ab7b0c42f57ace1364520a1f61792d2d888e151115118b270c17df69f2ecf3b27258e29695b9dc94e27555b6a6ff4fcea415bb85bc8e838f580e24b70dfbacd6f0db77081e4c3d7e4688a4216e4181b6dc40a888da7fa5100cb172c8fcb7a7a38beebd6fc25f51464094050a8dd05b1f586793d20701564d67dc4ba080fee6e3e2748618ca7913740a0fdf9fd164f74f2f3baf77d71823a5256d1e3a106903a82c92c2059ef129da363758374da5a40de54ae2861f42fc9ae2f1852521d2ac60225c0a75a5deb3f0ea69de1fc90162d1aef4103e8bce93922bc0d02d5d6e768e868db5260a0f47710de0ea3a4dfca8277e29a693ec4220a12569aa6115331aa45e8d1722274da2280e307093d90a03f01e07d9a15155bba33ec2f93c59aef0f187c8195d19c76e9847dbf07d18256e9293d3032b14d7b37f3171c4ddb1456f03aad82623b1ad3ea6178cd77838714c6dbef2273e35005bf8a9e9a5ee14716059830c9f8ff1ea96f81422bdf2777fb2db4740d547a97f66245db1b3e7615e04440414ee1d0a6c4be0edb89fe53c1a520393623379bde9e7a8d5eb7cc3d0764f86c2947d21abbc15c6bb461282751aaaed705efe59b2d8d3a40f199053f3ba201d98bd73229eea5c99f36d81a2ffa5f113962a1fd6d942d8d418f11cccf785fe92a16b20cc3ade42903ee28c14a2eef68f7a576e6c8fa27d9175a9151916736dbef35b185547e4d8e2aaba17f9b97abba91894cff85923a05a6361c047fc4b737e8a0a1a013d17f928da7515928e0cec0783abad8b620ed918ef3c3d40f81ea16d8d898fccb4dbf587547a0728883e7a00cf619727c4b1ac842c2e573210e373e1b7dc13b47862e15e27dab40252ddefafb5c866b927297454772eced41dff2106054902fd7267c721a4defc29a5097e7d3154ab0ab0b25143195806d953a456965c4463203a3468611f46f5117b06b59e4c5023a8d8cebd6480872203238ee7792d948d91d87d1fb028799a218d158b1fadc6dcabfbca707da7d00b261f6aabe5924b6caecbbc97131767c5927bab27f5207416161c7631688ca14b1ff7a75fb5dfac3e887e6947cf015046df19628a5cef9848a061b45530457a2731351d1a1121545a5484dd00dd9f7cc8b5027efaad453d60511f9176e9cecfd74a76a1ab0b6e54b606978834b378129f9c9a421947562550318be0eaa1286d6422ab2d5079db195ecc5c362e7b1b61de7c6c3e6671baa41dbea7c42e76bedc2ceeae5870a579b414966fa7a2a4d6309b5b9ba7dab839d05cb19c78fa51edd79fad973ecd14ddc82108e0782c158cfc3b9855ded29e25c7c060571b546fa31d56ba1486c8308dd222ba18b53ee0887fe5b8ef3a4716928a1703a25ee81e43108916c941f426f562acf3f6c0d1a8eb62ae2b2ea6a8d30f96c7f0b663c3d94875e32971fa081ca924aaee490aff790a0b76e0310a752eaec9188b5cc0aaee5a3cc9648bcd923c4191681919cde4fe6bc00723ffd3f1cd2d3b9d00b76077595b7164a4cea1bddcf1e30b0da9826b7ea1a13ac75e0f9862e28b8ea60b7a095c9d1df196e3aebfb59907793364ffdb83d7ed2905e98ca95a5e8d6d9a072e9bd05e9204a3649aa2d98f05640452473fdd29dfb4d002db7dec5e640a58baf8007d6957263a245c5c29c0160b32ab650d3095e7dae3ece4f780869fd51eeae53520d91b66f81a2584719c010a3026b65c83d189d62942d9e404e2c47e88a8cfca658d3bb80ea438f5d9059d23d37c752c39f3c98468c4ace031eec6707aa2485fe831b33fecc666c56ce792ac4270967a502fe790b84ef4b194484041a22f8179d3ec96b3189d89db551729a657ff506b33ec477a997ffd78875a667dd268b401c45f6b67fb261e94a1d612d61b3a749d3326f4c31730f4566ec6e01c95364779083d0106c876f8b36b3909b716edd6bb6ef7805b30ee3e2cde3297e3146e491037184e4165adb5f5803022f1a29438557717425ae92da64530fce75f1ac667d3bfa18f66c28ee4000090ff21b1ee5e80890e04d36e9e0239833a776dedfce420bae77a22cca6fc23be1dd1ca1489d799b626a28d88cda6ba965e84db03f131b42ff06a13592530cf586320852cf28ec0742f5780f749079bef24919c6486198a0b3c8a5cddacb1e357c68f9a7d967cae1201e3f7da20ff9bb927fcff6907f2210721504c9e8e958ee7353f4b307feecd47ceb890d715f9cac5f72b95fe156f2a75c6b294941dac4cc933c6f499f4735d41b1ebb4360fb35ad763aec9e17954e55f41cca5aa250a0fc3333f191b04170f5ca6734c8491d09d70a7958f72002f4031177a569485c1c0bdceb544cde43447e3ee8d7a072abafbbd6b04d8fa16096dc69a9517c176527e42e494e97e790191106118b566959680545c8d385f57050e8b65c726c44003ceaa7c7e9e3a3a0ee87f576a5e639e4bfdbb6e1ee35045f28ba7c176376bc4ee7e2e30dd66c32c8a1cfb4d9b765d8f122f5121ab8763bd7f3c250653d87e92cee51689f8b34ac5824472ca4dd49754023eb736cc835815e4b11f98ffbd37795c28d6f4353e36b7ddcab07a5935ea81e156ea5153e0a940a3e6ffe1c577806e9be9d9642813df653b520162c9d3032c7afbe62ca6b891a88a7b56006f6e0a74d2857fbaf98a72362c46bf7313f76aac5730c5d515863813192c1faf17b608cc12e4118c15ebfa553f7533b2911f1c07d3e4be1fc01ebc716a2e1a9f328b9184b7eec4faccf5a57c9e32733a569671bfce268cc45230fe91bc06e6139c70e55b6c0533c6331fdbb96522b03183888126f72ba359ea01e94824ee004624b56e7ce53845d2c12cb3d83eb738f51d4e1e9241ce2dfb9288f4ad04a7494c12961b511aaa581f78660264546","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
