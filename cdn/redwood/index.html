<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b65923ba53a8abb2e6254169799d454495798f1c8a46e6912904e8f0073fab2d0261809991da69f4e8ea77dc3e502cffa355583f515c37e0300970f29ab03db18d717ed93bc25b3914ce7635555649fbbe2b48dbf1dd629e779f35e97826207890dc57dca6ea64369a38a939b7689e68ab9b3a08be9fc647a86723018ff93d6590e41d69ec4453297e74a118a3a12d0dfccc5dc0d32dc385e31800523111ea352c4a593ce454edbe16db431bde149a790ce5733f0f33a60fc27acd6824ededda37816867c1649be6aecb263e988834d981cdb856c9668254fa8ab40c54515a316323517fb6b5f9c992d306751a26a30a7c9233d627727f8b3f6d39af2b924657e25b9b78ce78e8323a639509af3fe9a79752f302eea157133d3d3873c21255573072db3084cca2a658ba3a16ad05e743b8e4ef93a59b8c5770837387b92dd13bd80f30f45dfbe1fac2468d8d88e0559e3f49194729401d0d324db1bc852dd93e15097e86bf6877810079b95db26398312a6205a53772df8d57a09f4cd9184ac6128381eced975f0c8583a1f5e77a1b078b01ea5ddb2c201f2fe0c99dce08fcc2ed37a9dce8ee1f06d0553da2a3c9bfcf1998eb244a5ea8a24b1809c9b739d9f771c659a877bc83e59ec00fe1161755767de434f6973f9b09ef005527f227ead7eca55c45df90e76eb87ebcd9703bf88f603265106b625fffe824805b95323cd1643f24d0fee8aa06fd2ef9a61463f704ebe5864e4687bc3fec3c282562cbee64ad50113bc3db6b1d4904af18cde0eccf378ea14ac2997d48cf82877a1c42dab5f0a63933bd683eb43a7a4299ff81be06dc6bd1d395a2ddcd7e54a84db79d69faa915925b9444e6abd5741514f462ff505fd2db2c261ee73a776c0428da7c7881e596eecb665943f1cacaabc68d362019b7bda7ee2dc5d9eb88eadc649a9d7b424172e57b7dfb9cc39bbf10c646cff15943d4db54ca1b6be7ce6dbb101067d0ae637746c69b8bd44db3b7059e3ee096cc338296c0de8a477e51f5ca049761d7982fdafc3b2ec6d8b331fc02fa9e2b91f0d29efb26e08850addafbbd54108cdaaf2631e19613f3315c094e348ff7cb4b71eb52ec6af2547c9097196eb49cb552fd55001fcef72db1e06e0d6897a306d324c01729a6c31a0714c74e145e465aa861315662d0f14d6134fd79af19c9613c11b875214c79a4f4363966dc064138b959a94220d49d495db97d4517e9a60addb950f1c177cfc4d5ac16f4b337f353911f75a59fc3ecf0d92507d4fc3847be1790839aba036efb71541a62d07c7d859d22a68454d1738358d23895fd3f5fa2e164ae18b9e9ffe33856bdd85aa8b2aeeecea16a98ca498af4925be18324c650dcd23b9adbd89f94907275b16c27f40c118ca93784a112658c7944183d43362980ccdfc36298aaa35676d4e1003804f971717b2cde06f8cdb6b9a94a1799c12d8e1bef72f9541461966aa31432008c6d5f832b072f0c66957881684ebe6a42fa5d735d53e48579ee6e5976dfddd900516c7c5b63f2ffe198d1cc4e926df5c3aa2c03a9246413f1ffa776dc8844f53a6c89d0adf274874cae3e937aa4eae0c81c88e3e7bc59fca84131762d8dee4e147e0344d35bba7e39feb42190104ec023a75a77e2b1886f33b9d4190e0c631c0b433f0e498790130f531b4286da843eada9453547b0dae5bb77a97fd4796aafc8109c1a72c7dfcf70154e99d51d868ed765a1c77caf78ece20cd9f29a1c767349ec818403b4af8a181f6e6a7ddb3be34ecd8eba9147d23a823c499dbb0857a2a08fda2b927949ca3cd6af85a3e5be0f36a3e95ee4bff442927d87498bca7493c77f3475a0c8beb1eeecf087a7c36d59feb55d84023232cbb92904ba04cdb60ed9d4426709298258f4fc96650223161b586d510c59c8ef76002b058787879823ad2c6929eb39122f6e552b33eedabf5b9210d1fbf3605c2d2496fe75d6a9ec16e5a755cdcf719a2d3f1d52b481f6dfce5dfe36c8a08d67cfe1e7834786ebf4bf00159ad413a44cc63dbc3376bcf05e5f7f066cfe9c6665706dc6d031f7c36e6aa272fd68ab843bf17181d04ba9f2415a9c8ebd94e87411ed2bf5a3b94222be33bd0c70eae25ea5462aedb142172baedc69bdd183db2bba6e2f9fdb6ccd39bc7338c86358ec5a5b448f6942987c68a32975265e49fbf91d7dd47537e750ec8ca8787d57763470dd8debd190c5916623549e68265bb6c2e8d1c8471a032af12129a6339dd0b4cedb28ed83f136677a9c6871635575a22bca8553f200d5d14bb0e69c3f7e62a47cd6241da52d9730c548e7d2d5bce9ce181ab320da9fb9ce2d45438c8811c1dbb30978b0bc59628a19d55fea62a943bde0736ab88b58d42bc56c00e861c6e130a2dda5e3dcea80ac6b46821f83848a02744f8e5a9972996dfad032bf12e14c2a2c28930c5a8b2304ae24d3c9834dcbf156a4fc04538dbe130c59b7f936e6e9df00ee71c77d0643894a253221ce7f086f90a0f17da9677248b5d2b0a515ea3c441de0e0ca0d506ddc47003bc0c5f324abdb2cae78e7948dcc01d8f8b301a354b46188084c6bf836d9bdbd7db020fda140e726f5e9b7776aae14bde624f054446fa298d6161f0b3bbc4c5c35b9cd5d54dcd3065834a84134715d23976017988a24e47a9af29e37eea07f77d14c0e2c4144dd5bc4db55e2ff063286f65a610d47452099dfc83d75f588dac6efbd9eb4adfd0106b707b367b17d9c91a110f157f969d2f118fa0e82b53ba9166722a8d39f9b2b125ac8497a37e98729beedc579ca744304a9a2326b72b03844f66682c2559735ad659e2550840e97b560834762466af63d098e0321a8ac4fb2bd3799559943d21f298e36b85c7a173c6788152faadd9357d780709170310db423cd6d85f8d63408560e8fe4b6a2a78678482769d0b9c378987d7ee635f3bc5db450d661f1da5ca65c97dc91d6f46776ef5cb13ebf65b2ca2dd25bb4b9d6c4f82710047eba460988574453579b000a87888f1c617cf7aee1bacd319a4f97a8d71d8ba3991ec2ae1ec652b8cd609509b4fddd574a8a1ebf48649c329bbac014382e8126a91b7f6dcdc4b0ddd2d6dcdb97c80eb61b12c96d42d9be950ea64fde4daae2d9596ddac3ea744cb66172d5851edd76d8b3dd9e97246375be0982e0a2ff269278039ea1677727f0e73177350de8c84eb90fd0eaf56270c3372fbb4fd690c33ca1dce373c8db401ce224834ff223992e6c07e7c2bd9f56b0ea2af9fe86c6d3c2a245b5e143c54b6c695bee2b4591745e57b82c822160778944ae4a2ef92e918a90dd860784f8b4be8c6b38d0550ab4da7e5e0acd7b8c1ccbec8dca99906ba52c0153a3e964c9ebfac39240e390e7f691d5aa050543f0eb0ba4f5e8c9d0c15cc197e70d755230481366bdc17704205fc1758bdf6b4b8725101fb46527b78adfe49052579dd831b4c113574d68e1aee9247c51aae4f2fe3c5d20271f5a89331a643a79a53ccb78748ff65909c618a54e040393ee2132f9b2365fdf5d1465783501545913506090f689fb1805bcff01c9f35e82f742f7b40e9a705c25bb69ac72530aacf39eccf8c950de4d6eedf7a699442fbd449f40fc2a4e433835bd6a914819d5a2746b58bc1084f4f88be08fd01619eafd44cc79b53a151fad8278373c702eb747ec6c2c7da6cf0a1b9239ff753777bf48430a0d162522e4d06b2945ebf45f4711d8228a98a731aafe1a4d8cd0fb700adf3bc2c5beff2b47b13382b095b7a5bbcdf9c085584690566da3cf69feeb9a83d07483a0a32b9a7d25cef15be1a8627757c40a9617fdf35bef56816246910209936be31c0adeb0aafc55a429f1d903e547158035cd013ac07bbc6cf7cea2324409655dfad1492c8a9474adabdf0499b47c9ca49697fc887fdd096884dd4b358ffb23eec53bd8852f84a0589c999f3252855df76ac5e42bf0d07b7f086b08fd1e317a2c11466983470b328199a91d5e6f64c88460ab99f90ae80837e38c287cd853f8d37e0fec1132f8c766fef4fcb9ef333b61cdd75267d656ccb85e124fee6f4af8c3aea56d785deecedd4942605f19a00a4486514c7ef454d07c3d32cc7454a9f8ed2cf9fa89d82b70f14020dea57ce2c85a06da90cebd6df5f4e81b39c1f584c47b4766c61480aef36e69f092752a14b966e6db6a6f87c03bc9891321b862cecc3b46e482a118d70a97ce8abffe9c8df9f936b547006074d47a104e9035ff2c7b22b0e80cc5a8ef0ad74c66e640a5156d9b94d5b16c6c8911137bc0cbc4e64156e1d1385a5634c65f838ac4ceca4657d20714cfde8d11c9331582c64a1ba9d98da5595b595268a566154a6d1a04d1b42bfa8aee18126ee6baa5ce02aeba8b7868fc2d0d01e5b39cdeaacbad5b1a8e6d603cf6d73954f9389ebc622d69c3aad0e660bf7295364cf83a835541542ebffeea6d21b4108fc9015d563fe3de78116b711ae257b511264b52efa63db8586f044d4cf5b8bfefe4236cf1ae4208ef0ce7a64f19cae239bd332abadd58ca46d658e67015b99642541a15b127b194a32f13fa832e72cc4592a98171392a31bf3cbf3eab8fc978579f32c21aa91e69c0af936e0b0484f0f546e6e17699f9c74393a5bb31ce2c02c2bf6b629af5a7a727b2e5fb8fcdf709ab436181320288a86c027a0e29054b1b8a6d0888812a61d50b03886a7c920b1ab07fbf91d1dba6219a181d36bddd972d229c285dfa414eb4bc26e89de390b69295869689f88cc9a44a17953436a1c89f00e4ad8f7966c3d927d9dcaf14225b875e9d2e30e14e66f0744b36ca2a39acff09ec7f2c9152c28d84aa1aaa646aae470c5aae265a0247267da215c53d49c407b858311f7bd2dbdf54e91f5b3a8811f2ea00505f41db6da61ceef0218df1ca42664f37ebc6ac2d2b308a313068d2354b1052df619ae25c44f901d734368312ce50985309ebe17263baed3cda5b15d31eed5c69c2bfdedc05a07e416a3370a4a8730af3815cbd65849e6d5d3003b36ee88389204ad0316104cc9a7731583c5df2a649528dae0c745eb7010af94578cc7457fc1e9ed6b5f5d1d75f9ac9d3cd13a5e6ad21d61a9429fb97ac3766751c4299385d1121fd3f66816ba196faaee54a06351bf2a0579346e6acfb8e7fa6d3ec681d85120c97070e524c452a6a0df0d6fb9043fa2ae9325ea0109401e3c4fc8faaa27f549c0e64161cd6e18268f5a8bcdcdbdb76f1966bc8901cc5403d639b5f5abbc5947a001a02c32384f4a08f330100786cf32183a5a3551eeded2d712a7b07854a0beb3d1343a32ecd9d6c6a678d35d1d55886a1d0fe09e633b0360439ea9dc092d621d3d5648ed9bda40018ff755523519648a231c1529294e279a29697f699cc01cbf4c984e97448a77c71f21110dc4eab298822141bfea0c72f84eaab02cedd707f8e8d39c7375c5319f07f8540564c218419f57d764a49121eb51cf8e91a7975cb613da7a2b3c318ed1998ee855ff8773049146e7c9e5ad85ce1a31137506e5057184065d66cefe6668a3f6e26138a81ba8af5cfb1fd7c6e78156654d484044f9a30e486d548f0b3b5dcfdc285a039ecf5b6cf16e26cf99e7ab7a8fe701c856fefbf17ef1ebe61d9464e4dc9e206395c252b1d43713d6d77be4d6d22afc323ff5a2c0e2c87c158ac1b9284fba88fdc18e84a94a1d87479971d23526dff92d0daf875e2e7b5cca6268763d0c8f5e57e2b308ad25158c0659c913c3b40c1f88748fe6f519b594cc38c8e035b18ad0a2d69f8f3a478fac3c33fc0a50ed7442f10db4e438ccb7062ee993859a25063a1438b7e11c37e6e872f1daf99fa8ace808bae3f14a7824d50a5cc58aaf1b5adb6974cb1107dfecc068337c7309783868265cf8e27dfd45ac0bbe3f70b39b8d97ce5031e9ab7d24e630ccd33511f48b20f4475e473ba4393adf8faeb08d70ed9ba339f7e3175dc07408fc2444a5623aa753750495e0533f3710e6590cd67bbe075d1643348a38bb63a865c1f718fb45b92754250ebb1dd4336fb7e67f7e866685d6cf0f1cc793c3a6d9d10e905ed85c2058e1ec337e4a9a9b1b36f5312c5aa23e9bee1cb4711439202a6f22b88301faf1174faa756cf6538920af1dd016fec11f9d0c492e8c38f4e780d3082c1fea607823e673b07646790c81bf6fa530c7a609bc79e6117210ac3b7dde5a2916493c7d7dd2f79004df76f01a04b6f533cee514a95cea2929d562f4d944d643a66f50be1dc14a2d33cdd37084f5763d7b256917cb1300d4c0407a47c133ada66416f06fa6b5b5d1f98434773b77dc204f5492139a00e4270a22ad7ffce60cc43f8e988cfea2595e4a57bd8b25fe86a85e7094deccefab47e79556ea969b7ef66481b97593894957fadacd615419d1ea0a97f42f75046954578b411d658fcd1eaea822fc8d9eac3167633d0a14ed33acf574281ceff7c462670d9ba1bda571f233bf90c791865c2f7008432b12ef3cec9ac7df88edc8ff77cb983bacdeb93978ace317b76c6c6de6c0cb293fa8d38eda21def2a3c90b813430d5c3dba37fe1bd5d65a83546058455248424404cf7514234f7fd78898f7703400e118f4b220959078a62d87e5e926e38f246f1b95fb7846e3f1c9ab08fe9c98295fc0f9cbb78a339a16c4ff8625f03b1540e15a03e11e64a6abbabb603ee5fdd0016e1a4da1815f70e28015940e6294a49b2ece1e76b5c5cccc6048da7de6ce16df812189d9358161a8b0d107aa4699c766567cfd51449cb1e8bfe107599ff99b6c6fd23a3620f471b9f134728b9030f470e09997f0300e4094e390a6a76e109eb154967665fe1e8266dd8ab830aea887e80375ff36507d6ccdcf9010026c3802458fed5ca4e4866d738e847bab5bc3620fd6cab5e4fa57d7f74b0d732312b8b8ca5c93161852169b12d53f06c92a23de775856d6a7f68c4e923ad72a14f7cc10fe906c5834a3cb6e214be4eb39e573c06cc3535583035d09b4ba2cff851d99f409fc41e36759167e9401e1aef3164c26e540cf13fb69e070ddad6097da7752f3f9d87c59a017f13cb1620c77aa1426de21ed32f9743a0715a357908a2d73ef0a3d7815294cc2b86530bec5b3fd78dd89ca43bbfae79a9a9c232130daa9bcec7a514aa4243c7c4b3da41d60aa2ab3c2237d33be793220471f34335f7f9ddb8d9b8d1d850607a7689c82582abad8f8eea4616dda76727632f3f110580310ac91e85442fb1a7adffec858abbc95e0703c3869c9921f52d849837e2eadda81464e33f767323aadaf09fa2849017c75def428e063502de5a76ab9edb18c6ab8a30e66666d7c6f15dbffafd6d0eafc903d5b4b561fbc259462e086a5c2738c772017cd7f379a860669f8af845f3bc8abcd588f13e1716b5f345f184dcde139784a13a33c74c302c124b9dd0dfdf49ece246527f83a4c67745260d35ae0784f8f7ee04b2874fcb3f50cf09ab6af959e48c8c71133fe8c59f4f7b597fc009d266408e84d4fa7f3af3fbc4fe5187026a1313e1d294cd320543e2070e266f76393738b6cb7a4796087f768e9ff46d8351f14ffde34219b7868c81f72360dac3f2871cb6d4cb352ae35da6d5b0e68e353442524a118a75c5bdb221526a0f75d55ca6963a20de45fac5f29398cd437d37d832c009326e6e7d01f94921d3b34dc787966d0c2da444b2eb3d4577001005adc5d4668e1e086b8dde5339c70dd9dff3d1ae199498f237c68b6b068f093c78aae8040216001efbf689d8f13af50e24965982fb8cb2eae05041bef5b13f95088b6f4d97c7cff2e1e155aec437e6120fec283f2a1c16b36165e23f38f427e5a5bc05b0c2c0938ae8edf8afcf5491bdcbe020899359e1e26050d26b196a526b00d3f82792c57d6c8bd664330662ea09b6416a4cefd04c4b94cd4958e3ece06292be2eef981a29e178d1bd97e842419fb90a83ed198ee26930ef7109b5714a91cfc8a496f9f970c9082d2d18922ba9109b04d13e92e29b1664f9f7c2ef1fe157a9f3fc3c9facb4a9d1bad08401c304d7a78ee1a3eae45cb8bd04c3535358974431bfc60e55891d4869d1566c3bdbd92bd1dd1c6a287c53aa4094aced5e9f19707f89c42c97a8740c4dfa4505fb5db84ef4919eaa785bda8cb997f305901553fb0a93cd9dc2b02c05f7b37daa639bae17269fc230eeb6f1d746b0d7d1434c0d19be9a9f09e689c4d4aaf19d644fac6a2219517c09b74f6f95b8ce3a26f3fad30d02861383937b3478310d48089c6441157a5d6f758842b13f44caefa8896c82e00c8d8120d2a686f7ceb97989245b02a9842e48dd7ee957f21d49717549dc6d5ba342cc8c18faf902f52e7386a4d410cc513ab1c5d888f346cb6fa7077ac002c26b16784f0f99aee4191b94e58566d47e44c7b308a7811f739db4f7e494ae321a91392e953a3e882cf1e8be7f514e523c6c3869a8818882d9d984f959befa04072f452c6d16c59e9d2d790c387103250abba6ed1808c96e0e7f2a804aa4f990890c9c60ab366d00198a263ada2edb0d04c5c35b619e9572896aaa54cb3121029cb82051feb0d112b4bc19af9f09aa40938fc55a37c0f000ade0058a1d82ce7b2b2d50e083aa90ad3f535d454b40895f47e24a7ee8fa18627ca9d315e6cf78dbdfd53350aa2636ba947cd295b1fd092004d71d5a91ef4f0ebb5e12814e9e4d5e74c9a3e835b275d31e6f575e10faeae164add6e1115a6fc90da693f6fc6fc38e7853c5bb75beefa8f0273beac2bd8f5e320f4c370de460448155348af685675c0fbcc2432972cff8054d38d75edd80cd351e41394eaf4a62390623753c5654f3677bb9c9c9706ae94afcc49ee5b8832b75f0593286137d22c4c867edb6abfafa66d02bf0e33374ce1ec18e7f7e70a8e8e04dc35fecaff716a65e6a82e38a51a6267ac31a55bc0321360015d74eff0c02c1ae5307b0e665805187a6b1dfe6a79b3a2fdbcdd5cc46061152855eb31d15f9bca5d15711894bcc1be2639079b0c3429da57247c7afbf759cb1b8c45be94602f668502f62ce793d8c56895cc7bd9ae3fe8cf91bc9d8cb4adf53f688dabca1c994cff8095ff07c024e4fbb7bbc3553d82251d0d79277db20023f78ef2e907af2a00761a2734fc2d17dafce8741429b57a0031291749783d8825aba2e28a789d7a9e2e0d90c24bb6e2da3bff436fb603f7ace0d35afe41b9c28815a71728edd812b7bcf7423d868fa1e8541b3c8d888a002e0be6de4fac2d995f507df8d92a6f7c89b0e32c98f117c6e1c57a34ae6fa95fdc88bffea144fe808e10a2b5fa1204dd0ea622bd175f5da941a41714a861416d462bea5a192495f0f407739efe5a2dc8cf2ad16ff8f53cb878b22d2e98bc4ab9fbfa71884872957f97ede7a70085581959b26394d507b40e86811a5a0156bffa1c0f8448cfbdb97bbdb70e391ce2b997771c0c00398e006e11d5c2afeb507419daa9a2165031c2e5f67f0bebf3a75ec953ecebb01899e5bce9e21ab0fe54f29fc0ba12e8041cb87fc9020c3d0ea629a60af6ce0e89ef629e63dda19791d56017c7e5014a7bbd0b6c7754c9660abf9434bdbded750c92978461cbe38b947294f29e68ee0393cda329cda1c0ba0864c59a80903d70caa60917fa8e9c6b82656518043993730b536c03317ac60b9607ed69d2989c361414a3fae7be56dbe4364778a12ea32e3525bee4199947497c3750b7b3e443d89b1b1f1599e3cf9a856e17f23a591b824e0932b8ead325cc904b45fc5a9c49eede0c03680130881899948543e58ed28bf9e7860688d00d6207d1b1e82d8058fc5742c6d110fc430eb91ef997ae92d3c5d59704e91d44c26b02893398cc1f2cb962e89da83d474e04ffa6f11d52acec16248f24de18f7e3c9771b689b97e93d59b720cb841aad3a4aeb4611d5310ef68b8111ee42a6dbff2b171b4bb952f85c489fcc1200e6d70c46f1bc3ed730842f4b3fac6b33748e3e9682d637e0e88137d7598d336199c92d786707eae1d28ac34d247f1dd9f2c8dbbe5f76088e2989a63cbd818ed277bc8f395c13ecaca0793a5b1aa9abff243d8a398ef06e546e043478651c4560d5cfb5009e40682219fe089efcc1037949fcbb13f725d6ebc2d0ff362710c36d40a213d792381d47e6a35e20a984006c3542616fb103c2b506dbf5c7bb80b54684c3ebaa97d207751598954eda45055645e2223fea8e9ca1fa1ed9268dd866739fcc8acb029fd652abe5515695b8d11cad3ebd59b7719af3610a9cc91dbdf345383b6f7ae2cfd07a4f0e7288b05222f3bf1b1a659902f2a0cd482ad7da8c226184a002924866849d2409ab94e70fac61ede76e096ebb5d6bf74452db91bfafc2ab1aa9c0aaf5a05845b2a26dde055285cede9436353aea004718c3a2596f31956d875c2647d71a7c09b0b240d8b9b7d836e4df5ec5aff4caa0a7317653479613c8f372ce0bfd919754b0ec6a65e4b4154d51f06894f897d0875d5e023fdbc90e02ceb32eeb8cd7c0a5dd35cece8ada2dc7ae53e89868f2425b0cd930c47c4006d724d1468b4406b8839590b741bc743d321273452371f55a626ac5f52ae21ad64e2e58b7943fe80cea2dbe44c7c3611cc5494f4771b1d34f2b59973107566230a4595204b31a47efd1d39b1652d9e2f5b72ac85035121f5c9a95ddbe8aa178a383edf472fc7a97d7f8fbc6a389606bdc00a8e0f52c93965f8951fbaaca8f071c394c076dea7805eca2dee16bd9a253df554beb4af0145c6d1405265984f33edf17bb5d3c1b827ca8e3d0a29bcc02e0e1aeead2088ea52cb8093697239b918f9d4d46eb118a7858ebe3640b3fae2c10895da4477d20976821042d0d32ecfcc9c39ca469ba412663a455245166577ff0bcaeca5bb6400b919449cfdb89ba705f4f244e23a31ff64fba348694070f6b72decba8d73fd88c9b10010b9cee2759d03c06248414b39c615ebd3d01e505f1055ebdc742ed29bcc3f80de7bf44344ae11a0dbe1f59a1ada52c1bb63a635c0a08fa560662c299f0f6dbb28ee45ff5325d211dbb568707dc2a48cea6ad88f7da996b7b122a6e10a27fceb70a3cb4797b9506d4ab8959b57c227f74fce01b4bc5316b14c75a7be9fb9fc01a2e3613e302bc22e4ba9665d4f42837d175dfbcaf8594f7a6c83072fedaacd608266b95d57204752b17c1a726f36c85ce2204a8e47a64ce7d6160b6b47f44026c7ca7615d6155adca7d35a76bac1eec959540c5ffd8bfdb9c1c7d555a8f4c631929cc85f654f7ed44d992bb464985c1e8ab7092ff66fded37429117270974911be2f2cd082e15fef546aeab3eb37bc85b312b5c5ea68486f91cb766cfe052c6281a5bcc5fadcffe18b74c4b57fed90813fe6cb46de2cee7f6147a8a66cc1e207b882b7239b177b94add90540130d49020bfa817d7ef0611a30f5198424376498c2c929670e6aaa273caa949000812b110151b7eba8cdb9f13e587600b3807dbf1890e58bb2c4430cd8040ae7c77d6b6c19114f8a8e4540cb69bd82426a9190666c97fbd9cdeafd4ae6f068c98ccbc76fcfef0e50c981da1809f7d79c2e3b77ee9d6fd9455ad2ac410603a6cbabd1c13c011dc749705753b69388b0cc6f6917ca43edd4f8802d43572d463b7d5ae2650c550f1a3618ab7318903bd174e67a8ef8848e3d9a60f825e244470eada90d911d7c0c4059fdaaa17bc56c7795202aac26248e9d7f3952c80c1f0fcee031058a1c0b864cd9e2215fe637df006a88ca4e81a8b66ef40d4f3ca8b7626d62d30aa3269da1c31b13a945b54736ac7c96fe9d98adbd1146baecfc1360c9bf48303c52414cb7741ae89fac60b6a00c8db9b0e1d2199692a5d08f42b11f24d96ecf002d62b88d153e537a901b8e2ca97790619597b14313f774f2c0266927ff56dcd9d4a9cebd17ffeafde9cc836efd7752a36f2ae74e6246073065ffa0a889c09d4dee2f60ac3023878355ee49906b4242853d2f457e9deafae46f57f7406093e55e4bd35806316f6b3d28a3db5500510c5d0f4e3576e29f5c5261c68f1b5cf41c10120f39e7e6702738390aa5ca44dba1c0d33bbabc365b20bdd90dafa9b71a08946a642222f4e9bbb8eb70aadbcb3ee15c72e74a7a81eebb3ca1e13dec3c6e32ba7b45c32705e1ed458418a2783973ca032c8810c187485f1e5ad6a70fd93dc57359183486145e86c0b2bf673a781866567b65964d18164e92c4358558d883055a278f9e7a8e1d59835545a2f2b8e221fe66b16ef07ac23ee51cd962e746302b632e6fdb4d5e71ff4cf6951e0ab62a55be9905d7d76b8830663de1a5de4453c2f6e3bb8b711dc4eed16da13c39738facc9d8103b293ebea2e48ffb6da97edffe6f045e5f789246185d2f423743335f8094c7762a8c485c57625fdeac181ea4f5c86fb52b4b8a46981d7e4347594244bfe9654853767b7959ab5fb74f14b677c2055e71d4861dc8daaf34a2748da432074eee1600c0170c11a724b93f6382ef5dbb2936d56b36ea84fdebd7ed7d2f12ad108e2e83b911a8c411c7b5e38f2b389b0a1c98d353133790b65af9474f2dd4aaa9c1af1acfaea9f2ef6e52f570e2f5c003e5344f74b9ae3248b55930669c840bbb373bb00d146af782abab5dafa1bcdf7d4b7f228de6691e1a396695235ae577ad54f76262115769a364abbba9a6cb802e65afd05d2f5342883ed26b6516d65917b77bf03551b4ef2a9e2e5cf6b37390ca32a4a09f86dd7fee84a4f414d64857ef51734e4a756c947520597b7cdb8c0fe93f9768ec9dc8bf3daabe2161e195b88ea1be0814d7e1256072ec2691f95c58053a3467b870863dcd246e4f5dafa0b90bfa6c17b9e8289e372471e99afe26dae9b242bc29ceb96d55233a27afbc2678de21cef21c5d159eaa190df44d5cfcb4c8e2312426be6d04582a4f30a201a5275496f515358ec9d4fc2e1a7ff7b38ea87cea59cd409bb534b491fb9fbd8ec90d362f2a48c18eb86f176f2146d0b8bfd31ab4891b816f5b8853bf2d85995c673cc2ccee21c631a9a784c82fe36377fddd1b66218ad6c7747ddf8598a246187bce99e36568a49f5c00406d38ec53456a450033f687c39cb3f93ba74af6b92c118a3db453a81ba8f128d611d848d78b8380de986700fac365072e2a5f996f08e3fa6857f890ab142e1d93fbca3b68ad0173faa00d54d8e0e22bdb519a84063ff7fd872000c7d3b81b7adde7dafdd9ee5ceb197837b7b5352ce727980c88989e537510ba7c08adcf1c6de097f7796a9133066f30ab68f891d999ce17c5532ebc9a714b6e20527ece61ead6a6830246794a2a67cbebaa20fc7a565975aaf8ed568ee81a663e0dbdc62e8dae5236bc0445a1a83bff6b9d5798c86dff987aa9bc0beccdb00ea51da8e9cbf9011930f179a660c20c12172a1f5816af54292e0467ae79b71b8f908893018cdaf129d3ee0f46830436a2516e0fd58d5283974c32dc3f5b60df9c163a6e70b0ddb898e770efb01a366fe8695c0b01eda5f306673596fa043eab68b3f95da5bde4c17cd0f32711e850115c893f4667596f72d398e5f03ff6dd84bd4c55922a4481e8f290ef1d72c7512be548d080359c8399505a0a03e5579ddee408e4360595be771acba0ebb952b6c51483c6bf281cde1da2f675dc46b0cc88c88431d34f0a61a20d96ab3005707a975d9002cc5cc9c403cafc1c55a9cf05583c7b79cbfeabc30b3e7172d1f9adce3f0223a7f8f74db5752a6bc2265f8d64dcae26b96b41994a80235d05837d6107c56d750b5a7d6357bbc5074e827bc160426e444601552274dffb4e57aaceb118baaea5e5c81ede4b895ffd7411f73099b5af1e948dbf2d6802634ed125e47d6b75611055ee4d4920fdb94a6cdc5fb830374e719e5be29ec237cc8ae22c963316b8ee523498febcae90fa5d9798a5e2f2b404c750110edccf90cae49409727628eab9ebfc2cfb185b737fccf1eaeba2a0f0c0ccfc8be55b87676aa62bced83891ccd8f82ff253d7f331fd6b7246af0948d3173c2263ef5aa79b6e4cec6e843d7b600e00b3489580f4831a8771e2bcbe04e4bd5f45343ae443c3124d7636b43a767ced94e54671f79f1b10568d007d31a81a99eeecd7b5184e377e924a37f196ea9547120e150c1727d0f6cb349a46fe5511a00a26fcf94b5d5c3ce988f420fc83ef2ad859a88d84f8c2cbc61ea6e3d0f8283178b19935bf1494394f7054de2b02324eed4795ea35e840bcc82735ea0f5df1dcc83d20a28802b2ffc8fe019494d626721046641503757cbaee05ea9966d72ba22ea82800139637fb473e3e4a571fdc276b7beb250a956602ec27fcf84905607af0b37fd5adecf25b195506f5dcbcc2f7b3449fb285538d71a342288166771d4eb26c8fba96373d478717095e5f230b558e914992c5022db82e4586a01783cfd9c65cabd8f1caf592be53ccdd5c5ff73c4024b9f5f740c098c28513668a48c9e4222f4572ebfad236e49442d1e66e910a6fb105ca6b702028da4c9317519c97d4f09beb6ac21623012ba7c7564e0f82177808afc62958599e9b62c728c73e2aae3035d8554c1b962f95aa5bd36ff279807ca043ea916a2cad089ceecc12614872a0ab05d8411756a49d184c14210d914416318af705de5796b56ac4101b944508d5a23b98ffbb4f041429f0d64c8c9650a08af58b3b3213a09f537851b0e00e49b1c6c4531ed01550b66c7f120a6dff82245f47b58e25c9730c6668b0bdfec44f643bead2ac85760f7f9a4135d290e9d603bd9d9c8a9ccd91a311f22b7a5253f9ba017577c954b1e173655720b69322de20ab5ab59f70eb08fb1b3714131d59c86c7e0c16dd92ae2988e5f4b39b235fbb1c1fe691db9b6a1204cfcf0fa5598014a9e702a555b64e6f4b2c9b33b17bb56ec6f8c4a65916d89b92afcd352ea9b290391ba36e9d0c395155ff84046d14164430a9999778da6582efb8336802a83ba3d12b2e792fa7b030f1e380fbe4f28c4a9a212fdd7e5f3f0d12974021148017d3267e47d56f97a2288d50a80d59f040eabf8a56a5b87c62cf502004fdd01430d727b00dcf79adf771f9d7e3b62e2b6171c9a310cbc4ec2857ab9f54b7ac8c07981655a61b6b8cc09b9725c237517128c160e1c0368844ad11bbbe76472b59888ac33429fe1910a0d601af205baea24154406ff07b4369a73b81d9815e9ae28e47558ea4d09a234e9baab30913376f3fa236ac3fec253dee2192c5a5031318176d295104e41ff4f18ddae3e4be031713f3191fe06f158d718eb2d96110b5f297f6c00d9bb718aa26fc2e52275b2fc20143c886096630e5d3b58f39f9d10e3456a1e9bec00ee080b7f2aa466d2419233dc984b1a09e833c43fd62939ea2343788d3e75c7bd42785eaab490d9f412ac9880acb3ce2bf62ecf291c6fb3fd4979b695c839873ece4226a42a44fed3e82efe9919ed5090ebc563ba0790185c6c3b03d2979c3261f99fef116231866ca3c4a383dfab6bf32d1fc97fcd78d6d00e00012d143bf65b7e1544100bbc24c65f98695bf382fdc75a4b540312a32d58600ebc590a6763a6889044a01c749c7e1b8f515b924b304121bd89f1312f4b1144ea7db426df9782a829759b710251cb3a5fcc0c5733916ccf9b42dd5b88c4694d8458b5ac95661df572a64e82efbb3b8525b4a4f5710011e91136932b5da2b5cbed2156dda04047d35a8487c6828ff920f07769f699f9841d63db0327e061267a94ce4011ebf9e80bc6ea587f1c1a0be2fa38e3ba48fb514080586e85688f76e9cc092e4f5b073f76fa3d6b6ebe9ba357af0cfccc9a7a235423adbc26d3b30a74668086e8f7dff0ea7b3699e1accf43e2a922cfa25b41fa9d31ebb16d68d7136de3451d656b79da040b549abeefe9cd76031f52feb0808975de3a3891baabcdb815aae700a464049994edbbcaff93af73ec3232e012c93512735a83af9c3fabf06f91c14b1d51813dc45b5dd8bd8620989cc522bf12998db570ae6b8dbfc99b203a0e5946709e18edbb4c4735d46d027948471b96f0fce0a8479d33a821fe473d6a8ff9c1c843401bdee3b9a286103cc756692e3e1db6a673349ccaa04d0e19b4264b5025b0d192ae0657bc01764de63c34beb77f8561f9484529d3e2de39db3065ca9a5ef1bf3c78543e06702587a7b95b4e3efc955d32bb0eeaab48e86458e85ba7de2aa14fd6a7de4205134aae71c579e0f93c70836d1e49355ed340bdb19ea38ae00a09704f1c99b0ec2062d88ee96e61d4553177e38fd09418ef30cd2afb3b2d88e73b92025186c58150b48b64e2c3afa6afa48599f30f007c6b5959161a033ba1a1065e40d13f139007855796b0daa5aa6867b5ace2ba5d09ec18fae0c88c97ef4985b0f6fe75d9d09f4510fee8941bdd5598b28ecc316b556aada18907657cbd8ada9384bee6ad62c97d2fdeeab6bd950f5676d922f536548cd21fc06d34c89e1750c3d41bddfe5ff43762ea91640c6853c5a17e810285683dbfd0dc1b81a5a8485cdf62ce3232003f90aef7d3b7d36b326e0393d81ecec34a41477e41d7a213b981ea97eef1566537a0db245fcd3aac4ffeb60e28c988764d35d5a38db56b7249d4cf070bcda1a806ebca95fb7d0f1ed0288f20990b1043df178dcd1f66e15762317a95a95bb6e6a9945a2e847a82a5871ae44449c0a2266997211df5cb73e7609bb9842dc13b4f4a27ca33fdf40d3d4afd37ed459632ce6d419a18e5a9d676f4b09ce517248a6a9a5b439adfbeb4dfb798254d4750d86c36fa67e0e996d70860c37898745af6e3dcc2290d5af2316fb23137a6b92e7ed856e9b9c700f75f9bd36b24e697ea29346f9fab60337edd2b258cd061b467ebd401b1f95b580f80c8930ed1c3a90fdb34fde16d3a3ae93705892ae79a5ba1524bc3f1400e15fc08e1f96be919d8e71fed953958693699e501ba41790e44d8995355eabef42ad693104a508ed44268d039048c4dc11334baa24016ef41e64eb58f99cd6950fb865cbb4ac7e0547f9f1123096101cbfad5fc647f8e48f26190b759eee2d4dcc0aa7326cd437c3d97167b75e4cdb64fe052aad5a3c89ae3b067df1334ee7a6220202630d18735eadc2846736ab9b06593ccb205da2256aa691c9251e35a3089b9e478917aeefd5472ba28541b3ac158bc25b3dd81ac92866ff1e5d5d672b2c25cf25d2448117ec6ddc6b08acaa0720a04b91d3ec22cc2133a1846b7b2aefcd41dcd065358a9bc406615ae939606712f3abd7cddbe9a6df08e3e6426c60b896cbcaccd699242600355825763ad8f8d3626d5f3d829756ace837a0456a1334632288e1b250de12f45d0671e8e2fe7f9429cfffbdbf9b8885a36883464fc03de571b9cbe6a8dd7613c0455f11c2fec0db1020fbf5fb7ad3820f008ab8908b2e1d26fc628107dabfbe28f5501c410262ac55c3df56372835086eccb1f8b1863830b34192994eb5fda8e9557d028bc2804e528eda6434817cd5b7cf8fe85a13b36f23110b323ce4c8c5f02c818fffe038c4e7962565179013eea20a069e6a2844cbc71c591a945dd24d7a1601aba35e71a99ed6e230c201f6e62b21d658972504944f6a3000dfac8968a5f0804c2b708e3ca5090f04b54933d805444f567dcc524caa3d2000553e9e3fa329f4c34e93eabd782d589ded03d61b285684382a9fcee53f39788835962af0b084184e0e2dd70611d7d46dd9bf0b14ade8229714545af20f3d6c54309e6ea4fea5fee8e8ba420166bd6b0c36e5ad26532e5c3d757df00c140f3ba79071937c4cfdc0f004672bc56a531ef5d7905c6ee3d21e2c23b6602970abe06ee765a8bafc9958c9f8bc4559cd1148beab9a52bc6c6527fbeac53141741ba252a1e617fa1d587833200299d1960813cca322a3ec5f32bb4e7bcaffab150a1d6f343b3b8c0e6b141fc6679b4daf3b31551dcd5cc8f6815b99a491642656ab24aa3ac2a9ba6e548e94b3d980d1d46f1ee8bb9abef2b6f5a1b37a09abdda5f075de303703188b5b832398c7518abb2b212","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
