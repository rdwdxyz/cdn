<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"372b892f2689e3614cc4f5301c7fc05439ca6c3fc1d183a1f1d16bc43fc3bf5db3d279652ed7b835966fc739e2368270d6d5270c2cad3181517860acc462c05f724c0b5a1294a7934cae6f1731c011b16c9bf6e9d1c2a05bc856850a5c560be05e694ff609504a163fb46212ffb90d0a0fe17171b5ba43498c58e672b708cedace8313f53ef554e326f50593c12e989d08820d9d788f2b271b890199d504e2c18822d92ad7f18af042b3dc999a598eb3d5b1d749f857878fe694c0aa4335b491cef19ec45c4bb6181f6529dccf03f1cb3661d5e6cf2ce329ff591e4180551c6a4b36453501438d03833838b5947e83f0ad302e6b6099982e04641ad4fec7c92a20a06378f7fee5fb04ecd86afc4ec87d4943e03d49a74666cedc96e8f3980829958bd71db54cda709cb7f6e0a620d504ac5df07ab2d498020b3d3f6adff948c8282dd457ae5ce366d138f8be2409a103c0f834fe3007186a9fa2f2cf44dcdcd344c8d2c8c194bda6524e81bc18a2419d329f577533e60c2d8dfd1d7e4640fb40d4501d61005160ce7bd397c05373a054c9b7c4bcb92cf19b2d0b30af720b387c0b324b8a6c8dc0ff12dd9c71f21099458b803c1721f2e4072445c970e4bdfb2ac8b4b41940f2ff83edfc24d36f598f4e2e4db147c446be1b23d5fbabca34c57b8a1aac1c2f77c79ec506e988bdec14fdf418b8067bf8509b3fc19df8497ea71b14c00597a7756e1d953007d9f3addd4ed1b074f8b7243347895a642660e3bca85fb5edbbd360a6056b00ae93b12be925546e941ed87838872de61aad2441da3b1137fd8ee5f30060ffb7af626b4f5fb0367c9b62cb0b9d1bb38c1a51084940468bc6e6d92bb8a5e6cd63ead6cd94c90417c0906c37db1b44845967470d57fbe99ed241cf6c01b5cd62a9ec2b83653b7077a0a6a04dbe83a12e837980f53b8fb10eb31fb44b448330711a3648220a45a7a081760e70068471c1dd031d4b9a5f6ba6d08aaab91c8fc5225a35a60d8764125e395ee92800ae501d239c638cbbb429b0f5418a7f87edfe00e8cde92dd386554cae7b30d6d397b9797a5503a79f58bf444b40937b5b42f1f61bfc1c1e3611ce057a2c7ecf70cb5002ad161ff0ab4e90c943a2ff88b32c27e7aa1b56561112c3c49aca3bf01c48d6722e2de9c6f4b2f03f8e959c1a7d30670d0704a3c97bd4000016e08f11d61aa7442c3dc397d99828b9db48edd08d642c09373d844e163c8b09bd43bbbae78daba905c7ebec1e0a1c339ea0b48ab36ea8cba05fd519b57144ed935302b5c3375c4524432e7503e2620429b01f35c6178e1b6715bfa2f02b67fd4228dbdf66b6020c44219a8c22b0ce7a8cd4168a3dc1539aa367eb03d9a1369a9ab3c616b5414b4912cbb406c9123c874a05afd2f8ac208465ccb87b9d277643f4dd886500707b1dcca12fe3cc02429d6512d4746662d187e7e9eda42cebe421ad2e07b3feab7f592969dbf54886a4df402586445f3f97a6ac30cc3c9a7dc04a02bacedba31161e50c2d739b5b2e4642403961f46ea1e7cbfcfa2825f5d926cefcd6c69c17c45e6570d9b3fbf100effa28c39c5b503acea3eaf0d66d7d160b84da3a54a28c8c02f49c94c7ac2009872b46aac332e6d266ca7452caa9f2af8ca19d399326e629d27983079f46c8bc778836c4ab7671f2475b90b827fd476e9b93fb1fe300d0b4ff252fbe4b2626f799f5f173f8e2b2f236a2b7bb1845a373bc71d0c5ce814007f668d4a4f09640662f6c64f025051a57f4b7f74b21b86acf76da407e907a356db7054e5e2bbcab1670de58688654615ab13cce06cc3d4844fb68b9a1975d06f0789df516f179bcc9c70af6b3029ada950e2f2ab30eae1d60981f6e1768a8a6217cd6f625ef2ad1c960e82934b0f856190ed9da6e7634ab58c8e5109c104fb45429f2fae23d3363d90674feeb50d697f0822816f5d8c4831f61c3ecaa57e13fdfbec95a171928164424b75ecd71a14fa5a9948162a8f9953d323c509298e6d51271888b8a2104112b2e67b77872774a3655f75bf3f3fcc2f310a24a5f8b84ad248654a25bcf2fab50777c95bca4a8002caaf896303c7419162a0ac399f9413deb707b5f6a6e4f3df4cd297c43daee17994887cfb1c5c6130b3d1e49ac2973bafcb6214b91586a8359465da7139cdea1f2279b16e227ee5187c89851ef9ed40302175f5907c22d6fecbc6b3a38f07ec3e26485ec18e6ae7e10525d6e962dcf090416059cb79786386ca205e76a777eafb8555877da71ad62099e4bc05129130c5fd15b09299bf12b64f6222914cd25292771c2f199ac6a6e75fe414f9258d6fe2b82ae6997678d47737c0d97182ec3a1bfae524bf1b3f3365b299639a8df6b110a2f5e57a7acc961369d543c379e9aeae96314b2fcd9bf2520e38030e369c20f43e9b3cf6cf7878911ffaf0b180ba2b88c5b5b8efa41c675d2d9d1be0728e5f065e673ab1d59eb042339be8ce4dba265ffba86252dca31ecb79753e957f4bb912133f2f50ccf8d63c52b4c911a90edcc2dfbe29f6cbb3ac695bf4571a3548952c9f09936139a12a2f9bd9222bc54004bb4725c473fd7d2463fdcecd2fc3afc90cec3e29d150de401d37f4798f8b3861a2e7b6145be4d33d545558274358137ed8e549b7886965d9c6cc44c52261945aa0823e383ced320d3f8b0de03278921fe11595c743c7c7928637b114454bb6f13eb144ebd4fc7379588c1c50f9c052502014ebea0fe443150a3f609cec14c47b475927be202bb4a77e2dcffdc01062bb001a231df81a14b1c4087cc5e73d7ae7055cf5813bee06319be526b2b0cff829ddc448801feb8329938a6116087646d7c855f5cd63adb53470ff8649e9c2fc34800cb0c629e7431c521d2544c4cf644d0bbb5004e06169989801c90511107efbd86e7821c4499db1aadf496146f402cd9e09c9812318f2c30bde53e42ae4d3be86fabd305f37fed3468266cd972626509cc5c0bf30a0761d57d4272e5ecff449680b6b9c88c15969a01c2a96518003adb39d3319cb40064345590d61ae60de82a11d4d9aa6e148707c27708b1c1f058d623ebdf9bc653e44ae4b616160ae22911d8d0dcee56c23ada3bc9621782089939f094252828deef4836fdb036efb434896e222d0a2e64becd13e395a4169933df17e758e59192e6b7103615cfb59835a443fd5c9ce52e8e9b8e565d84cf4c06ab4fe8cece7cd510431e4098e647ce30581ef0c7620117551965509fc36753d6b2a9e2488d2ae045ae2f4226d2720a325e4ac5b309635c8be59d5efde760b69f46042d4e66a3cc49ba702730ba819c2895be82965336865b9d92ef6341ce71f4428f210cec07223de195a0943ee18702fc8df4ee03cb0d2a171f15d9d52b5e11f252c2210ba91cd00771e6de8419d9cd140347de15f9479427ee9c586627b1639bd9bd71e98c9510379d93d11f8c56f9417d715e7e81c4eeb90fe6d17dcff4eb13184113474fac8b59a467a9e5391335753a66156537e10826cd0f2c6cfba844680a14a0a769e5659c1543ac832e5bee11a086ff0d0316e23417f301589c49985a91a361cb45bcacc9a044f3224adb75b183d6944215a9a4eb3046d6b29709f7ed3bf040901c8494e8dbc961fe75b8d831da2d147cc24170a6e78c936511bb2b847ae6c13f2310070e2d2be25d0e52bee312c45bf079e1328d340a82e18aee0708795653c8748d3ba82e86f287db2b43c23fb6a9dc76779906c48b7c1a6712e610fddc505af1126844e8e080ac8d0763d5bcf3648837bb7f67c9e363e1489aeb16af230921c64b05331eb201147e9a50af4b710cf710a883ceaa0658a6de2318edb514b1345c4c81ed10e03fe8ed894843c7bd172a092a0d4f7ca4fc234036fdd882387618f1583d2533367e5a96757c8c92d5eb7ad3d8a997749891db4a0b6e298e9164d323d4fb2f606e9b75831e4d14aeb4f1c76e3751acfde310638d173c6dc857ce7aaa3d5559430d2edec55cb6109077c8ad32f572e747b59cc8f43c793707ac1d9574624ff8f6c6d4230244f1989895990797d5330888de87c9fb8f8f77f48f4a7e57a1bb3348f4312b8f859c4518dec900ff731d8675f9b391e0da256df2f40acaed392ae9ebb0e768e8eedc0debf56efed0f5dfa41be1addee807f17f58ffe09ac09fd4cd3251c53f6ddea56734c4a98c4ce3f1388f4cd1a019349ae0046d99ec2d220156a71b5237f64a1e6c8202ef55f2b5a5f6b25d2ac737820daa3cb02348322cf4c2d323f6eb99276c44a4d44d9021813933db05f3738819714631663298c731a712c5a6c32152db0f4838df580dcf879113e9d4143d52d60b0f962e756d8481110baa79fc0fa60011c59f7460da8a93b06e8d5f5e27bdfdab04d110fd23ded3da064e758ba017be4fefe3a49fd7eb1917af2e64f3e01d6cdb120ac7f94e960feea66e0e5608a03fd89041e02caab16912b17142d347d46e501e579be72ced39564287aa8593668c5607ab09a0c6f221640fd7c7c9a7012132e653b35108f80c286b085ab4894741f9a6cd051c9edcc222bb7bba90fa8aa95f81a72a75c8e109d27dd71b8dd69b1a8dba1f3b9fe5aaae8c26150d32703755b024745a4b82bed3824f3702640d9dc4c4ac11cbe0fd30a0c286688cf11fcd081766ee5ad5cb139692ea42978a25261aced58c7cea83991d58d487e70cde9de96bae511d26155d4ccfb74983f1ce95452d4cd3bd7c4a424c053107cda9930a4fbfced96cd795c61fe3ad74b5a1f77aa0a371e45ede7412851527802b6072161b76b8da4bcf9b9f21bd0d1e17a67d8e15815affa51ac6c3358d7ded5d4272de5d853ee5052858a4d0608173b29a41e285c67db073d6efb1314fca72022ab3e3143853abea63cd76acf80261a152695151b3165d24e7f76da2ceedf4363a12aa248d5446858587365a02914feee84c485f48fa548c77267c584cd57002c8070baeef8cdf61379545d0380ee9c6c0b67be5ba2ff8b7361daf8b1f3f902f8c61c4b04cb52101c07cd96a555b8c7c5fcf3c927561c088cde03993b8379174880d0c72b9e3545a301ae66ed5ae3b57db9f2ab24f020825a64512fa7a31a2ffa3b07e62874329b761cefb88c49cb390ec699c8511bb8037e4e8b42b34db291ad1160e616538a132a13e64e6117c7f5f04f938dcbdd7e1307cdeeda54971414db03ed684ce29a009961522f88ab1db477b21783e733b60b6bf8b1f67a07844c652b8d2c6f9a778141fa72814fc23da9f282ff406cfebc68018dadfb0b8204119eb980d003d373498f29d9f3b57adab09503a51f328c4b39c63e8b5cdf3aadff2432ef7a076be05ffdb3f07bfd1b9f34444c7418cae86754d80ada460eb746473cdacbe7e6e25a344277e1325a9b521677e32c6a8dedcca5ba068b781baf6f26d05aaa066130a3ddf418881842b561c9f7ac07b06c4b01089aa3690c421ae5b675779fd32ce9e9c82a7b341b2b89d7572f4db7501028db36d8aae51f56c7824328f5865b15544e400dbde5ae357f67f59887f9ddad3fb3e1cd63ac1e1a96a609ec9c28da03344f7f2b1071b3141e7a8ac752a890ef875ece26f509c0c8d186b68fb94d04cd63351a94631d1d3a9757940f3b8fbbb830c0ae0c2bbceeae6419dbcbc5a4b3d5e3617d16f98c77ec243e80b41032ec920b8a11c7f54dc18637a5c65bf1a13e1cd175ba56c5cf054f2ca36706ca5b744165d32097b3b120238d9983f425f069140d21dd1b2821e8efa1cbe833dbca4111085eb4723f9fffba4cb94898d43159035583fc09ff992cb2d0f68b6fbd3eef354cdea5fb273e6772e2cdfc8acff9400b5fc67c9596b5ef3feb31b4d6fb3058d802cbc6675cd9fa92030349b7ebb8c4c77df22a9f1e3e709993b307030a0968f9f7811b2ac1e6722fb80c1e4ca0d830ef7b0985ed212370c130d19fbd318482e3688052a967631969dc2f210a7595f02fee9292f9da75051abd537691c20abde7792b3ddb571c1815a49259a5e0bbc0d0507c9491e2e87ec0f8e4dba4832101032e65214cabe9728e9c65a12dea54921ac53baa27e5cb6e953863047ff9ea28350aa028bfd11631db6a4115e9f8f50c182f481f1e51e3eed05da4e726ffc12905587343e3ac996c70043aee3d4a67c4c0f658e491e1205cd08898ebab18a2abd2cd8acc8bea5e51255ae5dcfe7b09d960492b6fc9fa27415fdc7229a2648d50d178d41bdf7c9f8e2011404f542899abba3785e45682e7c6f5e05f1775de62a2549fcf5d303ca94e35cc2ce534f119afb7f7608c6b87913b46aedeb876fd4b6d884b6930ae24fc3a2330a432fc2489f4339ee6462a3918bc10a344b0b2ca50132071760757cfb5e8353a3412888e77f0abac0ef2ac8828c6c1f1502af7a622bc5521ee8ae3276a5642afccffabc428a9a5663168e04f1b09e0450758981498a9d747fa07f7e1b95ef4d5ce6c005c6b3f9642aced0318f9499bb03a4b4a299ecbf08549da6a8ef538b8b773891fd8973699814458a98feade7722fc79b0eeb46ef5ac36dad15fd90ed8dd897d8e8e0a88726ef6126637033b4a14fdf92b582f34ababdacc60f2cf64038106d464edb8db587969d6d0c4bc7e63827a1201bd7f427ee4beb87a05c6053fe567ac1a1ee8113efd5628a99866fa32dbdc67cabbc2b237125304cc1fdb5b6d28a0f7cee02e0cf2a3c3288fa4f86c5a90a13f6880f51b66638abcda088853114d3ee50b53fe615ca535fdb15ba759c9d2dfdcca50b3f5c14960f5e4f1d69731397076b7a16206721237b4ed3e5da3d42753715f2d3eb00a572051570e317569d2daf8ffc79b0d58404fb2d2f7499bfaf56b39faba2d05e6413f2689415ad97224de4ea1f78f7c1cef784ba6cb6f0f60156560f4df20d25670abeca4c57fbc9e12cf29d967be9d3638c0b845a9d0f9526767fadc1581d90102cc6fd395c571bf47a1413d807c408067bed513eab6b680daa788f6a7bb6a33ef4e5b89e66bf55fc01251a12307c7210061fb6b1d5808a9c79db8168977d49433bb317b8763b29d3f93904cfd89242322fddaa29a0c77cf0171763acf707b81afa0d7031bb06c2dc645a1e132e724d3cc6e103021db00d4a02d7200fc5c6c72e9000314951edff57aed47e202fa521649f53f821b8d68311a5f7a06fc42ce50e3aa468b0743886f37e5a95a07714df9d94d55a15755fbdb444de9397d0b9304065a6117e90360ede0c59b095410461d21767a84ef4c9d85b2732bfa0c1270639cac97f5e86ad330c953f03e1f407127079474bfb69c20781ec4613448f5ca5da61bd6834e75c82f7c7f47a1925ddf13aa0f3a490e589e0fddd41c89253b6790a3a78b5a20ef747fc17b6c5fb2be3f79419c16c7cb956df5205119892b8f46becc71b8de65e0846e4cd174892ce938ab019db29cbf2f0f00f89b966981215aea6a96e4d456849650329cf8cac334d20ca971fcac213ea92d92bcbe41fe96070e8371e7bad81d2a243fa42c26f325f6325b8ca8bd54bec4e259647261c207473cb70c88f7455d53f35e9735c1b28869d711c5cceadd57f8842ee1ed8e4b47f9be62e330ccc1efccaaace0a1269ae95f28d7eb97c08b7f835618c5a81b63baf74f39c7f99aef4803648717ee62b0981e752df7941dc2e48589b6d97bf8d49e6be0fb0555426bab956ecd4e94f7a745cf37ae282d835baf6ea2a0662c2eea142cb3ce0c39d7810b36e7004657527cbf3c5aded9eb62728261e7a5e51f9c408f762649f0d3364719fb718e9e417c15e6ae5c173f610b75ba77397ff475adf317e5186f4670759ef84ac2c68d6d14d22be471fe0111668139e6972393d55fcf31019a24b8ebc16c73e4a189f1489cf06d73826d4c6d123c46daccf539ff7ccb046346baf64c80baa1c4ee79134ead606f991628ac8ac673c3b5497d1a21f2c8b5cf4ce5319dbd814c1cfdcfce15741a13056c3b44da85d6001b7d3c2a08ca39f9b734202d62110c50ea4f670adab638b45f3563d108a8520ff117b993d7be0f2b67260680d5ee11dbcb6fb6f8c1adb99c7d7ced4eb817bf55d8d430f9584e25046b7a1edb6bcf8a4be2f4bfc8dc42f040a236a5ed3bb1b19c8f9e88729aa7412b40e75efe7638968f41feafa7b79a587dc4c6034fb257aff4d5f5d27734cb7832f0e271a200a7b465a46df8b551a7d89072be02fe1b9ef8ff43dfac611db4b05757e2ade6c02177972401332a3ca8c469db8183591f858b6fbf54a9519ecd96582bdc184ceecd5d3cc489068bc7dbe718c95ddaca22e8cb118198e9b93e1dfc86f10aa20db3aef9469f537c43504df43ad7cb2528bf960dbe2a24797d8d5bda858cbbf132a605b9272a93abdac6bffcb1cd3d71fdb0986ca3e44a56620f5e5af3c66bc22ee14332416369cef1ea7d20f35f87397e5b0157fc234c468309e5eddc474ee6e0ab1e6f285ebec9105b6fadb1e7776b7bd93ed564920cfeda60b6cf34d55f799256478cc2693464f7a8a26c6acf3d00c3199d11f66df82b08a3c48a3e04b5c1c719e6b9e92680beca7a6b04df9de47e1cf3f24bba84617db0f4d28b5ab9ae6d234e4873b8a085d9cd4fa38d9c656455440c88953dd694843e17015a2580e8ddf2fa1902c35363a238b2608d37637fe085affdb3df012ba41387bd0a618842aa90c0446aef09936f271bbe84543c9582d73686705a59f4b3978268084f72835b93781f16690a2b7a4f80142100635a88b80d91160c17a32db3c1b486c4c3aac581bd4332ea18c92d8919854f8b5567b46d094503d26854315f50fcfcd39de0f017876f73a2b234c594b845a7f71a2b556b4241d477439f5b9d45164d879bb3f15d497d9b4cf627f29337aff73aa902ba97bf90e3b2401ec0f6300437f8e5f528095617b55cf49752cea105624d9c2691dfa087f8e391cb48d66512ec7f1105f804737c90ead96343b48ddd994c0bca84dc4babea8357c7d67a53339a5f892acba2f65e7375114e5e54b5f0e27b1a00c57cc882ee3eca6e463ba81876829d7340e17685df2b8e9159673ac63ffa78dc43ea71beb216c9d473504334970068cd8f158c005854450fd8ba820ff04de1625742ad5664985437007c89fe6ee67bb8052265799dc92b4e8999ada13ba81a52468ad213666ce9e2b07c1414ec95ac690259b73b4bd797274f8d8dc6731a65992dc9c32d5f3a918e011396aa38d355f2cd9796f41df60ccf4b5c74beb175e538e1c59ca70328b5368e54d31a31d50e1a813ddb23862edc19bb1bb15855f0fdeb9069ad01227db3325549e288b8974a932fb242401190b03f8f228152ccae7bc78141961c133551d6e02b71e085c03920287df53bf72ecd17a93bd4f87dd290b83815a7e35cf14ff1d60688ea89b92cb93fa6463e0ef95b24456e5d5942a4b5b5a7e453406edbc8bb33de6f41c2ce03dee71ce74e82577e9b795f4b82011bd47fb48e6765e76ffc71768bfee714131cbc8a14ddcf8b1f49b420e9f5287417404010873c3197e8b5162a1c3fbc29ac3cde9eb99c72eac57fce5621a2793e01401071c9b96d0d494d19976a8e08820b74e6c18d4729453aabcb219de9cb5c4bee45dc602beb17ee44cc6ecdc8afe6d1c0ca70425bbc67c1124c34ab260bd171448bc51516afa34f89e7f307a713fb69e2e8a124ff0b71e03d9a9191d8e81e26a520bc25b25098972faf5fc1bf5eeafa30c79763384fe31a27741d0e66e20e353083720e559e4516f7f03296f3ef99f01fd3525c55542f9da66a3a7e6c1f0d15ed24fe659c91b28b540518a1030969b95479b59768fea91d374bdd64b1c2651ddb060406ba9b605b294d32eae3fc3ef65dae622d61b64ab9430b233f25cfd134d1abd86bd6322cae45c146113be7f3cb3fce6b20c62d7694db2e3dfe6863af6ba42199c54f29ab52baf027a0f1b5628a153d411420cfbdff09d1a2ed650fdeef130a782566db2d991cfbeb9dcce1eae8dcac31c6177808445b191a58d60e6a15c51de20b67b48362e917846d5fa09ae45177f64001726ab879c3a7a613b8b4dce2bb2658520eedcf6aa26c42f5ff0e5a5aeead6cca81da9d4adebf06322d2619ba0b662c51741baf947cbfaa30d43be107e40535559dc1baedfad35a1f9593f7211414b3fbd78d6471c7d048e99d6d4531e02bb01cf6baf4b9bd2f6ff145da89b3fc40a9301f8f4171fced507ab17bea00d68f247c55e7660ec968079b4631b9f3a2ba28e68305c0e0a24554e298ceea21097e1b1715b358d6146aaf262dddae3751c5bcbbe93c502337887bbd5dca537e5b852685de0442a0f7a381ef3a88fcbfeb1338d6af561b0662be8815713549938baaab1d7ec8840239fc87c8aefab2ce8f7b0e0c32c25ecc17dd6f08805dfd615f0bf4db1e104c356c7352432fb34dacd54b8a631e6aee24354135d5724fd622b3e71c5bd33e2334a20467e6c33dcc0cfc222b9e9192899299c0145fc03791cb4ec61daf4af81db86e808692fc4ccf7473ae9101097054e12f38b7532245594268be2e0e5fee23a3cc05588864557978ffdf3c345a4be3f781bb88ddea5eea011ee67a9a5440f6ecfe46992280ba4ccd63aa6fc431e677c030153d998dd4c75e6b9621ff0330eb657b22f24dad140613167ddb4564e3082910b344f3eb647df5c5360fe0a1f1ad3a3d35212c0bb04171829dcb3c8b0143453005450e66d08315bc2a9b5a555daf1907300da510dead617f9a26ba69a37d101f817ecdad2fc58814dd560636f23c3f1bc11d5aa73cb415ab13e9ad743299996035c54ad32178a6cf2e91e79ef46e6367f580de3f18c79c2af285264300979f3678394939dcaa8a175955d8b17fb926c1c62f82571073eba1dbfc801f0a99dd644c23f3875fb19837fadf36102880bbe996bdc0b80f9f815c4b78eab15473b44738edec7a1fa9160e7bea94d54db0a7621982b6ef2a41a702dd2e05f5d80064063956a4e250590c139eec94aa146a169937af5ca5af2214c8c23ff522ff5de9b03178f233c2c09a7dca516b951091e7d9cc80c5b1e79042364b9fe5b0dd82cb90f1ce00ce54d2f6397b537b791cfce3113215fbcbe269d5fddbe4504766777389b4e698018ad079e409b821ee3270d58794a772f15f32ca5f8451bc0a68ca4a12a410b5c6a9d13d3f8f2a8ab0916eb828dd5a0a0e72787fca5795a97d39f44cbaf3ae13cc91cc4695a8fcc4a5a972505d1cb232fab113e2a801d791bf6f0063d2a7dee153792a4ebe0f94dff6d657e8a9f3cf638c896c675e6d18249a9886ddf0dc5ca84e93033d1492e30760b3ab11442257461768952d55c7010f3ed1c448f18d7fe1e640f30b98efe3174624d236bb1cc61c4641cf624f0e7678578be07faf598a2e34e6ac9f0e1bf5649be326f4ad2e641957ac456c32d0c2578a490bdf7c7514d8aa3b085bb52dc38efe490188fa364eb8abca06caa381d3f6f05aa588af48adf313eb8a75191e35592f532243a401c30b0f4a7d8c58c737d272c8a74428bbdf2f21423b741f41dc18231f885728dd026955a2898e93732bcae5786a74e2fdc433c3361966844727de4fb63fa95ad0c7a732349233ab6486b054f89c04a779593e21d9652c4ada525b568f4145fd003674eec9b7cf789abcd10d6337bf61c462c61aaad6d9ea0d246a33fecb7c8b7931b4b0617cc8f462e2272e11bdcfd74c028b3807079e25348591ef737979372b6623860cb346bc5900b8f7adbb6f5070ef004b71819a3428fb165605fd20facd5c27f4b71e68bc70a8ab0c9ddf0047706cf6a2738c822c9a502deb457a7b6c241e0e9e5d8fd36b1aa5b63ebf3d051176237f3bb5d6f203945a4c89291e7abbb3f3c099887e908a278ff036fcdff71c52bab49ced306d92beeb7980da063cbfc1a5f640fda80f0075623ae207e36ecdb245d8861e074ce0b4a64fbc95140a3fddb98c18d4636d4b5ef52ac190db23f7365e97b91d2e0a6ce97edff10ea33cd6d7d28a40a165e4d2af54f26e14eb66c1974def70eccd489f45937cf0e6a19cd04bfabf1d59daf8b7ca2637fa5051a6fd1713bb16a88dc4aace544b43a76dfc83655b62f2ceecc042ec30934738f078f48ce49ee851fcce9a498a453cf08d96fd54dd22980d0aff68ff0946b7707216d8066b57755b2a83d3267147fe04ba2efed6f6167ec92c705b3c5db3adbff37394ef01bf3fa3e16694f4705b1a993433af1ea4e9381b00e8ae8cf539fe0e988d1ad4d36c2b661d9cd3a74633f9fbf25444763bb670c730a33182e454cf34dd94b857200fa06be51f40abb8d1e008f25075c6e2f4e82adc8281c0a793c786cce45ba6f454f870007cfa34abc0c206664e73fe34fb5a8da1dd1b3842e217dfafce7b56b9738e63117becb98e1f7b29e61a1bae9f00829ec14a1428b416bd49590db55c74e63df3766b9575282f7a4dc9f500d2031b93a10c34ac2a8eefcb898162ea94a164e89ff13cd38b0469ab2cd16369c7d8f8a64c53610f6e71d4816af572af8fc45d5e876867fb42da9c36d45bc5be0cfc6e109f7de83333d9611b1685ed59c39706e1857e81f84da6ba80536d710dd74e6f8685a20e337a792471b21aa20f4a7d89a57e9de2f93bff8d2b2644251c5978ee924d97df99609dd9375d29c06d88bbc67ca770b2db7d0d0c4efc71f6e60b58db3b7e39d663ad12affd8519ae269b21e8aa9c87f6348d3835a59e7d8a66c8631c62221dc48100059b7006221a2e4c265b762bfc43526337522e6f962f805e49c069541985694644e488a59ba7c7632cd877eae9fda8342c246655af8af499f5e1a07b79d8f172e6febc6930f3e88514010296d484ba5c26c2674f8a60d713637512129ac86b6649fb24a8f508d3def492eeb625ba51a9d54a44263ca96173f4734b4470de4a3f02b229d732a53599bb6a755798930bfdef80ed2014fb168baa4ed981957e975d22a663e0c891e98cb67964b70271baeff0d10f6c1deaaf630cf2cf37bf1c3d2f0b0d3851d86371a6e33836dd687723420ecdf9e5381ea1da4db831352f7b81db2f57f5209920c28d186a1e846fa319e47b4c1aa82e799106517a5baac0ea2e7fdbd812c988895ed0399852489a7d03c916c499ec480199b7e13ac0cfa346988b892e35c2dd66dc944e0440fbf08922bbe1956c30e9a842fdbc37dae524dc584746dcebd840e02ca4932c9e5e594fdf2f891b975889b73766341d68166d02ead62b116390b2790dd62885077b4bf0aa011e12be501b91629af6bcd42fe281c909fc645aa7d8b122ead49e6d147b2e8e0c425c1e7ed99e4fcebd2b28a2593516ebeae09e0aaa1fb480185dfe1c33e1529141852fe72e57f0ea8ff5f2ee2e52773c75f67cc0f2303e197ab30507305242ed629a278cc0ac2246bc56c89ed8f07c8ac08544e2375cf884e7431a9c57f0dabaa37c50d0fe59edf932d0809197e0d22779c846ea78281dc46c76d0f3b9a7298e06f1581e5a81a1c7f83cf2bc928dfeec3d25d018fd9f8a98ee0c04e2c7b197560417ce36b5544dc7bbfe950218c5b389e59b77b05c1943b48ce2731f669b5d4d31dcbd07e63aaebfcaf279f54053dc651581ebafa2fdc062d20580e168fd548960ee4dc53c6ac101559b5f46f183c2c3f23cd2f6dce852d2bd3b61392f48a664dcd11d5331d8fab68c07bfc1e18ca06a878198eb313c37dfc2d13908ea0e074f1e3d6365b8865947dbf1af00e9f92c20340bc10daa1cc57ccb9da87d4e49f0b519e66a9e417e39142b2c7624c8be05719e934b29b3a23d5c41e3ec75a80cc89bc8a37910e9724116b99cbb8f92e23f564a0677280b479e4abee307649221942f3db23acfcac8112826a97000861bb18c811182eb35208473a44ab9f59fce696005969f23ebc059ea005b11bb62454bcb274f98fd702494c98055ebc4771d17d17465cfb22eb0d616fc15bbb955c1e1f0b0df8cf97a782ae1f55f891cb90158760e2f31fb19c2e470197c0bdae67fcc86e56bca5342db1f813078277986c302adcad740887ea141afa4b528645cb9f865baee3450e9a67a54e73cd3c210af6d0cfbd694c6c4773e4d938c66d53386ff7d2b4ec9e74c133e2feaf903a233036f4839ed2b41842213915e33b42f588173e2cfa45c345aabf73ec21b1b98f806e0a5e3e2509f22f231f2bc6b86f63981cdb945dd02ef2522565577b7fd3c1c9dd5a6b6c26d5dd4bf956e659f1bf44664679a6c51af33b2144c5e28ca4279a6db1072b941a37b4e902c9ed72bcbc8b610cf01d805f66e7be68b04f3beb5c2affadd619eccb2484255d4a48a332ef68228c114d5ed686fbc749df8d9bedeef48fdc9d57eb14c956955d3c0dda78d9634450fbfb296dc2e6ac391e01f3eef60016f8a929b298a594b9c6c3b63776270c71009329a2f0c3718b5be95e0978e536fdeb1770500444172a09733b543f66c7305d6189f706a7d43f002c16b0ca42301d5e009e2600d5e74d913563c06d02d504ca50a6c3aa5ec659f0a4ce188fb743d935072be3cb8c3a5576c75abbad02e1623441b6eda2e7492c6265feed1a90528379b9fd161e1762ff3e8afb4cb23d75d8b05ebc41d42f3d5bee8c1905eaa9bac6db9d2661838f4df3e3d4f9682404853bba49f0214d921c9bde783d4271082302d17f15e5370b2fc11766259f91b345b4a76b0a1105aef28fb518e433f5e5782e83ab3d2068445ef8dd02cf9a065af0968d3d604976ef266f7163c7c55e255a62584b2cd9e612edb356ba8427dd4cf13633112392e890a3a8c54c2f98d99ec7127fd6a0f3783e794863822f5ad6aea20ac1e255804e35592e92f48f143a721d6d00df9d806109c2109c7bf00dcaf23d0e8f692cc975e9493ee87a63341c7b05be939784cff6925bda02321a218e4d3fe4cc83f7e4dddbea89ed48932c4ad96eaac7e68c1cb371ed69364d42ee41665305446e10546f47766e34f30b505c0f0fb767ffba563bba98e9bb0e58d3e0e48a8ed639a8474b717f776b9c88db5befe505799ce6b9175aab2f1a88651f85c7cb505be9b5af39ce993fd270e9dfd0e6b9d1df09137f05b5daaaf5bd4e16e5863e13f73d7b67f036dfb0c43e9cd4dec943a300872120daa4b07a772eb1f95b36564854be4cef422101d4edb77c7e65cd64eb8b875f0844ff95ed1fb6d312e479f34e9e71aaf573583715e98dd08476756a230f240168a6ac723d102c794dc93c3649b29a64226a39ca0a479e675c3e5c8a1bef50a637b5779bb4f20dfac6f748debcbc5839300b698e93c31d99a1f395e0ca6429eba0cca98383bf701fd4e966ad57600443a2ee22cadf7fdc357d2fc675f5c1a0c7288a4045b5e30d3495b539eedd02b74f74f84e4bf62b800b3144d3226052b58e862f9fd0a4a5900f1c87d6c83edd9d30ed8066406be36f9c559ef8249578df7691ece2b61d4703c1e9684c791d239b6509b71de01cdc61d73a0f3ec29f61d3664a27ee400792a559cad3d9c09f25db0a912596dd386e314504b9ef27f45b5f778bed6918fe27c913f21850481ea7a6a64a78238aed5a2a9aef821e0687d4e63ac90611732804ace9488a9cab35589a6385740b4a52466f7a855a95a889b948306f1e932fd5375a5d96cf10a0d601f6cb25397550e7c9a3624d5226647a552148ae51673869664ca38fedd637f25bd127b19b9bf53b6f327367da14c9cfe86cf838a09f34b4113922ed64f8c5855b71c52f4ad7c80e04ec8526544a1a3f072625013feca6f78b12dfe1e00247d99d1eca23ac6862c1d15f2c6a41dc4dd459bcc56e6052c73c74e844fb3c3d3f09e261b8223a856a69b42195eb93f5831814ece3ef1c46cf82842a2c46176af0094b3bfd43bb3eca30a807163adc36374ca8bf01e47b91db30765fc22f9b705d2529f0c4a8720dfacbbdb7b91094ae0207b90712d35ca8552141ee9a437d85a6178e1fff33ccbf036c999626a978a5f60c6f6bad92658f2583dbf044e212104c820d59c06b0f249138017ff4681aebf8428260f081835db8b4a1c4debb304a191f374273832317b201900a9f96602b213da062e9fc03066ac1485579a98222bb914991e42484aac43f368e537352a1f78806c71d36b6033bee31bc2928c5fe08c753ecd5f09ded0a70a4b02cada00c3d45e63ef48de9092f4aa579d998485d2f919c4f6668b78a8ca67fd5e6d6351ec3b4258e31dfd09fe51c921ba1cb4e9d8093b31a66229679a08190d4e9807fc90d1bbbaa053caa1addbf40639ff63555eb4fc6e5e0cc2df10efde39d96531b6dba5d1bde1e07632f49a37c1c54ef05dc38421acf6d8d48bbd0f5893d641ae0615d12dbcd8653396dca4644995c87ddfcb131c58fdf3e42b2117e6ec93580cec902238dcafdd88b5e1504f6c78d06a813606c6fb9af459a4fc76944afb88a855fddc6b94047ce02ef142a3bf4051e8b2d864aefb004a02f5302a59a9c43822360352e4bb2ad4091073010beea699508c5305d3b0627fbf2beff2e211e8d470fd9ce01255ab734de4ee2faf6d762771554d44ff97706e6cc4e6016832ab54bd895c68cf2f9c2a2b098b795e39d145082789e3261e300600b2442f6ac2cb6a10a8872e91003216878ef43b570dd1dc5fec57383e483abc7cff10eab1067ab85ac0b566c8988e2921bc77432779d4f0a63e02b5783712b3c60ad509d23519a6d6dfc66ad09d5f6d32404cda1475e9a8849653054c72aff9a987f35988f96b7f3daa3d271969c31541605b29f8764ce441f87fa57f841c828136e69fc8fd9b5d69a4252012f1fab0c87cea7afcd07722d70271e9474cf6219e9a44e4fed7ac63012250f25d8dcd70c1432113e109159a7b340071082cc2e68b9a86e459e7a35f0c9e93ee624da4da6f37a5473309d3deafde89fba66793a9a4b923e1ccc3bdfb9e0a1062f71914ba4c86da6c82d9465fef7c2df1ef41d9f8cf4b74f732c22b8f0394e0c4b09485c6c3bcdd81078a9c391b18db368fb412a79e3443c2ca9fb4793d12266afc235c8ce1869a49aff454a35f93becbf342cd4165d4eccb2a3e010402f1fa8d8607d22689ff3e6154cd3bd6520d98a842408db85f4d44ed6f446082b960eb4523fb6c54d5a781e1431a758da03e159777a3302198896cc93911905c0b683702455e3415740dc223cf743e4cb3baac11ba83ce27010c5da35abf663318d17975f944792a94f300a8d6ae1785ab7d9aa74e72079752181f710c97ae6ea9b730977b2b32e85731ebb69540d30aff86c1edd5b96042f05f12f9eed2cf59997c207b27652543a6db8dcc5925534393b6884594e855614f38c43ed7e61dde60cac612920bd1fad77e4adb2d88c806db05ffd249ecccbf5e7a3cafe7bb4d4f86766bd915aae04d4efe1aae97fbcc761db9f50b508c6063c9e5dcfed01bb1840e34b909ca039e9121f5aee2b3c1ff53869ceacd08d87b4a4b0d3e32922f42d34ccee182569637417b7f7eac575550b2fc1a5cc3c4fe6a64594aa76de1d18685d281c2ae1337ede4f255a75a1cf5745e1eab54eef53c8eb12d55603c73cab221578b12c96343e5058c2128799bf20d6bf8a508ef6ec8c865fce9df0e4a82f67b160a3f9b914aba46d48bb8b5cb2b6ee47fce2bc0966801900df83bdbafa1b596bb27431d8dd192b430ac6d9d2e8dc0cc8ab73ca7a4cf14c6b6e70b4bd55c488f6e2d6bfe1304465abc0b84fefd58c7f3deaaac78db1a642d935550fb240beb2fc5825520881ec01e957a4a99f0ba7d37fc638e2b1320814b2ecf4e3cbd1cac970e22f2621d9afb9b04221965680e8a8327838e6155b224e8d95651349d10031996e45c7aa897b8399c8b7711faf60b2ed087ad3d2ab7a263c2977be5e51239bcb997c78ab828c3fb66a6ccaf4a11ffc0cdae60296b1dd36dadddf6579e2a033d71565c48206a201c1dffc469a353f82fe9101e0412c3f263b4c13f5eae41cc04e5245b94b714a61d511e7ec326df28476633c6d202fc650f92a9f4e1a5c5c0a7ad703cf3a419b38caf66b24b97f7f3e1d2d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
