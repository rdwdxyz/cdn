<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"57d596d59df217662dba325dc33ccdc35fff74a71cf755f73f748788c8f686f98a7d964c503dbb770ce22d66ab43468ce41c2d044d2e14115f2a6e83eb3e5b25dfe10e4e1331116525e093a18584d2deb3419b6f7dac28f092dfbea04c770c1399b65e4acd279507d6c6bae6da8d520ffb610c8bac1015e3c08203bbd1e73813fa94f48359c5b851e9a976f9fd6af65e2420c4729a403be05275fd78e8cd31dc6ed4c27f2da95c59384d01527bbdfbdc66934a1aeac0e12d2355982454d4207505261161e33050ad9fe1a88007c4b96b44feaf095308098806676207e93f12e09f0aa3a276d18d7c1fb254d4f759de78dddf245ca26386a2266c63883063873c5ead492432aeaf4c7eb6631307f59becfbd048913c17936e5e7428d0be2f64ee77a8aa92e5a9b4f70a33d36c98363a29b7e93d474fc5f90bfd4faf4c2b94d87564523abcb63a7f0452a93c0e9183c88ee4194f0f4d7e6ee3fdcee847b07ad78c18de8f4cf59fbf59d7061abaa6cc0717f20ebef062b5ac04699caa521d6ff0dbebde81cabd66c84391262ec6a179ec8b2b397719fedde3e89825088b5becfdd7f6506784bcae956d2b7248a35fc2aedece2060d6051930efc0cf4fd7d851955d0cb64729e9dfe2d48ee109322461c3c1a17afd44ca96bd0be7293bf73c8cf1c836435995c05d8569498bf7aa1f5a3d67a8e4c5b6176574e9640fd41217633b9ee863dbe17ed45bde3ff8e9264012e250235df6536e827f0ec3e9b5ec52e25ab42e942f24654eefcfd339e90fa6067cb7f1c22144f0606ffc6ec98114f8d0e0f624b95ffadec482b983fcdfcf98093cb8d10ab0e49066cac57503f542ced731594325b85382a4b1541ecfa0188b5924f434489101bcd94b1d27476d8c99de425fac41ab15cdf7fe41a2c26f4d67d2991e2e2de2059adf2bbc402079e9409ba0a2cda3f2bb9ba63899f5b111c5ad3cf8b86a2130534c63f0a52dd5f44f38f6e075b68a7e30cf08bbdb3f5129bc20cac318941c56775bf9dd7faacf86492d3edf25092d03de6d85fcedb83720a5475ca4681e04856dd259066ee599754d148d0896482888bf183253ad14fa70362eb47448725d9f8c2342a4a85e857b61f423f51fc10734e4b6f4f12244c4d09ca54440c8ea19dcdb89a9b56a2272dd00ef1bc31601cc16e492a7bdb9662ff4db95a164ea00717872fd259584451ed3be7f936c59d203b38a2dfc7eef0a91f3746ba386a8a15e6f263b1e4c9332875d0538c7f120d5155e74c67ad094fc5c5131f3d99c2f6ff71c17c33efdc25fa9054b53a3fc6e9ee9b239d4f750a41616f4e80284fbb5199935c75fd80064efee8727aeb5ca8f807b0a37ce0b2220a827ce0c7b541fb74a4fdc137d3da418be136bc8748be953bcc1420cee55bf3bafd3e4d35ee45816e01460d961bd930c7ffc30e2275a4b461deb937975979f0dba5f577e9dff779a13d778e721307e442a74fc2839a37aa32c8a80f99066c62e94e2da8402331959325cce07bda12f6ff01603c1ed45b5ed8b8e23ba01f4b213a2564bd774df441904888b7aed586ecda669fe3d8da8640c34969e692a9728ca0f4e985f56e47b401b967ea2a714fe827466fea1ba676da9c5ba0b3482ad234eb41fdf29b59f802446cc4ce68c22bef5e3ebc75bf933834450d1e82c427505f5e519ad2585b56668f92e3625c22e553bfd3b62e3319e2207d6fd59b129cfd3660880228597957645166027d0569605c7c15ed4ee2f96350f450d338a9d6566adc67b54d1cdda882b5221533ebf5e620f0144c2cba37bc042b4ef5efe10e40a9faa207dad0005b49157dbd5cb1d8d0fbc343a1d015ccc21aa8a7440b2a910d8b56d442915ee538c57b6317e34538d7de2841925c7caab8a75f0f83418878bc2e2311d8af35b9e772f44864ca164e491a8f1b6a9a15fd4344ca56b662ae545797fd341d2668d6ce3ea80bc644db93a4821cedfeddf14d3262f8ea239bef5781bf30f7f40bf3229180b1cb108903558f4e9b7c311bf9b43bb4903096df326e66bbfc54a6fb93d3314fa4b5abadcd16ae87ec3cf1cd1f7f2b6dcd6f63d821816881842195d1a0a4315e93f6f6569db917e94df2d921087aa199896829c850b4582f544c091f4d7f7f3bc0ebe371f5f1c98ae54eccb44d5c9a5eda0cccc4d4ec33bc4b91edfc2820553820d5bec5e814f387e0eb1619cd27ea97f8357530930add641bd9fb854b53da5774eb3573962cff6945a2f0aebf3acaddf8e5b347173d0916e0ba8d54beda63fdc0d938e462b8a06324770ffc7b62726286e7aeb0f9252bf159009ec7201f4be768a176410409a9eed86f9ec300c31ccd032e1245b4749894d48881d9d2e7074ef99aecae3f0fc28467c0deeec34927ce72b172b077f6ac4959184b7a30384c71a0d9d452991ae3b9787e323c1bbb0c255d55a30b6af1fa8dd89f9db9c053f0f1a71e21e0bfe313808a903995ced0fb2c1964bf73f15d840d99ce00cb55f9fae50e0675217d598d70e235dbaf19e0f1ba35d96169d15e27e482668d3563b0e150a6b7b7b8e2b1d67384b38076364d53fff5857c9541647bbc622b52044d02d0898d9303ac4b3ba7c583b7bfd78a6cfe65063b7d1879c56f5607e2bf3d92cea94cf03bf2bd74cbf1fc62852e64f6401f7a2f2d91ba4a2b17dd095d56e841c2face0b0b3e289e07aa42a901ce1db189053a2f44c97d7d0e718612f160114493fdf6e56878ca62d22aae94d3a66d27566114a476503f4bbb1be0dc2fcea5b2e255bb41d4ce7419927ca21f4bba45a12254f41a533bac2ed064c4d4071fa79962014ee4fff9d5ec61b9fb2642755a0ba2709d0ebafa32ce9f641fff8936ef2896164541ff16dd968199e071843a6e63a30a1ea15c111f40bca627c2446caf4eccaec31adab95d9cf4072485111c36fe4e1c525b2a9759bd045f5f083933e4ad4c41dc7e29022b73019f29b66765677f94065b24495823a98c409e66e1ad53833d9929715d034fc4488e9de6fc0f4d344d061ca210c0a22620a56fd1d09b73536b80cf2f405224ca505339ecb2a8ef8a4e6ba4391ac73e6eeebf8ea3dc0631c5d85151cf537fb021af070927bcdf85eb858d3e49524d06632a72daaab7b8e9a0c35811175b2a19a143feccb26d5fd50cb87d41e137f44387c48d448749f6aae5320b469659025eebc60c35318091125c24cc900add53337eea8d4d69b2267b7c435513241455c73956211c6970206c9ee4f31c8a4ef01a925c2276da7feee7b304ed721fe91b3df87f6c0ba8193c7b72370407bfc45fa06deb2629785cfb1b649a0e84d2ddb8732389db0615b90df2042a536d8860469271fefd8fa2eb723664a0dc7d75e81ce6e9af0c7fbc0622c9151e6cc3caf7741b89ee4b58ce3b43d561c5ecbbc8d11ec3aed47aa8da58c681a9b189151ea72022f3c4c3c1424ce7f934d4788b597d494051a8bc7c28cab687549923caabd60b97309dc413b5c7af8fe75d2fa8b41a9e195c4fb9bc571e8827588ca77344e0d4ca8ca510d52a87e7d9167a55fb026361d0701529f6ee4e8925b8498693aa1352ea05d15042dc282257d6bc2ee67740dacd9cb6932aa9fd13c478a317a86a463a323736275955b95d75aea1e24cd781bd8b9603af8f9d4d0ecf2dacc2b0f8db0b6d8b5a9b47067fc9ab91b8bac42051fd614fd64a6baa35aecd2bc4deda5927a53c035e6d8c44268b10d18e85ac382f6bec58b6af49c8aed66b1fe7f3895c9a2dc65d21d8a8c112db9154ecf5598f547c4bf88145a0aa75ec8b6c32390a1268070cb7be379da6c106a4d5f7662b1dd3e9c9a1d143523b082a24bc99dd236ad8c475ef7fa481b704dec7b8f04bb6febe1b6c475de570bd27c5c81b67f3ea4d607d0e7d100888f2bce2e9dede867af637ccff7ca5488fef528a958826a5fa6bf6ee51fe92972377aea1a9fbea30830e8a1db037e7ba794d677d3a7f991389912d4d0e03792bb5add9dc8676b91fac7c9b52f7b62e854e98467339f2a71f80db3a812c54b8cff5e35bae0cb127597f828933a8d68b45f06fcae4485ef4291c873aa3c5624b1b96307226f5a6c4c16fe057ca648f43b19649f8a11726c1ad7104962185a024b27e0b8c4e8b826383c13b250c7f26904567a0866a07879cf273d111b8dcfe192bb7f4f39480a9a26ad2438c00de0b8b910eca3125095d4f32ddbd0c89a6a718a0fcab11f2b143a459b827993c62d1bd8074b93fe07a4eeddd365f265d498771ea340e6c6b11e3c1da25d6e6f13cda4649c9f1bbc7f7d6e65cfa95cee317222b5823d129a114e70a5bccd374fd6af71be05453de30614f24591569295462737ec63ca55eb3fdb45ec912f401b450a591c5da5a451d5ea434fdde4a18d5d04ba67c8aa658dc6714db52163fc05f15e2e09db5133b80193e429a15d4d25815faf51b7f20ac1a5c262a7f60e4b106c6ed3ae72381984d06e48d412df94bd0892981f37dfb6d958755e4f7587093c9b452e67e90f37903f6e44e3cd23443fc9ac46f17f50e9756171e91a00dfcd34069d446b3065c663c85cfb146dae135ac1e94de4f85f0ab28712247051f7ff6224a135bf193bab648d1755843d96bae636c337e3e96e117dbc4100b2f7bac981d360a5af1acd6a54003a5781b7125f3fc8e97fffcbca8d2dcbbd764af1641949419eedf9e49203dd66a5e30d222bc97c4c15e235d124b30988e523dd374305f9ff504c570708f27feb4ea0b53bbba5a18a5591bed4b15a0efba10d3c29c6f0cdd604ff2face44f3ebe9098e7c88a86daa8dc80958d0668452bfdf2b34a13b89d48daa028b2bdd8b5e9a2dbccb366155df2e6d367d927f1faa402517e3b39424eabbc6ae3df714b33de017fd52f98bf58eaaa16525b2130fffb366bbff6006d560bddac8f095be7fddd423eef60ae096e59725d706b0111104b96b4796552e9855457f73c2d4f0e2690d2d42b8119eb3b348ec9334e8d4f8084f3f29111485306625d9397c415aed6fe8c053efc9bd6d0a4405ceffe3f58ce183df637d6dea5be542711d572308c4796ff8f0a1941fe70c5471fb19ca3cbb64a465c4a003bebf6d9d567ee9b37d09cdfbc83eb03e521b64efffca71096edbb8b4bb4a67eafcbab1b867c19ff3f96e364bdd6719aaea1c3541f723831dce0e9243f58248e016e6c962323040aef3c7b88abed50f2f212a660269588cdae3286ce9e729ba30bb9e9524bdb0f1eebd817e7226d39cf47efd655d088910d7d6e8eb2b5c5b4be87b268d304b38bcf997491cee2312774507e35177c136fe71f6f90c011a8af977d7a3d00b53c801226f537734aff52da6375e96befe40f7cea0525683d58246af21ffce26014707635f12a9db1a08c93f1e207a2bb2c235aaecd623909655ae62d152d3c31a06b683a8bef042ae7e08458372369387c72d268122ce98f25dcfcc2b4f3394c167b089060f5162ad3982fbccf5c73c9480c0134af033cf8a982f044e3501cd367ffd08da873813abdfd14e05b164662e68f7b89f670f826783620a6ff895cd0b25ced4303df0ca01f4cc0bdb76ecb5d089149221c5f59a1a958165e754b49a4b7076520faf0ac0f7f9a83c7645707b758b7ba8f3b2444cbdf91df750663e134020793bc0cebc57fac14a02dc8fcfd98a38dbc60e2920fdbb588052b6bd452849b4c52fafece7d8a170bae153a633ac4dd6575bb58fcb1d7d756a358a7681c902b2413ff3b361452f0c8a976d004dae3c0f55a86965dbeee50e78d16123e4c6c1dda64d5b69487dd21a6a7efc52bd87860822ec8d667417dd3039a8eac7546a02a774f5d96e1bf173a54209bd72c83834c59117109e3403e4327bd7c1c7a6478fa9c910e9b9123eae212ffb2a849b488ed72e43c69169bb4e50de7c25c9f7049ba2e8c5548e1d67287cd4f8b9bf36f8bdc8975797e4b76d978627d73bdce0a2dbbb004cd5639c85dbc46101a4bc25bb859370c1480f1519486d35fb6537383df967a16fa7d0c1042488b67ab0d09bf2bf3a01db6c75b625b34f31e578a711bcb7bec9e00fb961d65c4e031c2ebf3b02fa001e60ec5c11bcdc8c5a5e14050b6e5dba4751fbc30d2093bacf2459549d4dc69c1e8b8061ae8bb3caec490e277d828a3dbd64f5d9839fef29f8285789da60da83b48b9e5c7dbbd2c69d88a282be42e0f00209bfcea5bfa1a3826270ba96addcdcdfb6ea6bd6b5056b242712310f3b2007b1d7fa42d0445e58a3f8476d0cb73a7d4ccfdeccbe4addc3e3634f7ca619174f14b580e874572549cb1d6b24f7f49fe33b95920f6a911df15e1d6a5d5a23bc494cfeaa678316011b1e37eaa5f97f50482d11e2902bd198f09c125bb2f4b366e0db784c79d26abc900735dfa576dba3c5851f77021ca3bf30af81ce81e4f78fab6d4a33f391137d17bd607dc3ab37c952facf46d7f394bb5ac7900289501346463f976ade289233aefb1936ead1570a58c1bcc72afbfa99fda1822908f653efa47a429d1073297c8a4e45f9f1b8ca877b67531f3cbc7646228542ffab142c7ab57c17613db21eafb7f98253dc3af7e34dd4395d5280b5ec574a2deb6567ce7e36a2ad89fb16c558d5f7989976ce61a164f4238a5f381e712091dd33d5019ba4faa74425c7a4b5a1decf5fabff70ab6ed2b22b4c4076667cc54fe67a52bf29f8c9cd626fad0b2f9a7c4bc7e08fe952cbbab8d9aa7c5539eef17cdfa24bb2507f42456fe334d802337eeecd5f4ed5607c5ffb0fae07c9a59b7c851feed970994366c428c4c660d3411375c7bf96f4ac24047c6d004693831f113aa9740908e925ad2fd6855caf1a8a00a8c741da2a84e76ceb896d16ed3f6645042f699857d4b7e6969cd11a45545450e50ede83cdf209ddefad514bdb77ea896e13740cd774f995d2cb65cc439532c88da5b41f499f61d0ed1e0e13f08c59663d0dacf596aba792793739fb27d890effdf92ce1b6a652e52d1217775415e4de4bbee69bcf2b43a72078fc8972aea3b850e45849e72e936782055603208987053a096030fda498741dacb41b832057459c526bcbbff998125c730f643d472404fb3262ed95ad1ed879114359118e9722705baa0644ddb97d2ae59cf7fb40811d4998dfabbdc50bc3bfa2acaca5d68ce12ae772a52bbc0a878e494708dbffd2df07147f0734b5b8d67fd04cfa0897f0658d1bb08fbed0edfd14db1dda854b45e4552453d03208325eff04864a6731f4bd0c28843f86acf23ccfa0d55a1a00935b115a49d105cb7d371661e6a654e1688ec6fe6ddc81fba2fb05c4e4f4aa8e3044aa5f38622d6675930e4d9037cd4fdab452a7faafca3802334422aa9c42035ecb49d5302c71a405b5d028c8408f9b4d604baa95922eb2e07882d9c1b7e973adc1af387098437486075ec29dd59539719fee8eec3222aa4fe9cab8b279154b89ac4fdaeb9e60ebb442a9942552d0ab8e90fb2def8a547bdbf5de8dcac653fd5b11fcd6437a7c37bb64ca3b237b982e9410541d89f5a63fa33ff8d545b9867a08d20cdf6e164b4161d8173687d4f07346ecded3adbbc03f6ba62d80de43c472f7d958160433ca93cb44c6e7703e6e3bbcfe8099cf8bc005016b26064ec4b7f0bda14097f588bab4e004c901d388eeead00de83ecdeadce85a3ac497c9cf2fb19942feea5b3cb5b609beea233a5958b5773588d9a7cf0eec4a46baacfd100cddf493d8b114e8919ae625cdbec7d5d7508dcc87e58b4fe16a8b56aa37496873a7bdcc025d4c327f6a3526e2d2e42684979205a0a999f2ed1f54b1460d82d2d26912bc177b77265358d22ffbb7faff4598a29871ceea8c14d5c8b49f8281ad9983847a0a476d8887ac9f4e9d3334b690efcff366eaa2d50e8d3adf43363330e2613eb0b83167a7d6886e117baa95636c44e5ae6cb21dc7d2678666c19b725e79d7d2635239a173c43ec40cced9229fc1f327be8ec85c8aa62af7a6f8b21516eb647db3fb2a5f909055c20f0f4e5cd311055bfcf98dfe1d05ea9f4c1a26b068a7fed78a7b0b98f8f8e00eea03efe030eacdcd3cad8f456cc1a4c58fa4c403251b6ddf64af1095e052b9bebce43f703baad48f21c292b75473b0a090b06e0175e142996ea641922aedb096110de0877794148c30537b7ab59a9d8911403680bb481debe82170a2b7f7d0de9c5e7f48403be89ef9a347fc7bddee6e8dddea09b3b6d13980d21edc1aa93235c92eb2dcd8cf7651497b22d9b93ffe3a29381a42ac2f637eec7b6d1f45159b6b98d6fcf01a6d7de70f3607fd1fc40474270d4b076fe47344e88a5b632386162e8bb30e06c87e4ca9051f10d190209896fe56613187f67ed97f4d708a953138e6b97444688df5e90b89eb5a0e69dd602163088d9b27d2067c33c8a6706511063b76311379c714db65d6acd7680f29ed6d11244f56e75e62d48a1f5053a107fb2f58416316a97a49b5a65eed4b8bd16b120fbfecffc53f1db29cca9af32a820820888875f9c50786fa689442612a0ffda0e2d219571759353c28b91ab00f3f1f0d6f1cc97c868eaa659fa83344e0d8facab508eb9148f9622fc5279b6226caabf2be614af169682bcc9df0cb900880d176bf5165490a21d31256667262137fb15de50d5478c03e183bc1898e690f6ee604fb831d301cb9cbc9a5340c2b2d00d426c638d6ab6cc015d5b53afdb2eefaaffe2f3411412a98a4d5d38a89ce67c5e1ca6baa595086659302bb6d337d960cadb8a68daf0c33ce9ebe440316a13be8bc9f4ef78bdaeeb798a836ef458b82856909c81ee9a2ea2bdf1d70e5a055e61c6d33bf5b1bd16d1df9e0211aee00da6b0577354a8bdf744bb7741ff683ef346ed5f9a7cb75dc8fe8b79f0df7dbda546c6ae743569802d5f7433f512661e2adbee87a3020f69221a3423167a1fb0373f9ed51e9a80432dd964ccec0dc4390e1e25705060801fd6c0ace68e4af9d9c7e3dddfffba7f4771e04f0eb9356b0e0f670772b9dbd96ae86c761062e9990d8735114c6863ae85474002235b24cdf5218d4a70446adf7acd4d73fa124a12a311b5ffcfb13a36d3dcdd0a9ed7ba6c4aaff192b3f22a2207338dd1f878183a2e4dad2dcb04f35e5204139471bf98efe3bae90d5c661a849ac4ececed06a5ea3bc522b6577bd91dbe6a362ff67ca979091141390f387cbf2d8cecf2adf3c83ac1cb162b771f276707d5ba36b50d003c5de1a9bde3e79ff554580dd7e0c73bc21ca245e8b9041b3053238af14214e3ef110afdd195ba631b1ed40c9006b51b8d187fedf6b3aa474ab9c492c4b35d3bf482dcdf6c3a6073730e7b6787d18b142b7a63db64aa4f6b6333cf250efeff7809932938d41398ac19fbe77633c876905370601b90bc22bb4328098db2aea7d3c38fd650d80f13d9f1ea2ce648b0d86c34a55e6d8dd9c218a0fdbe836853bec8d43a1990099cee0835c967051ba46dcf55885fb4916e15ff5c05395fe045bde8e48120811203f3acad1755750fae5e1e19f88782d0e90555ee7ccaee2984a63fd785bb369de22613cb60434620d6d692ed0d58dcb0bb1c9b03b9203afc5c2564aa85267fcd90dd14c6634224d46d3b5a0d55cd5f3e9d0f58ce752f76f03625b1730fb98169cb6cd798a144e2ec65abca8fb6e9506ad72dcdfc1632614e8a65fc84adba0fb882f15572769d2706a597d386ce647d956b1d05bf2d0f9b9b5df74e12e55d39d841cdec0787a5f5af1c89de04a2dcc4765e5958e0bf4cc42dbbbced17f7b1d4594a5b448c6d031a87e232ab1b78f1908128749efb69e72c58c82d3809761156f27c61ccb8ba6fa6ca56b266216c54f3405dfcd750cc0d501483e2526b7619bfd8f7b848ffa8814a6006952188ec8a4839ad90c1d00fb68626cbb2a2610eb94dce02719134c791263f75a14eae4639c139ec2bb1f0ee567417fed35b012f4a0ef998f5b7e522287cb5207c4552564452ba73534e80cdd80f4e31eb3c4885ad1b68dc3a532f97886d70020d35bbca2fcf8fd4d8a87c441593f8be48b9d52c49087663afd5e27c066e3054b6cc2f3781ff3d4159b7c9e3af76aac02b47d1c50ea6237308c5c2e5b4fef394c5e72770b42f64fcc9197c0eda424778f54bc72fce63a2d037b73f91161b36e7603642cc98cd71b944108ac007df94ec9c1f5f547802399ce2df7aee6d2839c774909d5560b37f7a06c90f73da3dc558f0248ff22fd0c3a2aa1b32599b00907743d9ef0a48cfd80db4e9bec7e095ef7e7b75de884cee32f0c52ed1a49203a44e30117feb7a2e98e34bf60a2cedae32ef981c1bf8c21031f32acda3a6dc1586c365603d66b322c6c66c366fdb1890654dce1c28e61a7d552ef1e8db210300b4e0d41f540f652f9c2612685d977bff9b9ca38606485d8d31e441d5326dedd76693989acbc3d82805d38481b4b125dff20e61c9894373ad24c9963b04247938cfdf3f7b2d70810a083c0904c297d74af4f0acc401000c28e9c57d7c4a0f0f9d0ef4fcf1181fb284e5a00d1f48b55ba512a65ef593a5c40893ff8d953d7a3dca622154d96e22c85130cde67c2718c4a70312548abdbc0e66e45440bb2afcd53ccc2051b2df89edc48b8bc19a3831306a9ebc4b7bfaf7175ecf628adc47a4f0d129fa8546bb5c7ac25d2aaffb500f0d174e90231738ec4df885d13e04466f47be3b5f59d3578c18e18c0be16879070a8fa54beb111eac9979e2f1bc084debeacafe0b621e60d8a1e35c6ae90b8fd4bfc4a3c561dea3392e4dc3af23475fde02360fb1064212d1562aa07766c6694e24febed65de9fa3750341d0a4df6e8c01ae8e29b7f9e5c69c6d02189fa2f812831aff6d12baf2e5abe6fd4f4286775aaa1c271a65466f10efd50bfba98412d88fb7614399ed3b9e9f7ac46f81f6a65c6045669b7aaebe461345c6a352afc99d039259d79dbebd64d0fa9ee4d4a082092d8e7f48f35ffd8a8ff40e6d52cbde29a51be260f5183a9b9ccaeefcb914375c34d2aba79c78c4acb231db383a44db1c1d50ccaeccdbb00e9d9049e5cd613a80fdd887a38f4327c2c508c58d988b16e3dd6c6370f1e9aa27f7f7cad30c76cc59dfab2019ce3a5c84555acc1f993da1cdb725e6beba9859c019bf88f3dc58fdd50724677502123055975d58c05e7bd5182f8ad04f62714cde61fd9c63de5b3ff9c5e5f6884aa5ff9335bc63931436a180a0586a0343cc02076dac1350aec3b004ebc2028e95fe1aff886bbfc778216bc06cf7925a584fe61e8ea718b9495da37ec626775208b659a7865e650f5e7e9ba8bedd2bac9878feda45f0cd493efde4f0a0e55f3d6feb76043588896e30f79999fa656b69644c213f1a96dc871ed8c97380ca1b6e96bcfde2ee24fe8add26588e729ecaa554e1ca45da8f38a1b0783f17c6d2cf3d635dec56e58ad832f775086b30dc2d6a352076166350dbb2bcec4bf6f2a6440081505336f595bb4a96e9993eeb74b351525c76790d705d276fb0c93caf2df772d16f685bd554162da17ea80c86b31f17a5a99e80ef5a2dd2b7fa5002efe28dc8477cca86a830325562b8e2197cf04cbee2deae5ad38e35e07edc4ef30db2c5aa5abe12552847c62866cd78c9e13638ebbb98b41029a7470dc8b4c434a747be1d3891cf151975f34b957e99550c0643b38d386c753fcff550945db66c9052b005847150c209251ef9567899f44dbfb2c7718710ae86d279898e7f54e4e7bf53ee336e4c94815722d6336fbcaf5b9cd6573f380f95ae0a38dbc6647330c97140e74bd074386a7bd35807c69ff1c4612fbc6396118162c43746812dfe47360f4c0a9bee5fd634860d27fd4b5f2a203ce8c737fc084a8aae33691fddac5bb3d159b33d07eeeb801b19bf4c91f9af428a20e881835c69be0d5572922c7d564f07764d756ff280f07fd4373dee423dc99f9b3cf7d0a05e70326f8b2804c31492db57297c29f0d647144f3c30dd479284e7f84f4cbc34e40af0acd026ce2f203407f2543746a3dcdce5a4a3a746ecf2fdf1172af14658724b405cab48f9c6b0b6acd04983cb91918b6737ca4acbdac610427ca8e963aadb99909a6f26e0f4593201d6df6cf44050e0979f4479d2154ae15e406dbbca0cfe0321e183ed2b748170bba9ddbe3975ae9065a999d252324f820edc4ce0a925f27a483a04eedcbc886c5d583f05de577ea6d0d6424c069c8f5e615b01a551d499e4779a1faae37eeb8ff00d9b9f3dbd5efa0f48c7f232da6a251b4d77c27742807d84d1489331065e5d4977c006fecabc8a3cf17ac20a86f63be0ff80e258c18d16c58b1cd4be0dd7f86803234954a12cb8d8cc190cca743f63e91709c3ae2938423e4b5107214b28048e5e978ef7672e5ccb574df87a510f478cc47a6272012bae18058f9002e54c6836ab7d88c359624e5360c6fa9f52cf7266650cd0e210cfa38eea1f98534c45d0f2dd5302f699081c1e96cf49e88414b3b949dff5c28f0ee474f4bafa7d5ea368ac12f7532b89615e714401a326eb7a2f0245e356de6238ac4cad11c95afc8e112952495173037683afc83060e451b6b0aa29877991b7815f14a4a31bd4eea7803a37709243e91aaf90fef345674abc1917bcf3776708aef23638dfb9bb7ba5f1628a4a669c7c811b96e9d4eed8b66543535292c50d18d67de5e62ab88755cad0878496be25bb062fcd87381c85de432616751ec5e4be9502197dea3532b1e207945bef6f39edcd09551670f7665f7ac554270a55efa84da6497c47af792e87b93299eb3bbf7130dba77eefa455dde42673991136c4c305f25ce58b88d93968aff28214297ff9c2897dc2c74e0478eb59c4c8e2752031d966d7cfc11ef3eff7ddaa1bb9ba261a5b6e48300b55df0a4e3a68805eacff24be6e4b6da8af6c85bd9867cdca27da4506e362a8e32c44a37fd75dabedd688a208a08944bbc34ab5ad41bf8e5b793c19cc9260ba6caee337c4279c3da8f1da5d929dd19a13876dda6e5c6b82b66cc9807a499a105321d8bc2f3e9e00ff1dadc0499359f5c22ee8f298c794a579f873c4fbd733c0783a41f071b81ca9d6e559ca3fbd47646d2f668491113534589d407efcf5fba5034e21138dc5f0a827b9f449519da9eda02271881325e598d1b34ca0530a14eb0185c8d68d7aaa8541fee32a4dab5af4793f4a0fb84d36f41db2e2520d666c1ec0db07b33c3065795f396de3eaf0ce7514d3e5b89e51a91de7e5adfd057f48e2dc68089a6606e39e27a0f7ef7f0bba3a4368aa4c6a8ab7de531dfed862e6ef655d29d00971dd32f19cc9286327c60f5fa2ec88090a149f6f8470e90f14ee6cfacb73de6de1ce4e227ccfdf53ca5eae572ff08e9a072bca52ce8bd19c86f37e28bdd23ca0f18cc4c31dece4e274f5a233bbb2fdd9ce462c4746a2736188f1021f01d0a7cc872ec566c4db0a4e68c98e6c9faec623ad5123b0ae0dba9770f8b8854a95667f23f5877a81f4200e8031243f64c54ef8660e8dec8370e7b6f18e15924e4c694a5fd88f1b696ef81902973df93183a1b0d69f0aa2472048858b9eb5f2bca3d39c5334da731cb87c50def90c9eecb8626060fd7e9cb1cf32c3cdfdba62789105d47860f2a33dcf1b1a5794a4efba2aaf95e67ef2de4a99fdaad4b76b95f2e026bfa9fca2c4813bb4e010023c5d8df41d79cdab481b2e5f4070d990fe5bef03d9128a13089d8f93a240e45da51f02283b4f4d12652cf3a57ccdd683a78fe4beb500a32e9f693b5fdbff137b9d1d398580834910627e2f313284bc8ac0cbc1039864546b831b8a6f2e7bef4f275c55f6dba79a6d0eb0f7fe26ca5557c2cb8acb8146fb4fcdd01e95cfc6c0ebab69d2ca29c6ed965ef8c84e742525dced3c66ea0f38104ad97e39213f45a8d855f3ad40d2b6c8051fc302ca6cdc1a7b644ece64fb98e2d055faec4fdad3668804b35742312ed5d5a1dbf8f8d5765d11d6fb7af8dafbb634e9665786cd99886f28347421e3052ac52a4e367398ee24f444d290c5a4ca48fd02ade5863041bdceb905b574391aba2ce678eb4cd7dbbb4a4a8543e734da0b8c36d2d35249c6a21bb0be881874556cb90cb86cede0f3b29f215981587eb6910b396e81fff521566f4dbe2e132b8121007198594901396d7e4ecabf0d23fc45f729073db231506325ca8b9e227901ed972d7c4e17cbf4cf240f26c9bd840d1d48bc8d6fcbfcc911ecc41ce851f81dc0383b2f2b3bbec8e8b0834d97642e9180cc2df56fe2214a030773f92842d51a001c2761e35152065e1ac85815e5fe6abb99da1bacc227de01b8b4fe2d38d4c0c4183ed219b1f101fd19fe6421f1abceddd6b230ea151da9c0dea5cbc18c75c760fc054a1de8b3ad3414867e5ea27572a8af23afba2eec73e5ecc0df76f947ab5d5d3466c43dba33f18226caf6b5e044ecf6bda7d21a92ef814dc848a73c4bdac8714cabddb4beee9b4f0a99a83250f3c2bf7e12ede66b504a2f2c074c4c312e414ffa555fd9d4b08d6a546189f744353b9abc1f0c4ec7e7a290d4f2ee78e958f9cc8587b5cd38d3094185b63267f3d4eefcdbbbdaee7fa7ea26df73aeffa9e2227316f07709831ec48eb694700be4a2af59728eb2a60f2fcd116e9cde495f63846ed48612b74910c9dbb2ebfe3db0c969908128dd851f1162f19e3952cd46110272a0959ff4d52c2623881e5f341fecb11aff7614f9bc1943113e282537fa9c03503de61f05687f457ef93bfec99650b2b7a3ddb64c9d42537df1da809cbdcc5a47c28b0c1536fc962b6c01ee673b1a250587e8b64f798d27ec7fe03a923041ee28855ec544b6ac59dff90362e6ce2103aba9d4375379aa28c6ae2612c02cc1a8cf097ca18fcc22fce9f98e3f993b4754d3bbd0b16c3f30a8e92985d6c36f6b58538c4f974c345245c0820256010755f3d43fb30433cfcaf860bebd1ffdfc9955bc81fa8d4f0c7ab869056ce69be857aa6a38e86c6b620ceb9442301e4d1d3ecb861a8b6774197216ea16a5774603d59a02f635ae78d6f6ec6823964878721b8bbc5b305355dd6eb4eaccee1847a0eb7dd24ed0c1ac16c30cd5009976101c2d864ee54fa3804942ba71bbeae91ea8027febbcb80dbe4979b6ebb388756960e5b95bb034c1a67a2a294c17c80c1c9c15aa436e5cbe52c6f7e02cee59f1edce1a4517981d10ea77a40145f668d6213542fbfa1412c4b4792142c1b9cfc80538034a628ce6163f7a4f53c8c8759790dace69958e8558473bd3bdc542d7c85c15779ad6efb1441692f4ab7a509387727b351749ae681fae5adb135ced86b3e51a36803298b42cdd93dc20932ac9002ba470ede5c56484663876a42c771814182d84c88e456898227d685935edc299b334d837a27fb09fd329773ef9d370b411b37da151ae2433b5c8fcfbaa21eb45e5aa955bf538fb6783ba36dfd50768fd4a38c8e44ddaf17c7af856f3694cfcc16498669b75457ed145ae0e68df9f5f99d633cdec0432e4c4fde6a228178ed5800ff7dbf387ece569739b082e03d8009bcd5912e1f9a1074a950f1172f301db6b4716e98762fd08d2a2a7193c93645a1319325cb8d2ae41ea38e30a229fc3e436595b71aab0a6ac37fee17082fb13899e0c2ba359de80727ac2cb8619794696af2dce75cafc005a4725617469c2a2ad1f4fac98d042d928fb7d607f12e6b3a158726ab69c34a8979bb63f686417a892d1e2e472586df04488f24eb2be38bd2f36cbc9c20f89347c6a8155b010a4e175afe13fe7cab31d5d1c5f13e5f03536d5baffcc0fb677b0682dfdc44d0aa60492f8cb4a49edd211a271269e2008b40be83b2de31893611f091e073f6aa06c1f8ba8f99cbcb65eb1acf8da51b4dea24ace9c489525722c89ab1a9f1361320392eac6016a74a8e8d4e49be0c405515a6961f8e91637f5e19ac3d31a334f469488f22eefd7887db38e58fe8927559f0d9e133687bf2aa4f80afebd559d0b4a00727d8ca15b83aaa0ab0759f15d2d3180fff0c92eb822babc641f2f3560456531f354c8da70b1bd99fcb09d189ec5c077d13a1691139faa443ecc42f625d7e3b3ded32882dc0117549ac529aa0732333c0919d4974d94b8a94b16d81b7b19b413f9521dc2ef63174e753ad730f981c2355045c7bb167e03c23ae6112dbe8677df04f937aaaf6936c7226eb1dabd58aabc93364c70d17e6be77d63fa9561ae6a90e95f4af4a2fcece3cc8d5b1e5b6b74ae9ee4875e8c6b4597fe2a4e113f4038fe7ffce9e4afe28b22de15533e8ba5569db89c5225787cd203c82367adb8161743ac3e0ea7d85d9fd1e2320604af3f3ec5600e564f206209ace5ed7bb399149c626e1403c15cc1e1ea73781812737e6a35df5650782a1d096cd1ec07b05da2091305876c7a52b806deab62ba90fc8c24ea2d40748bc4bd18ee1532004a0fd7e579734a1dae35cb21558877da09d41956ce014d2ae792196b6dc98e3fab34354910c6ffe24fdf579553ef45c92e96983fcf6b31887a2f609f13cecc1ecf39e8fceed976738d36a3b4d33766b86ed5690ff086fb11627c642024d4a789deaff797ba8e6fb3c8f1d4dbc34d2989766fcec8e267a826b1d6813cfb1f092c1c58bb02a958b539a6393153e3d3577bea62ff4d85789f8e557837c9d916cddbff52f12d0831f9d251ba7aa5f8fc870161a5a17112a746b2584697b56512677c24b0575ed0f060255ce06d3d00dd45261234fe5ca7e52817c4ace101517c92e0758bec8899aab4845209bb1106ab4c444f26c41623fd3e179d80981a1d3eb083f31fc7c55362c29bf970f520617a79f46d23dd5f2e403df57bbb7dc6b27b879074fab90eb6f1f7d189a62509117062dae305c62202329e916c05318b3002d1b4081246a5f3185874e3dec30a73bf92071fb28a70f889873dbec5de0b38234dc3cb730de1ba4b21899cb8ae40b4d96932f189cb9f0f5ea7302aeba69127e03a96c6510b3db200d9a39582ca2685863fee844d52fb9f1876ca66e716496ab80257f9b424e9a839dd317449bdc54ebb7948ec98519e9c28a16968353b1d8c1bb0dd6731157b99f0d461d817d8f196d367531c19139eee43379dbc39017ee1d455c27ad67aa5adb422271a4eeb1ffb7b7340eca81dffafcf35d190dfdc1c48c25e5bd21cd58a8b9674cd6b605ac6b0ca9d462203ddb6c5de4075249a33949ba5f2d9c7b50f79766a9666c8283f6943295976bef8e7069706bdcd21ce77122e820b33ab85877696a989e9578fb4df413281c4d61be4fe1957f407cef614755f68786ce07fb4009f429fcc5db354d246c41561539895005349ab091c147c386ca858bd510c090e674349980ddd2b0665851ccaab71867eb3931adee5ae1ce4ca826a357a559667a1a9fd41f3421c91af9b4e0bb05d4b54037d87f94156568308eb9a922490957cda8469dde9cc7e5b3b14f459e2601e83e2a6066a06a232d7b14bfd2b1cc6a9c03d8e3e7c16c803d7ebd03a48232bb052c9ff96573fbb9146afbcab13ad3f3108bb6ddec13c8f7f5e2f3cf28d548b2fad2ef8149fd405359a457cb6190a0a1a5aca9d1f3e4230fc7d974e5c4137455d420bed465b86f3cf7bfe60aa58790872bc07bd7bf49ff13f3074d31d04c25279c505bc3ffdc62bdbaa384bf338ca45a0d6d1103eb955bcaafb4aa0278e42f0023e18b265f5ba273fb2ecc483884ea313e723c16392d0f8fee6b809c65d322d9e96347c0b2edb61fa2eb171cd0982515f9a0cf0dffefb6aec24e03cacf74e5a10ecc0077c83150e35c7b96dbd535ab16c5818e769c3d2a8177abfb4e8224aaa2f16b3ef2192ae107315f150deafe429b542c34d829a481965e1cf70956674a45a705631bf3c571c5748f6760c6883e9f9a3408f0c6cba020beeba29d2728300bfa034f9464a75d35624421ade5df32153d370cfc57752797890b35d8a69717c7d12c7f2007e3e7828c285f63cc42c050c634ae20ba548b519a4fb5d52bbd739e624b0a876584301261f342111f7619db6a7577c35f1a2de75888be7a28bd4f61d542","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
