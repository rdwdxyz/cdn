<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"21dd27b47331f514656ab879d18c8297534b0412b3987149482759a07555c2cb7968be068fe81e113b7db735503d198b705876740cf0991c00f3cf73c52fe0161004d64eda90ea31c5a1c34617b059c5ce61eafcdf87689b49339f485b5d8fac695e1689b4fd6dc6e4b374eb8a317e83ac8d923769e4a6dfda32c0a0bb3de299fcd9e3f955638ef9dab9d15761a1a90268092799cddcd2ecab51b656fc6ecd06b6588a7c6e33f249974c7e511dbb48a76206419e3c2ccd5b824a7fdd88afe9115d9e3c3aca0ac6b55d56399435753595ec5681435950b21456f2cfcbab462d5c83855250d03751e65bdcadb4412e4c16ecef29fec1629ff5963d4bc0894ed68c5dd42d40f1ea125d856897c968e450964a307429fe1ffffdd0e3c1e6776556cbcb2fd90b944790a28a378c6a0bdee99301852879199ad85ce8d0555a3fc22c69422d24d0e29403040c8752c645e0561105747d5515936c6919673e6d50738728599d3149eb2809c9294a45c3f275bdac6b35a69613578ce1b26f676dcd4e29ade6bda511055c76f2e06a441786989b3d03f9919ac2b2f2d1b43d54c3b138b174f07e27db55c51301617b86543e524983212ba68e6e3d8d2f00dc3bcdb2631b1bd697cb14a66da9b5788e1fd5fb75af7940fe362888a31b740e2b9537b343c34c3053990cc2296ce293184273e33adf6656cfde90171394eebd2235021318e19bbab71831c394d590575306bda82e144c9528cd748f81d2056624624e387d35cca3a4b323871aa29ef1ec6dbace42498c19055b16d7e90ff03a3bf4fd946ea6138eb29084988bf404d3be104d092f21e9bc3aed11d10f878437f277549213ecb87aa88cd39072f168b648f042f8929514972acf933993d229abaa8b65514706c4c3b47f4ff120a1a3ed85c27ddb37454e20f546e54f31868af3f31be95ec224434b903b1e6aa830ebd404c52b648e4e015194df6ed5f5125b466398f32577d7e7e429b0263056e4e6302cc03c91956e458ff07a00c2f46310a09ea050c6672f8316b3e7529c267e0f21d7908f5723003d464e300d360bdde56b1121f800bb96ce4611f93920d66307c024b1da9783844b00c99e690fddbc35e767381d0b420b5e86c79d1e70ee178f949f59d79009a27cfc588d6cdd86113ed702df707703de68ef14fe47c867f2f6dedf5690c7683d9a0632d90fcf30de8a95923dfba2d0c9fee3afdd285d804f702100b0e0c0675097cceb025a44de7e26d1339e986ea3c497c6f3629eb30daa640fb6fed94ac7ce8e19999fb71a7fd34c1e4c1373a4315b460452167760645b8f389ca0c45a42a4c52cd6e8283004267152530f570323e136e67e0dff7c14c44bce7103e3046bbd9a586ffea5fd2a9cc57200a7a074f0bc21b9b2195493a047bd5ce876013fb53d93da652b396b06b56738595a121ff8e12bea08334ab0e441c78401eb080e38c541a367d1aa17a6a07aa768349f61e658af6029e5d519cb7af25ded48f7489df69edfc9c4814ca76b6cb0c47d1282cb1cb24ae174a148c96f4249c37689718b6b5245216f42af7c7e3fb2044e5348b4d1400798c35664ababb43a9cb29b45d8cd1c48eef912f2510fb878479f99cbcf1d777cba4d7925551a96e88184d2434b9e8143c88e6274ece31fa9b19999cacc23c7276313c68d2004473efc55eb573ed77bfafdd08393e3951e24223b5c60461c7af7b2322f1d7f263ff44caf140d424ad9c58db32a75992409ebdeb2bacfd0005d2500a86e3b16077320c3534504457fc95057fbab0462edf4de781d70a8ce91bec00077ce78d90ee89e29a0d5394e81b21ad6a1bdac245d8ff86a1d5cff2eaf55e2a779618bbfc3cc6b1282c69c90e66141c8fb18fe9bf691835a8745d2a047306c712ee9810c6e83e5b1e83d740ee1cff67c80e68a7a2ae7b1bffdd8b5964f19965e54b2eef4a2f07b46dc8534f72d6540aaf74ca495f416ea7847b9942219accf17a7ecdf32e93c8004951b335b169c2f3decc84a7eed662f7d6d47a7278536a89d3ef0d5d689e1a639eb44f1026c968368c2b16edde27288033cbb5e8cc3ac37031714650a1079dcb9634c78e6ccd2788e74600b67ec6a791c96824955938581188f354aebff9bb0f624ffc9abd7831d246bb92de6e6304a77db5e65f7014b7e7360f22e70817d1f9b328e37832b0ea1bbbdad6b01826f7f7af4aa5e3b7a4f63a5d2135058b0a9b74755ee6b8ff03c6f2604f68896fe9270ea729a0bc926f3a73c54b64625e8466c57150069a5d6775c7b30fc23f3d4341e1f69a096bdc41307f22dff057d119b287a44d06f3b1510f16be9c4f14857dc85c319db6e1aa66d3e7a76398459dde00e66ed479c6ec2cbd3b6f7114b916190f222dd94a904e01450e529a06c6483c8aa5d60dd8ac0f5762411e3bd79cc3f55f5cbfad4a442e652901ad662d2b350bbbf10ffe97e90c14b02f67c53fbf670fddb5026b48cdca69d462a068b858b3bb0061d7dcb6e59707cfcdd4625c0b050a51cfda56b14f453d76f2b6326e8216426a7c596c471b6ec4c1cd154f026d950fc0ce8458c452fc90c4226d291598675a6047de55d93d1f6dac1e4a02bec5e30e53125db43b27f328e2592318624394a35d8e474fe2f558fd2da661d956fd496fccf094ee8380661b5c73280f02eff0d46b3a74165d3c6a4f396f1815bf97b13a6a4d95c2799e0c6eddd361b27ed1cb88141963a8fa5fc10df093c92663b1e418f7d9992091d57f0ccc6584004e4faec064cc5d54ab2ce8e6449cbdcb2329e6635f290588bed7d521bb6e0036433e052f5cab52711751fa14b0289e7bf233bb76320a17bc95f5d8438cfc5d136aa3772604eb7e3c3ea688eee018e0c0eeea91202c3085b93e000318ccc2a11599e4d7f2493a9d25875f36ee54ffabd07ee6ac86f45547ad1b9225e0f7cbeb4f5bc1cb973bedb747c483c027572e810835745087943beacff72bcb01c538993cfcd96cb45547b7e2d81331a814ece22fd3e4422fd2487db07611b25f63960a270705f67dce1f961a2b8745d4fc36b0dcc6108a3fb4188b3c7aff7f734d299d3370e64e149392f65ba5222214953880b8d5b2131c87bd24918975c5c7d5fc539da0882cafa37e73397f8f5751bdf79a135c738da7aaf804a1fffcf980ccfbc088a3fb262cc43c5495b9219a63fcc1de9a6981e9bc421eb88ab52d205ce92a79971a7670cafa7ce365c0d85cae95c12583754c698cdc9ec9915487f8cd921fc105cce0f62ea19997dc0320a47b29181dc2f385ec4fff20bdfdc2157f606b8f88dc32bbcdd2d14e18ecca7ee0b09ebec9890efc2c0e6752848fe17d69f9ee0fe115220a38d50c6a9ee197f09e1903f62e48e31ef47327f5983ed38fde8555bbb9171533c7ca43bf13435cd25892fc7bc1a6391f6a3050bc42fdc9936809919e1556fe39f3dac00306312ca584952a0f8872a3eb2f831edbfd62ebc040133b44abe60db295ae3d75028996f427305be8855a1009657c14201623341ca7c9cf251203aab19a45c21296a383e8aa6c3e1b92b2757f70b831210e282d7c68a75abb98a7a79496e965ac314ee4faae81b10302957066c8b67486ecca4e32613a0452487fe498218be05f1538e6c30d528b65e4f17aac7f72dd3d854528bf5ca04442153adf6e32d334d1c092771a587b8f6a2bdc7d94cb27a76a07023f20e510f068251ef161c9ca5768c6f3b7b39f0dbad9e6cae9f629082178ca0e95656d5eaf3fed319046d53bf8c5a84ecc5ce30db342c0392e1e62780c01d111785114a8fd8f283257396288ed2b8bb90fd0db5e185fc2d6127609b5739cf4919e4a73890c6977d245f905bb519d0cc52a087367ea993277cdfa8d9be37c662174543f5cd572e11cf8a1bc9fbbcfd07d95abf4791aeb5e6931b7acbcb3197845b1c4fe4ebb3efe2f55c6a416094861438aa3edfb1c29bb638ec6b5b8b40d96c5b17404ea86429baeade75e3bc076573a62632099c13345155bf5588b402174104e8107a6b442b77c73474e2b7a6b208fae4400c2b517f96cda5d264a9318bf283f2c97ceaefab4d3aa20d60b86e4aef9256bc5c69c3b82de9e0cdc67cf44c3bac8aa5c795b9c3d15f0d1423325798f1b5eb68faa08322d8ad49cd77ca4630fd38fb8a2e48ea92d59ae3218225967744236f6edf7e3d4c52b555ca89b7295dd4ea77a04e4c27d0d9252c773bcec7157d0cb19fac15d757bb14469e1e7ae40f1b4a5dd721136c583f57869a67643ed78069c7cf536ee7cbd3e5da3e5b7d38caffc7e7df39605f67b3b1cf0d323abc9d56c26903bd3980ba8f4d960d53ec42b618f455beb97ac24b6a9bc980648d03e3225b25bd3f2141face3161b7805573990c4fe838a55ff6c19895f5b0d44bcb675bc52ef105aba51587d0a382369315d4773b2673223f9daee035a947a6c469ffaa2e47e900f1747fa5aed23dd3e9f1192a1a2240bd547c618accd9a5c8e3f6d9739b59e2ffdc7b4acdf93c1846b5c846f569ff8688da9d4f5f08d51909ec5d781fd0eee31a35500e46b3ceb9b48f30be8ae43eb5445127e811426461cd45e377285eab72e5c8d0d749eb2996cc978e2ad2a38e48207132c164d9790ee2672e4b089c2284be1c5b63566227f78adb4e38b21fce126bf7e612c180b651d5ef1c3c8303ab14bb693d969fef9f3d8dd5fabf5b1573a123ac7aea01b55d26b5ddf2d015accff416912f1379af442aa5e07945303db265b3f0421b1e0c34831f8ffa29eba7ac85b142e884acabe3514b5f0b40f2ebd4e0b0d9ff4a40a967743c9c62626f621547aa027a5f48e9771ba8958f07dad0ad31a89ccb669275ca5bb17454f657b9860e52abbce0326508d2604fd0d31b6a7ef40f793b731ea73e91c292f15d26d64e7a31d247dc3cbfab5c0c4ad06b08116507313dae120d8739eb3ff3d8787e34a3db2349add2752741acffe2e75687d3cef0d374eef85dd90e43efbc4380267a8260bafb5295b8a5227d50b990680ca9d0872f06d86c5b05d210b84ba7ae891751e02d0545e75d135f943f0fd598eda155266efeb52ab02c935f31c3efd1e2340fb5d49d920517547261f5da91b7f453ed206a2616afd44911f706ebae74626f60bc50da8b3071c5fd488108f96470f84a58e25fa023fd0f045cb120b87d62c7a467dfb2bc9c44529cb944ca431409a776fa492627298b643bb49ef98733a64a94328db363cabcf7c81e0d4d57299d19dd8f7e6f3bbebac33cc66f3c738f56d04927f305d321351d8f947b811841252ef06df3414d26c4d953df47b23c649b45a61d4600696a702da5bd642517de2002466799d405cbb3d83cf623c84ea15ee06c684ca321f92097bf7644a994058f904aaf5417165f4311bd7d535eb957d2e5a4f5d414cb6fbe6d9fe668014836b3fee479315006b3310f50f63b1361d7fad42c2efcfb11d6aba990faffbe77d3cf1bb85e89e5ce75294300b6123a21a06a7f895239b9c9b30b410f8b1efb348f33e12b9c3213534d30363a8cbcd6b1f57e17138e66625878fe1f8533d6978de5dd5a4cbca248d757a0835db18060779c6388034b1722c2eb55d63c25286c46137a90d12a431d074ec697d911940194dd38654aa8c6a6a743cfccaa120c9d8895857daa161d36bb8381fc634f3ffd450d8e5863de7c351be7a1968ccf9b30a8a5519cf9a1f977bdce5096bf4676d790af87bc1bb6a5a2f487d54c15c137a74f6e0bda75e757760e03278925fc17655f598db0b8c816fdca64468a425cf41bd417093d37d3ce396b7134faba64ea62b6a30329329c605fc63b75e4c99648a5c2378cd9ad7f65e458f1ecaf1f49b28b9cbfb29851f5e376e66fe8a0a06dbadf6c26f36a533a763682d2f75adb7fb258faa6a6f20346dd1b314d5f607749b195ae94bf356da33be0046022bc4378faeaf978ad25e4f8288735a730cd40296b517259f60288fbc474e4976ab8393577084ca8b92cf5113c4f8d0449811ae963c62996c48032e427d6fc8b1edf0fdea6fa93c41c445f6bdce56a6b49de9374e8d1d83925cf02ef169bcd7057f48278cc33275f17fe1817a15beb200c52c1c989801363c391eab1261053ceb95e837a3551320903f7a31ae3062507475c1d90b59c41be6e345b81f2e5e9606ec379867f883172abcf567acf58b6aa5160b65de32a023c160c3003ec7ab2d19a32dbdec8b86bba4e86782758f82afa43f031bfd0f615ef01330150b90881aaf39b2b4908a700d5d2e13968eb1464a4412a15ab6aae873f0fc3c3c801a111868bd272c9e169fd683a827ba7f9e078fd3493c396e8210b431cf3436e151889322fdb3dc296ecc33acbef8598c7d4d7c02469b8e5eb81f851d5531409c8c9b15f1d84cd8276c7f3df0953aca92387eb03795a315eca513479cda1184d8849b2019c3b9188d8abe67212004bafdbd8135ec36f94cc0365e3e80f6b4731d4ca5c95e2c214425c470ed331834219ca33616e71fe490411f794710c6163eadf31787cb61081ab0454a41f9c7deda745bdf66763a15b2421d8316e49c473ef4bd9ca414ae2a38160440894ae8b48af2df12a7658295c9ec2035637fc4b6c1e5ee41626666943260c4ae99d6bfdd842c8355f0497f054dd5899bf3be0472b2c7e9e866c54e96c5ab550650fd97a285ff48b0a1c1e4402487e4c6b3ae9ba4b8b6e9697c8764d7cfe7451210907170e5e596ad39248c5a49f629d84c760cfdc2f56484414f68d03ecd9ab829963c8b6f1734dfce0c30b083db2c3f3b911ec997b9310cb384e980a545d338696c8dc0672530542234b0affec6f56d8ee61c927230d83e71e8ffb2ca692593bb7bbf5e2019b1422f5c3406c3ecb486990124e5cb29ab4cbac49874cbbc769d7e0b4c5121a1db5303044b5fd9f3a08a67e5cc15880fca62ea488cca7dff4a50036088a9dad4494c2c3b78e3005d4e775505304f3d4714f234d955430b1c4633f7d7c5efbe9ca6dff26aafed155f47ecd9f911a372083febdae747f37cae32c1f430fc07a00b9975706e6b4860a8a5d40d66bc48ef57aacb8eec770e2c726d0d54d5af5736a26a525801e56e504db969d840f8ba3bb4c7af413ccb616776eaa4bbb1c512407b798ebad67c296225330b40c4db56ec172abc872ffdede38f741d353f64963f92bba3d0518c22fae10c1aca6a7d34ae648a6cdae967688df778ce2b43fdcdef0ae3c804a9929131db1633b8d13e3ddf4c2a535ec72ad1d069b8e68f6349efc5e79bd2f03fd3485c26aac6cd1b2b09537ec194f811e5c1a3ee323347b440154b2cdcf979c7887fbf8ceb483db37824e7fa35e26fbfc53cdc08ec6fbfca1b3f13cf45b9ce400b46a771202a77ba954deb0626a5845979fbd2049111241039a8c325e7ba484981e4a905a44d4b817b600905680828efe561c4afa0a3d096a8476684d657d0cb0b861ecc84318fdc85513eb7bb13d302a74b78ecb3dc2849bb47bbb6515fd3d1d43ce3887e261483dc3b4d4ff393320109ada1ef10f51d0d56bbf778daae6be71451e76b0df2285ee61b44545e1fd92a7926d68e5a35e429915cbdfe3407b7b85b801b203ce82c725e313813b10d09bce660375bd9423b46e14c1886b42bada531764ea2bec700f77382aff34dcc291504c768594ccf35c9a7154cd96ee4acb1fb7d1aff4089ee31aa92cc317f82f03f65534024abcfd49d1dfb837ab994ea67c90228b556bf78e7d960636b7eac2f0ddde266460ea797f368c6db73dbb00c3623d27c95cb9f36cdc483425ecca35e14a9e9eb9a9fb20d132343999bd81afb03fc6eed93a5d45975878e696a52384fcaedd4b9952a5cb6054cc2a81c43d1ab5b3257289eae66296bbcef05bcf7e997d46b26f985cd84091c15767eea673c4530b9dd9a143033d8987d42c113839a35eb24312ebcdc3d77d4a7b6ed617aedb5c2f447a8e21a333a428ec4468a83d87fb0d38bd1ba2c6ee52ad2b83f7020fe7a244adafeba773e0f173c20eee150555f421a11d9d7a8c4cc5201d9a0ba25786ad79644ff48f962aefe29505bb0e6dc44751e810b6520d95fc7ac404d963bb842577c5e623f15aa24954fba8b94e32fa311b6e0766ce5d0729dc5d49ef9a18b6ead8f50cc33b0809fac7a06a383a8b6406b85ef8c5482fee97cac15024200b1d5b40992d3b1e1486f4c50d93cc5e5ec563abc7268eea5aedc5feaa210cf5831d82a73afd98050a3a9bf886282129f767e4fd4bf9b315e10cff5e194f8fbdbd8ff9f1c10168309b3a77cfca4eeb082deaf6af33ad468471b789a279ad5328d508837aafc9bcc88df2f299b1d374f0949ef61e38e03006bef38e55a354fff103205c6793751d2b0cd2e087ec6890722d24a29a7ef8a2389ca1d2cf8a98fb5a4ca0ddc52cbbdc604886515a4db8b471c2617f1dba443e17114586ede981fa2254fb915790ebc402fa4e972503cdc369748f2db64c7b648455fac86ba99028ba3d0eb2de294038902c8322fead84734d5f22ca089fcb8300b557adf7f31a371b4dd253125f0943ab4e3a8a7c9cf52683e384804d3284ca57f55bf20f4ee0722e813e65cf9b3d5fc331704ca1cd705877f6d2ad81cdf1217d9e998bcc090425cbbd247d2c22a7d56a6a554bfd33ce843fc60e1a1965b53a5d5169c7b4266c322ae2796c6b92ce94a31b4bb280bdcd0d8c0f0b225d79c88eff267bd126ae44d6aac4adc4611c929366c90f89b813bd42bc12b4f171be39ab98b76d2966660612529094d7eb69d54985f499903b81ae19ee6539d17fb253b5d42305b35b4f59ad196ed27fd170f436602246368e0e7c806cf2493ecc77388558e8b1b3211fac67221600e28c7644331f81360404c19ad2c193aa10ee6a58cda9d0b3552fe4ae555cc3a758c19dee8342087263b15b12e8c971039fc2766694cea3c13d5ed9b9f32d07cd4020dd42ca0ce3df8db0ae72f0131cfbec68585bdbfc510b0fedda70a0db229b3a333d03f493ae6e897f74a50cd7e58414617aca9896367c72f410be47e858f26d468e8ebdb77c6fcb5656efdd48688137b5d2544fa1b13e991b22c3814ebf0b2b4160f1da4f212a89b363f6462d8f00706030fbbc0f1c905dd4d84b52e7a97b895b9fa1939b0ba4509f495a60caa8b6d8020d93bb740cc22cb5860d6d848cb82ed41e90e1bfb0d84119246cc6445d5780338f96c76978576a356da015601138f7a3dea85866635e2aa2d39fc570b5c684689ed7a73b9779708049e3113f04071fa12e33da8e6323f93384181f4351728ad9ac64412b4ee310a6fd98ae7397b63ac522017d16ff54f8b2566a4ded982170a8aefc4d6b8f080e26763c295875950b15ee9560926316373833078668a3fa3a41459dad5d80e5960744a44da4fd8c056215e7c813a4249d5a7c3c043370ca76c0c719d54d2dc5357e5853a9f2f322ff655a81578510c2d94bead8a70fd917885edadf8154b1531a3dff6b6d21623f6cf0fb86e3c03edd6322b39b06de889e792c2019e187ca94a52178e14fe5146c119051d48a49ce37ae1311bde9393132c3a1c751c7083d6c2d0b3f54827b1995482d3f3c492d47c54515c5aed68f998d5d735c5b5a3abb43bc1a009de8101583774c1cda230da6941d6a2293d379a59434f5d32c8e3f1d8636dfae86b348cd152f3a119ae2ca9fa4e529aad0ec05380ceb7166cacf5bfd29135986e181994f7064cc7ec9f5d9d9216d8eb32a38b530a8ee586aa400a183c933d379bc44fae630824400d3493a5a14f9d224cddefd9a32521c5fe108042510cb8bfb0947bcc75b235941be41e0f945a8a05dd5e37cae31340de9d718a851723f367fb9f9dba9b5b2c24ae4f91bfb3b48772356ef14be24fdc4a72e545c3f17075b553d1f7db85cd2b3e2ac030eee630387f5b9b3ba14ecbd0253920d2ece614b4b8cae786dcd4748e599ee6b38be7de0d0787fabcd96c46d2bb2ebeb143155126ee93d3dd2f16431beb1e6d3426b0845093668da7677e683f8a52aba4d35189c4df1371f25b453fcff8a9bea8a8ed602475b249b82108aee83144eb57b1be57279facebcaaacd5ca949c708fcf9a8e4e76bd09ab45693d08a62b7a1643624d9ea7cf98eef867389cff4443eecc70b74555929381efe3aa0832ba1b1eef24835f642c64b8bdab4caf6cd00585cdb3f3ce5b7ee4ad90085e881f438ea7daacaae6373ebf56abd6d6949dc11e5febcfccf3509fa8235dd24b7c6006273874b68717dd722412ec21322b2a531f124a37341c5967df670bbd858c197ec248df4771e7713bfcb1629342cb150216b86e4e61e0a725a7e957da65d0613c2a3adb50c1efe2b59622b84540f87d19591e736d1b8f2a1c7dd9b3e32f3840fadb76c21d8d3e7b1ddc7d869c3b6757097bbd1941105124c2a37a9e96cf5f3938028265f6be59d9d00906ef1e929480f2180a6407d91b9ef6d8aafea9db2267a1dfb660ce51b1272ad7a8d5220938768459097dd7eb10e9c45551b788219a171b60eab1b24356b2fd18e87df65c2474025b0594e39379358a023b86eceed391ab1d10118bdf8dcdb17f322b92ffaefe5089001699cc4817c442926ba09985cbfc99f5931ed7d98cf04f2409050d89745192f2ca3ec9fceb2e9f6732f1711b7e2d4dc04dab8f16bae27d7eebb0d50e99241f66b6bcb3e1dc27eec82572356d175487db80136506f06d7529b25b4357dd75b006caa0b1d8d37e01e2133cdb31b9a63d97c7da42b72762fabc192b63eb860053ffb1b421316bcae172c3ac3abaa72a3179fc3893a1d42c0a52bea5266877302b863cad3a83418b4724660938f85cd12bb1f3525635e17e6c7f584f315dcf825bca1f9069cfa21ea20a12e093d4ff1fecab947b7ee83d1ba5184f473c6ad1e0f35af4c488d7bcd7ea80f1c311572214c9ec0892c6cf713b6c61e1bd07fe9e7c687974e4b5408dba35de7bbfdd0a84f3856084431dbf5e060b57f715a16a9734a392e71800587bdb49148998c3c19c4bf679e42fdd20347bcd5c7772f1c7b4b756787f0ef2115b5a5df3d76dccbb8879dc30df3cad83448931afa196fda6d0c03bb8dc1fa472c9176853e55d49fbca498eba8811e20c30641dfdff94bac1022b5e0dc74ff431ed4433427d1bc19614fc8e2eb304aa72a31f012ae94c65e2ed10eb670ccc1fd927a4889f6710a0bf01df33065a06edc105c3d49b34af1bcecb4c5d80b8dd6cd2589e7d30fb88a52b1388eab2c3ae3a54f7dba6e5d2cfca23b2c58573118cd128ceffbddfb1755ac86cf4d4851c4fc10680a055b1ca0387febb6a6c8ee86159be7e5e234f085a1e9d965ca2c19d3ed2720a25aaf633d24eec068ed5954c4dc8466c6930747237bcfbb45b9fa7395b1b3d2a92557b0dee65a9f44fc406da3a42573e27d395b383c4408500604d36213cd513a9083d429883bbc98d8bd317be4873a224114d0e300f18ae5e589ab1286602b2e0d280cc80ca0341412a2f7ba3fbe29b797a7cb90d22d6a8b288f22ba35643a380a0ca7c75466672d0a97e937887cad6a57663a24a3d1ab8694fb855f12371958dd3eda4f012097ad9fa552ecf0c06689fc27a2a3fb41286865651ea87c1159c24b52b7ca4e61978b2266ba121151c73cb869a988f483c62fc6e69fe728f210434e3c6bd842d7b09df907f39361c228efd948a773376d9b3689a08ec8f464b6555d063dfff38bc124ac4a50c4cba9db600e9ebd9c6b857fd0d49d488d9b7b4317f12b753d454e09eb5737b7a6c14ada629b45563a046e1cc03f0d5862773b04be90d6d2fdae6aaab83c02d91812e8878642e81d20ecf9e5a22d2f0ca1a3348d5d75f165c0455097f0700fa1056ec66ee07e37e435aae804d99d1d2e5f02a246cc142656b1be924991a0d5667944b61b9564a2eb2b49066b71f14a6a1792495ffa024bd3ffdad16db6e9a9d4620da22cc95db77520810a70d85fb711a7581120d418fd51ab036b09acb4f0c68265f5f2ba60529b1459909c0209ce18265897a6883f34f8ca556c4f166879dba881c9c926f99b49e7b00c43bbeea1bfce2e32c47dbdd1a5e7ec62599078df7f13c95f81822b6fb8676430d3114c49aa7304540897d674ada0c6ba892d492029e953a687d427055f53c2e7b1bad6eaee9c59aff95ad1032d200988fc0173289ddfd0e5599f21bdc5dd7b5e029d3c304a0ce63a06e0d309384b532910c4b3b483d9692f3d481f25f3989d3863b6005293572d05938d8e4508cd4cbed94027ea762c31df3f9242b941eb90baee65919af4733c0cbd4711247ca9ac5693468787dfbf183b84bbd7bd200399e2611ff5dbc55361e24efa7df985f75630b416f30d3edad542ac8a4f48486ef859406419461bb566623b30c33b094de47aed8d1a4bd0d766a5c4556a4a96e707b757ad048063e8e3b477b6cc6eb2942decdba3eebaba49e4699436e49ffb7adde1530cb93671ceb4548dcb804abef0c9319c8494956013a516c089beba57cbd72807cc618ffa2590ce50310cf7f87ccee9b3096154c5593b9203bf1734f435ee02ff219bdbc8bdb7889ee98c6020e2428e9e18834dbba5f706b38574f822ba517ad8892604b9e8a76ed6e4e0d5cbaecdcae4c3a715789cf1e8855a827e7fb539b264b89ed1dcc59779117e7f7ccc16f193a53721803996fd00e014010b3d9c8ddb87b0edfb97b12c6d649760eb32add254ad82b18f78294f85b0c62db905cd731747514342c524b50f68acff8247efc3a0396477d9834d683f10c61302966b935c7208b9a1961046fa497791b709b3b801a1f45f6bd85650700c5f817c94444130c8decf6dfd058112569de19fdd1d11d565976fd2343ef0e78115571dae72dd8c8074c9b60b68ab66070c155758df82cf679532a386a4e58ce0346ebc64a7cb73266a55c5f3f65ca967df45aded2a3d12676e7af8eff8a86d080cf251109688a8f9ca61652823c6a09eeaf0e4937a89cdafba03b2a227e003e8bef9ec6ffa192069ab40ede007b0cd613290c0dcdcd017f6bf13d2180293e4e865edfe96db4ded7e155022b6cd87952aec1e891d0199daad3837fd12e01aeb5dee72ffa0a39413ff843bd978ec5a027434338e54cd5bd38094f9b7b639b8a3fe45de8ee6fb2cbcb1b64d799c922f94cf347077b2075af02a27e5eb44db05609929fb496301fee898c96fdd240b8a870c98e249582f1519530de9dd849c088c2f108695949611e65a2b38644694f48b917f7bb133c08597db70b97edeecb410d1c0b003d445422c9fd93b8a1a0c8d358a2210cda1ab4c41b3b6d0b62c314bd551845159c09034bf8dcdac6d88ea306183077c2ceec6e75961ab84919628785df9db2f6ea082422b54599b0ab0339f77edd5431176d320b248f3137829d6c075fe43b605d1ef6530a453fa9b7c198defa71161fc9d8b60c5784952a66574d08450468ab06979b999ef9a6db50ff8cecf7bef5f4c2fd3fd80de82dc3b0650e33c32f13dd4f9c26755e51ec98f178be7147729199be77e55e343f65cca73bbdbe95b77a0ae5ffbe7b21fecc4c06cc4ce9a03358bc3a42dfda58bb59fae1a9eeefe0185a0e7fb52b6496399207e44f025fdcd2047e32e75c2310181532fd59b5494175c6aec4427c0f59ee2d41bd75dee308f948bfea99626667c908538a33a57fb4b20ac0953649ffdbc0cc572c24b376d037a611ed07ef8649730705e957ee35e626e5ed6ccc74177cdc9f0b376a228e8bf20b972745f829c9a18382b1af4b092a26054f5162b0851655a7ba165fb7ed9c519b56a6b606876a3c0523c881b2437e45a9aaf016c9d75ffa78527e1b3a513ac1a39b15af23094b099655eb6d12bbf1ea17f985c4a2ace061d9219940a967adb5ec776d840aad9a55085c065f339bd1c94fe2815760e723963863e062a178b293da06c50992de47c34c9edee2a181a6fa7b650f612bbec8afcc73a9001ff19024a55af6a1e9cf0d4a3b53471822cb6c4aecdd73d329f0b0184502e7a82977474944255c29cd60cb500131783b1589146b9bcb96c3183a31ee9b86d273c200b1d96a08cd94413b0fb243b53ebfca21b1354b0a4b5b2eb0d40db1842570b0b3ff2e777b4eda358a8204199c05f8dc7946b198c751d5cc0c5d3095e39406fead9c0578fec712d48d110b12c21f604282a0cc1bf13fecfad7a4ab7a23233bd9317f7a16a04524c6afb2e68dc47cc2d9cb92b7dee1a5363f850da90d6eff6af3ff24a69554f8a1b3086743b449df81c0aa3680df6153ce65f84f0b9fba4079a36bb6a22835c2d228f3d7e39715538cce1712c0952888382391326d9100003ccac8105ec5e28b79db52c3ac37712d2424a59cc40db22d21d5e648b29b67c3bc5f59ad2b52003225c8cad2f6a1aaaa73b46dc5379561de8d7a9c24cf7538ffb4ed4a6c5dbfd864da0160d9ce4d891ccd02dc1c2c5e3cf478427444d1fa8b00571701303712eb860a042c7261f54ac923e8538647d6dcb6ecc22ac83d64620d26527d652fd3c441cecb37fff5064c76f996e88788dea8bf8ed30c13784a6b9c9dd3cea0f581553b271d7f8718ce663685507ce9d0665077e953896b5edf812b8706fd1bdb94e3f19f4036c80c39926cb17aa165facce1f98944b9fbbd0d12b92873dead0c69388aa172d201c552a4707e545eb1efae874274ab0fbf68608eadc6d540b962931d4f99cf42f18b34ff97c3bc824bcbb1f7f54a89925f616bf5cf256489f2ce5f42908ab042eecc5aa18ef98eec7a6e6f21259a70bb2a7d441437f63b201c0295a2e32410e07f91d154c278ebe1f79b78306376f4cbc9ffc53039c30545df849606342bc171d0fa6b9955e265c6f69f6a2f967544eb4637b2ff6eea11d98c2d32f25916bb02c51440954302c9a6cc35c9ad3a2d32868542f265d1a1ffeb3fc13913013bbc119f9653ac48a1066370edba2529c5dc399b7f842b802b872f59d7acb28d31a3a990896d1dbbc8d854b0697c66b88fbaedc7d420271e83919f20f6982a8948de405d4694a1cc11475132251c235bf050eb51567747d697ea371af656310d6e835435121a83c17ee860a807492aaa362a40004591e94ad4845943e5c9c928190936413c184f28a18b578854405ff25d82bd19b02fedfbeae16161f3debb5833513139e45b4b64d92ff32b9fce7a0117e3c8648337b841ab0f150b80c44b5932f4bbf78668e0349bf4bf6a9381ed16d7f4859bfe9e9426adb33dac8f959f75318b0e9adcc6c57f7f11b0fa7b60adaa369cd2f3a2b22fd5c6af0ece482ca53a055e28a1ecf8e3c72fa193494dbc04609d2e1645413643e0727de1b46e52a7ec7d862df6c29e0557a7ad94a347844460e521ec5ebaeba65a3862a08122df4c37ab8b54e7a769d864629147e7e0fa84fe5e0c3ec439f24a10c65baaeb4d9d04631c47bd4bb5239450d7e2860489818bea13dec8bb88e74f99eceeebecee87dbc99892da12a44873a8253ee91390d33de67595c0810e251bf70650ccd3ea08e264b8bf8a4f35c12611dfaf1f5958799783d148ac9dd716479d995f34c4237a4d150b5a8ba33009bd0b1e1a9fbd2b2a283f53eeb18d95ead3baabc1402b40d732b5c9f9784d18e56f0a8a72cb051e8b7dd4efc36a311ee39f51b3d1904ab8e4f12437fd0def7e880fb6659d9dddf374200ced25e8bfc388f2098b169985ba2104511a30918d0a1f87093042c97f8fea2a846d7519a6aa94e02ece61533127d190e3a1506a06e7c8fb0ebc5180a709409e7f45be11af1c25df0f70b079d1a6750b3997cb03e71f0c57f41cf6ad7f99bb2bbb04051fc8da0ef70b23df99986f648b598c5739a74a0efb9070ec443e7b5a4c8a7649914954b5633535945e072f723b5f3af86c50211d4b2291b76d8d986835c06e13909d01f115efa6845fe09b9da77542fa44cfa38841c4edeaeeee9f3da880f1486035b9b8fc847f893073542f67b9bb9264f8055d09f2d90911473c8ef0618d1717780b43cc630eaf32aba8b765d2d517d19dda10b96fd51e7f31b0e900636ef30e8c55d8a7f780622d6b2694b7d19bed59238dda437599b37e71466e3aa3d858af4d3f4819cf7e840ba9aff526304fe280d1ab91e0015e2342fd2fe5591ef2926ce0ab670ff0962e0189ae9a9ddea295104402c0e4e5d5093baf36131208a8128bd0c67823b6757fa5d91cde6b409c3d98119c5263d51de32ad740bc22f0c81cdcfb4be3d3e3a76a85108c0b92673655f932a68cae910c5d225c5f8e3d45f35cf889789aa8823f64ceef73fa692a0fc6305c5fdf0c8dce36efd3530567ba1b22b478bcc90d20efccd00388eb0dd574c286bd84aeb048a7c6d1611a12dcfc208bc0c3b89c3d99dc67f0853ce983f2cfe8b7be3fa32ca832174f97b2231cd1d13b0ea73cfee1dcbdf295d0d9b2cf80f8319bf79840c7a530e88b98c422cd3650dcc3c5ce1bf227ab2f3c7a8e37d3c8f55bedabf4ebae881a4d132c30d0cb3d678501e7ac7ab66ad6f6ff0a46d8523180d1ff1a88d20391d7c8458ad71791ab0c1de9000a596851c34451147083d9990c8642007386cb12c86bb2ce166746564e423c9532f9d840ba08591520306bbed1a02048246be7359bd8894426ed70307bef9bed71fc6662f5d9c5cf228c24f43c32b8ffad81d4ec1e1c3653dca30ef997c882255ba61808b0cf16efd560856a8a936da8b64ae37386d212ed9cfa1211361678090a4d8eeb8392dba4ef2049be5937d116d201d04a91adda959353f586c78a564224292681d536eda9b499b0cc50a6b57f47d45fa8b386cc8498b19299fd1c299aa4bcdad11d2ad049097767a3edaa3c5b6fc08df0c13dcbd6eb0e0cb047560e8a857b7a24f29ff4337aee2cb084cd70b7c4a96f39470d8ce628a0e4f4edb61eafba92cb734472025c4ba7c6855363db14799b803be0acaf0089d5cb99714cfe07a5c2e18d6dece15cfabcc8cbeac25c5ab341403d73fd756bfd1fb1e91192243e731c39bd25510b1f57fe01170d73a373c00de567e7ca308ec5eeaba6a9d39bb3036c3d505b9ef9799f775ddc1cca3fab85e47840bc0cce5b9fab5d1c635ee29967897c0e2dba5ca7501d5943c09528c2f8df49d314e8bce5afa9be2eb3f4e056b6d0b994246ea783ce0d22c9ca2f73ec9e25227230d447fcbc34ce45a749c1e16b39287fe120a09fd40214f41464c1021a9421a5e09d8a619212d2b69e7dc60b9ff9b630b4d7f4b1001336d9f2b909bad50da12d7f5058190e145de9c0e76bfb0cb9cbd52a68a6639b04c9900d9312e6e407d988efc610faea64caaadcaa697f1e3a884dbc4e8469f366856186dd85a0c077baa644ad32e6efd45a331a8bd08ca5b153f01f3356d462ff68751276eb61ce291aea3c68494bcdfbd9d2c9ff2cabaa496b66cf2ab12d5c189f541bc424ab8b7bc7898062832919872db4b970315390c07bad6dba50178ea5b4eaf346f2a3c9f8b410827521ccf5c9230135a9b5038c7386873b76e66a078e914aaa12acc0862e5f9903a069a43ffdf25cfa127b8030d36a1c761596aaa4c97ac6ec23b4f5018b6747de1c9d9f47990b32dace6a03ee6d56d3aa50bef098422ad8b88445a45bad71c351f3a57d536ab5275cc6a477cce9d74d7258c9c1b5bd934b0a0779829dd3ce37fecbae2dd8ebc2fbc817f088f633b862cf451e6beb3a3726420ced709025b215dff021420bc2c1187fb90b346bc41a248c4d00f0097d57b5793f97941087fed57260da127ba385e7f8301cf82edacb4c2ad65ffcd7b69a6f94b11f36c6a8ef205cb943c67f1f188fbe540afab5d7223f7bd3d9b6eec9f6aba332c265d2c60637c40155a4ca83c586d938601c8e09a3b8788ef48d8e265a3fccfcc4b34cfc87365c922c5fe171c4aec702e09862cb5fb137e7d1429f9191a5ab42f7dfaa8035b057d79ee397cc199acc8bd80279cc3ea4da87cde8979b5042aefc4ad358f6dd6c389960ea0cf385075ddf2f2520bf2c200e60960ef3ec8974d17f8e1d3e4b78fb45c98e31dfa722576b33","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
