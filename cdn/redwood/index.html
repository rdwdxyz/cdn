<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2a7c746a3bf41ba168936ab3ddfeb3cd738c2b738ff8d9e4f1367c140aeb670bd909adb0d02dfd9e00de3c2516525fb43759092c3992e3fcfc7ffad4ae063d7aa15078b69c5e82b872c93204c0bb9b05e0885f1058b5507303a45cb8b39d1e79746c73cbe2311c42556530fc0641ce0a26e092b9c81d5e8cbcbe614ea8cb7dbd75f77f3c2b30468843747efc8eb138018ea82a6e5ec700134075e4dd7122b3121c2a63e6b4f8555db27547f8e8c1a5fa02fdb4191caf69161a520e49792e96031662859b9c2c985405f86fdf04f499011c684fb8de78cc341108d82d169cb2342f622279e9d42de98d4ac9ee6a0c0c573a04e88f433d7f733c29ffd73aff4239dc745d255350d11f893b999307eb6f5788c8a1850eca2a55fdecf1766628c7dd0efc661bdedad2bbeeaae70b56f5b6d869050cc9f4b8232630889c8a329b0b9844c4a25860abf93bb5e1ecd99d771a58f035a15584fb1f43b01cfac4d04504e50e34d353f21a4e1960393546f76ae3ad8f3c494241c6c2c0e985cc67c07667316ce361ef5a3991dad94b9f2a45cb559b6c8c9a17f892c93da1e63f3d0aec35062a589e09a25c89e01276040f5edd897be55450a5b21ecae71c242e435fabea309d204a03601cc8e1cdbf8bf6470937b5e8e5173b811c4021126587ac9324f58c64b120fa477a3da3183d1e0afba720ca4ce05e219e376b1534f6ad6cc0980467bfd87c3651cacf85475f75e98d6d74930dd724ed58dbc9839e343252b3c7ceb5fc0553c6cbfe098e0cf43f7a3a0b5eec211dd5f56ef882e8610d586f95d06771ef13575c352cf1195328ca5f27b19a0f5a19bd6c54b63ec096a7109dd8edb7937d5346575e562ac388eefd4c423bec4975436fc74861b63c368042def6ce054730e9f433350bd891990456ebd8b21c6aa242a52e00640879a6594863fec9bfe48cbc123106b5c002629255c254f349eac79071a00ef2a431b03859b6ae17cb528ffd2ffbd51b4635967ba3f7a717943301cb26c86a2ad926c38829a4969799a3e916e759a97e3b45d2539b8191d64a36a68e9a08584a97125272396b5a35b204f64b1d020641d79aff5cf4aa96fc93728f97b576eb9bda0ac74d904162a0f1c4ad6492fc6357939aca4a861ecbafde5d2b01f30fb8179c6a27dad9a1e1007b3ef6688bad31355ef8a510fcff8b910170d2a4fa6f71761b7566e4e97efb3fac006472f7ccd0aab46be499e3c9defdc81764bd79fa400b238e6bcd2bccc8822c7698c47389a89a21e5d153295f6d26e52262c72fa0a9eb56bf7b255b4cfbb84f7a724f1e54ba93b01363e63c60903db58f6f0f1891c17663c07596a41e02d559594bf26bfaddf12160b2673edf81ff6bcbbfd6eb051f301a74ef5d732455c8b8709527b92dc27e8515c4315734dfe1ef5793bf628e26006fb50061d27c6eb400718a03f41818ad33a250034f9c96ead7efed756b02601c7e80494485a8da5388e5aef6850815297d55641fc0e3b54eba42e69eed6d1263eb42b12c0dbcb6d7a18e0bcbf30dc86029407a3a223ecf2bcaa1874d00afc4a9d23304c02304dbbedcdc8f55caccd54d8c9b6f92582d941f5f0667dc177a6639576418180108bd96812307ab7aba1ca0c02a801cf7df1aed5a9b59f2b06757803b6fd47576154574618eb2708f75d5ae4585527c4235ee056805b2cbf384bd6e5e32032415287a37df490912b90bd0cb24b39677b39576da67fc9512002055e89918c394353776bb43c74ad324c52d77065e0977848f0983e05f0b3197d62c26ca0adeef8964bd8ee27463549e14c9e393d9c56139088587da44864176f0bad88c4a9695261479c4f8ac6068dbedc17254114aab82ae46e418dcee1c2911cf57f99a8819f56cd63f9ea75ed4f5ed09816a806b79acecfbe9074d31f11e471fdb1bbbad278f212ab66cb43f26d1a9e9e4b91bdc133738c7ac4948f4ca0ff68fdd10eea3d170ead27919f28bf2ddc934491663a91513b38d4ae19a82031afc5ccda2c69be40bd543e696b897c6b35bb9d9441cda94a92c1e50fedf331af90144d8efdae5bf726d0941e578a5bc0ae5621dc0cf812e8e7459a125da0cf918a9bb56f3b14e896c7d518d0242a80f90cbfdabc8ee77569aad053df2a7e1412ebf1ec074764ec6e070dc3fff1f6a9bdfcc12e699956b6b8cc5a771779c80674006b27ff87eb58abed5399974283637afdd75297023c25595290275f1a6c0dda1c71c6cbeb6ed3432f5f5bb6cafaad82983f121a64bb76c1247b2994114da728571d5f003e5c676c3ae312af4756c69bdf6fd2e7c1d256f20426c550648e8d8a8ee4b0668ea467465e883e01a9dea1ea9bce158b0280dd21f2c989f5d093148b390d968ecc7a56251c8786efd64946eb900123bee878da14d5ec104a49a8dcb1ae2288a2edf9db817cdd0f860de7ae166ee54ee502c08ae4e68e4d117feb23fd2cd3ea7661cfe304fae8c8db551385f1d9a9e32af3f543c1d9fd232467a0ea39ff45d9d1ed4f7d8d1da1433da993bc707886998071f856ebb654235f344384e289811ea6da5a9b077cb91976cd9abbf148ccb60ed85e7d96d426c71c4ebdeb17e41a9872eb99cfc6fdc6ae742880000013d42b36d90d1bd739a9862625dcd29aaf5327231906804f4d39e621863c97ccff49a799eca442ff568ec06cdae4512b48ac6b09c95b4447ae987cf8e847db426848c1883b8755a96aa0d691a544a5aea706dd1e18e161b8457832371c6ac95bedbb408788dbb97252479d8732795017c523078a5895a85360e04910931b9a61b5036482043de13b882ad25d5d019f2482f564f21f69010c79714d4f1ffbb76377e360b4eab0e7b65984e5abb53505665f17b6bb56e14444fe9bc5b478bcabd0f5da380f4c58a28a428d2096b1af4637a9513d283f51b346463c497b25c61352d67eebbf10faf34e6345d7d32d282c637091838f86377f20821c954532392a7c23fa4862a58c2b9502d8ae8367e0c1a23133ae061762b5a1938732cde4ed666c21cb89ea25940865f81116f8bda096c696957792e16cc7521d93cb65f96bcbdae10b952ee1ec71c169296bbf23ae4eb42481de14de36c67aa45313d948ac4dfd921f5639f65ba5c64d19b1c241577e276ec54230536f22f638cf3531fbbd1b7cce158822d26901d9ddee1cee1a05c4f586e3d0de7ef1a8f5ab8ea1f92c340bb8c450a049c9153f30f86f932fa2cb7e339f11243ce2aa10c28e8a38c8e77ae407c693517963a2bd999e0827fe400d974cda3e9075a998abd445c9970b44d3420846c364cca918a945ed84db2876de183bedcea4b49474013f867fe36cf7210ca35e9cb55daed1da540be1938a24d18b53c99bbda8e279cc7285619d86cc076258aecd0d5bbd4fe4639d5d526bc696db327602ed703671b4932c4bae2e527e1f047b5788daadab5ec40268c7f7aae252b644d5ef3e93fdbae6311312f7eb1a298a79b0e01212fed7a82c4d57652235c397b3557cd51a38e439d41fb1a95538620dfc56c01842e77b8c807fb0de074c48bf1085cab619f4903b7b0306a7711c49276500cd44f6d4558171f021981910adf63c22505ec3c66e9928faaa2bb0b8a7f63f3ba36be19ac79d021114ef6d12e7ba74dfb87ccb1d10dac4e8b0fdcc30e1413123291c7234bcb28adba38eb9c23b29ba4419a8aae8f547c1876583256732ce04b7ac41e5ac8c397b36f83f9a04f8ca1ff719ef3db95ea873511521613ee022b7f924c751313f002e18ac4fa66ccae1dac9cdb6e2e5caa7981eb9547d2342e2edc006e30742cc1d443ef8362c5abdd2477f480a4178ddc4f574980a3925f141bc3d09464148047177322f5f8fece9b3e026b3f6825c85d7f4e750b0b4595f86254b93798dd5f021294f66a2670f159fce189389f5e820a3595a0efc97b014967383eaa95c4bcfcbce8b7b260ee1b31ba83320b282e4e47d37713b7acc209b5907d4f17c1d06d7dd3e84c4ed72277a876f847b04022962869d66f4ef124cde5ee3a28ea433630eba709ae8a49240eb93dc6bcbc5849a31f931bdbb41d38aff314f89a7b61e6cd1a8d6c72de634f97415091a6906bffc21c25224c09a1f4c6db0e11884696df6a0d9ea102d78faf340b8b4396283c86ca533f7491958583e51b68f83c5a84ec5ec3a98ad614b1b8e528c35042043c716d9b2fd825031e72bdabc5378aea400687acd20c1995b24f0c7750707bc8f7cf3107f06ce144ae3f2bc48f5e44caa70feea1d31879c6546d657ba6a916860d46d0a7c3b69dca131736a189735a8875cab74ca1fe5dee3184f26c48b8a93c8f6ca4e4682873a1a99493b84edf19da1297e5fe83098f1021d47dbd23b24427d2033df59d231e3e555fb202b2835b014e18c57bcf2bdadf0fc11ff9d78a483ddffdb5f24099e9a88a6880310c072117360838c8b1f56ae4e47349e841ccda477a335dba1315c40883e4b1567fffb6ee6442321a62f85417fcb657186d5ca5b0c7f3f471abb6b32ad4f8cde235a983d0715c173f95bbb9a929b6f85c570b0eecf10b6351d28084ab664591e986ea31eeeafbbd33ea565cf2ecefc461a762bc9df4f2dc26bf63d4066489282a949166ffbbe0b84995fb1102e54e17b7590d0c09cc62810b571107e1d10b2a16065dd1e099776168fddbd905006b7ed9420a38583a557eec5d3e9948f1321f67d1a0615859fa093ea32eebe6f84a9db5e2da6344c6daa2c2976a66e9a795f20aaef7c00597410a81b9c22faa7e5802817d69c7c6e57ae7ff3b29559bab0b5f8ba3d3028253665cc8ae72d01230299e2c4b6602979f3f0a4c7e66994d3a625e81a501b713a1fdaa425419682780fea70126243156ad7194726697f8dab4361d4fd7bd61b968d978430cdb6487caad33e83489359989f2fe8d34d04b5ae9cb7e646644b9103c2d6cd98fed320f6a72709384664126b1b7ea3b1158dbb22ab56c1fb252b454a903882164d3f7452047cb0882fbe1921a6bb1534867c94a3da54edda02c71bbd37a6bfdb988cbc4908d05f34e253a23c25fb9d9e92edbce5c8da1a8cb70d77754f840257db4b40fc29e5b300fc2b2851629d4df4f094fa6cf9ec50f380dc7e02bc723d782a51f04535a02f0202812790d2797b90a8166b89a8d45920ba6c5eb67fab026ba8fbed87596a34cf5ca271cd2fc80973d613231e2cde4f75c654bebde212314ad41e64a416f4fa042535a24ae2e612355a847906f7c8f6bb148b8ef609f0e1fa6789ec931a349bc3ab7d25003738588c64fd580cd8b097082e12b208bc3969a6a848f37814d357de0adacd9ad6c23e0fa61295c3cb79644cb583009d9023596434d890c997c78e9a9a352cf980068308043b1db272761fb10f2e66ecd152a0925c5223b27279de8f8ee7ef57f40248947c189b662941fb015c72a982fcffc26515c9390fd78a5e4211059221b94c82875670c7335c7a26b4536dbcf4f0be5014f93ed92731bfb77b005e486900d3337f3893c769cf9ec0fef454f9d7148c7308bc05215d3b5967ebc1700141c42fa8985326d54827a07d3fefbf5d88726fd969f781e924425fa6829268c1060f9680a1eab8725fb4e0586baf2895ba96dc94b86005ce33a68cf6fdb31c175971d71ef2ecd7250f07ddc16980478f5feba2d12dc7f577913672bf8317a8945f1d88ad1342431ca868d898c525bdcfb1ecee70cea799ee7f7702195ac8f4c758a0b00210e47e8b05ea9ae36ccab8bbf57b43a42631604202a9e901ba7bbd7ec8c5a9420ec99afe8cdf0c0bc81aae58b2ba15e0a09333c8378f6575065d98ddaa06bc58dedcbaa1fa011c7c46b45d2f18beef59ce7101a8ec44f1caab49806b29737490b37819c595ad79ef81123a47043cf613eb597d88ef75c18fbd1456f9b01f895f4dd169b42a67f5244287b63492619a819297b16f67d40018bc7f85460eded178009a5b3ceadddd21b85710d522f1031547657e80245618ad9825fd90966beef82c394aeecd68139bf0184a83919536d53731ab02accd4099c3b136b7fbb0fd8c96fd43ab989339dc10ff64a542ebd96e224d4ad675fe4edf10550a3a1753f8effdf0956a1206af737c15208ff47141b55f93f145d438cd91784d003000ec09e35a149ec583d83a046f502a37798a8e66bcddc6e0814cddd4a03a651b6791e52400a2e56741f8039c55b15b19d030fa195ad628bc5d79470797f70be43774ed6f4b2600a5e0f2f62cad542ccc79728f631f6c74b6b1d21033dc32d7de997339ba23811ff0c4db4071592c24a3d49084da7db2ea54ad2677425cd461b382e07706964abb9132ee12119923fd7bfc521f646dd46a4ea00d7700c8159df5a7cfbfeaf6dea76285706fd9ddeac1fefb9824572765e0c7baa4e352f24e4d97e25faf430ed6688003d3497c052b201506d08722b79d57c30107004ad5a45b8138b94eb6bed3659971a98a408fc2367be54da09319c5b320c45debc186cc4d9fa702ff2f563561413ef82c85b016631cd746391ebb4c047fcd519ec51f4894198b6dc80bd3c6c8ed3282f968880eeb867dd3a7132ef36152eecfe02ea555cbd8d5281589aa0587670ef52a9deae4bbe5deec463ba40397b3663953668b736b6bd3ebbf672a8da585a632cbd6b9012c0758979db08d3f7f9c181721158663b30d42978b3092f4bd35f8f7121924e2565a54ced015e54fdb407db170c2c475c5faa585078c2ba6962b35841a795574fbb06b181cbb3cb4827cfc7effce67f6dfd85a0991d31be8991d526f95b8e46e49783323eed10895375c5030f2fa703370fd9717f84a885327f07fe049be12309b2e9ef4d2f0e3c06b88131f3f76dafc17089a177e96c2fb698dca4a306837b93ce9a911ffda2efb9f7bd4422b11ba77e2f440212f0b44b4d60b4e25627a59c806fed4f630e1f26f504ff0747b68c0e05ffa98b6ade5b642fd7be222e2c3a3324d2f69c6ebe2cc9ab22c41923e2f84d1e77028ed99f3fd2ec77500fe6ddaf39688ad1e27a55a104ceb4acb46cd4df120d246bf67423ace10172094f02f459a4f40a04ac3df6fded956872ce28811016bebd438ae03bcf8257ff3f16887177f32c35ba89604ae13201e13c1ce636d5982ee26158ed2f7e76d7700d4de59d567350ee4e2b9d740832d144b5795e69ec82efe1643a9af194bb5e2082035a4bbe26f78091ebf26cdcf3cc0d3c0aaa074e7cb0c18dd362636aa46c46bc55aa922018feb9dcf4e8d59cb2ea4137bcb18600182c26bba4de109347ac34c60ae78f609bb002c875c4197de3c645c1d182ed78596a4d0eb084b8ca7424900df988f3dfc3fd92f20b873afa31b69c668e961bd44048645725e3ded8a0e91516883e7ed7294fe2ad40e04a3ddd5a74d71c376a10ac5c15dd6ea84d733c95a037ba46eb7ce748252a7ea599f4f68c345d3782c306faceefae60ab92c7f03930ea6c99246fad3b7da11c1db42326821b258a4a6b73305124463e05ba111ce94f7abf6f249a0c95a5efb38cf467bd7d0b1a41689db87bb89c7de5b01cca931153e6c0ebcd6bef69f12866f960cb808c2ee963239d44a40860328c95db13a84182e48a573a2aa9d4937f2417657d170c6990284068337b463ff8141e8c70503ebd3c2f85ea3daf32ec711ee45305c96ce8de39de88331a3957507c034c23d3e0f4d345d2881ed9a751fec65d8b44fd97852ce3a63c6db6872c1886f9bd0481b984751bf8392c8512127120192a030cbcb02da85d077bccca6d08c812ebb93a54e4fcb11f1e440edda0a20fb9a7ed5004714d6ffc81de33e6edca498203922ca3af27b4bab4caff9b3031be22009665cafa5b19c1e2204fbe2ca47d9e28028970f212646e7e65a47caeee22d5087e2904c96d24aab99bf8fea284bf4129cb74343310f7c2d7f201e85126c2c5aeb37c71c5aa35c23df79e221585691893f07bd6de3bfd833d47e1385e0cbbe20c9d150d0af5ad54cad9b6c85073bd112fa1adea23d98006bf72e4c7be35c809a2f561dde6d0fdb5fc49e29e4af664c911fdb451399d1a3aaff63fa9b020b2af1d6c7934dc59f698339b9924a79ea4593d9e6232bd8b3cc2dd5b7d1cbd6a86c16b7e7b32bb3549648ae2853d671a29a2a98bec9b99b333c7c2f72bf77b88efdbab7b547448c948ab425a8129389927a264589f456f4c91aea666a8c26b30d41ae32dd4b541f697047598bfd9c47c00beb62a1f1ffef5da7a2cbf87183336244906f32fd533366a483e34f42518f691666b4e5c7c00d17ea9988ae1f4c064faff81655adb0cf4ef10ae2f028cab56954054e4dfbda51c66f211da8806784f0749156cd14a8917d82038166118613b4e984203d7fb2dfa8aaad68dc50246a914fa4410f8e6aab8fe42507d03816fac28c42934426696c6e946b1be696e4e872ae47a1019760738baace29d5e329f80114cce203cfacd6e684f59ed809914ca88e2cc150230be796d7393a60e7268978bde98261167dcbd51fc4b0e5d8fba90835f57e62601e32d51b7367ae426bf0460ce41c96bdc2efc230ee47f87dfc7d8e3b0fd73060f2bca0b1d1864650645e42824f773b0f5e8e92d97da7e236dff992a67269c4415571a13b4afa19d39ae7a223d9d75ba0ea2b2c318f668ae784cd7b8b215aa38a2e72991baccea0cc062dc9aa1d75eba7f4fdfd668c1adac30c7f999218ce7bb96a191d47c1a7f9303c0dac70c0db229c99c0a7ef856c3880043009ea0742b7481e158725a3cbeb722925e8950b98af9b9b6d87bb8c36856982fb67a31e8f96a8f71f333797bf87cbd432978a1585984c9a18a3e7ac54d28b8c094dc59bc6a3dbe366b8ab413b97d98663f35f80956bb02e3802cfb2b36bc987386cf937d1ea1e8842c7fc2f2645c6661f61dde8402b4b66bd21782bd92438deda35ce9f7670ae346462efff8263b73ba3901114e28114955367c2bc940271e5c30150c83aea89ae335c6b98a5949a10a4c66fe614202a79bb6d032d7d4145a992df837c1e7b64e0e0d1b8c5aae10acb5ee737865f57fa7dd7887b6ac94c9aa6d62a60e79fc33027ba5cf4576b1068f28197be6244edc282bc59f0d85c199338772d22e4d486d00052ff947f85b35223fbdecfa24436bcc4c12006021a46f2f6097c6474116b70d05543a5da590e1aa4e6f6742290e6c30ef368dff45c65e242509144b8f009cc9af19e0258bb201a98c90221478e2be36e1427de4ba4d5f3884ab032b7de563328b922f38ed0b529ec1c3793a8b5a2361f488543b477fbd83ab691205aed1060d343a850ce99564328544827149f659eaa483e8663c7c895d01de6da1caa1858c87aa24464610f3c093f92269aee1b0321b0c0d90f93bb3886d533ba2f5ce5d220b6f2b27bbabdd11bda11cde6bc8d1b5a372604d2dbe3acc0fa5661e3b966070595c9cd93c980271b291ca574182208bf594f6e6db4c9450cde60be124a67d2a71a9b166b2bc517eb6b68068b569e5ccd00748d09baee034d0aa8a97bed513e7f7eae7f6dae5e58f8898bbc382c45bdca8ece5aaae538b0ff852c63963291521d55dd6e3e82f77626814f77ab44375a5377e5100eaf5757421584e91918104473a27abec227d3d2cd8b5d4d5741b4953384bd5062c2858f4a063b9eea1aac74c5b4f330c912b2f3f5969ea522fea5d503b54881908f3addcdeaf36c78367a777d714cae80e5aee4edd58629859a43e23380b326a059538e44a40faef3bd65917b938bcc1b3f18acf7b6eb6b9530676d20517186fe45b0b3a95bc9ab4e3ce650c579fcbc433f1db7a6e7f94c34240d0dd44a541a4959692cf2ac69d2a81484dfa79ef7a80a15c79ea28b27e661742df1715228583d2f841365de21aaf2e7a2820ed041bb4ecbaa08cee2a5e4b7212bb0af96ab56494ee55f20830f20ca43f5ac9339df7e9b522632dc4aaf8fa89d19c13d1a6707a30f71d68210de12e3f09e29f6e5bb47fcbffd660dfb6787b6e16158ea1a9dc3f29b2b942cb370ae06bbc66b1e14b46a1ae5e3b7d8ffc9249a71d2977699092f25dbb9712890ec4e2fa299a534cfee2fea0107191a8362e32fcfb0e7070a42356c143b4dc1bf3e9c6c470df5fa29f4bccfdc9131b677b921fd95b3ce4b652e8b9bc48ffb4ab0d8e590b29ef829b6dcc6244f00f369005750d3399bcb2dfe0ab6dfef17c8a5f77288f5938d132bccde7d4d8e664545fac0a5e9e42549d8a3c2a590748b595a99ebe3a13b70047937fedc9c74911765bdec4844097c2d6100d43feb7a677d1d1ace99804c1a9127512622fcf9406e6f4213af324f572310517375bf3a287249d3dd81beff69b2efd3f9b5b4ac7e303f6b38d2cc8926d6b43e87e2bc0785685356f22b46815f635959a13fe83a9a2e9bf127c5c330f4e8a8d3345b4885e36e15a63327ca82997c0bbda547e22bef9a87ccb5a5908ebd76203c80ddfcbe878b8970cfbb3898af7b7eaf694fc66e33faa4731f79e8d68d17d68c1876576c97d0d83ded04cf55ca39a1cff302cd93f0733957e4d258fd40ae4108010cc749eb0c6c5a32e464ad1953c0bf8ac3fd9f0bfd7ecae6009842879621a13fe67465af936ef6304c8c7335f7aedc782a53a0f7b30dd928481ed964aa0e6637325e08c9f45db5933d210a7cae1595d16e95dceb507f563f8819f3ccc06c4499b318bb374b479ea095f9cce96766912099e088ea1197338f7c1fe9998a740ad8216421ba3c959767c8b0d3ab986a4895159db7a75bf69aaff8105ed906c57b020dfb9e9123b67356c78c9d9dc8925e535e23cf12dfaafb3fa6ea9d17e7e87e2c489cba654a7142b957f569e8a1a6782a6cf915b179595b2b2d2e487454c762117d98d331206b7b653ca8614740cceb59afc10e3b67e21762622349592b44e331c17ef549c22ac3a26e2545f8017f2b0a9dc45761ccfe2c80694f36bbb2ce25aac4e32d2347698cc793e63b0ba81bfe6448c2586eed471b81fa93b8c712b3e87faef3c2b2d115b2d3555bee958ecaa87afb718ab8ca5f8adb2c6d5d2f619d3e9a5ae0f3f022913d5eea9ce0b6ef20d1d36e89f0126c429252525adb378bb3a5993f01de77e682c1ba89ebb4d744009b173c1e9f8df46b2960ec9944bf9b52075d8bfe79531b6a96e777a765dfb07a58fc02a1e3a7de4887647b2e152a69823d0f6b63df79e5e7d1f703fecc8e1d8d93146fac95a175a33679271f37ed45bd422bfd78015fef8ac123e909125bd1816de59d13d46201e82497ac897fa3e60b1a6358d61d65ca70afc8a5a5048d7633cf0cce68a86a068e85a28adf3574727714379bfdd820d976b1b1b6f026511b65907904f17c08c8c9926ee05d74ba2a9abe1bd35746af974a808d56f85931ac09c04bd6eef16e97f3050129b95dd3ff07a8e98ede3e7cc2e72eb9fd02f48a82e219d16f2428191eb67a73880bd2831c99a5f13bfb964ed49aa2b27a30bbc33eddcfd70adff7dd8a4e5eeb9a93d4a2149c59f1aadeadbfc202aa876ca9efc1baa43c3cbec144e6500be1caec1eb987ecbaa4ea1f034f2fcf46386ac5c348577f59f436c4126c761d088a2bc233743be2e2e63d68c5cb05604c0867721ba16a8afd2a26f7749187930be8817a138f40d4c19bbe4a60d8f3ec02ddeb2ab3959ddcf8b378759f89b2eac59b00893e458f458b83b34fd6cd3264a0054688a2b8fe5d19451ae9ece9d13709ed3c18c4ab6162d9949f1d085b3fee6247f7340bea53fd0416e9e13c17c6bb4683058bc1f6ddbd09b62671d4eb741d329ac9c22c2c5df582a846843808dead00c3151f68fbebd0b79da29b277c0209827ad9f3e58c4bc91bfe53c0198f04db4314d9dddcea701517869bc5980f2392cafd200e265fca259ea81cb104e8fc03643084da5b1c4f2efb4250b5e5f9682721bb82da28295ab0324777fd777d85c1a96675f1e8dce45624d9dca5cd100dafeebe230278f8e9ae1fbb34f67597a2bbbf7e19a8818e665e7ab5bfb4bd3b1ed28a639a2fe7903728f63935bbd4af3817d8e4b192135fe460f679f4a3db2d0d22122df27bb30990922b58e0df22fa8713e89c5e55bfa51e8157739234926b63c9635180a5303c87ad9d11efa1a971fbfec195078c982a7c6b0cd627d3126531f419dfff654810a3c128b9c4f4bb55b66ecb45c77bb796ce9512d5efe4488cd0777d5c563f5f92b227e86296cc841713ad585333cbc1128bd37c86ed9e7ad29606db84b54ed69f07b36f88e745ca44f18896dd6362034b182caca2bf0f79198188586030133d95af5b9de9c6c0d2e8463b0530c83cedd5a777ac8d7cdd9ef7d2ed8190489e22793e54cb749c0b5b0c5f15c36b1dc5c42339a2cb28d673e5a76a285742b6bb9102a81b3a8eefb5d80c6843989a756de5b00d027951427f0e7048edb6d40860c0d01188f19691ee73bb604affbed15cf3923d2984a51d4ea5ba3820ef6cd276c1f6b07fc11413bfd62c9058d974b1c5633004b1f24e809f42eee21a00e41647c20c643bc3fe59238507808807adef94c6939dae871c7604a4ce53d66e21eceb3fc6c529cfe75f0e01c95053ad1175ccb2126aedb2ed2684d30a5b0b350c9c6f486b33ecf8e98bbb670f6be60c77c0853b1dc14c19af2ff9c55f4cd6aef3d56ae9bcd98eefb4c9fb4714fa62fe0efd900f6faca00a591e84c8c4ce8e0b56edcaa39b3dc204af35bc588b48503c6832b7e9701b2794079aa7d16ccb4361369de3b52953c9e19f18a8039c8da1624c4b804bda149519491572dfedbf37cbf3b562f2dcc01406f345e75ad1b973e0d122603d8689521898719719cd7fe770f1ffa29f061ae24cd5d927fc895eed3061c29825d213b0105322d54606367ed8be17d3614b87c17939d818a8b23617524f4cd7e45d58974dc7a9a8090fe421d5430535f8f6514ac2ee39696f5a3ab7834cfd8a792138bd50b11440b78ae6927252cccd0c4b2aab8a21dc41d17f33ba1286e5dfd00b21b554d65c6d9b1fe2671be571a9a391ce4ed9b227913a41969446cd2e45774fad22da2e3c4b6860a56140f7d49721ed621c015c0e754dbf24b7c1f571e2b1e74ed5cd789b84e24e04bfbbab8ea02e9cef6067fbc702a65c14f794d1d06a1ef8962c64b3367cf932e5ec1ad1c245b5b9cc267db3dfe17ed2a7e989840759fe1d595af1424a5a81104af5d74594b5ac8543f66dab476a894704eb29ab78f178d90091a884be927e25b57d51fa77b0819a2fce799660f840b851e8a2ebc69ff345b44aa502d42e994e47a7c5db744be7c3a04d45f3a68c864d1105d0b77bd668f82513dee52031661c2876a14bada4dc3720c6fa094ad62f75d2002f5202dd0d7c3ad9e5348a10780e0272cc7dab71b037f48b3bfe8c9d65a6fd430e4f1de8f5451a0e0a350ecbad7bc33bd1635e23fd61dac6460d5e5eba61094ff271277b171dfa4807dc8bc7a9b9056b2f8cf91dcc7b16eb131921d7dcef2a1d83314c2b8cbb5f2f5ba1446a6d1f2ef5a831cd36e8ddf11a7f912439c50b33e8e0795097a089a84bd6399b6bd6a7271ec21ec2b0b78343364c39ce3422946f734b713e0a0c463ed88f9038bbcab9ed7cded4bc86dce48e0ec3c6aefbf39328af5400c64b32f89e0c8c5146ff9c1eb2e05fb6ea2f6f42bc22979dcf6229b75fd43440ffe2c7512e5795c7d91e5161d8aaa5783960a7ac0ca6c48fa26732159e4d4d735a2981eddb38b71357f4f36138f18c1eebffc906f2a1bc2c16972537b20b3b560b0b7ded16ccfaa8a6f6ca0e7d783547e58b357ccb11921c60cb454b46ca17286b699fa360cddb330a2851ec484782f56816fce85efbe263713efd5559372ac78ccc66624afbe959fbdf3197d43d67e809fa4bc61422826ab9f5e7b256f1ec230c425796c91fe862c562cba3c237819c0b1781d76c715f37a19bd0cda4228e363633865d430a37623e1702b5cac4df0e10239bf24c918df0fd351a910845a0aba3410d76ff9da9d2b5472665637e8211da465a6f721e51a2403a4f5399c926ccbe9fdc56374de18ef014267f7951d9deb363ed0d2465f1d6def9a042d46850dbbcc81bcbd735070a4cd2897aeeb3b6074b08707d9c6a983ec21bba13b2ca59514aff199c05ab7bcc1464dc531403ab602f117bade6d59ab6fb2fb1d2c3d88f214aaa6d766e8b8987a89e3982f4504760d145dd040ca2a489ea901c2194bcb12ddbcdd9dcbf422ccac54306ac51d9a6ae6bd51e6de9e8cd3c3a96136ae5aef9cb318e8a170a281bbffbc15b6e2ed32bd208284c53533a280343932e8539b7e06fba5b85573734709777ee39b94207cb8a0aaf0dad208d4f90d572faaa0bfe10fdfcdb7a38d2bdee915c47c25176530030dd93f5133b10777c33e630711346a50e9b35ed48e0dfb0ec22037faa702fd188cd309722acc7a85e3d3078864d3c3259a955fa46998e24f46c270fc8f6e97ba3d2ad694381e52a2d19f7f62ed96720ad22e66123fbaced0f70ac40da2e4dd36e9ba1af6c27170bd33d8e9d74d11767b5c3f6bff82952ba69cf65352be3879bc32ca0f099c423b1eee0f2d1e20cb5b63d2d29d237d39ced30cbfd9ce63da196d5ffa65303b1826934853653b13153225a24b3de212401171030ffa90f7dc3f5cadf2e4f87b96ba4684fed20a13ef5141a1fe55c9ae80768380e8a643a01f2db0753d61acb88ebdcbd3248cbe3901fb20f367b88812683fdb84574514015aef288aa94be761c85fc7c27db20ca1ee270fbc413bf3b61aa10ba1b9380ed5f6330332851ea7ccbd17bcff477420a133fe77f49df1b372f2a2e5bc7723efa10a613582978c20c3510e1eda3dee6d1ae33318932d4a4e035c2c525c549f11c04afabba782133b66deb8fd1111457646562fd60de27895188bf05caf70c9c74e1edc55dc418ad79127475161fa325a7746d19398b97989a0b6500838d7f592ff81f3e5daccc4f2b10effb107d7e83da80ed2a5f11d36698431e24aaca5fdf1740123ceac02f8f308a2918394ae91707c77b5488225abcbca1bb4b2a6da961052b1739685870bf660c503d7fb69a2b4a0831f8446a84f9a03f5236bda93b07340e492bc2af63b5139b5ee9abb37c6583f624f3159758ef81e9d966fc77230bc3022b5d75f9e4500c4fbc26f28516c9b541a7d28da3d806578f7140478524ba8aac8c0473648e58c7c55993e2daac33312353057a0f18ed56697b76e2d54af740e4ca7a16dcd065ac3d29a5852b81a97ebdd3cd41b35d58f0b25fdd5c966ac854a686e4b964eacce250c037b631480becc15e35088827bd2c0856fb5024b23b511d3c19ffaff2543ea11cf7c0a6815eb17fd97afc2c7e97bb296e167b8f3293cc85247d492583d88090f925d7e9cd04e0eb30c9237f4bf7977e620583cd10aeb27546e6ea7e5f6066b58befed0fff06f319964629a58176d667661e85d3b662c1670c05c8a77bba2780c449c814c2737348843e16a69633e4fa1088814b505d6e7e851ebbbad67c9c0b0e5f26db3117e84375e9a7eca276dbad55971872737f612ea27bee54567a0a97f49d586e9d2e87f982543454419bc8775ef5f1720b655e8f86134fd8593243a1a35e3dbe7b01bffad3c3cb051e4a808ac5e88722493fd62d8a22405eaacb09281461cd2870da2731d43260bd100c175adbf0c6da1ef8583cbcc595e429d1c9f336a73ad9755eb8b33a8b7084c51c7e8a1227446fef707dda527e5c343d1c524c008643b3d1bf0038cf993317b11e7ed32c020cb6d5ef14167f935db585f15498ca09b45f69138fd86c91cf2006c8f28ca7ef86b1b7d6e79cb12a85031b61c1796c0e83c81cbdd0a2b39ebe412e655f6b109ecfede7d78cb1efcdfc1ed8c0a0b263d821d6575b87f1b19c6a9b11ae302d6c18328af6866d32a7243bb288f905eae612c3a432f1a73d8ffbe7e34932b2462efd07a6c3cbbd7b708b1a25087287eb60594e142bac850f9768f35e461b165d0356703de345b29cddd8c594f9c25a4c94f8a6484081d755bc131a46b0ee97716a4b93b99cd0c2602b39e0b8905f3d655b99999302b40532ad3eb3c80802732ca5ec5af97a8246132c8d7d0b282f11a3becf66b0f347058e1faac3290eb0d99239372b0f487ffd8f4a742388347169f44eb89c4ed140c9f78b550d47e984776f6d1b2678b01e711ef2b41b633062a4da4c7f099ff1403219545f0aefead50153c044d33c5c032fc5120ab60a85fbc23b66d626e878320ba3f55a60ae9d1ca12a29880aa1f40057c5117c432fe5bd87c01abf12271ab71f3eb3036edfdb57b41c0d9377225e5f974c50a100e22f01a0d0d9f20b95d8856c007872166409815e23abe27d335301225625ae8a5ea644f9eb635ce186072b4d79aaeb0dd461e7d8a398928a84166c9df6ef508e6337b797c248220e4af8af801cd8afc2cdfe3dc6ec0214dce4d694a67338c7cc5cffa70d5cc034c87e783b7bbfa438e7ca4f9558e42a4c04ad3b0a6c2178350ba87df3853b4415e91f53db0691308c46738194a469e5929ef60a7ec7b2c33394153f15738162a89d9898718c1709af696394ab205c10034d09369ee27ff41e80a3571c798d53bbd32b129fd125950c6ab0a0f26e81c348617e267b970750c13135c64a27de5be14693af4ad6f03ff9efd988d56b19c392ef189e201d671ce393140bbe043a84c81e221217cf843fbf98594f8b8a36d3b257332c3e8d85d0c3b26a183c33b832f29c6591cec98564b4b8271bf09fe77e6832501a9549c1a9c3a8329eefa46d668aa1de4d038371d11d8e7d232a78e80ec7439243432b002cbc8e77da8613c1caa31fca9a6ba35aeb02273afdd5b850cee7c6872b6789d028b77e1a6011e66a854d577f1721205f8435ad3aabe363621f888cf8d409eeb3cae374a27599032d3dee789c84e89a2367181b3b7cb0c939dd529a74879cef06c0a8839688605912a9444bdb78ba9ff16387fec1fa73016a94c5aeffcc1cfcd87bc6433ebda95220dc29b8f63f15a54a8b821701d2edc3e61f1d27a5425925ec394fe1f1eaf86ed2b20b999c0b55a5e7d246a77ff94a30d74b510cb94b857d8317d8f7d6d3856b6cca2fcf2f9dde95f598502d832dd1a1aad865df0d0afa4c2d94925ac92c9d0c365da4bab38f918d191efdb1f416f695d729d55ddf4a6d42c6e5aa65b3e5107665fb2013de1379ca914fe6aa45a078cb80e27f63082f9b207539b42a681b23e32dcb4795bb5a791d142aeab1f841558c13cd50c764536c159cfff0a7dd75b1eb74ee2caaad30a889925034cc0d2ad180c7a01314cf11fdd3f62665eab70b5011b01269132b3c7d4cfcd1f166fee4ff399f3a9593841d0086bdeb67c2c764f915cb7a74cb805e9dcacb572d85ef85c91c09f0f6d18519b3421b6e60156220e167f129b0b6910266c7a7d5daba35d2a76460230666c06a0492b4b66dbe8308244f5b27ee3d00f9d7674abf60c91c3bcf995d457225d77fb26fe18b54b1c6d4c5911d6f59dd3cef2716de85c3c912937dbd34a3296d83ba2328abf83e4745a49854750751829585bd2b9e7ccbd5f001362561880c0726dcae858d20180b26fadb93fb3c496ecff96e91b6a958e03cdc78fdeedea6027a9996bd04f25dde313310f1cf4ad7d428fb658248877785421542143f39962a42bc51712aef20d1aeefa4461e849685d06725150231d994ea968844f4941afb840496de0eb2aaf5e06cfcaa895f69957f04ac0ac967aa557a9f4974270d6783c7faef2db490fa57ebe1906a3d29bde1a195eb441e24a1eb071ee026e410b59119e08c7482e208568f65d9cc49d12d75bfc60fb9be7e59ec865244a3fb5b3cbdefc426d8a8779c0642d98ab99509bf76d48789b111bbde0ca6f46c3dc925f39b502a2280cceb879bbb3882a5b1e4f299e498621464ddc7125597fc29250ca02be3d6537f7472ec8d7194d49ff229b888c7a114ea4b0f052149f3b8da3d86a83d693edf2539ee690746becfd3da4ca642486c47873f48e05e5610df12686c7309f4158","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
