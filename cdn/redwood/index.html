<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f11df2d88a5517ea2fa2e5f1adb04b1b6c28d4caa640197c4096e10598f3be7fd1edd14bf4ed1c2aab4d2c6856a7a4150497aba78599a5ed73fdbe9f57a7c938a5c21b964ae08810c6c634ab3a83241f7cd9facc70757e3a3e72cbf4a03b6787e8f6ee6219b80714a1c0e3118324e2003712ffe9ed1747f29be2101de5c854cf4d1e3e1e568e85fdf0355791ba24190d8b1c40140730163c5ce67309a54364e7adc3b3074a33ec2f05d78172ca3f232138ee6f42ccfb73393140ac682dfebc9cd8f6b4eb78d35d09f9a5dc8ec0c1f9afecb193e6f5d5f33a88a1daabdcab48010d5f1591233e430625de0f7e6a16341d7acc7c6dcaef8083bf38fc8177e32b63fda6b0aaed1b49ef5ebb0663c5f37eb6b8fdd68cfc0fba1d997f36428f1c6ffb40f167014110093146ae28923d094054dd48c0bc9f99e6df4bfc8da3691b235737efda4488a94e3e3d126a81182aa90788faa0f004ffbd1327e78538644b1e75c8d569827809f5350bec506b77966291a5397db9ff7732a83e580e481c10b7357fbd25c8a4ba2c4eef7dd6a0c2229dccfc55a540fb9fb9ed37420499d90e29a10c239b20ac9edf70a5791ff2e4f14878e115975e3121fffa51deb85ada29401f0e8663fffd6070b1b57d6676b2cd39b908024ba8b81b91c757efe7019a794ca69447ae518f3199975a25342fa8f083b7f7829db446ee1edfb550ce35b88682996a2a17ccd3ca3d8f0c1ce723a4d59a43dd2045cd374ce5bde4f6e6038cbf06b908f165edce760c757be928a02c9fdf43f07396b4de9681eacc256e52dfcf72c6e2c6623d389a3c3ded6c210fe2d7247c68afcd96415916eb781c18e5e2d9afcecfdcdb1e32d7d3b7b9c41947bdded55a430db91a03b0ab7be5caf489c847ae403452a798db6119f1935cc4b0c91d0781db79cacfff6bf5e38c97e0cdce3f0ae5eeca6880430ecc9159349cda4de668cc3f44de2ce47f3fb1f4af35cb6ca2d045d9d7990360a7e146169ab184bbeb63b4bc711c7bdac93408b9c5787593b0d2084fcd80e1fdb17e66a6707224bfe8354682ad5c503cd89044057d52fd85639b4936dbcb28075e2a3a3b9beaf23472a2a09f0df4ce5a047d2f5a6ee41accb4f3c4af8e141d43a63f93698c1040545d03105fe775cc663c4c5498d244da95a150113d86a7e327d011f9e68afd9bbfbc61475fe5d58a570ba8f22fa3b0f992fddfe4d6d4340173ca79e2cee2e04ed4203581b1f96d3306b46ac072b624af9a2982d6ef1f55ca4d214ef587b72f54c9d21c2c2112ff4692734ac209010fa62d79bd7c4b9766745da5372dc86e12b73e1c55ffcd715a1619063d735bda6a49f9471d16a9c77104bd2ae8335b1194d3a6e416a80134bfd27da63d41e7bc767ef4edc593247f884a92a92c4be4f04f708962df29998253c7ef4bdc3144e1ec6f106033d2ea3fb4670057a38225523596ab32f9a313d3680c8e740c407a9db5f0658e95ab1de4ee48a5c99d01a4a7d92a76c05853dd9453fef52f8f0732c28e722d1a11a84f121c4d2a1e6dfef42ef65fcf5f9cfc2bfb54340ed648483b5a527b199f04e5869909a3c1d115cd6b55736a123a72e255d2c4c816b990679bf4b6c070fcb3312845d4196b993d5d351bc527aa505834f5e1d2f7520df47a8070811fd9f82af0b0903887ec376bf3a72143f09f28c418597c0ac012315d988e77e11847e66aa41357d439d34dc2183ed63cfae6e3502a406b9de3a68462045cc20506342533a26b3bf3e8d84402395791798fa11a31a6053c331fb80a4686c427eda80f9a1eac4b59382911eb814c9b6906e6b52e5b483ca041edf68eeba0fc513a5f3c913f69ae2854ad45856f57039bd3bd27ba464f0565576c6a14742aeda7b08049adba40af6e4a2de6bfe0c3842acae74f3e6c7098305087b685e83e52a1361491de895fa34502439267deba298adef6704bb5da74ea50f38288adaaf330e8e61d742ed5a0a879f1aa8bfd2569332f362222e228b8dd9fcc624029fca52719850dcec7a8199f99f7f7bea46cc9cd42143b8b849642db6f3d64943ddf323775055743a6b03163ecfcc6a520a7ef912387ca034b63ee005568754eb4b8d3590378c79a8cf039f736a1bbd8a241a7401466a4e62406d15f767691c18feb39e2256d02bd3b0afbd1a901736c1f2c43045d8066ff66d56a11d04d14c7608ae838bc66cda68d93f51d1386d7a6d87a0a29d9363b974f3c2696073536998cc0651e20dfe79236dca70a93321e751905da19ed06287955d0b348703211c1ee7340e5a544d09c6e95ca43a87cadc7f4cb859670a980edd0dfc962337f0f5a4c8eecabd1c4cde2e8a6077333f3b8ef7b5f3caf0beecc72f090bb9d02de49b413f94e35fffa34f9c422335159933a3113d0863d26836b38da821161429c1f6cbc6790e638a8e11dc3fd5f49fb5f8cdd3490ffe68e5acc55aca9d77edbb847124637536ab2c4b8ce8c1679ff1daa54d70edf5abcbb56c49b9f957fd608f93bd3caee6f023fcb90022c9fd6162c2d29fb1bde9bab016edf1fc1b890a607cc25fca9ff44ebf5ded8406ac9835bdc23471934c6ce47b2d4cd05f268df48771e81e65156a0bba2e78c0ef1223b3eb0fb5b10fca82fb48c633e81b99921e72ac3d5dba20d86c7d6ed1c014bd8b49020d829b71cada4bc1ccecae1a786455685318fd667897f5ba1bd0ca1f0e947fb36707e102ab8e25e6cce46e221e24e09fde6f893018ed670461cf7c5384283939a7b84625ff369723b14de72df0738fecc241d67bea4e5111b7768c4adfcbd8c0c056248e05442be833a62eb1d24cd51992ded700bd252e534a55c1c60fb9a73676487700d64728ac1cc586a0ecc832edf81b61c43bd543993c3cfb95cb8329db751ca5218c12e203cc8d81bf3a84620908e1f09d31d58f6faedfca99b87894a5f9e5db2e048025a2c9e44662e5b9b8691b8d3477fe49e1d9e77bb8a864979afe65c5ba361e29a674dc83f41edd474d2a5af2547b5a30f089af2789ec9de76b08edbbc669c97d8a6f7e6161d2b345423dd02fecf92a9947146976b57cdef9fb61fe6ba10cbd1955e7faba66cfc9e2a97d041c1ee7e0364e9f2fd0fe3d9d751c856f65c8b578318645ad0b159152014a82f8d54b9e7097ceae47cd8ba03c2fcf00576fe067cfa4e004c575b06238095b04133d35bedab84b83be85ef59df7d29ef6adc09a30d5038ecedebc9395400dc4656eb6f0a0740b22b4f994a6656a96511d738ea1adcdef6728bc88915ed20fff3467cd8913ea729287d9c55e04fba2c128ed469d1d1492a98edfe0dd0c8c94dc2890c36868d5ad3a9356cd224b0d08bf9f22c47fb04bb0746b794807fde6ea10e020fdd90ab1dc1a7ddd8cb85da95f64216f5df38fa51c6b49ed9a1e3888469a0f9ad43bf5589d5f74bf8eae40bf69deb0c527a3de70d05f253d276253d859eb735e2c290acaf50e890baabb71ea674a6b2acb1bc9e7730f8d0e16b09744958a861e6cd116f8a7119a6b5fb8873036280f185a9928768045c0c2f4524c84a3c09358459facd501cd9577a0408084d4ffa7d6ba1186112aab3a843ed9ad85d377fc7b168ed625793e7d638b0e5976863ff304989cf654e7be5b4c73e176863cb683d38839fbe0a0763e3c5137cdc8c229f99b5918b8db420a85313cc8ae5dee32bcf931ac2491f5e3047db11001e57c56ef7122ccdf20615ef218076ffb51e013b0fd741ef67fca99a5d9a7fb22ad1b54ecf08e1500696449ce82417d22142548546eadfc2e8ab7240fa6684af03301986c3357666833b14b7b0b40002f07789085ffc0c95d5f9baaa671f599c6314d9138d2e6f759544368c9fca441b0ac6e1c69141a9023ffa7951225ea0948f62b38dbcc66e6689e6bd66f6d4b6f20941ff5d0233fde50c8c848f25e5443d24f7288a3363a12f7788d9b69ed28536cd156fa6cee3d3fe16f4f4979e2051ddca25d65bca719705ae785bb6fda86ffc8817be3e8c1ef661019f8dfa2d2b33447ea518e299788fe3485cb768aea257abccd81fa6122ae3ed4d4549138e5696ad910edc05c252936d8d28b194c34140b3922e7ea7c25633783c0515272e6ab34c1ccf0d4899362657bfff67af946d177740c93fa17975ef1b6f59abd4023462d00b9a82fb7d970f5510499d3200082f6fdde756f3d8e8e5a6443bb4fa12fbde7bc1e06e44158317ee41968263b9692a8f018b5420f286e87f59ef4c917656751604bcc14f4f8385f5d45b0384c5d82c7b7778cbad189d9e2ae2e3deb28f7c77769a95e1f0e57fa4e41e1b3d39848898a35e0b0f907031405c5c5e9f6a3f9f06c26aa7e1288423b9c484f2b5441e74b45e0ef13b34a4d853c100e174d4e467c95875e3eb50b0afa40b4845b48a90b474d14da6aaf3159dc82d3eabfa8bb9852c50f770c23e59beca6354e2602bf85ea0d206cf2b5bda32d498fc5a1cbcc2fa19968032fc1c42998ec8a72e8f6c14adfbba44a6b34450629a231f3a34680bff0045900e148f2fd624236734d8072d83c44b5c28a3d87504876bd0b9e4a01f89e7dc101818a34c0c7c3814750bfdec1a2f32eb3a9cc3aa03c03151496ad6e37d66a2b20f6e2ff61870dc9622d5e8ff323900f22dd7bf93bbca70875f13b68431908d3a98c0e741485c0dea54291cfc97feff6ed26538056c8e127af0cf22fe7430f2baaef322cbb83cd0e3a785f6dac1ff71e9b05775364310f7d5f0b4312215dc0d9342c21e537fa58fa0cc0ec129cb7243ce3d500bb5c88bfd70fe182803767247b14bd1b33b567055c6f72de2bfbd85ea6824e7268cb9d8cbf2e869d59b619265f4d35dcf0d802077b96318adff4df2af76768b0bb7b39790cb9e3903c272c69672c2c31f0ba84ed86f24cf2da74f6708b700300137db0dec0a21ae8ea4c5b07001d84516d2993f0ed55258794b053c44095bc05004dc10c59622b455f79df6d802d548927953936e65414d4fc80744da7b6dc97807238de4872d0f571ecf49bbe429e3dba4d855c2e7b0522959b2066a3b9568df101d9fa36fb8514b190294f644029572d44daaaf54d9a60e5b792563a3faee63d99f0bb35eb75b60a809a24735d2761cfaf840fa471cd01b86071b5c018460d5d695db7f5e18f43f6a5696847a62e4aafae4bc8f216a848b720424d211d65dc8a5de56640385fed0fd6ab6d8f7c5fdd7bd30c22385afb4b93c00d9a922a813b0364107182a99691980c4ea01a4720677a3ea7c68dd31ea78e66c322a62fb7c016a2f088632674972194232eba5643f1964f4c6e2875d0bfcb435dbe4832a5aec7f9b33758347318486e2fdc67a12512048858396449e4b84df95e68ee3a6f006c3cc2184e26b25fea306d21fbd6bdc8f5111d85152a2f58b82a76dd9bd9c0cdbd69cec35c72ed90f6e5402a05375853f1e4c20f1980bc49022590295d7c82c0d6ad87a0127b4e45be2350f61452cee90ea5456252cc1ddeab1834a64578531084c1047012e73da2e6ed416be6ce0c9babf825be73c935a5d25069677874e2978a922fec1de8c5de89d3817457552af8952fbc5c6dcfb763c3d37017091b3e856d3e672a2b9a0929e69598fe71542d3e94a676ed49d259ea014953599daa4392197a98b274eda00aca376a7190f5e49448abcd79fb2432d8b563ea73de6933f38e8d4dfd15f41d2d67fcb17815672e30ad2424d0263f524c8723ded896c862904e5406b54cb1db1434629a33c81a5f75f5ad76dcb608eb4b853956cea64d9cbbeabbcbbd657b1021dd6740d38947df80b75486f96b96b8afd457eea3734376c0c8cc08a883b383ef6d95a2b7bd02a8141af44cb2c922b691e090ff19f13bef98bbbbc516d7acf8f40be0c017c8f3522b0c0146b12f63b010865020548702dae2140e3ed0491da762c13675603a22c5835b7cf3472e2e8cef914d30fe77e997552ebcdc9a90db31ba1ed4b60435ffab259b7dd4ab52ab1845bde45ba5dcabf0ec648edc427c54463ff76ac5ff60e15df5a462fbc70a3e631db0eac72efa67ca880e4421fcab1db63680a4da40e5b28cfd0fb52490a5b83bb443c66c64145ff272968c66055e10aaa0fcfe5ba03f2ede25982d439cd56c15892a545d2f2b895b0140f89c3a5107589d7752a0cdf01939ad2e78e2ce2d7083795607afff36e7fb9076be953076a205043c7fa9d300a2efd8a30d08ca11591db047d26ba3fd381f1483fe1bfbe02fb9584707a1ea42ad77b145d4d9b98370b4e21fe076861aa64da978dcdd5641cddfe41e37d5081e359d0e350ccc4b3c8d6a8c40ca13908c6a2156262fb76a7c78881b1d06659c3ec8512250f06b2c3b00bd21303acf7a93a147222a46a058076d61621303d453fd83a12647d310e52505fe9fbfb3e2d69e5f30c3da1912622f68d0976f844152b989d611f1ff0ba63b50fa778cd4c77c0ae978fd6e3d9dea1b5d943df939d3fe487cf7885082b3194c2dc1de8f99954f4c249a2bcf5bde94650ec656717ce4e506472b757738d6d4fbd15dcba9a536951098f258ac22c1b100cbd62361061ff5e3accfac430bb9ec9aaeb75c4e6c3ec25e142d40ef86531f3478394109014fbd2e128b5c341045c95282b30c9cf70e4f19c66666ab4d2869cdb1b3b0e8353e4b536fa10356d50ecea4688e5390932a56656f0767f0476db3f829a75c7b32f9435223d647052c7a8d849c16d6143b1eb3db583ea251f6b1c362b811529b1721f9d4123a75941071c9ceef506ab031f2ad52294a737c97bfec16adfe55d27f9b667fb80a39e86d165fbd89917880d17071be9788516eb5895d228672ab926f5c7300ed46e5c223c5f714e599edf16b1c46c4fe9b4bf14554d5608bc7d73a2b3732bd16e756254c601489408d7cf1b9c244b1e8f3c9fd8ae406d151cc29e0ab23602b6cb0dcb5f1e558a2e72b6f1961a92c209c90a3cbcb4861a4af32c49476dc9c368e622e077665112daf4ef7b8328d9506dd0feec3a53710b27897490738590e612e98e6415336a48c847823fffd32b2ccf152418544bfc6cecbad7b16531c9890fbca481ee11915fa86a7471d0b05a75296b12a719a1862f21eae0c60982b4fa4f2c942b8d200c6514e7dad3955a1c4d2f9931e14391605034efa97f1c2626c1fa69729f4c189b3bc1aa652018d828c2c734fcfde44381cf3b289fe88127d2c4d05bf4119d4b0b43447a593ce348d3d95af2a7a979aa5f6e2f57e6d82e6c4b28370608830710be830b3ec4152eb616bf46c0db3a28bf2108929d4d7d7d5a1d52a2e0e548eb305790d8838fb0bda2f728c5dc1e7d41d70d21967135a206cc3b1c1426fcdf8b455634463f62593830aaf47f4b004a551504da01b3eab2b93001293b512ae63e6b64bd6df0c2beabb97450587f772ece78b6a4a7e8e3eb87f625947405d93362e3b0c7f52985e7c5db2930d5aeea3a2c8897f9f717a2c7fcbfc4873fe0d38b5c8657f6ed42087597dd7f3098d9cfa524b052d55b71a9f47bc962d71294b8fcecedaf15930c58f0e5b6a697d06909a222b4506c922ebad7e416c9be7da24f66ba6c0145f4d618d066ac3343d7fede9697016b64784bb48dee828c2b19f96fd2bbf2eb1565f00bb5fea46b8ae01d1b4e89a91e23bd60238395344314bfbb0390ae7288de24852ca0c598296b278ed4cb073690741f928bf848246e616435dd4cadff3171015d9d817aae81f9458d5b25542db91d5cb357f4af5b8aede28402f1f94240a19417c0aefb42551dc49e9ae62681ec3ed05ffdbba266c9f7fec7a3a269927b17404c67967f79ea06792b9c565c7ed66a801f6e33b75bdc389028694388e84838623281675ebfac247df16089617a6262c315d6f86a385f949ca4b1a45739dee07897bb0fdcbef6f6a030f7bee65f8e944994ff7440c81541c0b92b7547d338b0f38c7668cbba6e181252c21103752646dc903ca73b85e1e4353604222b94d3540521347bdd86edb360bbb47fb19d61c3516f8b5673dad81f4b52295e0259cf0d542f5d77cf4eba7bd0621cba25ed3e9d959f6250b574ce360f48d98486f99aa0830989d7f0442a418af273eff811d4c5a21cef91eb83e2964962a5563f3f89abb1fa831bdbc406aa0d1bede6430b2fbdcb4e13613435d282e20a861b9727d7b230a1e88dd9c2f491905eeb9fb712d8cd9c30306064d0a00dea8f5526d3acdb714fe1cb849a70c4bfb338e0fd5bd1e333421b1fdc3e59504d35bfba52ad78ac233f0437e35c6f66a32dd5824fc46621e4ba2aefd06e23e7228b19f93fb8d5212336b710a715476bf4c0dda480f7b4a58fc8a775fa861fba43610d0b424c5e43a30d5b07e27b64dd9a8437541dcf2e7e60c62f5ad37bcc7934ba706c79f079e4b0c83f17cbb9c41471fc0789b77218d502de4144d206491af62f09cb3f2bbf7e2fcc7af6404114692beda81a220f7275742d5a689a99598860b5fc476e86132f015faa7f91d798170dd00474d0c0649c199e3f006f88881646dcda417fab1274d86b2eb68c23c615323d6f6f93496cdffe865fccd36098b679d41ce065b3eb8ff13f278b1469446d81b14994698542d59e04f29e7be5baafdbcb34ef0416182577b00a518cc156b68f04c2e4e2d4ae96a2d25f62f5d5f267606055a155eee7ef2f01c8d3521fe5f87d5b705602feaca76b1b7e2e97e64277baf45ae4978c1a17a68514f515dc385426f67d125a21cb62e16e2725ab9ea8498d1810fe9fd90691c61863b77c59ab86a9fe94787fa650ea35d1afbba350d218490fcbb4a171b61e73f0ca091dd39ac42ef68134e3d0b57f0439166a246e502d19bfcae4fdf97f1e54c7b01f447bf1120aed499bb05a1fdb85edcd7a64599f47a5f95e431f784087c2c779da746482540bb8a49a74d2bd47ed5d71923f42a0ad1b3148f4610d17fb7fd6d7882a0106181f54fb06b69da4e50aac939a46da12582b0eb5f03dade9bf4e228bedb37c5cf26c5e817a57586d12f37b3e32e40fce53fd31ad563caae151881552cad3fe4b12819812355b4c203b7407d33f87d391c5a0c9aeaeefc97f48b01fe85301045892503d96d57a5aaca1070c5bf937ec90edd89bd03cc9ad162ba36132b0a8cfd1258925adea441ddae6d725174294381ca077c7bef71748bcf3ae0da219156a2a3693eeaec5fdaa5c1e790b636ab608637bdb7b12730baddbd074618cdd412806ab4ff7a5a93bfe0b72f35737f325c5286604a6934462f61b9ee4f94e561b3fbce7c72933efdb04fccbd79582a8416f85f87c518f2cdad5f5a8be30581a1d30d7569bfb1ba4fca1d3f59886cd2bf95f21bb018b8a29687d92a676db2edfb8ee411caf07512c083573dcc957a4bb9591c31148a011e84864839d6b81c49dff32ba0e82d59a13de6205c822c3cdabff6299940b3b230192f27efa21fde8a435cef87d327425d096b439806b94ec989794dfa44363df19e3e861f2d4252696a604d87a4edf636263d0c2a1c2dd6f89044f4a000757c8096b780c2c6bd333d03c8531c54586b536541820667c0e0592009d1bb69b85cb6dd8dd838e59fd5d282de8be91d21284a3d81cfa4506d57aa6d13a78ae373de39c692fe5b1f422de672402cecb8262a742107147f5e6038340aa85ad5dacbc6d6bca847132d5bc235a359bb6af2cc853df0fc893e6e0e1cf6076b7e3580306e0bb7f3eb9b7b3c99fedfbcb40c5d812e664f31b07074009896e89024fb888996c23eb1741db0ba2c05c57f2f121c983733fbf534d8650f83b7446bbd6870d2083d364b3bafa4f4fa818867d31bf583563eddcdcc76938b5903e04a88a24e0dc8b3f647a836c444de4fbaa0351d4ecec2b2fe02655934d5cd0c24758697268d3b4aa9ef8efa2c0ddad4a26d244811156eb44c36183a149b355fd997abe9d4e6f943699f6908e40175f9e648c6deaae98cca8d0b16721e677506832ef38b32caff21c8153129cd0baf4190648cbe8903b349e28ec7d4577d6974aced056bfcf8fb674bbd6b74f939e57547bed0cbcffc5effaa06f13706266536e8babc93d0af58c3fdc528a00f9526b05eec7d05fbd94fdfd2746b6e691fde126cff8d446064d03ae37949d8d51fe71fc0aa9f9b4df70af8642309b9eb4672046339a42ac95b328ce753dd3acb004af168a3cffa53cebad7b963ca13236a884004e93eb19a86cae2d09cf8a1c38432b35861a0d94060a2136520d8c409398fd16f2f766e6ff47e042a364f458bac5cc171c25c4bb21cdfb7026d303ebdfc9e65613ca3b84d3f1196f8212dacfb72fb34d2d7d2d4ec4578defd250d02c7601398ffb13e6c018990eefb19376142e2b49ff09ff7b0fe8fc1882cbf5fedd7d8d823e56606b91cc77520d4404132b80c91e9a102030c34676298b0a13b77ad104504f68459e3dcaaa33508b3c9d279d80a697a31633a7db0cc2496ae1c109180691e538fb1082f0087d252692f4b206a7e338733b61d48aa60a52fc32148d0781a77322c2ee4ec8a6f8f4364128671b8d9edd983a6b59cb0d8b39da818e67980336eda886b66b9112a17a74069121f407c2d791e2154d211dfd7ac2f7c0f5fe177763f4fadc4241ee49ca51da5e9b0724d6c36904583b594cdc9a1ba5f1746456e4abf4629667beb8160b72c581c22afae68138902dd63030f4e8f3a9bf771b5c7d0c1cb8c3a8f2ac1ddc9b2af1241602ae4242846c9073140a5c3740dca129e20722e9fbe13035aa452e3c5aac88926b7d64d38dd6777e449d72cb5cc6c66dbb1a498ac7284c5abe572808920a1bd68c41e5f868e175f1886733937191019c29c06d1d34aaeec362a01c0e2d1b8734d647728afc5fd19358ab4996549298d8f53342e66a2c3cda1cac70d3b0d2b9ba14043b4b48b5d1059070f5da03063ee74e43b0a8c26bc984e84be1591349b89581d96bd8784b4d5a63d986067de0592ed3e6145732b90d96032e8ed851b16e2deb8a31f9a41206b9c8d33b3433625b8fb1d8d07a7fa06b8344931b556a6c37520364d4044ef2d158e691a8e862a7a0c02c78818db44e98fe87ca1ba45b18e6540cc2fda67f860bc54d6d9cfd8311926d5e029cea5c5d4f2888d758cec20ec784d9fcc80fd994c9670cad880416873fab93e94b5bc705fb409a7dfd388fe1fd50e0c04d91b698ffb431147808aec44e1b5069fb9f0f8de39ddf74fe4ac73c3ee5f8d25c7d40a83962fe625a1f9c2dddcc7e6230ec65010dd1ba88ca3ea434f1a2a4843953006ae17d606dfd3e59c2d0fd248b468275c8fea08e74e28cb13d13f262f77470b8700bd8da6746abad6dd2e3876562c544ce87ed9d9b2f5407cc75c51a44c98d23e4dddee55db216d78686e8e3495c2f5b01bab5d116e31ca273014625d1f1fd44a5528f44828358bf7bc7661603fc35c0bbb152512fb28d7317ebd09fc963c6f4e5e40704d3a46b07a9a45e0272f6fc5ad08ab290216a26458d0b29f609427664c075a425ccb2673ede0df17f31528c841847262eff6d5c17f526442b8ab9b3ae04f04317d5484c0bd1294c4b451c2dcea4a33f40ce4112f87cc53c3b3e22273380a1e84eba8fc94c0b0bb8afb8d478417481dfa687940db53296e1608d544347e61f691782c181777fe1be4423728482a24a1350cfd9a3d449c762034da76c9bab56b6c0d144137ce88aa770810e0841a593d5ab05c6d5235139e9cbbd1ef32812c7d0135309310fd0cf18a69645f2addca2baed46c4daf6fe9900b7ff2fe6d038892c82f436974f76105b811e0ebbdcf7825d29cc7d2c8e6d76d63047102fc1f8c1b6fc035cf8a5b0fb0fd48453d1d5a3c8e7ea4c5dfa97332a919cda3a2913937c6445382aef6700ab301247c449e59ff75063c5a0e295de3b56c30eab12f2bd72f000cdfdbffa36a716cae782117576fbc48350e51431985c897503b750039a20621e23e8130b20d1a6620a4e181170d38a43bf101c980f3858a4fd519c463f7daba198e9a724dfb74722b1022e108cd0aa82beef761b30be16e653f09eb3522178963ea11f1f63b4249833944c03bcbd38c2074617bdc112bc91a3717a78af30f662b1d6957907cd94d962eb1b6994a12aa87824ce3b771035044ce99462d5b645d92ee068d0e649fdea23c81794c05a97b1987b07b7751ef36ded506b06dd1ace6991cc6eb4a2cce2e7ffb27b203ed518e2f7510ecfddfbe9cc4ad3688798cd28b9586c0eb8f547479481d24415eacc4110d0e6c977c51392686d86c10d3ffde31bf8f3eb4dec2098cf87c4f380911ca697f8522217b9a86e5d53fcaed1dc7cc97d30b932489011b101d0ff1fbf13c5ed6dcaddd1e7e8206d4be45e891daf799d1d08e663dd00c02413c94182c1c9b074850278bc95ca415942071b1dcffb5f44fa242e460435ea2f9802c3a58e55a7ccf69e54eaf6da404bb2b169d491ae3daf378f2ea3a70096f9c753baa2df1d1732f2fb06d4415a873c16e0f5c0aa907393f7b92b6b72ef81fa1ce35ca2e920e53e410bcd76830a4669018728426e1a938c46f75b60ec41910e8a3366c2ab9c92e0d3ba5fa10bed09924d09522469273e36fb6d49da266d9a2b3ccffbcff71bad97f823cbfd12cbef2613c99d6339610fa79849d0ccf910c482b8ece70b8f6c5212b615ea98424f0e44dd65c5aee01c5c15a73f6f97ac64dd2aed7225b006631668bbc8fc3a53cdccd7be57aefaf60bdbf0359eaf0ad712e086e010f45768727d26d465b1a4de6579488b6730adafda3d4dee5aa593f911960c456cdd288763d564b4aabcea1f15c7d9b684dbc48cd4d33f1cd805fbdf5157d5029e5a897233ee8c4881d95c68206bbaa3a5542a71094bae0ba8177a8aec94036ced67f2c0d4f43b99d25af6ed4af531fae324e73471bd2817b440a5e248eeae9867ddf466d58921259dbbeb8a6e5738e5feeae56a15fb477427c2dc9e93670b28a40e1089e5b1a05fa7453ef320683b26f0b8d8e40035bd3cb29d5c84f55cf993a41767402fbbbed75696bdad17fd7fc5da9365ee2509f2178e616a335f0f28ffc085dadef9ee3a9fb5adfcf14a6720415faec4598585e1cd3106779fbe9eb16558019cdb3bfacce873ea20d1ee0d35b69ad25a18f25d4431b42d01dfaa444483dfafff1ddef4835887341c988ee0bff73e2e6b5dcd0d836f2a6b36acc512094e879b4b068f4461f793ca304505ff056dc1d70597209d6f666bd870e7e44721a50d78dded9a6b9eebe2ec84f84e20bc1e73511c92f2e33e1a7247be7e87650746c2666cf317d9fc22d1b9062601abaf42aa938225a4c8a9572edf26886cd5b8eb555250a8269b4bc7c95ef5b5228dab6d108395519b7384a8ad2065785c83db44045b986570c6cadeb8676dd598553bb31af393bb0b28614bd380da1d6670197b28b42b2cabbbcc47e9fce73b2a101743c0873e30eb439712efe6a05d79f094f99877059d940b8f5b66ff32b69ed398dc8f7ab7710da79cb46d932f6b9017f36d33996d2dd8f33530207a75e9a6e20d15d032a87055283427028f1fdf1ac862737e1dab55b8c8b63f823a4bb255330dda78350ceca56a90ee8a1ddf462ee0318433cb83f87287e7837b5451772a0a68a0d71fbbc78a90f322318fe91b4cd79fc91fa13bdc1a6342fbf7895458272e9f1b911f5ec9af7aaee1436abf6c201c6d2f102754e02b19280ba227e16eec507f53d865db63b752105c7610ff73c335502db8eb04690ec71e7bdbdc59021db4aaf41349d42206eb84cc48c0d9d4b2edcb047803354677cc18bebb91b30871ecaeed485ea43bea626e444134f94e9589a3d0bbc514498c32741fdfdb388c4663b018721fe391c224151b44645fac76f1de795368a31e8690fea26aa6f77a10df7271e504d0fa39e6305bb6f439fda04f5f00795339129e3b715e559d89a9902f31ac8e8d94084f49de96d587bb9b42ae3494943f1b2e4c3d144ae503d909304be77c74f7810df12f60ce83d13c6b5cd71e63836e79da117e139c61cfc39dcb4502380555f9b591225314f46df2a706610e5b538729ecc454f6c83251e12e7274e80069ec56c9bb6cce49e546ef459cbcee41333b5c782b3ef9c70e2882d92ed8717f1650820a5c6cf55a7332bb01b4a9624ab5d0ae4cc7bb408f304f5332f1d6512793eb62b9424ceb1c93576b5b86930ba0465e4bc4ea1d2392f2a5b1c9d8178e9018db1b393295c2f5b6f485f342501f4efcc3bfc62038af5487d8e29b2ef9349399d99948e36af5bb3005fceb6cca2766a4ba09d6942df376106c1bdcd7846f8cf08e7c48933f8480ec392ce161bcde75cf357828437efffac464c8a99473f349a15785d323a5e64d139a2ab70dabe0b0614bb6aae73b41eb2f62bcf650d63d9b6152f782545ab8133ad6f534965f97e0439bbe3706c34aea421e8563d176af313854998321f677f32d706162b217a97ee8af7b1034de57174d3506181f796d5c1fcc8b1333cf5efbf7f2f6269766026db1c0df424f81cb1e9bd74676b9f5f9114e3056cdbd99be47f8605380abce2bb0c7526dcc66ec7139f3b09099012a2cae792c700ccd561894662e2ed8c12ef588fad023eb7695eb5e299be52d90015b515e2287619985beb630cad122c8ef5bb7c4ae465893d387768d8470945ae92f43b294b05856f7b9b70fa2a06fbdd046dc50d18f85f46e79f418dc52a03a598975701769b1b64fe3025fc0b617247a6254068f03f2cda1df0ee8bbcd45a5b89ef4fdef7ed8a9edbb53b5fa9ea85853c6f8a212031d2e6b7c307e65e84d1023359922e6ab4b7cc84ad1f1d3e14aaa40bb9d02b2d248d6233b8fb7b1bece0a725893d126e058f5d6998625bb9f5d94cfed1edb40ee7b7dde176bb81dca27085f15640f0789b85c7994e4c142328a8a70071e2f9103b37844996a0717f4ee7bb8056089d4360b232982766aa33e6cb8d77e7e658ead8af5842bbc1a02594d13db1193264d24b88dfa691b9cb7585b4496450936f16fc470d39e9c815de0506aacb4d244bb33d416fcc1ba3c253025a9f5d4d5014fbc672b4e5c875d93709a1cc5c0d79d99bd516d1fe5fad9c14a5eb84ae09658e8cca82c2465a6a0aa4f84b733ccd0fee0941e39d690bb5a1da168981eabdc92b04da1251844074a69c3db1ddba8d6787bac07207937f69cb77ea6f683befe89689499b4b880f2f021af0706ab6477acab72b613326d635d70480b2f114fb409a3fd2d7bc90cd243d58506fe2890acfe2d326fc6c86caca1a8cbce147f8408aec766f5a585e854a474658d3021a79599c23eda9535b7268445c07251dd529a385ff26934c9d88b17b461081ad1f436190e7ef0cc04e41537f7954872e1d1d29fc16f6e019a010a4a977b7b3e0dbe72d6d1a23248e7fd383de5c369edb4f6dc91664ee0ab96677af39f067e8345174057412d41c2d3e3d39eaa8841f9b775e9148969018a75e38a85d351e5e958ea3426f81ec75349cc9577d172a6d50ffa4a1cda41d5ae763f2ff8d10979a9c8f79be3fb3aab95a6d685ff4e5a342dfd8b15b8aeef907a2c90c5e901280980c53fd9e290c91b944c9295b02c491e9b2e56db3535a2c24c884b73b838c7b632921ce781258436e186f869efdd889f9d82476f80cc9c69496e368a9b04f6427358746a7b8b3b22445575ea1690703d3843627b96f6a3d2097cced9b0aef8bc5f61b1f5dc3fcfbb1a7f0aa7aa882a2a7a30b75db1ceed62eff575bce2b0803f22de8f655820a773796b602402983a67fe40e2bc2c19207ae9bffbf08660eec3a87cfd3fde4770fb2589c7ba532c32e3fbd80e333dd4f393e7f350a8011e63b452deb10733b640cf24eb1cb681c7520e1bd4556cc56e38210b28c549773632dec6e71a3606e0acb598293942ac0feb1ed2e5022f62cfcdc3948638aa6ae26a2a26331429bf2f34ae7c6e3886f47c7cda14b45acffba1613b465a6469399b25bf24a686fc39f78687891dd574622c23df34f36610030b70f896806bd99ebadebc368769b85fffba60fadd82ddf3fad746d8e42a617b0203609f9545d1c0ba0fb40e9c61ac529a0cf686a1b735810b5314864f43e3ebf24b26880f1fae47ad820681ef8aec3d024ca95d63e8c356d7ce39376340e3d724baa09aea74f09b7d54b248b3a911723f314f3563f8265b010ea47d5e2f473acbfdea46f10488b097dc273742c34839ab645e15e7200337dad4d9a02f1242e622dae515a889e13ef7f09b707441848d834e2ccf329496e2c7acff00cd4c311c1ef4ec43c2dcc93d409622177524b85677b77e14c328a52d4d9b07ccfe55d752f34ee26f49d3414fda5d19b42ca91b6a1721713935a8b8b3a9c282db1e0f085161ce8103374ce14daa6ead28730b49b481c0aa16183b5f205ad92e818a5bf37510c7d1e667f7c5b2c4dc7c3d272f24667abb0d79edd61ee9210c00ff4343968183aba98483d3e33a314b98ac365634a3ca06a5bfc582ffc40e17801e65f1f7403ba0b98e567e279d7b97131f620646ce4aa08d93755a321903e7550c4906d9a6b15ea8717f74b8932af5a037d6d1b1eef002bb91b418d238e9f4260284cbf82b9cf57cbeabb02ce1691c0b746e0a8aa68cc3f97f3d513387ccd5380e2ab7508f36f76a0e1661e710c9d637a1bb5555ea3721e20e416b5adaf1678b0089dcc4bdda0e099930d9e0f6a540ecd534fbc5758959867ea8997275b5bfe1e064dd3047dbae80993e7f75003fd82a0cdc89bc8eb2201edb654ba54c8a70306a16ee68d0f03c403c98fde7d4ac1acf794077deed3cb97bfedc24b72d3e7d2d62b8ba9752ac134c9f3f309c984cb09b37ac659e4fc33c16f8f86648cd8867b5e2fc07223fc866aaa4f907a143aa488cc643b77b13c5481019738b0149b66e8d82df7cee4eddf42c80eed30b4ce0eff1bdd4ab45126539435fce2c212d8eb390ea14fb673213d679eb79656cbed9430dd7ad89e20ef6d5fa8a5750f4bc43970b0ff7ce063f6d5b34a84b655f4d7e57b20d5ea73767277101bf100b428732b671db6197eb60c5001ebef8ad12f7d4faafaf0e2840c9f855a0b83597dc58620787cdecfc8ff5cd82280ce928955b540cbdcde9d6f25e45b4563de0fd77c41e820e2e2f305da632d55a1eca495dceead4319008684f3a907b4aeabae1c87959641f544d376ae8586b725b55cf07fd57999d0224010dbee1765911025cb243fe7605ec1b994f04b004e21aa1c4ce4b904b52ce388f9905e6b619999141d0011bc353a752fbe10bc434b39c11f83518ae953b960b2faab50bbc63c4d71d75610c6cbc482052ea97519453f10c627c75c510e90a754e3ad485e5bcb9f2b8fb2e775d15b6ee08c72b59571b468ca81c90dcf15d78acb513e6a05c635603bfbafc712f4283e63e02657ba2b0ea5f13bd9494a3887ff2aa780beed01130c7e709573f1f3ef8dd86e2210de7f34e2042cf80be42a4df60a36954ea0ef3d274583a4f596baf4911997fa17432dd1d32bd69bab18ccd90bc09401690acfaae22933ef92dfb6e85f7355ee058117aeed122e65c0c596f1c7aca324903b4e30d5ef9e5ce38e561343e7b20964b09283136e8ee55bfb4b8096584b563cd610f46d2f2510a3aa4b82fbd73a07cead57733891c6579fb3e1c618246552935fc2bebd61256a2aef217352e221e2db00a22684ef5fb87516e21b1eb21ee10ea7354b9a562a787eb181b72ec29ec4dca355e59be3a589c18b3b56f6176fa4ef9b549e8a529b917239c76d6adfdcb8b132bd325d5d5f2931931f39080aed1209c77d0a9ffe1592cfd48333c5407ae7cb7e43e75839819ea133451fa9b2518105a7cbbcc3cce800320b40f0c80e897db31ee9ad05126b3abc3cb04c759d1f0afd2588af51e590813fbcc638e69c6dae77af9126be6eccaf6414caee10ab36ce2c6ef2840a128370d8c0aa1053d1fb75a782e343f14addeb4e49cc4240544acfbcfc53817f5eda7c419a1fe154f8c08bbb711e77462ce7f5f7bcbaf5106de92552d7efdb27b111daab7fcc9b92253d1828aa33e3b9d77645","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
