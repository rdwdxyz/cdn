<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2c10917b57f1a68a81c8118af84317609b4877506515db10c9d0f5bb377adae599f9e97643b6d828c22c0a744b136755a60966213009db8e8f1fb2ce9f4487ae4a044be159364a69d6b6baa0596948448162739c60a0b830a132451ea93b7bb7dd0eb809ecefefdfffc5231658bbfa0dd5cbe270bba3a6a2f4c3d5014895027bb047efcd4cccb0d9833d137801f6de7ea7381b5f4fdd22033339d877addcf6ec0eac7da5bfa7d6fd91938edf9a626a0e53f75be57d30cbafcea77ee1bca65e1fd2a50e3b51e8beeb512195fe0e418a02a51fc7926bb6bb6826ddbc3e3effc5705efa0078fb373ceb3c7763411e2dbbf960db9aee8e9079692736f5b746a8c2e1ce43d405f2abd7b897ea1eb08d3fc086208643f3ec370b23a858114665198b52f84b1e2184bd3ca17e6696c00da7f1004dd17a4cb5d60a32d5db337ccb72cfa70f65d7a3a90bd786c1c66e08c93cafaaef2efd834bdb1cb528c6bdb463e3fc7320e8c2f567ac433c015600ed54ffc1e0f3a5e975959d1e3e7ffb9ba3ea66583d2d089f99c0497da8f3f0b42f91f21bac636725bd6f12ed8fd9c5fb6c699013cefedbe77fcca5ee63dbccec65dc353f58ab91ca8f37ce6bb24aa8d7ce6c448cbc3e0cb45faf327ece190be3ef51b3943c310a3f0c9b707d5b7211ef953f5a3345bc9d553a81abe8b659f6c5139e162ab5d434710db1c02a4505b76e945eec8af12a5c64d99c77bbe2a78ac3df49a973caddf723971b5aebbad86f2a9924876decfa32951f179161f2a250a1f5d7dc162db686f1a588a6a9e40426addea4c2b341979098a8e6d1fcaaf363b1d002ce9e5d20d4d42e6451a69946136c35164d8645bb1d003db44f6bb1e8ded54704bb12c6b402ff54d3ad9f5f56394c2a219f45303869cffd0e6bcc4501d980e7a9afb0541525b844ef5952915a3d1736fa4873b2fbc3ba675510e0e7d1aec91e955c7fe2bcfa461f27f142b8bc90432eb88ab33b2087dccd8d90b77f040cdd2a32dcc6e2fc943256c147521a0cc6901606e4816d34af5695c0ba149101aa6a381f0b0606a4e2874ab2e8c585b22a1b4c767d054952dd43226d340ba543f2650765d9dd638f8e300bbafd208751cc8b3982d69a8e53c5a2ebfa9a582e96ce63bec988b98f0cf42d7861d2ad8146aa055feedc8a6cd43ea9f8c58cdf4f78782bfc2c40ea0983d4df778014865877beac3a1fd3307b15e257bea62cf567b86363492d6e4839e9a0ecc3332382d08269931e19c5e9c6790d2a38cdaa0e4618096a96247f2d994691dc45b021f7de318cdf0c33c6375cb64a4b5aa576d9cbf63d611376101b7b3e55dc25834cb6fb8905af20feca90cf107358827ebb78a0bacf8c540d2f1d7dbb5ea3624a45c6e8f058459ee8fa8cb51a7501a9675c153e7db5b3718a8478609d80e77559635cde3992884f6b84d3957a9161a1cf08ab3002a6e66ca185f8f52c002236b1d94f55e0426c99a8dd6313045b243ee9978e861c5cf752c28a657911bbf66f3ae42cf3cd05485b74c1216ef15dbd77c44853a0369f13bb32ef9cee2e9549c9add1810ad5f2cc33e22ada880d652cbb09c6e03c5c19fefb478b62cee45facab625c58777bc5ed999dd6db435ab91b071334d9719ff1cc06aa2042baff3f5e5acb74cf55504fbe9bd346375e4ab173dabdb82641251342f606a56aa22d614c165d6ce2aa0f342d0ee7f0183cf136ddaebe1bfcd2ee2382e059cd5b490578186bec631e3cceee95316532e4966fa75204710002cc00506cbaa3be42d2af117fa5a71f4f4aa1189bb082efaf1cd093bebc132336194118a949eb693d4368f646c130ce6fdfd966638b18246261f001853f0bf49b76395060d3bcbec56cb61d8b76fb795a031cddbe358e9df1a51c62112b35055901bae14de5a7ad8644775db2b69fbbae861bd59f32aec8253e99f68dd10d03dbd6f401704f7e9205ae58da815c5af11203159b3c012f75f422bcc4552b8c491ba756e6765bf18a2a1e681dca547122108eff512566b89094c7942eac93989487d6737325fb8633efaebec172386ffaf5d627d20709ef2fea262b396732d189421f5654d22fd24e5849a43d73c1b4963a6b1b5b396abe53237d911931d397f3949f16d40156ac1d33aa1745b069f2e881d297c4e032ec10660a5b1b7b5e10c384b6f3c7900184c3ccb312987b1cb04500697d94bf19b6510ec6eb966c5506a9503614eb47992843646266dba75aefeb4f7ed58fa6d054987e7201e4b7b5faa137788598673d47f74374d2bfb6c3a017572f51d1dec06df9d000c2f8a4dac383d464c6ceb1650ee72125160d2c7f35ba917026e56beae71cc9215dc12cc8266a7c2ce49d9cea59bc1aaf183a45ec735cd2c69111b364eb7e69f0dc655e110b4bd1688eb501f04a3f0b9e89d9b0f8a89ccf36e5b4e87907354b83c34918487433d1af63eca29057f322a2665155a30e1ec666db064aca2737f7ae7144b8e86c097e13d9146643292ee3a459ec19fb1ddbc493d2cca507cf0f74efa4bdda5fdebbb4091631db0647719c9ff5a0e3c1fc4a818722fca2ab71802e6cc8641081885f4a34fc3808c2464a3a326a19c4a8afd0eb92211feb6ef32322897b8ff35ca8cfa8f84d848a721b2dd0bee6225099fb9703f5fafe797303294c45caf128b26f7d589f739b94bde64841f99914fc4b0aff5787914ff38141ac9843bfac104c5f3fba6b4bf5e5046220fa1513c3aa8dba0db60d9406a85446e89ded751494249c7870f7766ec397233f8146529d35904e6b585e9217ba363d034d086db97c39ebf779a45362edc692e15256b8cf4df981a911e4183a1a76761da932762745360b4e54ec2f9125dcf4363902a24bf0e8ac85d11c262f9e5c9b4bf7475896f90dd4869b3f07c4e929d2e1e1a12377b5ec724fc23829a6327cdb086a580817fb4959a83bd34b07d5f8d6d675356252ca6c51e351cc9d103ac7812074830a73642547e4ce9581b39a26759389d6f34c2595f504dfd81ed8cd6038258797cdd054c5117bce187f50767a520270858bfed7bb0ae1ae474e5fca91393cd518f84b1c5f5a0ce505b7bcdae2f62cc6a128ac316ffde43fadc70524e9d3fd619196d8dff6d5136a54480f0aae8bcbe520b76bb31f7ffc7b000eb5f17177e402cdf083e3b58922631e688ebc16d5b958b151f818002617c4d72ef9ac3d039f6d627931ee2e58371ccade1cce7df0a7d13920dfeb6ad84bbf1e9092689157a477f8f8a123642dc518baad135f8233a796a726cce88809b16fddf773571312013da913834e943a340d9cdd519e7fb5b66d0d62994c8b7fdf2a3fef22f5ae6f4452cde637996811d4129be5c043c9f254dfee149635300a49a60a7a40f6eda063111ba17bb2c8a2fff2d39357ee1ae9d04377ce303e967b97cfae172035c1c01ca810405caafb57e190ab339ac2fe569e2a27aeddac510debff47f7431e0c5e05ddc8f51e77dd474c5298d6eec77ea0dfbed7f135a9a6a602f752c3e6a156fb49a9fe55b6d753fcd453febb7205af51e1b70e41c0b208691822a69a4598f1391d765bffb394bac330b80ae2ce7563005eb226136909308c79d06d68f9946ad524463ffa8cfd1800a950f62061ba87096245b3cbe07bbf000f5a8cc269ce0dbbf6f531d7e5ede623a2ca55b48259988643a194c461c7934d86949b036fdb79734bf2f5730646f9ac311031ee80afe753db0274225ee70819e32822ec73152d702d70624e4cdb0b40e0807af67e0da930dc74df2dad158defe5d6c27b74244d7c7d57f33455052a2a66f3384f6ee5e7b8ab19a89eea1e41fc8fc6223125a33dc5e3a324f4d700b823715bdf916fcb53d3118b25bede1d65ae04a5711003b778e90bfcc4792a5c9f55927d032851a51f8b9282646a2afcbfe7b1e0adc649491ab5b7ae9d220e1c16efb2467b9fc138651913c0f785e865d666c9d9388d69083d0635e2ee5b2a116518b1ea5fab1a1593fc251383a379c20c02788591bee75f14b6cd59427dca8bafbf1f307fbca8b4740f129b17871134b680d42f057c828c2c0fdc13b9f42a90647ccc36a733994d88cd96d79e2716186765a82ee2851af09a350f63f02174187eefaa90a95c75f13d759722ecf4423b107d85c3ce1e607a16c1a85a904d5ebcdbd2e25d76abad1adef44ddfb9dbed19b4b0f7025cffa004eccde34d629774d3be6a9c711f663bdb6aabea947a0f1563706331e8bf963bda6a7894a27e6076926e6de2558f8313e88ce60c5fca1cc0c3036111a56265333be270087a77128a82260e4d2cc7654bbb27fbbc5cdbc5c14346a1eaa948e1f7017d8e15b483ae37cd628eb4933c89139db808272deac14e2c5cae12b04adcb63e566e7696da0a085c4e7312313e51ac7bf878e523ca55892ae1c01c9df68cb648ff822a800c6646417b83a5269e0ce82ff2852274db69ab84eb43bb53ab4e08154e80b02c0586d39e23903d50560f5f9363c06214f610e60e289ddc4b104775e9b86848fbe24f05c28b65e19298a1f00270abb2d5344be0a91646243cb28dac609bfe7a9a49986b55832c32f07f8fdba43e4c6825cceeb67d71448154cadceb797729fe4ebd699341e88d42961c749510db5db8050b9366b5074d9b7e60594a7ff1b37eb7f957c2f852925d209f9065b16d91f42ef2bf16776e5e60dce86a75fefe23c12aea5c8887537eed9c0f5c4f07dad5b3dcffc6203bcaaf6f476ac2824d55773d666935c5070276a90275b6b287e5fbe2c4c84d76b41978bf9e5ee4cd0ced83056307220c4cb8f730ea782a80ee4bc67b4e90e99b0752dd2a75d7ec55dd72049450baf12c6f30ec14c92518445a113e87f2d08ca4f556db4a1d18795dbcb58c7b366f37fac88fa2472e89de561e80a371a4fdd0c1a91eb370b3c3ba69928ed0e5c32aaac36bc1e6a658aee6e25eb4d60948d9f54c5366d499501e44f2bdf1609e830bb1d02dfa81007e2de72b8234ca448c922176c6bc281c116708e3e46d6c5b0475a5a34a0f1ab657373c31d16552b855803c0d01b6720512c2fcee0cb0b368b18ca25d03f5fde92c039313c2fe1acb6c8c558444d00baa18b17cea7bc8b73d851a1aa77a3a3f376e07860e988ca741af4f99c4e508fc2e22430314dc280d110c8b50af102eb250c680123d79c18520c5a5c84df0bda2255a6a31e8e36fdd322b3eafd69cde1cb97519cc7dc47eb161411f1a9a6873fee865070502147d8dd2a7f9f7c7ca480b12b22996d83c90e4e087589e5ecf9615825b13d8c076d032e2c6ce17a445ce87636822eb98672e4cfe5059ea96662b51e713d16653b0bda74d495a7307b121365ca72d746579bf6f1424c6ae6a25272fede6f451c52588f0cb8ddfafa0cbcc70ef33bf21979d131f82f7937df1ad5d8af2d2c82869c7bd8d0ec07a18879a915024f502fe9871a4fdbcb72b15d303332a5ed2ffb63080494f6fc4ed8b636797255d225eda26c1d07ae3e97310d14bc1c8ccc0ccaf3f7e0a309d34e39ff4208b6051fc2e0b2ab1ca6cc2b28d7094b0e026688460e1f078f425fed8f68a1ff28c969c4a5da31c62b3ef3ef5ee860a0cb46c8cd45fda2723e8876f8b6393143dd1ad1ac67a601b00704b95936b9a2ac4f16466b2b6499e21ab0a449b20f3516954aea1d37b5ba4143629287ba8bc1ad27fd22fa9d9afa0f2b127a74af8fef3d91a2630cf30b988183f740296e62f5c09969d4d17480e697fe01517c3778563127a1e960e4f167f18a2e84b4a9aa8ac68446f02fe959b379879798687397470c2c1c86af4d4eebc23b0f490c4c64cf17beca902c3b813b42a20124b319d910f3feea8482b02ebc2f4952f7363d7e9758330e2b7e9ec8d47d6be364f6e5cc0c3b6dd6019ac0a284864067ba4edd15fef9e38490aeab28cfbe10e13beada323fbc8ec55259c25310510c300c787666ece249da1484b4a7fbdb767cdf9d5c2afd73cdbc6440c06aa6b1f7a879a666e22512cae0e24599810c4ade9434d9075e9301f4a6b35fe21d94d0b29784c4c2ec7ddb5bc2173965ac527edea4393222fe9b5b7f83c2368df38671574a05be70e8a3d0b6c395f28fa67b86057f08d6774e96df47dfa7b9b9f4c6b7ee97d156f12679a59fd9bf04db28b0b12c8634df7b1ca773fdfa1d3585674a9a13fca6c0850d87f25cdc217fca45e943956c5934074854a3496d0074873ec00920d4fb1902699d20b5432875d642cf650f0f037d7eac3dc191c34c76ef8eeee595c1d187d7b6a85dffa9abaf46e5d8a763f47654e9e50b193cda710c72d85c3479bd2bfbe9ab80a593f4f04efa1c9679eebedf986bfa89b5259adc99a65245ac6813caf960951db0616f1971e7df868ee53573bc032b8bf9cf29fa1f351a96bada9386c9bf4b93902f2b998181bfd40abf44072e03f02c4f651f7aff351d7d3e0c1a5c56a9e002ead64c45124471e4a2ba556f37f3b00891eba9bc044b18b9ceab06f1370bb62cac63b13c93ef71b456c2baa6a9e4762b64d9ea6d495d8e2d66bc342750561c85f52989bf4e6c38ec6e4374ca2346b9579b1c398cfe45a376638903763fafd46f8230f25331e013b15b4ffc81673e04141b4747d21be1c91e80650fee1152719a6c4fa3ec8c49896946c9401481ff7ec00a70563d256e564dd4a531b320f63241badf5e32a53cd6404a14e68cd3c3506876349634c36697654121a08ab3f502d7cfde3457f6399bfb3e6eb81a7ce0a0df0a10310c10d881efd40c4f0928877eccb8207fe34ac842806be8d1ccc2670c703dfa6613a526d817b134c9ad03795cbb4b4274c2cb33c1d8ac22904b73b117756b17fcdbd4f3e75a52e4a55e4f2c009c33c4e59f62bbd5033822be063bf7e0d339bf3c0f81dbe449e522917d7a5aaa82781a6432dd2558f804e4219722bcffe1128bbf96bf6760398e4ca1764ef318922ac102ce2bafc62f05f185c5f6874ab6e7f550f82156fb1d4b6b0da78b455956c1ffb0dccf7c00213599b13d574d053801433e195b98634c1dfb367de3b6876d8a98fce11fd4488ba16c0049199725d31d8fcec83595c5d9918277b564bffaaa1c767c3a9c540a2b83360e734342f699342781977fe1f67657c8f1b6e91083341455d94b1798c38ae4e26204eeea2434feeac26c2760a012e080eccabd3cb14dce8da1a9d67ac774e4da5d85b07f56efbb4bc9ee6f3e6b79aae4d807a561964aa627350ca437e0c436344f567ea87351f9936d550733a59ec8578ac438cffa6ffd0262ea59ea36405ef0914c483c8fb53213dddf6dca78d4a144a60810f0b521c6dd47b5af0319f09d2a51af039b4c126a1306070a8131bcb93a0c8edc3dca59aee15b2832c4e2e1d4e36145f5b7c3f5e155e343f32d950c68b67191e7c83e23a8f327db29953c5ca1051f0d49342ef358c2f684ebd825f095a466510b3fc8cd5320a1cf4e1392199176f7af0784e44b50424c277775cae062dad5376bd782c366a8557eed89e6d186c6576248ad6794093cb5bbdd251d9ef29d5a2704cb2d8dc77bfd6c1fbd65065600de66155097481d50219b6383990d2ca40dee342a6bf8f176dd009f048022d7fa53f0002e2e96610cd9bea54ce07c85aed9bfbf2de8d94d62ba73af6219ec5e2341184dcbc73929c34c670ab25da24bf08f42c6384a5f31901c3a9d28c424453ebe45c776f88079cad84701d0b659d672653cd0def1b178a9cf1354c21423670e0428d7b44ab2e38f9feacce0bfc6f4e5db7e5b07b7858a5f0c972697df8357443bb7aae865d63d58eda570af532eac524e151734cdb74f4957c78d350515719730c2b1df7f510c98d632742b63dd9a31c9391370b374b7c1de446d586cb630ee0dcd31917eeeb6594bacc86b3bf48e8e096ff0d12ecdff770a7cafa8464e52af44627c53da91128ca2db42c1dc63e380a8049bb7b615dba8399486249d72425d7f4f4c8ae103a96793dd65297f9d408079272a2655fa620c73e6c8af07094d3292f93162cc7881bd195f9530106b4fc95a48a328f5ffc3153cd6ad4f0100d939a271c6605e6e7928b75d4c7f0b696fa1d44403c35c7ce7b46477a3d023bdb8f9aad7e46e65190f23d7e4cee2a891e2d49e60bb499b70d08701d707ceb901584efe56b854fda74ac7befca08f01a16459c3663a88a0ef2a276c9aa95aa1e0d45d4cce5f7b3a5f3794873bf8f5daf42100a96e2fe7d41dd827dfa6f00792d1547c5581731d06ecd6671f721cb715e9697b9aa30c604b68db51102a3133326d09a112300cb7089ff39cd7e5e0b2786e6a68a4cbc6f2030b921b2a6f728e8227d7b403acd19c49c2d294305e75ce4caa4e9ccfb3fbcfee925c27ef799ed7e70faf508efb34bc1b8e1a4c4c6f0fd4a330581e575bd200a26e1beaf20bf0dec57a395002cb5a9d3fe8b644c3a786f9f454c7c1a534db68d431af78b1d9ef6f5e5a6100c34b3dcd35a5e39605a542a4cb2a12fdcbaa74c1a14113a8e0a4e032ec91ade6143fc05b0b0917ecf44cd267567b7fb8877906b016c93b2871f425eac7593cf8859200f40eed882564abbcc2f03febf9f7fdb14b206da2698eb155ba7042ed8fe32dd882cee8675739f2f4d314b02dbd9808072e2f834edc58a986009e815e9e700ed628ddc36e010fbb2b7c003518bde6f5f8a913a1512b3a50c6bbf4c4631ae1cab6cade1b72bd0e9b5d9e4684d80ad205846f308dd08085559b74c3db4164777858d7496766a49c05379de83d98b93a7e9c39b53fd620c471a72482d7720ccf071b166d5bbb44260864e9320c793ffd3108e741138b01c4bd091527a48cd4063581a3e7be43c953bb41545feb4a075a53debede74b76f985b062a8f3b60f54b670fc4dbd53f3144b77c2ee64bcb32ada4aae38dc8f2039fe49c691c92d2f52fa69def3d9408f58698c68b0caade73d7da37ef938df657f0bf0c12f4f7342471f40e08a736d95f804a6a34d8b62a840f17efe18d55fa87b40870aed02e7417208aa917ace038ad7399eda6aca8f4892a354126459a11d75083cc6731aeb4398fd60f00d23b91787c28b53ea109d88317410bc7e83cd050737e0dc1c3754417da5ff307de61931db8b342020df9e676f1f85cd2fd089975499a92b3ac82d39b7ff838e09793a4f21ff42d187513e998da20c7ed47637e1c5f93d298a2bcf4096967c556c1b0baf00dbe946dfa4895edeabef1de853c4bade5599f4935fb7c9dfefa21c67a92dc0937d957638c318823a1875c1f781cc753a8bd5a15187c4b9f15e7db37409504ddef5a4a9d80a0239615b93281eb51f77a5cdb1a9c4524b0cd6ef1ce5106883bfdbf46d368a05e5253d599cac77e94df69c8d7884cb113a95dd14ea104e610f4ea77902e5b915617d8744b66ad9170741c25eb8266eefc00263e4b3dde1f889026e305ccc20e555df4e17ae24fe000786c233dbe5489b95614512915ce3118febb76dd72c383302caa9bd257cb211782148e0f6bb14d3a945be5784562c133c0c7339498e1415386d93198628bf9fe3c850377973c037d7d16dc87d9e3eb0913a351cffdf161625efbf6cd9d74fb42286e38f621ececb0952490b68d462bdbcc241d6b19fdb167619fd6388dba6ef48babd67ffa63b38dba64688e1cc920f78d9e8fc43775cb97e6bba860f86af6b1724f342f6394d50bd7020644cdfabae734c14bd11da3b11addf60de4f3ddf542c03420541b6b5ff34e51e9aab9ad20675f4c6ae8edf09d38f0876de8425804ea806c8ff3d32df1a7cad04554630f53a8e43923dbc0d7c044e3981fa432eb8ef9c48c025e7f7e33231b7b144e47f5ec2b27467db25ee160b6e936ca0bb3c5abf3e727321ccb88508a42ea760024b6bca409c0522a62612e474c73e96477e6b8e1afa9ee5527aa1082000f495e96a7d7d769a1b18bb2f2c3200aeba8da7f5970d8cfe1b386e587efc54329442162b1e9225fd7f13337b6317e5dd216be9d8bffa068e8f62b4cce20b828661d4c9a09ad66f558dd2d1eee0c7060fb8a71bbff4752ac3b7abd5767c15866beb1c61da2ad14b429d91937a237653e267def3c94f37b36a1332075a96a6c32a4dbeae1f77b9b5f489f8ad76f2c5cccfe4b7e89c17834b8fd274f547f022194b55fad27ac90a7f14c6aaad51f3acbcc69ad65ea643dfecad9310fea11b13a3562309862264ecc63f28c501bdb47a3f4cf5335e77b7b91f39ff5e546f7b331cbd21d8a6361a269f465cc3a1e1ff2470eb4e0df2cb8c40e7058b8bb2be7b916dc8dd818f5f5f041ab4c444417735863e6155395afb31503723f826fbb179852be7878bde7719ce28f6cd2aad53c60c76be6ab6478b03c19efacfdff2a8aa0567dc3cb9fa0425eb0524cbc39123714f0bef2bc385964be6be1282461265d7a6e740192e3f139d43970c1c289d9a4f983c61043a2b8c44a9a5e77010e5a2422754b7bf48ae40541bc7ac8d191fe9754468b608972e69fa524f9ab8bd24867b709132abe10965e0d9ca6fae95460f8a9a79f743e2749f35c103f56dd82fb3eb0c0fcfd0900768da12552b74866f913875d5a822490a815e7174882f7fdf2da670ae90130466e10898dc2c68fbee030acc90066c7aab94257759083178a0d84a588633f6cba0401e4dab718bffe5cf6d2a7ac900615def2e179b24a369745a4c9279effa885c0d8f1e0055614cf8e703957c21cbf6d25706c9918b9f778477aa3bcebc2891a10875bb389e414137ab4a4f02f8beb941696337fd961d510b6fd69cfa5b89d761c64a7239c80e7192bd40b978baa0d2d23815f66c21a22f857c91021a400cdc1bdcb6d07fdacb29f6028439750e5c4746f46c32b7a437595488ceae7383951acd38264b269d10008e013c46ac9733ed282bac901fb3afd4cf86130edf020b9c4d8a9b7e0c631e0534033f60f5f891dc8f952a94c02ebfd7749ab4a010a5550a166199ef1762d5921b49aba19a8d707659df9bab5153f248fcc6fb5b0ad5f795545906b18fba664027ed28e67e05211df9049880cb5d37967dbc247a0a0533f5b1cd6e252dfab7cbc9b6aecf6f2f2f2459564a4c53c5b690602ce1fca98cd5e50be992d5a75f8dae305e9e23a5eb467aa89b965ec435870a7ee6d1ae6b5ce91e7a767a2b5b9a0d807ae99cf264f1fb640872a20e2dee65b04b4e2325d78ecea77f440b1baf4e30a6b6aba4614aacc955fa12c0f6957a3394727c11dd18e7efd4cc8f8a9c1d5b6b5303e6fc955956c33ec215e670d0b6e8a2e1876bf45c1093dab71a291739be9080ceb16fb92de48a9f3f3c7989ab7893aa3cff53c0e31968099a22d15a84d53c796a34f13dbd059003244dcaf331c8d498a93d717e846619d3102abcd4118343ef02cc461d8da67a0d7320ac06c6285fc827f0cc9916248e0075b0e89aa379d10c4a11ab2195cc14835b8cb066dcc6df6d307c8c39964536962c2daa6096c0b9ca6605bba29d0735b174cd4806cd43676593f9b946367e8318c9038d0843b741b00b3b7ab935f4c995fd243d4d4b39415af5ba853297d71d3d25e0256a9782c3a96f26aadfd421b7283665ee6b1238cdcf211034b2e4c719cdc9ceee36e13d02fee700a5bb7d2edafeadfe0bbfc6e0cb374eea102dea56ec448ff0c9e1e37593696719a4eebe61fd592a3611f98667e02bf345af2bff523346db1370dc130a9606ff2c5ccc1d8852cd6ebc9cacf3b0ec26b4934a175ee7c64c715eb41de9a23eb3848f30b51b475f8e029a15a5e16e734ffb1a2574089e2ffa465dce5c3220c3dc6a3dc88c957dda584cdaf3ac1ae4ca2b30c8434effcb0b4ce21a3f25a030cb6a63d94e3b9be6578bb5be4c37b1e1cd3e61917b33f4f8f8c53fd587e8f58527ed2d8bc774de6cbbe148921b5bd5cefde35d42e5960c3fbedd15e742a6adbbf7a83bc36e7f58cdcb76a987fa36498ef17e6b076faf1b202473e3403dd69528c90aed09aab9fa3af5d700ae6f7be37617a99e259fe0c9444967a0b5e15bc83986f0d95625e87bb3367cc8e5fab4f9633be0d4dd09bb3af7a8ae181bc99c0dcbb5d0d63295e1ab1dc9915d23074daab71fa1a4c4c8484ff34d816dc5415f1f2ea34b67966da9e5b9465a12b1db699ddce538f9ea2ac67067465d2e127b2d1393e72f40c0e415fc4fbb338693d9c04652d92d0780ebef8e9fb05eca4c933eb76ebb80e19a928780400e7aa5b809a264ba4f4931286207fe03984752ff4aef83e12687995263c5b4e93241308a84af47a3023adc2ae6da2260dee1119d9b20aedf721df1b37aa6c26f90bbda339e25f26d4a76825e3c2acb7b25cd332f1db18e25ff0e8e88e1e4453246820b281eb7bf4653baa9eeb59c747fca496b55c1cc79ae89c904f5c4fcaa8b20bacfc9e1b28f4d47f5e085bf16e7f68d1489a5d3c8d98967903af7418641308a52566946020c3d10bdca97981984241d3dbd3e03442d30e58a3f54def74c504de46d57d985ca1fabd0c9735a70f4a38477cde55300113c148143c6befad649d696b786d61420fb8f1aba4cf5fb7f01a21a0ef175f73d62961f06e5aca3632ba2b4efa5fd7f13ad1e6c2da38869aea348b582a06cbeb261362b2b385197d24c1637563d13fd7175398d46091a724d2a704491d3d728ee4e04823cd09ac35d88bdf5e8db3871db3a3fdcf5ba93efcca1a2ffb316e4072f1f7e680817306b0d745d0770ebb2292cf715161cd6692c0836e7200c8ec8c89d02529c09829c3767220b07987f3894f50aac518e261d1c80b55a830fdc1ac768b82f4a2060514048a45c10207cd295226bea2f210eb9dc09a5e81775a8a227d14e1fa46a3b32e7ab092993c5808d8dc00a942ac11f57c1c4fa67aaff152d46d2a47ea26816a1a5b0f1211f8a538bc6203ec4861ad6a88f9716e23be11066630fb3ea2288b5be024e48fd7076898940688a7e44fe986ebe900392121a24a5851b687674aee4385d0d07e7b80ed90c029cb4fe23e93e7073d951ed706243dae4f4459a75d2331b4afc819468fae8314f8bb506abca6220bfd53d6141e6d3a6c7bfd94fa19fb0500846f75a16e7bf777d6384993470810e20633f9fd5bb4e083143ed178f82040a96aa97a116a18a59db97b518460d8c394a22f4a219374a4dfce768e937459b03a39e006c4902a6592cef6922ddaaa76bd9d2c2b8752d01d49f57cf4100a51db8349cbe13aab1a4f64d7766c8d32715d68b207f0da5fba8c2e92ea196359c187993212b4c8e6eb403cc4247001f4104558b38768d019d11f64a768cf1cab65b52d9a3602e2e0d79426f77929069d8b73785ddd17e6f4f492dd847773e17f73ee9c7bf52eef5c8f096fe1de3734bbcfe6da8f87d0e97fb0b545d129bcf8c1b92c39679a19ee88cfae128036fb130cd0c9ec9318b3611637a2bdeb7338f67c460cd22f85a421ef073fbc413180ef347d401e835209e056beb09e52a3487f4f6ca7dd029ec1c602ab6f473aaf768eed5f40d470e0794f995f3c22c9973e1b8a7fbaf9840c96c97377aaa233cfbcf0b61591a5b498658fc0d63086f7dc309c283d8d406ff5a42167f5094ac6af2b0154c502005146f915bb9df124bd0ccd0da913057e8fa9be0b70d2cd7a40337b79bb0b6385e9faa82c093d8a5f5fbd527b80062943b89d1ca92ef7a3805c2d90601616f0276d48f6636a6ce4a91c2145ff61b5f62b25912b35034263f347e575ca9d3dcc00d8c0913bd45c340817c47ba491a1edfba36bcdd11061c673af5409e2ab6f48d10605ed1c8dad2647b6fcb7d63547d0f6d00358b3c4946b4e6b4e70a2271f3c71d6f319d6793342d8255b473c0aea34fb9f771c2aa1fa06809bb9c1ab075613bc67e567c8848adcbae16de9684cbcadaf9e6970fb200afa5d30f67db73ea518421244299463836ad380c65042f69cd1105fc4cad909c22453f17dc539b83b9cc64773951b97d9d93a7ada830fc203608ad9aaa3ff1a9e37a250ea18a78b4db838e69ecec2fb0697246423de2f6f3203e5df7cc1752803e5e45f6806a1d2fe7e37671b8c1e23abb886da171008498d1db4d3fc3f06d946cb48240abb5abacfe067c97071fd1146368f3749898dff2fe26bd5fb2e8d43fb1c497f7becd16baee7131ad4694023878b6f9d950f2b537cc3ff9e93af233eceac4b0e139516143e9d70deae342f34fa30f0b22988494a461d3f4fbfc946399d11f1f9718b674dc3944baf0e3f7343963032d1111174e9c1334b649ffaf259f17265d72a8ef6a16c56802d297068551bc6453c8bba563715023d8b77909841aabe8caca09a1cda619a5a3d0269ae8f25b8e512ec6ecc49dd6fbfd5971d3eaf1fefd58a97d63c3f9d7f7270fd67094d030819d166c5ca6786cddec197cc9f150d5212684234ff2b9f21a7e25094a48bd8f7232fea8a34ab03b4c2b107a187a5df3ff2b535736a0056ff649f8f848ff4814f341aa65a17b9fd137628b3aae368d198041dc72569774df23439dacf5c750a2ca99f9aa66d99617f7d95e6f6394e4b9a8ebdae7d381688f191b3ae9bf558cf128f7ea9278c7dc6f57e3152acd0b0b02a8a5321cc961a979d8f60d2a5c2d1147a9d16e02db27840767b7b63e1e8fb8790c54024f89120a0401dc8cc3eef407f7d91812aa772915faa780993e5bf1508c32c745b5bb040c3f6a54e370638c841c0f0126dedaefdf1dd05717861a23f05c0fa733b1930f656f6d5a13fcf01e12f4df87665a01aeeb24f0bc5473aedac52f853e8d2a974af9533fec96a93d6a0c9161fc51e94bea8bb129c4628717e6f0cdcd838824af72a9d28e8cdbdd5b3275835c2135be41b190810d068a8c9d3c21501d135de1a5b58dd99aed1dd1f2d96212942fef6282b80e0b5869c3535b5897ba985b823241b6b002dc8eb990af1c76aff4c3d439da93d33f7b4a05a60020943080c9d7319e63249ce1a344d67ba8936eadebf0812af7451674b6adf66a05b7c145bd3b4d670bbbd978292d69ece62562e1f6e294d2e751861b05c4ce6ff5cb96a765654119c21cb5b87157b2d20e175a887df39fb992da02aca9ee9c5b2bc39a72dcc2540669972f7b4023c173288270d112c412d77b7a58e29db4ae1728f8f3d7b5678c6e232b249a371c529b2f8c251eca192252ae2865fad1cbce5b3ce48bb98e3da912fd04a4f6d89b09296e509102ccb8939d8b9d0b752c621a34b53be3806c6b952d9f8a6c7256f1438ebcd8671aaeb80c0ac90b3288e7aacd143cd5a6920c6045dabdd441e148a6e4a792be5beec7da33033ff8c9140364af151220fe5a8d5860da09b383236372c534f122b426a0a779e324d46bfc4f76bb15a0b1d9da777c393183339f94ff0b1211aa9092411af26cbc1d82ba988ee7ac2411d923eaa630880c44056b2174d1a2e740415797d7e4f61082361d53d1cedd80c72b7bf9dc5af62c30bcaba9576a6584cf98ac935e518bbb1e06a4da43a72e3e76192e45240bcfdcb3c0f41faf1a8e6b525f580c8b7b248a8dd561d50318253ff0e891d017e3de00d7de88257b50ed52128fbba8e2678480a48a81a13ad790cc925b75d0e48987d1a4e64d6c3475134f91fbdae38cc839dae76aa57702690645c37746a233121675c5b8de60b06a9327e4c2c366a4269779a7f99fa1be90ab195dbd89db182f6e00fb827fd83804c108fa6bda87a3af19ae1cd523f13e2fd3f5e08fea822d801451ec08b5382c52303b4d47cef57c97fdfe82b87f23e13b859d0ed78af67d6cf64b8976f42a54bc7f6eb88caff13ba2c43095cb4227e3f5b9677b10c19c0cc24a20e4c73f07b2ef93a0d70e557d3caa47d625eb6ae9baa9e139ca9e02dca9799dcf7fc287250328a6a9792b87ad1dc0ae6244164865342f5802b6ed5caa2524ebce3b7280efea68335120bd48ef2611e7f305ac0581e5dbaa79a994959faff2a07c67726f72f6b8bf7e29041df929b076f01dab9d57f355d28e3753d4415dd90cac300a3bcd43871042609aea8025bf16d7cf662f5502b6076efd4715cfa133b36cac623e837aaa170c637c7f3a1158359f74cab96505fc4ef9eb8c523663621453bb682254dc8ee3540586a20f1eb92498738f540927ef56106d8333d059361a9fc5e90d6c3d42af92053113c2778028e9917b6e78f61de6615ba8288c09e900c323307d5da486f8284eb7dbe60250130cd1665687049b569c8cfa3f1d5c3d5a3e045f42403e339b3abd9b0734b6d254445e1425f00a530302620750d99438cd06cc63805cfdabd698231c2a09ffcbfad1050cccc1b0e605412412379453f8fa4e1da473fa1aeef4009df996c6789c3e28f69fc4774b37e4f2e78edc31dbc47efbaf6fe7271da378b7e4526e89268d7ff77387d25ed9b9dda8ef859d332b627b9be2180fc64cbf79f4c772c7376b2f58ac8dd3a746626cedbdd18bb4226f9442e57c419e5fa980f12512f20771a3f59427651ba66ea209eb51e7a198112c3432a99f3d999cf87e39f8371eaf44fe17863c34108ec28f0b984bdcc7f67dc7b2f5cb65adc0e44c6bbe8b57b91790523ac657263a36b51ff98429ddd72f4824019ce70afe7bc098b1003c3e8de5b3d03100dcf9f2635e7b0afc3495f67aecf2d29f43dd78ca0e99fa6c85f288c5990415b19f63a3c6295da94790bdee8452f1ddb75182c3774e108ff367f5dda2f92c3ebfd2283aba1dc51dc0fcd7596df83f329be502a0c304f56dd29d01520b5b18737939e9a35379229d64525d153173ff9d7f781e734c0d5305b0994833b08812fb5d1807b25179bbf6dd02a4ec6f603bf9747e027f7fd495e7501924c0f1217c606bef57d6a8670f062d339c3e554125aad61c18e6470c33a821c8c35fa4c8646825bcb9cee00422a7edc89ac8d4dcc674a1083fc72e1732d61baf9327dd5d5aadaa3441779d3f61a094f2ce33d09052dff6e15cd5ea42cf0ec004a3be75c4542cc56446eec76bfe30ec540623fcd10ab7b739402f8f18f7c361c201aae38ec33a9a0f660ab507c204d9feab72dc99412fc1055e2d849341e963acbb9bcd00d5813926baf6d8a87a5a9b73db99a88bdf83bd7db95e0d22196be14d8734bf72a04dd863199653094cf595b39d96add2c4cf4d03de1994bcca3836b1ec1a28968fcd37d8533b965b5d745a950d1dd8c8a1158356f53d9fa6978472875998a19abb0ba9a29cc1cee41a265694cbf2b62a1c9b21709c0ea8a88573f47f364f842a61aed7ca3cde5c7f0be9b689eea055d4f58ea46c209fa1383d964a9270ec80e5089d13042969c1581ff5e48a90fb365e46d0fc5104e5f228280b1dee24c0aab0b6be9ea743486bbc99b7a353b5d73a3047950b8050e998711cc86a52a021f7b9da94c1528c879af11bc087a63d027abc79f9744e55ccf71d89960554006d2c57efedaa67a5419432e66a41ff13079c78ebcac69a2f871e2007701970df873e0491b0eab9cf6addb91bfb76e5b9fdce2b380a2f9dc8ba0f49a1e7dab48bddfeefd744aa01c3976acf7b77c91c3905287793276a4ad5904be78d286857e7b1769e7aa0834ab25137911f741a6efeb6495986c184b870ea2c36bdd1ef3fb5f7518cde78dcfe47e9c35b3586710cfa1c468f4c9e2fb25001d608daef3d71d473c57ead656fb6d765b991b40f57a62172bf29f7ce3773b0dc8d1721e67bc04e572ea31010b663be0ed6b920fc4728bb8948506357fa1d5ce3c9936a007874e2f7d13a79dbf8c30992234a127a65a61437f1ee85b97de3f1aea63321122671800dfc2549fac2c9eef313991cc73ede614767de71e5e8074890b9e1dd27d43f3850c93032a48fac2bf2b7e47be1bc24eee456220e9c6b3a533d789ef66c302fc770bf96c7604da91aa9e4f08de7e04685ed5336956cc4a7469e7529021ac358a6e56141e82fc96ac530c9efd488cf8f0bcfccfa7e369a19c2fd2b8537ca22f9116da47154c8be86a197393b50ed00dc0e924988bd926037d07de103defa8c47bf665a951c52324f53ec42c04cd1f626c923f84a25f86895a15b191423301541a585025f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
