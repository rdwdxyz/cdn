<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2e274736ea4eb6b5e69b12d5854fee84736ae525b026cd32f6339cfc255b55ba286a67875f2de6de531d1384612157edf70ca1e439c9e3447586a86b3f91eaaa5f2bc633f0574ec8d4eb81e141851cee0a82245abb0a770a931c36e1c7f17abaed01d4a75290a85812ec87df98d9651181782391e1de590aae985f362caaa3f8b252fed8d6894e298cc6bfcd734a62281dc4fa8f63081435d6b21989a728cefe33326af6b30f0fc621daefd60e52a42ffac7dc74d57a3b9a4e9089d91539749b55a3f56ebe63f96db1d436739bc23ac8d383efa0e01ec3f0bdfa2ac44eb63b30488b0f2ef9d94ca55e877dbef4d7ec4d8a4ef123a288d3147def4689e77402fd009ed243e61b5935013e8351533423877cb54397a31e8d777c14f48a0afca87eec05aad0e30df6893b625b8697078b998b0caf6f6db575cd58d32a633b5e884f002836a9e8b4318c34298e04c35ca546def36cb825a2e716174ba5bb7edf830464cc9a19f749408055acaf4b86537fb2dc70ffb32d01d5d2a7d5efd93cca2142b753d3f95dce19263a12599bdde2cfcf935b66538c99b94c2de4582cdcbe7a5a14cc946cfc18736066eadb4f56a57a36a4f75a05b42fdf666169ca991f32b099552ae115629e9f2ea2c3b6f9cc4cdf003d1fc01a728a1c69f339cd02b2e24aa796a999cc76639320214e6882a6d01f0784cd18b69b906ea2481d7985fa0048940c8cba29f32d1b0a1023bd3973b8c79fc9cbfacb4b9c490822274da2c438cdfc61b9b555abd021b249a03be5d16c83c37f32f9f7353578b048bd0a378b5541d347f1d4c2892e2d1b63543bfd9feef0d9680df04cf59d83cbd6422056135b9c5092e412de0711b166302a5dc1f7b96241b1be3faccb04e3ec84db353343bf2d3102ccd977547eea20f091c925a0572cf89483240118d9ba59341af52d26211af8778f35ad298d257ac7a467a6f8a27ecd0d3dfdc4b483487a9765e2bd924b6850dae21b61931d24329b905cbbfa2e921ba564aa5bed3eb3be952ab6769880b706d25681176238fb0ef48b448fb2e8a84449881c3b270c43239a9de829910fb5008520fb3baa1885cf93965ba65774d024aa65327d0ef9b5f95a28e9f29e9c546b7c5b3f69b4a82e0a8b275c25ba00cf8c88dc9b1c83d5731238632538e56de69738886263f30c645a81d0584dca4cf4bdc65ef1fb365f042a2afdf497acca703b6d0303986d21345da29b4311061c6b42a18753df1a9b48363b75b7ba6d773ea642b3888ea7c4804dc0e881f4952ff3f172ca2a4238b54da33d5450bc110dcf972ab3fa6e94766e9826b90a7b1f286cd1d8c5f12f36d97ecabaaccb90550a9f13aef49f24beb846af0ea3fef587a6f2c4a9db63502909b8437de32fd41a00b904d6dacbaab3fde8a7eff20592b8031f1154000beddbc7c4d6f370feae5ee1eaf37239a2c0086dc6ac23b0ecb22266e0718a3413abacf48ae10c5d48aadb59fd4a1b6240fb120bbeffee11be1848afb355ab56bdf92d61a59284726c0a4786891f9dd966e2f0136c891eb902c4450162fcd89a9fd7e32dbf1660e9b4a34b9131140959fb3010bb66b384676328a769bba3c3586d5e9be11b8fd16c98b2b3c34053c0c5ca93cc48490838c075eaeecd644058e1a6eb3121c3f5d13e0f0e83b48daf30e0fae986c2e54083f3fee654d46e9e08eaf74ec9fd4e0d34ee348f4f84740bae1b5bda4dbad70d9b561883fa906c29d4818379e7a53eb081993e1282de75d8356cdca2fd420b3457df2f362a40000e39819276f605383bcd4d539c75d77ce3e460cc5e6609e7b16ecafb2f13fe5328e7cb012feaa109c12b64cc00c0f61d8c2a3146518a067d2d78d5b2e9f293bf77db9a8cb1a44e18336aab82cf83b97dcdbad7712d2d875f450dea08abc869963c5ed8343d8b10530c6b20da53a670c625736d0d2cad0fe3f363251fcf44cac207a270a9a0faebe28e12adcc5193ca96fc6e106b9890118be28dd85251867f3ff853c0648ab727b5220a69f8e895e2782a22f10c8bd4c364b27990f39cf002d4a8e32572e281947cc7c2c96d9735144dfd0c71aafd5c9acd4385f5bcea800ea14bcfec1a12f2b83f0ca03d6896942f454d6bf4109530775629078b70afcd2463746fc2c4f6ca35252374f28732aa58a9407c5e171c79140fc7a4770543e5bdfdce2e8b7d77ee476228f11e12795b3aefaf40eea24b17f5a2c90f7f924824b8f6d5e60e2e3ab7ed89672470199d686825f46154b1eaa2b5e7a2e90e6365a067019deeb333e066f7300ea3732a77b40eff8fc33738c1e270369cc5d4caffcd69abf33061a8c82ee9a3d022588857555c2462d8e136b3406c6b46ab8c4209b96543d1824b49dce63a6e247a4f2065f13319dd9914084dfc614880e0ceb96c3fad18b3e20c1bf629d95b49571447959d5d766d7a5260b1f169c81f54655fdef81d2f07e22fd54ecceebd41a94e49d4e88a575892f62bbe1355f9af0579fc8e9768113a11438d05470472236094a7c0a8f843152da7ff58251bb2f2d93dc638da0b8fa9ad953a6c3e4540e36cd40b946367724debbf3cfb9aeb8ad89629f29c1b54b79c3068e1239e53ecd6c6d9fa880a05854b159356594003928b0068248b8ddb05499a3fcb08eeded984ce7ac92f23a888ae1fd3021c3708a885fb4e82baafa465ba78f6565742e03b42111a8ee20b8ae429b6df7e56b98d71ff9494e258ff8830378cc8fdb009146fb8337a226a901039baba7a55362691aa5ae1b7fb565f0561096ee303e22d5e811db20b9c5ddaa8750da2ae5a1303cc5bb43e9016b4380e8e42e41d3e3ea0e4cab1584e74b860506cd0d580e19775e6bbc1cb5d354823f4dd696d7756461b0a66822ac0367662bee0f3806f0123215db765f69b8c3ae6a18c8b2c7c8b502933c81776eb0a274debd810c61a0dd8322e58e4b8972b9e93a6e77d0011da9ca27cdd27fc8fcc46e7c6995765f328030a1aeb13815ac86d19f6f7dcea84f911235143571be8745d42e01192e5f9d27a44dd566ebce553fe364fab87b1dbcb14fc2b869a578d14ff67c34279ecc622744834553467dbab41c7c61bb108b63df75d0b2c58318cb962cca10a6206b1f2b0285a8ab9ad897ef1f12ce32a917dee15cc260c5a122c68acecd8d0580fb4ed464240be54fe1118e414eac99827b5ca1dc8287d2e4d213144ee5237df8534152ae20e6cda3538bb35fa6b673d6faebbaf337e16a41900083f925035bd91c746635375e4e77f24c81c160f15d190fdb2d3f1e3c59eb6775164f28e54591dcdc0a7fb71f1c287d66ec45b70e98394926ca6517c73b561fb8867f46ef0eafd25deb1ae40915710fd3ff2de3bea9e088d24bb84bc2ea5d649f14ff5246945838a168d458da2086feee335264e16242b038dd5c62a17f96aff9b7637a5d7f62d1c7c2e71f3108431f18e742351bd3acc071a692b9855da1b017b8c1d589ea054e47d0919f538bb0328b374dd47995a30d9a9083b74de2d670bb30c774d61e0660aa23148e28b2bc98b36fc3a2df09da30620efcb09b5d183412b5de953dcaf38f96f6edf2be04e585d91e98ec225bc539a7eaf6786eea2d630ccee075bf8c1cd25f28dd90efc7f8540ee4216cfe122b608463ff58a99b2197e26954bf5938dd768866dbe6e62cba9ce8937d9f1fbf1b41da215edf339ca5d825a2c9c838d791d52b941e79cacc8bba233541266a37a28592d11ee3611ee3502e52ac70b0f39bc1e509573031129778d1571d5d7d6fe5877e1b094fb05fa5b9beaddb3d49878987b6386e6b9256e20e3ca5e3a3d862b78f04b00919c0a099a036cdc7e1a6ebd376be607d3aa82a3496ffbf82a3045a5c542a8b47fc408bb9ba554733f70c1f3270fe968c4c29a5eb9cb1b7248b1758a31b9e90300d80d88c8abe42605f8620c9c240022be5c78869bf4f81c260ba104f45d8f3c906da5ce2476973224454d69ebb465fa6c2ee06ce0dfbe9b4ca61217bdb852ac7769b65964fa23b1e96004ea85181332b48964b8d3012aba204823ebdc794972f0912742055b68e0059e5ec7d5c4a989e6e86f88888ffbad9f404c5a71bd23df7672f0072b953fabdea8003c5ffab002b1d8d6b22b962cf3727a6f6c53adb128f7a2efcb56415a558c21f6558309caa02635cebe084993508f6d6ac15b31686bcab79cd2171dee74026aae4447271f718b4f44f392c45978332d4b45e2ae517fa19f9bb179afe4d1de6191956ec4532ce056bba43ebc525fc3c28e01ab513de72df8fbe5218c2c3d98e2ed91033fd42f5683db832516b6e80f7240a3118810913a0dc7407480f935a9b64435d9788090b966b15506d1de649f337321db60c741287458362e8c61a5edaa756fef25ad4be61ec68e8e8305dd42b17bfccdef58d3e6b3d9c37652f118392436534af2384afbcccf3ae8753d82dcb3b5568f3ec3f5af2f74158e355322cf8372c87bafa788ef57f1ee2f211712c3e34b3b09e0bc5108e4965bfa699c87477b8bcad898b54fa5324b7304966e2760988be605731d03540377fb7d93c859da9f79c26e97554ad716c8e03e2af4e75480c3155b46aaf0788423ad370fbb76662ed85cf9088a98a8c184a87577faf4c2d7275ed5e06d2ed4284df669aa346256e5e4b7fe113834b976a0185fbde530fbf9c98e42854bfdf156dde3aced9634a360ac9fcbba1c840b061dcd478139aa634ac4e9005a955d8129c94243db3aa5dc9fabc1791d2426ed6dfdd37940bb0bf98a10f256ba873c841ebe6e834d162b4ba4e0e1df33a3dd6ae4cdc498ae562e0c59cddcfac3b31306c55f9441ddb0be92110102f7d2d6131ddeb2deff6c66de71d0aba411423fc4ed0d6006f070fa242b8a1c9c0c7f430ec42c7655591574a1897a40c20f758363b614dca0c9326404cfe26ec9163281dba51664900647d24dde8bb7bb97cdf746a72b31899b0c7c5b9be74999b1efcbba2d132ecef301ac52b8c4c692f3155a477d338b983726e337634bec68702f51c456b18439485d3f1fa50dc76bff20568271e8f3f4f612c34a95c4b073de33cfe6b06615424ef58c1a468cb5c04426aaa5dd66c52a617417e25a488b2e330012899dde5c5bf261df3ea0e4b8eae9906d48da9a74ccae4da326afa6bf7381bc78854e7db81feb27f8fb1b9dd08e45f615f6be6cf61d6d832df778b77df2900147d38aef1e2b2347a3712b82d2c9269b4ad54ef65bc111f132205c86a0d6a0a6ec2413e366115a4a3f6126d5be771c88c2498959a162a66703ff90c03f35fcad3c48004e5f54c231a93d20357d66bf232e1714cad958c500dfe6e660c24596daebf8cfd013f69ad9d015ee7d3b04ee45ecd1aeee291131ad92653d25ba48b822fd79fc26fe28cc0e7cb1e653a388c7e31411124c9f4982b338f6ed052aa0fe39c3910f14416e26181024fd5bd2abdde404f53e84843a49844f1a1040ec860dbdbc6406396cdccd732654d8efc0307d00136d53b43caa24a8bcd3476698742e02739b94807762d513e9d72c97a809160af214dc5272b80f9ed3a756ab01bdab657e05ca3657c0c33dc641b6e7fc48b3604182f7283466053376097cf87720e36595776614fa9ec81a5c6b5606247de56df2dbde7036e89f91c35930a201d49655f12a20680ec7a3bdad0c4c5ea9187bff9e060a95026c6a4d9e5962c21823b47df23754c6f51a0052efe4405a2127a6fec3062fed881598caf0894e66a1a9469916fcf779ea8a97ed4dcea24fc9eb52ad2326a57f6728679bf7537284369d6d394ec1ab6d351b89420fb21303bba04ee7a5024b9ded72790a407421fe5553fc311d5de6a1eb28a109a637955aacd3d4550c7e14f01f26cdcde11e17e8a5cf6675f17fbaf32ade3cf24de2d7d26ff7fb1eaa5ee666e5ba3615d2056efd09a75a50ef9f4b4f0a1450dee5f69b61f17b19cb552d566c0136bb737afa3ddc099384257f8f3292542ea1dac28f1e92e7930a002200d9b02e21163a7fc82bccabec3cd7ca78be60d199914489daa765bc749cdee2e88ec79316bd65f0164ba19c2f57560a6046a8d0e5ea3f3fe0e9b08cb9ae19aa30bffc5edc8ce6e8691b42572ebb610d04844e6a4bf909278210e883ff82d46277a4dbb03ae505c93c29b5f35f36c60e23632188d0683b732dc5bcce18d13286ab573964421540fc2fd9746845337262717832ad127a99226f1f84e8c2735f91f0aaa27ad993936b938b8181b353407d369a3af38c400427129c9ee6754917eb3c79ef56cb6755130aea9fec3f130151b158f70950edcf637c93ffecccf00dca8ae4ac1b0779734d39ce5bb1a83d4e974267cf91b841de9433aee03f84a8f5839417c2294649930d6ebfd38d5205c19f2e2518a2a37602d1077a82efa9abd311ad1bfa92fa02a1a504fad461eacb67ef9e31746d67de11dfaf2d66f5af0799925504b3b42759faac17cb18602261ab414ab8c53b95f65befa2e65c998b47d2887d2e9e5b46f34924610cbdbdec5288a10c399a6f235ffe839d1ac9c09fa4faa445ee66ee72d30da57c969b26fcbfb5a3681afe33384aa052e1a7ed83725df518b8204e6cac450602e868a8e292d15186e1cc20d901988baf1a1df3eec56d8f5aacd58ab7c9214823b220b30941e6a9173ba468ec21ddf0069c5858df4106c96b10cc005176b42e49b8a5f7e7776a3a9ae1c36b9b956f17416dd10d8d9896bed0d7b5b6e7465f0352d4b6c1a436e0140085445b357b2048d7ff991d1c5d598b0856586bf968e69296ecb191ee516fab536b7d344b647d0fc780c0a1827cf6cd301af43b33713e1f26a490ff6e53eabffda8b537aa47b81db4d987feb7e7ccea2fd9bad6fe19a96eed51ff97a2f092686b6781c9da6ae3ddff1b9e4a89aead55f18a1e03f8b380a7ac2ff0711215c65c640a24e714d541655dda5e66d2f54e78155a0f502893833208e52ecab92871397d7cc96c3aadf5f760e04db5323c7ac87f7bb1e690c29fa09d3cbf05be028ef4a1b1ea726300fd1adb2be84a4108d1652fc4f181562dd45562dae313ded11177092e63d8adb79a6764f0c92aefcf5c5e53c0f82f510bf474207c8969a646b607db22ff8bfaa0f1bb39dd3eff3c3da8656e92de840e2c29a2dea34a64c5d232472203611c4b9560ef727061623e5d8c7297df8cbed95b0b2b91043e0f5181766aa4b05eec85920c4915d7bef7dae1d3679c0875b7f9c72720ad1f6a9755b3356953e456ae47693673ebb42f4460fca4ca6a2a95b3c94a6696569799a8edc67ebda31c88f17ba07ac1f56b3d73a4b561f9eba9b2cb5b2f9ae13b45ff569a951c562858c2099039572569a43006ef76b67d72902c1a5ad2e392d1cea0eda448f50c368c139e84232c323b954baf77e4de3c4439f5e5a927e39cf86e94daac8a4858aee8c623828965cedfaca0085e42f942fd1f18aa49777ab15807984fd9fe313e44f1aae85a8a24b54878cb3e74f726a7a472773a3fc16dac7d946a2c1a008aa20459f89fd3d9e839726c4d469d84dc6dfe507cae622d4f37252ee8cf4c8ba105fe85d8cb835802f9f4c34ee62b43e717a09baa72d1c11341a7da70fecbdc18516a2fc9a9427b4db7948940775935730bb40ba834418804c6c184c12ad434da8275912d5e3f43ac8feb2d2d65b3910f2838e9e3dfcbaa68bcf3d84fceedc00e5530831d44c41ed7f34dd2006edd455eeb84a860097822f96c705a9a8eb538d204ee28c011789879a75274143b7ee0c078cf5b0cfd9ce0089b624a965bc63ccbec79dba0d0816f8484aa20915222db96b2aab9a3ef2d6a26278078e2da3c1dd29594571f8aa2769083112d8121099958ee90d40eb71c51fb0607800d3bd9609713eb64bd438a9876631e096a52eb443b6b942f45e3f180099c386453eb7f62a7c2a0586c5987944f5420fd45857a1c2205dfc9a6cbd2ef5e0fcd524fad34b0df2304cdb9bdaf1ef59b443ff3bb25066acdc30b3b16d146b2acde392b38774ac4cadf684337467443128d7cb54ecf7857e0a2aacc20a1c52761b8dbf6196c61d64ba51d58dea822767cad7af8720ddf18b442e15a4c83c76ede92373a23fc3a3e7e649885e6c88271b64888d95c3c47799913ed33b5a28ac5198478890c84fed9f1999679310c6e173abe6f964fbc05ed06b9a2f535b1ace4002cd80148dfcec2416f8a89bab01f5b6ea8cd0bec78ba36fd79f14925babcc13d1e25f5fc0920d9794956abc69837f060ad5790f10f00503a81f253db5ec70ba2620a32f490c3449c134cd970934d1c60a169e0f82ca4ef8d471100e7f434da015b93d368b10031606cce8697b5f17ca1e43f537406b3a7f6c12cf7fc99e52f6a61d901565f16c77ba38c67741874064a4439153f1c8acdb3a4e609ec79a1a5f2236ece2e2975c2165e81c17e7027455a40beec449cf3448576d5a26d1e3818f287d84210f8fafa3fd4b2028ca76732581fa3ec4d343ada55577bcf95b933d305ec8f7c30a2114ae4e8b4552b9ff0e7ed0282dbafd866f57f50eabda57a0379f9967eb641b3dc0157a46f6cd56ceef37a42da819a4849b28c1aa79334ac05f14963424a221a8bb4e6b5eeef9ec9156f44d22047f3555d9bd9fee96b354c1719f3cc746ff12081f4956f4a0f64193e2798613a50f58847397f3a89b4d8cc17fc36c4714baea3fe45dd7290aed3a3cb4f71b038e9bb3d457101bdab318e869fc2ec4331b48953e818ddc704a70ba8d61c7e8fffc9cb0a705864d50e0583e762bbd2b230cc54b9fa12f214bdaae5bfe01f98813bbbe43a9786b173d15de99ddee162941925442bff67c2fb97868a02224927426393d2f91e50f658ee843ed7e95368504b20e6a407fddab0e554271169198eb53215c30b01bfe6299fb374b556f99a064838c54c8633eb5c698885e001f9adcaf53716daaf09d6b4b3d6530b39e4226c1d91140652c2be310063f00102f53f4a3da7c2157d39a908d57002ad7ce0cd52f63b3edb1fd178c481b95ff056597f2d4c7aef74c86683d21c1ee8a4d120477c6c3d11e48bef0e604c0855ad4e1d4eb7e8ae0f2ddb8768d5a3f271593f9401a3713cb17d00f6eaed013cb6d243891bd98867467e94054956e6e4cfa2fe6bd573d02383fa2c14f196683ae45c518d74d6ff1e413a29ad08f7a18b911821885b20c57280bf0903177a24a704853fa5c7a79d5d713d4935acc8aaecc4133d5350772a1828c84e2985bb471188786d80c4062cb3a50907b744e065d3b3cc2856b346b2e06f40b480db2adbe605322065e540630150ae013d97feef6d9b6a64e4271ecf4c981e804cbb4fd81ff406821e27f1f2a726d794b9114b2eba57d5c6204c3fcc209321d1dc527c5fe0c1a1e9a8b3738641944d1d2543d843c36c15b5fb5fad6c989f9b954996620de2377e5e5f8638a655b9851042a050530ee76961b561716c245cb3766e7f700aed1c0998f61268346d8d06e82c09e8c9d54b7867ff66452e23e74d6483dc429e06c7208570afeeac1104fcab82c9d47d0c1ae1dd76a6e78921209a8063f3c1e3decde4c185a603bfa6daca9bc55e51e249c41e9ad6cc778bf4d695c198258bddbace8de63259402339766d5238c2a15c5f1efabdae5dd543e18503abf2503902a8ac72e40ef97b82b32de5f2a9a5e18180889c9e7fa922af654c17c333290aad8f9a1b10ed166c15a98237349b60dd455a3be1a07b2b18d7dcb1cb8d859791541233095d8d67dcbad13ebad120d8bc666f0963447ff3ed00570e17acf592bcff009bbd84fcb8f5582c9ae0381eea557a9f875a0d2cf62129e79f3dd3c481bf1bf6600fafe920f10d85a18236d978375c317e491f1a31b7e06f6b6ba5505523c7724f5067bb0bdc81f58dcfac8b5bf8bd1013b0b750958304578085d2f15793768401baf1dc6ca49f4b0b7085c6cc8724852fdd53e181e593afeb17d169e463f7706ec0c7b5f9d5c53d2743e5487725ac9e4d8123694eace5d1c221d50b816f5fbec5e98a83a4eeb635455b62065b91bc7c9e21ac6fb7087364196e6dc8384701993c0af510e58951f24067825723d37350dcb736e02d4773ec9d562aefbaf67b7ade1e6dc19aada9db95b2660c4f03b829c846ff4e8a1eaea717b0b5be2a18ddbcfe3ce6b8d77aa2d5ca001178e06e85c79a98ad0408679e76111d5ec24cde96b5aaae56c7825e5de21de2b32d4313e4a3bd69353f5a1950ae722f76524f7cfe93354cb02706e192bec8b2c6fec8ed2df10aec31fe9534254aae2a13ba3d68d2e562738e364e345fb7a69421022dc2696b9e67d92248878e2cf664ce4c44e30d807fa130429b01555f51914516c645da3f03db568b7decce8d532b4153009bdd502afc8ec048786c9f307caf096d6cde72928d6c0cb79665c49bae4f137166b347236a5528f010c8a6f36e5717872fc93417c516b49899c976c28343b57d7894580ad274d3433fb847fddd1575f825d4c23c7e0d913ae7813ffea4aa14616e66ae294ccdb3115f8fddbd635aaee82982549039e0c9e93c6afd245903f65c4a0d26f8d6ae5f6098d8fa02293739418916497b39e2bd68cff9c3d36a5ca6865ed8d48520680661ca63a3da70fe6cd2b404823db75dbcf101773a756906cd0273803f445cfac38d4689bc6fa30714c2fa66155ec20af92f9e761782a3b54525aa3522bd8587689da25b4c0ed0a54ee0a3d920e60c3ed9576cda9577646e274c7e343419515bdf8a8b4546ec743baa35089b21f2772d604aac292197bb385dd119d90d146f8de32c8ac7e84b1d089fc5d2e3811237987a51912db0010a42beb2669acd688c694d0802e5abdff6e2e66d30312663fc9cffa5c9774bf18683f6886ec9fbcb582fb9f0de7a05e454b3c2ebcb8b2aca5592d9796242100173de82a431de6d4048491a1c27500408d0a6fcb4274bd78d308923d6cb87f505c3758fb99d697d5c2af503bac5a899fbe8a3cd5f584cd57975e3721e3a99ec98556ece4abed4b4900b9e55bdb1da35722f2f28adcbdecc4ffbb6a8a496dd5fd08ca636ebae8e303a23408d87956801235c889d95b0f4e31c90a4eee7438a8b130891ab4417aec81cae66dd32de836578cebac2ab02b940ad25bef595b64f2bd5146f9b67835108973174694019b4e17f11f94332737adf372312dddb1a0d0a41ccd56c8b5838c7ace23f74997fdcdc8d78b34942596ba72912b7fdee4d6b0502759955761a42b18c476c44f0d40da265a3afdbd4ae79aee267337c6248579b1a82c21fd17f5781493dfaefd6213a497d62a5a363c8224a8be72263390654c1d89d04f8b5d45aa04ead5fac1c35a7ee53354e45fdc245bbc7f3999da39b83ed56354612e7188ee01eeb29fe86a4c6efedfef7bc3b4bfa5c74d212e7ffab013a8f27b28ec9c0916adc0899513c93e73c2625505d5f3cb87192d9527135497ccd708dc4b3d2518da78666d0ee99daa6e44cdf2f9eddcccfea659db7a347f73d8b3e588ac109badff7e16a4d0b640a93ef4140b15e5cf4c868d25413b136a5253981c2acf7ddd2483689cbb3a8dced123bfe796c4443a4c871f3f1aee0c8ffa87abab71a6700b9eea38f1d0de88ff826180452a8e08d7206a5626c9c98229cfcca8642c1d14829ebe531ca30b3b5c95c72ab26d6730b37b3fe95bad4dd52890647b00664d16063d2b4bfe9c6d7a97db75cd7f87e123aa6b89184af053af515a605d8795aa9ae2c46f0e97fcf528101a3e680c79939788a2951901445b998ae1b3e805d42e045962adc06e68020828f7c58af01b5227ee42830896f7f1e014836a3939cd14d8f9d5faa1708d05d3d3ceb797ad01679ba1d1dcba6fe983ff63e22e540eb86c9a9a0e1a592ec05844a3332a3d9894966313b1ccacda53a794bfee2d8ed1959b36d792b6707caa36832e7c52c8ade4c80320de30a5c599f6d21fc6c0cdec018bf191839b6fbd5568fb6688361b96e724c5cb303796ce520802c2026c69846571b1d61286829c58334d2453e7612e1da87c4ab84df5dd20b72d5cb5c4a459a13276b3d4c596006a0e9fb3ee637755c3ab93b75e02f19da68d2fb8dd1ab3a6edb1a90ee4163c4fdfbea4d41f14d137d4919c295d516bb4ac70dbfe0762353c2f72051aa7c6619420fd356759806e84bfbc0803b7c31174381ea9c16aac6373ab4f78b16d22e78efdec9cace4ed1d03a6deed4bad4d887827154e6de5b37a15a7d8fd9ef462ebced9b41bdf6add723f64a3900f3a391902825778a9677c4eeeb39009565c820e46d714163453a70ab255ea123cf5c8f3c66ddb9af310a07493e6a4228045d360b82529c413854ae4a3a173ded9e29f60157f70fbbf5c4e387ec5f0bc2cc1a8870c222a351713701b703fc186ceb49ea87444e9659f92403e1cafb6ca6e04d76471bd539ceaff77f2a3d4245c80de020e5709480e0c5b619277da261974897dfc37b5678c2cd6fd33ec2ceb748515e06f07bed0aecf578d50b7d13c9919a8a375caf0d1912479a8c7982a20119226932b507fb4fd727447e047ff9c2408081bdc6a5804d169dc958cc4857eb24106eecffc01cce0add65c7032dff1fb8398279ec1d5635f56dc07da41f5d5e083a2b815885d86a9a12c0900bffc4bf9c1b6daa3db8c793df05d895beebedf5c266577587986c641da616838a8f220ce1b71f9b13089b029f6c2c28f830dcdc0daf281debbad7c0dacd509ecc07bbb152f05b8ad2801bddc26adfb2be6b3a31867b424471a08cdc9f970c9c44b6a04918dfed51c88b9c7402f30e572d48767109758e29aa5dad17a59f06a8e69f526d458fb568ddea4b4c73da849e8f99aca8b4bfac75a588f78876eefa5cfea175d8f362b8331dc5258c6cf2406220e9dfd277016547f7978ad501239519b795abdb8202bd46ca20dc793d797fad2410aa173531da973c6b84e91f1facafda3d1cee0656f61111d83951484559791049040df768f453c90808225ccce8965c31034aba6c1b9c7f54ca4281cfdd6eddf5ad79e5f8974b7f273faef7dd4553225b37422bbf4aa7fa98d897b43ced01a9dc8a4b65b864b4b57ac33e67d72940c4449a7a15667bc04a36507b9f05a9029636ff274ad5af7182cdee8e6cc077a5a6f0cd7b116314ba2b43297ae93dd69af80d994d17174ddabc778cb593652190055136dadf914b9c57f30a56bf6a96324d40558402209db38b8bb459be853c9ab6b59db8212e872f5f4fcbd33deecbadd953caac8f0088b9b3237a39d3d9bfca9438ac581a14b9da38c9989ce5519141d5179899344d4f3593c915764800c4204ce515e8b45ff51c5c42b161db7a70bbb49fa73f9d283b32d2bac6c795f70992264047b5dcac79015272172501d8a7ab217e24b51f7e2280cc043f48c86675c8ee35b0b5d7dc2ccc2ce9f3a37a32f6852bc0e7c2349a46ded8430345904f4337673724fb7f2e3f26f8c5be1a550c3f85160a93fc3f5b7e2a1cca6b200a59a75b72c5daac99db26e56d21d80d4bc0e650fca636a6c0920cd4c92d6294e61a0e95e6139962b2b205da94e4d918d136fd11fc37eda4153f042431c8f23b841ed30ca447ddfa0d247ebe004b8d60e7609f74244941205a5e15ba8b69b53b5da85f099b34308b097111ebe35c4ba3143c5d7d537f824a41ecf41c31e2b17f384403fccb531eb8c84242213248f526ed9d69b701b428ca005ddb9e3949b946632ae54af173f3fc451d7d35467a62882cde3c2f2c47b5d4ac33310863ff12ca7c435a05b634aade156f4f75fa6f0a6eb9ef5fe8817fc732d780b87d31be36b904da21da25f3a902ab4d9de157fda1fc7a1f0aea77556777a578f761adf7234447306cab3abc02042ff68c299134eb0c594934d355595a8a018c2501c45bcaa4a7afbeae63e8ca57197a7dec0cca6d176d30fa31246e063f061934e257d2f361980a4c3fa7cd0a3631a4b35f28ecbe4230b9761d7134a72bb97f4bea9739245b655c4acd384c6473300ccf13694fa599c9a4eb9e2a5921739d3a8a5e75a60151ce4f7ced5cc9002be66fe7a45a5026d66de09025ddd6072b110d4c1e449072963f965486bf970613b90178f602d0a3463f5dd93f42cbf1f24da2ed1d1b5677e8d101c1592d9e374cea0a9eaea8881178608e4dd42e80a3c8a0e33dff5f2787ed10310225e06d04bd8dad38d57196a2c3463a43c9b353e58ee34a119ac9fc459ef8d633f688367ad47b942c913f70ae1f07c9a10fe9a6470a39ae83715e88bc35e3b77c5d93ddce6c39eb122d7952bb70080d3284048157b71d0cc7f2cf9bc9e928cf306034ef93bbc00d134388c60cd98244d130a00c04ab4881fe57b228fac3ef1c446857c2df9935894efe8213bc23154eb0a4826ab8263dafbed5446860fda9f94b94527d87315d753793cded23926f4c46ed190918c3caac32911bdb6b92162f621425cf370963bb7338ff4934b9a1b47ffd8030f41624e32a21053b65c0426d566a1942dc4c9174f7a59b916c8fbe5b2bafd905ad6d821633fdd259c953961488c3855c0da36d7e9ae0a366355dbf7dd14f489286816d352f6d6ef6d2f529d9b5ce18427aa069aa87b4bee3fb9d6696d78202f919a43d110589e279ac49d517eeb05decce39fa579789484036c4b494fe15e2d554a2bb57d3c0c3285d314e7e0b2d0abce59fa172424ccf685d3ed137ba8bc9b63fda6dfc8b7f897b19be19878d3455710e4367faed87adc06a400e55dd237991c69e9be07b6c5d4b6a49a37897489a9323ad99bab08cbadedfcaeb8f53f0cbb4d85b19906e0d41636cecccf50e11903efa662ae10f78cb609c13aa6d920b75c0a8ec30b7ec3d34546f1ee4169613f49e006d0a28d37a1c4de52c48b67d8ce0c98d078644fcb9902f66b27094d6099676d11d935dafa3c8ef613613eba153fcd9446e5861dc261b8a0b014cc6b9699d8c9a6ada152a8df70189e71952221c9afdec376c25352a5084bc133afdb2eb14c5a69012c77a55aab73e9b4b50cf60e311ad9e9e17eb9b0d9482221123c0feb448a5cf7d0e540941c9abe1eed4d567d7e6d17eb94e455d2c1dcbf774855b39743e8c99cdec2e80b6ff7815006c6b3e2ee0d7e2ac26f54f7f81221300d9f1392a546aac0954ebf15f3296daf557d6816e396f6e7265bbf9f7a15052d11a135403e205f134eda36af535c20727562d086a7a06e9032afc67d18c25da00642ff4bb3fdc62c53831982df4a0e7d08772d281ce58e104afd1eb28fd272e55ba0fd31497dcb0c900696944c50cd8c41325fddacd630964831c2cd540d9690465ac65bfd202fd58ab758ecb58049c63737d30303ae0930083a7eeede19faa87675932d88f53bdb582486e00c3351e2fd9788793b62048b1232072d80640d101bc5eaae16b8e108a949ee569bfe320d818d332cabbb56df87354d07558b062fc7923940ff3945776bc4ca79cfbf3a5afa5851716f67258ada0207d60fee5a815d514c84e0852658d35693240f9b4971e609e2ae20517c5a26fdd6a90e709e30623bf41c6829bc0f88a3e22a05a68e5aec7b8a3210bd31593668b3d80712b2ab86101d5e80bcde10930af5bbc9816d0ea0bfad80d5f88019f3eb131b212ca31f327b7d1375e0b65c77711deada83e6b409e4ab742cede10e602a688e2309d27a57a01ec3d00de29439815333b60b2b7380260546b232de2474a47cc12ccdf12f51ec14b575ebae3f97690441d41be057d7de2ab296c5cbb8adc33259d864d6cb5ca187cc60316836e238b0f13330f32d7ad281b506eed2073c6e1e5b9fd6da91a47ddc3289d574ae32facb59aab2643eae744589f423fa1a586cfb61d515b5eb38808f2e145e41c6c27f0ca36dab1ae1009d406b31ada39e8cacff7d9b7ac8e79d55069143a088de27153939200e86077364fcbf780d78c38a781636562bafd906731a94c3121252ec1445643775e64aff8b586a673707fa2c2c32f3cb28ddbd4e5195e06bc726e9a787bc6a44f1911a99ee666da55a783e85365847400949c63894cc155bcb77da5b28b38f62656f70e1da0344cc3d6756d735c79af649c3b733f18629c1a93df7df54cc3235cfbc920859facaf15b2b5b536fd94bc729d1cdf15f79c1a7d10fab9f97e07253acdf058ec819ac0ce2ed0abb6be5ff52bb65599ab87ce67114cc7bd19de44576b801989bd98b6bcb6d0b66a5ea6f0b8aefc658ccf77402951d14dfebc8a36e09509f55b57e1fa64e56fde4920145590169e6b3ca6a2c8ebaeaff05c30cbed6ac4a1f264c08fcd0ddff6c1a046204bb3ab650f66b3dda0508b34d5aafe7815be02cc40868d45ecba225dff8395ad5fbdd69750ea42722444bf1c84ed7a279d23ce208c4869234e37c53f6ee71f1442149d8fc36041321f0795fd9bec0911fe06695afa08196e3700befc11af329cb85d9ae2c0f1ee157b3f5411e34ed7a0e9e7c12d794288759d6dbb7290f52bc9da5c9de72db6b5dfbc82de63c9dc0111028792d4e0d7a524454913c607aa9be47c4842da6edd4c51cb1ef3e3bb6daf649ca647c2c8e2b67f5c888520fa6649aa2ad7579611b5a1973aa4b08c4331b6d77c26a8e4dbe215e72739cfcaa6efdee8cac2fc8c12e0f87593cb8222192ecdc3aabff3b8002c59d6baa774ea9f69ed1a5e4c51b080a472f0230fb3bb1a641268555a14a948caa630c676e5841209ea1fe7b2cd286173d604834f3baea8e339b0aa7d09f18db183f29e34abcd76ef8407fcd5ee5c3edbd9d44ce434ab74410c6cd7aae605b39e728f476d8d5ab82b2c3b85ecd6902910322aca6c8e9f1c69ea0848156d4e61506fd591c81702b963aaea2eb087cbf3af5be2ba38690d91055fc205ea7b2ef40a763f2f0645c7c3100ec29e55360ce6a6319f6b1525852abda5c6e384865bffa753a0de9b4c467171d60525253b486c0421cb796453fc1b0484045e15c1ebe0faa6b15f82ffe2786e3cf5a7486853b094a1b7ae300aa3f1ad570fbc85e14ac16bb6c4e39dd88df4659b7a9031f905ce2fed9c93b7a42fb14c6533bdb99c9ae4b59855bc116f317cb80d6ccc6466529c8a69b766a0a1ccfbd4a4181f8503cda99f718b49d442930bb391af249e79e64e30d81508197f7a88f0664dc2d65a3a32380a1ed6fd8ea135f495eb99fa1bedb30f74098222ef0d780e8fc24201732b5346d25847e75d5a6c46ef600e6a7b4f80ededa50feec717bfb884dd9c24bb04aa53427cdde6e0d9a5debd63300b1eb0a467499d3357829b4da2c7878735d6ac0cf798c047e81b17db34c703e3f463bd7f75d23248862e559d3e72fb215e4d46f69bafc2f5e89f8dad0a766986f7142a23b9c59735399a871bc40e2afdaa69859d71632662bdd2e7ee81ac453b3e3a2de6925ded3296d12d1601c30c3909721feb6a18fc4d9372fa79feda298d786a268af881e7fafaf7834b2cf34bca90030b70460164792c96c044fe95066a529304fc85cad96b4e9347236b64ca9496e386e66880a72a65492238e00e10f10d66e514ba5972e55116da3efff5fa7b4152cd5a78e794752e7c7681c8bd91357a2e49871197ecb1c26dbef729f8f006a46494c16d52c8909ab1cafc847a24f265f7ffa63b71183d671519bc3f080d47e685957bba4b2f22da9034c6c2f88896f34c912073df64af5a079509956208e436136db0accc1e92a4e86e1912cad3fd2fbbfa2e3645bf516d8a7c787cd54857a71472ede6b452d08158f8f6be70661057de42f29fe2e5980ae8b89deba51b41d4e0b2d72b9c75c9e54aaeaae93834d426192d0d657e7a21c3966cca9d499d484357fd5f25b53450b2522ad3c74929881aaff3b63c6c3a9a79cd156d5abfa29727a1270eccb7fd947ced22949242da235ae27d0f03b322cc7242b4fda1d821b1a3fcfe56e3d9d34fea5e4626dcb3d803f619657fd96fc6e2cd48a6f800a5e0c0523d3b2c7a837c26dfc37e662384c6ef9e7c837f6474c810bc8c280ae17b6a19af4dfaffeaf0b7c1a8a0ff5705a4e153f6b1a5478cefc554bde738","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
