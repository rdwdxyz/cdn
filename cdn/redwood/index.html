<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2f6c46388c5e5136aa418898d0eb8856edc337b9ae034b51d481fa492a92fc6d44c6958883181e9f52d5cb72b128989b7e37ad0ca462baa6bb2238cb30b25eb2a5fb307b2c876240fab2a515a116c0762f2e8f6afdc5f524eee0965d3fbf04be1006abba34fc0cb8c6469fada888ece8ecbefbdec090789e4f6338e5944608c65cc16ecfdc6d3edfbc2ace7a05564916b1568020035aaa83dbb11f521db74fc926d864a7086dae64042d78a79a3874fcfdeefd1da6ce3f2b349c0243315fb6cb66913f402a51b05626216314439461e8f4933b08ccb50cdc40905ed735c06f43b63c94e4a931e0b92cb504b0c2dbf2872e35e347b3eea3fdd8f3b81ee7035c19a3f115a978cf506cc52b092ffdfdb34ba3c5f68a6ef2559eee78cf38a96b71dd2df6089e54ff19381a68ecf9fbf90511d5ff2a5601962aae1258d7b283c3afb9f69952f8b511f5fb0f8ba329472163745026d15aaa432de7c5ae7d597134c8e5359c70f7364c7a950c8958f5c277d3d3b32159dcbfeaa6b042da8acc305b438b1d35a4fc00ac1efbcb00f7bd7f32f2bef4f4e76b97882340f1e4e205ae8607b9757816b20d01580ff5e94f58db7b342d55895a5058323c72e560b73ff0988550c94ab5990a9004e52be04646aee7a08d732e82860ce160d50872f0c8404e63454ffa1a63b3d2b7d7cb31a73dff4e48a95a0c1d53a3f3aa9c4f2a2ba802fba66f3e2341747bc04b8696c5e7bdb1dfba50c7e0c698513326f112bdb520844085615ceb8ff543a2786b9982d3b0e2c5fb607d454458e5b8202d5c71a552df09289ddae14241e22577e41b366660290a9920d42d1f579454b1cc6936911843ac08ccab8262f91600a0e56f5e5d5e2a1e98fa261d22127feda5a9e3c8490eb5eda5690211551727e88be34c4cb0c5ceab59acb02e2eb096ad2c5d224d0b529057df93bded49500c68c6361cbd9e2c16cc8ab456d4f6dda5e98654b97586c922d513bd750d89b60946c0b1de45d68e18c9889e4d9840f522306dad0438a88d953aabb36032d06467c50accc2a51656b269944b53694accccd864491741d6d4cad0886623737f4c7e91fcb29338d619e3ab00d221fd0c91901ca13c2644121ff9312479a3a946fee3c18d7955e64501d5fd9dba92a0ad5c209e9eed2cab0ebd61d0f6939bca491989e78e4de068b2eaf622266099c27da486d60d86adef6086f65a6daba6f63a150e5a6bb0ee535bbf7525cc1e71b6713ebfdc4d7cc038094080a8e58f207dd0382fc2d138ee941df2d9e00fb83e45c28824a66f03e211f2d8bdcb7bb04ab054bfb1c282fd7e56ee587f721e7a3699361296f847348c8548339d07e5965a5af2485c6f78259e6205cf6dfb3dff5ee9e0949d0feff3773bc8db75c3fe2b2b11fb597572c4749f03319f781ae3d676ead51bbe3be13402d0dfa5862a9965c0f90070b83983a4b703efa5892cab051e76a149d54e3418f6cb579e5faeafa1a0eb263f15886761072d57a3081e9fc67a3a8b09e28f91bbf19ef1ccd05220dca75cfdfc2c5898fde9c7558c825eecb5574f5cfa0dfe20a3b7ad4747d45bc91eb0550f626b09c7e2fd363a43938983654f1b8af09c4ab015724422adf4b5872560921874e4809541919cb14a48e599eca5c789b7745955788f946a919e0b761180c4a64f0c151e5d9e18f0a1d7f1ad19f6877736302a3a2d5e50424ecbe9d1599717ab6bdee5703a452d6e75659a5e34babd86b658250a80d90cb4a23b2f8ad78d7f3ab73b5b03f11dc97fe51d31d5f91d7f688f344e2b586819bd332ae108dedd1f6cf6dfdb0b6830dc213f78c6c87c0afb511987fb515b756c69857350dcd145c8df3e55569b3542c2091a7585ae0bd891bcc05b1ab4e5ca6ebdc74593e400db793c259ff5521138d965e494d8466509166b8870a06bea13e18cf1b63cbb0da173813a8b225a7400027f8fef96b72541143aa0da4c463a5a83e5351a1cf7f65666737ec3fe0b95bed038e6d3bb2a47539931ae5cdbf5ce02ff632e126472e0633e9579eba4fb3a03eadea989368cbd8950dfe14f68564680e5f035131df0eb8d6bde6fc88c6e6c7e8a28ffdcdfac934eda8fa0d7e69f020c3aba806a520322bd29769dcb70408e53bc1e86564edc348f6d7eac4a9ebe1ffbbc2e9640f64521bb53cad8f284888244cfeae3ded58bc4eb7e4534bda2b627d21836a23a2a2a65710c0051b6dfc7638d1211d8051f86a2d1235df2b5109d2895701e0071fc1f9a94caf3eff6728f337bedbfe47546bd12f53af22072d7dd20f1fcccfada2c82cbbf49e7d88622c8c81a5280f9df471427f90f1cb059e8fcd36b10fcf55b2e3eb8713922b8078c6b4d5f76dc05efab7e7e7590920a52596dea06c34bc81942d3f00b87b61f62753b6b20ca7c729677e13bcb584b37c14c3875b22da2f7e70e987796a75787fb38966e58ecb1f5cee8b43a57dc13eee53fd076bd734c5524d02ad74d1cc9dc59a382afb9fef6ed049c62a904c3d30672c54ddbbf311d8d3f424aadf0b588f1987ad6e63f990e7e994199e90a49591a559d8f8448ce3bc0a408f71cadff216236b48b8d38220ba266ad2f5687401044fdddc3e3e6773a54e8af9ad5462a2fd8d29dacc452e6a71e679079cce58e6d0bdbb41205488d0bdda4c15b6fac4512a853aea61341aceeaa842ceca9d5ba6aeb048222c8ca5daa1d2ad6fb3bb2da9b1c0d1646733a864ae846dbb50bb0d82aab6db9da4db0bd61b114552f7509f136871bc21ac98a15c8a4ccbbedf79239de26161b522960199a6166b52658475a2dabef78ac4dc87ac03d64f2991d38b350ef7031d757565b6a19b001803df61d809e342792d67ebf0b3bb380fe3c69ba508964c0150bbce05d624810f1de3a26d0badbcf30e2a199b7d5c73b5a1bbf22186a1e08b4a4aaa5e2d583e46103b0801a38513a815fdceead6732ec4c6da466e3e0b3e179fad90d911d8e9f8ba765d824c492c8e647a2c707cac70d672077aa2e0d1999a6a58950c3038e843eec8b11e59dcda825c135fb080219a7243d1fe1698c9f1930e384a1e0fb8ef7ce04fb560c036b711b2043f913a03d59759dc61766138b43ca00df737eb323e56a3dfa06ea20a218cdc17244cc3b37b07c28bd3ca2c0701d6b0f64977ed7bb67137a740dfc7a2642d2888529aac1079b7c3927b7fc245a6d448e6a096a35e6008d3b4d6ec11e3b938c1895ce67eb6cb64f74a703f94857fe4e3de893000d514bca69d18bf6d5b06c505220ab54efe151991745f4fd47676d4da536b4c667844ed13848e8448e0302b8af955f3730d1d918756e527a50b2670844f22f6735a935129f6f3dab26e57b6ada1ceb05d4fbe532a1746579f41737f75a7e2df6fca79bf015388a48d8a021c77c39d8cfa259455a3581df572bcca1639fedf932ba0e0c41694069032c013eaa9703251dd7aa9607ad95f37b1bd6d2ea519fcde0ae3931cd73ad57e453999a580a50ca1fb6000c7c143fa1e388ca16edf1b107714d7c601176e1bbb3cd1b77cf627abcd0d49e2d4f148883525569f794af69f462a985a9f6222ecdae4f366b0fb5162e71f4820cbf87fd8f5810a77a3820519b6a3fcb56a280c6aacffdbafc22e12e4de488077c60d9c3736b57847bfa5a8ad6e85f51c297dd6e84859d94d9710bc67d53d26dd278809d4ba1e2de16818a91e2cf6f8a3f3cb62cc7c38294bd276432cbaa188c6c2596c6525cf66a6e29204c86b08cc5f46c178d189bdad42b979b87e28b822e431a2fa4f51ec035b078c1f9f2feebe057795e62f2757af3ea4e1ee4df58061ca4baa7133eb08b2e577b5ad4b3b9ae6182c499a00ab9cc478de2596540377d97a3137aa984652c31581b56d317d2b32792607e8428e4fa6419ebb2098aa3c00b60324479558336e963f537f442814206d6bbc14714c231cb4228bd4952b17c352f2589dc249cf49f4f27ea0ab88e47704d181c8efd4cde090a9d3da1d2413ef1aa8a9a87c3e28cf0c6c2ba5b85179b5ba1748d879e0c247e8a34ade1adf5cc4d76f608a33423816534b163a378eabbfb4c422ea5627e7b5fa3bf1e4f6496bff4acc3e6eb3056e1f97725cdf62e6a8078ddea4e956fc982c53dab509144fa6aa7a53328647d994123eddf9841da4ce4e7a127ec16a37218d79e18597823fe4704deede7df29c6ea7459b685d254ca7e6676ad4f43a8bc7e6559400badaf15d7e7e8e5df52d0fd29aa2b9e39f2726723d66e1b043f3480a5ddaa083f9d842baf48c17bc3df151e373e08c2cac2703065ab3d8afb4df16cf587c01a275a322a08e8d41ed3579af4c57ed778ce8772f6977206673324d0000f235197f39e7a43ffde7a58acd792da4f506285659d221e8356cc94f6a85e998d433c21c1b3e342bd1a23da6b483f8ecab482fef75a4fe92498fa43dbf1706e873737c339a0098ae53d10339d0122e14d3d0a1827525efd03fa6e2926e56e1c67cdbbc4900dc47c3ed63f6185ad210300fad4a1221c57655e03303270cc1fc681a05b5fb05800947248554bba8de1ab052c2db6fcfbd407d8e918f9c47d95e4fcfba833ca92850a6c040a841379a9eed21761d878a47b0c0c81432befe45c19c21c754ddd5910a85f290b681d2d73ef56cdc6557ac4afd84bd77178adcfbdb7187dc5b2bf24b978f70b04fc0832b0401f5adebbefef3f556d7c0c5e5db3b78df4b22ff546e1c714b23c0348768552ac67cc65509d0ef1775c48e75516761d56f1c081d0dc23eb568773da58bc123ffb96c0aae745ded41916ce667c6ae6d0e8ef00be14e96f0d7036a36af7f25ebc610f690bde959b2be9f920815beebc51aa5b2e76ef5c9ee57bea7c6df5671b3bd8d3e09e48a3da71bb46e44a776ff1b5d063f5a19d831be991992b02df982b6d9de925b7696f50e9fa33df150235ac3ae4697e6172b557a10c68cc12995cea70cd2f20d8f8ce117f8f9fbdef00702de51bf9de547eaabf6d783fc27ffbf587e2f05b79cfefcc876648c9651d92ae3c3111294e8fe95b124e5fb83ecaeff154a6d28882107f655784c406f7e24eead88a8ecd01196a2791c7d3ccc5989ffa82c96e9aaefaa671208f760e6611ee1f0878d9c8acd559c12e37ba8fe2bb5a87e4fcc9459e86f2a2ff8355b6a2a2e1b9fb0c439d967f31e4ae9b062a0467e4ab51c2c713bd2f2335dfd5f61118621d39e60ff288607c75eef72879f64424ca9e9f1a40e0eb2f4f6645cfc01a7846176f3ff30a20cedabe3946233b41911d3253bfa8043acd2ea9cf3ec793f3adbaee686f94d4f3208280bb5972fb42bcdafc4d8ed9d58c3fa099dec4ee92457edbf1c8d6ad44309bc70e9e9b0c97892c097135b18e880ce4937623f0d329b3b8e36dfb1c64861d7db0a67ccacd9ebf8917794ab5ab1ffcf848e44637a7237819141587793e405ebb05a529a22e11271c017ff99f798d1973ffaf2fdeccc6693d75e39dc81ce5f26837cdf09b3445db754d5b82f202398b47c151a03375f8f8e64a8fbbd83234402e0d3e791d1b171889bd4514ffa58acbb3bc274c280b0e9d6d920b00fcb1d6f6fdf8356de03eaf7de083a88635471ce3126be26c43d0b2b62862be2498a5bae7ded875eb872e369cf6409d2302d82423c6059992033ccba3bbdb08f0aa58488d543084c25fa3d32c824090032e7f8c1049570e0975fae5e3c9632550360055b4a06795660c3b025343dd9fc737204d3acd00b6a62dbd121d170b8f3f0d096f835e11d28e9ac0e04e4d976767656a0e03bdfa666982299da0d303f794de7df74d3b9a7a8ee13de8b2020ba22953c9bc340e2913c8ab7a2d3e636deec9c13e3bdb3e0a3d623d2169af88ace643796c31caf6fdf5826b09e6a34a98443fdf2d7ea7475612c1a8e64fa88705d15888919c4a2c29c266c827ed8606d51731f296adb0fb9fd511195705fb90a0f5b8275872a96702ef2eb0c22bbc9b938c4ad98dad5f2a15f6351141d03eb6d58867fe9f7dc6b13ca661b20189e3e0fd1303520da542c0950ad62845760a6235dd145c222d1aac95bbc8a458f463bc44db7af6e586952b5f422bbafa32e83e38f47c3d77aed0ddb4380bcab0e890546ff0d1182b818087114ca9cded28bf007e87c4e4b534ad6a628648ebad62c6ecf25f30b559d7ce825bdff3a18c81dfd8ba129d279c084da14f67491a61df5acb09a7172b17413d5c1688202d623b04316639f1de5b2c835435b60056ec058ce3e3bed9f3bb165fc154a92d4db7da2b2b3144ba6cf165b82f726efba4139c670220aea3bf19999601fe8a466a204902a7e17b50d164f8b7f4f949b60dd28d00f5b3222c48647922e3e6da4626365f5248e4cafed42a2739db074d41ca19fbdcf519d5dea9ecdfc1737b2cdc15574b8c6331b0d9a48a8ceef736770e863e9ec29339febdea301d16bc1abc373d2fc56423959a8908cc0340193a26119658c4ae8ef902d7ea029d53a5d682c0aff7c1b0a53cd00c9503eaf1324c10ca0acf220eb6faa489d6105bdafa6f46719e500fe279b69363ece1870ba7df2085367ddd1dc545a1c2ef8882069784d705687dd30b6d86a2426380e4c75cd854f5a850ef6cdbf020a4b17d39e891826e0e1e7b214546eedb7ccd529b85078960267dd2721e796ac40593a9d0c82b05176d21539671e237b6d2719048ac780dfd7a9179f1777174bbeb792277e7436c249c60f68109020d20f10c39eb5c6537dc7ccab0473ccc97e51307547886b15b2dea69890d93cc2840da1b51f8eeb4d015c60a8102a5a511e470a02eabe2acc350a80974c19f0814b3760bad0132d883a74cbaa04c58d731f9f06c278c209430e757c3f91b005a7566134323b73718efc9e276d5491da9436216ea51c9e819eb67dc4968549845566da4a985070cfaaa603cf8dba03b54e798284b2ca5917501acdf8030caabab98eda526462624eaaad2c35257e7de129bf023d5f95b7f3f05737eb5df0874eee72f9bc781d3326407872f4d26ba01228cb09d76b99caa87a2792f5436e6896ed31570aea97c2c7c11c2e99e101dcbd794fc5ec36d20cb4876720ea0877681d22950bade6d9545c87afd9070f341c2fea79a9f80616bcc725d0439cb8fec5d8911bd68742143550fc4d2616fa966ef0a0c9462a293fb9aa56cdb9ca5695da8a8c7fcf721d7efdc05b43a169f2b7eb7731dd04dd87faa11badb9ce77e18376c9b2eb70efaedcfd7c9ce2656e15133acba20b7761d96c706a466b03103cd3532ccfd4dfff17a11b4a899aa31b7fe319c43663219262ee28d8451aaf3059d2f2e9bcee39b2f0873a7e47dcbdd9922918b319ad1d30b2025821c18fb029c500631f222af5a62331edefea4d1734c5ed6e87ccb746a92ba9419706639cfd7da91e24559abbb8d0c888076f6f1747a8942d46653ef1d49ea7bdc7d36a12160567c644a052169bf0988e5f783a3a25c1b5d6bfde76e2a790ca50d4ec6568158f405b2687ca438ce70b75c5d991a933a6168bcee25d272f7598358416a5e52def89e1b4376274f05ee419ccddcef50a35e63dd8bdd84af78934f538b172fa3ac3e0eee2f9936a2cda10a2b62ca81a4f9785661ce70f012527aee1e67dbc9fb4dc5ae9d87ad8d583c675536e47b9a1e18433c7d097f41492270495410e31292766cc20a3e1ff7577c515d5a902f1eac12e1950e4f8aa99c71644086f950c22c0f9a80dbbe63363513d6b75bd6cd9c5f8be1488378d6255643874b8544e3798ae1795d34812dfcc7d40c545eecbce58c9b77b4e0c0ef5da67debfa9f025ab3e9b37acfadc2b2d34342929883d22feea17c4a3992ca493ed2e5689a23608eee737117cca950c6ce2351780ac38a956887d074b104449e7515c51e0a696c5071289a21f8cdae78ecedeb905ec49c047d51acc42e70649034549e3c88d4fa13aae56c8ec6df5288b7e9fe24b300146f29cfc66f8c820d363af66001d5b7ca34d6a420d620259fe57dbac5a2b6955cc0bce0fa358a00580f284d45ceceee9ab7a35427db2f7bf6458008f725d87ab1e469101b7d7456274e4e9707fa95a095daccccdafe0e9661a9cdeda855d32f9822f7c0379d7859f76252c8cc96f65b678830dd4301a068a4ce7436f3afd70471ffce5c4f5c5704d8ee2c7b121d950a6a15d5ad55f4853d73a7f3d159c51cbac813d6befa417c658eee91c95d980bc5528727d42491b5b4c3e29213d0ed8e854d21e406cb8d389b14af71e831a84c15e819e5e193ab66cebf2086ec41fbf70fb186982405532fde582083cde59ee62a01ced98e78f8dec21fed28efaf4604a628804e6aca73eafc495cb279bac2683b0f779bbd06adab2bb7da9cbbd2b48d50e996f3fad5117a8afba52f9da072e0ef4ecfb2f7bf5bdc67a7992fa1c12ab765c8c0433efc127dcc1ba096ab193fab1395df1d1dd8699c2f6157c0443f810a1b6e19b4ddca088bf3658e2d489a47b3b4b4e76993489d237271696ed915878f7e07eb2ba6ce6b215dcfa60a7c6ca59119f951776f0fbdb99031546cf812ae320c44b3935b99b2f9652774ef7a3246b8bf6852a51ddc5cee0ec022616df0b3f70638ed9a3f945e2676e34e39f2c9f537ce48ab4ec8e6487c01690ceecc9fcd7fc3ea44964f4784ca236362fc5c323f93081902aaf546c9710cbe374c2534f229b7ff7a8a86562e1f01127130278b59c60833fd7bdac9f53e732d9266fff65feff2f61da8ca1ab3c125d066241a41d8e553c94a865bd3f95501688444ca62eb1b9bed5d02d3f7777a52d0837a1235f27a54ec658531a5e0016cce358773a0776b946b956834ac648191c18088653b8cdd2e56776f31f8357ea3c5762f0c2657610481aae315aad19e8923439a0ad3b7fddcd293bd88c4ee99e4e31f1ad015a37f6aeea3f799e8d96003a246573d8e07b724e634c91b19963e06bcf2335f345507a24cbc571ac68ef02846851f0cb9d9b4528d93b378c8b5039c78aa63df580c704997a9d7be8f6e331a2f5f857f855b3ce612b97d15852cf4a8fb8bed6a82a939b008396856189076dde8eb483f6c4289add5c85aede25ef011bb066d1a15ef197f3a47a53484529fe0d26429981c8e6d9fb0e0021bc9d2399586d37e61dd4db2f5273ecb419c3cf20d42629b40ffcc41ec316ae10c633d12243b3dc4ca046c3f913021760c2812010ffffdcc67a4652ac9de8bb1c11919d50dc6ced393b9c94625c770539b16ea1f40222a4c6fc4e074ea84f96a7953b0eb61837b22115acaf2d0f77a53f15c5831f7fdf63176352f16e98628007310dbb37198ad093ba54bb9594382f183fefad3f92a694707d9b444ba3542bc53ff963fc09a12a62ff350ab15b536a054ab77e1f10ae672ea79d5043af2d9b788a05e9f166f75b3cacfae73d25e55d80d8d2fa7e848b93d221e057b1268b352d842a9f255dde7f2f3675991c031cf32b87e17946f9a74b16ca0adbac1c0b0158275af39be1705fc1455caeb7a15f6065cc7d19cc8c39e54177bb4eaa3d1b82de101b9c18018e6dd7919a316e599f04c6e6916ebf46f226225e1ac2ddae2159e22612f24ea3510c67769329dd981523882e3c376fdcdb7638e0430ceca026ca41c1050dfa803c175c4ec41dd479cfb66656f566615ed2df69160237df2040439364c1cc23bea24cc52794fb6bb2cc0f803b9d765e7e732e6c4077ee69fb0a37ffa855f08e6d204855762374f27b3ee353f6f8da186227a2d398f783e53d22989ab11d2040c946f6a7e3e805198e886a81dcc6eb02349b346f0be7d373d032d87d345c8fc5711aa6ccb95bb6d8f8a477cc9165617a27688ac284dae102742722f613bb9a96889a43ee725fd94b24f87f5166bde5e2f7217baf714d0d26ce32e0bacecf0a7a8f69a477e82ad1daaf498533b90df3b5fed9fa6caca3d6258a1fc8f007d4399440c9b7e87afa7c78ea6a6cf61b4c32c2d680357fb75d97dc1100d8e8ae452e1aa93e48902c1cdb8e065bd7c8b10e5096274cb58ce8e7ca2f3ec416a7400deabced7df0e826f8c71641d2a665134005ba70d4066f342a07754e11c82becc6eaa0c66c3b2f8515585dc3f8f0be685225936827ef9dbf60331c75e979e7febb6f85f4096b6e6e44a70544fa419563dea8b24fea2b06c8b7f22890ddf1f69218b7e161a59abc2bd4f0d66eeb3f728dddafd379aa4526bfb861675bc5dba3da368afbfab784cfab6ddc5c155bdaea8f3c88073430561f71cc29ba8627177e4d2e392f5833326ca3a86baa0972112944bd99a9cf1996e095c7ce35ead40866f42bd4280f53114973f3cabe89754a17f9ba532403f45026a53716f59e1804781dd29e1e7c866e3b98b7f2e574cb67073dc3c6ea8c966cb590ef9f32ab6af6467bf1fba9119ba128bfd3981679df00307072922494dc39286bf2c94cbb4b4bb27667895c2a16c81870f655c80d4ca0e72a5d4a20e4077ff00f6d1ed295800a1aadac4d7d887e68ec52e36dd47e3c1dd373f1563d4a054953a39f040ab4166825061d78878f1d0119e40ced192fc8757c27b51da4e1c8ba9bae0af6fdf227770575bfa79771444b13709e2d287a264391af3ecd43606a463774419d00e64cc50b5c8d2910333f7d2152bf912bd31996817400e9a04ef50536fabbb9190d70b2f1eccc30523c03e26add8cf90471dcb96c45c88e28a68623efebc9f98c29c91e4e611f4080ca0eb752547a34f8bba2a9bc07de3545dfd3f96c71853c8d4ca5513cbfd4baa655e6ede98d4cc3aa0f8b56e2575e42e588b513fd7bb9dbf30910f848bc67e3d8f3c1ede6d92fccf6ce18402968e94029d02dd5c65991604532d22e3339d22c58bea3a34ce1413cd60f39d47dead6fc305437b5ee24a167eb57f1a0179398f619c8766d001865f1c9744908d761ef95153d8a3f6b2401b6e6749a01e8823ba69b497cd9df20ed4b11b348c4d027ccc4895621e589818788418641b2500224983992e458c2bd73d012a501e5a6ae4c94ad57a57d5ea60b7b93d18ad4b3c898171a46f4b4bd66d700edf94303dbd984d58887f41dddba39300814b1f187431eff64703a8383b9bae822c77bf732498c99d0eee7545d2e2caf3f877a3444a5f88e43290f61d3b0d0865f4749b3e3fa134c80dbe4d17aff6b8462d27ba25d538361d18ac38e7ee43770149c3aa4ebc42a7e358f73b9c985a14cec8bdc3ba608543636f4ddb3554096d699910d42dacd6231c3fae14303832e90c3d38bb9a0085d31d5cd609ba80efd0ac1c7fe42571dbb84ed5d49637473823e0712bea4f88159b28cef46985befc42aa248bdcb64f0b92534a9e81a30702e8fd42224ee92c2d6a9dc31b5970e1cbdc7f0f2cd428d136efd339bee358e56fafb6039b0d3e9ce622bc49cbf6f9e6f8fcf61a001addf38bef0263e9eec6ddcf287a9d3b37df755f442ab286c40e3f10a508396c602e95aea93476ef790272e2ae775a6f7a8e0e1e08bd377e0b7e299599fb62b78a2007621a588049235d60c4834706b4c32b06870186cae327751b66878aa15a5082b4e86c17667bedc4d7931aaef1b963c9a320dd7e1b44254c56364add006e6558134153c178d357b5208642e80feb784e6bfedf367f4a236f6d96ee2d219ec4a5a6e5d1f0a549ec748e14f7909439a17bf450f6e186d33b509780dedb6c3f75ce7515035d56c77a0d3d7a608dc70e387b8423cf48471f96d798e9ef71f306868acd2824be936e22b042ff7866f039f4861ec27d1f4f32f3fe1989e33730d5353b6c6d6672b55cb2fe53be3dac908e10fca84257815f16f0b355d701b4414d3d8b86cf007eed4e42fe4f08dfa5f80af2f686d19b74f6bb060e14ad69e33ab49b463e5de6cfa0f468f941cbdc68cd68a353aa487e36dd3e207ca36a63698f086542ca97e8a6c5b38c5fe0d6b140ac8b4e6cda37f2396302c029b568554abb2b3148ba3c43d2e76d581dc909f368908b20f40b9395ab25890c8ebe4563f3567b99663b826ebf938c164cca0b12a7ac5dde1e33dfb6c6aa630b10212097dff43aefae4be332473ca08c403e154f81c3a224e6e00d8024fca95207beed3fe31efaf95321a3057189c48886232ca03c349653c743830c55d54cc1e678d7b97e60238d03a1d5f9bd748d269dc8632246f711a035b90aaca19cf23024b0649d111d4174214d94c495b25ebd1987d343f3ec7e0d7447fd40c01f3a827030b9046321f5e4e420b6cf33f725c748d6d40b3e1474cfe7f520a1ff50dcede0e8360ed1888a8beecfebc2a7a5956bc10ebdb1b004d909199ecd9367741ccf62f063a4008d949ffef1a28cf7038157ac966e6ecada7f4ebdeb4d10933493b826db9f32f2db779c69b22d1f7dddc6a5a3636d7e39a66bc49ac28cd5cf1b654dfb9d2654b2dc8a4efff9b732db3872059227878e9867c76234d8a533f4a0e2fcf7f87fabb9e6c2e53555b3bf72bf9b788a1e1e139502c5b1752669ca21654068cf4d3286aad0b83c981fa1383c75e81b2736e87412299bba185dcaa1bc1a9d80787266645cd474b02c99cbc2d02b5011e1b3673948fb3590b3de60690d8d4cc7832f0e5da1b1ab55f77bb1d03a7cf6964d1d90eead2d46b673364657d183243a3aa952f56f3d160cba184d7913797c4f3defc7cbde6ba70ddf8663b47cf0b7a4200237fef27346fd6562fea0538f296a732eaaa911c2cb26d013788100895c33735ffec522407ba777d4d76414105070190e76b6bc84122b4222a3798da379f6a9f16fad5dfbf051c10d4ed17250c84268403e0035d95603d07b06c6ca2bb3f8763f0f21fb3f77b6434883a05038f3fd6baab104273dd38ecdb90b32470656859c10eb06863c573eabcaf624018d11b52970e313f1ed9abb0b4d0a8f0785ecbace40427b6ea4a04223d4be8f690f92375df56c3f8b5d56e27ec80a0acca92e743d0f609df38a153a40b35958515390c248f5246e553d21f00dfd96bbb73774db0a0feeb6367c13655acd52fb24479291233f8e0b8d19a59c75d231c0939934ff65e39011d9f51f98f2aad7b599dddaf91ace1e8d4a95883c869eb2ea291c6b0025128d7a6aef3403ae8d834b10e28dceb8cbcaf235156117dbe634f943f5df2d6ef633e2298f0c3263516bfb42a1ad067414184539a57fb057ab21b6c621859e0c7bd698f4728bf8cc8f3e98f07a2ec83d9d4b912153880aac375a4cb43574d9c7322fbf85eda6feb8ac3e1dfe15c790c2b7320acb43dcbfbd37f4f586ec2840c03d21d54fd7f30d3f1b2c1b8ced19c8756fc2b76cefaae06470987008f82005ec7d8e6f8893f5e9e1966c0ae4ccbbb142acc625fd8e8034416c5b48b50b98364b1128b59ed3789f9b428af721fef09353c9aece87c63e1ab916ab60dbe1d36e02bc7ae80297db6a568c140bb6c45f8d298908d676894332bce0651689d271c0b31884421e2eb5769dd91c19a31a4bff051341381c779f9236ff22109fde663c9879a39f3e95cf7d75a7fb85eb8a57aca3f71564c4338309393cc5903f45f29d9f15e7cca85f75949ab4dc1eb86e7a8f4efc566f78a43c61e8a02063d2552aba959e71ec0297b26e671b5f1f20feb7cc0972329f0ecd0089af2f2cede187125f9606a823936096ce3bac4ea17eb8540ef4ff5e978af5c8f642a0f6e436152166874b688814f8bbb3dbc85cae3a33576197e42e9b1a2d56901ce5ae06903aff3d1aa2e349165c5a44554612083c5cf7b4e1ba40ed3f642cd358bbc714bc51280c809d153ff9a9bb7488c7a000be6632275393cc8b05bdcb4ffab46419a05e97da547db8b6e50f019ce59f74a9956ed5b424af81ad747c9507f0aae3ac57ffec57dd79ff8384c3f7bd48212e56de8141d6a9d6bc965bacd2e7e60d62d61ef851c1a863e91c65632afe9e2cd7b59c5cec62cd38d235c7819ad40ec79c2ae4a5e09d823492baabe2bee8bc5f0077e0cc22d0f7af7ee4bee59589cf4abcf8e465d8d35e70abd074006c0d6c70e295b3c7adcd43e9538f81d4cfb932fe2dc8538153d7e9ee7f4cac00aaae108229c5cd61cca483f309d24d7bbdbfc6c84a125c963e45803271239f43be95f85a453b71eb83ab9f9d1d51e0e5888c0d3e85a5148da51f4d41b53755ce8e9fc4012fafbcb90112f9d7fd21d1792928bc2b2023f90c21d69a9395f836c8953eb4ed7d0883fe1ff9c5d22649afdcec6af25504acfebbedc8408c16d31f1bbd7ebd64b23ac903861eeb1f3448057b779668481c454eedaf915c0f5d17a69c0e8ebf9905b3c96fd2ca5c93b0522a64bdf0f16648258a5b175193fdae127c91eec13c6aa57b8a77a29f382eb715e25453e9c90d81bdc5608404fd586159334d863784b34bef0d295dda28ad2efe110fa4d2363a8a9d5884e1c8b8fa605d13335b5052511071549462e87fedacb4011b9d7ac86f1974fb4728c3c5a7e11664a547ffb04ba8da3bfe4fea17a4f6056d35cde9c8d6b697206932ca4fc07b13eba566a432269b2e1e22d4d64ca95d705c1eaa7536f0638c8c066a0f66dff7395d3908396fd0da0e203d963f64c38f68ea092a8bb7fd3f5464b6a793a568b10a84a2fc40b18d26c2773d3d071a37691480913c2870c166d9089ace7dc82b762848813aeb63b2ac6456a90c2a9fcd4ebef1af03a042fc8938678a9d06c39fe014a4a4dc94721a10b891305db23c6cd1df5d9f07b7df00de7902c45f66875b37ffa436aaf2ca8c9595e1d015563c76d7db05a374d6a9334234b80fd810b8f045dd3bff46b8e7a2cb2fbba7bf158eb919c586e72cc713c641a57b7f8d55ca259148c3e5fe60c09edf5e91bcf9e734643d54cffef552fa4af94f24b3d6b90de474546608524f1b24c33052a58ba5629067735967506c7c5c156195117a91e71ae3862dd784ca00541d20d75046837b8b2d326938445b36bc60a38ac5c78a3545bbbb182ac4f2ffde80ccfea59e13c0d05924195d0fff62966a29f66bdce19acfd07a17a6370582748eac56a8d56ae695fbc93e7eb851616b3da1d25e38178119ec486436c3424c47ccf30cbfb7e3fe8ec875ebfbe818e70615cf1a9a54d9a69dfdfa58b070522dfc1b979fe3c92dfb8a9a0a765483513cfd4412a7d6958f3d62","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
