<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"37fb20ce5b2fab0947891011cb4a307d8cc9a524d318bec11b72dce7c455a6405d3be44cee99ae24ce89f90dd73d310aa69ca22b0e81026d74bff7fec9e0b90991b4b3fb7429fcb85d56a19a84470801ea50d4c4c02844d302d4713dd17c2aa7f7092cb5395ea377bdb759ec9b00c0c42813ce850b34cddf2f40c9a5c6aa6bab4a6ecd7893e5b30456357872cbf568563a26fd67def4d1589d14718e47ad26bd7a8114bc4808e40b5f9f3ef0c7e74789ac382bbe45ef5a93ab8c1fe7ea9a7d2e45f3701b7a68e2fd410f142abd13f1e79eff2a7b898fbdb846fc5c93aece7f2d83e28f5be43c5d8d7568af999d38fab3211cc5aa7594dfc49d8288cfd2756d413d3963b99824e81146180082fe735003b7fd2ccd7c30c7f839ad33a73f00596829d3b503c79c8e9f87c8728a258c78f8f66e05bdb8d44f3e814bb4f5ad4628fa295f8432d933186f7c10547cb1b5ef52c7007bfb21276764bf005fdc01df1d248eee836a0ce5368c7c69edd273f7506a853041c8a2629dccf9a0906666bbcabe3f3afc4550b12b188c54bf60bb4bbea6f0902f18d5f687031e6ae20697bf4229a3404abbab3523931bd22a605810267de5177c0bfd17713298c82ffe0eaecd0f6f2c09f021029db5a4de11033eafa7353e0fac5142683fcf557a59218b9c242eb4577495f5fc3e228e37d1c9c4160530e38f32749fd835e2c5683d60ffd5a09015c2d4cf7d5075c12d48bb57cc024a8b4fccc30360ea729b09b5ad1e35c982236929752157d8708a9ccd7ed01fc798d889351137edbe9ff1ea7c0babb8bbb960a7ef79bfe8e320a2db61db9f90f2dd3d3bbb2c829c48740ff6990d514d393fe9c4ab039989e2c5f17faace0195be079add770ef9a988e33655bf9db74b446f1454948f52b1c62b3dbaa89959354dbe10f1626fcd5ea80a1eb9b23102f4e44220ac7281be481f2ba1921fb9bdc5f90c8e0604f5c25af788fae363272206ee00f383d7b1a0f9025547b119379be77699e499acfe593988e7ff608971351b05789b0b277597dc46f2ea93eadf6a13bdbb323694e075c03dfc335049731ccd261aac16bd34f1f3354fae3cafd69913624a9712b6ef7f663301922e31a95fe6d89586dd3a0bc74fa526b1b6e1283ffc2522a79e09a3c20f5729c2242ab56360fbfbbe6b840c2dbcd1e49849603ab557cb4479b6f81e2a817dcdcccb543f68e3622ed5f7fabf81896b08bb342a93fc07e730385b526daec2ce8f4d47821aa39aa80a51c6f69bac0bf9ac9245a0776b9be712a73c937804562d003ccbfd6c2f66b30103eb41dbfce30cbd54cfd97fe2637d75890e0e3871d8a67909d162e4a0fb12a097cb1b9b3ffb17b3c8b4abed895137f6d0e4922c9abb33880eebb9ccc322aedd16a5bbbbbe70b31064510ecc232c05db1c92a4b4e8779a5f7649008a764e357d36bfb9655e13ddb1422922e9c31b7323d4ba412d347d6e25611d19540860c8a7169b085a7d216d91fb522fd35ee3e41f8ecf7f8c976163c59db97852e6383efcc7b706bde779741430f1a12ecffeee7ff4ee609486c1d6b48c157009736fbd5081c94e64990dc029ce65688c13a8d7a3762f931382b222962970fdeda2f29b8e1c5951edccf7b020c917eb8cd0fc62ead1654ab9c7888f3aa22cbc8156d0168a72596fda0687770f9a8f9ce815f481e44e106aa3538e3cb9e9435b06392c7cded3d20fdd55746a2f43ef00c14989d39bb4cdd70743d545ff3b82a91543d798a05cbe380de2af994e1df929a144184f1b9bc0ca9461620b843e0c00e23b761cff126f8f80b82afbc6349e5ea4b18bb2432bba221447104c7fc0b4810d52b3acaec273fa5b5c5b646ac5e943d9b970bc9237aa29206ef4ba3f5988a672802b5164af299d496041689b0810399becbdf71aba65c32f1e9151370887e3b5d13bd0e9e3a965cad1df24109e2478716ce53f1de8fe6ca6c4d26f4fe04fba64d21f7b21bde4041cb73ce71068670df13f5d321dd7abf14cc8a770885347e1fbeb10ff97a3be839ab2a2a1d5c3db002b18cd9026a9223ce75368b32880ef85be1e7551262f950bdc4ed3a61b179ce726a74ac7fa38a3963b087df4ee747590a24b4d790aac9743d210b85080de62ef1e17d54a54ad985d13fac8b04de86fbd47505bb225c633c6044643915b4ded73966635dbdf86c3d8f906d862f4ce89f14460504a903b90a7ad32804b68a6504b09a71cc3cd12427e66e44c8b5f86c8a4b9f0d15f9f9352f55ca3bc76d7a095db4f8351841397a6f5cccb5a72c6aa9db59c3d7c2e2673db4987ad315c05954821d3dc4cfdda07ff3e24528d48f7587abe64573b7228319cae37411a836b704a1d77699a36698b6e49fe3ff9a27e5a240161b77ba05eeeb9fd6c7427882d8455a6bcaad035fb01d6b3faa9cec5a9afbb32c471ee81f5c48c8daeadb8b1caebea7a87cb4df53cc1379bc5efadb373ea86fa031e0e3bee7b653643bf895a31fc5acf023069e1768d41dfd1139887d138c1c13681df0a103b975698898afa7c3c86c63e57186e7ee7c8c118367c463a322fab386041b2e8c62949b78fd173cd85c06d025eb7d9f15156d74448747266066b74f404d7374ae716dddd1aee5206c2aee0624c14bdec27fd61a7374378a60a1a4da1cf6ffe46b70a543fd4433743066d920eb16c6dcd0b70bf510d5aa0a7863fd158ab78bfe50f1369a366b507a9639cf4f0462d03dc421052ac2809e948b48bb09dc4dbd6226c0b3b5f10b711bd0d35eae3a3631be56b44f8639475dac032e02dcb9c369d91db896d80d495b077cf9688324adc40cc26a4963318010bb27177b5fdbac8dfcb93ec804e8673394deb7b840fd2dd759c70dbe00eb9e1808d24e566690ca93ebe31846b54c37afe90bb78048f84fa4b5228835e1473b5070fb06bb1746a49c6682d646b27eb72e8f8740a9aa936933af7333aee9c603ae697651d1b693cc9d05c3257deb1f60ebc56ddc060c3caca6d94339f144b8b42abe234d118fd2eae0672f129f8e638edc5311f4c783f0c3eb734fff5864902ac9c333719b67b671353b60ed32eb1a958af0ad25a398dd040f5a3775f959b4bd0aec2deeb95b17f5db4430b0ced329f1350e6f741e7023a3582987ed6c6da9a0665f067d70d793a6a68b533c460e7364c0379e818109d0f9002fe5d701eeb730c905ce74333e3c523a5c4b8f10600ce221dd9d5e947676c0e1f219b719a79bec5863997f5844350c234ac0ed838b5aa2963595f0c1d207c65430cfe706e30ae5cdbbcc106fae61509f1740233777ac98bd2d0702a48620b61f97677d586af44230b649cf778a42fa5b2c51fbee352f11eb13c29d14ddda6937a5e936e8aef5abf7179f31439e4b746abb0063fcd5e381932321ed2458b3f0ac89840d475b61056ddedc4ea6b94e805f12044050cf7ac813d137348a057f91f89805b49d7a6ff24289aa6ae876ecd82e02bbf2e6df6651563d91934ffef58fbfed9460b26f4745adea56a27d2f3a06bcab9f0655bd75670cf783ffaa7e173fbc3df1bf72d3a6d34c3ff9bcd62b456a266fe1b1dbf98f30dc971afbe25e2f07602668a82850ac7daa7162c7ee9475506aebbfb5068b9650d2ffc151cd38d73174287dfe577b96e3a785bb11353ad80d5a259a00ba7d59b4cc5ac76c63835b42cbfd1fcbd3ab0715ad27a435a6238dced6a2fafb3a51d402db7a0fa2c957f6434f7a1f3a692e1e257fe70a715a9c4d430b275147aa427a42679dd1fe59a07e2fabae0711788c347658c7899d058b5fde3f40f5c7bc9084e7f1c42fc6b568f65226d30a454db020d683a1d4d1ae9be04f6ea1ae8482cce23857b5fd3ae985b4b3ddd032aa7414ef2cd5cb4628a0ccb18b40c4ba9a7f8efcae1c8066eaa40473cc2b5f79d71dceed7c4871e45d646c346096c46858041147ddab3444960b0bd371ff421820efdd8a8d01209b17c843e3c67603605acdbf5c1003cc00e8f17d242bccf532cecb0c6b7a7165914ae0f1866ebc02b8baeeb63f9bf02678ae2ef05e68010ab42ff9dcf2d225e360acce7aa1a1a3caf846db5fa7fe934ea6d3f781f614581a1b912122d24bf830193cdd262adc1dd3b2e57fd219072fc45dc033f742c91a334d75545376331d65c8526a06e489ccefa3c4c1bf3d2eb280f120efb9fa60f0da6a1636e642c34cb28b8d4202d281c1e91d69dec2d08d41af916ea035fd501cbe3f030992264674648ad305b0f2e413a128b3dcdbf4e073f41700c7db35ffbf777c94aa70a005d06fd148b277f514cd4f9f723ca282a054cb68624347c367630923956abe53fd0c8fc51629a7abdb5a041c2659a73e2bb10ffa644e1ae646f192d32dab128e16931134c70af9f35fe12d5c09ee5b439c594d0574cd667090ba46b0dd5a6058f456314573ed5165f9eb124c7ba2e74381874d6e2ae4f4c7275c9408cee42a5c012471a8c9a28a1d6d2c7d1c1b18f4e1bfc7e4e1b76ab93f304ec06e5b6da9c8e0eb8deb29513d94732ead14c92409a623e6b62920482a38cf38d935ce3f6c6680619bbc6eb01fe00887ff7c75832d8ec1c54e0d28a3d518b88c3e80b640dd9d6324f5d36d3356421b0bd6d2df94a583069917e5ac20f5917098d9e75cff9e9d3fd908f4ed6689bcddaa31b012eb3a738e7f4938fcc4136fdec784b5a53974f2a9571af9ee9fff1a8e8bb9e9b5cf56613df5b76acf91e1addd939eda4f4d7a33ef3851d25b5f07f80c992dec18b6a1dddfdcabf46bbcd6ff9941f514f504772d71532d8fc95d6a5ccdff4e04b6998b830743e3b4463e0f1e365f4293a94ccf25e7a5036828717b2036104e98971d96ae79ea2929f4c2875f06485b5cf32d575c807da1977e0d415b7475e75fae2310035f26672aa35a76da67e48eb774433b2d3dfff51c310079c186048220b3703a7ae4f89e0c8273576dcd0dc6debddf82524faf180489c90207d3969cd14e7cfd1549f475377350078134b64393973a91fd05f637a00e5acca093b92f7a62604c3bac579f79eb31c7fce3bfe8fef0b9bb0d0b9577f4d08aa91117ecb4d4d3ce4d846bf683777f9986728946ff61e9c5793e09d0fd6fe49a11151573cffa25972e3d82d6fbfe4e434c06067672bdcec32393f8f4da840e13b5c0104f0ebde361f2b4775502a6302b6349fdc8a68fffaf0bb2b28eb2ccb07916a493f248cec87ccd117ce813c50c95885ac28000ce71bc3239eb6fbf36c728836ce4642691a3e4d18835047519fa2ec6c4e530c532c2294d36e5276b91ff91161a30176bcac847057c8ff1a8a764b35b009094f6736a86617b1516fda6ad46e00aa26b2b721d91cdedaa944e6d5f4b36736594068ed11775c5e2a1ed0f17c7d0a8cfd09e54e6bb1f91fed31f904f12d6479a194b19cd74957a9e6b957b03ec6fb475319180f6edc981fc700c35502ba9d96bbb3346efb00214cdf95f79e5e205736be60295d2e48729661e3472abae11a8fde73343a4f1179ba5a423fe824c3efde183801c1b44abbfce5a67d0e0f09e82a739edf6476c0a70a5a0e729caec2a33387fe545e7949ef6a04a5ab3fdc41775b1c1701f0df2189edae5adf17ebc0add98c8af01b83dc288c8391a986d71b0fd0086cc92ba9efca032a27207550a446489fb0a12b3469c2002aea190ac59d756a08dc5f28d9c6e9f1723ec7a01f9491d94ef3da423290418c76b3cc260c93c61731647cde5a48dad502a7e10f26fb431235cc8e8be6f73bfbda3ba234a63fa5998d4779cd2d2019469a8d2c1da9607581a5e35ccaa40ff6e3fef852f7c39bb8208f9399797cb827984f0205486e852e147def44bafa2ab0b6ff0966213f471389de9bb22fe56dfae1942f2b0996290e798a832550142134609bb8b53bf09b8664036dee17d46869c460aefff1fe35f3c757bca4a4e0eb77e58946eb5c81c47768b7223bad90bf38aaa74e1f8bbaa113ec9cf7f9345a306372afeb978250da42118aab2a90572310a9d47f1bde8c09719709ae268d28ac3b4b71f65bca24dce4ba58171bad4bd8d03a68b8abe07c3e0d155d66318ac05116745bf5cc2e7de2ec2b18cc161f590a91feabd88b8839d650265d9938241fc00720dd87e95884bd0b98a1b56beab60e03e468903177ae24f2c3187a0cb129ad4063d753753da727b514f24feb615f1d7e14d1131f48053abb77df16550600c4ee82623a1022a07036c855670dffd70cd3f5332e9d651c884de8fe5c73b03bbb0b7c18e96d6c135edd66e50e57f867bc9a491defc7fb1bbe2a8dde9ba82b55245c745369a382abe1bd86ac3517beb0d9b13c1639dc121406275e79867721284fbea38b5e7fdbdc679273eecc303afa3c4ea1d88c77c30cbf7fdc202ff7b38e5bb49624f3fd4a6a866ceeef05a57e9ed49219dcfc7b49207d2d4c71d8fe8b339cb513b1504892366ca45c5dc6f669eed1ebe805f298f2e2935123be193bd2785fda27496f710bb71f2b5ff867f543df420fdd35b07cb323401fd1b6e1fefaaadfc3f9b5aa31abaf0f2cb30b0b987ec907895247bcf5f04dd27d79eb19f10726f89b42759eb5f0ed0c427daf278e19206eb238bc66651128a356a1c0c42477064874b333e26aaf7eafeca9f7e1240900e4e540e10013165830bfa7dd42985c9aa3763e0d82d9a832391f0387f6e83b1bc078619410308841a53e8ce57f9096c3fc99aaaf3a0aeac721292e86c82eca22e384a50b456b06987a5ba8d26db65925a78048d5cf19a4654acd2f40342a2084b6ff0030d30d3004d149d4c0d08d1944c0197e0c2d9f4cad80c6ccb882528ffb53e730864953b1c9615939652f505807ce4731e2801f29120a6aa6f2314dada3f78993c2be77a0874761f59fed74d9d1d36df04a2307df3b9560d8e76fb1ba3f387db81b5e9a3cb8acf4168a209c72ab2edc9480fb607a8d5aa93c3af766e2a34f5619202ea88bbf3631d02be75ce95d82bc135283bdeb439f909b93277aaa4660ad516b22aa8da63b7e1fc0bd6535b461b3bfad25990ad4b4454675b909f0a95d31ba03b43b89056a03009317d64eb36b6040aa3d8a4320b29daf6ced26b175aa501843b4ee6349199df0f630846d64738637b975427f49dcbd15af70b11f36300e47d7aee7618f071bc2be2560d5440c318d0e69096401a57acf4f9bdc92a8d07f96ccd7ca4becdeaf427125e91b3af9940b335610725acc48273338e301015e2117e0c66ac168b4304c4d994b0c642cf241d3d27a5ca9ef2e1ee1f1c21deb90004fe9094a0efd3113ef2377d40f08c263a65191a400d478d92754e66a93b044a6c8a44c6bc738befe46ab0f2918c49f2e0f543a4417d64e75a10ad9122c550b82295fb91b024d72744151530394b013fed0374bf1bcc4f257044a1e505f29b91f4289d6fc9c2f239f83af81f87fdf2f228b067f6519a5f2e2d80341d15190f78fc7dd36592bda0f59f3211e2d68122d7ae92abe4f99d21b108c295a5172d1c80033dfa4ba294413c88baa322a4efeebec8c2597f0820b00ef58e5bfb67a80a8658c5111bcb88fe3b0bfb7bb9981b9b8ed4f9e968cbcb637378783c14c3846726bc52f76f7cdb04ee5435ee90dcb1fb5ac9561da014cd08df8c92c994a95dad85f790e5cb341ea8341439499454fb6455fd7c0bb002ffc726b3c0fe6b9ac9d438a44b8fc2f6d5adf9d3795bbcf0ba04a0efad314d0bc03e90111be4bdf99831414cf429ad829f75f63b6dac8d769d113ffba7e59fc1c817e61f28db459b5b5ab747a6ae0baa9151c5b1fa80a8400ee7aa83f35fbf6012ce6e0343969a472c7b1ca0d64be0a3dca56ff01fc727af102f1a2fae7b5c9e44b20f0b684b00bfdc8cdf3f13dfd70f9b9c4d2e496bf22a2a953ba223b7c6f3f9ab375e610afe0ee9b7f980aa217d4c73dfddd050f4eef8df6617908c403ed6d61e860a386137e7836e49bb45fd2188f19cb1442dbb0cf116370c10a4c8006cbd1cbe0accae5e687a128637fea508cc335a634e9cd3301bf7e3dcc1e7d367f36c8322186b3cbe7f1c740f162a7d8fc94c8baf72e2fb9b4d59a62582aa3335b5d9629373ad44ae2a053ba132dbde953637d9faee124c56f15f69fceb4e762967e6f799ee1300cfc6884fe654d90917bc2c6a966a72910915e2fd640cb074b3a9eb112551343ce45aa0ad639ff096bd0467a276e39d4c19cdd43617089526c549c39bb48a660b807d05b2d3980206f8164e9bb238d5aa9a82ed9d55c0d0a23c5f8853982c6074248665ecce1a6e00111f0de4d1ec54098b58cfe46a01041514b79dddd37a6ea2ac530ee3be54cf54df3c67efe0ff211fa3ac7739cb87f7d27b6a92dccfa6ec7f9905ba654bfdb310b827544090017a44c560bcecb7572700ae8a854c11d0ed64380faddd8972ab56306c11d7fae2bd7516d09aea2eee21423e7541a3e4bca89040d5efdfc3ba4767915510ca56e5d928e377fe7902e72cb40ae69bb02100e8a85c25e01908224131f828134077647d4759148caed88c07dc6a04762700a952bd4f811bc7523458c2459ae9f0f6793c67c60b382cd431e73b4b79a686ccfb5566c5bec5634b340ca118111cb5df6069ca12c11933afd8ff0db6c64531b218426f771624e21dff2180d75d0ee86b7ec4427c32001e0849f6554e0739e61cb290805f70598caf03ac37a03fecf48f301a5f5ed554f57b2db3ea92bb01d6d68f3cee8aff274f3506510f68c01e24038f4ebbec8ad234dc6bbc2a57da4447d46e7b9212b19ae76709af6d76cf43792e49db7eea3feb5cd9896244ed8eaecaa25a939c1f2020c79581516a4c4147f7d42cf965f12b80784dd13077bd188d40b0b1b4843d79c8c096c03bf52889545a373dd7194b8fc2569c97f897a7432875183f9549cd35635abf0422d0365bd60bb1f21f36efaa579475c4263aee4bf02247f770ecfe592deaed907e676ecb747c95b761cb8376110ef6dfbe739c69036d436710efb38700025591e608c3884a7e57f4c0634c1a3d7f6dfab87acaa75a01d9416495584003dcc50918bdc0f989efa29bd6276fc98248c989220b7a6a953a51ffbdc66834e2b3d9c4b347d51b56d6b28393c39cedef3ef1d14628ee335c43968691e340d33e8cf206f76bced2fca9f7d8eb9da67147182a324faac8142a4bf270282211b0b6a7d399251e389601ad4598c707e3323f600c4b5d9aef973e141670b58833d8d3ec9d44becc930ce231aba2973794b5f4f2de1fef2908e8f649059678063f44e39907286cc93cb80f529eb2981e873ca52ec32c90e8ced0a800e65ed92a0db7be6b0db55e1232deb9ef14b4d1c5128e80c1c605fd7213b739bfba70aeafab2c64398490f073321065017c1a8796bdb08dc2e541a5cb3d4369a8d7b7472ab5b394ec4d17344a952978696c9f814523c5d7374400b3a9e69eaca0e2d923495e7d6eef66e2514b762434c0401261cd0fbcb2c9d3ccf16358579bceefc0dcf32fb72368e2825846fb70937c3f2b39fa1e53b941c30e553ce503d065ab6605baec1f031030e664fdc7b4ad25aeacbcc6646cf977741be5b5ec59e37745986ae49ae67e4d75c9adb4487868cb67cd017ab44aade3784be31e6df7f76285cbe987eb13f396ed4273aaee69ce99df021d8f1ce0e333a4ac0acda68ebe457fe3c7daca7cfd72e4a7c2a42882f8aef39c5005764eacda1a84644f16bc313b41524242fee9ac194469f5487d3900c850ff1688edb8af950a4d343048c4761392f3dea0d40d590a85af44c7449450a20c0e5e30cb9c4a84b18c1a07fe13216f5eebcec0abb2082dfc0bc14125f7ba216c7eab9969050ea38f8fbdc8b244a16fe2c5a9141e0154478d713ee482b2751e6b39b3b528fd5cbe3f2ccb3a83ffcc1da32ab367379eb905cb706427c24c581e9d4ef121894e4e8f4508619c684fa587eef385816e78caea72a0f2acb7ae7acd6142492f3b40ee253874ef2e34856ea97426252c5662c49b2703ada02af6890980517ba38bd8afa216b923b791b27cc06687f36472f2ec9de09e1dfea9d4f05475ebcef03004a1b7308a88a22047b7a062df30fa512376c8d974d8bfbdee8cffa2b6a9328c6807ad2431568396ae79f4a9e70ad7fe77d6eaf69b5c5ab0d18da96372465e792aa9736f2aba56ae3ea222ad798cd267206c3cfd6eb9c93f931bbcffbdf335ada3f7884017ef7dbe1f99d82bdfe95cca0777daf1fdd32875b29773448b46c53e79d20462202315a2343fb5ac4d891b5a8626ff421172cdc2ccd9bfcdcf0b1be9e935807cea20809f1d65c8047de35a70fac1100956a01d023d2383d41eb8e0d3c3541969a336e42e91f5c0a76857dddfc119ec2df82c1d3384967504a0fa1c6c4d24419f6c50e301dde25da379d7fe8a1f874bdc06ba9dcd8e1e8ba2cd661188a5ae949eb3741503d507f546925c331b9e2802c5e5e4ee6e0d9b3cad1f42ab7dd92c953bdb02aaf88b8f7da9e16fb43a089ae821fce70c45106600c1d9f92eab861cf773173193e19933c0613d94e09c8b76674a89498312f6c05f8b01bed7e65ea634a79cfbd23bf1ee8bf836d8826129b28ffa572e226eb555d99b0a8000dfff1fdd57c4e929e21cce4a4b46ad07118276fdf8a5d2a2edb0c10907bd70260bf96ecc86692573d9fa17b9afdd696f0b06a27ead2d7c4ffb848c312b9533403576a895c651a5a0e96aeb33587cf4175b68162bf14803d712fef777ad49f97b02696256ea3228b153551b43d1da5a4db2583e716ea095d0950b7716f069cb2160ef85d05e62129d615ac5964e18171008daecf1a86d415b6beed39e3a24bbef086d4fb3ca852973e233e596df8144bdca41ad7b2f01f23cf79c6446b00820ecc1ffce0d2dd6dac8a94f3dbe6c6bdc2b39ef600a2e5027595b6431031779dcc4faef003a50da52a6a3245bdba94e979cd178dbefb1452e6f1ba8cb1b02716856e9795f6215d5eb7c6b6bb279c802a059d28f78f8c8512c7f5368f50f2ca4d92f32bb2ebb4da1e79db4629d7620f03160aa1f37caecd7c8192f61bccbba6b09e1b4bf7bb9fd04b798e125e94b7d52a75a2a3ced7821d57159054e325c33244879f992d90db805ad994a86ad7287f9a78fc88522d25c7e67afa118ca172bc6a50cb808c039d40cdce46e7e38b5fdd301fb7434a60906a9ea49d0c580b7cb57ad85e573df63a15be116f32a1c012e62649ed6cb86bbce0ce1a26500e1326ff5084d940f314f17178063e4518c236165c5e56a75752a100e1f131e97ec8c02eb1005a0017413782e0540fb30ccd64183a6c182a519397fb4ab871f852ff3f2e8edb6f197e1d366c91326df11f1d2cd9ce04c59c0dbb2bfcd0bd2af907691d0721dc13c5dc4274f4b3f2449ff697402ee0218da042976b527a4c5ae002f1740525a270985e1e52fe7711fa88f792e19f9ed83a1217b4792b526b0af4d07401987b7503c933f4ead6a8e775121a34545a0b5188447af64e6bb5795ccebfd6b86b97936069a19c4cbf9a35a72bee84863f861011e6dcf9db321f754fa91c0df76ada83ecaec30204a1829cf9ba5029c8420a45f25a238964af60aebbfa9cd54e7a98c96be08dd8e02a86415ccf65f557e2947d85235fee9c2205cc3c23b57db56f3638deb6908af1230b598609ade96ace40ddac1b176620268d7737ea76408bc774f33198b64f41a1b8fb76fa66618e406a9cb7c132239c4a1976fe47a8f0c457083503a20eb95f6f170191905fddb552b44a5c4ec893017bab720a083eeded283a9dab194c6f572b290aa40477f6d75d0270195d2f980e94ae751fa5b9c890a5a9cc81cf8b54f566e945f923472cc5234514e095093e646bf353bd26c7500def6b8dd55601e88c3a211d088d532fd5ca73a9d9d2ed2a27570a114f43db0cac312a4539ecbf36cb7912a03874f69ea3d4028b27ba905f8ab5d1a6d76143adac2eee9eb97ef3c3851dbb57464a3da34e465087bee55de253edccf594a248d112fdbf594b7846f51408a6a55718eca0ed566376acee713e2944e804baa3520aaa6d7802254043196b2e212dfdb219a34a6d632a05b86b51802ee749027b8082ab23510d67f419da3c955dc1b8b4301cd65e0069bc3e7ceed37feccd6695df6e7624d134a60392163ec9bd1117258cf7b351527c2a711e0dee38f9722bd5c62af6228ffc7ca68746b8aed7a7e415671d16af426869bb9216fe4bd8e10f8b0a2cfa721b03b6666fc31cc18226437d1612468f4fcabea59964847cb7c4a8f2a10192b6559224229ab6436a6198fc021e7530d3279fabf19dab99789b5acde35676c35455baa1fc274720792953731e5d459ec9fb329552791ddc2a6d52877bf68d56b771225edbca119adad8c8696482c506e9336f11e2e06c77ae082042b1bd52af42b5e2caea8ab5a0c474a10060a65222d1575757cd8ad0d52b7208ce7dd148e763886c4130dba28d5551c7ac3500e5d34de2aac8eba3e0829eb78e822d518b26fe0e3d1effda292e0c00888da8b0ae31beb083c570f13fa952f334d57102b0413cbc325dd33f0f7035a7569357da5e9fec8abe6cd44b0b5563813aca87e1f6999f5f57e5c893eae8ca978bb51989749c1ead2d77b844ff55eafb993250d3509194dc50cfec6b853ab8194402e83033cf42f45b11f26c51dac2d15878131e3f61bb49710a8b33f68964b00739307d0459557bd9ac8dbfef00d24f30b47dea01507747eee43f6a5a7259901b711dd5317ef8ae1e89d02ada35156b0cfa7ce1dd014818d16ef5a6d274252e882463b4966b5266cfc81c4502aa14950a655cac0ef2e2112316feec1e891e6dc32ab4d7f2c675c14edeaa6f06a3f40699fb13f01776af215395d74fc68ad6e8c55b99ef61875321aff790c5d9ec9896fae4ecc8897a31f28aa25accc014758c37c0edf0be46c96ee39fa2fd426d7556e034d5d8910df4155d8d2993cdfa94e864cba8504026f7ed2d0869b60cd283cb80d8983a2ce73105232dbe47a7f7c5a2af59b0ff25587e31ad67d69f885337b95fa479f40c83a9f9590c267b067af9d30fc575e9e2006a3bfbe1d3965a207f2bb3336bf62dce183595541513bd589b04ffe3f5a071476096b76c19b571cf5b5867781b917f8d64189b373caf8921ad6a6e3b9e10126bbe3c5bd3b1a428f086e8c28536b94e9a20a83565f8449fafab22904477ec5d428e7afc2e405e3f9e2e48b65653f9052eb2ac077e7b867f6718e89e7d8b199c1a8dbf1f21bc1903329f1c08aa67875ae4e92fb274c6b378fee81c637eea32b11531d6e330884965f38b30145f4997c16364c2a3e26d6e9aebc136dfb74cbc3bd08a4ff60ca141d31cda42d43f29db3a2d35952dc0506e9b51159071864c29165d25c25fd5d9a2c114c6eb75198dfce731e19c21e93d0d6e5ff1fbeabe4263616e0ce2a68092764fbb13a07552c9f7a49aa8c454d31afe799f2d44bb57c225377ef0fab5107c46e5597634e1ac6b058d50a4300ddcb3d17093db6b3bdef38faeaedfdd4d60a0b652b10f7e962594c6413991d387cf05b76edec4021c50a5914630f4199ca526b41b21de53c1e9cdf00fd64229aed96a2ddd7887b6b4e7afea1ee4b5922cc74a1c5d16b13d6b033ef380aaf1ced0b139e19793102632c557845c81e7bd0a0ce1242f45902be55b7b6e76a85ca85fb1b1cd8928d4fa4a1c7b2b7b6569059486619c8047a8bf7873091ea4c72c5bbbf39daf812d6840d05dc835e0afcf27e3faf9b5684194c0db1112d293a2a74344016b6937bd6daf7c11ebbcd32e325fb9ff0aa35d4cd159513854d88b6eb78fff02a4097340adb5057a8f417ece54822b3c7c5a4228d7950514cc1f6f4a8e945be5f5d7bfe0741b0103f5e2bbd899b7825c80f045f4a3ffd866d38b756f2b01adc24de98f12a31e855b2c516abd48bf7fb9742e9ca0ad5a81c45b1b931d057fd03c4139703eaccd96fd5c9e5f0d41170cddeff9de8238c614b3a750358fcb5ecdbbceaa3e9f04f79a68941b5c19e3c0abbdd7216e18b71e117bd53e7f75307088cb8b9483b53e5702fc0ce9a98a0c211bc396d864bc0f2b40651ed289d7b116a4ecef14dccd9a76ca27eaf32a2653b14c65c972213b202d8eba8470423b6528af1c9a5fe66c3423b86e3ca36872b5541389347cd91f13ccc7921e1882694aac18b57401bc1f4459b37d093bc8c5a8ce93907151ab886734fe6057269e4e54448a433848f16785adb555f548616414b6e2bdd085aad65f7369839767685466efa648621e8a9d27da3eccea5f5b9481ca4fca30a70baaa1e10473ac8b1fc7aa1b40c49403bf860ad752c96a925cbfb6ed552ee67fc0ce74d25e9ab32312de762db4b6491f7a079720aef8f24c8eaae9b15f0457a605e5cc737f9f24ce366efe065bbd46d34af6474edc3c842bc5f30ea8b45cc056e4b5bc854d67817f267be34dc707164917872c9f7fba2a28808f9e9c3ae766a486d87a46f74fef7ba568847f49f76b3c2518ded841ccd4609e0ee18c43d63dd221e491a1fa94d98e011a3f45afb19b64b9f1b6469531f0877b5d051a6cba4254df9f2f0f7b31c545c97b50443b558b0eb74c7922cae8e9a67a8f22ddc541582a40f67b32fddc16224292bc90e83c7349345f8ef343487eea079dcc09527f7afba1854185f81232e6df4d0f54c699351fe1456d5ef713df041de2f5c7dd0c40154ce5372177ad9a4271872624e3f373ea25a901f3fe791accd836c32799a3a0ef1ba0656c12529b41b210948d05661bddd2b1514dfa84915d85bedbd0cdc4c3e4401a8e97393501d0b4437d81b54db6fbc7c059880bb2261d7fdb705e6bf1521773af2f61a22fea41bc6b0da63249ea65496534b3c14f2cff140f3355fd092e763a665505e8c7ef801defe281cd7517c09968e6782d14d6bfbf977c80dd9b9c41a7d8971df4a65fb78e9313c3dbb48d1af6d6074c4e71e1de76c99eb1c0d50f02aa8bc924742c36cc874d764a249adb448c4cdf74406f6dba2f4ddb5db0ef61b5748c084e06459df6224456201831406d9076ee6ea60a74640e96a05e5885c4cb2fcd45473a4713141f5d085244dc2eba0a9de337c64687bed2be1a64ea60eca9df8519b0dd217ccd93a8ed8bc8120071f6ebc7fed8bd5ec68737c335f985638a335a3b6207cddf4c201eb1bd38f6dfe047983a6b421bdf581216f303f2f2860bb8f4bd4c2db4d2d9f71700ece03b5aa3552ce8bac64dace564c37a6f49a1ddfb99d7842d6e483d23c77dfb97eb32cc69a50ee4c34e68231032a2ef7f261253e1ee5e55207301bb8adc7996718da88563754076f7f1c942f149d94eb9ec5b918096c3b2c3206d904cf6a62ef0140297fd10d945063af06f0034823bd7d4d3885d2a9092979578965813a8c5b7002dfe5a5aee23e4c28004a8ca59b1db85efbb6e1bd3e63e084c34d40bb6ad63faa5daa1c3e30bf981f0103d9291723851cb33498ee1f755fbe74365e8612801acec12444613dfd58571bd11551a8f93742dbd67e6cc12378baae0490b613f0c1a905be98d37595129e9c28c32a94ef0ce86e30e4245420f8e4b01b300288d25d41f186e8f5abdec3d3a4b80eed1022f9dba3b516c11972fc197162bf5dd990af25409cda363a41af7f2868db5028c3ae21888a1528c0ca77dd85ac41b9877063d48690202b81d7a5e8408e9577dcd618dea6d736afd2c062a3b04bbf6cfbd745caa7b43584ba095d8b83fd8552ec8fade644b4ebcdf0a483ce05c15169aa4b5063f71797d17695eb7172fb8f29c1a224a9ee44cd07a1f22e8eca094bd5b0b86d559ab26e0061d796418d50910cac38bd06a3d217bfa67c7d2de34db5894116a556664fdf4ef44fbab65dc344f6909677d1bbbcd321ee46292e7c46ab6a4d76b3dfcf2128ba0a5a8bcff621a76ed96200f5104c851cc6b4da5e49418c7a1a041d1df974d0c5961abe5190c4f4e57e6163899db109778033e6e50ceae551677f4987fb2a7d2f1831b72e5c6b5cba688db27dc59ed44c2e1e6864e86c23227113b92f570a8dbfe461e0f153eab8ca9c7c6d8a1b2c95d7c68e72b1d2412c260c4428fddfcd67d0a9b49617dbe3e70368f0ee7b6cc1e0a2524f2fdad4f5cb7c3bb88d3715f7485824254b636869ae15662756ce23afbd4cfae09376d1e06f9ab539a6589c26b85aa5f482f75f8000e080dd1e755cc6ad726b0d6b14ebe5f0af7d552f07a9d20405e6d172a4c49e96d55fd6c09014de24f0b40da768d463a77240f58cd8686e046ad2708710bfae869b9cca85991fbadc3bd70684fd05babd653e47567d74ac78cf5ed2ddc9f3eed3f1983d8e776aa3889e0bc54d5f0696d41a35b666f7cba21402407cad8c53e25fe13f42a797ce70b8d67ebf45eaf076db2a3a1ef19728113d1cc04fdd991cd679af2582447a253ee7e4e5f42adec50a4f25e43eed55bbedcb988e3dd2b2867d15392e07a81e6c248e901040f21e3f2cbc2eb152f35e1f222857800e1e73d71068f10f56a2df89f231a1f25013738d963dd919bd04e33628eff5c054e0a9ab0e822ea78b5fb35efc2b2eb16fa589bc57e37fc18043f6667276463134429538f0d8c0023c73d1f51b3612f121e474af713c2a8aa9aa1df027523e5352fefcbecb2877479a2de0b22d3e37a3e8cf80914c264f28eec7a73ac1e75ecb95d75059597e931ed053b9cd6a03feb23a85e11eb23c88dd16718e3e79d4dd70438fb8b536cbef09e79135f9eefd153c49f2575dffbc058ded865a5b02252c7b53420e7f813143b0649b5f2018a15d2408c99208ce1aba890f3a0501e83673657d41b2a4afcb55bd53a33efccf3869b6587e1cd133a9a310da2ce3e003c51fa9f46d3ab25de8dac4d567d7f262ed629e9a7d98d06b37a799d1de108704ee9b13bcc31ae1c4d685c5e24a88739a9c3806265684011ac7f712a504db6d740786600b8c907ef7142fd0c594946df76da960d0a1d854890fc08c16787d9a29b72012a8a6a2ee41eb6396c312303bc984b1750c5145fb5fe0580382ad5baf37a0b8a32a4e70cc7c447ac2dfea3c5e4e6f54657ebc0e7018e2ced9c790ace2928bccb0f7cc62ac7bdaaceec44181ce63ed68c3e756bd81c3e9921cd7bba98c281f44e44a7a7fa3219eda3f0ea0bd6a96953cc858b6a24518fc13969fff5f49786146177285f49a505d3df2027018a2ef04a0bdb25458e8f423a2c7bd730ab0e9b0a465d4ed5f68ff5decfc379ed61139e39fa0b0f7c6c73daff217545e09e73f1d835ef62f8c9a90927472fd5f007a0380855601db278ee6c683f4840a6aa1e22211c9991cf1eeeab332adc5a80affcdd986901c5e5b984ccabc91ad99d2a77620ed8de8356ac7e853476e1114c4e34f1d2df4755bb69954118f1dac73d18d7f8f9522801cc6aa9bb70e36c5576b5a9fa985668366246289229781e5dbac61f2ed4979bade3783e51ff6f36bc44143dbf09e803bf570f87a4177975b5f493c6bd2257844d090b92f0ac2fc57c342a004c6bd64c5aaceec6921a709ed6aa3a93076944ab476fc43d078f86337134bedd6c0f590d4f7ab6d19b888a55fe5141c0c062f12146e354717352b6e0d009f906bf4d90620c36355e5da4c1e3ee41c366ffdea74402535daf90457eac78e3bc67082ef6a5262f094bf9ab45ec0f7f5e6424a5aced727d4309def19019b100cc20adb9f9b9e614ce1e4864b2b73f414e87a70a2280c08c23cf5fa0f7a99ef8ac372e34abd4170fa5b0c23077189af42815faac32bfcd633f22821e126751975fddc927b7b6b4f5f1841a47b905ad353de3a892e281b0f41c9ebae57941c49f48bd658e52e63c1b71b8682f8154f0a489e93a468ceb8aa34ed25b6cb2ba4349fcda67d4674bb372f88c863ea244707ca1b891cea81dc6923ad9004bd5317c3889a7de57eb677555ccf97dbaa99df56c4127264cd720fe1d51071cf07579d0bb129451d985b5eb9df490984cbdc41ab0b8691bf74fa93866073e3c7e55ecad46b167baa9f7eb115251f139b717ecaea6ec57a6","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
