<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b27269081f80bfdba0be185a21e9519610989d9e16cde3ba97f5a05fff58a7c7a3695a378b6e50ee2989eab85926eddc20c227a64a136b4b9fc992d1819ba916ef8af62b93339c8e064108a99dbd4fb5ef3fef44da8cccd272889f73a4e82ef0c0292bb3638126e65d8fcea4307bf3ef82c2dc1bb00a7e770d0156238bdc13590b02dbb67c3976cc53e7a7e3b1d08fbe91d8f07ff9ba93f8bce132605de0d7fced3ee5ed9e9414e72e17681594bcd8e3cc49e96a005c04eeb8449da998e0643567d69a41e8982f03d77869de05af4357cd1da8d80ba038b734a080c255d445ed4cbb21d6dd98fbd1db7bedcccc7215b9d0e2da24232287e64bb364b8a5ff6cc8e1f8ef504ca55bacbb7fae16d39a10efbff69b8ded27c205e0e7ce8017d82d1a872549a1af4ba6b10a4e0b94e993e560925f6249f76dacc993ecd8112c82b7657331564a23067e2e6b59436bcff9c12698c005810b32a93a6bf60d34610246f79104c6725f15655ddd39601dd072c26dc18e2bdf7318836c89c3b8bb39efb95ee0f29d93132b6e7b611f2191bb1fe7c0bde9b9269c6ea52e03995136fe280e4a743bcc23caa332e0978abda8223f842b672ef623b21bae634f41a78a8da67a57d0ed6783cad521ceeccb540067cda2172f279b7b8d3cfaddc8dcf1601c82b4bc2e3e25910e216e226b3717bc46b6c7c1f3945ad6565e10c2e1b0bcff2ba6562842c375a3d356a630bc929ad6d68368d45eaed91bd0092a2dfd52b25b929ae14bbedb1877264e3c434db23123fe2f0436c540af128681c348d6808e7654a6461a5104018fbf45a20d08f07a7d280b20365542fe83a31328f29625ad73df4ce125fff532500376b25254b37e14bcb7924c562a842a3969996c2feec4b3af2c6019edaf144a3a84d507207a42044c3943c86746032b13e083c746871eeda14e803fb53aca0e17c0dd42d2545e3ff766bc181b7bc268309fa1cfc54264b4199b22984a4d2fb1eff0c409a2aed6fd788e1b5ad1ccc973bf06320eb996f0b0dfade32aebecd2eea19325260adbe49c5b6fca0bb1e3bf2f38894199d6403d6d58970f7cf609615918de404bba2cc9b48715dcda670f04645787a8d9b4e4fae0a61713241f062038f5e4578a6da6dff647b3b578efddafb0ec7cb0404ea2a4211d3090cde90932c3bc48dfc22a1a5631b82609d30f319f32babd5152b5598698666178319007dc5831c389544b1565537f064c52d11e44743ab03f821ee79b82d8995732b0c3dbfebc8a3f26a5c471d9dda56e16abb4521c06379fbd4e2cb83b8f4ed8881078db813a7b378699f776e485cd14766396394e943a8003bb67110be55df7efe32c07e3524092a478c8dd1f14bfaa9c0598edf4c5b7cfb3efe704fa287ecb0713f050ee8cd284b62902ef4f75ec768dc02853fb93895d23909a1b8bb64209b85b3659637033a4ac02a807914e9352575553f019d96b75d6f4b7e889f0aa0d0e0cb4edd05dc702734cb911f483a38d218d122fd5fc3e4b0003e51654a3b4b59e1de49ce3d822de7b3e5950e7553e47e7e0a9aa044409c6af95fd8b8006eff6b8d6a628b1d83354f35055a80f28906f59212ea1a95e36b7a34ee7ded34a6676a617e01271077d708e28af2c90737fb7bdeaa487f07fa238bf76a5bf7b73e6635cdc8167aa1846a53a9b408521ef1806e8a42c1935b981f36d431cf392ca562767844c1913f1c5367cbf8f21fd8cea358798a9921ac8b8c2a84cac1751aac0f42a9cf027e9f8649003731021fcccb3a0bef46bb8a9f34bcbd50de69731a80e595b8c95f535938d6cd18602ccfc4e1e7e2bfe12abedcfa3a33fce90e2e488c35163a5e0615c39392c66a92d1b3fde0a35c81e943f93d704c1e6cf49e2a4e60fc757bc725cdbc3716271940f17c9ce7907569278cef90d106465c3f684039e70596bd83e26fe9410782065caf4c2c501febab24054edef1c822eed0430386a58e41db5a38b4793652ee2e5f4292fd3a95465aec42c439090fdce1701ba54143557dc525697762d18a077f3bad3e56ce010237c6b3fcf621759ae25df1597a4e8d32b9a67d48672f05ba2741aacf2f82df28bbe87fce7eddc8a911a6430a91e4a1c0e5bfde6a20f46a56dfe6b91714abe36d39a203bf2d66c8f90302005a3707c853dbb12be731365874bca45f866830b1a3f1fa32bbd28f449aeeb511f7c3648140c139262f846a603d705c576c65bcf6cec194f316f92cf9212fdf20cbd0eca5a91a2cbceaafb2fc7ab64b2305a4ec0dc0d1261d75f180db77d744de7f5a6f91552f25c1e0630f870273a2018fb37eedec9c2e5e758b1fcd18d0ba48be195819e1c2b55d5c73be07c3307b8bec3c1eb547775ed7aa13f4caf98efd3d3f5692a6aa6033c271201d602a3dca6f49d272e2901b3648e767861c5a588e3e09380e52ee80c03978286ec7a1d62139d13d87c9c19de8d6dce112f3f2f93f8a93b528e498e71ad02e7edfe1bef7ae55260300acf07de55ee191e9445190ab0dcf46b5c83ad1de02abccba8b170960e76ba688d2ad1aebd7dbd996266a8e8d6c79540a80d9dc48a16e956438eb2379cfc87f695bf3191f835e0668978c00d424f04518685822f764a0f2903c6e355b1d2abcb57ac5937195e57a87dd482ec88b15be52120e2e9e9f11aca33fd5ac35b07484bd7bd8c27d27e84c94cc1f9b2a616894d0221d7d2c143f6e0697aba9b4ea4da4e5b02274be81e839a035c6f10334c5b4827af4bb0122dfa4427898d6cbfeefc64ad77f4136c6168aa442289337d8c0f31724b98301f856b66426dd618af232d68bd2eb652cf7293f54a0eb98dd43f499a3cc9f91ce4b01ecbe4a07048fb09e3c288aa8598b5c1b3d66d84a96e85a4f348386c83b890acc3f04f551250815be82938074166ef1c1d0a650f9eabc5ca215ddb2c03f694c43c0103871c5d334fe9a4065d590a13dd976ad0dc43648b0c0005fd52883ae859cb7cfa0589dbce24dcfe431deb694750bbcf3bdc84e43484bcf22955426915d4d6e273a72b57dd27298b03fb5bdc4e416b0963236dbb477225cf5ea07ad11b0dbfdf87453233453053ab2e88ac148c76514e61a3dcb5e3f3fe35d20cc0680f60731d97f1b815e420db1c8a24ccea3ef42f6076039d9b507892e3ee1dc5bd2cf42c1f8ccc0549a1bfef924aa68fd39f4fdfc3398fe5a4d139799d4340ab41f7d8c168ad0005d4e2715aea9621f0ae29d903d1c5379f5b12eda6f0e7870cba7c2eddcffe298e92d881838f3acc2744b25e1da9ec4465db94a0c2dd7e4af077f74abb00a69492c985425e7a19e941c329a5a491032fbc158f8d00abbee49017c06cdcfd03a80dadc7a93b2d74a967a7da37e18be0648838246cafe5966da60124abb675504c702aad047068b4d6911a2757648d3a607038b5e65d9d857bad69b2075398e67e08da6987cd2ba2af04da137625f2acae8bfa8faedc138c778316a3ca31d58c4b403750c7e3b9efc469f25d7d06ad5b59e113e37424b47cdd8487a639fb495a1e15d1222ca5ccec7fde375c29951a856697c34791fbd7429e2b277a7e9a2bbaf0c89a8e4272dd93b947e96e10b5d01ecb0e89588b290e4277d2f906eae724a05c7ba33916d1a56a79e8dda0d7d0c2989c9120f8b82ade506198d03b0c6b0c9df86229697da0de1c7cba3d4f8a19fbcdc39f0370b71f634af02d1ac17f8d55aa896d1ded9dc7e3951aeba19cc84e6bcf6fb22a50bd7059df4b310d930c4485021f4d75c3110f799bfbbfc1be257d7745339871df18bd4828eea4855bab77e22c0fb52f1b07b522269111fe3329dc956a11e884b43069380299b1a1e619b4f573d377f018c3efa714bf76c5542d969dc3dab3ca67471dcdfb1cfa5d246f109fde5da42a1f29512b0ad76f713d7499aeb4d3ee537ae4d954fc9c7cc835f836ee4895bfe5d3b1716581f4ee1de683ce5ff32ddb6c1baa5f93c8c396ba723fe805e667d90a7173a50054a79a74a495be41613d6c580acbbf6f5638a4842ceacea9b58d3c3a008f797da741ea7aff9cc87415fe4cb6b8ecfa607e6f9d7e0c317324b73b4e748fddb8ca8714f4d0d0fb6a1ec8259446f10a48f878b8f299f1f2eec639a58670cb2677418cb1c05d73ecb554d1007e6dfa2b3f442a63692eded4ea03731157a5807284adccba9b56deadbce2b4fdcf1896033ce83739c18ed38487c1a88aae0de4c5a3553e172e1f2dc714acea34fca838fd9bedf6bff8bc5d8f4682b53c195be693e4a4bfc5b4b4f027edc5c46ee94839070f3953bf52e07068a8fb31f65610a83d906715ba6bc769b2e71bd3c571e1f6a34b2e986d6c1291d2a3914d3962f095cb258f854fef4ac1012c990a7308eae556eac09f792227e4c315683660ce3373e00141df0426c587e935a7538515157c1439e3ed88a518627a63048926b187fc86f810a4c1d07d2da90002f2a2f784cc361c6827741ef3299ed32fda2afb337f85b280f0ae353bd792694ade84a3d25314ddbd0610967bf8951ad006bf744b6509a11d5bd26f1c6075e61f4252e1571c94fed494bb2b34bc40a824bd0e155032daf578a10f125d8ad435d737e4ed15625561eb01f4cfedf5a9320ed28bf791272b97acea8a38362c5fb05125a377f00fd177842fb37e1c0ac63a9e9f186d90cb8ba1cc498a1c2700813e1ee42330401823633584b9e46d2751eb8001e5f0a627e290fb24249c96c81638eab7d347a53991a560f7b55150354dc42479e0e592ea6be75622bfabdf46b1643d91e78f41aaf2780c6431c0c2939b02296a074f27bc7398f720fb8df3d494f7d01dfd1114e912046f74258d3e329512d2ec3aa6ec1851b15c9b718b0f8fb6e8d92f36ec5aa44d497fca2a9a771c8d236d06b74156fffd5b0f1ab21f8b0a7d0b082011bda29c80764ee3c84fc61ac403cd138d83f8a4aa0f301aa5921c2033fb2988f87521075530af97ba375b4f32e8ccc1c44c07cd3251a680762b1123363acce8a830429f506fa084a7cb8eb46a27f5ecb522f00b60e00c9d2fc3d52895ce6b3dc5600fb12046ed4e45bff64cab20ce1c3b896ad15fb4d29935abcc3c3cdf48f708be672ebf2ffbe09cfba6a12c5017a4c603598bcc952047bd8d4633a2d19fbe767729653bcff9fe21eb7030972699a8cd5c85994f0b624dadc50e5584a3d1184921dd7a4cbcb33c0c6a988ab94c6e8e857e458a8a0741b1341899e0ed4ac4cb5dda79f038b000d943e4f14027f512ce0568b61fdc2fdbc06da0a8f348bc359411fd0f5723b647c99cb0491df3e8d2e5d379964b393a7f473a83b5d83f5b3b1aea746dedb30065bb8ff39155664c866d8824464f7218c306b48f2b26eeb1efd60c6a0f0d6b8df98150a13ef736da79f77e9ac0074f57088e69f7b0844d249c6e5d6847d2c276053085d88d336bdcf37fe5902e414d1064bfd1e5331ea7cb8ecf830c2740342464bd4780d0d10faa7fc0f5038364ba086ba9f1348dfae1de8b97d7aee249e89715823e51a189eff3c1ac1c1c468045a904a412172d890ab4c4ddd0e3a1cae947fe1772f6b97308bab76c46f4a5601f3b8a591dec713a3c2a3e0e117953e266511c32cea4ecb549f8c6b3a3f66be21ac4f3995600e6277873bcf79e7260c567de7bef881f145438575af7c0b721ae8052c6dfbf4acc49203a46c2454be9968df137992271a6345c8900c06e985695b13be70e1e35ab08e735868cc4a20789085a33e146d95a8bee482d0a6de216d2004094021d08e33a6ddae5c43862df6e7daecc1f2a06b89a52909f89728c44824f65c80079d45f5256e44daa608b713e62048267daf167b8c1aa2b0c786448c059141e3f85ac23f9b77419ae8c5d515c796884015e9eca22fde26c5874b50ee75a8dcfaa02290c039931867f6e159389a6aa8feb39f35b15019bf1df4e8cd14555b4a51897407a2dbea6fab7463db7ce8f081d282634fc36ab0901fb4a74be259b83de72d25e4aaeb2c79ba4f2e82d1eab780bf42c7e2efb77d7f02868f14f689b5164bf4c216a4b185bb9d5b195118efc1730c2613abe26fe9e503a76feed9cc14afda04c87a435ec5b0a03487f84932362c493a8067c5f2bd7d5270280715f8dd6d06eaf63f0089b891675c5f6fda66be4979a9b5ac60ad6ca04cbc78d08d5ba4ef7d8ee9c90c1893b414e2952ee0868e79daa44ed0eead21cc2d92d2e84670b213941681fe2c080b5eaa612f689b20af1db86e2d34ac90f1ddc5c91ae417733ec6af7a4d9a0ad30cedda0eb881fbdba2f81b1f823c3c6b27be21156b13bb43e57d7ec55d8dcdc537267d87cff7b13eec15cc5fc79a5011985a0c6e7ec9cf337bab39e5fd5464c229f1c0a424ba87459fc2c3c6383d070e15120a4f7703cf4aad6275f1e8b1affe75e22e2554d0ec930a07ee3add6bfb825dc733b458f3054c2950c101981b1b2ca955d97f828dec3ad6262b324852aafedf339f3b0a4d484d6e7907f2f3fad6de24da59ee04a36911cea5139b85b45bfc27b1c5f96cd3403b6d52821789467a9a415fd1f7cb2a3edd94a26cd64923cf167b12ff37f27fb1e64a55c10fa416ffb9eeeb73a83ae7d40e2dc8fb283a5315088ce45bd1cc7a71e012890b9476773aff7debf1fdca304d5144c597aad85c529245b62f439247dccf191829f5a37a7a90532459ed6e094267da2cea4ece8ceace3012500ab1aaaefb5c167f97d13e05bce035e06773a5ff9c6f21b7f9f46cade2716da2ea11a69a5eba4be63531006993af9245374cb7b334aefba4a2d137892cec51b3ccf6c1dd0fa188ea04d040a8da62b059ac9615ee36abde63c20801d21e8c53af356ba7a6e3fa9e190658230dea89863759ccee0270b0e23a7ee9388e37666cbe44dc1f81f0a73f240c02ffa05c3c4d01f0c7b2e2d944e10300cd043fe0eebea69563022df0ed347f3acee298b96a3270e3bca10011f146367b63adb3682f018dc7610d397349fb8ae52101759c76a553d32e50f1e8b09cabd9a79e6aab53f0d80b8c82d24857bf36313f3eb773895597fa66f26da54e520c2b1fe2becb4140b479c60401990ca245318912528163077b5e54c3afe9b0e19ed97c330160887b43635272d440cc61db591330db65999660cca690862f5d232060ab572809c9da4ba2654eac239efc59ca1db52516c661c6e53310f357ac2ae092d56993633ab6558ed479d7114c0c483b8b3fefd2f641bffdedf0e666662d31c500cddee8e5925bc2e0510f339254bd3d9b50810262c20a53c57ad1d19c812d5f26dea32c3a1d08c3bcd9d29afdc754ff3d3fbd37dcb24284bc306605a8086bb423ab907189789cb6f2024f09010374181959f78e377a6f1190c5d861df2a8687c468766e8fd158ae043726a1dba15d6108dba5dc636db6551e062cdddb1be0094937c2c86caf6857fb137794e1e92577a7d5338f4da67cee160e63b73578853f56aea4dc53c26cf30af583b386adad6822232b1102cd04076705395cfecff0b94fce564d271a41b391a39023493e06e2efd821c247ec5b5a8c4433fbcd156c6c0d510037eff64993d5a00e8ae07a0187350853702cc2efd0b768394a89f8fe78ddc610fe9dbfd50370f35d8acb695fc3143b4985af1d11bdebc8153f788d0bcf70c3001c64f974e34776fdee74b9bc0ec14500bf4b0866cbfba07f43b25bddc85bbd8e73596dc95c21c38768130b3acf84fdc2a31fad2f988ded5ddd4e753d2a4105eb2d4ff32db9b069b6a626adc5306562cfe86f65524b4e4ba3e44f92fb0d09acd3d4c3d9aca2ee1ba4eee9a5474289dc1cce104b2a409fb91f74dee6ef88bd433378c3f2901f168db51d82fc7df27a9e1c3cb0ad7cb3372b11f0b91af98a6dbdceaa18645d67bff783f6d2477507c1604668be4d3ca71a5c61e4c9ec20b7f66c4dcde9d8d25b54e5349150896de7d954d47f80ef0f5294f5184e8894f0fca1696398f96a604228d1de230ac911662f0c3cb01edcd3175b742da4e43b145944c2d71cec32ead9299f82b8510edb21f4861172bf1141bae3753087a232f3c51c18e8f9a8c90d59946a3421ad74d1b9abf8884f3c1c23ab7a31d8ac32a5d91fe988a9dc39675d33882f6d30a97675accdcb630041f69d64ca5884f12175fab46db33cdc6aafc36f102b9fddc74eba7e15cdada99566dfabaea4fa90cd480680ade1fb2e5befb9e5840f9d31ba7027f2ccd753a85557f9c5936ac718cd9f4db779c776e63f11b64531314cf0f9acf17ee10b74e579f33447590459c45efde30a54228199cf8c200b36a61f9172be9a654725b5c8edc3a83aa287fb04fc3191e35435383d90fddd48a8d435a50db8a483e6d1687139a3ad12067dfe8cccf575e9773d38aac46c75020824f6d879a044bc50c37116a15e23e0f8535534f7f780da4ed8bae70117766428faae698551faf7d671491bbebb0360e7e6023bb5873b271afba2e2a8dff998c64f36d3a68c24b55ac721b51f942cb00eeaed090a020f1c1d307e822675445ba302dcb0329d0badf43ad6454bc1a498dbdb262fd9db4cdf519e360e33f6147fe0d76b92e3d6495e8d289cb2400cd07dac9e326fd7a308420f6ec69493be1f3fce8bd90459cfaf757b14d32a1796eebccf44894b3dc2051f95a1d45bbab39420612c2fe04fab470e9b9ed7ab4a3d49ae076c724e0332a1e0dd56994b0ddfc9ae8e366d93341af0d469b8cc1d93e8a4aa839056ee1938f58e4ac4365c5dc171959db2043d19e6fc372b14e4f4af6ce0be596704fd76b963c4de275394139ae1ab60cc5b03d38309dd8ba004f97d2efbd6755a470955ad6a275aad078341d894e0dfbaeeeeaac26cabbe05cb01674cec425b20c52973cb1ce6c4080fc63ecb98920043cdd6ebda6e467e8d2e7403fdc072630913b69a9762218fac3240e589dfade2da591c1c37a512d7669d78367572fd15863b129f142d6cc62fcb3e63668820c126facf0b3509114404cd3ad1e56da739c2fe6e65e2c1399db4249b979ecb99f5bea526282d4f005f1a5cfccf0442ed789d5a08942659f24329a8c5bc566ffbe5485119c7dcd3615e6730cae7098b7ce0273c08678eba75637b3d6473b5ee05a18a0723452e3b3d2e827a4b722b94b50eafd2e2c40ee2d6b7180ced4560c0553ad0a1f897d8d24c3fa9ad15ded8ae91dcf44a5902384b5421671b46b5612a9811662d7317236cbd2dbb7c03d759499c74c240c258ba7541656c7e1bea090eb51717d49fd5a9b404a8ecf7c1517b53fe4c23e239ee9e424a1abc207d970c92499ce5c3a1a6a18f08e293a2843a726188c03bd83f1e3fcffb4127da686ba9f8022f90c5a472fa5d433fc29bdf98e07f6f00ab939fa14ca2a02489442a47b2e88aa00ca424624deaa7eca53e62b7e162acba2f940ec3a675c192e0fb09eda6cfdcd7484a7714ed37b2b404cc0ce3ff0f52744843284ca7cbaf67b20fc15c27abdee36be59fe4023497e28b5f18b61713889ebf2a2e206e2d492e32533b339bf7dc450a3ddd50fb45ad64f3fbe0f3b55354609f17650e348f41e6c1afb820698e9592806b3f6167ab503d7c994f9bb0ad8410f12c0f77e54a4277c982cf8b6b3cd96832f008237f735d60619aa82d8c8304a92e9c978f4fe0a27bfee2b32a6be006c71d3065f4332a49c961eed2a1b34dbec4cfe42b87e6475955c3786fbd67fd97a004a202219dd0aefcac439998098b9b148f1871672208215f6a2e74cc804840b41d566471f8fed056a59df948696f46712adadb37c9e8228f520c87bb688c11ef590b7e05509ff6ddc75c33a7479fee0b4542bb440231b742af48122894c68f95e1fa471cad47ee598d9014b50c204933b176439a2cae17959e7de0091521ec05acb9290537cd8c98d6eec9a476cfc5c9fbb4ba379e3017a4ffd5ccce1958d1f78bf97756d9c827376f62ed6c0c02424e3b4e412c37f64b131db7c453078fcea2043547e3a188d1848c0b7a6ad9c0ae82bf1074aa747c0791839bb0c8e84ae84805d8ecf83e63cc8afa7684e7dadfd91e7d448da0930b5f55419c288a0e766045b6160d91f239ca9de2c8f1516168869fcae540d97ac7843b722e8b762c79b6c44ae3e713a36db51e9152576a9fa3c48f3e20d2977b6d876160cb3eb6cf00f32cad5a17882f8dc860aed71cd29dce11d79783a1f57b3cfeec8aa859baecc3c8107ceeb65572c82821821aad5b9a2f04ee8ee698e7e27852adbce28c4a4b1bb8a2840e25529e68810092073aa1ae782c20a3eb1247e7935fc83bd5eb98d0c56e06ec074d2198a7acaa7fa9e27c4f93d3cf1bb59d1c2fd5bb733a05b1b862d59e671cb76767532d1e1d9c10992a3522f555357a7aa641be5d31d96e12ce2f01e5fb04763df44a4a6ab3119f15da4f51295e9d4d8b994c921d26bde0c5ac9dff1f6c9063ced982c03e1843863e1b2ee4beb14eae225206b7bc1d7a64275f415be067a21d80c40ff704fbeea18a5e7d272a3e18e01cfce0afd774f694240ebe4195c7153fa8ee812de0e9440d6790ff7f82c4bbdf337e70fee9f3579b1eea18f0d8ce9c21f2154d39be243652edbd8f9442cb5321a63d8c19b1eb39d520ad30168dd81a8cab5cd6615364622d0a926d99c5e03e58fced798434aa7be52f7eaffc3bf671465cd1e97973ad01961742ba5f36a4230bbfb3ae1863655dbaa40f6408a19cb3e345591e5a38267b89b638ad116ec9f19d54083e846cdc62024b369675f5c66bce731a7381c08fca8f6aaa67fbc0ae2d1a4b4a287894a8325c48e6bd76256b9462996e88ebcfecd03755ed3895b7d11fa981cefc78855a3e4ef65f89899374f58fac63c904057642694ca3a00ddf0c1425ee7584325591ce554901cf0588a66f850f5c774c3770c59af82e3966af082326316b549ccde2966e806de6b158b67eee27a3140b65cdb4a888201c41b4d67108a1df7679ba270ec5ff41192e98aa9e906357e9594208cc0333072d2b3420a852b4f70cabc3aeb1c07b75d7ef61b8031c692e600d42c1a29b72482c12c270c79f2a50caf9cbda02fc74973195933518df68227698a85293d81d073f749ec2de8b81f9c1f37960a6d039eb74ecf8177883b84529afd331b575b20fe206663ab2cc91f20248bd5734ca1e4398b4a63d4a7d8ca0af9952d819b9ef64a8d0b51da0bdb6313d765c6733ca016034bbaffb80b2265d67a29a649f2d39b18332cbabf1199c91d0789c655853b3cfa0b8b4ca0f1cdecfc10d3594866964b66813af85390603d79190947602a9d890fb351b0e56311db2801578006fe0d62b96ece97f489d9bea72b1b5a097a325a6ae019f1f96de791eeec365f6d73b4fe413e2ad1a34ca323678a8a25fac926330f2e61635d13b418479da45e3c7e38aa59fc5dece2dd7e582a477e190930586812964069fa1ad2bfe6857472d9163eced21540ffbba095f55d8c2901f7f249f92949c1b20020521404593b45d050053aae1884599c60539c2c4e4cda6c11ac431d10abf111409f692bd67e42daeae0c15ce67858c2dae81db51afaf9496fa29fd2ef0e004a43be68e26bcb3af8f44525292cfbf5f36d2dcf6ece893f7801e75db10d575a61458f07bd4810da10cc83a5dc0cd4805d331db28ee78eee58fa039467b0ed2db78e52e9faf0ff6f3f3689a2f150eefbaaff12cc771e03ba2d78cf0e4e1b5434fb92d188bd7e2443fa9f8140b0cfbc13294702b6f5e05f105a1773a1fd8d7836499761390334d39bfea5121c82325921fca2d472faca08e6ee477ba18c061a8a8f1dca3f7542f297237f8d40d38823f604c0ddf6d78f5f4266bd839da718c0ba564385dcc1a16788e2fa24fbbe40a0bd5233bb9064ba834d6c2a43ac050266ef093e669a4ddad8fbb36d3577485f8c645952a27890ce1555f834c95817cdb9a4df59ac1fa3e8450bf1e8baee5b72d171dfad9ec3749f906b48fcc99e9fbd799db9e40075fd9131d5cd35f94c33b9c4cd2ddf5d705a8336d8e595be875c440778bfe99c35b333bc6ca9554192c8d957a5a756ddcda50c7e904709b6e616326f663c3a69361e2ede0e23c4d7e6e8c3c47ced6463d146af8f3732fb1e7cb9e19ead042683a1b1896986d5d13af42852b8fa365cbfb930bfb1c8c84789029fc0270448449d8a9f4d173325554ba405d454dfc5f16fdd1a193555f995f1a9f2e34cad7d921a9aaad140ef1bcd945f6842f1d0be87f756e148e0bf9199048d9854633d3739f4848003889eef60bf1db2ca4a7115c4dffec0dd626da084213b049b7ea4ec9a37486c826457e7cd43c20078a848ecbe24abe0a780701da21fbbf3243782f8700c7a4544ea28cfe38fbc7b740da504d4e3b4b4e39456f26a1b2f96793a463c5098402f9515bb3c4ba1409b2d40ae5afdc5d1a21b963484f74d9438a08f18b66c3fafc5fe07a6e151c6272fa0c14590bcc953e412fefdb7e21fe107cc88d7aee56cc921ab4094f7fe94ca80cc63de8d249ae5f9863ca511acbdae58c3b399005fda97657ef1e457129acda7617e87e1d8e60a99d5e9a47619adc6f1a14c3f258a64e2580f24fae6cb1500b8820d8fc94169e37c796b83f90eb5170b35bc336eb4ac23f46e10b7a848c4a4b8a77c26b496be4112a27eba8970e9eaa320cc18e8e2ebee33173200be7e493ea273d187b9b5b08bdd695106b4502b2fbbfad4b8bdc1131b564fee105aa13584484ac2614eafade9868f7410f279f1f6e9e45fb9ed6e0f4602e0232c80a20ee12ed3a111b5ecff51d48438c543d599815eabbecb1f2a87c2926bb26420ed41d5b67cde7e2554076b898da9346e6998b49066fdc6f71d8dd9ab6124a8652c728d1c23f1c9fca1a996e430887dc6c5eee7582549ff1f7d091fab772daae39ab2f7d311a182675f2b2fd0a45d26d1d55e9176b2ba5a5fd2ebace5619b3fb48ed9f3169723f1adf3ac515b853761b785c00bf8425cfd5a233deefd82493e8660fe0c45200936e2610e4cc3cba99a8f4396ecc2d6599c54b7ef05ef7429bf7888d266b4bd656720cc5a3d3841d46a1dabb47460f54368a88208ee9a698e9de499bae16c2b39b91c64e83ec54da4f4123b0ed21055d93dca56bebed18d629355c07a2087d002f442fbcbeae5165325006f250fab60b698cb17525ca10815b65a94494ab6dda406cb586d118dd931ce02503e27ce39c6d7e17ea47c963b4733b52442e6b2ab5b0d9411cab17c99d6c7c093f01f9ca0c367dabe9d9ff1e554e2881fdf40d55d934a10577c21a3dd3e92741dc7a454a92bf31b4c8b822b109599046f05f317acd974917b9fb5500d40a0a4481e5cb4ffa87739f0fbe51acd7707d6b424ef83ddae1fdfc22df511b17bbc0ddf957f538e5301fb81d4c08632b73b9c82a6f829cf429769f259227ea365592e574bbfddb1ee7b7082717ffd6d4ffe95a851d491cd87904f86288d0acd13dc81429a3ee957483454c95ae8ab6f9f7e2ecd0a164f67ab13edc103a3b32cfe5506850afd2c44deb60cef4ab55e7d8d5b17ea781012287341830e6ab0560dd63c0acb3bbc085740b402c0fe84c6d77eeb0ea526585be6acf89e42e38ed44158e844d87b8079d2a06330645f3f43bd89d8663347fa77b44d4a3017fbfe58daa39a0fc534d516088dab9cccfb5f24d995ccf253e73459f4306a6a74e0dd7ff8b553e5b919dcf189a5b2c3a93ef7476ffd6ff20b11d145ee65807519396e3d7d6a9937b3a256640ac28683da183a9e9147b97fdb948ab739f6970aca608a39136b31d90242f4f4e1984ab299deb142097401177e667e44f0ecf1f8c9972bc137b00ff5b38ca7baafb8621c06aeadca010a0b5ecc1dc690c9f96903784bde99e42118b02dacad05e2221118ee3949e7aecc5b03a9cdb3ac251e1ad3e421055e022e44ab7a6686316939be41557434d6f57249bf51f7ff1663a40c672974314adc488fda235cb1e1b69e22e0f01cec45ea0d7567ab19dbc1ed4c735f1f9770b43956f8268ffcda39eb3946c3fdbee2c34cc2cb14ee05eaddfabfc5852d54698f8bbdb2e2d23205dd946ab9a8fdab25f6212d6d07ee2ec6ea9c61bd1d3aa4f295253c2a2f341abd072b2856343a3cd22de3b6f69f8389ebcd7ecda0c727234d712da179bad231534c7a0a269f9b28f3cb6d387db4335375729aa49fa439b641d22ca0260c698968fffafbcf3dc15cc3e58a0d151d2a35769571009a4ff5619d92294803b99614c809005a8bcfbd830959348bb0f6c6459aca387fd26ae776e8694848c18466d8b578acee1c42f1014632d0bd11dadddc4c1985a8bc856012c3bb4c99492bc111ed2a4ac1cb117cda0f4fa9e01b2b1084e748d5e844a64d5c8bc73530b1655c70cbd6dd6cd4d3234847227f34ca84697bf293159ae55741e1ca06f1668284b747634e86a5b4be2f299632533b7f1bed95bb502ecdd4f1ebe3d52c1e42472f8064832c94e40a7267df5839e70ff7f67a9bb89dc0d1666269f965b936bd5ec55aca4c377c331c032415e8dfc46ff255fcebc9322ea1c04602ebd23dc7af27d9c4c2ba6ca6bae31a44e9ca9b49edd06bacfcc5ddb0693da2f8786db3d8c6392796c063cbe197b83864a60d987cc76f346428f38c0bba486b53912718e40e6bfa70e04e01b9e5473de89fa65df0fb977bac14510a6f34766e82fc66b2767a9cce757cd4580e62f1845c46db9d4e7c6729d39af90a37ec7b5dd72ab9b1ba1808a1401ec301d7688dbcf2a71bab853dbb7a026bcd8c94dd4fde6b13dad2aba98159fa926cffdb95bd76d042169e636c328faf3173e9c3c44c5afbc5fae975ca1a314258047807171ab6ae183a82788d0e86abfbc8f052c05096ffc9c86700fa15c6657a4e2572ba8c69320bfe36cf851b360205f14461462c5a8f517d79b995c5b1bb31db2098707371cca91eb2a9650373d038ed0651ac88d907dee911a7bccbcc96702a8c533b27ff92d4d0d7146afef94a5213c0309dc44521868021bbc11b8d5c5391945c3f9fbbec7140d76662288b565937bc73cd196308c7d966c020f6a348b0ef02ce84988045f58e03b44c0a4bdc0eb8fb4c58e1d02c966a20c46799f3d46c4d06c62d6db4a6d4470708d189008c8d12e9bd760e773a70c98047150761df88635edaba0ffeacf668ab3078b0ef3e2ee6b197e2cce05c2a1b73f6e1e47ada44bb1413189cc01e07c1d9e8dc6669547c4d595e20a88744596b732ca57b30b15d7e7fc734a5931d33196a73fea98ba34577eec13ed1904065442198a58b87ef37ae2fdfcdeb82cc91f38f807953c0282211f3acece23c4d811f678468c1dd8c7d7a7a07859ec4aae96d504a61f63ff0a5191ba3f29ff818fc821889ceda5d74f1dc3ad15b0ae3584a88463a55c0dd6448007f6d6e14e19593e452ff05a63a7d76ac80f31598e308f3dfeda084803cf206bbb9fd46074098fc809319681a6836f26f2c45de4eeabe31b0359b2068f05463b025edc086f04c7faca331fc5ee9673027ccfe80ca9c0b1b4994cfc2c16fd34d4f8bd669b3256d7797b32601694f7f87cc008fd2bb264fda92d9c21eff0bd1b937c9e0ebbf1e2f3ff6855c428d4cff79ce691d1ad327dff76f19a08ee1cef08770d57fe980eb95440d123a365310ab4b3c932d855e2d2db398f0004d1cfdf0a0a0d6f5575977008fc01f7662ba1a7ea2f6587f6c681dfb62cc90ece193c95b4e045ffb27b727c2a13449be6936923f7a3ad5e1f86737c4108140586ec0f3d4688481776959254b16565d23d34d2e09fe6cc38482add4b13e6a1818c09d4774094cd887e2589143fa599863f0ee52c3ddb2181b365e00105486b7e6b2db238611591edb8aff9dc85a787ec33509cf8310c897e12769acda75d459d7fe76a74725d83ba589a6cc8b2bee15e57b682e2425565998533ca930afa510cd2345291b4eb55b919e073cbc8d19859bc0b85a5a8435981bc423b31e6531019fe6a4ce7c171e69953018154b6c108ad9f823ea0e0ccce4b0846f4e49f6bbe598227b510e3c0f4ebed69b232b7d5bb0ffd7f6ef4506477f8d071905d08ccb1cda50309348330b0e33934e05941277dcdb00f3395e9e03140f881dab67fa347c51f6f7f7220036ff26562d018133a13cbc8687c53cbdf4090faf6dbd78028b54c8cdba3ca1da097f976a9e6499abc3673602b43fd97f3c58df473806360a541f7bb8a4af7fed38b32ba8193335d15125dcf8208230c4a6a6cdcd0ef8a583f9e11ab9a73342c2de0fd7c10276421f1e1a0d8775741a683153ae312a4e5846bc9d16756bfb3c63d851902831041ca351ff13693f994eeee6f879b2270d7ea91d058ad1ec854b4ffad5c715549f30acbebf0d4a89000a9d78b67d75cf8720a88077963917afa457a4b08e03f473edd0346b8d00dbd175b8bd9112285f81dd5bfdee72545c3db1aad0dbe4fdc04c8fd5f353a4820c34531945338a187fa85d8a56560cfdb912c43e05ff67bb2b59dfe8dc8ac487cdd6ca1e186bfec3102f295e7e0f2e98630f3d53dfb6dd1bc4e6b074e4f5e3e3654619b5d82b15d684aa74fab39ab94174002ca81e6a7fd356201fa748fdc88dc4fe5dca5693f88c0771f531cb0b776e0c9e4b5d1f84d51ec54cab38d3a3dcf612936c6ec6b5c91a632d72f6287bb2762f13973ac060ee6a18eb7803eb0f6ab55045905d129dff6b3c9b0daea1c31c625956e8e698315d20a5afa4dc8244db139e4a28595ed7d7f1e7eee74680c4622f98a33b3d7f99c1d5a8f87a5d692402efae1c177550e2d7f697ba3a17bf1d1da437f9924814e06ac97e0c7083efe829e7f8a2f5951196f8e8e2a308a80ac468482d842e65f9480896ed1b7898293cca8ca2b9a56bfdcefbdfe82806ad9d16af2abc1f3119ed3e16f38b894532922eaea68f5549a38558ddebb2771628bbf7c69c47f739e6f65cf2a1b55bd4e931240d0b3786806e0951e4a5c3d958d89b313816975323b875c480ec4f93edc164b3b53ffcf6ce525b1e2b5ff07c75e20febb7141bf12b0ecc0ee6ced4ac6c8856d34eae07dd826d2663d9a3e80d6c1c89ad9d091fc82ecbf5ea148e00893934afac81ea487ce4b356e1c4ad77e2104be6b76a6858047609bf7d8d5936b490eea14c66c03cb23e1696aa919d443ed5c99a44c8dee4f6d37af625117a0ba21839c18de5394b8ed64700b3b198b1a36d55cc2d55ddf0d6c1ce30fbe2e95cb1859944167f840fa3d891cb99a3595e6c95c372965837e0cc2433c04776f499b5a7deb445a473412358230f846a183acc965b842806994d0536599042fa7c8b32e5cc0fa7ef294bace1068d31873f666e82f1539a23a9b82a50222b1492116321cec1205eea6b8cadbea74da26f511ccdc61d382249a739027626614ddc3025fa5bd61132822c89dff0c73e52a0905651fc97fd86789fa1f753c6ce5e2790e8c3a25c815a6fc7defa80ffa5ae6593d17fa2073ca280dc2ab1fe31e9e0f7303902ba946542d8512657625f44549da59f65dd5787984330285cd2efc0b9fc5079f1b0b50f14fc3d18c0a238d0562378f136b68e86b932a55b2a0e706242ffb8d84753b3093f8e9b17f1dc410ddd7c8f06db9275545077698e95ed58545ed99e0881274fd918793060af8c7ee86522e1307d3e175c4df29272125d1fac1402573963d62f28c88f17d59b4debb5d65ed54abd540330d52425c28d715bea48406e734bce5a66110d80841808cf4c73716002b748408b44add9ac3974de4dcda21c312b00112a90bfeec8a235cb9a2248e15d2f849749935466f6a3954f7f118f58eba9d08d16fade8028607877334fa4e0341b13544b49f052114350b1ce4ba4b6e047ead715d5c3faefb851ff3cf6ad8b2bc368158f0fbe0355257683c4628d0ddae7f2e855ee4e4e700d71485dca730a458fd955deb3029f6e94bfde88dbe188a7dadc95e2548dadc65c8c90fabda22182fd38374b56704390dd0def6ecab5735aed473f23e14ff31a7f4291c2246dfba94aeb602aa154dcd2d3f113eeea765fff86785d255a5cbad20d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
