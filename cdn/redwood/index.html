<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"05d24d0981ba781474e57879710c1dc7cf568333fac02f7de80ace6a5a3e099fdbf7983ac2a4c2c1836d6f9075ff8e86a1f553170b068baf3f07a1b6142fc1aa571b66ecfeade243e01b23661fdba289f59f8c62eee7329c2d2982857d133c0a4b0c1bb7ca747d605788c841095edd7a40c3f05f54361602067d9e9dfe7012f1663fb11d1bc508302abfad240ff63c6590a0f44119d43fd4d01cb7c8b160bc57f4c93d107063f195b271cf570bbf5b9d43948073bd1f1230cbca2f3aefaf82bca46154306a85defa881046919171b481c7ea2ed4ad67eee614811d1b6fc0e5863a391d015f0d4ad293c622a1aecedb6a1bf24aa014307d077eae879f26dbb1597d137325aa2c9f579b030a51c39ff27d652cf2f7f43547a99fddb7e426643d348fbd76339e6d9898d97e3c5f49a7987a12c9034ac3081c413e17243822416daba7315236104705252e3140bbf8dc0c85f2a87fb199eacbaabf6a01fa1d53c121f659025eb05eda764c80082ceff5bf2fb2bf655f86af7d1cffd21a04af54ea19c786cf52d7580b363382eca5354fa56ad26520ce4a6c1266a82cb0c458df51b8551047499ff17e387b278c2f5616c996eadeffefa37fdebd3703cf64eb841122d097b42531301999b5a3f14fe375e57456fdbfa13a8d639c3c1dfe001b9f6fd22af3daeac703219822642e6cfc31369f6c0c44045cad864a71cd9bc88547203eedd60212a309ff3aef510ab1f27caef7823291502d14b9aedb16a3d74babb3438d6f6f3ade344285263bef5799bc879a9f578ec99c461059f583c4b988579bffcf0d557c5e0f6dcecbbfba17ece5209e10bd8ffcb9429c9e8da3d3f43759b5cab7f7d714e3755b240c8135ea707e263d9c6f87bfd2c17f23beab89802ad18c1768ce4af8ef5a95617e34f7633f28f352ffc290c9719108b3f243bbbe9fed8a4cba3b8d08b46654c996a14e52b9d865c9a94ef64bd62f8504ebcc91d740039051bc22e98b2f16104dcbbf45eca2a797b5eaa7c81495e5d988d69aa376d87d7557bb147a9030ee06348bfa078c4db23e9765832ecd39793a5b3f5a7243cc9e62576e297394319b84828bf49872ab81d67503716c9531ec587c4bf4b588ebbdb03849c70a204a2a6064a36eaf70004f625b415d389dcae57c082addf13c6284ea141868786780993e7df0ed3eca4f29642b829d5e79abf0af1a13c2f6fdc01a7ead6ca708e95c3093b5d2ea596e23b351bc4a7010d88a8f8b2a984728bc4fea7d5ab7a7978df627b69bca1dbe5f9dc4bd6a96482c8721955f9fd58ba9aa1a6b29bfb2bf391aad4576dfb2fc6d1720d21e9eacc68ec74cc60ee467a562a64538dc5a9195e35333783db4778c1f3d1c365796f24921c3f428bc7028e6b60c3a6d12b9513da2d316a7ea3ddf3f174007739a03f22590d220eb5a158db56b852b38a15bdb0d63b34a12b92cd322b161497b87f0e68f52f1aea5a14a174278b2c678d83071296d072091d3c4627b73253f87bccddbc89565be8c2d0f23633909cb6c9e74c21e5cfef82995067ae7179f322074864f5aab0eef4669734efc9c0bdc32b48f0f0a48e201824f365e60f819c93edbc588d954ad5ae3aea5ab5307e15a8b30b339c8ca919a273d5adf0c452b0fa184af23f92e51f8b223c2f236c276aee686f8bc7b681b15cf30194cbbe8dc175327731e36257924831f92631186d20bb74dc551cb49ba4e3a4f70258e2c83e8e5cad8f386e628dc99574345b615605279f393bafe2e2a50d6476e74df0bcf05950b877252d6abc8f7e4d6ba0b57667d424816c746d2513cd283d945414ae39bbb1f4fe28d6546991fee87355c45707ca081d312bb52754d7d6ceb438e6af4cfe4f89f107dba9f84f9f7aad0c54d8051658eb7bddf9ed966c7814b0bf62a26b42f9d7cce1f2685032135e8c8a2bcbd9d31f7baf1c5c6fa6d5e48ead0d7c063290c638240808f7c5cef717681dad7ccdfc8a28a7b6599713f869d5315d6e94c5b0b762fab3a3d129fd6de4432aabdbd6118f31edad6a841ca56807d45b5cd3715b05990c5568a0bf1b3b705193510b29c9e51e66d1357e5d2fa54478b6f68ce132373de8d0a2f87fda5278c4a3a898cfceebed3f8c25cfcb862631ded8b8e629960d900ec60b71d3cf9ae9613e4ce379663a871327aaa15cf6c7d17bacefcf8c655fffab018a8a394cc4801f50ba5051166faecfe36c184015f5e1325b73b87f60e5bd7797bde63717f9edfe325237be8d71f908d5885b72d438e0388ed28080277f7e4f0595619daef5f8bbc2ebb4134d3cc8d549c47d09de81e981dfedf6dc1272348ace02f63dda93c08feeb3c8c915b6545673648faf2690849d46de03cfcaf0d5e58d14ba0593924ac62b7070dff5cb33b058c67a43b6dd8fb9735787db7d544a793f9de8adb4572099e22425e247ff0286f07ebe7ebe1c1f289c46d67937abee4b3871d341c5b6e1723ad9e8767382442cbfc6ab0b196e75c12198a1850c2f910f6018b379f657c4fbaaeacf72aaae9302f2bf2c0535eec76cab66f6067b7472239c68042c803e4e7ed5b016a44a19b2a4354f2739b56f036ce6b8d9d63ac77edeb3c464b64c1c44685891be71e292c1831c231123373a2a6aebb82a530e0fe8b7ebeabb981118a2fd6f8aa8bbb4e5ea9ddf3baa59f7f1e558ffb30c848f0e2ad1c4df855e4010483c071c28c827227f379193374697aa555ff3448d9f2663bdacf9bef9281e2354fc4ac7388c31f991ec4c73a187ef07306621eb5a1424ab6ea708e76edbccd8afcb0a0dd6213bc63c1215b79d73cad4c99a37f6ad0eca671ed05005596ca427db870657a542a4b2b6a0064242772cfeb6f11ffb3ad1d4ac341d40a0b3e94aaf494c94d6f34330cc2a80f88e7bb2848f7e531ce895859d65642a3333a8bd6a8094a19e03d1b1f35a7de7f553d007840f5131006e45e150ecc50c1c6b892c111defdb2f68d2be396038e3c2bcabff05d5bc7b6de8eaae6a70c3ded552f9676d68d05ae476bf371723067849b2cc7b2e7a689aafa9efde788a2972d5119c0f182f9cfecddc36e7a5745cc5a55b5762c55f7b05ccdc57debe1391e50de4451a24cab5f6907b2704574e55d6260bc873d7d94919d0ddd4fdb96a0e4d311de672c668b504600472a068a18243296e87eb15f679e5b805c591a474dfa62be1d01f1457ddefd5381b642a23251dc271c7cad6d5381a38f663e5d881cee42e982b03c23a09f4325ce014d55b13242a4a0886169ca2e5b0fbeae3733fbe3ed5c3fce3320904b964a16189efef43d954f31a2bfba8a3c28e76db84f61a8ae8cb3facd011e0e1b91ecc343ec4c77abd27b4e238c1df8663dcf1129b76a9a5a735fbeb0b6ee606af940ecfc63c6db23f5efd98b094cd28f3b8aad221fd0f950fb1b64959ff088949b42c1df42452a9a60b87cb383e52f740a491d45a32ef183dcd60a6b3eecf845c5f6af1a1d1e9d8db56adfb431a969694a7f17681012061898cc68ed1ed53f0c3947f79826d75979e0e0fb2c51044f9eb5f77b667cd60052782504a24084bd868777f6e7bc353a952b6161bf440a73670ceea5b26d92718f08658e4bc3a3aa8dfbdde565ded8d00aec27bd43750e664f2f8a3488a8352bb96837b7790d7d58885fc2c5897c87c3aada592fdcf2fca1f675c6fd5acab05a61bdbcdd38d88d7ec46185566f6627deb18d218566b2533af7a67fa16709ea9fe658255bfc917c46e06708d0f6c8899c447f625e096efdb5ee41b53aa4c257b248db98c4dca8116261f42642b9f56aa7e3bf470a8be51a5532e5a8f74d350f5e5ae9e0f9b0c3d695c90747a0af7a91f19cccbbe97d18f7abb1b1176f9ceb1653341029557c758b775e672f6802ac7f5b57edeb6b707a520a7f30b1e00f199488dc0a26f1261fd77a471ec305b987362f9cadfdb4c2136d9d5802f7aa54df2989e1b87d97090a617774fdccf8973a5f2aaff15240d36ef4086f104c89f4f0fe7f444369c9d7f1225bd0e7e70da54c444bee23989baeb32079fb1479326bb21e9f4eca17663362aad617bfd0bd2f5a7026aec1a8f23244aa65256f64daaf4dda16a94c4379bf60ceddda456c29a6a42f61e1f6bc2396de51f43cbcd10c6ba0e01a41736a0195d720c668774ec4506759141ed11232116a1624fe0a097d00187f483aa864813ac2a3589a1b1f51396bc6b2fe0b7ec9ec2a2712e4dd16ed8e57ec54a2ec2016fbfcd73af2ff097309a8e4aa08c6ed8042475e07896f15dbd75b4ecc11e879ac6632dfe326d99c2141b8cd80dfa482bf2de85e917ab28745440c8541f8b0436198af0c4bf6e80a5949289ff66f7394044792311857eb9c766ff688bfa56066618e6e5c44dc7a6c1ce6cf158e8daf3f6a775f87662b59719f311f945e522b6e1d5d0a870f268611a53eedabccbee8c5ed1114927113e419410a61e4b591b4048f1a60fe0827329c7781fa185ed6668005b65a184f6c957115239b89e85e2e5b5d7ee23b283524b0cb7a9ea663165f92c65ef39e61f27cf097e39e22c68ea63937313354e6692b954d97867d0c770e8be77d5b101b026d0ab94ccf48b6f1a737802854132e7e1e84a795418df65ee6a68ca8a673fe35d0adc69c8455d47edda56f7a6de7144a953191a542a4e2772aa99a5932ee1cdf961a69edcc387377b52183988ce8e554b5fb962c6fdf28c88f4d27ac1cd70da8ed38b905089522895555965d32383c6954530c53284c0ec8482b05375d8f5febbe95eb03d71a894015245c343615f8624822518555390634e3fdca8fc2c5be943a3d602c9f97d3b24e6de8e8947a18d24a5a01fffa5c519a004c7c05160ed4041bebd44c66383033233e6761fd4f79cba75f2ec57e8e984d57117ee4a3d391db92538c9347591c60b3b4bb68850294b2071f1d6b051922f984b5ca36e2672adb8eeb63db2ec2b8f418b406d116add4513ee5c1e1d0bdc712fe772c94b61db6328a19f8428c36556ffe24ec154dbc8a697fc93265a80b0a1f00a377d98889d6aa0c752b376979ce6a852da8185de5cf7e990b282ad098e2be634623229bf1462efdd6c48f6e3b8e2256f2516a34691bf8f5d79a57bc5cc1e92372b2069f9902f274b1e9732ee34a91178ce401a3920c608c7544b633dcb33eb0742f638bbd5c14cd02c34db7cb905528984e2ef0f8d1ec3aa6b6bf0cf6a214b3e69182c767bae2a4c5f784dd1476eb19c690fe0afbfe7262a0b2d8262f6ac1bc68e501a91419c47bc3e703bb6a04f4c010ee0776816a8c466c6916a2b513e9385d8f2166dbf85be5cefae24b05c5abe80f3c4539c0171d6f2e3ed848d5590e4e8a719ba2feaecc90b74f8beee31f3cbd6c6b4a7c6e5fd3a39072f1a9b16c3037857c4ce92cf2afb68895fa1728eef60785597730e30f09a8083340f1e0a8cd49d1802dbf4d622cd0d25620ac6a33eb6300a4f20c3f728dc7adca7670421f63c5fb7b1f8a44ae021ccb73478e044a4db913d751e41ddf4f4ccd47c21c827b0ed2ef79a8f0ea6c282246262ac089c5803dfce494b4d836cc2e93b9996a8846e12d127ca0156533c5482984996fe5af462997bb4749e45b27d2ddd309e2f5695d26d095ab3f25c946c19c4c4ad7d50f04ec6b96de9d9d1fba477eb1db21be9addcf762819fe1b19480da80c4530d2846458576cea25e83674780277f94074952613ceb77494a694c3c6dab3a3f516c149a6e250d2d6182f342b22eb4fd3d3259b5bb97f419cf8607641b548b23eee98ba6f80b0fea4f4fb2e3fbafb29091124c46a22c42fc656e28a83bf36a0352277398e0c2b183598e58a4dbb5c9a0a511abfca5ed37cb5538516b8fe0bc02c70d1482596a3b7ecf5d5db725d504fbfac15b2cd2e0af7a7ad74219c63887599b5192efcdec622b9a43dce62ee1b287ef35510d90d8ef4a7e6d0e99a72c0fe9722c534e01840e0edacd9993cba70c512bc95c8d1d977e9b82c4713132b90ac6ab27b08f73c11f857af3750f8727399391958df6ed8518dddbed101c9d787b3b83fd6f81848bd14b64c450d41e4e920525ca6d675f34c43e2447fdfa6168f5060a0b16a7b2573bf0789a1411338f12db12046a85e28e4849a40ef7b24f0befc08cb1d75bc50eef9954226f6f95fde13a27f2ea797fc2130b0df3d240f947f3b737decdd45ad26a9c377321e1daa93bc4bc3516f63535a416bb5bfddc7e55c56ed6a8b5d1a917484d55271e787ab9922a19471198b13a8120661e1d3c3ca6c8f35d5e8af525d7f2cecec919cb222246b5c5398ba96a093de7eecd36d632108df7dbf8fdce567dd51088cb92136572ad6f4b3ae253befc56ff90d1c5c137b4981e12becd9182600641cc31b600a79bc618e6a6789c8ee802bed3469595361bb6fb0ba674db28c816b3082e9dc0b484353a73dddab83765d7ddc8303a96c6764baa01aed9ec9c55b82d589f70705dcf365fb3b8e052eb7fd03fd8817fdce82d11f25588c31bd7cb0256db4fd93710fb1fe624016df277432f8280b9d47387acdc51e47b25d02da522227c2ee6a9b8a24f32e8053d3340c2ff6b727dde09b7a076fbebd170be67e76fb3823d448417923eae40675a0ccfa3dde5bc88b2c2090f4e952d94711c2c692475c6ad7d4d4d0efaaabb9167e713d2f5ad3649ef76de17fb01cc479c0b6540a347979bd8225fabbc6e8a2f54a2c81678bb91679da5090d7ecb1c127cfb046f5f69079af23012ccac90bec0c3aa06cfd6e8538a87c897244694aeaaf90037e8f29108a3c4cfe25eaefca2b965f0fe849560f94ad24b54d73310444c2ad77939c859533e933167f46baae1ecd63bdb218b23eae96509803245db27f340f57e5dec1de102ade2e8acd3a02b3b9a7b80699678cb005b0d5bf5a43310206fd21d6159408f32c088447ed2551fe8c05b788c74b90f07bfdfd27f0d478da84fe533fc1712080416325318e2182a52d9a7c6f2350053a41cfc71667c88495f6328a7285aff40ec288339cdcc4a722f779791b37d06da79af3c20c7d7243866bd5706134307e7268c0d0199782ab5e7ed7c81dbd07ee306c42ac74e502644898c2bbf6f6e1b394e23ed61d615652370376c170cff35fa492307af8ad9f9552f7edebfae3c517598e7322779a84745b1c6ec8a571dd2a1eeee2b08ddb87086abb891c9f290012ca63def9a08869d928a72b74c117ba1acd76e66fd0b413635c00706001d4a2fd83202a31e3d4d1761ad5d6528572665290428e3aaaaaf78c8211632fa837dd24dde67f3815a3047766a140f793afd3c9235ba1408afe842d1773952ebad858dffd20fb98eef9ffb4119a43140c3cfbf4604ac3d5055cb3e7e99caad5d301f7b6da642dfb2fcf5b712d377fcefa564b13f5b6b637aafd9e0d582ad8658f1d90c2dea1cd1aa1f778a05c4fbfab331ad54545e93eead318378cfdef29b680970422accf5c825f31d17997da02c1c7498966cc9af3f71f62d4339dc33856afad6da415841e896b8db37707da0542dbf993bb28e8c4f4ab05f72cc68b93b30a22586e6068bfa8367edebe543bb256b5a0ed224b0606aea79066e39cd91fc8037be1323c7094e40b50535871d187a20716670865231552f655a409a10b9214440edfd97664d8d9822a2e6ae42121358766c2788c2bbc43cd8cdad8f867ca983290cf67cdb7a6705d020bcafcff001aabc3ea57531b457c92e5695fa42c71912e93155714666d6f92e3bc44fb405371c2ebebd4c96e1421e53aa41dee10d136eb5564b6b1b7249a3a0f87789f2434621a61d2043e3394aa87564a32dc2df2a41b889553910ddaa63f8f3a10361cff20431f6202d14fffefc913fa9b7b0d21f1a67aaaab5e9fdf70a488e419df698caf067d2553f78d63dc42b6c99ec136f29cd090c7a22737029fee9f78ec1975094543106f51168cd3c6dcdd825f03d18dbbe762740ef5fa170705f35c52bbcda6a7c13d31991ecb469599ecc3452d21221fb4278652cd857bc83c114d29ff22bc08abaa9e87559abcb4179d83aa4c6fe91d8dacbddb98c39c1b50aafe4d6892130e5c10d09b13a5075dd3eda729c3423af0fd797bbb63b62b4ab19b881c2247c9933fe8747729e81a3dcb02117bb7b567356e8d46d92ae6c50f555244dcec5c9b9c18a84f2b113616881ff94993b4ae5a891cbf216ae1bab7e459e1bf0d87c0f403b365cc8be6b100bf50d2b282867fe4f9182b3695779700a882813f3882e5b482dd63ce8f88639c9a0f39ee68bc405f1c90ff8adcd108e4e47224360093d72e2b250a8defec13496ee11c41187217d9d6d043f3fb6804c97a8393724059afdd73821dc9ba89a13b5e76e54bc6c8af05fe76c8e9789ccb0de407256c4fb3d4c0759120eb91a35a849ccec69e8303dd479abc405e7b53a7d428d28a95a768ea1b00d3a0adf79937008c103fb46b7434d39dc115a82aa0f20af63eb7110fdc25ea20ff9135bab38323baae961061760016c8b40d1d22ec1404c52ff64bd5b3a4e1e1d1b55623f65987df5631e9111d284d0a383d86d5724a36c94e2c43350ba1162a263c8f35d3220960707337d7be103b6bede871db8c4d05da6e722700bea1822d7683fd0837b510dad4add80cba2aad19e259b9540f21cab49f74215c480af13b32903ade5fa45f842d85a394b2d794a83103406dea0602bd4be8a7e4261fc131a5c5154b4c0d9ec60a1ba933ed989465106d83044385cf0c738e7f61b72e6505d92dc3479cc959fc19d5f43445bbd691bfc2106730caac148d76b0f69572821834b67536a012163c438a74e880713abd0f108a1d1ba818232e8c4d9db0f7b79754307a71ad12ad85bc9f186ccdede336a6f03b0d7f47161bddada5c707d6b9225244b64642fcbc7a917a914b02e3998aef3b2ab5db4cbac2374ec195c35359dead6655813994a148abbb097004ec8065f747239a7e7ca7f6ecb0e54492b8c907ea269e87ecbbc4433470fd2f702c20ae017e0a08104782581eacc9a5053932701d601e9f1f90e8ffd6bcbd5cfba7454a7375abec892b2332413b921e71d31d480a90309c248c0d870706e57295a8ec786a06fde002de7cb9b9e01f726fb0472364c1ed3acbadfb5d239d698f327155c0010267adc56023c2a7b2a667dd7a9d8bc086b26239c3db8d19c36a329affdb6dea0e826458aaf047f25dc54b8846a0115f4c8334e591df1dcb65da11219a73bdb1078c5daa90cf2e3a5898bffb5412818861ebbab450e1b45c69d8a32b322743650b2ac25c6351999f94a4fd34266b92d691dc5de1c6e694e804a2cb2d4c7061f69156b28f0236eb60fe42fd4e527e552eb59197e3134bb516d5b7fae0f84a4b35300fe0f95a61b9a62e05923d8b7bf28489b3b26dd1743a2580a383676f1577d71bdc464da831652e042c59054018fb1822b6a9bbebb1284779f6e94e3060c66a94560ad93ac253074d76b248323857da60b1b47ac74a939e10f1e089b184b9aa3d2123b82d7b214c361ae2e1ab5f36c569473111bb1819e1ea1f98565545aa4b29eb7b5d2a2f936785fb30d9e2f1bc403407e129b9be465cb98b03a5fc63bd47e8b3e391b67a2fe677d641d50e06f171eda7eaf10857f702050c2d03826411cda7c91a9f2195b716ad3ba1d0c0039e56a9e2904460e0ffe463ef13702595ececce952328ae560807817f23ea3a8010ce96930eb9b676cb822481085156a34885a329db64c81acc126004d57605f0755ddc394c609dd273501d0246b037e60e3eaac3d55e573ee21f9b5b25968f64030eb94fd2e838648b7f53bcdfa307931fa5fcb3be55ae14d30a8baeae8731d10c633c26c01b93a6cd49d9c5d0826d0eb2ba3a36be04ecbff4c854c121e3be94560de3d2183680519e8ce9bd23cab791057e7efe293bce48e4926c00aa80e9dff03c94a3b8b73e38058a1a122bf8a4d671b770569d12b8aff0ff8a876d4cc96c5eabd6cc3f68268444cc2abaa12a28e967ee3e5cdb43917c311664daad735fcc464581660646248f71aef70ec734e0d278ec61a2a776882da12a269e98ac654d59e9e0d94a7b957e00689caff65b4b2d02c7cbc99209dacdd7fef0681e76d2eab5b50f0bf2894ef7aed34b22c2dbdfa91880ef2f6807b415054803d3c7d9c79e0217588976b517a5cb8d752b69e5629dbbe5ea99aedc6cfdf6e6364225ea3426825868b3d06d6d790dbf3fffeb7c142bec4ae945943f8340fa0e16789f50a0e28bcf6d122fd2505271e81ca8dcb4ba018d8a137ef2a037bed8f993ec5b391be9f85a6026d43cc000911c3a2467e16b3f6114709eeb680e7364a9630774182c0a5c0ab3b775c16999a0607ee336fc602271311aba74d6e9aec63169e592560b8c2718aa7d7f892d50906800cec5d094c251291e5f1677739a84bd06deabcd5f35697c7528c9684110a82471178e02fa1994ec1c5d18e3dc0d05dbc5f62dbf7fa9ee7ba2cee7db3a765438a469d3887bf9cf3f3a16bb9014a4603bfe666060a7ba69f818e22ddc1f7d5c5e025de7b7785eeefbba1d00ee5f3b4068b5fbb501e4085af80d53e757d38894c72d6143e98e64fa437b3ccb74275f0b668cd1ff9dccbb8ab06d7ef91d922c33ce87682f9d67de94dce035e16fe45e966f5a608d497c74ebf3a1663de0579791a16a9ea590362ff5940b6e72266f81f34fc9482322cb4f073326838610cb2f357042e5b01c9912604626b56da3df88dccf1473c19c90755dc17d6a66a6a4637eb312d54cee38a8703f757869015a5aa6e672624182d5545a6e1754c063d7be8a53deeb8ac63199b3ccadce05afbfeb1ef35fc3e174d0190d156bd14ce97f592d29a00777d73715c08b491661ba71a1780c5755859c7edd1396bb66be62820f6bbf36de7649efc4f255f7b62f3f3b168f961306b7f736f19564583b4b6094096798a90364f759ab6d0e1218d23bdf0522a80d4eb757dad123969f9007276632c971af82729da473d5f0daf86a3364362acff799c4ac1e7db6cebff8236ccd4c35d142a498e1c64072bac57d0693a49202a2b1d932a1fbe60cc59e16fb6261004dd03a8c590cac99569240d5b645854c8e58a3544629e4d09eea0a8c6880ce7aa58e07559c55e7928dadff6fb25dc0b41a7c9b751204669311ce27fbda5d7fa54afad41e6490c2b7fff19b9097950f1c53e36153a27ea646142a24361bca173ee28333565dd537d52af6ecc8d8746437f24bb9016abb28310b2442639ec98bdb80034c5c0dd98f4ed412e0bccee8f6fc9dd94feb446020b9231ec13572c4cdc911f11fc839246f73893003f87618490d4ee91d89fae8b378b0d4c97f19ce7c7744f0be2dc8e3a3cb9b8961c339fb3b057803083fbd2fd482ef0160c82bfff79e66a50a8039ba36150e80c82cc524910a9d02ac6cc8ab7926102d6627817c9acb9dfc0a22beb49a8ec60ea799b18446fd1e6d5d1a1950ee0616d7aa1f923011625fce20cb4bb2c13fc8c13407dd01be29bba7e2dfa1328006ec40e18e2b46c6f68f0a0423bfaa2cc2e4fea1194c7c0df915f9fab2c9eac215bca30318e05c6b66d5ddf4a0e2c3b934371fc604c5c27081435aa2ad40953f2c3b6cd1c82cb99ecdda518430919de90b48bba1800b7728e411cc5ddcaab3f256a1f352492c1c5da0d9018e9cb13a52f46f331ffe9e0dab88dc5783ab68ddbdaec279a04ad4d243efb19e07fa3205793158ca7e1768eb72c49c7d5a38fc94eae07d12b94c90fd417d6cd5d11cc50735b70630aa5f43570c4602650e15af8f9f0327ab69b2207ae82bba415934de09ded32ad958a940bad7076e6e8eda406794105defcf0abb7a88d9c1f24771f7d0be6164f8372a1bc000df23440ef21f914269026f022b94c38a92269522c100a44d62cbfa38780170a5aa7ce3c540f7a58b86b930db768c32817473847ab0185ecfd23e49115c33c940e406abd4c0e36aa43706f99330e1871bd3719250e798ef90c41ab23e312f88740b4198bc10e73fd2feea3cc1cc048f1c5e2785a4895c12b6732ddf5a601758cadbcf19356ccceff7c4c8a0fe2b6ffa8f47a7db1961f98e0848cd59583415cf9002d8c75b061f24bf228d7cf19ec00ec33c41c50958609bb5047ab751bbfd63e26eb809c2537769d62c3ac4e48b0a92792d34525efba82adfb0caa0ae8b99f851c624f816e33ca52355a5e607b0eb7a99b0e5f5de36817e0f188171becf44140d63ee3f53055badbcf7864685def3dca6e7b28d185f5ce6079fd699cf0aac5a456e4e033c2bc2610ac1297809adccb94cdc949d9a85e7da1d213ad630d7595e76026b739445bc1ae65f43b45a115f8c763d1646bdceb880a34759ad97a53c9caeb3af4563ba4d842f1023064aa6c7a9a0f5a7429be99872d5d5f9c833c97edc4d0df3112e6446e900f9e0f178881db06b7d4ff0a19157d0e3300eae1865d2327359ba022f1163b464c52a8f10596d1ccca08a5dea2479d328b58b10e733673cd548655cbac5b18818a911ae1da86acc495d7db962dab9d51f9998f24cabb2f5a03cb9837715565d1d6aa90da00199ce2dcde4feb98d02af1f65dd4bdb731efd45b7da84d3f67c1fef9f2f19a902d8572b7e0c7e7758f7a707528db05cc635ff131c262e7fed8ca75d9e8365e06b3493e474d25665c418b73f94fbaefce393f689a53e03f9f2e13d32c50dd8648735454b5fe4127aefcf8e915ec9c86e1f4f53c9a2213e1b0e49b6b61a1788b168c8700522a779afafb8ea4b1c923f701da251585ab7676d817f7f9e01605637347943002943efac58f0bf8669887e59f54e921ff98a4e38052d66f59b1405cb05a40f5095e4be5994a582b60c60cf16943394b1b5032a5256887dcc9720c2262a13d4b99547a3a6a1d59feac1ceaadb2919ba323546a22fcfebcc7aa8c6bb0efa58fb2d8d059a19e41288b10d2792806cc748282acc9ff8bc4543ea1800e9bee17a27fdb587ddd77c44b7993497d40be33a53edf4467942f298c5565f1ffdc09deb7efc916af2b7b3df644e45beda9be8cd0721c6fcb235738d694d4414e2a45fadf8bf97f66f4799f41c6c60039e1d5bbc80eb5b0da8be257358ae33579d5953081a6ab657b9243cadda81306bd505fb47ff0c82ecb37e08a8bdcd10f5cd9c0cbc39ae11d398c04dfd347b33708fc313ea6323a60daadd4bb125e4b6fbbdce5643234b291a2a382401f43ce68ec8b95cfc3b7d4e4fab0aa1b8ff64679b8c9d87c4a26bb14bbe857855760ca3d3043997d93660a615fece9b518fcfef752f559efdd9b63b8ae170bd59ec3da70b862a31f5ee9add71303cc49a0a97a1f21d204389a82f9c656dc9c479387d07897eafda44bdcbd50ca4857b2cbfe624e06270fd127095a0e8d4a5325baa1ca25d2539e769d71bacb90cf9dab2a31c466fc81979a70c063f9ad2ea7f8a8afe029098f8654b7cdcc2a6a45d1b7d2adcc9d646c9670e7c14aefd7743ca749736a20e227a45c8fc39c664d901e6373516871b55bb004b4c487ff4c039b5db1830001cbadcbdfa94ef78ed48d74c79f7cfdcf931d1e84249f106fa2df26b542f33bbc881d054f925fa9d4521027b030c30b2753a0552d79e21c03fdaa21d1a39201cf5147d9cb2162fd5e283bb8f3bda1781e0fb89f0d1a328efcac96fc16484bcd958031b89ac4a5de35860c615507da54d56533495488536748442835d88c9075ce0f963b0f77515410c8c7c1ebf76ef4b4e215867607ebe95a6c0b35c384d8930a8db6dd3da1e66e987a7001ff8cf422ae1422349732ca70a4539031d19716fa953716cc08fd8f7928c3b26fe5f48f81f0083a79d565a5637f60bd1ad8b607af613b0880b044626d31f76be59fbc5eb378245fd21734cfcf9173579539b2aa11df8b31cbf2d941acf05f9782e76fa3e8a7d0df8a608a8bc02831ae5ce41949026d6ef5e7be731e838ddb0d9556df5e2d326546eece4588bf8dc9048d1ef55ff2daa7b60f6a3b1ac4d4535095a3acc6e28f00ac66b60c82e1fe5acd0d203d08f249a0c929d6e3db5528e0ab85b9442d98e7440b0a29789c9ebd066246a1f91508367e8f2c05aca9ed465667c6fa8531319492b0739d20e264dea5a03b6f4872aeba4e7761881dcf3d7161e57cfe7eccdae26db051abfa44dbe33622ad0c746448d1f61459183f4d593595e0f590dedc4a63af852a8295b35660e31c98b6c6369a2f1ae42655ffa3ff768ed4ecba4fb0f1f2549aeaa94abf0148d9efebd3d3e6e812bbc743ee8713a7ca7827f7095f4b186b5462ea1021b858b7463145bf120b45c8f3bc93e962b192391f78026a32785a8c30b177a3a8accd78859e4fdde29dd5bed79f3480d7e811d9a2d1fe378c38ec24a8808bed4d52053d8b75068e3288a1a4401234560f9e44eea94b1a36c8643b83b32662e392d85cb9aeb160fcda6230c8c7eb799877093d5c089a5fe195abbffa0ab5e46fe23da090f5b38ff9ae3271662cd0eca543ef95a3c59b956970e4a88059b9e60ed1f7a5719a8930b649061bc43a77aec4a4bfb1dc005a9d6b90aadfa31a40b52df0b4ab853e2fe8f673a98bfe9a4406fce3bef4e09c31bd54aabdc4f84a5eb0c0ac1aaabd8c454d95a3beb289ab2bc5b4c4247c04d8f4fb50012b860158f1408a4cb4ecd9da2236a431870ddff8c6fd3d23f58ed932aca7ecc0c31c0d749b954566564a5cc277a53397a3461e4d8192c899e111c1013d945cc94238e1324e621f461939be303837946679bf11fef47577c439c0e1393e5351e4e5f4ab880f54f6f6e4ebd3a4e9c8cf634b6bb602aaae2b765ed1ca299230b49c06e0ead7fc44dd71ea0fcd4077e52f312f27a247e08c3dd639552b7ded8d6e42a12f75a70103ab22ecd50063d3b0117e58176628c58666785ee6dbc2a921b0655c9a9828473ade0acfca6812152779bf552201af4cb5f47fd11f3b2cd9954dac82e79c93c542a31924621e90702405598e4eb06902c640f9f09f0254b6e30ec7cb359a59b96d4be7821bd202e74c7c1b05435a6f28a404552620c8bf26f1e3827f4da3625a26b90e11508ccb8656476de14fcd175ca6b14eacad700f1d4886d72504f200912f82c5005b979bacec3043ad7ef602f027ba98cdea7e25da0c369b55cc10e82431c93e8c91345e6f98c1f57d069b0d7e3d6fdc446a8636fa786b6953fc7bd35d46327b198ece0352aec1e0cfa9e8cb1d6a99869de27eb2b11716e74388ca97d153471d31af678830654ec432bc5b90bb90fc03b7bf4886aabb439ecb7c6562aaa8301694d7811ddd596428d6f4c65b62e8b5cddc788fe74c1821e1e45b6fd5b7dbdcb4265bf9cfd935f82698c41c28e6bc144ff357029080b25192ae883d04c82900498dd3fe18db9c08990a9f28fc612bc219e9da3ce70a50997c45d92e9fb7f570e815f1144894cdd6497fea760dded998711bf869a37fb922ee03f6c816d2dc8f783b7d275f89e4f4278243f3a870c5d910594393f84e46fdea03e3d0f30dc8c3bcbf4799480b6491157349158fe75c6705a575118a51b407b10568dc057b247b25bb7fc8045af0cbb000c53a578b7a3595875e1eedeadd33e691569b0cb0e2d54c69b76672e41d284592eea90bb68dca07e3e0ba6445b525937139ca99d870de103f00a90432326c46eb8553df53fc50226ea7af8ed29f50bb1092227ff8ade900fe8f5891f6bbd96bdacf46ea431c6d843681a5d9f2bb6dbfe27a804344bcdf646d0ec4b53e04e9707c396bda8490c286c8b3c8721f94e53bb2fcaff1a62e583a589ebc1e5f7a822f1ea22650272877eafb0fed2475e6b8730fb8d8ed7311fce9889883cab3f4a456a7faf4397274a7aa4c01dd5f669d20cc4788bc66d562d73b8e390926207139b827282d65c775a8056e487aa052b8e9d6190049a0636c8af83343dad0406c5922a482f0ea8f482b95a0b225b70e3677dfc9f874ecadeaa54fa562ca2e629d4ec23522825388a50fb46ded1fcde4b54d57679d070d348fa446e142009ae737280760c3a5a14dfae1f77d275dc627c91e3455094e7e6b15951645ad9536b8d5bcd761d39a285f341c044c5b5401c013b5762ecc90f45b216bca5fed82f5a8f01e974c9a01d48393053883fd1895901bc3f45185b89a8467d33f6b93c02c509b8bdb109a1dd99e1daeb8b85f7349ad45d03f68dadebe00064bca6f77c2a644dffccb1cbf8d2e2ed7901948c530561dc959fed0843bcf23a13a2e7a0fd315c9e911dbb0c90d7758b75bca00807bf360144d8f76d3b22f306ecc4cd7c6f2c5b043a4e41cd8afc7e2c8f2bf649d13b75e26212c78b2a4d7b99602504edbeecf4ccdf67a2873aab369896496a74268bbf1028a11dbbe73fd55b59aaa04b98763be7f4cfc869139cb82965ad628cddd29fc0d4dcea4b2d77c3635e4b0dbc8ff0ff250a445ecf818b0b4b240fb8c8d2c4190b76d0139acace49445c2366d99112316805e31cd6f77c2386c943cac062a5eabfb76f15ca861b9c075222cfbc1592504f99acb37c1a1a4e5bdee9a0aa50ab7b87d66beed1f942c4922f2e67f807b6a75ab4c286ca5f8e131d68a74f31cd74229fd2087b42f8e917ea2918d506946f1c71ee0f06301977228fc77b27059a40988e60cf319c33e322bb488e287a5f75b57a46a78b7f2df56ed7c2aac8317a42b8475d83fec04aa9341baae538d540a79cf90635db2aea9cff0a7a9cc34002f5bafb16ab362e6eceb9e1119c5ace1c3bfee604eb1d72ad04a4b5b4656e42b8c08acad3006db8bb6c10edba4527fe369f4a4c69a27f3aa95e50ac27eaa3c506e595301d461834f9270af617c04e6b6ac2013e34468baec536b5ec52bb5adc589abdd0b8039274d5fc33f791834caacec500a1f6fe460384ebfbd4ba08e3c38172c5e5e850793bb640c25d8b2be3524994fde38d2581d5df8ae92939afbdacf2e3dd47c21e4ea44687398ed9ffc8917aeccdb6bf4f9979b9bdf6e2c8050563b493b7310ba03b8234563311ca7dcae8fe5a53440f4054a94e8a5061e887821229112709d5d85e6fee1307c65c67a1b9b7a684548c1c1df2dadada7c2e9ea6e0424eb676c0f258d664f50094ef8b8c55e699f0f6d5eba2bf2b85aff43c8b285c24f84c7dfb7d5277d8fb088bacded5dd2485fc65121bec2e9ad8be5818c45bce2e9599071b0a59121b9bc13048ada8a390631f69e0da6871c31631ff8df682f8fe23500ee494b67bbb1198d35b3481323725b197be734d96442cdfc2042a86062bd8548c430c976397aab79181be62bfbc67eb7144d2e01940eee8f2d93f62e0ff1040136a9b61ec7ce767f7608f8f5a5ec80b008e1bcdf00d0b95f3a52e046e8231535ff4109383c31cd7ec8da84aeb8bbb1663e1cbd5259e7f0f408818905b8deafcc64cfb76876f8a83b71d17645ec65d48e88d755335c9b9b9afc611f954a8d916e6d3540a0b53ba7f1dd811e370d5fb6f7eebfbcb0e0cee6ac20cb6608f3d7e4b16a6f81b1d374a2f4ee31b9d7c421c07bb990f490c4aacab6e24970a0d6647c339d71d438017baad9742d4190f327ea39af67e5027508dc66e88535ca094d963d274ea49c9d5030adc2fcb0b2dce07e4df997e83f105239aec1a5e5bb1ef0820b2e7c7c133df102290af2f74b6087024e2baa8beaaf6d6093f20321ffe23fca9d1a84ae5d24ce4f60d57169051ee2a67a3126531d1a23a75193a091adf7fbbd41205dd3908bb9138b85ff2fb944a9ebce46e509752577ee99ad07da21441c424d8c83d7ca45dd5edefde03c065a43b92fd24845393b8290548eb72f169292f7b8404f1085df0d940be76b2023b3b1ff080c103cf57924171544abca2cfd4b5e49e1adebbda1089330cd3e8f6afe9106e97bde69101c564a06c79928987255865441b557404d428e0a4397d16778c6d89494d1be852aca3db0147a4383f2d849eeed92c5f3055776955931624b7dbb58debb92994175ae06ab71765f486ca12390a1f42d78115e406ae5624b33157d580a5965c9dafd215f8b0226ec3abcb298afc92a10592f3","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
