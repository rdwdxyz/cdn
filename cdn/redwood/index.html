<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7775edbda01c22af96534268c606fd5ef7bd5817cd9ac8bde4e937099067e5a7ec9cf779245672ca2e66316b88261c60f91c189ed7ad221ba4faffb8e3f31f524ea3c3cbd81754c57c1f41ba2b6021a248932e07de161d4c3e6d8d8176d1fed4d96d456b3eff11583f7a97533fba46d825d24d6aad7483bf8788486ed1bca6c7bd01aa4d359f57944c08566f9dc57ca35721a6ba671f5afe789eb670c6d4f34a91e88199ca593c486530447f82ffaa271a125e6d42b3984121405d1eafacf9f223543aa9fd9b8e9fc49d60527f4b36f17c4ff66a1051c3fb6cab49bb0ca500bacd5a28eecda07eb8b42149361de369bb2de432194a30ab5d50a93bf969e9415e98add0c4a4832c1c0e150b77639c6d692f7e07e5c5e80ac68a2c4b459bd4d21ccde26ccb631d3810b47db9cd3e3013dceb303947e16aadb7ef294d70a87dcbaf0c93d7d00a9e0d1f579f94d6dbfe165b90e5c51fd2aef20a29b6a883c443105334e14e7a5245ee055844de8181fb4cacbd99afb293bba67bd3105d2bfdf2787b9ef3fd96edf2e35a95ca97b09c380632702eec7d734e1e40924ea3ac168617a7da856a0131652025f757a16cdd25c9e206f6cbc4e5fb4e8aa714a1062c99635ffdcbcad7c62386cc825425c4c228abe17e92d0532ad4d21b6664e00bdd5472d390fc8239b77a55e46045263e42973c01d4dfc8803b32240478b3191cac622cb4011f7853b38924d8b3003744ca58376d71b94e446c0bd5a8a5d683ba21b14354d1db88263ed3336af76fc4a83de7e010282fb6f6dfd69bd864b7fab61be02e6093fd2095f5d157e42961648e8d49dea035eedf23454500f178bb82d0614d189094de193aea18e6eb0457d30ac09311361cd70a139959bd7bafc39faca31cc14277ac909ba64eb741279451c156f1ab11dfe5dd1c188ee6fe5e8fcc3d40d873d8065c8e9229389e3a75df47508a99c8733b2631eb137c49c2eb993ed7218a117810e765a255de0df1e61831bac78a1583cd3b3c2c7307f1385e19568d164c96cf6f763f4262523df35c081bf5058aea9a2bcdbce3e44ebe4fecc2e0c6544a988a22ba8043a620dbe12d07a9a6c984107ec1586404e68df01188f2f88315020b1a692a4629258a2772549471e4770bd61efc3092c6965f1964dc4e29a75fb2c29b13043d9dae62d98de30100db322f00513ade05b42414a4729c4c618a3e2020708fc5d66e743c1bb04aded7e616be5e7768e2917e5ed980a9d5c2ad6c3eef0ecbe5f29596be702669f9d7cb942782c0949b5babe796ba37f446fff9fd15252eb9c676764e58effba344d412cc11c4d1d7e587ef6aad54aa24d1c1317dad840ac21857bc8a72722f004d705b9e42d2f5e0734440ddd26a6bbbecbb7f35e9a58c63f47fc47126d185a639220c1fda3ac8c93ef2186665de4350b4a0e9ae7bcd1e2fb6f3c589f442ebe38350bb288e83f14a9a711b53bc3bbba40178f664204c2df8a7ac055b88e5085311413bc4d4eed68486c9438006bc6b2ce196bdf355c99001485474103117ea971601943ff2e373713e8934aba99694b3fcc8e274d26b41d06ddca97633fb9541ede0c78d9d90ae8cdbc75dcec06629041a959777d35cc9f6cbfff7fbdf70c8c3789eee85e315721bffb487107d9c437a05be6c1fd624c0ba8411dcf2f51d3aba385ef64738ccd4728c4de7c75434daa38985daf3f74838e20625f783470e15197f8e50750beddb6a5e09f6d073bcb41754f3305d5dea3d22a15465c3d7f558ce4586a2b788bf88648b035d39da3dfe6fcac0c2c6c484638bcac1d890a61769cef86a8f7e799cbfc2339e440b3424c65b5f1c6b92c384990d2fb86c1de78a982f402df4daa75b9be76b5974ae081cb999a8cef21aa5ae7553466636573e75ee56f203c0c785cc9b578381725fd2b1c47b29b7f1a8260dcb039d98dd1a3874b1d3e3cc8cd8c1fac21fb61c3e38ac50b5cd34f3027c6855584550a453d854976ed875fa7c227777a1e8972a118b989cbf3b6df3f553d06a228e1752a5ea77b826ddb3144c5e5965a329777816572823ce8bb470858c539dec4c160d36b2820c559918ed2137aa5c3543b95b7c2fa806b6f3955fd666b20036485a9b24e6a0d7a36d2ef748f1c66720469051852efcecb0caea1d64775203b6da5973b6ea312f3402874b82e50f2f2f98c0ca3c8d8996c085ac255cd33dfb2ead8d60013fffa220c4bf61c5f9f8cbb951304730dc35cb37e34afc90a8482c55c893f77d413d996e8e8c67b3074135f69ef43792571623bd4de603985e64654646143d1c561c633c253f0c6657c17e9fb9c580ca1baa0145a578640517c03574636b0c0351026e11ef6d9f60f74629fce0bf38323f02a716e68ab02dc33a9420b38c1fb0d6b1f8d27cbbb6ae1c0e7e292be6c26b05e040c281cec38f1dc76911ec592f1764fd26d13fe7ef63dd55ef59f0a497e52b117a9cfa5907028bb92902e3c7cbc941c9757e62376efae184e187e100aff2657677dfef1a4ad9e6b6f3700db3cc93863067d97a1f30bf24174bd8bbcc4170b5ff3d29394bab01665a68ba3272d460d14c8d310b1197efef02bc956e90e0b2216e165396d794466a1366af9967b504f5faff235ef81473ad8e09b6d09d6cddaba1ab4308fbb95652111f091ce027cb0defd68a8822b081c7188f6748e1116034b675129897f1669ed0613e3e99e3eb988e8ab1a1d058cfc4d25dfa851fa287ae3eaf8ead07d9ef7d5af4f8d20ca87fcb8b0b43e94a8b2aaa7d756b95d2f3d3cdc3fa596672edc555797eb3a260d7a6d3d69bab560267a415d1b42b327f2177c08e268d76fac21c6f3a5d5693bcee76f298d58b185a49302fe102ec13dc7f30b14b578b48e8721ee2708b6a709b430afb3ce07db3c10742a2c98452a4fd2d884f017a9e2e803ae7f3c8a36ec396f5947746d4278c18673812ce80759557a72fe057dacc33d20f3f89e779602f6a83e5499bd30e88418a0f0c43e7a32112111a63ba1383f74c8a505792f4f7e88590ca4ed3326290b17c770a8dd59480663931ab6ea03210eeacd501fe1072cb276eada70920b0fafed9f8fc2bb359b2148e6c95cbf62777c2adc2dad416f71b15dcb64eca70f6f3995dbe7e9b8c14ec08d67fe849d09adcf672c89c424a6c4fcfee30f8614d927607cdda75bb293e4c091081ffa5a938a125e1b831bbb2553f838d5e9cdc8ebbc9817ec804f46116c22c26ba5b7dc8d8d931ab3496e4836ffd84481fca5792d57e4657a648f1b08f642aaa10a5af81d142188271d511baa1e6bb4973558e15896d74e75e36e73748bd3115051d640476cefbfe6394f310ae417814104fb78196193ad6d87c9674b3c8195f42c8d153e2a06403181828c8412815c2d9924c322306ac88b9253781b9a9a6b17f08303238d5b87ab6b8659b8373db5c4ed27fb1a94349e9459a095a043e14cdab0dcadb431c738d73da3ac62da5f169da7b92540d3370d97c13ce2681fd54aca914044a6b83a6a83b623b6f002de499cc0dc21527b42256094cc1bb06f524120fab4328bd16ff3855786304e2b73a605e9d8ec9e5f4b0238bfcade797b795d2eb73abf5d8d54b9a6d8eaf30ba64a5202996a68959cc668e0fb1aca78330d3d5e9dee5927cef64b5ce55d0472865dcd6397020df1ca8526058e6f4f0a4b9ee46257af75bb85834af4fa19c32cc4d85405507214eb3e11f3a256ed4fd5771c4494abf788b44bf19dc94ec9640f8bdb042c7c6276070c33f35b9e9f79393cd1d43fe7dd6bbcd58cd433ce777b40db8b897c55f64abf85b28ca95bfcc9464e8be15d7ee91d574b6e5941ad404a99e29fc48b9eec1cfedcb796d2f3fff63d9b70c18a1f37e0038c5634396a6e176327581a31d7728255c4a09716c16dab56e6d8d8a4fa4d158471e9872f3a1d0780f7d70197e2cea558943fe704fd95b23745d346904e8580cfe618ad877035a6ff5fd7229c43ffe336f71f85bbaa1b5e9d69350e4e641203f0798ca61d63a51df177369d1c1aadf99ee9cb88f3141777c90062a046abb9e590b66909d88e0c91d42a7ab40e8f1ec7db8a235acc045044e5c140a2fce738b65e16ec448b26801218129da8233b021bfa98032b3e275e8a0b69a5e8b7ec4b2e647ca9383af22b8052bfcc2d2147989315b6656a02fd79140e85f0c2ab5d0edf19000f875f6f58a6835fea68bbdb3dd8358e7ad88493bc121154062f244f6cbbbf8dd0427e41d36e1cc7cf4ca8a884074fd783c5ecc4b1568baf593923212bf0f3baff34d5a36285509b854c056e3b56cc497b0dfa8b2245e53084e0e59e07c4b580d1ec25951a16d96e98cf37c1fb01e0e30901bfe0ba46ec27d95e3a93b89de97be454ee3c4ac15505969c95cbd1c72c978bde730a3e44c62f6ef6382120e5842235ae792b737944c2c34c6f496beac4efd170ec3d9a59d867f97facddfc0e1c607b8e7b31f1e2b71a5c4ee0c6157c8dc604ff84dd35ff790bcca3b63f6782454fdf6187b8a3cb89b5a7cbe249105e6b3e73b85f2a7bbaf0151c08f4f2e870795243ce6a0bf148a626c032e3736304ecf2c7ae0e4550cc2d617ccb0d92fe888c557b6f2bdb608ef3e334c823c8cf2ddef1b1df56b52e742588b20c6a13de2bda1d7aa3a4246a853bbd90a8691a41c59af85eda0beea8f74b3ab00d2c7945d20ef9d3b8939c1463c4adc3839437a5ddd6fef5cc08bea4fd2ba60866f4fe618198cca77bdc81c341c88412fcd71f05d9fab423f362b0f04febd509c88820a6a56384533f118f3fcfe4288bae1b93496af7d6c85a616fc2b476a73a20232c57fba3aa2522374409ded4cf746b853b24abe3921792703ed249911068e2381926eb3520bafe3dfe8fab83ed59df598d7bfb0f5668e3823265c060d50cc1993112588fb0392fde2845510e3cadf13b58ca5b1a24410560cd76490b0a77436a8cf0cbd93c3160e42be71227562baef5051721e859cdc735ede796ec91188107e350dbd24ac7480b3717b0e41a66859bc3bf6e14ed4a504fce7491b76457e615d6bb69606b5f02602502b9f5f149e939d517341b92ebf815518d1ec46bfbcd4997e94a44b6ba0c4328c06addb74053d0fe854d09306a8b059f3b8f1c22a7c783c307e8019ec00fb6d77d5713f76934e41dfbf0fb02dbf2280bb24ab35f8533e3a0fa45fe4b3aa46067ebf84af7bd8d87a7f0b5f2f92fcdb08200d9843ad06652186c3442f84a6adc88f90f4dc05c4043031a7bc58a77ddc6669a88a0930fbeacc6037b7c7c2cfeab619a82aa2655d1356fc926e1b1427e7a16458fb1931c32a7ddc93534b0e5347796012a42ec4832830f5a91e0bd4798c9762c5cdb0de4eb38fb6aee486d100222f1353fad9e37c0253d8c4912da1424cf0e97c06a8c46968d1858190d558fd521ce13c278af535abcb974048c2e6ec462fa24def7212eb787d38b691e5748af5e93068581065d5c38c4b30bda743b94ee551e562c5b61d1b87578fbfcf253dad411c17078b12568f1e5b23916c753812adf04a75946bb54762b0b6d24f5d4615e128ad6ff3dbf6e3bd7311492ac75a05db08aec4aefb8b79b292387765ff277cb094414b85f9c25a8c624168358c09bd1df3699967bb77dd4c601e8164f42a8439a44969f4b87441b62fa304b6412d3227c00928c04e200b561e5d123a9201e0acf870a314b56d89544d91ac87814f3863d6969717993db51dd7fa68a893ccd534f4786e209b162836e64fc322a2df0e4d24c7965dcee370a62617f5532497b4fca4bc6a672c14293b3a292d63c5ffbfdb2f726bb81a2092e13a023095e065e1748324d6650ed68ec0edccb28c5042ac5a71df45dd479d719b4a5770d03377bdfc2e0bdb958cade31483308fe268a19d8bfe40ed44151f20c648ec8fd1a4f13059cbfbc71abf39b824275764bee6fa9585495f1d7196e81b639a2e682d43012c303be13ace1ce0fbf511141288c8bb3fc7d58abfc093d4b5831748c3fc35a0e1ef0aa895ec074061e3986fc02be49c15422826cec49fb4fd31a1b6e542a7a2bc1ce8b7108b38ef5e520ef30584a08ca273911bed44c489bf903653e2a7f13cba01e4a974adac9ad33c624e642ebc87c9a95934584d21d26910ca0abc58dce61c5b648ef5186242ad5a93be22db8bb4f2bc7026c249a48f0b4526baefba887832b77758a1e310d73c0a9ece57511efdddddc4b2c4779cc38eb2fd0bcdd36a02129cc62e1a6b9505b755a0eddef29df867c1a91563892a944abb61cb4379230a27c00f6e74e30c29823b97425efb713a3d2c1ea20e2fe17d30d5ea8185d3868e07e83ca6f44bc97e41b38ad453e5a5acca4407e5f8d1332272f859238b3b922154692a6ef73aaf831253697a7a3ccb524a068c2df71a5dfbef9369090a940c188a868a1714578f91498f4f24614e2a5a633f26d37466d0e3fa8342cf6f0ee9684d7c180cbb16ce7de4772402f25ce58215df0b879f0bb46189bf2cd4f2c7c470d0b2fdd93cf9f98f8516d074da2d2f599329c72313560f158fe9049d68e1044469d5cf90d2b1cfb58600dd435b46d6ab044412b394fc79991c43c760ebe2efd06eacce42064ba0fa3fde85f8374241595f88d6117bd50138c2f534c124634dbbca79d8042cf8a49b30c5598a76fedccc696478ecbc3d5b91a5b4a4e3228ec7f309630f25ab46e3953ea64236428fdbf162b325af0fabe33579861cef3db3c4d917cb16687d6e7c200a447a99e7077121d208c4b27af44d29af01038f9fc176f58acdf1bb2fbcfbf93fc8d3bf12367e744f0b901bf844b14fb4e09d6bf866052fa1b34cede51b5bfed96372e3f8346c24527f4ac3a8d5c22ebf306c0af75dadd4c1fa18826b838cca06b317b51c084ecbf80d4f179335d3b96819d29891cb5f139a893810b3bbc50abacf1168869b428f5cc5f4497dea08fba3eab7e8b51d7a016290ffa7ffa910ed155baa6cc0698f7976580c7a30c92320a7bc3d69ec6f85d5caa18275bb879af67e50ec584252c63f173a4420a0a7f4e7a839e56b9327c3798552a6c152455d60f1554fde77ff0972ea3b44fbe4b800a5808e3baacc9459aab6236ba111944e0c485d6555c241e76177770af1dd132e84010c8278eb9cbc8b22660a4d36148001ec6e53aadd4baba41b90530ee73d48864a4d46490f3371e09364965a7a6466253f52c7613d8941497f3f3de8bb628957de5642f129dc0a816b972f4dde4af80d455fb7cbfb668f90427e240a888fe538ab4c59f8021f0c0dba6eb8c1ae58950916f392d5e73a4805710f7b105127e61569adcda21d4054cf22ce784497c516ea668dde881c5951d746172ee31a928c5efea88c6680449fa6930c0eab20f68bd07665f2c0104be2768678b6e6c91d35269ca080ed2bb0162dd5663f33e819875a7be10eb505f8786d919b724b1f2bdb2150a2f70681ba79314961b54862274b007d2accdf919b56f293da579f1f68f7d23dc4f0bfa5d50fe6dcf69471e3b68f1909bf90d3f84b678866c5d4d0d98a7a2317221788d918d35f7ba3bf05aeb0b77ada2a86c652b27e37e5270ce68704dddb4e63bac643d12fb30b1fbec5a2ca94332e16e931a6c27bde8a6d460cf981b89447381f6adb732c194753e82a8478bbe11492609e8f665aba1725a3ae1d1128b108748f63c1c21808cd7e1edb85320b693c23eb473c18bbec10961fb8d3eae71480bf178fc096355abec6b83c44e0c523b00cf0deb4f3c453bbda2fe463a1732bf382c857a1950e0bee970a14aa4ede20a406c8a5825b617cc37fd2d9f23697c1c65c66de2a37d06049b355ae791d389368fb85ff44866ae4652c11a68a682d3893acaf776862e5f8350eff0c4b1245a7ee3a97042be2019bb8aa45847f1f4ec69ad5a09b86af60382b84fa1a8551e49cccd808922a2070a728e9f5b4a4e7fb372495bcc9eb922f799ea46ffe0a8febd57887681087fd5b5a82758f3e31c773d324e5f559e4460496f01d49b961fa4efb34e3a02debac95be95f68f7f867c4ab71f18477998f8a3accf4f03ba6834e70713ee29a63c39833e2ea574a833782a17d9d5f1e1efe950b72d2d1bbd80fc9d5458de82fe54b6df20239827dfcf215653768ba00a4ccd000abf99d220e12ca74197446c68d7b4393460ee7822fed90f4fed66902b825aa3b8af54226229ccdd37cc62bced403b6a745ef27a855e9b0543d8243c6ede0bdb67d60d10f5a19f9c00227caeaee41c67b9fd8ace558d214491ea07f5d3b6759fcb570c33ae3fb04ab88f6e2806d1505d2183db944bd9db895a92e69d221d131fd1d0e71f1b6980549f810f6cce728586caff057446929dd3a08d1c68c07dff1352c953e8ec895224b7c685274632bcad684c073abfa42adc4d8b6580ca30e80170d8df6b1da71dccd944c957f0b1c31cac9454efe102aba8fedafe00edca5d4db18659ebfce49061d38b08fcb4afe4d13d689b754279d9fc57b338039aed818436dec8f19c962140a7269acb5a4160095e02c72d9303a2583df642d8696c9983feadd5ba5c605d415dea89d3adbe903fb6672516ae35af1dc85c0b7b2b016078b7bd8c2d1eb9bcf4817498e9f2df84765706a81f7d659cad1395c0e1d4f6ccc6a33cb263e60d969cc8342e68485e4153836578d50700150d038cd17a7837db575d520d6e5707d9a3a823aea604529af7e3d98ba0a7d660e958016cd427027d3663e74f384de93842889aef5e0ecc37c084db8f2edecd80a7f10a7854fadaa901fd48ce5e9d8d510d4a9d403dfc4fe545aa8f59c684273eb40b77721cef82742d00182659f27e06827cf1dfe44e4855c8bfd048e45a820ab7ceff2a787400cacd1272cc55b5f7b67420b48c8662ae3c1cbeb7776ac63cb425993d291e88af3650799051161a321080cfffb570f7a8959f8c05fa535deea2fe7acabafa1607a808391a42c50252044bff0f0c7834cfeaf8b6ccedbaac3f365cbbcbcf7946ee0204a7d0e6af6c667d1ff86d630d6cdee5e94bc0dddf762417df21870f7d528d1dba1578fb81784229e917aef68db55374bc8c86653f26e477e4fed1e3ff3dfc3b059b66d4b3613b684d7b06d02e74a030974e64ff38a1a6e4133ab74424034eb3472cefff7b03048d663b530a2f6496ae4960156140ac56cf07818c7ca293edbff0bfc72ed242f0fed84aa2077ad663d3bc2e9c9f58fa93a2a7f15df202114c53d055df0e90877ea3c4335449b86118e987dc042ec7309a4b2aad9084c160d68a11ad5016b7fc382b3ffbceafc68de6016eca227b90b29078795e9174a5c771953aa635544ee90121f8cd074255ee10555189228ab049007a7fab8fa68bfdf02f9c8137f00e7db8cd5a8de44a8d8a4be673c70d465b4fd804bfd68b37a0aaf0340d9f48c9dce07bdf507a15a43905ada7674c2680070bcea310d70ec6de288d6d57edd29594b415572544a9d511029468446eda9179b1242c0800fb45be309134f35c94a4bba138896063408cb5b645e3ce7d9e104432d9c071f7307e2170f03686866a00f38fd6a6948eda5228cc17da4774e45b094f7a0c42d8bb567cc0cce45e742fa36bdd87cdc184842c72046d0940a99d36c23d8d6a935345a24481116fee1f68e19049a5d22c201799900abaf5af44154a8812441aec0e4bbe445544c3fd299803d1e44e8758c7efeedfa31f3e969c69d9cd34eeae4c041e0683049e5f57eb40d64639d3dafd0c009968719a195edaf9c40964ac6ac08d76395bf010e1e9cd612b73837e670341cb1831ccd0c2d2ceaa12eb0cebcde666d1fbc57107f5070ca000018991c2909beff0c0b3a73aaa207bfd81a2120f84c6acc24179f29b3f7809fb391ca9b4f5345fd603786230ebd614fe12e2d7683e2d202d100e51fc266b6b79f06a597dcf4ad175debeca7c7dcb726614f1f5a89cf5d40165fc1fdfea8bbdd5a815c3b147e4d910dc2c0923684d4b74ff618ab0067ad1179b1218bd763ff2490668eebd66b1feae14433ec01e4a1e245d80a2874ef728a8dedaac51afbc99569bc566be4c475b065474de4491b71b216b713ef514233fb20b9ed19618a5df5ab1716862e1b10ffd5b6dd77d78e2e49fd99538f76e5cf9ac8d6cadf73cc378f13dae8391f64e61066f715826dee38f637926cc6f1fa18f57a2f878f0e3d6d9a470c2859fa5ffc7a34a2fa051ff42609a664726419a83fa23eb253ff624215868e7842b98fd879d3c8cf3f1af1474a56554e8d590b83f7aba246b0b08c676aec692702ea616ceba9b6b3a2e98b09395049089d25bcfa5aa603b8e52615f7b186b56717ab62abfaf89b50b9397fdde37adfd6881585f7af64a61038f14990bd85f61ca231d8046b780b22c21fdbcec97cdea1067934ec5395de69caeb8db40f07816540edfdd3d889ea271743002e9221d7c7b238ef8d56de7c346e15805055b0befc3229a300e431f6a4613ed59cf7f08f05270ef293e2cd14ca3e5e9f147b1b887fdd7618cad493ed4240eaf33e8ebd766696b679588eaceafdfbd80ca8e1e9a10ce841edee5939366591a9a0935c80aa2d0f37967105ab085cfc9b8d04fe11dbb626994b0dae53ddbeddcb9c573b281541277c2507ab8cb8c58cbceb12c350dd45dd8ebcd471bb3da47bfecff1520ec396f7921e7422d0f7f5d9841c5e74ec13a932f3b505dac01bbebce07d6c3af8e5bb1bf4797a7d5492ea509cff014a26e2d718f40124c206b45114eaf53724d1726c2c11b7e6a695597d4cf349b721ce490e153bab69dd2637aeac34ed817e588d361f2f7eecd15334f34a892429d35d718fc5c2a331de7bbcf6bbcbdcdc2dbcc0f87cb283c195b73ca19661886a0933835aef973edbd3ff3cda45e6544ee6f488965dcad8e78c0c0a2e71babe69220487de63a1ee92b1cc36d4d7e7dfae4583c776d7a8ae94f5d034790bbaaec6e709abd18cdada8b586ad64b15756ae20ff8a3e9121a1981201990a98f2d0faa3540de4581e1416b4338a62303701db37ad3ade091267587329bf9eb5c9f890f85efb1ecf773ac73b73a89dfa7aa57f95aaedefe2b114cf88f4d89af86f2eb0b6bc7a838e4ec98689b8af2993e9640e5c16d61c7b48873b7de5cb7724ada2786031209f318a0ccdaf39c847d2e0867684d335cc876bf1ec864fed6ba3c92c4e9626cde03f32f96af9f65a71dddffcc591cf9e6bec0289e112b87b4b4105c9736c120c75b393b0f7148e89472e54da76f9c16e562758f4a5216a460741fefe2dcaba86a0de8a0944384cbd59880174e174805a032e35a902d8a5b226d8574de18aaeec521bdc1b4a1050baae0fbb36321589c594ff1984e68c452818fd50185f7a85b4370e92c2b145257477630c71c3614225041e33622619b264cda95220182ed0fa8bbacdd1e916a0a692c28cda676120cf3762337dfbe8667653f7434337431a7f51d75f1ea22ba73ca04917bba26a721f135185d5c6a923a55a25156c716892f0bbde3e8ca620bb18302770761710f5d42954cdfb334c3db23d9a3c57af0c7640dfa31f5979831b051ab0d1f2c61c4ca3d991a9c5fadb9dae40caeaff5f483fcaa264aa52756db4a9d55de4f65d8170b5111d0b711f1a6b12e3fe1d0ccfdd3ce779435d45e19f996ebbfbf3a69f36dec13654c1377f5cdede716a5c37ff4ea7617d57894ab48aab60c48b749b1b62c95d33a495fa1191c6b5e6c806840fb4f1af9ec5267efcc179c89dacd63704cb871efce1b8b7adfb1d253829eed9665dc2efc402c6ccbd0532bbe46af12457f6284ee687a56b56b0bcf24ce389b20dccd8a4ddd3cbeefc35703bddd806b2cba7fdaaa3e75ed6b21f65c541acd3e85acf74868f7f4406058107859c0600159010cdfbcf0f0317c4fa7c6fe0578d8f449dff9dde339c662c214849e925f50298792cb27af06b270c04b45e036c41099b40eff27cefe4d2ea0f08a9e32a00fcda71b1eb0f9dbb012f5a42609a174ea6753d52580685ec3127e96b3ef79a3a1612c2f33fc14d00a54aacae903d4c6c9e84235f1ace3a086aed9e517b8359c4f20227573192fb4aa515b41fe15046baf3b5105c56ad3a9d0b9c785256237d7c52041d2645d55e8b19b88d19907feac58a6e34583cc845fccc7ba508514398ad24dbc355a8385e81c23bdbed00d0e0294206db7c15c66a9b71c5576dc49bc2c80067901c71b07af476ec538fe9ae1a4029f0ed2cf769ec85d7bd8adbfc84cec1a7a7140ab42dd0ac9b82ec8c8281b3df29f8f7fded4bc7bafad87149fdb378abccbbbd7822c340b267e7b841dba18b6aecf4e5461048f8b3108fd427bcf82569f72e3f4549d0636dd2f78469f4e977820568d8f34fbf2ce57c2fed49f844ea788d9aa210809b3a7dd3c28bbb49d727b8597098608d48a04abacc9d1a64f0d3b6639af45bb049fe650caecee1651d6ddc5c601dc159e6f60867e9121048d4959d7bda5c5f7a385363cbd10739f21e0e9542c9a0e3111472b9308006b2de9127d2a0996b2f69d01c7d9947b9fb1efec4409fe303ccfb5a5b9f79aa324b8e402f907520b82bada8bbc0ffa04603fd805e1a0c860911f2839db1cab0ec4254c7f86e292f2e761c56bb1844ad04261f907b8f0c3f57272f728ece04b946209a6c45e01ee653a8cf4ac3241dc543a6f8cd1a693b495736eadab643420ffd50e1f1ee4939dfb5626f96fcba5d961163abb05c0aaeff13ff9e93f3e228ed8ced102a02a17bc34700954e40f16257d35ccbdffa5b1d14682fb42707034df643f130a6f691a289701d9a99039164787d3cfd338de3b4e9b0f2c67b8a381e130ab222352fb2dce1eed9874bbf3e9a3c0a5df88c21959d10fec50a8c61fabbf87174d74361245fbb62e69a243b5ebf2b1bcf0c86e00a1769724a2d285cefccf6f5fb11b3f0c4366b05128f4b9fcde423b95a5995053e8a7168c5194ce3a865c81d51c94afbe0e643979a45f543b042be8cd9098b556af4409949479d49e909999f5cde0e05b387fd5f9366d8af2146c2b50261a04eb10f4a118f17de53b38294afc83be44afc32488c41e012be3b9e681d601749aba30dc2d837b0bc6e0eefbaed5239a20e7b360319bb15b5324d0bdc91f5006489119d219d0a226988e8ed2009a035632f3acda020f88cbe9e96c78b387f5e694db6d832b8d478290703445a4e33eccd939b229296511bb1c7afae782c4fee80a0e4103627c0fd07aca7753ebd7add3ef7d3a92f87b5e33f84d6ac60eaa1972720550c4ca219bbe9d50da8562ccd30c3af487a326c1546a2b7eb86901663b5a7f9a2bded7a655390760b250b96f2cea41f5cfd01a45bf93b9aa344efa7cb62cf6ba0d9475e5a50f4d626283eecc97198c96a8a1c1d637df43aa6cd2b32e41c4d23f7c5d1f745ef98042ac34af5194956aacc20c9243533ffa4ef02c715cfc74498f3c07a74127a3fdc7884984fe5ef5f7a878415a5ee0dd7c5eac306e9c40172390141c2c7ab1cdeda9d5d639c8a0296a55ddca343b36f3cfb6da39f917f51390120becbfb63909ffdeee38fd1bc640b1ae078648cb061d101514c44e3f8ee69242dc4a7a1be46c5c0f4f3ee3111ea0c0f26bfb359573047d32657bcd708b420c84f7b1a0552abfe518cd1a636ec9dbf2da45807fa4521e7d5f0b1d2a8bf436b297c66f1699ad5f24dc0cd9da2162287d9ac5796aab8eb672aaf1afbcf69ccd8e70194ffc01e9001db9fdd6d06a40baec0f201befff4d89e56f1a05bd67fb662adb3ef9c02f39d3d71836c5d2bf33d4c63837d5686eb396dd2e1a58c5b4e37fc226c04a8b565e8ba12780a64ae33680485727e650f17eac28008030319d4bc5ea54bdd2555da0eb6d3ad53b21e4e87eee5e5b41ba6b7011a51211368796ad4c40ccfec5877164f294200b77d91c547b339d8478b30b736b11712d613549767eadef6d01824f9ad768d88dc997455586528e7ba0e1a5ee22110fc3b11e1590f6f3b860af6dee2b0b4a44e3846a8a052ba4bccc0da2b236c72c30044f25d74aec855acfabfd307418100c8747a9c3c97e4f969ed817eecdc199a7f84be7430ae13061d38507b8f8ac792aba0558235c8435dc821f5092c7155d020d967f0c96bbe9db24f48966b973d7ea4d9cf2684a856c2a7b714c382808decf77178065258273eae9b498e65c0e4fdaabddbf87243933cf3d2b36158d48d4e4056afcbc3f2c5de6ac09a254993d052765683bbc83fb5f6e88d84c881e0c6b48d1967133bd07684d9432683da06807c4e48f45d1f7877e7467dd6c192c6a3571e75d5e615f7eee72b3640c4e7a7a8d74b521e6095c97589e949b0da9af3e4594461fcbcaff48770953523e57ae7b5297440a200ed2b0eb1c0340c1bb28fbe8e391a4c06910cfc86bd47fe04838e15f88721bb7f8056890de50c0f08905231377513597e8e8c4d760ec2d7b46d962c34dbd05df95ae1fba1bb7d0c4bddea9f63395e71a18f8e8cf8dfce926c05244a2b08f4ddbf3671ffdce91e45db388c394e9557c45b40c403f1cef35dcfb98be4e36d46fd58e5480c3c0c752a6d9c757ae646a8c61bfebab34d3a8bd76ae9a8e9402800502d236de6bde01056fb452cdc11d8d5e321beb0bfe465549c3d9891f7c69fa2aad9a0241bdc6bb288a977e9a93feff330c9034c59357911e915367f7b233c8c80ba147dc59e2cb141f6ff338bdce9d1dd11225d9dc01c6341c7452a6ec86bc96715cc897dc9a85c7943b2d3bbc73c46c74a0901089456e5ce80285f64763df734e785ed573ad6f9cd550f8c74e2d947905e8a89556aaa7b53ea9bf999ba619db68b61491e4f4d301025c19379d1d2e3401c3d3bf9ba7e5c0b4a05e287e13b4393a698cafa375439ea0357047a7c68851985728933d96a773ea22178ad6201316c8d7427bd3064e3cf0a91fdb12ee14fd38c3295e0d23679b25578e58801e84a38a77c1063eaf839e16902dd7b05f1213bddbe134d7151d5011e405a11c3d876946e6e511bcea3f3d7fad3207cf4520104ea66f2fae7e991e11a4623f131e6dccf95d0e2c27c52db226c6e8fd1f09ff8d216631aee75c2828d89dc0bcb6eb12e7dada5b35fc76f724d36edf2e814679661f8022e1ccfc5c99661bd8cc52352876701f9937b2e9a59051f074b42db00c5a18caa8f2d477d086f2e163b87f35a3d4a64a5ec5b5c096a18f592520904b4dba11f4224b4229664999c880000b7a0de0b29690527c5c7a4f8dcbc0a89424a3722e1d731105e39f579c529b8ed5d6286e5c5f274dd1ce593e341b5a0f260bb8b6d8f7ab29ba4f9b7bdb4c90cf0e431b1c42c9c5c2681e53e7bc83e4a7992d553d1048a26ff13e0bf4beae80a5707b85767a78b9e889fe736a1d771b44d8e67a47708346eecf9b9021c773a2c09639c7c76c64dea4934cb716cb26fba3882a1474a655f87f609d1f827741d5a5392010d96bc5080df2f8afb1f0b57dc0d2f12f0bdc981cdd8748a382ea06b3c75468b37997cc74cd754adf7d25eb089a4ddb8b711bdff342ee3195f8bef64640172d9cf12a5ae99c78e6f19d90069e457a593f804919ab951f9e97683349537ff69065c7784be77c1017f1ba4ce6d3ac3a71f62f6401234c271d8104cda17a2f92ad20e11097e1e623b92a25cea8cee7bbe19bae6e1790c73b41339d421a899837c014afad9759180aa240d7f6b3b6210174d5d38123e89f7abf36b8ad4bc3272c2545b3aeddaccb291c93cf6190c7b15e60cf59b619a4a9509013dfe8b7bbb1cc9903c49bc7c0dfb0c69358e1c63c091d0e816e35cc4973c2387875a9c718f91da5668f8470a6cc2aba3f4279be2e7238a5aab7e13bb3643d7ca974906df82d3aa301c53a2ec6354d2a2dfd61018b4f95f64996c64f52aa2e0127832d3ae1e613480a525f927d1baa8d017f0feaabc5850f45fc0dc2e11a74018e44f45416ba3e792ae49789d458935e377e50ec9a7efcb94aac768944501272a7d9ed596737c79b835981b0112accdf64620126c53721d3c15bfe31f40db42820a114b400894cc09d15120f98801c9f17b54213f82c0503715157b9505b7ef62aa92381b1c85adaa83d2edf2d9df1fc6544028f8cff192a1890d2628f8bd814da2f4add2a3e80b3cc8cefa666ab227712ced51f4b3228c99418b0d7f5c952d7bed16a2fc2ca216dfe800d533de81fe337c970825181fa2b5ea9def658f4d77bff9263371e9b9c0207cf9c640a4948af1557bf18c666c8a39ef434c69970a28864595a9c153816791f732a0bb931d020e25d6c035c731b657d4190663cc6d0f901781f3d94cfc00039e4714b1e0846d330b63481329c59e660a4c25b6b5626a3492d2227582cad6ee25e4181eab1ed26e2de7dd638694f29b1fbc065af5b3949e406d07d93a4b7afd4f085dda5b12d02a6ebb33423337adcae1bbc714443e9972d73877b4dee617ceef65892d89a57bea1f34822049c72b40ee6dc92216beb1f3d66f210dadba30cd5cca72144809e72e128399508abf4983e878f1465e0f467bafb2163149111a221a7d756ceec8a9355bc3160ba6a6495f80ec82596dda29202325a2d92ed23dee0e66ac886496daef4afc0ebb412d1d7c9f8504044c26fb8de6ebb4f47fa99cefa698c67326054591a7fde8932fd413fc64e0f27b120e6234f050fd69067d863758a79cd3490056721b9057f9fde844024db4772f3793a552828ad5e35803b0c0d0dcad9ccef60318432b7933fb26f98aa1802aa2ada5acfb9f1ecd2d38fdda6071b7045ef779b0bafdc1eb62236445cb8e25764f1e68384f7b2596c2bb1db01de284dca0a3b2de7f118ac3a61d02a079fe606f5f70a05e5b04949617adb9b3580c225a756af9300270edb2348678953102cc533e94a89d79aa2ba5c3ce8c372f116c162314cf44281e4479859e454a3e7effce1775709d3abe425f45fda479d4133e7adbc24e6a91ab69880efe61921cb87f1ca2d6bff08144c3246cd0806e1b32a62a86aebd5e8e8f1549dc058b00cfbb88532a2cdfd993130692fe0ef3bb2039c01bb1db15d7e8f891a2c65f595cb71f5317da212598a72b88d93638d59b7b2e00e29807effd81821e11669e4c6de304f946f90ed2da865a7c8d7de6eccb3664e48b8d8968259d8dd265a9874bb909073ee36b0c501eb4e1ad79ff4cd61e211d47fdced00149b746adfb38f3296d5e9e4c53d280540554c8d31e8651c433978b8d530504e8b72c34275d37f0fb97fba2655c987b4d92bf83103bce9f2a5acd507ede9aa5118ef545b6a461a533e89d7cafce194f696db0d6a69642c3c12b415cacc422cbb3f98dcef6f7d4fb169dd5f868cea1007cc41f9d4ecdd536466bf02a6243c20c7b77846bcb5b02f5c755d143ade56a9014237446226da90edf71a48bf341072d143cec092237136b2e1bf11dd976fc2d12e50d5013c3ce4ef61a3eb98d9a553d60d1095fa3e7be3ad05f59748d7c42f19ee69bab80d92a745aeb106a547e42c30203c9fdefbf26bec63887a847356f158768d31a897f7d5cc317ebb9e930832b13758e5f50603a2967600b8476f465fcdcee102b3fee314d524b9f1b0aee068a06759aea974164bb64ab04b902bbd8fa8843222871c97e4e5368fb00910b024f57cf87bd7970ad3cf32deecd83e0715b7e062b72281458bed5829b80ec183b9ef09ecd205dc3f3cfbf217509be8709e68df10138871f19f8a19cef587a7624f591a9d6511ed2bfb2083d8f93d6a521830eaa14aff5df6ba6ce24b7e006910cf79c2c5dcd04aacb768d91563b85b1b37827bdb547f8eb81d6fa2f48e45d39c8627513127628d3800d80036ffdfa8a690ffd0c779180cda181c89d5d52086daf03389170cf68552b6577d3f16d56ff91aa148ddc30e35d6faa3880c8d4ff347a96cc5aa5675d8d5cc859bd7fe568242a0f418f20d92414234d7e5d80ca454f9adee69c7ae3ec20306b576faea5e35bd4d782ca92e42fb17814119184dd82837ef1f7d8589d6d1384ad2d62ea0ef532220ffd3eaa72a51e80b8b4de5f303d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
