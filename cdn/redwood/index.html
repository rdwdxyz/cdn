<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2cbb26d8eb9c6e7dba466d0878155e69b2dafbffd67cf86b7639acc7adaf80bf4dd31adbaf96429d986f2dc5fe1bd85e2ac2b9c11ac43155111c8f427d31632cd7643120d7e7af337d5ceb6b04298ea86eb6622f44fcfc5a1f71764965816475d11dfef898f2eac2d0f0fd26e69d151d6550415bd3244ff0602c960afffbfd16c08968427a7d02e02f350253a95b713d534433eedd2c5f1a85f3c3ed0a71f8dbd28480ae797169a75637770db9a391ef4576ddff1672f2eb3e31eba710b58511c3b6f7ff91d1aea0a61bf3e57eb9bce14181a2ca2843fda87dc23a2d364ea85ba6308e3a5fcbbf7074493e5a93ea019d03d85a6f96c19c6aaa0380d160896e1fdf442988e4fc930cb609af89fc035231028579da30b029109b20303bbdf5975c164518a61d2ae4c38d49a9c4c3e77745f3803e974cd8e8d20fd574f3bd784dbf0d1d5802d4b8b20d50c98541c6d9db3c25234779c97f3cbbc02e51f0cbee4df99858197d88d96b3d46f3bfa623613b5a3cc070c65be1116ace07762d2c5a8a342a97baf634ee2c7b163fe47da408b6f7903834bdeb7ab1799bafcf622ce0b2fea5a784825cfc0c61a1dfd53cb739d8cbb3cf1bf8f42db2859506c37b12b0bf7e3f8a3d55219c4deffe036be78199ef1e5dee0dfefd29cb48d4ae72ee34614c4b3b33c0fefdd60c2a82836a57a2ac546d2ce00a5e9b512c108af6573547512366aeb2e246dd3df45be35fc28c644f2d9d1c12cd8a8002fd2f9a5415c13bebbf414aac3f56cdd03a120405ab315c6bff0b61df69c75e1d00ee84aed0a3ce70061326d8fdf5c2da5b68d4fc72b169dbf72c10983c5c3ecd9be4416c8a39e7cbd4e762e9f8cd3aa34efc49bc0a2a8955af51cd11c1e567c02df8258867cbc9573a3334154f2560736a6d793a01c9ca748e565d7b80586cdcaa93b56416261064f70323e704c99ca1aa8dd645e49f91bcd4ceaaa59c9abf1ef44ea8ef86d380e685f283afc7eb038c1dd296d1acf789c2c7071916fd9e9cdc7d7c63fc65e99e3bca2416b03f2b2fb506bf16486fb19ccad3e5f9d64e658b2d01a0bd5ef702e068657015d0a4b4c68d8450b36ff14a659bb44abadd6aea3fe95d085752011e45b203a128f536742a13d470f6496e62252aa81cd63ce75698b6422b8e27b25eeb8e414616a5d56b7f5a86c6bbcff42023d1de5094e7f3e27ee15e5d0adc85889dfa715c71cfef0fe1f1fea6c05c5521ae8c952c342d2961162c95d6f4775b456b117718d6829113b9f6f564cddde248defba8e23c30701ad81baf6e68450a8a5ba2ffe217775243130350ebfe8a089d18b3bbc07d8ea86117915f7dba651dcae9b099ba6e01662b53a080e769b7367dee9a9e35acee5001fc182eb215ebbad4380bd11aa37874940203f2a3e692dcf110e57180ecd25524d62f6bbff0e6291b0be91f2c5cfd065cf936faf4fdd36c6ca15763cee41bd656838a21e05e3304f437bcf27c4ae4262761a6b363cb49c515de47d60c43ae240391065ac20d988dd95b93fcf098e849e619047e082538f46cc0c116fd3ed1a625f3dd2c9af79897b00ffeac94a00f77f6a08036eceab17faa4ea44e0a164bb09373537be78bcbb710000f0df5ec5f354e66cd76072deedfb6c79f25cc642a2bae5df4ad72daddae5ac37b719618ba2d4cca5c213a652515c3b649aaa8c76b035613282b9a9a259be21e8c30f4a160ac1af2c8d46db9d06cb73df2d096d4090bcc0b59d46a25f9af8bb832aaa26da9a1c23fbc948dade89f4e64fdb0844300b95bca41afc04ab7f5409277c9ea4b174f943e3040e235cc1ceb896d2d2a8c5f934350020ebf1c7f633e824ec01e528229b11dd56e2a4977ea921dde74bcb519332aaebe0973a55341ad8d9a018784affeaef160215d3d8583aa2e2052809b44fcf15293949fba356e723628b9516ee5d64a2071282e4df99461ed19b804cb9dce49192272611aa5a1c48cecf565eb8fc669516fe4aa9ac5dac04fd453b1de5b0c73a28beb3245462a21af7ff7882c782d2585cf5c9c4f4fe06ab19786457a294f7e86fbd590eac69a8cedfe14036411da18a87739abb716d4f11403acdb1ef25a252f1134a25d9920a7d7012cf5c4f805d01b3bbd81318d636d0599da0addc5a95eb30d51f92a60d60311915b43b231aa2e7b16f59abad410e0ab2ff05713c1922c99b9595e29cdcb6aaadf0b6976ee43d6c634b4dab8c754336aa09e1d81d0a1bb300288a15823e86f4695339277e436e8e2173e332db4a9b5998c9baf21c097edaf7f6a22954bb2fd109df47e084c7f1331d01e16d1a51de6d070b01c2b24a1d8aec28aa0df4418f674562909f96e60e1f05e6b2e5c8840944a5bc87a93cd1f3270b4dbbe759a68c21bcde37dd2fb7a7ffc96d78e3ca25c60721521d948d3b3fa32a30cc943c114a4c461180cbba5e49599a6fc44f7a17c17cbc6c70a99a7cb9a6558938b44f213474bb141e242ec9b22e4920c08fb08df2d46569bba68892cddca4ce81fd2951a6ca26a6145ddd8c65a5d77285061a31abbc237170a59fc24d55c521b81531db1d6f26b1ab1d3e6c86f32c6c87d73fad33484b5a6f3761c69a2521a951d282187d55254d8e8e7575fe27fab0eeedebdd9b0c03ba7e908ac90d18888921182baf04f190ce0b4459a1819d2165ee5f0b81e41cd415236b3971ed98325bdee9764b1d17ef28b237452b39b8e2e5100da108eb8d14421d1128ad94a7884065165a9e19227be6fa0c05151eea6cd6ef7ba07196b5408f628485c7559f14a5931fa5a655e7adcfb8a26d0263a806956e888588208659edc80cd1012d79dd897bc01abbd7604000bd16f0f94c7ebd386787bb41a5616f61e5ce4f8b81100d69de61bcfbc6bb81e826e85404fb6913d6be8e9c91426656cd54b3aad53f36b94848e14711d13a87661368114d44a6b3effbcbbce4158ea1ce6b77638b7353cd327486bb1cd8ee6c674ed83c28ece8dd0cbac8fd49199e8cb22f10fbb09265a23b3bc46702566832581d2b93117a8cd7373ade3d30d064dbafa98cf9c7bc17c8b8bdd0f353fc41126af710e5127829edff098fdbf4ca99aba60f70716121a830ec3fdd84d11859e3e7cfd1245a0b1bb1d59da088e546e6f452b04232e553edfaf6ea5047d94159c37b2995e2c6ee5b7d4140ae1d4aff39123dc4789aac813c0198d48cec523306d39086e3db2e9fd81ebec3b69708921b671793aee9cfaa948196c5730d41c281625b67e62360a1c36d9da3e598ef5c74cf5fd9d08788a910e38231973c7ff5be9866333a53bc1fdab7e1edba80d481218605bd625c0c3c9df3c6d7c04a3b35172778ae9b93306fdd1cea5310d40d7c0c50c8dbab56dc243c13983336b3aa8851c406688d9fe273b311a5cab7a52287f70d6275f0d8e411d6314939741ba76d22150ceead39f87e92438bffa98047c795b2437ccc60fedc1642ebcc3df7cdc434abe7137f35295f06471180a6d252cc52a3eb8ac7aa6cc69c8dfe4b14cdd9aa584c8dfc89dbd8085a51f589887e42a7b074582a5dc183134d49e8631c5d55828d28e244521e823011c852d844a9fcde3d04db339aefe100000460da2cedf199458cd004953b7f8929a0ebd00d2053cec4e38cd7870d23140536f0426951cd52741e7e7bee6b335475c4b69b63df2e1b8aa9185b0c7cc2879ec96cb9442fc25aa4c07459ddbf5b40e1d7c3e96753d6cee2cb9a31a0f24d54c8d8929514bc512a5e765d45fedb9fb62293f8ea260e77ed280ee0920c29a72e8b2061d7109289a72bf593e9ce7f89fd4ec12454a09105fa8859a14e66081dc95502dfcc2840eb152eea56f66c9db4e7124cea71388d64c68108eb6a735327ccb72d114fc6c16ba866539f1e001ba217c5a1f65df8e459cdf40b022d38844df1a233b5430fec1196271445774776f30a57adf33d989510d627a9fe07e5a307ee9a40a9ef59503c4c6a683510243eca76163c9feccb08a602cfb31e2b712d2a4e33b4d3c43c22e9d11826e88e477a338de840b48fd0fc83d050abfbe0b9a83c8e4b066902dd4240314fd0c7605277b84d1c4e42a2a59c4b44c92b09cc8686bf3d77d12301c1329780ab2b66977d0507b29fb021c6ede56f3c751da9e11f035bce8e0d89257dac75c694dff8500f8ab0324067af8f3e8230cdc9dc20d88d487e444fe63518bc94ab468c1eb99a9db989b4f776702235dd04e4c6d0d12c7e5d1c81d937078fe83c6c3169c7e0680580ad3069ca3d884de7865e2f698f98d79bd393a5c8a06816b4309087e8c869df0d4b95da3afba7fa2f0f4e26708643bf64bf6749b14487c959171434f4102fd952956a29839cb40c7a445b5da9d52e40891422bc32f44b9e2cd0cd522c08f14c0c42a9f53ef5d25b93a39c5471edb9663957f11735d0e03faf6f2a1500d0679bdaf253867f2d7466d99c1814ce5225fcc4896798644d3b9f870a2e066f7630f8e32e3ecd3a6478229d51969ed7873a94ff6199d81ca7e847cb500f1ad9bba7744eaf189e6ad0941e9ddb04f87211ab63fc8f1fb10dcdd937ed7fb67674fced3b4c3a93ed3a6fe768335090ffc064f9f23fe3a06088538e6d42a5c08938e2a76e7cee5c6fc7bbb25c9d13a6be9172bde6b0151ccaf929c888ca1fbe62d71b20a47e3274657e124fd5a4b91d47a604cfe0a8a36aeb10548005e34b23ef250950a822145066313f3c0ff790d7d86cdb5b0275d61d9ea124cc1ccce7e7644791b055d9c22e5ed271a54dfe878e4a78922475af753a09ff34e9312ccc3b0332b31d475d3df23475a103cc2cba43578e2b56fed17250e9fdb146b8d1e228de7611d4ff7cfc7388f8023ae45992657d73d4383fd9269c385034c71a3c6ce1b850fac44eb9ea783be00b71ed5648c49a51f3fe56a278b50ebe41addb13648cd2a8f96533d30e6a92ba2423ee9d430834d2c69cb5105896d7322ab86d8010ec1b9f53c531d56e7b18f8c9015d1379af54f56d6b80fc27ac6d491d8445a4e737c74b2d9b2fde5d519110a65ecdc3fe8a8f7a8095b288848f6d2834d5fefc0e8d10bb8f7f3c7328f1bf98e84b907b194a9c0e2a2a482591192986b3245eed6a822fee6d28c979995c41d59802788f32e7d07c57672b3aa1a22ef2987d81d47a55da3c1cc947ef4cefea135f63e50cb493e3a0a6629d62885f3c20f1dd0db19bd031b0c97c9c88ddf543cad89ad28ee5ed9934c7116a8b3139d16478b8d280f763e6734607e63c2114158e7aa51d5e29065705cef9c055ce74719901426b6fcd7703bb5c7a69ecbb5ead9400508468cb04b792f5703fcfdfe927b431668cdc2ab528d0b0a23df4ad1bd13573a6e82cc5a0c989d878ec32c7eed2537c3cc32477b93aaf19445c661b392058dd205b4e27cc2d43e59d323f88ad51b1dde706fd15d3e1cb328ce21f0f99d0c0c64ede589ba311ef1f6dc83ceef1f83206c6eeaa5953db54041a1b93ded10226f40c4171f5576f628ad7eafb4b135ba154828a2eaafa31ff0031d348c653fd14c3c2c279cfc83b17fafcbce224a3f654fdac5c7303e17878b0814a9b089e46e8021651e181dfb52337f64e072e0c7cae96b1a07aa9b15d7a3ad55eb91ab2571db57381313d3d37eaf74b578e1ea801945a4a6ee4e41e722102d0ddbb40dbea0a927b836067539d925c1df17e8e60b0b727ba482e4801cc26a118bad1b728b44246ea26a821a70322d032337cdd283047b5bbf4c91cbfc7a9959ccdf2296ea0e880e31a528556b0258d6e88539b8063c180107dba12c77692849885c91409a191a2d018c689c51b85049631561b26ed07f94bb3f92d643e68ccdf257e1fff69aa29c200c7bde22a9bf4533a22d4766322024d7922a126e0e70e270d431607dc8cd51e1769b1552d980b1270830b47ae924e0467609c1e946e87f040e476269a1c8649d5487ee7ac83db8776d3b19aaed5248d6126677e70e933fce01395560de010759462af7bf985e837d1187d20f3e1f5bad32293df6c508dc637c2fa4b0f4a29503d4b7f5efb6f6416647db1d87570e01bb84277449eca243978bbbd3bec74e60540f6e4bfadfa3ddf91d317df9c942785c4eb05d1dfee9ea5ba0871deb58bc535d40c01e2af232e3f626d7f660d9c45d0328cb19d233ca55dc6763c3ac7521c4479e98f8e4fb836f9638918ec9f87209c001dd2f7cd62d6b6f1f19a8c254d006c4165a74b27b9bf3b13ffa8187cd31470c5228aae2610895e881af921792bb8425e28381783f52d2e7a62c1b2cc61e62885752f3c55c388476d46c5e979b14a5b2fbca27f8b397c5faf8a545ac6827c813fe464c2d2d2bd1b89c0f118b1a856853cd5f6f0f3f85cf69fe314992fe0588dfc17d2f91ee9b42ab456020bb3c6c767813fdc8ddc2d45ebdbc51d3bdf81dbe8e4aeef8de57d3df5217029274efb2a1461d010979ec62fe6a2ab5be399d6822411a35165614fb06647ff9bea755f81e57d7071e8e0d2e9f3eca484d78e85fb0ecbe50a35fa4e3773b481e7bc684ae03a2c98028c680e29a7de0c247a5259ce98be61414133f4d44d5f9bab77f90fc50f26f78d5b0b06c527ac5b28fdf442ff62de0bc054e146d72d8d2265969c61c86e89b29595c46f3c180603da5af4f40027a1fcd50047ea40ec0cd2ec6515ae5ee8750cdcab47aa0846c233b5257a59361861f4381a14301ff893b4650920e107888189cd81ccb05046c9ee3f6eeb0cdb66eb4aed169baa0e7c272d6667af7d43bb360d9f75e9598ce71718b348faf30629189585a482b4fddd249d2486abada132eade26a0c6661c9d0bb0c69a93a9a5c0e9d91e04639cacb4325c81c8854c7677900eeacb12dd2ac136fdc976dd4b70a510eebf7ffafe3e3d9bb02d497bb8eb54afbd637c216a0aef2d158738093bc51b04d268bc35a666fa6852b20a9253de16bd791806c4ca9787f607e360ebb21e89c7101420c3c4f227ca9b40570c81ccd5792cc16121e86598a0933f3c6bae6f4a3a8e88f01ca789cb4f317ff0b3cb7d97863ba155d3286259f01a77bb98cc5a3a82a76cc6a9d57d222c17c0e818ef2401949a8be33243207525810b68b679eabb0433de67966412a57bd9fa580088b91f91c73f9b90b9f99c0f2dc64e6f4412c723ef37d48c2b65e31c410bddd36b12e4ad971e7fadda63e0e31cfb4d1c5f9ed3df3daee17c940a2f2aed4eb25ba59071ad08a74bd3e66ace08f740b06da79eec0cc89f8e6a4640efbcdc54501bd09c22229a4ced39c0875faa79b1ec6ff1ff6ca3200239cb8e76bdf3d6f626f149e8e465ceed85b80d2ef8141f213eddf51b179cc71eb7f565335b2ade4261969d0b93590e644767647046c4c2225b5a944607c8ae6ca8374d82cca9c676154bc9e17769f0b934b67ea861bcc3f694c17e672e681df11d6a23a3b6830273c575c59237a5207314aa7e0aaa613f4235a5a6fa056e118222a837b4668e216571234333334e53074d7c168de8ae5d425a8093dc3148495c77dc487db3fe46d1345e9ab2ed76f41400b8f55065fe6c2254a0b5b3c1de770b6ee0761066b3058510c3fec2d7a49a1ce5a23f00afee1c80daa2ba182e480e21e92456f33de76610f05a2827e8d9e08ae1a7d94c40b23520ffab35079f1263bd872e9afb9c24fdcdac55837f8deaa82688f25c684f62658372dd8dcc4e71878d2d7de88f0abbcbb406785b56f0b5af3193f89e78a6d99c46c005b192107c798b513161034a2ee68459d5c3fa09e02949ddf0bde2002008f0d4d1645fc83ef607d77b5da65a2d29dc85a7749eed7dbe3aae61ac8e586b22db39559e9bf377ffd4b16d9db1a006a6a4570c2d1fca3ce67f57bfe7ee83663b812f5587b15f1b38a77393a05240b8b9773e9c5309e0c99ad1a37263025bb68d3fd527abf3ddf455323672498e42ff42cb39921af272cdf50c8d71fb21258baf4daed4ecb5b4c011d6e6ba6312b0298b45933edf34711469aebea4bcb42650f0083dac03e19e7b3d759e89911e7ec8d4b49be4a14b84c6837b54ebe84e4768efccb5652e2fc2c7da622398cf14f5eede30654041e8208be88b60700b52d709503324aac521a50a774aaa4d6320e853324e8ea3daf3eea741d1a37fce97f695cb14cfb099556f8b506a7c181bbef95c2e3e51b3f4777c93b090cbaf02190b17cd55b805a725a5ce12a1a4552893287b4f6157a1943fa2c5069b1155fddd400242cf6c4ee641e61b49e4af3d31b06363056b720f5cbdd89af7a9d44b4f9755fb2ced9155643d2aeaa87e4cf23098a0e3d835b47588f80885db8a86d7f1ead86ac05764688b07a97512aba8bdb732abedf91c7739eddfda98943617fd600dba5c9bd6edf0be4e7c9e5b79239d8d5391648b8cbf4e01442623d0015e84d6de70fefa83b926a3a30283fd60832b64c9e8bbe1b7d86bfdfd3cac7aec1d690b8421defb5c47d073be3d0390f9e8ac593fe0cc3507edfa2d5b367a8b1aa3d13b97242508a39dbe50a8ff6f97f84f03f231a29e1c19a82508df6aa002d84f5140411ec0547e51451a2664d9f7f7eba7408fe21bdae5b66b55e9e68ecabe3854bb898e82bdaa093581d5f3273b0443b9791cac4d4ecc587992ec5711d2091e6a5404578016b797003823dd275bf68f3fdb81756f88e48affc0a307f2a3319c445d154405e13c85858f69b8f1137eeace7e6f198b9c89095a81ae0a394fb81ea316c30e42550833d69f60b0bcc48666f3145e8b2e648296530dc37b10b93b3f1d6ebce328c478dc68516c37a0a44a9d7b83110d1e2f839bc4ac535839a8f038aec107d23732ac9387115691d9caee5eb119a4a96b39c865fae635c09d389c4802872d4a451af71b8f951fac8c9116fe4d2e00b4c00238981ea9ff620beb6cdd600242e00c19c6976b176df9188760f473d7d69ab4c9d154ac3e15b8e92b09e4dd8339c29344ddf589ae86b0607516a7ef1bb798687f4107a17c4c29c7a3a86667eb2f0c8f9ea7e529fbf460b8565cfe83b3495487b9652efc82d8837d798db637954bacf04eb553f31772f926a020f6dcc702de99ed14affee54b0ad6889d08c12985280a167fbd5bd6d82e31ae5cc4ee14dccfe13f2f287d69ed94b56b823a4c889ceee7bbbf86e5a0bfae409d04aa49a7cace01128ed432e42aeee0f061b5154a4fe69e8f7a563999c1e742749c695bde582cf8ec339f653747bce6a1cf37c3effb2474ea83ac86ce65738ac2137b02f52bf6f45b70d9b09b069e5035718a6005d24e1b115ef4e35900134078b43a358f8fecfb7615938fef1a68c25db64b462fb472e5dc913de4201fe2b1f18c8572226eb0396ed7b3649ee4f9c09156076acf6520254944b0afb7f23260a4ffd415f45a95a8f8a483b5c02d7f3ac13745574d4576dd8f26a1ef7a015666ab88f2882b080884d042a8712085e780133631c405c615bf16ed83a00761920bc8110d958df5f2e78a1b5861a2ab8cb4669406442dbc3aae2eca3547563ed81e19613733ff8692ebb909e250ac8a8d0b2e31f6b081875cab5008544fa0405b7b65d802609074eb1c2dbdb40006eb2a2e2144627c5c198de5cf67d5e51bd44ca33d8ce855d7213863c1a0379db18b9f7e4a9b26312fac88cb4dc583cdbe68815d136c2558c3235f14fe9ee71b77f93e232fa6bd6bbad6277beb553d9c2b263d7f61d4923eab92ea87b70f5e60c2b171d948072c8547ee064e56fc6e6b04e03d8625aefddfdf2dd2bf47e736b9764018795e9251325727cc18394873515d417c4dae51a2083cbe92e269bb73d4df406ac1ac2b00da6a074585eaa1c14bd13f7c0fbfa7b6d9c7cc8de741a342332ac6e952614d256d8ec3d13eedbb9030745c2d6e2894b7f161bff16c5383fa42538e1f8e61b1bc191c24bfd5191b4870fa1849f847ce267d8f9ee88185f597b52e586a1cf4db90e78512687eaecb03cb0ad7d5ca24a44864f0d1ee15ae6de0bd2e80476d9c107922104b5c6d153372aa34228f80af362cea276c4af62da5b894f30783bdfe66f4f67a0f88f88f3b07302a1c0fb4e39153a3032113e4380d53ecc3f4d2c5b0be3347b4edb2d77462fce686e00eb394f1f154751b541a9b1e270fac6b68bc2ad1e7a05600844a24cb7414bc01de828b57ad4021310a2116fb051c219b6b0477bca6ae2351506c6463d353bdede28bb535ebfa0cd07e9acc321857fd1d2868b21bcb2de953adef4a9be5a01674a4b9561ebe2fdc00e77fd41d12fe0dcaaee04d2a61b5336e80c09459ecf58d57118d129c1e3f2d592a7acdfd230865a3913793af1b0a7c4662eedd1ab6d2d688a695a3a6ca27a258cdca2be8ca3b693cc6f603d3b31a29ab27063a499042dfbbacfdcd22e3026c5b2f2db01d2038bf4aab9d9073b67ec9b42891b8e12c1e912d2eff315d1a70b3644aaca157b9eaa726ea1ec6a829c9afbaf90a8dcae5abe9c265961f89c3f990004a4cb020660045e13638d62531c439918d391e929fcc61187c6ad85d3634de9af2185cd164efe4a9bfb6fff66aa49413a28e1c8dababc0485bd8ad6daa3ce41f13e5039ff740ae80a385f6eac8eccd267809869482e1e48b7c0947a2c39bb0927d3af68c635de432dc30c21a16763b3053a65e3fdd15c8416254aaaef439b648cf1d41bba6d82bc9898001c9b63c1610eaf53c8943b40b0a0ccc371a06083267e4f9f8b944a394f3ad323690f44c000949d044b7efc9f1fea597899aa6f2ef51db496665e44f6bedcc895fc2509a94c5ed012571f29e8b697d3a5f269f3a9e1b36452b95903e7a41c9ec740d39fb44c20fffa72962c83e338690092a669df87e1f62adaed25893ef85b4d69550f8e87f5ae0a7a959e5b66ab37446397b340a1474653cff066e3545ef45f061fb311907316a32286829c1c060b95030ae0521dfa2fae37edf4ccf087351ea9610a79738d0206143b25afebeef3bf70cae85f80d3adaff155b01be386c5dd939a02948f19b0319066fc6f270dfbeacffb0824b6a9515fd28b7d6d12a6696888257da6c562eb05d5fed658debdee5bf760e32a4177b3f61511c8c9311b1274e92657302524448e7e6487e6cad10ef95df5f61d8192ff7da983cd4249d1849947febc64932528da5434edf9615f610cdd51aa6c5c836b7268fcf0678f2b388afbbbbad5ada04e179e3828f72f58d797ec150e321e6c3a0b001e17316c1d5e4c69329ef58f19241cf619d0187978f5a2065e92c35170baeca8115e05565ca867fe527504b5da1585d73f549822718bf0bb513195ad2c089213ed1609cb8becf74a270ed784f046834e90bfa74f7a3ae962915c34f438e98070d6f6599b1b4dc574a2e7064a8d2509f6735cfeb83b73a2e5acb6bf6bdd623f97dee5eda355488a075e75a42cacdc668940b45c36ec18615929b5e3b30f50a8041a265e5477c322d58299a3d4e6eeda2a41e2a7c012dded8035e5dc0669f6623c137e1a1beb3b756d2f96a1556bdeb9a0cd12b5e131666a3789e2f7cf26a302683b4a54acb396153bb72b708627118b92e860a408be7fafe8bc22628761f0342d6e8cde0e8589231dad2c5492a4b709ad8dd54836e0d8af941c07f07baa7634e009209790e40f8b5717f7045d261963621ff1c7bdf2e222e1cb49bd2661f27e1ab847111992d1cf116c3464a40c384748e983e13ea59e8c904b14a134b1f28989ebc22eefff52b0f53bd9a752fe5748bd6befd380b44ead46810b9d0d9397280dc6c66cbf624b3fb7cf5630c20dd7490eddd51be88f41290e597f1d368f0a43fb0d3265ce9735620fdd089b506de63e7cd2ce852d8fb8ec7f39f84ff4857abe4f1850facd37b855868137d84ea2a8809d58c12c855725d83e6db7e4bae9c95c8c8a711d6c7a644c141b45d5d27bf632f82fd4eba8dde23f9adbe4487c6eb6a655590cf940f1cf14c9255efdc160ddcaf82a0ebe60c7baf09937cb7a45e2d9809fdaee4343b8b55beacc15803bb4101870a170f1768c7c29ada62e7e35cb5849d6afbb9fab20dd8e6bbfdd27e29131ffc431d7d0dbf675291eee427d281efa357e40c333fcc1ec755b81e88abcd1dc7bbccff3ef98ee37c69655cfc1b81e2be13cb406e14802402fc38ab79aa49e8465175ba4eeb68b00eed88c9ea09bb3d59750d7ecfbdbd00a9cd542c7dacd81f68b608cf4e5f61f9d0e5db3cefc4415ea00b633b88e4bf23d8b3b9910b8f01658f09dc4cc1f5d05a42dbb6111f548a81595484ad73673fa82ecafde0854be1e0dcd7acba61ba67113cb899f832bbaa57e87477cd1095458a284735b3cfa0505dbe613587024a20f874508ee6322a05de2208a853db0c21f164038c9f495a2ee894fc2711b7301a80419f69de0496546a70052bed4225216db490935558c37759f7f601cf7255ae83bd7b4b5cb1ad3d12a6157aa351d8dd245d5ccf75c2bf278291c8f9ea0c85ee170ffad5bd04f5465bd72d2eb397f92425126b764abf6dc54b921f6297546023bab3d0e371b61f14c2435d5195d6aae7653450df613d71fd7b47c47ae02eb97a24f581bce976f2c3fa7e9283978d1998815ee5219f02f2bbdbddf9fcfa1497d81cca408cf3b0809d9c168d87c9df24b8a151a5958c0f125153861e20b2c8521624787ca6c22cca4b49cb303ed67824984d053abe7485b94685ae363f40fb8607dab594c6ca5b545069580d5cf34aaa7de7aea4277898549eebb77c3c3047a8e2718509cb8de834a4079832a2b73f7157f3bf3ee8aae1721121326aef83cc109b793b147ba0f188bb8781806c948a8e3fc68a789b99fa613218137e9a2f0b75396c7e233c98d374838564e59593408645021c274ee16192a7d3f3e43e78ad676eed8ee42b93d69e1fbfb832616f406cf0a1fe75d8daead18485792c5c1b20a9c31c5ea011ead4254ba1f0d7c3a2f161b11f7fc89a3eaf0d226f748733e733fa7dc7286721bec09807c6517e0608a9765bc65cf1cb2c353d28e46af482cfd07d18f6811aaa153405facae0caab6f36c58388426af281fd4c001f784d36f88dc7f5b6c2c561f44a79933f833c184e523a0317b7d692e2325dfd52285fdff32a0322da277f2c4c01759e6dd16301835da1025fc8e20642191727738bd979d8e75dc80087f5f707f2198b6d922fbeeb8caa455d9b17b7ebe0f79452fc07c4b1a97d34a2c530d7d264db5e4d126fe295e17503ffad65d5d84964e1309c3d75767fdba53757466e915a76b84189cd12cab4dbc58e666cfb4eea6ff2f8d53d6857d5e99e8d67fb999ae45254240ef9cc5f080de28be7932afc6273268e919608881b6865b20d8fe9d4b58e626bc0424f8b11ee7324108f0dc69a83a0d75dce38aaeeed3c357e0d4ad7cd5a921d5e2d895e2f57edae8d7b76ba2cceea1aa7e1736d2b01263265846f56c59931ab0b3790aef912f0d939d239ca9dc11578a4d164ec206dbdb035a450b81f9a68bce8653046bdb4698244ea1623f5bd51c76c45ff9d5bafc2b4b2c12c67009b2f6238719d3b9b042dd4b973f4d32315fe3e4912536932cd60b9b95665a87e240bce6a39e49e58d490706ea58a86a6c0282ee44994e9c9b97b14da92252f5094638bb23a86449172d0f4496c7bbbf7e0f1ec98fc9e8ee23541006390f7fe5c8da0e55628cb20fd3bc340bd25ad2af6d25b0cddcdb42193a6b66da5d995488f02a9b21fdfa66297161ac7c806d12705c2bc6cd1b0cae729e1cc20c06350b0653e9cd1c7fc0e35fcfee3e5a9ece5ff96e092ac9d0e4aa0a5d8f5779647b307714a9b55220feb4bdfd14bafe801e61e56d43aec43b32d1e8b78457ac0a7772c1b7f6c43461a68b9a9503fc83675f92d48a78cd081f559b2ab560f0d368f540d40e59c68a3ec9209a6cc3cd10940c767d6b70c63fcb27d9f3b7b6da72ecdbd7a7a75f3f498364a0184d9a5a2dddcc3eda53b3c744c1b88d495411eca1c4ee39eb62e1d64f02cb11a86f8004dd3948c8309e4bc77b4b2130b82ad5d14dd7bec29bdc71c50517ef181a529b944e8bb047bf9aba2b2e81940488e00508f549abf3ba780273bad28ce9ebb6229a66406f581add3ee0afbe5771308847ae1310891961101f7c72e9a8e19a3406d44684508cf4763def88146e50afd73332c4f0e74519d3d47434067b6c9b18db1d17663081ed4fca1140594a4d4372c884affd9b89555375aba0b43679f89b8a069d1deb7f8b472bc4fcd5e6fa513bd4b3c8ef028959e521993a4ed7b409ab19f5a5f9fc20892330112ac78be204531c3e9fc8f88f17171770879fb192d519cc203496e1cacbd9e89473062cc3d9a2043f8527d5138790d496707dbc5c1d1b669c5c1ca0bae30aa290fb0f9b378e832aac67c765b63e94e69ea69604d57bddc95840a064a9425bcff78aa1a40c776c52cee457b81b5b85c81de633af7e2b6dc94d9d9498c239e84e45fd9d848b0d49bef9528825bcab144505d068ec1326eeef41786a7b006b8130ce9bf7dc93aef5c5797bf98ef0109c08b1003276003a9189edf4cd34979b7ad8ded9447e7b26fb1253c1dd127f711f74affb7631658c81d4f186afa1229906001862a0364806b5aca89544f29a02a22ace9107b980b35ece37298501490019cc8783353d990765a89b641c40e575689616218a77da995625f21785666130a50248e8cffcbb1652c63a300ab5145f20fff8eef27c308044bdd8300a0a455f5fd9b573812e99187695f77782790b2c1789c4a1611829c90c29ff74b7002a23633fc032f0a7698c69ee590cbda5b7779c020c1c0f3e14b3afefd58109ce6300218d4a653c0b2106af55b5e7b903d71065bc7bfb740e6fdff6bdda54184c4bcc9b1fb14e8813001796e5fe0190f932ae3b6298a6fc5d3bebc45f0da351732ac226a89e0df9b48b6872aca19e0dddcc2efa96f3bdb102c773c471c7dc27460a720ddab0354ce6435d7f4cef3eaa5bde8083c0a391a4c5c4d86ac4d4fa6d93862f20d687670c30f3dea54196d501d6cd01d3e66bfce85b8ca924e557104c10639351fec01cdf24c10012196e9e48cd990d53be330b10f725cc3609eec6a72b630a686427f364aac2219e7d4089730b13aa76c2db43618316cf0430090f1da5bbad6e7cf54958111bb908012a903dc7f0abe2e6528c2dc10b08faa845f3d95edac9ab7f6d16ad10b3ac367dce16fb58faf81666b2afdfd88a712ce1dc376f4a832dd1aa1503090aadb0c9a4dec8a1848c95c33ca395d3e7812012951a6d99d0e55ebc6827c17e37f483eadf522902b1d1d4b592e2604a565fbcca3edd9185400c9bf4dd0df7786967402af44066843cd35feaed6f73d0b852702da1434560e3a7bc32dfb7dedd0065b37bd048bee84fab7d897e16d2c72bbccd12247be916f58cd92d392ec70d82c0f01f82975d1be8482aaae3c34b83768045f173f3b15b3081c28d02deb067ecab55950fd77792e583365e13078d041535f0d503668f6a899b1d0fc4c53e40473c5ecdbc8a76f4722e70b620cf558d2654688e97aeec988782b80cc87979c8124ceaf4ec21c1577120edfc5ff4f84ec43b98527e2be2d0862602c6e7a209f4af8045a8f83c69722efb50b1ea8bfeb400bbc5e99701ced644cc06ed0d86c68df558a65c7b15f1849399cfe3a760d9bd3b06b3ce6edd1ecd846bfb02c6911d17327f42f30d8776df70183628b04257aff724e2a3ba391ec56ab67dbd8b2db73928dc949aa24e6d515be06655ffea15eaa22752cd01c1c02ecd7672f292ef7dc383b7679fc0e2ecbf53caad2b2c67520279db2fc955a797344957408b7352a1bd51a34d972ce3293de9f6895608dd2accb3e645710f55f062e76f46df21de0cd950a99a6d234d547bed80a75ee0f39c1ec854524c4244a8ec67b50a853ae46bba3cdeb1e2dda66fffca2a669eb154680c73c2215ad7cc5a69402ac201773a44389d38c58395e706778592832ffd44dd86c9bb729f747c45d8144638f17cb04a279212f8a68b51dd44c774714f0516244c9fd68b389c5494d649e7f453bdeca3a75db78f805102d726ac7416d9ee81e85d136e32ce93178585c1e3a10674f81853407879e7564b5efd91c43740c812bff853fa4c61bafd12458731fa1301f337602c810ad8689172f52a0603a0295a7ce031a2e1c29bb4a26e207a487a720ee1b0f5d382f9386cb923fa7ec1e36a8021a2fdb8a691c35264a643819dfac03cc865a3ef85cf8b9194cabf014a297af763113966c63f76fc3eb8ceb1cbed9f92699bd2895ea82acd68e1520e82c97bbc48526e24f4711a32748ab576ae22f20bad3ac0016d15d1cb90d3a69ec6cbe43e943529b8e5a53bb67d4ed57eee4b4597b7e2f947c369842cd419951fd321a2ecf0c59a45820e4fef06280523b8195c3df2d0b4953e03d02fa62ab44df9a4923aa55df60cc21ef8ae2990f30ce0bdb152999c8e0eb787628c308bca5265c62294928a60bc848493728490e81d2974ed4297dd982bdf2dca719767defe817d982dda8d4bad26d14e3c6dc4d9501b9cb916095b436d9edcd61680300d456dd67bab38b23689652b37574eb64299b56ac4f707fca12a4649dbcc5fa94d6e04951491e2b858dcb2c80b451be32bcbbbbbef0f7e1670db7498a3a0c5fe3b5e6a433ca08ae2204f4f21f1d748f76329428925174d3647807350e57b857f9fd17435316faa446d449c836c8a4b4a1795bff485cb1938bbec6a472f5f3c5fce1e4b56bdffc904728ba6ca0be17d300b3eedc31707dac837568848882e1864698deefbc54287c3cdb81806107dc630b20bafbe5576aeca56381bbaf33846f050effa620b2472746568324836e4a3764c1ba467e095c093ca081c330ef6111ed14b53d171761d6f4bc70a1ae5657bc36248a3364000d7ff79d6ac6501e02813a05e8cf1c24d6fe18b7bc94c2b02768211202ea0ae9906174f41034b48daad8b441645cffbfe7994cf26d9d108a771056fbaf30ecfad8444c72ef385a3ebe89490bc58065e658f394f16405677010e61f1421ad94db54d60ca2cc56f08feca2f36d612218f0178f5e9808c21b7d6e0c1b34a4ec2346f0836ec26f3e096a2b167c62b6445e14b31f7f22e851dd8befb493a2c78f689b2f4217b31609f80bc2c50db0de209b8446a9b107c1db4413ee6f73f4ff767a429278185888df75689bc8ee3b0a67debf7c5583e3eaac119a943786603b2a05fb0020da1b4323290841433dd776ff362c473d2027356ccc83c6efcd63fbb3e388255ccd91ea3259f0844944a039d5ec40ed08a70b4ec6719fe671190d3f3dfd2444022593e9068069d0bc773c96c266341f7270de797d3e8ef0a0e26260ce762dbdd81597ce925ec518bcaf689b20cadced1b16b4293a73eb79520d3c9abf4d0978193217266df364189bc1241119519c51b091425160b1eb847a03726f671cb5f4badabe33b5a0c1dccbf535d7ee67340fb11e7518cfe03170b77e34b116b134ce729d33f17617ab5f2eb9162171e27934f6d4baf25999468e72267cedf32932c51546ab3199e3572852585135976c94c423bee860ecda2c494fba36696887fec56aa558f1f37b79b410ff6b90d0b37da67a4019847e315b8cb798b8e48e8cc9fa6d634d1bd5738464714950939f11f72a722d6ab6140a5896c4142d67e70981a697a438580d6ec97945739a492d58f0d42b50b12cab89b8eaee5ee7ba9c23526c5d9cd204878a74c83e2534bfb63114241f490447bc195d306c30af016346de2bdd4243cb0cd6feaaf052475d426aac6dcb461228a6a836a1fc50915919118825225d196c0743b646309056df6aac29a123bf0c8f1f7efa37f89c0aea17094cf0679520fbc3d4829259c7ab9da08d0d3c639af7b3cbeff3d6fa01074528ff42da92083061a38abb4d12d5078fb5d405f3429b3dfd584e784e12646da20aa669a2a7b41ebd3ed170bfea5f8d6d00e3d4eef7f982591092f79f0376c4f8a2fcf5ec04257ae6da1e491c705674c1dfbe08cb401fb6840297d067a97b722b6056a8bc27fe3c619787dd121896a4b3bfed08cd5","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
