<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2c39f6481e4d80990dc34f74beca512750359baa4053c856a74666eb4bd795fca3686a734594757735616960f375e3cbafe5acc0447ea906c0566fac0d0366f4378294ba745f7aa09ad42b3f960d614fb194a31afc4878004fc98255a25c42a092d7d82af4326b1e846d0c1fcb93a264c2791ed8437db12afe53dfebdf46b5be90898b5fdbcc074fa2d8a3fc928bf75d4eee1d49af6ea9e6a851f3245b9b7c29a152fa45f25db79e6b3a71f9fd95ca46a7dda4468cf42012051301684c691af4fc2d5cbfcde849b7fe80cb1f85dfb05398c8528bb73e4ca546f5c4a807d39ecf44f2c0e13730ca140f8614c7ca288f9d32440c9512259a7e597df056c1691ddd809b67bc9ece5bc9f99fae4dfee99cb5940c954a0cce293cda97e721f21d94e4f00e284a764ef0622d361c799e4eff433b1fa3603e1e986aef1dd59fb913d8c870555bf1d8df418d31afb8d2f72fdcb5a808643b06e662618263f44715ef651c2f610bdd75dddb28d79a2caa3422ba5efa146df423bf812bdf30b25552f82f91b54ac09e7abde9b51a6d72edba7a78f8ad0cae0f58b6201c1e02a7426f81136975d757b9131e352b69eb85742b329f850b5fb3ceb3ddb3a2bc972e5d8f803c2032c9418aacebc13eaf51783aee1738407017c1796dd3159e6cf2479c78fd64ca058051db938e43f5b206df25eaba0509b23011700bb6e010b755911f666ca0075f28da3cb819cddaacdf5b6a8571c24dad02463dfaaa9d998516f9b8398d8a075cb45d9742528660adb26138a4a44eb0b7f0c2b0d5eb1534eda92ae64c1ddf9e10fd28f67dfb1ffc59d22e36d95c7bd5c220a68f34a6f2b7bb0d4fe3eb90efc489fc4bde9bec908771ef623734aabc3023b8632435ec2b2d2c25d1808cef4b73f2be4c2e5e09d2b2cdc5ea8f14b2b4b7653e3d2cdac2ad88756f282321e6bae3d58d2ef5871560d42eb1276a2061c4d73e9ea499deb8abee0034eb3a0ca3eb86ad4466d2ec6ac8ef7a1f8ba314a6a7f8a07148364ae914624a95e6edbe8bcf738a804171c05ad0e5141148317d4a4e58eaa7fb0a40f81a62d9e1aa8ba6da1e02240a5a41c96a94dd9ef837d1480e7cd2bb1cad6266e4585f3dad51ca84f2e5589c5e0a77e47f06bec64712c0aa30977f115006dd8973875595bf834e9545fe136505193c61acf7be1309561cb5d72d5ffd33d2a87410f945655d36075f96136f2a6043e8a99f8e2a9ad10267a75117d162ccfc611eb5931041846dc5370e28c577a02ada497bad86904cc342196087f2bc81b6d34c6976636dfa068b7e493c099f75faee916f37478cfbc145d6288c7d24aa37619f7d1e7169bd9c40836704b87717f9b78b9b957873f5a6704978e9a5a0704feb85438e977212063a13ca7d697bef087240c5c289780cb23791cae8affa16a50df0daeff59d43df8c039711d62e2525dee2ff6f23a6dd568df0d018aa601c4a35dd467309182544abfca72240edda73f1672a12ccf44c3967c3a5f57e03386ef2cf5b6ee79a96e13bf9a3f2cb42554e6d5b3fa350abb7ddd9857176ac854caa4537ce47d6d20bf841bcee9eb025041f0fbabde320398a2b28c007b4e89e3b122b9691d37d89a7ae55b80aa470c5c43e83a46aec6eb470300ac16bb02841faadb2362810957607d502cfa11ad0784736019b1ad80446fcb5b039f4951964a61ce19420eaf754da612b150da748f4f1d2d91f76b7f2448f83ee6acd2aa9a16de46f6d03d052370427db18f6e150b043358271d767bb54aba3d5c33aa5c162cfc4af834e0a9699092eb1a3bfafad5947cee56d3f9bab3c622510514d6d3f1e95b112dad3f5e7017b9f284cd0085506a0a16f4b95059a4886e02c4f1f44401af7e97b7545a0860efc59a95ac983e50b50b83b6fd60efd32f2cf0ac8a2a26fdc83b04d7b4950d742d8cf193a11a4e708cbe4bc2dfadfb9add59a158c9a4d6dbbeda95da8c7b0bf61debdac87afe3f1aba9f9bd574a03e6daeb9c982f1b495c2030bf6ba3f2bd2fd42d1481f84db35efe3ad3a4df3da707cb4f15636800902e7431bd281b7d284963b1f99e3633d1c4731512bd93088e902b50bc0b5e695b86852dba2d8b2c7a23894ceae9595b4c8a735de8789e22d959f9cd0b1ef80e3b3732d4bd7cbf8de028fcd3ddd2dc77300e826d05186808ac808749ca6eba561c9a40355aed63c3a5eadfbb9335594087fbff8033d8127e5f49bd21eca4deb4c106273ce4de9da804fa355df8ffe9a6b286fad4d76d60d22a97cc2e84e1eece238a97d1eff8b2b8d7a5c243e0284480b5baad4c8dd56fbcb3a289f5569aaaaaac1e38f2d8844a4489b6e35183ad09b9f69644b7c6e804fd34ebbc2bfae1d0cf05ce6f24a209789e95a08a8d5236a3c47076be938af1c1687f9afa77741bdf075dd6d6c1c1f64fc95e6c24ab176ce81016cabe224c47a361c069946a2d383183b68f13c9992ef14fff6ab2ddb3204537667e76772fbf847a3dc7d5bce121269c327280b6bd60a9a392fa451b7efcecb2c9320077125d2a273e00944d1a3e2a0dba7fa91e0e7748f65326a680cf701ea5615bfa57ea8245281ba698dcfd8a2d9eebc43e046540e6a90b93f6988335e912df0c2eb85f0330aac0ba3279ebabb7b5d82bff84c4619cfb91d938b39cf05c7bf08a4f113ae132c1de0b8e2869e7fcc55fee540bc38c8d98757057cefccbf3fac41c0eeb8c0575bfa972bd229528ff099c402738ae1129988a26e0eb7d010a392a4edd110c65206977e6482fdd12efbcc1a6ac7c726c4fd6de396ffebb31e47166da7223c3e0b53ba1c07a8bcf9ec98e76b34d423d123c9650456846a83de04af86afa9071b97ea16ddedadc821fb735f6431b0c7e1f7cf9333b319695b33ceb84d03aa1eddf85e6cc0af3df7e8f4915cb2929bb0f811d423e399851a85293bfbaf271553eb545b95721a851797bf919667ab99719cd995c808ad8734234b8bcf4ac2928055a3e25c8aa29ff67d343716b51edbefba240863f9fab2970e418134eef3a1c39b598fccb1c35193f601e5cb425836d59e0c7ca73aac308c7c3b6d0e2435ed193168bd973bf1534c323b87337007173e02aa1640373408949dcba32f71ed28282a6dd18706b7750d7626369217a55044da87c4fc43ae5cb6a45cc50c00c7db3b678f4dc211d3013f62b2a43c149f29c5d87e43e02d1fc5ceb13b047616434ffdca3b9590e1bf1b49c741b496f524a13ee5ce50e234cfd967bb237ac4de6172396c885f73d3978f7239b82994682bfa1848e1ad3761b2c4fd7a63664d45b2da6897405986c8879740fd79b4cdeba6f92cc6fb0e1454261a2de5683be6a39c2ebd89ea8c058a2f959f329ae973cae3e50923397f06c80dac5aa07aa87900d8d1d3fb83d9296f0aa1eff2f205cf68baaede477d93bef3da5387c528a40b1712dd965d515f4ed96cd484204281ff9fcf7de1fb341e2d41d32b689b1c7c7a1f7aa8603933989b426a7cd896d858988efb680acb002b4dc4919e4f63ac7a7b304fb75549dceda36014c839c201a3c2f6b82cb538e41d6295f98c0b5fccf3f90eb539109c5608836d4208d43537b94fe2dfd80a9299853e74effc0957682d1f510da3e3b8c8f02fb02524769419465c7329c635441deda2b7d412d6321fda70bfff5c4f887a222184dc4a76ccdc3c4a58bcd68948aca90dc0535ef9e9397b8b26689a8a8f070b0d3bcd2ebb7b23cfe762b1fc8b74a77a8c5ebfa62eac48a3c0eb94affef4eda574fd388595a231c61d83032e308704288852f49f82b1adafb41ade86bb428307c701683360b41c57e916fe782964f117737bb0b2b8254ff4c398b93f53930a1f1aa930b15a54c60d3cdbb2aafde86638ed8b5e09ffeb782b6d645bddbceec4c7f4513c6f610f14d61f878f29e9c0e21e8e534c18475212457e9d60448f1e7f990d5d72de6c0293b14d64143891cab0ae3811b1b8245bab88124b69a973fb8958a0bc593de5d47817ed6f877de19c741e7e361549e401be047650b33c658b48da7aebb539469c789ac122f09ab037751b3875a37df53736595194fe900766b4347ce24696aeccb1bd5433fa30c12fba52f3b4e88c7e3e9474c22279c31146e9a28eaaca60bb896fe431fc7e742cb889513571e1965a191e0f306b9eadcd7ab7554c2b21e9a8eb8188b187137b2fef5d06e5685df5e882baa968973bb64d4f2b4b814f2e33c38172e5fd3315366b15215c13caf31f46ee641c7c9f5fa06a28d73febfa76d1531de0eb06237479276c1d9a00a50653d3bdb32f4cbf6b2edeb8eed49a1e2092462f2a66756b353c07e73147064a689c82ce9cc8bcfbe74fe6fd4df8bfa3f88defa024ffab90ee8bc8a02b00af1ec5f01ca378259b8df98f3374d644f22f671cc75a0c2474447abe4dbef36e3cb8da7e0de3805812a7ea6e911c53a0faf537d554d44e52bc6e522105bcb831d550c6e2154b902223b4525085f84dc3fed39b0e585564b207ac05f31cd8a164431a6ed5edd52aa71f0db721a5f2d6e88655372f01efe025896cc1946d12f57434c0988353704ba3a60adb4ac817e0305d469a7a78ca25e7f31cf9b585d3783b498bbf2e803e1f2dd50f01f73be49a82ff898fa3af9bfff43d1b649143ae595c4a74130185d39e262d3ddf70b2b5b5a9712de69e24b8a6ddc72490b3b6a163ac41f0ca91ecdf5c084ff4933ae65e2d5ac52d7769857bc3e08b05fa602fbd75120a3b0c38a49dd2249f8bbd1d31235153b74a78b61a61ddff0fc6e24cfd35ffcd94580f52188eb47b5b608d1de4aab1c4f15cd75f7984ee2e4f8745f6445a3bd219644fee58e085ba566b049c16c3a37c7d65bb5224d1766cbfa2e2c06dead69f3da796e0eec5f20fcf732b6a7c65cbc10d517c70b844e5b651061db4c794d11fdbbe3b946908f819408eecd7a15cee7e585da9b28daa8b1e61782a0638268424098cc1d75b58cb143407ab4f262aae090d3546189387783386aa6af09c05f87e50672e806a3b5dbe5ea1c92d219639c8d0c5e0fed864f68f91e97c0d2494191b391ae6ac56e2163afe8f66f2a649afe60ed089dbac1387d1dbd1583755c41fb1a861e1b17c1139c43424941a56bedb02446bafd14d6f4bf77bbbe4b63b6a676177ffcdf7e95e91ce7487c93c63fa5ea41a2b3db70eaf7f5005566ed57c5c7635c9995653457e402e2850f45c82bbea4a1817cab9ebdb13fbf503b98830b01216e2468dcd76fac9181db341e2827f4cc2b419e6b74be5ba1c217954a638c7933d138a0962abd4cccd498fc92115c8433e606fe9bce36b0fc27d629815f79d5672f2bb71e3447ce9bcfc43c7ad2dbd43222fecc328cc0fce89585ce3584b68e29b892d3b3da60a49558930acaf3603bf00caafd1b4b10f90532cc227b9808a21164512c66dd67738101475bbd7c933b935ddf6a9e305a39d6cd0167dca594491d17c8dba783619c673825d7acc599912f80f0e36b6c06cd3ce600d5c4479cbf5bf2246d21c325610192a7c0370e85c0c43a203e25162af1c0151fb5c3e1049aeba7542136711566426c4ecaf0bf299a0b9e0cdfea0a9370f633352ef0f4d2584286dc2c519613bb519e21878796b062ed785da88b6fac52edd652e6873b00c5e05eea78bb591bfdbf7fa379503bdc38840b9914c08d12bba8991a825cff0d6aa7018cbe4c75b6cd78bb0364ee24f1e645c4415c91b3015add610078b19956453c0f667b37b349e7baf562a6feae6945599ad943917221b05a084db1d9d85cb5db0c1f81cee239558d35c6d25306a084862a442222cfc3aaf0018432fe3d4dedaa803d06e72b9597f1e163c6a49a151fa3ee4ed930d6f9fda379a76963efd38349e200d4fc62cf2c71b4dbe89a7d44607525abf7e7f02895b3a5c454892f7eee46595f3ad55529356f845a4a36c08fd7f5b485ae2458bdcf328c8952e2c6bdc38e200ad3058992aeb3173f3adbfcf6bcea02eb5c145e91db33d8c8c282d951e0566afc6ac4a41b86eae38fc90a3731c5043a08c84085b1c6314ff622219e4da10922ba60b26389887af4b001e21eec591e7cd72e5c4cc925b6034004a6b947ddf884e0e7989f10b8d566be0b5f16136cc4cf2a0f79ee9e18d6913fa1348d15f6c7358c067cd7631b1b56cfd8309ad62d1bde176571c25179b8d2edbb40083c1cc85024e38da684ed50286c1da994aa2e1ebf2034931682b2d9234efb023765d3895cedfa3967961b57cf95a45e31ca2822495b216f0b961b609aac50babc9009339185791cce292fe0e5f4f6b0b2bfaeddb429f550580ebc060e89fdd11d79beb7042da30a8e3b9a8c6fbe736fa74bca1b7f2cb2353f2aa9eb8f1fa2ff734d62fb3b86faa188540a22d8e17fb1c4a9242dd62687148860ab344372048af22b1b2e15b742ffa5ee7b5165a5b886b7f0bfd4c0506ab274c4054e61c13dcbe06a7dc32a5d258e1ebe0973f3681d1b6ecbbb0a6acc40804a3c3b6516335183aa89ef287f09a79e2f2f0aba0447d75e3981673dcad11cd676d545085fd213f7bcdc83eb07a628adee6b87a05290ecfdc72e43d944dacce49e8e89ffa8edcbcabd2d2ecf3a6d49b312c1704fafeb1552788cc8120cb639e252c9bcc8c6e71f723c7be2280e6dfe93e543eafd7af67218eaa983f66dfedd47ab1ad22ab202998d8ae0d765c3c6e843706e5084ee0a66ccf10aed65568169359423ca8c6017a18fa0503317dbf770f65da9722942efe916d9efc1d7f6e5cd1d4300f8aab42e102e3fbb7c7188a9491ed396bd4c29b87ff35a1f0c1e20d63093fd93989adba45c430332fd6641298da1ece77d6b286c18c3999c5cdce1f4c9c1fcb07418c90f458b0031de015657460bb6a0589ce6d854c440b22ecb2a66ed4487e8d7bd226df03af120c87777eef84886b651ac251a5c81526a61c6d6d7c8502b870e358458ab32f3ab708c9c6fc78f93b9bcccdc91632882ee37a90040f251b2096a298cd89fa136ddec675cbd326ebeb45368b5c3e923f806c0d2c7d5a4ccd3f3dff55deaefa26fed536eced64c88b623eae82a454f65e432509326abd16ebf108c1e6eb05d4c282c16974a7416a4e0c8d305ed3ecfe2ef916b92d2d8691cdcc191509a4ad983d3ce566aab81722464b069c2e9721834f345f2bd073ff918d5497719fbb510b070b2be77402014d7fdd5346fed40b3c5cc9a5cad71f937b5eb3889148b77a058bf88fe919d68d4125600d603eb933760060515e0f8f7585ea91d620ebea0e42491621a1c08636c761785f7a3050c72709295955a1aa46d2c70f0f7d91650c2625a56d53ca8c31760a2805d66d5c160ba0453bee7a94a9a95adf03eca6f4590dd607ea223de2e4b0bd0e36ed32bcf91346e8320925328cbb349cf562a24d33e9f4d8edec01a1060e7ce7bfce9344ee0acdfd3393f9c8a02cd72bf5ae5f2a1a46ba98e1094ed849f65c1a817abf66d9e80d8f12e35e7a989bb25f58ce791365d3fa289f5a13495f88841dee301694435ceb71a27cb66e4e5d8181733b7e374c14df80e8f806308aab7a7695e54d962488c2158c1617e6e0c65e8802c90065f07c7bb75ca4f339e97eb26df5d3f39b2fe229b10ae7faab1071221b5fe80172e604d72765474f0d60c1b0ba89fa3ff08b9b9bafeebbcadab62d8f7de7debd434d1847d3822eb7642ac28adce61b2c7a435ba30ceef7a60ccd4252185862ec38248863a58f82f64f76c5cb6e19a5f61a39c6abe9cc2ef07dc0d64ea877c8c09eed98cc0405734351082c7bb159ebe5f65bac00a5aef69cd378f56ef087a7a6cea0f795226334236a359ce3db33fb601dbb5f40e0ee84079ca59ff97f21fe264c8b23df061293f8de62d0635bf4c066e750706ceb00be5c810708e08d28cd6fde5ab4ca466bd812af57aa0e892ca2d28e715e0662f3f20c6abf66aa8b2647455dba1f692ae6fe623b086947c26dd77b63055d7eb94b1e015dc6b6e28bce9928d036ac7ead9f018e9b04e7c38705025d6e516f5970c6f73f6d42b086add75203f0568243cf0b2fb49a40c3af3bebd4709e958c756a9cb24406f569374f51e7072dfda7d68b681bf5a643bbe6aafaf33e2d9d775255a062208646181b678b4d46b06e977fc184fab67661abbf02b50cbe47489cac27b83e14b9e0df6fc40b9664db3b21b9026acb711e52f5b5a674b3ab3986108b2f17d84233a6cd340c6a00c0ed466f5fc62193d8ce5a023346e0d052e61583c8fcb66b36ee288baa8abf08d785902fa40c8e82e941346e08689bbee365772398a08c643e10c68e28f1e51da5b9cc2c619e6d1354c9bedeb403879bb6980743c9b8cf0f8d78b47efd347e26575c8bfed48a15e594a61f96e68bddd81b535f92736d2925974fbb9e414af554a23b675c3d1582198704bf2c009fde0bdf88586b7471c034b72250ddae4b0ae91432d67b4df62d2bd9516dcbe5eafa23bc4b3849933747ec53ccfcae61299d0565ba9313a1197fff5afbe3d9b18ca4df275cf533f7cc6c66a7d78ec24381b1078d6813c8467ad5ef4ff67893f4436fda3734b71cd46e4751b65fa0de1418b4683532bb47611048b7e4c49e8c8d972a203e9d0bb796c01e6c63d5b15480cf0244b946e2338f7532ce8058080122a2c5852f950bfe08e49b30f4ebd640055b4838146d2a4321b6f5cf631373aa38f9c5bef12ca24d17491e3ee63ad01434914b57adad21d2a7a7f47261ee814f407f88a7c5bef03d34d86a0a2e3f7a18137e0c2db80fa2f000c5ebfc2a78c1efc16dc8378e63b51df92fe4246d45d9f45e27abc404960743e9f045a22bdc650ee0c609cfa41cfda69c24dbce275c0a856684cf491cb00d8c7e282b0ffb2cefc3f2f2d612d4b4476b75bbf6b2b48254b56afe1e096dcfaa8ee3a9b177c47efae89dbbf8681cdaccc9867a7c9feb7437e1ca8dfcb798a911ed98e28a5debfd595f9dbbdcd678944c80c7b8a878d5091bd005d9c704faf5b3297a25b8bf5984f68e9dabbd3055538fe185618f28dc45558beaff27a86bc861656cae42a3aa58fcce22fe7ede00828ae673d940b5645a087ff9c48d222c8870f6e1ea5ccdabe4fdca1bcf1fde483ff5b4df262ea26f4ff8609e146c687598f18b6a044a01677d7f3af9234244a2fc00a014ad27b169ebfa7a928ba3181cf32a687ab3e70c6f63ba11c8bd46c13b2ef10da0067d95511edffbd302d85a7f33e093579de38285213383f0b9c1943527a98bae234afa3eb5038000964885de13060e437228614c9d6d867c25bdf7a5eb6348bce76c48e784c99da2c04860ccc42030081e09c496f8cd0239750321e6a6a212789fd0f94e64462b74c3d4559bf80f8e8ff448218ed3f5f53d44919d0aa492d8e0e4fa7dbe29d0fea77928d735b9b042d4640d5d5019492120144d72d718f021df87a1e6d7d3ca098744c7c3b2075bc12dd29f707805fe825cdd2d49238c1135f305986335cee0f7a2639669ff36725536701ba76a349b09edcb51843f99be8a957b40dee0f56469ef755a2324f1df07de51bbea555ee801d6e928921f88729a5d9c8b99cd9c4aa9363d53f7977f16070dbe7f55d0e3fc130395431690f190f24b3f1c88d6c6a8683e3481181031a1ddd22d00507a38609d64f0a6ee68804059841960b7044731859eb709d5f4ed8e73e55561adc9145a43daf1fdace77e92e80c6a2011592217750782d42669130f8f991c9943526d07ac0671fbaf9217226c9553c33ba59e551fe895d48c660ca9790ef410cb6d1dcda91b1c8395e2e7e69e63c8d7deea8337a37c97c9c0ae98fc1442ec77876203c09cfb4f29a1d2f9430df83191d665abd59d2679a511ed616bff58ff364c83a1fe646549b51d00f7db5b1508d857ff7fddc8ef895b51d59fb88c08966a93693fcdf306ddc1023d83d2c249a050f0ee9b936fee03caf7f350ad44654c7b61178c63451447b04b926d84b760f6962a86ba48b7a21f5cf1d08f0e3250619e3d5223b34d0c0db91533d24a835147ebb44fd372c0f82e0eb13e51ee7d1e98d27bdc167e7f71dcffdcb54ce8630ac8cc55f4f8108a7d2feb39f7adedff5f02d3dd34c21eef626a1b1ef5af2e312ccdbd989a060ae4903cfe1489dc02f9b63955d8547a2e65de5e8563a7b569dabf4f6e07678f28563f8f72cb2c63b75f9c3ecf8eeeda5de579b8646af9fc5d7b278ae5ecb1a9ebe2d0b67123d447390b043b88124975fef9122b011b9dc6279dd19d653f4a2bd4aef0f57203a7b76bef1695a52b3da1559ffe16a0d96c420653d6be674694c7c73a5918ebc6bed0a9c6e1ae100c08922f93c86ccdb80d879b3c4ec86f31640bdfdb4f7123a98d586e7c74234439f5ccecaaa1180c2206c72bbd8c2c403cf2a731a2e7329be5f71408dbbb241c5b36829d70363ccb14ab3cc328688ee04199a0d5bfcb135748f99fcf0c49061631b5e90cc7e519654ae53509d5a48f2aebb60fea0431736ec5395b6ccac7ebd1b98a85173970225ce7a7b27fe415754b8f43d0cd4480b7a6860ab0638c68051809cf722f9c664d8c2b9caacbdd92fc79347032b2d640389073890cbbf0d267226d39f07a5a1f8eaddb8a3d5624beefbc2642b3fa7684b0fcf8f8aadabe5690841044ce5732456dc5a37180f530fb899a42f9ee5a4a7156f25a9ed4d7de799f08fedc68a62f7db5cc2957aff473cf465ab0d1dd37b43fffeb210b0e7b3147cd0b73a9e9d6a25c7460db8ba054b9813f3f5fd5eb10e6b9de270edcea6100e4e76514db7bdf6993df49fda5d5aaf378872be4b579eab3247eaef1a3b509a9a8abab696dd2d72c090fa31ed9ec7d608a85401e1985eec70b69b0bebb6842774b7c36dbd74d61d6ce7bcc1e988e6e07ae21281e75db2013fc58872d7b3b067bafb9f6a6934ba4613b134d599295bb73d0e38a74c8de61cbe546e5767788c769228d7d7a09d3b155938ab1e904cb2134712db20b0e2d01838e9c1c827ee4b2cd4adb1e90f92e62044a4de7230b5eea9cc444fee032a70d730f20aa028e1a6cb43c8c33d22a622faa5f30187cdea9782bcf49b1fb70117d42bac3627479b310ee0dc03d89ba6865e264f958adae1bba32791977d87b36c159e45b3249190bf15adecc14620a8996ff0f3a7f8a933e57bae3ed8d892b3c34da5b827c399d797178fc4d13ef1837800c914beda6ec2457b813ac02e66b06f3c1eda576da94bfeb219ab99cd3dd7b3674c5472674d37e4d0e4b4505f25e20b2995d08b20262da179a2f6ccd9b32ee4a40668a80650dcf871445f898d1010cbc351cfb35da88ac64832c8758f6d643d6e84521eacf9e3506cadaf5c12e2bc97606c99d7f018d4804400a7058f2bad4c56ba09ac2d9a30038e06b194c005559afb294be1e4dfd98e839e2a98e91af43ad1540a8703bbb87ce58c6444502847943e661c37b61b9b6bad4951594720be54003eb27da188897ae1e8ac94cce6484301098f961e8c88f7d0607232c901ff9d2189c110fc9767eb28575bafafab156b015680e4200fb5810f2d4b2840185e5e9e3332173b3f619d365dee4ceeab0838f9c9c70e2ae9969a7a2dea9b7f808956e3436953c44963fe2b6e80cee8b72cc422a1ffec208c515bc3cc1f06bb92ecfcc4d008565d71f0dbec87b5759b3603718e9e34a3e2f3a74b44b75d6da6d45699f39cfcadaf856a4091801c024ddfe27c4a273cafebfee8520da481951f77689b512bf85498bb2d7fa8c318e417d167480c682a2a69e85318e53485488d274b7cffefe7f5a0d4d5978174e92e2b1cdc5be4132ea0cc81e589995f202301ddd5ac95309e2a7d841e4b8e86dcfe55f60cae4ab0e5d4305ffbabb42b588b187adbc26bf855f8c0eeaa0101d160d54e314c7335a94a19bef76f78b6ba5f9084dcf581432324a8ee24cd8826bd00cc6104bac7bf9fcf62cbc7644b4d8eb85d58e349e92b7ed4bc24fa98f01d1b841ba30bccf0e8e3155aad86d68af4ebb1639d00dbb2b591522f140e9a71786b2ab90a0dca5e2263f76f44fafec10e5c6fc4eade76b1547f5c4e00695e7a08a94d9075610c60afca7a45225be0a00b5b95bf393ab248e173739ede625857ac6141aa953e3244432759b5f815acb8e82e4a797f4a9493cf6eb1fcc0aa77de80e23b09db03173244e219837b25bf3b2228e03e389750a0ad6a151acab4d86799e97a2d3bcc7448eadb3240a7108e5cadda2a1c9c32f95429cd3cbbf162e76537675306ed612c20a208aca15f66305a381fe212d1beb4528f0c61a5c7638713222c156c64eb1c8da9469472ebdfdf78f896dfecb0d3faf9a4c1954f8f56bdfc1b0b29b33f5c566c4e0429fcb7520395b78df2f8ac7cc6a99f45c284902cdcc9d8677eb89739510306dc2591043ce40ff7431322a546163ad55d95e64a52fe208029349e768f5700d2c070bb996a7420389f00c21b05a43081aa7e8b31839da05f92b29cc139108ab24fa3fd2ada62fceef6dd11e94370cb3f8c28baceb83768ef26d0678372bcaf2f93a69765651cd59d895f510dc085b9119da1485bb6c2ad8223bddab88e3a613a89fdc58eb7f69783fe248545c09ba01ae06c83432cc2fead8ac6ddd28ba0ab913338f4f5cf5a242f636e771e1ff7a0d89b8213fdffccc50a8efdbe12915640085291a0d031dbe7c518d3d33d060fc4047cf2fdf35c32f1d0a90e0bd1fb0e49549020b094600f81306d2b32e2a18128292db53d20c4c258ae38730a9cd871c78be5500dda036443b9174ed0da125bc757f2e87f0b358e7290d946d25dfa33f789e2fe499697719c9bf6df716724d139e131ebd620b950bda7c20391483d55ebd2cfb8e0c8280482db85ae255d0e661887b622739ee264e34e4239b0c35c1da5597b37cb328d5180512a9ed4e4279e46286a3aac49b8333e3e74212d1bbad51f33229be9e896a80c49d12ed62325e19d5ffc85e1e27ef993754f9e4b367ee448369b2a94ba6fd6892ce71fbdf4d0ec56196e1082715a81fe10aa34e4b2f7fc26fe8cf2c2d2044ee008dcd54a0653cc672aad71fca17aaa0e6d8a604d7cb9aaf4f2e6c41f0b70b0f55b581b34b26b45d4eba4479bfddf5ee7d3b80b2ce547443aa59ffbab54bfd9cba0b7627a01c4d7654810cd2f1763ac59bac2c44937316de6c84909581c7d15a69abe0ea35e690b46e8a74dcaed1bef64098bfb505aba4fb6eb941767fdeb5410d9bc074e45c4783f561f9d45b2b9485284b74e6943b0f29b1bfc5f780bad6c621ef5d6c36df520894ffa1c31489294322397f05964a6c03ce75fe751f61aa1177b63629b8d5c6a60501f73e3c69e9498d871d194f5aecd705eb025312a908df330c579302c1f1a029cc502b79464054f874e503dd2f81ce6d8a86e85989c97263aed68e89dad48a7f9ff5e6fd4b570641a81bc81a40198bd11214aa4a452506c76fa96cca8ddd0e422eea2f0429b53116becc7e0406053b27fb23ba5544d72790453af2e0fae872f6825f697be96acfa1dfddd2c99005ca982e2a2acd96185688b991fec222adc0bb918d4f982896f26f99098acb7b7c94ae8291099d20b03dd9f2a7507163afb85874d6a9e91d02f40f1247c8578d9a21e7a1254e8301af5f6d347be6369149509e7cd8fad5f5265c8dd48c9415648a6cddf9d82ea708bd25a413985eb691d410b5492613ef8acaec644cd008691a7494fb97274f756a3d8951f20712672bd53e2adce5595b1ffb055d5de446df7eaf1de3defaeb1b9f531a3b81afa5ac5ba21a21c7db77460a701d16f38dd982d6e1ea266222e75d2c2e50ce25e48a71ef903005f036b7c65dc79e21dfdb0bc044a824672ff85003113e990b4ff1388bd1bb9a9c5e9d57523be1b2dc2a7ba0dde8d0d8f1e0bb83733f93f409d79a6622481a2d06e1019a0d21dd5a3200ed99224ffbc3c1374fa1386f4b0c35fd4a2b273865e67879b24b5f07ea9cfdd1d31f46c9488f36b731c7607a3b05614490fa5e7cb423644fc68bf976cc3ef020e6a0646056e30a287e217d7b2427d848f297fae42246826e793e7b5adb75fc9bac14a73634747e63a1a69a8c0f3c0769396a1f8987f65a4041b6aa8216f7ad95d6fe0e81ae4da513d85cad1ed2a4ff609976975bf86aa89f574ef1780aed22e37fd8f9dad8a349f35dc1e00955b435a859dd6cfe7e976d33cc9b19541ce6b3039d843e6cb7d304fcdec722074b8dcb0ca9da3df5ef25c4eabf1e2cda70e6f3953be9cd2ffee43cbdc8c52733ec6bebdd9e89ab648b2e4e6a409bf34119ec2b313829a7b20b92a8efd98c0400534f87bfbcf562c29504515218e88a114141b2b6fd476461a6ebce6b56b3bedc4ce9173596e7e607ce0377aff7702dcb1ea199b929491aa19b948f4bb2e6027c0fbce7166dbc9add1944911e670199d3391d2abdc7e89a6f28018b66fd335062acefe630ba72ef6d66b12f59e626f157111cb14f0cca8a85e0ae07cd2cc0e8968aa2892508751e1dd0c0a9ee5b2710432e365051e9742fd3286684fe5dfe5c6d652b48c9d521fa82d94e804cfb5eb41e02532527a7704417de873034731027b262498c15448012251bcd42e9c9f7a96a5b86eeac0eab83598e88c920e7a281420817b734dbae9833286996d37dc3fe46fd2dde311cda7226ae37e581abc80a86f76d3b69051a1ea2c2ad2dd96b27f3b2e98b1b66f5fd999bf965077722ee3df254d042179a0664e8b7ad6e85029b436753f2cba3b1ee8e13e02a196b2f9c340bf46916b82b03d8a0357d6e95e8ab23559f9001037a7cac548d3eab0040627135f7071dfece4435942d01339f5f20487a646d8bc9a92dd7c796fbce99726b173dd6bf4d18a5403a720df12997b65db48c10a9e878405ff22d144a3dc1f783e5e61a2796e2f5cfc05aaf0afaf55d82b1ac06a25f981cf6263beecef9c314fdcfa95ecc2dc016fa0052b92e7a51e7b18b1f82f8c3b5abb73e4afd9e50fb7b8a322d316d22bc5cfeedd99c7778131bfd3dfbf3b193cc1c699eb79f82fe6393a48b18a2636efcce2fcc1c95fa7e5dc8499c668c5691f40e5f0ab8cb804ac6d911893f71fbe4784f69ec55f82db48955a3952e061c19901bf2d6e55bccb5d969540fbdce9e183a3bc3a7207b498d61bb4bf4aca1c4f58004410d57e646e1a0dafba2a5683517cb3aa95aa1a9453efacbef924f4f836c48a694400ab610ab6915edaf071ac310f5632010b32727171bc48d6ec998e0a6d1077f438dd4ce8782bf0dd51b83135e93bfa45662921708e424dc521ef2fb2ddb8ea7d60a52cd039802e19af550a1991da178844fcac9459c8811831c9650d385fc749ffcc05c798c79cd56f15b2a2fecc7208f05083df91edba6869179b07a063044c0265353b611ffe9221185d9cd844928e38ad34c7ce8c43958bfd1501a3933120b67a59428079a8a9f81324376495b9a583bb5adddd4b17092a8b8b514214b845855bb7baa2ad1d82f4884ac9cb355a70b95f54086387076aacbe47d87284424bf4f54d70ae0e7892532064483d343eaf0fb3234e6502020a44455ec0ee328f53926830b7c6b072316e096f9328f943056c3c727b089ad01984e39533f9fb3dcb0787dc1647a9dcdcbb6d881e48b320fbaf080f4b1eed15580b21bcfd6728871d9a9d7e7c8a60fed7e9e08b2938f2d0a3770aab8286e6588a2d42d0431298274b2185341e306d6c87856e81646c32ddd321de2dc10b65eee6bbed0b00d04c3649cdc2200d7959e126dfd488344a1baf659e5edebbcc471a3da18c0e57d4ab918f67eae9b9dfaa3a54c3da8fc3e66006525c2dde66156983963d3ed978e9e771a0c6ebb23c4b77a8a2a1e282a79141a7128726605f144d8cf8d03c38d5e3933b4fda7bd5248cd5175916da6dffaeef3e801972e6fef3a0d9dcd3dea073e3f76bf95b7121d410b8ad34050fdffb9ebb64279dd032a83c24fb6c502c6e05e0ed343a6987ccaa80595c5b317472f15bfb0bc99073767739cb6622cec8814ef85318d0338170634edbe58610e1f35b9841488472a0505dbf5788253bd1c9bd82ae437f71631201a0878a0687ee905e6c5e01d9caa8e6db82a5e7c74f2894fcd792cfc6204d7db5a2116a26dd056bab0655b80eea29770ed84fe31e5c056e5e73d9c6ed9f15da690785ae411282a4ef166a03a0c1f143510b99d68695782e7d276b1bea166de300c9f58170e83728b2767cbc730ac84992a7c7d839d1606c0955f1cef12087b90c25208ba821be4c860b49be065aeea0957838e7fe799c0e7058e830000789dbe11dc6d9a9ad92c67d32ff9bf162cf9fb7f2aa9a879636f27f8cf4adf143705864dd7fcb3d74a5f4f8fa93cfe56098437eef6904c41e0fcb7291c57f5ae6374db0efd21b146c25b0350de8dd7f6134c5d10a2e6d6ae202c2017b8a9fd65081e5d2b67c7bc6c3f1362fea057fbe2d705769b56b79803764b626d04165bf062c2f15e64881ec7a56687e129fd418b0a6e9cea6ff5b446a59b84f55493ae7377c1698a1d79e5a466b7d50fbcdc2a83deb9e0eda0689e5a3f134558bcb40b1c106003c50a1a42db45a990e8a47468de4f64a0267415c6ae1bbeb157a5bd601f27a66f992cff0819122942bc8068bd0d4981b7ce4dfd47018d7d4bd1faf37da7b53a7cd29a0745e2295dcaa8291ea8552ba65d96329ee0b1d5df2cb418dcae3f5cb5e28b26c5e6e91c4376089a61bf0dcce0234c6de3cb1e391dd96681fde01b41bb6aae538db601760db11e21dcf1496c7d40a7f26ad793fe64f73c2dc9391dbfd4cd4179b17bffd5277348cec266eae4107abf31dca9590142ada41696aaac1ab40e6774b91607d0bd64549c610af333f5a9ca5e718b12432d028b39cbf62f3470a6f24953dac05520bffefaf73a7eb29f8c588efa82b210c7efde04a4736515521c8d8967a19073650719be71d34e8072948ed6da9c5a0832b77a383569edad723b229a334d423707678eaaa49a5017c7163a7b5e8e430e117a881920b95dd04e36a71d92a96510d921508173c28894f8cc93134f03429e60359d7b1b5972d8b5b60fda6b32e79a64082151b8f3034ab5b0fce754fd6cadd792b426a9a5fd7b2cfe6bdcd9668a5fc43f1bb4d783de06d300f7162570b0bfb98c4085eaad11316c909173e62584468e4b88a4036aecb6231a52445578fa57910134aa666d2b304b790993ee1e3b394af9f19f2e754df464337fe1888bc8312c67c8e2c7f9c94afac515e0193fedb3230fbe1f618fb5662fa338d8ca2be084ec8a54af1a8e85ba8541ae67ae33df96189192f3beeac329411cd0211682385df1b4de4e30fc96d9b7391a026704bd438b19e47e3fd97a5956fd24320912cd52dbb0ce4dfb7f073d70079aa0a96cd69772568144135ac5cafe4b9ae06542ef3a1ab2544434132af2d064ba9059d38f4870280a6605be0b3eb004c1f8022a26fec1dade555aab36f6dc63057ff4fc5399564d334c07fa340e481bca755cb4da82d509779f46c45af408b268c41ac908e0907614ee612e1a3ff6377e18c6c99e16816a7c00363e1b71a006e99e0b6686775ce03e200de3cfd05442d572cf89cd1f05dec3570ae5169495f3d59478b10c7d96012d5c8506a0ed6614e735696143360fd7d5545208cd3c9f72bc751d6d7337f00f05ae5d0376e717585373b7a4c81ec338678ac217bfc4e0dd6aaa0a2ed69341d92e3a9b59dd4aa3c87eec53ed4af2e052243e5a58c1b1415baf426ff38d484a77040a5bfcd6218ed5e779b6c624d11e935d0d7e218a8f5c91b47596959ef9f1aded4a77da156eb22b063b94544d700b5b288531c5e51820a291eff0c896812506c4af83797fb97997b403bf8a0201042e3422bafca099fe5397818c11f1e51aa60f84c77640930d5e7c707ca081d46d4685468671d2e9155c09e62c92e3f0bbc70fae59aae7764f38f3916e7894c4583dccd2dcbe45c922f757493bf93cbfd84fd32d7e47c8ffa0e5b801010a10ed33dfe0541b353d78ce06a59bd19854c2bd4fec893b37edbee20567dfb2595ec49bca012","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
