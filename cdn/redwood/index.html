<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7c794c8fe82e0966cc4aed9d7203c67fb4b6cbed13ff3de49bbd5bd4d1d24d7f4f09149dd13b06077659227c8c9dd73083c43bb6a53b46cae389440d2416f26cac4bc3e12831a4b1ee3e5693fb379bc23051b348b7b84cc82ae1db71d631959b373e411db678c3cd8c03b6e29a536984cbb5030163bbb22749450d70159b397bcfde461a7862a1d5c05505f01e5df2c7525c512775a0605d9c6505ff430564cdbca1d144f3e9021c8c1e628c788c8d522fa06f801a8eb2f68f30ce949645b416d667960efdd4e04fa80dd836edf8a7d9a5a578e1558b996b622de9bf7e742ab02288a6aa0009e11f213f04f77d12693c01086f7b1dc2f26272ab36c52e8be799c8bc1034b8484de5bf9ce38c6e2200d4f892d390689ab9da418ea60ec75658907a69c20274dc016f203c91d3170e595aa7693600e71e37976bb3906f92b1a5befd0209cdb428feb3582c750d4a4fc00103a1643c98cc5602fd061f12715f05a1de2dac38a3acda56e013532e9e412e07b38fb5c8051e1c7b5cbd1df1123d056c171ae52855ad607fcab24ac32f8a09e43f6b48b23bc188bf9824a5ed14ea4c5cd5dfcb2514b05d51bb0b54661f9fddd1c7296fad6199801a8cf2b7d8a24687376a8af01b42a375a00636993fed62d31f7fff849c8f4505b95167d97b1df4f66c5cbfa496ae6861a63096099ad764b23440f48cd44905d9c2751a80a89d2e3afbe35a2f8c4bfb51f59b7f4ed7b9de53a59f3fdbb477cd49ff8f56d09c546b19c773c56d29048f701e8b5f827fc1b87935839d2967a3478c22853047df84a2a0c0032c67ad948dc7fa955e692b822826f11f29508d6c6f03ce4ea485e0ec935c2fc56b8f9cacc8c8fbf8adb198a1484605fcdb546979ee2fc7e3cd93758cda3c3d8ab9a8b1ff0af7baf3068ba01590ad7a872d0ebd7b3bef182fec74dd3e060d56529d952338d3233456a0263fe8061e9d4713e4b73ff2860e8ac22f670f7aa0a53802202f68e853b6a91dc621b0ae08747f0d5cd055b3a6f482ea10904bb9a8dd1438441a416e89192f45c1b9a16a56523173d48f3f82924628c9d6cc2a334869a02da5f742336dee0c68ab5cfce35148758e5c047d65647723b8c6f888fb6b6bbcb7b157de89e418a5773b7488cc97286b9c445e23284b93f1ab23474460522ff24ccce3e5c86f89d6dc4a3424bc9c95ad69dea445beca4399c10982e441a00c9e035a046872bfc854b1eaff5e3d8943a7cf20ab8b7c3873b25a70a33dc0c3a0125f16b816c9ab1258ba63eb5d7e88f4200acc3da90b4a46df82e011f552358e233b65de43a795ad88155e4aeb2606b09e86c67c6cc363b2945444c6dc69db1db605935d98d392401391ac6f0fda644c7a1e814213be50eb942a7470e4c4961e3df61b2ff8c25c6eca0636e27816146bf65b78510e282adfe3245cd461f10b66c0f360fc8a50e630ad317fc28bd575e095ddfb23136ff423b066cdbc0b9ac5b12ff5a312053bbed8b0a013f0b488823da0d853b4ef6f1f2d665be2d0e855a475fe7785314b8d9bd4332927893293a2f8a2586440222c9b1e658aa4203e9ae3fab095d01c3a9ceb15adbfa03b62b52e77bf119cea6e85389db67a91ade158b71bd455dbd6f58cb57e26fd004b06df6c55b5e7d0bcde1c2df11956e023fd8d6bf2d63892973fb80d261b74f85c01db7e15e0ece763a94346c27120a4e0b256151483a3f97501aef38b73d33d3fe2f1d3f079c978766e91962966de13054cf2af4be6f9d5aa72cd8043b6a4516dd6bd2e6dc8b549697242d7749d88d4a623a249df389c3e9dda3f803e6d3cb3267b28d7704e2c42bbcd6f4c7a06f7b1e6b04bba07133a08aabf0ab93a60b2c6e281595a9e538f60599ec29a21271377868a2ab47940fe4a336d67de6e0182ad205668182e637698325edc33d4479a3f44f1e645db89e387a53943fd511450640c95d644a1a0982aee2162074429a8cbcc5b2e84e5a70fb08c421cce85074ce8e892c63a46f5ca234403867f349e03ed86fe2d73ba9d4c279244d2b1160103ac7f72fd7bdc18b402a193808b4481976dc033c38de2cbc8878a520f42bd375c55d3f453ee1b0de45a2e7d42af48cf280c8f5825e77b3263b07d499244c0f8c59e1f6c77a4bc13431b476666235506f5476e46ace5327a80964e9d5be69efae61c03b4b39cd8c9a84bba502d9b5181df3116248b69f74f1d0b3829d661dd99986110b53e907b6af0d74e3a5629f44abb4d55077f166be789be1b2df94aa2cab89e25f4565390e049feab5faa4f4ae579a3a8aabaac4447f3edc7590fd32e8b1f62fcfff0129210b01a048949e3215da2cfcc16126db749139dc9267f67db999d5f64cc95d262a6356e9117d4fd294563c374a373860bf3ef6df0dac527b14ec38c695931c263c7e6cb6cbe0d1ccf86f0a5a08e3622bce64a6b4ff205639a5d4cedfe537c5ea984d4af9f0f2a6394749046a6ae0bc93364c4f6fda9ccc9fcea1015da68fe4e0ca5fb020ff860299a2b07d224a5c791aed167c6de940834a52af58ddfe99af2fdf8d5f608a2eb51b458b7f815bda41fbd0453baa536d42a0ccdb3a710532ed66b2f3dc934358993d8f97a1a8db55719485b8db26abf0cce46e5f6a9f470f380c8763e7a9461b4cdbd46e7cd9ccb47b324df8a0215f3929882bbf2dd15f58bad06f9c0508fa64c3b0f914d7b68f4fb64f498006a08656682fb8149105a12613347e0d1873e4bb0be10fed0557a0a1858e477e7f87cc582245bec756ba1aef37fe6d03fc4d925b8a68ff0f7a9a47ac1df222d8906ccafc65905a958c090f5c2cfbebb66376a9309c5e5b3c681be314b2a32c0e30410454104c4510a8a856dc6bbec314451718bf8c6750b9cca40885c22c300aab2e6e073653d3a9ec32c65cb686c5d32bc5050906631f6d393d0b419cfb9bd9edd75707d346fa97bae68137e83f0c6bbae8077d2a64986b4f344c641dcee9dbfe701ce4bdb0222ddf825b4a9d7f2b3a8deda8264f18102c1fe3d35d26279f714547aa5e22645ac761c3a1ec1664ad45c03307664c898774404601fdfa9ccd0e6c4c7d4f4ece59e32da2b4271ab6e963c571fd52f87db0aeb8a8debadc5f5a8c6ce7c8e3366dee9cea17598dcc6e800bea6b169a226970e3f22d64318478cc193e79e60cf67fb9571bd802e7d245c240311ad1857b807b56a20dad5d28566a369ecd54338de75b967846c91bdd34e7f467079c5f1ed504a75ba573fe0cdba0b7834325a2c5c194f3f923119c1c053d58a40a4de618560b8ef10e49de60fdd865330b289c6a48af134dd8ad329304bd67cd3c5088f368e11c3edeef0ac2cfb08fe09776016a90bed01d4e2241abb53c41f863e0c5d4a9ea9610e226633b963608ce8c9075108b0bc56054310c3b7c400bdce5420cb3a2090e9c5b8d55999ef25ea435d622be3a6fe717d4cf377f446c3218c4117204f96f171842b86b19702968e5bb902c33be3adadf877e54210073d0e11ee06dbfb38bcdb174c6157dfca4fc437958947db54cd05819842c4a04a48f096a8a831e6ff1c3b8842b436aa602b5bb38ef08d34ca0acdc15f4e475a86d644e26fa2d803b699db8446f1ed28a0a886af15fe3252e688bea1836e92df08d139cf55997f358fc4ce6ff881f9d01e0540eb2407c64ddc0560022d3aec9fbb3e67bf08fea5f63be362d7e65af6e5cf15b942cfd262ff4c82378ddf91425aaba798b21d1b2d1e341728c76d382b06c44cf1b489ba801dfad741d0200f97a9ad4bcb93d9262f5a9a7b48c9fd3cfd7143e90469241ce2ebd7cbf601717835a43547afa45e338985382d6d6a3fdb89b9c15232e1f2053c9e137a2d5ec08deac094617fd3e12cd7e34521cb9f44b61a72c33980e1c44485f1e6e185fe730d2d07f8fc0fda5026c89a4012083d769174ace7fb44fec766750a67719a54be54c3cc93b89d8a3c9acba43155a36fed5c537bd9abfc9d35605822a2eb2afb32c35a99afe106f20c376ba93a5c11caa588ff3e296fc0aeb4597c35ab6f74863de82167b71de8da29b23b40fc2a963e7360880b1dd6b605c7136291f40d8e6122ba8ea9d08c9ef4b60d7cdb9fe8a3b715ebe7d20f7dc1c9ddfb799969abe11540b9fc0dd62e6e790b033fa5a5d4fff19d7b6dade720d45e9e08758cb443dead60fd92d83557b17d4d94e9461a9ad8dd765fd06a2f09d180b321ff6f93ff12c0ea355c7fdf7c85b92ac3748943eb98ba6e1c496076ba15cdcbad41761edfd8937bd6364bf607f4a4d9a830598a279b276c88e480a0a43b3983e030d2c10c1dcd87cffa5c0c23ba3bfdf7701a23d78aadceb8aed2de4a311ae2bf77bcef6c3edab71b951c4a0ab2d498f1f7aae8f37a832131a668011a0e8feebe1592718252ae31d329a6192bf82159b83fda8e4cff7e6661263ada4acae9183a9f029bcd60661bb85b719375dcae5315389e802872441e92c7746e3ea07e40e7852af45e795d1c3622f57a2d2714b9bacfe76c69c5591dcaff06942e540b190e1267e50f5b78156aa7cbe98c6b5cd5501a1fa4272a2a8ad4cf2b5033760e1a3a35e24c70c32d0175046764ce2e5e59d99ba13f05c50038893a7273f5736e31039c2b349f76c31ea0c13f5b55a27caa5b12fa0e1382fff034fba616c7fec08005f1f922e58910c992a35fbbbca8de6dfc8594dee27b3b62645e76d7409e9ace2fc090245f5ca79e57182134550ec91bdb31c427fc1f6d27b66b3b989f58489c78820ec619879bce517714ef660d398f87eab2f223bfd6130a340d9747ef685d8c40ae789ff89605dd94c5247c3d7acdf207f8fd29698dab0eaa3a0063dbac57f8f029b997e6b69b074732e5d4f639ab28d46899c88d0520c6197baf032da4863d89f7dc38015d3cd6c2fc0675a9a3a90a435efc0671cd823fd885e39db40a45d407e640e53c32f20b6924f56a9213c5acdd052e72f777d7f56fe6e0fd6fc65a0a184daf22411d3c4a26509aa9c06ef27e35e178d4efa3b989cfd3a21bca005d08aaf7767bc4aa91952570fe0b227a1fbdec5547eb310bbc94b9eb734967a6de5bcccdb32b760633f1fe04aea6abcc6c6d3e4f78c534a2badf14433d8b3aa0560202dd117e09f5d2194679b935aabcb808e22d49bbc7e17c171b01bf238ddd944fb5776dacd4145ae7b36b968d59b182f4cf010d923292033076e6b249eafd4837983800b68705f673b79a0e512cd7d2ce3f1a43c075ce02902068689995a1013c50b51af86a9f90da756d91908261d13a51974d81081a2a79606c8314062545580b3f79b879a7dcffd637c5ad60e48951a5a2059a76fa1c87f46a6d695cd37b03c6784dd6ceaa95254fb25ca7ad051901bbe6c18cf7ee6ef343e409828b37132289f6eaaa3322d32c506845462e9b16fe041165c59aace9aa1c3377161f508bfe93a173446da67e69b6b7dcfd7e8113d197250a3eef5f74d13efe5c351adebf1f8c6d597f5f86396e0c8b413ec39460014ecfc395e17ab896244010ad91a402d023e55cb4f3469a23a002ea0603c1fc7d14ba6e7b0f11808b1a2a49e82586b27d392066b2df442e145c00245678ea21b4ad430b523db97f369f6bbfe9ed4d82a1b61847d99f82fba7925a6553e9c32da7be4906701709d019b8fba924b66c5e0c45a0eae1aec97fc5e8398bfdccecd67b96f1fc108256f9075a3a7e2e329b6d22c665969a9e9a7410b91dc33c4d785c3bf795d56dc23e68d308f52344dd4efe66f96987d6a32d79d691ed43b5e8119b45ef31c6f79159ed83c3ab4c6f5d94f36c2d41f542abc226a1c71d6e8936846c54c082f5dd1c84f4f206af10cf789fd37e99a7a83ac4d7934c0979506ec305b1f8d237b47af0c9f84cf5fd00ef074e4f869cd11851a9f264174f3eca744b790a099cb6e652b414465e77cac6e54d69302e769362258a501e6290beb0242a39c78cf1466a00c60565cc9dc910397fb43ecb7cdf97ae30513c5dddd9ba5b1d02cb65124bc643cb30252c937b62c079671455bedcfa2100f0e5b1ffcae3088d520ae060152b6c82950406c4b8fb9ca1e28874f6dc65899413e6e2a406b3fec2ec42bcbb63ccb7c0f1f0e2f24dcb6400f9b051c6f650a8b4c8c60ddd468f311e93af0ce4f5f5b643cbf779c01bcc903f872cd88e873ae710d1e56f8e921fef08df8811c429d7678af1cd987e4b84bd0ec73b8b0beb344e65e6cf71be3c1271cd4432c6dc14956f5cd3284b7c08983c4778855cab4aba4b5ea76b640a4f0e243f9ff466fc3bf83749e80a63d4fb9cd4982997b22bb32b54996054c6e98853fc6580e9a9c9d1898b620585eb22fce8cc5006f4ee503d8e4d09b06588bce24823c7fdcfc68dfacef7ba530caf2401c0ed0ef1f5534cb7fbfc9e5404e9265b234193c4034ecc19d7942451cc10a091879a8ce9e7d4a5cdd676ed71e5d1d32fbe3c0a6011a5ea013a271819e2ab2a6724786b02639cf27d82ac9a8459d5142b2ca4382dfcb1818964bb1fe3c8101e887403f9cb9b85c6d506902ed5356bcae30b18425a148be015319cfed9ca01a5c1121a816125a21b14c972aa01f582e42d858ba8b373e82c5be1e37b9b5cbe78064f675c29142a80ea9cd513231c29a05124490f253b2cfc6259a1e46fc78b6c8cfcd31c7dec25abaa12b980e6a9497cc623f8fc299ddb1e6a8a8eb60e79ee33f0f61da0322d14a6e9619e455da1a052d3a43ea6693704ee4e67ff67a1f5d91f1ad8b688757c18bf9a7711f545aa1d87560589519dbe144c282fa79393cd9884b140a54b30a2490003199cebaf5dc859f06138dccc05b15cc9d279b044ac7d62a8757844a97031e22c1e94b6b0e694ad2c8aa71fd264bd61d83ae9c3dcd0c8477ea19e54449666f3c1a49b175eda4ed981cc9cc8199b85cf6d2e7b14dd27b443d60f15b9617a2fa1a28f101bfd4ccffe96bb9bb408491e4491d739c50467db43a1b8221efedaafaef3285bdeb7b8672bd90aba97d55f1a53b707421f17976789fd5ad0cf0fa5e24da6e0be0c0901f031733d87b3031ac787449f67dd52be3344a711055aa8ec0e7a41dc86f81957181e1853d2403c8554713bc4f14ed76a8c98ae4f59ea093b23282633ba96aa2d167f11359fbdf6ff69ea9d68d25371151b26f40c09b235e1469dd03ab6d5df34ac1e7712bc08cf401694c62a9d7a929bcd2fb879fa0d738fbaeae04d6db5cecc22904ac128fe229147a66c32613b6b898b3de3ccae320d74ecdb761ba17f8d1d8f5ba0875f2f525f91ae81c160c657cb38a2205250f5e677c728c1a38f721e2a4ec6d550a1579fefcdff50d5c5ec3e426ea07d3ceb42727845f11529ebff0697ba4f7d2dbd46fecf3252d74c7a32cc2fcd43fcfdcb6a5049e23ff0ee1ad1db413d8af14219e7c5ec9152b19471925993398860dac51d5e2e01cc5bf5d9f607b10a9b58995243b1b1bce7bb7f836e1b4c058b0bc61fb8895ef2a5e2426c508ed6b0fe388235a33fcf075af6ce07b5748ce1f2caddd3a7abd004621fcc960f50f5b09da353ed999e60b773aecd023b04a741cf3fe248402765b0ef8b6b86448a7c43d77ccf99a1641212d2f19e400c6379175354018f4f8c7faa2c96e2f1d0eeef051d04c7165fc48475523d8fbc79a54a3b858c159a8dd61d6c72af4e14758677912a42aaf3fb2fc81df9133dcfb7c13d288597b195aecdc3db7950a4bca554b24c8712b2349ce9a0d45f512b15ed666bc14645da78af57cd1a5c5e5f7194ff3dda1b9e31406f20da0e4dedefd2631240064a4c8e5752fd0c321f9b9b7207a850f786d23ddd7a8bf0b5fbb4ec9af71a2c499184de114351512ece99eaec1b7d99d35b377a3abfd65bce09d5c1cd6ae08a5f5355af5a9e9b77d79f8eac80800f8be9d4e2e45f340dd6af9dcc57cf41ae74fb5a9d5126aadc519aa1f1644acd67c07b4933a5a82483e5ddefbb9fcc4c07273610c8ba804fa86d4d36807cdc428326002c885533ef6f8478a0e795d4de6321050e5529ab4c4e725e3b4efa665de263036ecd4caec23983534ae246e400b38e70ea33ce4b630819be3d2742348d5d4318b0db3f476f300429aca80ddb3f2056c2137a12e218e4ab2e3e1c1d0c74da1fa8f56047170752fa3c47bbd1d9a461d497d119d5b9aa5ebb9ceff7cbd2396879755510fa9005b9f11f84924cc7bcfcfe1b80b9336f00c0f9164d7e993644a5e7780380ac3bdf1d980c0124cd958379d0e831e65e1d37642e2a5269f01c31f4086929dc217ac9eed594ed9257a55448ee53af36c03cf2f33154eba45bc78260165c4af8b4b093b3edd023b7cd7724b7552237d8603d31f05275337606d627ef15917fd03fce7121dc3c09e11e3e524bad612ce7b6914d9a2c8168d5a2a8925d5cac255de3952fe736eed7fd563dfb07d359e0aa4f296560482397fd9a291c21529923a02b972a0fbf72e2aee20d9c88358dfac894cbbe9d5503391ce457e8a0b89da88b1105a92554ea6d6aa5c1c92dae691a617e630c2d8fcfe222367088dd1c7a9314ca4dcc9b5994af7e502a994e1b99014f521cea99c2e985d70b1ac0ddf00f327741ea189043880614bbc2b170315c8ed1ee3184d1a9a629ceac868b3cfebcf39b88bb2964fe1a1b5cc76bf966bd33a9b66ae9edb8c9f8a23a4b2d8c45358dda9b3c5818000582e7670b4e51aae00e3df3d3866322753429716a898982a72d1fcbc1fc5e10aaa98679e47cc359124500e2d02014c8d04ab6d5235389563048a1f9ebd866d799fec40434af4ca177316d140f352772a5a79ee6546bf21f8ae6c4c319bc61d92dbc241b7976de279b9d8d3629c1c31ef1ea29f856cd47b7db856c51d61433a1ed45f9e1e31593404074765a4fa25372ce6be192467941621fa6c07109832cc791524e67ac7796aa7bd3ea4e63943719eaa99e2ffcae61ea82a25a68fdb0dda3823065d51370bce7f01be62436d8fcd49d631e3b5dbd65d08512b383847f58b2a62cabf01f672fd81d89853b11dc7b86fa1de4df79d6e76c8e3bff2d25e1113ca6f35e035443ed7b4176c0f8f241b38e718e1ec1a289a80ea51ff997bde8374be466d6d58e85ac2eb0f394b110b02a92cdd095c28b1fdac205e04696d417f97d333c45edbfe4f980e4eaf7a1661dd7b0f12a8158413be3f4f183b1273febea90fbeb98032fb855878ad9458ca389410ceda3e72b4b274b4bf479a0633b8c2e8c9b6b1230c8566d84f46a526a43089556c27c295f80da12c7d0cc4b85d3019952062612e2b4d3da45dddbb693e9c60cb3873be00126d64f53599e813159196471fd7d087c68d1e8a692a90c78af3540331cbb1c9e0fbc80102e7de5079a1f48ea241fb3bdd10eca22caad42d1c6cb92d960bf5298126184b62b7468683046e66cc745bf3cdcbcb931082b925ad259f21c8c9ce7733a04163d4b005a782dcb1d5f9f51e421538d72f527e9b0333ff23cb90273a2aec78a597f593f5c5f364b7e8ac8f6b13a97b5c154ad733afe3581bf1f27c5e94e7a5d0a6db567a678feb3fb7f4522183fc29d6e27689f892d4dafd37a2d01a49ce61cfec982c48d4f804a9c5921de1371b2fe5753e1945bf1e5e48c8a5063d955168b65e507f69990e589a34f00019fa39fe3ef88a479a585c15cd5191ea2b65f080756d0a37e88ae1e4c1ca3bdb4c08bc2a615ef59a6fe7e4d90b443ec07d581a0a40c1dee473c929e1c7037c420d20c4852a6a199c582ad87130d0c1d7d832e3987d705e10c000428a7bedf9e571c4b7502fd0f6599af6c7079f85e1caba0e67bfe18c51e3a4d5d5ad87c312d6f1f6ac156c2f8c740761d558330c0ded305a530ddea83c21467d002caf549ae8f0d72bb4a7d8c87d39a26940fc2ae37ecbe23c5c21d9496f7fd225ccb814b9be5b3bbd458c152e34382218ffdac59d177fb19a2ddbb8b34597e0ea472b0d84cb4d3e2999eaa811a9f029a284ecc20ac3e67429902834575f694654abde2277637b04d957a9d72541682e436d65b0466a06cfb06063c81e6ac4d5fe00debaac8c5258772bb2e35e560e64db5771f9b25b1824cf4e1b42dfe6929943d91cf9af2d55e075498c5effb0919d61c2ef0e3afd69082a9ba44eece62b44ea78025f2dfe14a9af4d72f68f1e994eaa70c34035cd5a6436554691920687d5ec012b3c7ca0baddca95e23f77b26aa7235966822bfa45b1f2fe364480165eb5fbf1797ffed22a68845b4a406960c32f6e02a63603a5f2da542b3b66abadcc04cef576c09bf7dbb6657c20f191836e86953ccd3dcbc7e92b1a8f1e784be8bda2cd8738a1909c167ee77f58a735b65dc00dad5992b4d77c9a71584ecfee0963c7750a10cdd8c994015abf1835dab936c98b56f77dd83b33b9184898be5e767ff175e8f95509df2ac52fbbd9dc1c9c30e53af8a8b80d65587d1cabdec157d49767bc1a833d28884644ad562fac807ffbb29cc55c3ded175ea5e396aca35e3c85c49d357a3834f706755a26e09d6db522ee728735bd8742bd871747c9a14a6b53757d5b7bd76db14e51398932ab7cbc13095e269fbf39185f25bda4bd5d886235b5a6d58b187859501f08612cadf507746287bef49644331fe27046d908ccca8fae8057a812767f97a6850d0a52aa6adc57cfcd804a21f3f36e97e34ff447918f6c73b177e49e7a506de602cd8f083a48851b17ddc4b1a9c00fe844e677bbbd9c70f7ca25209d1ff409391432fbcdb2cf17f45f7337ef358a4054ec2123cacc00e575953b759e777510e8ce1d465e4b08969c0dea4ac8752dc4ddafc12bf999cb18e61e85c8bee26b70b4d5c3c0cdfdabd8ea3873d2658a1db223f26169fc1acbe0beee7ee71f975c1e1b585e8f341da7bbbc586018b5b327111684aa659609d525955445aad3e573bb43a95f3a04960bf410ea6fa277db4837bee7cddaae063e4ae8b37c06bad6e9e86de4186b3e00838659e341b22f6d466e3827e4bf0292cf89f8b2936ca2b972b0caa62d5f704cafff61b5dd4cf59b0079cba14e58128c8fbf31c50c7c16fe37faab53a23777388053e40e0297a80ad92e6e4f18c74b53062ce1b36774fb587f96e03b03651addc57021e7881fa102f97e281f5b3c235a2c7810b565fb8ba1949bebf45d8e743df3060770731ed6411e32743b8672e0a2b67850ace6e983dacb75e336ffa6ca0711cab51516d88334d6561b5f45d6a97bcd51fb387573ae929d313e7fc696a2d8aa2941f5bbea2430aac7e7448569116f6995d84be6a239f84a22d95717f5ea263370993b87f19d85aea003022564c2e659d0b5e5facb6c3eaa062ccfcc6e90efe440d3a22972d47f3de8415db7bfa8a45eaef3fa8d900dc64cbc11498032da5a3df9ed7f2aa284f6b3f6a43e7725c8821e33921bdbbd52be7d1df9899dcb8a2148776cf3613a38d937861492eacbeae2547d6b401c852e485c1c8e141729940d48519e4796764fedadf88ac907bab428f0310b771bc8830074d96876ac7e3d02f0a9fe9b8f4dbb58c90e85a42a76b326d728436b65a5e95f4bed37f5800db60a8870354942bfa593b4592ac893a6039b976dae6ae9fb0ea26c991fee40522ba78cc04d42e37061d34e438b7e1d87ff0c0322c54111085319d6dbf9ab02656779577bb71e07a0dc0d9881f802392cdc1ddf06aaf1585b9f91830f454d2d54208635a4c1fc1a21e2843bb117b602a496a788277954f2656c1b36f96eb28b414ce8953977c6417a9e4ec96d3b06fbe37b624995eba3035991cabd7792b68dc8f9b05aad67021da9d17f223f26712e8eeb9178de0a6d03d33330ebc0f44882cacdc22d4b7e162c15ccb937ddf834425be8d359da2f9d600d67806eb11e56b56b6f4849a780fab3a28e8d062feb16aeff24e444eb67cb38ba7a61de842def31525037640dc9bd06cd259872701d7fa8ba58ada71ad15bfb3ff061aab66315fab5e7767be27347e53e80d77f17b2b15139d91902bb3e5d4a9987f0f1ff5c0cb3421869a7a63b4178dac83fd522a37db9030f11f380de4149250769b6a85122b39685c0b11aaf8959ef3670b823832bdc3108d650de15f955e3deb5d6cd32de5bceea34137eea5f65209b9af8e305df034305d87fa7fbbcfb130db658421af21e0fa1ed6de60560630ac632a0f458a5676fc904208eb8090015f565ae95e38123ebd789714a9308ebebb27d0b2437186b9e3fab2a208e1b65f38fd2d76ea3b127cdf51abf30927d3e3de9ba07e8d1206e942a541d844a15eec5e5e6cf2522ecd54f2260b88f0a6d8ee288522c8aa7f458d39aa10e0c2e306ebc51c8860102d28b2863df53fc42a87eeb3eba3d0b844b9bea037d1c3d5b924a93d1f56379de15c9725fdac2e401ab4d13e0cf7a8cbd15f28c54caedb8262b320c1c0aba71840c09f8cd26e629d14700134a5661d5d8d33b13d8f61b04ca27c305a079063dad45d851c879622a6306ec2ab58fa9838234959bc2b762082086e7d94ccdc9ddeb065e76afd829a518a84d65b6b87bf3584e1d4a524b27312995a6f31fd2708c12b1908da5cc3b367d00352398c088438ecd781155674994a8f24c6eec204c5590bb934f8804a469fe9ebb1b099e10944736dc79a8d3bbb8eb26c50ab7de88cb3f73b2671994544aba2bc0b15da291909704fb67f384552b3fc9a6350c3b545be1a916fb063afa11c435d13656505d203da0bddc5417012d8b72bfafe9654750bd81ead2f0c1732535f0dda13b02f28f6fb349a9c67acdc6a889522fde4909ff3f5cc523960e511b33d0880131cf32a483d8352bcbacb381b9f216eb8eb9fea9912fd0712bdb632b7291f2f972f40c3b0373157ea00b14be1b4f37a9854a09365cdc33046aa17a617488de7f55769f8bf60d44e27bcb99aa0a5e55763b58e764f3a9d9a5699bec8200900278a48967e6fb870a4c2d4ed46bc2040909496a09823d710d4ad04c06913ebbae0b607faff07ae7b5ddf9cc974689fc4c4b98f940743203666a4323b250bd0172445eeb4b2f9b6660cb9f12ded8580be26b7edd636778ee2696567d7978a825f642103816beb4152d8a596a6b393090cfea3a2c277097e78e6994b6aa2b4ff7f9ffab1b67bd30a3504c6929a8759d0c44192d40c8b216bbaafa3bd127162ede08d22de42fcd4b612592fe43bba7a722da9b880de2761167b895296d7092ff53b19ddeb9fbc019e368e8eaccb09229936193f000378834ece6a72ab634df9aad9b2f21fcb5a947093e15a9bfc29ca7f20b80da6a5d86171f38eb2e7eaab44f8ec520c22796c315f1aa2f18b64e2171efb90c0ce56d684388ee495337007ea3c9b622c04979312e283317ccd4159a9a8299bf07493183608aa2911e25ceff1a0ee3e8488bcddaf33e9dd5729036b13789d880961b0e1b3926253d1a11213f5636d449f23c4387f4b5eacd51ada2747693fc74ed6209afeeb3749a0bb9208eeb6ff10e329f5c715bb004c77fc86a52e145132749c654b841103cfa8784556c487c05a13a5829485fcf3f9665f380d7958396dd7bd23250e3b334ea298ed3892076bfb1cc240e7ecbf7e605959173dedc4838f4647d6efa1516d977b8d886e86b9454bac5fba62064d8512c081feb0f282e506b823ce40fc642552cdda98201e9aa105020a8c3fdf3ab086d8f89093251dc382cf3e5100a1300379a164ee378834c8f7c6170325bf656b72a720b68ae0012e229d7fff3d07616808ec78042c9b731a28e0a8ed0770a909c5d8b6ef2b59dcf4b122e176d215ee303679b587e228d49f92b21d29ee51afa092abe33cad48bdf3e49a84443344cd35373d82af845db4e2e75fe0da9864045d646c49585214d2c23414fa1570a178b4e898cb7e5ba1a73200cff053d28295a843dd9a6b973d696a72690907f0473304b538f8a5d698798dd463e54749d75f079d42f42b7a8258b8b20acade514139dc7365bc45e8d4a60aaf00de2a3fdd4411bece7577831a79fc449fb84656576fd8cbee7635313652e083bee8d4352f820eaa3b017b18ba54e0d2f96a64300b545ac5fc83bab7816238c6fc419fd27ed0e6afe0cbd17a4d3be744963e1683f6fc2e82e337f504ed79280e237de26bba10561fce470014590db968a0f6bee0791b66c88970e510fc5657fc4545bf870a6460e7b3ce51a6a79a5699df420a9d9739d96b590d32d3e8a6f5491e18b1b133acfe9e060de4462e28dcbd69bd4dce419bb82c192be98368284c6457428ae34dae5aa22fc40d1b8be145493448bd0c1eca6717d544b2d6136c99513c29a373b10a0385b5b2605d47f11d1b365d364ce52e95b6d001fa970b085822935e5f51dd71b278df21ae7c32213753016d5db8c4fe02324bec1537188a9212277eead6e3da8e4609a6e5ac609965ef23c15a91a8d53dce34a42ca1d43b292d805b335c9ef20f05130846b3767b5db077ef967fe7e7ec3d1498423e7bd962e1fad9cddd2c5f09735eee35527fca2ee04988e9eb2b30517153448b14b43e5c52b98e9527a971929fd05c81d5a3802dacfbd4287c7533bab4fc55293d63669f909943afb7f223f7196c37582af1ea5b01c1fe5d71eda936695e6f340320b7c9a71e4f9eb7f4387f0e75ffe7c77117ece01a31d18f55530ec1333d1e3bc4ab6365b5ae2b6fcaa986657f716fb6caa66190dc758b90fa34448255ed07b2524c0cc3e87332ef11c04452f3a5d203a2259d16319cd8c1c35f59c0be0fde67224c1b2f6ea81570b4b3dfc999b6b51eada03df4a8733a1fa67b6e4ef1bbd98c04b3c955b7fb59404a99b7e5fcc4728a5c9e3b5b94871a3d54d24be1269b4f7f6f8efd318665d8cb443709027dd26e609cf5943ec78828bedb7c14725b0d03660b122053633d001594bf94013fa187f1e3f27b986b9415eac982d1d325070b80b08804ae3dd9c7ee52e068dc9dee6b3c8874f753ad56089067614472579683f5028751ae14ae2c904f135c91ace1f2924bfb0e8cd3a529fbfba20453e338aa2a9f16c5bf555a179500d4b2cec373e83e239c4b3fe881f15130b1cd0c97dae94e70e11f7347f4cada07d2d00b85074a78764f60b0531f4f70589f44f6134bea3c1a9631f9181a17011e76748542f3101441f1a9837ae15f8c2a94ded08cd1c0e92a4ae55086b3ec29ceb4c48c311bd0ed37e9d1363cb6bf06f6c99e44b4af6b0458a7ae7fe02de1815dfb1dc7b5fca3262d780ac1803c6018c3b46e1571d4b738fd3f5e4cdafb103a183d8d3a0a5bac6225ed6e9dec997028f396b33cb9811647c6a1212dadbc0ae59d5c5d0afe4b802342e82949c5b3dce6ba67a4eed4711309c758f456c02e050e1a017c3aba127ada2009e4099bf1cfec1ed40db2afcbb3df121bbd234bb319065be41e29987d7eddea915a0d9eac40bc8ba88438c86e3bf2154ade88e437368c8ee0d689c3c233a6a77bbf348fb2fa26f447a1dc9fec1951d070dafabbe08e6e9e03d3421d10cde3dce5f7fd5aa41d9706947fdde2acc195e15c836765c0fccac797bcba46cc7150f95f0533708aa79dc7c84da3a0986b61bcf79f3557723a4898645d27daf67cec326914ca35a15481e4baf08995c8f9008d02a084bdecaef0d78d26931e1cea650783b63714b9c07e0f53c09f264666dfb7d12f533f0c8c9311a51bc930d1c3cfa77f4e9d0103f886cb2482f6d250bec69648342bd53ee818e2a9474536ac91fd4a1d69a80322c42c7285690fe8b8217701ca0ba15bb4f6c6574aee9d7e6e6f57ff30889e324545aa25a83abdad2f1cca981342a12fd1212d5338b4f26095e81d52c1b3a7e807b3974be2001051b2730d003f7cb9bece9790078a79834e228e5892f1bea491bbc974ead182449ee3ead855375854ca26913cab4588440d11acb103e16d326ccfb1642a76e114303c6e2a01c3b7d1da398cd510bf15a146b3c277890c70702d36bcd8d8c2d74313bffaabe58ba35b8d07b90754808c01a3d86b440d5107d8158c0eaceb413c8e9f1cf9495375d82beb6f03b60cf91acc598b11aa0dc0286139c28e8d7d44e775286c7e0dfecb2fb4380a5f1b9a58799435694b884fe069e16128f65b5a2f0926cd9d2b7fb01dd05230004bba3028454d4fcbd671c3206ced48366e17436a39a378cf8e0758542fcdd57fef8750e888d5cce73baca638b538bf8cecc003a5782808ca58d685c6f8ba1b5a2dfb6525eabdac1bb7e588262786fe5e0e56d5190d3694998ea1c698a3932b4c5fb68f3fc5f720762a21e63b421f6c26867b3e693ca760eae3f3eab05e95cbfd6fed7b3e9e2d6ec75cdff96aef299c7df7997780b73543f0629811997a718852f3c9bae32477341ed9040f1337b2c6db23ca21fc45c4155b69c98de162441ce556d46593c9b5c1ba715f08e49961d392f9f3f037f42eb611adb7753cd192fc13588cd4655d294e41d6aebad97e50da12a71627ad36d8c08acec2a26a2a53872e05cea003d2a7d7818acf0c0da056ffb054a6b744f591f4a8cd444ad34bd38c6a613f4fb6acde7714485bd1b49654f86d87c98031d1ff9d822ebaa9489545100cc84fa0f6c212e5b2e6b4b6494ce9cd85f6c36b6cc158dccc9cb785f35e30ee40c5e93f2ad0319ae39da6cf18aab980ac268cbfe5830c644f11a035a8611b18d5fbb50aa57e80802890ca0dd54e10f5ba00ad43d81bc6c96d63be6b466c44c892af9a3a8c3e966d406bb0b1e8954773732ca117ccae7038fef0331ee7d6b956debb5c967f4a8e995c26362015a00c00acbdbabd4edc1b8c702555350d87b53de40aa0739263ac992939294070388c7e5607e2e2318d7159195d2aff65ffcec14cd9bfa9d9247ebde848d58d7f16b1fd1ef4234679dfd7e9572d16ed7fca7a0e87e85648541f5b2599baf9527c13a43fdd3213fe62b6a7952063f481c23520f60ac46b6391f81e1a3deaa294713608d79d60e571c5516ff316851a3695af390645dd0b628e061714e6768c76e763a54a5b590527f42448aa1c70cfa0463bd45970854c2d6aa0ff1c27c213d45b0f570a7edb06664ef452463b3ab002423e3db84df563a19c0470c1b1aa0628130068638197a4d7814d934582aad08d063dd1d5627dc896a4976a9e045e119d2b6f328c15de4ad106952e41750fcc255a0c9e4a7882a7a78d4b68a550a2f13d8854c2078d20def54c004672a83fe1d38ac48cbbd16e9e3dc0b60ba0d445d8eaa07db823750935872f57497fd73b0861eb5d5d7390e4adf30696bff81e250475f31dfc851d70ae1bf71e43cf23d891fccd80b13bb60d5d33489d8b2a076e25cca1894a0df022b0899aca7f55f17505ca810305336a3845c8a7539a6591b208d8a77ba46cc51c47bcb8ebe11bd602651408204afd3cc10ef54b906091dcf0cbf328b7a9cecf19bb645d60b9d0f48b3b706b757c9b7684162f7d2ad5271ba36bc0e4c8c597800478bfdd4d1f4c134959c646b311a413e94bcfc6f398182269daf8df23d35438cf11c7ecee1047b9cadc7116b076cf898e491fca26bf64ffd5830f7830046f759a7999cc98957a64fc7234744ca62c77f1eef5a29290d7b576cdda635e6d00f7f4148aa7322d42281cb298a4fdc60d16e4201c72d1c2a537a0f6b04a627036000d61518aec49472149d5f9830693531873044f7bdb83aa9a6fde20db0eccfece1f472d45431cf64c2b803a2bad160065edc0077e4468dd344f8155f0d068a91ce91dc2d919d9b5cc4e52a91ff11257a90c2b49887d43a614e3636d57043650e9d6badb13ac59ab5115331d092f65a0187d82d49e37610a423150760be8d7be8c0bc553e474bffaea5f84fa9bed80e7c8053370c0d15826ca730f54f1dee5e67a7153f8a8f53f1af1fd4cb5cd6e59989e1ed0226719b578369d3369798c53fccf6d743636778dbecf98ab6c33d2077c17bdafea4f01e36597e9917841dd09294a8046f8331ae28d33490b8c7263270495fd2a44cdb73f6fc8a631bbd5330ad8969ddb7290905ce750c5d6c869b8527d078281cf5a3ec73e9074b7cbebff9d27b92da99111704770ce1c31ee99","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
