<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c679ad699cc8d77c1f5c7a2f4b981a7c42da7d83efde0ab02686f115c518d508aada294268e274055546a394b462cc9756240a3c4952c974f0f5687d052f63323b0238f3ab77cc449fa3a24aeb3ea3382fcc533cf66433ae31499de6b2179be894cd57865a6a8df74f9c547a8ef3f40ef0259b1b1308af3c997d15c63eec7fbf905cdfc1210487be1faf600854df7164b164928a456f28186e2649a011735b297f51b49b89de59247abe1511a87e358e0f193c7fad57579f108318ada278e1a07c00be41a859964d286ca64cafd30e0bd074764f19149587c98b19d3e98790708a90e8838325a10c18eafb53b2640cf64b25268ea949d2707491921a4d209d92f9f0a1f14e197f54ac6152f72b7930b28f5a00ca64808944f73f62863cb22d721bb3e8c119158f5578362effb9462c93434221d7653ce3d5857ceaf0e05fd32c1c4f1b2470928dbe86a0d71cada21f083475abf40c04660a5df3911be44ab5f047784ebc518347b0d9d068b002e6eb8901a6531eca3a94fb0c3faa9056985fa9a2c6458cef54eb44ca29950e17205bd96eb9f213889ea3de48fd2e537242b4974086a5989a176d67c3e0eb789cfbadcf06a97542ebcb9c4c823ff11779ec3f703d4af828268a972e1950714f31cee9769af928fa0df4f8d3861515295ce327ad0fb8501887aecffb3b66e093fc63d3b6197131cbbbe64c2f2d0aa3d2fd02c086b962f05209731c718ce7e680646cd1fc3f7b22db8c1d7a604a1ab8f66bbb8c2cf16c477fed0adc62ad477373b81d61a4cc081c967b6ceaebfa1acbc29351c2627f377e900b02e324cfc3fd4b5fd86124205bfa026641098112006ac4499cccb8505554e3182626b8c90e341ca465cd52640108d78e5d31f793989b572c0e616a9f16047e0b1113e62c643fb605008b7bcea34139217bcad99af2da2e0419658192a882719a97a9f98f55ac77ca8a98217be8ef6fe001d941b487e7aa42b358a91d6cf4caf1d4222aabeb322366940b2ed036a4ae587ee855d21f01afea15cae6e848281d28142e66ff16066e9218a00abacf387917fe888c081a61fc13d70b1892aeeb9eb1a6c5245c5192b10082ccac686d2eaafd08ef5c7e5d041e84a3d01c5da750a746fda4121571a79e0c14e1c93687f84f7b6ffeb8a7a8010f2f227ca2f2743de1033071204b91876a0a42aaad16d54a70fff6692ead96e02b2a6c030aaa6f1ddbbf50fba64233388823851283485a398a81d8f854c0487bf6c48fb3c04b91863b7269ae28be68ea7d9c08c6a6b77b6b5113ed09502e79ebb40dd6c1fa57254d555af983ee0dd50fc9a5d8e77f65c7927b6c289c8be323d1a0d3a94fd18ac896379b852c079eb61ed3b0d404db607c1a266a389eb24928298037fa0dc281e5fea57685941195554e5286388e0f1ccaace43dd82d1311969ca5cc4f77fec9ae3e967bf13065fd551b79315f63f888d2ff66bbd296d976807fac2a60d1bb2e783088ea7d6732412a79cc2f116d818eef45d11d89e133459ae3082639c93f9200637f8d89c6a8b08194f3ad7037fb8a405927cff47cb956a78d321f3f218aba5dda174717858e7911351e8879852423ce7a18b607a779ea8740693c3c732a6246ff89e4c75ac9307c0c6b48bd44b8e6456864f4e8bdde1c69998c674981f2c9fbd8e6aea99c9a19bc872a207a7e96058c7c47c1e3d7a0a129b4da2cb470b7bf1cea0970d620856cfc5aaac2ba0b1c63c2b45d52a9ab331a981100780d43d90eee0bbcd87aed023e45c353e5751818f9509739d1092502bd6ead5bc273fffc32e666da9e3bedcddc717f6c9e325c2b5e48a40d089fd8a21cf350b082107d961c9adb49ed4986d51750322ce515ed1d4ca57e658b22a3aeb75bb9d46bc6191597f313cdafccca9c4e878bd9fcb1e9c6148acba1638f617bd60a20fa5d03a23362fbb2ad9e441649dc9ed6c4ef52ce372d85e452602134f2bbdf5ac31826c609437aeff1696367ed3bde3815f541a947c8db36e2174edb2e1498424a4f30a86a7281489b999a7ad8bcf9a90d2180c5bb88f49e4946f4679a0e4c76d6fdf0562a325d12cde67dfb620ed14a8cbb4b89627f0987369e720aee5168f369664a9ec7372b2be6b07d7f15f80afdc1b88454b59cb8d8772b04255b3d1c8442430913a1819fdd73b9aff28336171c0f2bf3155fc4e505b12370e1721d4009270e7bae78a87d3de56c034202ad3d48e7c05f2a8a8cfcf34ff08b44eb0ea6cba98a3732f51b78c05e8ad70cefc6eeeb3826ea98c9d4827b3002e659db9272b123720296dbbd856f562201ecd7b3ddaaf9b760d1bddf2c50098980f9937464f14879bda9f4dbf9f321af758aa826f6ead426631ff26159d8f5300426d44716de4269a24de9e1fe02c0c38ea59e07358e97ba869420ed7b7ed6b0da94e370fcd95bc9898a2bc7e5e35bccd3b3fadf335424b433f993ad8a460ce423c4d81692d7ea4560cd519ec62a3b1eb4655b8f24645439945fb43d94cd0997d379cffbb2f264f7e05b9193995a92f83eaf01a845d6e424ab180ec0ba474481a596263af30bfdd390ae5a675f020bf4f6754c3845f1dd7a2b3e0b66d9a7edc56de2a71161b9c985865395208e061766d4400811ac2f84a90bad42668cb959a173e2b858b8e408156f4db46c3db92e5ff44f894c9d969e86869c829acca62818652eeca0d36fe57b5f285b6b34eebb40cece9c317871d90accdee2205cdaa921768fbdbf4dbdcbffe40bd66c5ec9b563d2ad2e30b258a413894085efbe35bd76365ca639c540e69fb6ba08114068ec32eaeaf30f87a0350769906a07f9486e8722a88227b6d55e8d68efa921180adb7aa805a40964b8ebbf9aae4c909b0e230c216b5456258cdc4fb64b504059997f51ccbdfb53514599cfceb0e07d89ca919cba83e7cf84da0baf7501607e88705682bc774b365ad2318e60bf7c3c36fdc3d1b3eb6315c16c131c4347caabe53ae5a234821ceeb43f8b2daffedef32ca04287998ebcc85922f6b9e9bf5510bea192b279fd105bf72e0510a267abbb81b1d3389b45091f0c444a1f03d9d432c255664232ee60823c9d4f9c56bc728c82f22639dc6ab811b2f1508b5b64becc3b60a2888145eac28850fe79345b76c6430270e92bef88c0c94fa4dc4751623c8cf202cb7d27febde6ae1573ede565dc1f423462386c9a8d2ee4043b97f8cd9602d00707d986ca9dddf3c94420c50d24020d51a0023a142b5e1a30105750f34c31e6bbfa63125f47103608a2291c22462dce2eb5e4ac5b5a1944fe31a0b0afe9ed990d32481cdcb42f8759f57ccb7ca9ebae0b0a7ea43346d6c494662b4460f88bf553d93a7c415771f626eae92b4a377bcff5d2fcd44c0f2407ecfb175cdec6c7c6e8cad2132a4979aff08f32c64b9488d4cf7e877b7744b29f7c666e3e40c993e1a4a88b702f24df2b5bf80d08a055982bcf36d153f27f397c0a6defa09504de0a815196b69ea3dd50187b7e7e30439590d197711e434122d62e918c947efe96fe6d3ed23dd41bf0ac9bc4f3ea8da46c1233ca6be975f2f0f92e8df3759145b1b16285521ab0b1ad389b2a0eaa323c02e23ec0b45dc0e89a4da9b40df86f2f18c3ab38838e31bf53715341892a12d835a6961557a02d3a471edfda0267549b866e0d107c1a49d83fb4c3cfbe7715b38b0822b4149700c3c4e417c16da2c61a0302a5c7ef45ce4d5e22b81c2e29d343af5fa068719bfdf08e6651946f0ae4adedb86658412415c15854a38c88e8c3a095d1ef1fd9efb293a089485ab4e5e7f51b87f3d0241e8d4ef369d6b4c46d3bb44a1f149577ec61e65d1fcdd8dcaed715cdc5e95e69d31db4b68e69c25540131c1b9d32a178a29072566a382da9dcb5026e344fe1c4ac7de73c9e154c18c0fefbf1d70d859da399e843073f586dc4e55f832fb4428f6841dd4db51f1094b44416578dee9143919fb0f9ee7e0944c928f7fb287be079aa9f0ce3a89a390310655d337cb4a98f6ffb994827840759d4a752d4b368193fe9ff7ce7eba9bb65b6404fee5dbe65076e8150208f4e8eca77f6bda065aa073654cee301a73b24e3a18589c685cc0dfc351fc9a3b8bcdb4ababd2cd312945390d7c0e7220e69ee65319ebe3764a4c9d77cc525496aa1c73ba917ffe4211ef35c4fe2918c15edc7198525b112ee4207b1c1a2813ddc9b5216fc2b883bcc14164ebe9f8630d8d47397d5b4484d977c840aa6e9569d56f6f3a9d3a26b5d5d4ac12b1270cfaf8ce9b6caa2b88b6e863d73b05d15d203df88341fdb8a2583cbb1a2c91e80e11fa0acd470e1e7e274ba94331f036312c916000e44028a011145415b898741f7ded3571d2f9d5382a145f1a0dcebb51fe3cfdb8a946c1769653adba6d0f5da74ab85778cf889eab973ccccebac77aadffd9048c102602e41a8b4c5ee44f91ff6674ddec52cdf77787641f3bbe596056e9995a19adb67d0fe8a547f0a26b5ed0f6b8a4b46bc525384ca69e4929306ed19e8ce00fb830efe1bb4e37ddbfefbf2404ffab7435a5d93d68914851259c1e02ddbbad33fc237e71e9d55d6b942582381c5859f24bdb6a1f74069c298172c57ef35508bb68199e3782b017b51e8b8ffde3092452e9eded6fc5a49493613482eaba605c11e42a78c73288f40f7a184cbab577e94764d9c34205de7c386534b9fd2679f59cfadcc61b66a93147f0760811bd52396ad487612a4a2169b32070caeac7ffacfea6e6d662f7562bf6d91fb3ec6e2e59273f223dc4abdb7ea7a1f5dcc0d548ea329aa9effc58e162b173d5d356f64d2441fd2c4cad5cf4e45cf33a09e57d662fdec28cc8ce546aa240a83bd9a5f72b1873a7b6fd8e4a071540f7c6d2efee4778d9224eeec24aa1ccf3cf74530c08e84539a3ac472c319e45a8d2a564c2f5fbdd9725bcfd5d6506092d51ee8d10e89e3bc5cd4deddbdfde6cfda58a33d5a847b363f9ebb489031cf980d800f2f55ec0d1db3d6590fe01a1e48cf3027f0767c3f8b044338836fe7f4aad32dd965fd11c1031d280e7a530956e31c31809efd7fb4295fec5af0efbc3631a48442ce78c5731ed5863bc6d173ba54bfe16fa3f7ef15898810f97fc50bfe6af33f1fd8cc2e10e57a67b52b88f33cdfedcc5a96d1bc42432737dfce2a26da77d712950105cd178d9685914258276b2e43eb3b7ab4f6761edd4fae203476279115784c5ae1c669a81fe56d60b36d8307c734c28171022adaa0430db46c844b077af09fd6902965fcf332e17818fb4ad54b8536e3bd4bb3836e1ea55e2a2fbfc2405ca76db51d69dbf46204051a67f9974f149c6a854faf81bd285629db3b0bc2d692ea51205dfdd979faff4d4b3ad1f76623973986e4509f65c251d3286e98ca918f5dcc6a81333c0674f60dc43d976e3f2d5f137f390d1139864da3f147984ea396c21e8c80e8ca0658b816be7c3044717094312db37e66adc664662b6a88c03f73d76b2832c756b6847a59bd7b68bfb5fb8f8eeeb34a990997868db077a254ffccdb18998e9dfd377854bc8891debe00cfb570a339e2c975bc6abb8680bdda578b4196812348673e7ded904473da42030ae2d0635c29f9af2002dcbb81f8c79a341d5311bf608a4737446e5eebd920b5140c6ff020ee10f29277c7ecd6b6bb82710ac8cb3205205a46e9c57cf63c75ff55885ee4e9937754bf9c4013befeaaa54519df6d7a3cedecf75a7dbe0436693f749e5ff70d09f6c92b701fb6241e2b3b2ba19d5d538cecf7809ff524016161200c7542c3f5fa244c11e7a55ad9ccc3c05154232d136cfd38a173936c963fbaed2e64df7da0eca592a4407f44b31e4641a951d37ba7bf85439e012a18a2b12568eacc1fdc2ca4fdda6befc2836adbc85b19506a2364b142b502305dd3006bc5e639e595a3cc92a5d848e23ab259edfe97fdf927ac6207d5ec1a9a29365fb13bf73e07fde47351a0f5c0001fdda2462d02d60bce13f22ef3e47ae8530eeb76ca8d437dade1dee4897b97abd3f75d67d74d750b19310dad02b0b6dbe62f02be681e4e107cdc8b6ceca92a50cd501ec8d807922296c923c7f95a7e999504d472b42f53f7e3d2e91c88c2f55ca3f78f4a6e248510a2f26b737c78e8ba6abe84e184dfeb71c5b437150d4222e4d4a2fcfb1ef61275a8a41e74a08e173b1902dcea8206f98d948ba8e9d2f4cc82585d1fd076d891059b795db11c41d1ab33bf287bc61ef8bf587606c929e6dbd8080f2b2515c6682f151c05f68efc2a152d2c4faf1f83ce5a06c1eb529d4011cf77440b0111cabadc3150fb6e750c3ad2d594f0597f8acb1933c78c32bfc187ee651893df6629f0a0d6fcd7e02ebba35b1e7f83a8e1136177fa13bf19828030f0495275abd9841d21e88c07194b789f6de0d35e4f34178ad7db9c308f42a822ea410cd218b874cdbdad794219686c1000998f4a07f1d1326bd532f440d0a2b96829ee6650c7c7386e6b69dd6dab198dd382b211d1aabea6613d7f04badb99f81124913708bc89a4add2a6f90f4b45abd2f5c01edd50e00ef675e4e9c988cbd29e3c149c4c0b28312520d1b323b94bf03e734a9251a018bdbe66c2c8f06fd175ebf9dda3b1cf18ef6472383d8894e15ab96182a3066f95b49a6417688ce039da16f909e8bd543ae28a9647449512614aeb007db11da7c08c0ab1294b70fe7c9678a62b9bbecea3ebbd1da34a226c2b92da9cf5bb92621b5f5535da0b76d2312fa2a59c3ff86f7ae899ce3d9f16bb65dd8e5bfbfe2af3b7089fb942ffe57d84d0e8b6d2c2d66da8a8f1c201730a89fca3eddff07a9d3773c756a35e22e9885add3e1f4844491a45ffd45d4186d08d670ae4c060a42f2191a36423dd342774516cecf86064c56ede4153aae2bcaee112fb2b99cb4abda633b228f8d3cc8f9c825dbb7ffe67fd13092a659d65f549619595901b6c3d6e86391a3a5a355c513b04c3156bca27825be7629e56d442001d1a6e01b49b6e653c5ec7784a595652a77223fb3cfbfe1a96bac5511c425155258fb7beccd8b1462ad76a50b586da9fc339e10aa4eac6715c40a8042bd518cd736c1b1cb19f517ce9f646c0d1d75d9533015dce4a92e34aec0e1783875c4204d8f99cc2a6e0fd88916d993bbdaf8b6e96f43887286c22dc7d9300220606777791994c8b8bcd745deddea9745728b244f6b4bff09dc27982d83d9db5810bf6de046809d29268ab63723384663d9f1e1f6a06117847576e5b3c8c1e177cd18827ad9b133a241cde1444dc670c6a23e0c486c5f777cb53e4da912233d71f524bb8095b80eb3bdfe3cc14234a51b1484ac0c72e1d7420b4ccd7da33c97668363e0c47842f9e99d589bb3a9715a39c1e7c34d7c9ab93fd820cfa8fac5f36316c25f4aad892ba34c8e740708ba637e7c4e6ab626b523f5e70b105bc44048688bce6325b9cf20b1b093b07dc0f5ac12f848062bfcfba68d605d64dda94a0820bfdd461274ff586c8ef4b6b15033cbe96a86678ffe85beef1603ded9da075a20cce4aa9f4ec3302b64fc2c8c4b29a154aae71d5023a73d57d6d8ee203ab362ea68a17e79ad29a544e6e225bfce28c61056763aec24803de0ac3f79bfbb0d2f723448ed7aa6e28d5a6c0e4866de62dfdb590bf9cf3ac02f0fce8b795bd72cecadd7292d212f61d4d9fa60cee84acc8e003fe8542519a2ce007d002045d7ebe918ce6ba934e7be7c95ebb1684facca5543b80bd61c84ab38a9d25c943762aa37975c5d73b767c4867a80ba0fc2decfb70b67af9a9c7310c26a088ff2a9ab0bfc555a6f55b098eca2aeec911bbaa5277c6750bf543b6a55984e2a6d1e186d9b79606fa41c4e3ce413eceb42b836af5542eaaf45534c0fdc201cffb1556168ac50c5ea051a2cafd56a17292ec9c6bfe80d347fff11b795a73af1118b29d4a254dafd2211c7d5feeb7f73c8751c700ec27eebacbaea011df6f46677d09fb1f1cd37d967ff9dfe858f2eccfc1cea98bf5ea84ef9233e36f49a595ec0baa47ce61688825dfd52c9dd5dc5255a3b55b719a8959dca44b622ea7c3d445c2785c0cedd22cd1b76f811dbb47e0bc6e101b56cb68263d013cd22966d259aa1e3b15dbf87a028d7bc9d095bc53f75dc4bea3f127a0630058c2663391a0f429fc8ee063528cbfe6ddc194d4b8c296c4a8f45918706cfc4c0af6af9a6853ddd5dec84ad1e4787b16bce9b45cc73bdb1b7a66c101747cef5f7764f67dadc1db5adda2889d801b578de16a63ed820dc7a9ccd31f4b7e0fd52e858b27eea0b6d687538964b2b3e64379e1ac76854bd5ae695d92ab6fe9d196fa8cc69976228a8ea250e0dfe2a1451bf314c40f88ff5b02d88e2ac45d0bff6d35429db9cdcb327a8888f2dffb0ca28c69fca58d1a7b8d1ae57fdf3c6352f7fc4b751f8b8eb4e7be18f3ae6e78f36442fabc7e7f6f783dc57ab364f665e7a2659d37f330e3186ca02ecb92d85eb3976a2d82612ce0a0b15c3fe2878c5636206554219025a491df8f5ad87a721b8eb58634e93b305fc527fdb66ac63eb24bf9a551c74ff19966e3e974e4012b9e946d1c96d54450bfaad148ac8dea1e4dfab8b1c90b7ad7b95289d6d8359e857c24eca2248b3111d6a139f095f20ae595fdeed020f8a09716d0f71f382382b02341a914cada388d94df9434515c0a9ee26a88e5829927c437c3fd514e8b99e4221cafc429043d88ce4535ee8d452780d81fc11a7de3bd282f850dde2d20e11f6158b37fc3523ba347f967cf98b97f5b28c6c5085621363f814d7f1f095d30819781acb66409790ab8597cb90d1b8d0e16a94a79eed551c763081ceba03d9cda688d5d7586f340e6b464ada0a17555ec13dc1fb49a19ef2d523f7633a0945d21c518e580937ca0b731794f0a8b3c5563c33850a5853e6eef00390d870d6690cdd96315ef2293b3f800435bd5417051278a114e69fdcfd86df36dbaa33dbde2110b9784af70ba4998886cf70589af446c51fbc8103c85fb52ab091c5df07aedc15ef5534c0a56602fd0128cebdd0081b5a85b21fed30698337297ce3b5bc7048814e1eb2df43a5b4300592bf9adc0cb006452526354847394820939269acf59b1092f47db81dde26f99fca2cd3d1879a398c6e3ed5026eb22c171c000375981c3f37dd510f1ffc87f60bfa6e7fc84e3d16937a395d7885ef3b2b4dbbd1605a89190ae0cdddd585f398261effc7da223ad21f4ffba5ecf411fc5c1b8d737f7f7a86b9af1d6095f1e6a445e6da83464475911de642372f1fbdb3be515f81c1dfe8bb9fc9eea02d30b29cc22f2fccc2f885819a2270a5ecd963210e71ae2904c21c8c3dcba73ce2428e2416647fd3a41fc21723775681204712cc7bf3a9e1ed169f26e8a027f78ea07ce51ee842f841ed9c59fad93416ed3c7717ee15b7723052eca55d4f682529a528f922ef5364ac2a2476c4d16512af18ef59937f50dab6526a6933eff933008e0b5da4f9f33e316f872f16c3a9f40632829a8ba5a6eeceb32725e824ddf93a6ea4d23148cd8187f5196e53fcb4e904663f006e197ef1e42dd858d3ea52a84712d24c89cab51c324b3dc771b8bb68bf39816ffc93074a57d10841232a12ee5f7605082fa89e61320f19c9a94c39682d2dc49f1ce24803a06ba2c08c91f9a1024cafc58b2d00cc71cad76cd7e30c9080e11635ae2dbbf726692e9ef3632bfa182c82e7aab50f571b3be7bb7cfb61322098ff21b36b85be155f49c77b66b7ec9a4dca3435829792221564eaee12f58edef2e9dfb3c370350babbdf06a95aec2fcb7909356936ac85965a1e6ab84b3620241a704399dca94232fe52a5e4614d22dd27ac7d338866c799c772f51554165c22e88217c59cde41fa12b56d7f076377c651f9049c3c25c5e9c122e238045e9753c0106b75bd2a159badb97a75980afc1a846b218bb772b5046984c56768a3a6417df43ff753504b4330191a3f6a863897ba43a2ac7da2145600d49d86a9596f6cf2bc1830db9c38f4bce75586d0bdbd2a2170c3428bf06cbda1e3ac4b07436de02b4f0eb3586e141e842f8725bcbd40acd5bc21263a01084953c8e9eb8929f592d2682de22f99b7c899727d59d2185380053ffcb0f64cf8cdd52d159c3d4653d9713ea4c803fc54f299d0e7d5a219211963ab43a6d538653d8fb99498ba8a6ce7b4e8904c3770c0e6f7a0f1642c25385ea0f180732a40aa53389d19d07791e5ce6f6f9eb75d90101933a19d0ce00ffe07b492de41678ebd98dce4bef48bca28338c5ee1c1542fdaeb9b263f1684f4cfc345649e8a0dbb8ef4f44fa4023f667ee18d9d5e26ebaa09ee4645e25d9750e716b893de73414f64c4d3015d5e8928f09afbb5e540a9cfb03856f21ac5779ef513ad314125631fc8deb3d1969f637e7058d9e963f4be021d0753dcefb3f7850cb829c459aeadc30817031ad42a7e97f8553f043fee9c7af2ab5d13a29bb6832498a3de1d134e78ae3eeb015ab076992c5898cb62a6c868899b520e817ee9f084705045a1b99a34c40b43812aca6e43f3c175eb8a4c482b4e2cd75f797591068684dc69554271019c9563e742c164efe63f404d7365a1ed932dc1577615032f6c5eaba11dda8c8d11217e522782bdb931405812d04b2b8699e9d552b1b97430735c4f4149907e9ae583232270a2a19947b0e5b8f86fac91399324439bdb9c04ec15cb70f08581d95e584016cf441db0d08227f5f57ec41ad5578207fb7b6d7fc1b5b42346983f531bd4e2d1bfd63c87ece91c6c731b34bf86da4fbbcffa5861b3a28a7e36356ed869372225c3f0a5c97c09c1e6c8f04686d5bdb946db7ea5994638910ddd7e9e1df2082e041e07ae96aa992d0d5f156edbe7a6f86f2925bdf4a0aea3c4344a390c91b01b1dcdfec0c53ba0be05710167ed7c215c7ae657775f4dcabc4a8e234e6afe2e227274c11d4cf466d38664aff53e25fea436460385f72addfdba8ab8d0f0198c483caba3b170e1ecbeaf8f226cd8ef0a83f7a0c0f19b39a24ff64d9f523cf0c21ced900debb09f7462323ef6adeeb070e5572ea8fe1c5ea9eb990e3578d4aff59873971ed0ed91b778ffac21b039916d826b85a409e03678da904ab721181a7192339ad2e72bf033070f59b79d6c8fe447b41590458386a5fce944be241071f03b5f9b915a8ee60fbe391078543ff1427cab0249260d86338fffa06e600c17d46e234480571044cad3b9508b0deb63428a21bd102619fd5d1abed3b2c5df9dcab426064c610f113b1911117bc3b65dbd5fd4422ef8e7a0c8b589896dc5f05f853a3a9418cbb6358b58c0fd84c80635a8617bf50ce7f7d3b17b922958804819fa7e9a7f5ec4635845cd2a48a09645a9622390d434a8de438aef3e4182591e4f4d465b1839cdc2e8dde7e28c9df53a49a1c7f710033ce513c99c33fd9c1361174014fdd9e904579e854002311b5877c1cd43bcfb9351aec7ef5168d12293e67495ae9f55c355ecceb0ff9c5eaf45a24366f09e2f30884663e7a4571565db85a5f81ebcba0a34c2fb695d7dde75ab7fe5ac5e093b03c532033b57226d47436c771ea1989984009b21e3bd6295afa7a4db9635007628b3f4652055525b12686380371f3d4726bdc22ff06ac1835d71c8dd0df3daf8605ce3dd038a97e54d221701f31af836858e7d81d3334c494caf5a7df17f0214bbc2374be016f09927abd318c4bfc939f89f20220e759c682230d8a07ac8f94f786e4fa2bb83c9f617ef4224afe3da599b531a03923e4b5d36578627aad1374fd87cc11558b1aca47f1ef77cd62c05961aae233f2dafe4f2cc82bd25a00a0145de2e05979851a5f9adfc338b8d1ddcfe18e8c1bdca8ead46a2abd67e42ef5cdf1d66de0318d4a54650c1b2de09d4c66f01865e5f2de7349917b8fca983a78553130f10ded96cc345d96161896cecc9d38b6530f8c81f752c7173dcf7800319dcdc8d64493f82f9db4b5b159e10d3a570c0b161dfa8669ece658efdcef6625e676bab85f17869f94b27a20a9c47589a6b1af99e5755def7342e5fb65f1b935476836d74a3ebeff642da0a0bf215c5301ac2fd18e90ebd3e9eb76773f29a4dba90cab55ecb5f15123e40b969869d4a66b2333546abf4ebf7b9abe999730ca2fe6cd01e4bdc920fda0d6c1b71df258ae0c51e3a648b9b4e940712f9932eb8a58be27d345865d732818d38e14d5ddc17ff202a424ca068cf9c97df901175d527e344e954c653d3f4de9cc346400e33fcc9201e85a5940086266c7f50659b60e2e2d1d10b961e78519efc418ab30f42e9586f3c390f9449231e67dda4d6baf0e32ad7ae1f227e84c9c9cba65b81f5311e02cb1b65918c32b7c04a3ab6711bc55942dbb4bd1d22818d62335e633e75d6f1ef6db72fd6743cce931239ef26dc01dbda90968aba0f3f2497068c586575bd382d47dcbfda9346349c90457fb027df88542ec94c89b78a66c16c710c7ed02cfc0ef40ef38b2baab7d9996e9bed5edebab1eb4bfe2dfb3d39894c74c240d14102098b5c4e710f5416d2073cc498082e5a3fdf405df7a2aff305d6cdcecff6a2996c83f4c4ea467399d8f1ac666dcdd548e0ba41445867fceecb28f22c3a012e8c640f0913f414c195d2b70a7faabd1559719a189b67b513019421cc93a1ee935b5ec8e4d94238b6c769336d7d7604aab156d30769a17b81f8e32a41d375311588f98d7063f180781eae741023e627b116c0d4f8eebf8a171dc2362a53dcec5f3e754b70da4ff41dbf5109a991817c2545700620e1fe1d6bbf6e2b32cda883655e9b71a363dcc4f6fea91d5c17b1681f4ffa23fa376f2b687db14e2f0e6d447931c9a96b1da8909ef85b73dac256d7598ffbfe875f79f8920bda50420d01f3861860c48c9296c026131a88c3f18d37c2b6db33a50a6d4b0a1916e3d75a24f8ae519d49073381dfacafc890bcad606d3adf1233b494ca8dee1f9fa7b993e37e78f5afee1e328659906a03d10d2c7b60906d6ff6336d0aaa06123941a5a9b765b479baac36c52acad2d17ad046d24a078bd901cee8359542e6d8657bd551bb7ebf43166a13b55e8a46140bc203dac37816682ef0c535491fd6b8455fb5c99312cdab22b4befd30a943649149bb7fe07ea84a14b9755d41d561e19627a127addc94796aafb1abf517ca9ea24847632294226151c6b43048456f980bc6d585d7dd9bae1c37ba70461c94d09da38e88bd0625baf23bd8b90bfed0eb6a9947616a14d929871fd297f966ce72af910387c91644119c43baf232aa1e2df43b56de03b149a3827f3b3d59f42bafb74ec550c4a8a09b01a173b16c48a3a615fa990c6b5cd40c110e581546d8e70fe3729acdbc8629f692357542f1cd5b12827a2c10d1c070a15e803393cf9bdb3e5d39eef1d22875af48090c8dc021961fd78c711b6c5ad9b18e9591e7aa82b6eca6ac788a9d3b2f21d5571c79c4a42775a01f677b5d590e5d2067dc27582a7083937fd908f81577f291f5abd1525f71fd65e8a9bf847faf698e6d84a258f189fb3942967c7080f630c33e11157a67143118abea63f28613f23651daa491ebaf4c6011453ed9f0a525475861b415692ddb2d0f90d46cf8db8f425644f28030d089ebd325198d68109620d352a9b1dd33d4e76119d14236e973ce9203a8a707e5319258a29f0a33c4e3cda19c10bfcd101e1a68eaa9f7e9fc1c72e841780bebc79443594184f9886e836e74c5ffc3bf72bec968c4d56e74fa309849c453be0bba4e690849bffc89c2c00ffc8ef04d594fe21b9654de974260467185aff2bd7845ded504762886ed03a6cae6d878f706b161fcc46f441b6b9aaae5974a2bb06a8c08d48c63163db1b167d26815be5eb6d70e740ff7f581f4ac6d5c35ca8408b2323b7954be18199418a62b12e4d5a89a8da783114d222622b0b127b562fd93cb928bb939457f1f644524e295cfbef92d6f16088619ffd94fe9c99d94e3f93bf051d0d4dc2f2710ca40e20f90e553055853ae7616c45efad7f7225a8a8fa47a4d0a2e3a10d4e4b2f6870c5cfe7b4d169da5a6baebc757a05473c6313779f0c43623e36a879f6e7bd27580b7bdfe5650b2431948309470b6be14749270a1e862fd7bd276c33d53e37c87a7f4a66c675f39bc38b6acca2bcfc304b687c458ca58fd8bfc4b259073b3ff22039e317e14c0b4f34c54fba211e7f48d4880abc06f0a86b119cad3f6088fac68ed72027ae1831cc0799e07634ee2077958f35df8c355e9c171620c97e814805bb7ba875a11bd94c14a034c47f86e425723abd08a1f813a41c134d6ca3ae5733cd014fd1bfe5b226a975b8139e7294525f75507513628cb9b647e8638bcc4d5d3140dad0d7d9593c0f7f4231050a16738b5c4126249d90d8af590bea4392950cd9c49d5c03f319cf3046d8809cc62fae2fd1f213a226be6b5f3a9d07905fb02c38d4bf9bc29a8a0ec3695538181b1755bbc795f59ea55108db1e2e4e457eb949f9697f0b00d90d536fcdaa4e38916a72214a06e0d82f674a8a3677512761e32606ed1fb67d747757f6c2351feff8be3186323a68e43ce7bb817f63d6ca3b00ec4498f14c72d7b5c291e1e4e18819ed3a1f6b6027af14de7313fe403a70f505c4bef1ce72436e2854dc81648cb4d247bd84e0c5ae1cf70c31dd00769b5c57a46a84f96e0940ba548a3891526b6babc0690f99f4196acd506d2f0c364f9a7c07fb516d4e10cd268586500271747017828132e7a0022355415c76d659b26f5e9f1b29392e1afc8f4296bd56843438b6c4aadec59723a0c85d3063ac6c41b881fad869171fce678383cd747a4b77c664e67cd7d6894754546322a182e70d5c1a933961b8796a8dbf40b1cec893d9b3c32dc6951665f6ea9c33125dc174eca4798e9439c16387e74ce020f9e3a0be077ed98561b88027bc8ddd08981fc5a736fd7aea6e739994db8dbd330161b0a2f627a232309b198e6e477aec763706d674427847041bfb764b96a19fd478a910169f3545d69ccdc733dcc803c23629362a01525bd21bca1236b938f09522d482caa758e42a1c5303cc83f6678179491a7b4e49a0825421bdb959bc5cc52b26a32f4c5822b9381a75f31cd966693c562e6b9ef826364f57a58744d604da96944a61b31eebc93e8adc0b317b62d502e87641ed0f3053b350d0b35207e0d555effc89c6b0bd4e9c432ab3a00c2b4f6784e69aec635c10074325d909f56950983419fc9b2c82a1522e758ec9bba833f2fc17f7cb92b1bb6d9caabbe1ee12eb6298f750f88b9242aeb54b66c7e90851f76954879d66048b2b65f49e14d7879fc17a8e2ad4fcb8fc8b330ad18b4327e355299932a53cc9a136d25070067fd67f311dd3ea6afac3e666e5e7a2a30a12747287cacbcccfc31eaf71345c81fa3e7b004004125d525583d6b789effae7541ce06e0075bea6fe12bb33c9b1fcbeb6ef94272bb1d108a4eebf84a7d56bae59e599081b1b7aed38c42a24f97731134bdc831254a23c9a2302931e405b3d1e57883d1f4554811c2c7a74da6ced99fdd7deaed16a336c2d4fd8b32a9a5590d97620385d2159294db532874bb4fefd2405b067044431caa445ecf6ecc65aabae2911e3f5378133fd535d76e7629a0a2e9e10787fb4fd94a4b249b6eb7b9fcaa029e862b2169cea62a992db0d5cc6b4e9c2aa94bab5844aaf08bc668c7053d8c9d1ba412e89d7e3055b48fccddb360b395bb1d6ea3169f6e0815aaf9e14146c70e8193da6a586730898ec5abded7613d6afbf262476fb65e6a2f0942d9c76913a54d099f008eb90e39a154e316bc902e21b30a3c1bf988bd5c1c8a41f377e88acb2ae6a84c9ba529c44d4a2e9c83b2a1c43e8431bd55ff4245a753abe2b38bf8ba2eccc26aa44f5ed457f53393bbfa50ada2ec224d62f65be139f30bcfdf0468c8759f8093f7f671ca615420ebae78da6afd9922f5bf02c86a8e535bf07d2a8b042b0addc5f69d57679d4086653b31d97ecb818e07599b87cc17f6d40edd7331e595d72831cd9a993206cf326b73e93406354e813d4d8ec521efa8f47aad99ac464e432cd36a7196b930c041067db13922fcb597c0278b122e1d3a61d89fd2d31094869042940bad67d5cbe78b7bf968d40e71a5120326ed9a51ff1479584ca717570fe7a88f2531bfcf0e939eddd8e118aa835fecca1e305413d55b708aee4ef8bc502fb6643f89d8933f80326b1a51b34cb79e3f37c95ecbdc5d8fbe9a01230615f782b51a3a7ea71e5fc5c4d8d0d52d9a47d25a6a2fced01903d67fff2fc9b6b1a57f6834bbef3c839a540b49c23d53eb719899903f827e0afc853c215cd65885c4d7ef7bee051b240f9bd2d678bea4bf27d2c8b1e0008297f3b460f81bfd975c9f8406ecc851eae046d48b9e31275a60bb4af0f294155b2ff96831c7e5473a77ee338c063f959ca204cba72ad2eb86dc189d01660349475a0d7f3ba30342443879f3175ee91c5784ae9533933465f56fa481ec0ff91be698106c1343c154c55c27839f7d24c35acee2c2b6333b931858f4daed4267a8b502d817be99b4e0e787a632eb86d724b5e00078521fb914f55ced4e9778d9ebb08feeca508c28b299cc260c9a38c0b9ac8bf2f55ba55eee4ee81a09f1d84c794aea8ceeedd5d895e7ba4d5e86a734a3f1374122e385b34c8bae8baff258786cca932ff0c377d23ea0f5960b04742041aaf783a405f96cc7e7027159a65192ba7dafccf7dfc4248f2e5a4ab419903b057118d1dfd600d2ec0fe40be0828d242044e3b66e7ac02ec7e2288baf6a85b017550ce2d59e4106d6bf90ddf46419c73ff3403197c8809c55db2a5e05ea83360130ee04a4935e726b8442b8d8dc19d0e511f0431a4fc2102221b6f647ebdbea517258e3854c38ce7bd827f1c4e7e57dec42f6ce3866f8e66a9d6f677d564644cbacf07c04c06845b5085404b4c33583db8331487f472481050807d1c88079c796e905881088eac268d74f9d546580910c24290464c0c3223b786562054c7edb540916e6f24facbcb7099dd0ce05e85e0b96e1e4bcdce3717905f447f5d1fa993197c621348dfdc9b7debfe6a4449bb12cb8e880bb5905e344981b0e6a1ecc33de0a6d1c214f0e3b355ac1024665caa876a736a20e482e5d0ffb587fdece251b17b15b3268337055cd97a250549aebf9f7eadd1e1b8130318b514a736db114d99a41c64a466cbd35405743f6ad6e082f53d5eb37ff4e766b8d58d3893078a9c97a7c60bda4a826a33a1c41606d20e5591a65ec0e2e17ca6e0db41b2c382de148356ad7142f0cfc22c21a106ec1c06b019626b63ce1ea5a5df1529b422216560032262637f25cc7a9cbe14565620ed2798688d4eadd6bbccfe5b32d1793dc753633cf9e1bd15a29e2ee16b79bbd5909c017d53022cb9074d49d12b87bae7de075dd5dbabbe4ca05c1f854c70d58ca45ee1a804e08cfe695cfaa61f8671d4c1f212d351f72727fd4abc6ca0039d0fa08128bcd868bb46066345529bc84c1cb4f3eb3a54ae4ba956ff2524f40923816da6e2486c3f9b652f4218d51c02311ac6bae16bdfa310d1c6e62e2b5d2374f60b1b6ac57e4dda08533614495713cdc1680590ec97fa186721c224876b0f5f066d5e36e928e4c7b350c4f1fd5478066abe2563f3f768c116445703c2babba61d8367aaff5df9aa31b27e90d2283167796ecafffadacd1469e57b343d1bcc0f562a457e95f83314c8becb1cd2680ff9d42020baa6cb985b4ac6b52181cc03b9a5ee72bca40db5b44c5661f43b58124c95376ff97f87ae83daa990dbf14735ad3e2a63c285b085263e1fb731374b0e3d1f968accdc00e7d764a6b26ccddde429f045a38e466b29909cef0091b4de9509d24ed162226236f34dc87435c4e2da02c5f9ff4a1e58d7cf12852aaa9840eac1a941735d075e433bddec3e017660807c94f3430ba9dfde7f8f5fae4c729c2b612504596b4de07140ff8ebd615584b4fd02f5290091e539846ed51475ea3925d12d931988877","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
