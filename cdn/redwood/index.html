<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"4ebb91d345f2ad2503dadce6e261c51ae67cc2e11e9a053dd7a1a5cffe2e480ae1a771514d02822802266cef10553b5077a923f71a493cf50466c5128a29d92ae6c65d259c6e6a028a2256536355693bb96d9e7df093d92712de095fbfe7f14edb251b58957905f7f1d9ffb546c9e781df64e9cadf88d831ea281d47210c27946fa0a3022414c3ad85536a8ce9b9caaa6aab44b434364b1cb1f5da02d39d10e437b8c68f2d71a42ecd283cdc51f7f48139f2a79dac3f05df7d9c82683ce72fb27e3a951dff388217be4709d654b080b5d5c5ff0660c753c39f7f564efd8530cf46338aee284de23306c2b2301bdd927b865b56caa64daf9bb6dd48633d1f3e0a23f657bc63b91c8d7ad0ca149b45354088775347b02bcfaf25b270eabc9b860c2f58cefc6da838c4e52e4fed0aba681bcdacc09297c418f4e62676a0b6337c3642b0dc8755d352e7d445d2e88cb1a793a60c866ea8f9995cd36dc862d75844bba07233b64d5e31ebc8ef785bb5649346ad20d357f438bebfd2061320e52de82296b3ac40dc032a9a488a68ee89cef6004655c7afaecc2b144500fd89be1056270a3cdfeddd98cfaa4d4ddcfebf510ef10b894984bddc2b58c5004a9db6c1d91773ec247c3945389f71eb381c41db379e5b3b46d052ca726f8543c9f91ea1fda4914583312e2ae56a4472fe79315d2dfb670f3cca6df1c3f25bcf6269007f497a6a5ea609a386f1e5e29121fc35fdbbb49590ac7c042e44cc7d0577a557fb7969024d86664ed09d674d5dee34d6bc83451a1df9332b9f9566665355521e3ad7b6e8dfc4fcf9d3514b43342322e1842152389158f5cd999fd4ee04e8bfe901d3faa052b5c38a5d4af652268da6c39904562b1cb4eeebaed0457027f99681cc63b40b11030a87dd78f58807481a2072d82b6b5f2c1911c07347fddfacabc9f787dc73c73eabb94cadd02839e6d88e86d1694c5fa00c00b780e2a5dad507d807c6a689fdb5b81f10399fcb539aa8a094fd036aa11ec468d24c0aa469cfbcf0b5b74742de3187fa19e5eaa42982410e29a8ed2a1bd52a87135a9003514d7d3fc046e215910e9aa242b4f0ae1967ce249540f95111cd5a6c9f58118a78b7e69401a152feedfa8dc4a327bee3206a41075f0926cdd4431ed1db63409e9c8aa15243b898b72a68e1f2a5aeddecfabd6adbf270fa1af2eee58f3c86b523ee6dd7c93f5de8710664fb1a82f0fd88e1f5094cf67f3db052a020d15830a37c2ab4795be5770d18973dba4c5a15f7bbf7cf3436a1c78ee289c256f773a0fae241df703b2a9328ef3ac4f71e7cb135ee46a59284d8e51082ebcb9448c5ba921c82b829799bed9ccffab43c9d9585ef98ed4f4fa94680a9b3d7dd4784d361e0ef7f83c6cde257d9e666e96584f8bba4540e55c087bcda3f4c89a40bacc21c030c4f95331aa7976e6c9c055c4f5b19b5aee45e10623232c0234d290c26f984a40a770c2e56dd5a1c89dec42183ee74be09471fe23beb213a997bea6d37b705a28d52a80751428dc5b12977f54cbe45e0bea55d58229d4f42fbb8f2716492f1943ddc25c419eadc6547db3206b84760029cd2bd0b0b8f164bd0f465db5e3ec24557832dfa0ea75ff5fb430a7fd67312b9ed2372497639f06470e5ef0f0040f0934d0ef99b6c50681c061783b8450fdb4d3506bb625e81ff864355674f3292c4bc419a192d1fa6c652a014dd9f56bb0ee78ca19fd2f016d1ffd282ec2159af1c2368f6ce80f89032e7194bf74da3a2a600930283e34fa3baeb1b5003b0b6d440df12872e76630cadabcf304ed9cefa268a39f99837d86d9af7a7d12a29a0b7ac5e31e5c3a1e315e838257aaef4ee3461c423b94733e3115de89b3841923758a0055f8ce8c1cc44308adcd4599a0ec3063706a51664f776f77b83c9fe447ddcb7a1dba1b9ffb863b23d50faafc176772fe3d2444562b77704ffde7b78a33f3aab427d606c2fa9db7157559a3d52e864c0045aefbbe50ff6435eb213a3400c7c51ea772a95d73f3ae513f463e094cfee7e2e51ebc06650f0569b243d05009a4cced87f1416ff1dd59a27913c84f15ca1363ac5152e818210f204c6052230cc56d8cb39ba836418ddb3c1d754ad455592294fb404093247643d8806c2fce533c8856c1352e944a45c7e9829e1c8c23b165c0c4128beeb7af1e6ef0973a37897f9a7f2f53e75c6602e294cb3509f2f24f37373709ddd91069a27a034f9f0acf1194e0908b3584d9bde1311964f5be95d19c100af90b52bb79e81253eece933157526365bd0c98a5635266f62300ebefac8dbf8ec2c325759d1e85f932c9021ef5d325f88678bfb6c731258144891d61a6d83ddb73fbb71b5159f08960c01cfb4764bc2f5c2624b380efa044de842c671378fec15a28d578c2b92266d9901d2c3934ef0d428232e881b4fdf474055d2753c808f8c945cd8c66ac976b7c1ebf40b106a2fc002cb69603f9f1d8675483f2b30f6e9fa64c7951cc4d025dd556c296ae8b45afbe87d04b9d2bec65574d175ae5fece118132f278ad73529e3560a60379b91a506e8020d0b8f9c68c8a6036e0033ba50e181d3522691231ab1b76068272c50804ba6467b7a854c2db92d3ebccdf9a55d3f55312234ffaea900981c743148c8246631ee7bcc831858fd1d347dd2f5a7855c22a26e6775d06dfab79b8dbe6355d0ef7bbd69cc765af43ad0c9ad1601b38a437231a8c517688a7b0ad8296ffa1dc21cb5b7a32ce112fe4c5d40b461150403c14dd291da7594189da9ff57534c6446f32fb2684a1c50a6915eed32d7391ba5df183c77aba66abc9b18afcffc99b2189c8e4c43a96fc1e57433822d72dc5b34093a979203784683f029d5f6e350d691fcb790b26baf372bf6219de5223d6a5c29c6604ae4fc8f523958bb57ce1c938db01023ccd2e715ded11889e669dd89224da525593e1a4fd90612b9203196bc898eaf61d89b28ecf33371315c915256bfdf9f5988d531c9895032b9a878f1c9b31caae670d3f31d1c8c8d060498a63caf40f1d40a1d786e86bcad7ec56103eb0e98a138fbaf1d1505309ab6e715b03d6c4db9a17d0a9047402c94219e36ab404ab81a3fd6bb98fe504db2f11ddb0d6dbcf0e888365ec57cb814a7f9bf00462d327dc0ffb20a8bdc57eda9ecb41f6597326b5c5cf34c684ce150b0b1609945b6b6e83a4e17b574bc72776dddd7665e4e8688b769cfcddcf1ef0bb6d1dd9bbbbadc959cfccb9ceea5b2315263c7ab94832b30f8f4023f26db28302eafeaecaf25a020d6701523219e7dade2c878f61ca6d29e351b3a966a51388766e18ba4b168acc72fe70a2862b1bfc62ee1e7018eeb4e28f211f6a209362d0ddd749c5d96571294b4b895d746cad39ae2dec3e287d5d1e7866f70706fb70e3d534a5c02306e563a221417a3223e0ac0e03037aa055ca7fb5379728fca57f6705cd2af375b59dcb30f1171d9bdfe657c8ba9f3341b6adfe5eb89eea89b5fd6b13090ad1a2b3747eda2f488d81add3d90f64cbbdad04e4b6a1c19677a70bea8c275b8e309248f34bf6e2fdf7337f80e5888e2694d68018a86370c5705a035b9f98c237e49743ebb4faef67f2d70410937b89878bef3ad5d42c8d0c5fdfc9262e486b738db9f72837b25bfb9fb757251c33aa6669d4c2ab0210c8aebc9d6b5d3993f2979e5d57af53d81ba91d2c70c11077391168528bab03167f5eedea439037a956b12c96c2690f9f32ce75e84232c9f77070d3ac997362be23d141200309b7172e767340f0b7be9661bfb2d64e15d83c27f6d8cb1a941269ff18942f2b20a657e3b0da93dfad7c3b42bd00980adb7897ce09ec257f84dc6aed20281f96e3b0a51f08c25ab5fbf66eae21fa2bfbfca0469788e335fc69236f55182672c894b0e3edbbbfa59dde5bf0357ad1e22e2451d829145a8d9266920465a8ecafcc30ad77b1a1f0a38dfef60e850db6998bb1c53396797cdbe55b0212e86e5ca81f34e8e00d4191371274e5dafdf68c194e2ab9810153d5e89ed122089aad5db14ad78d974c37bd4ac5ee0321741c764ff780310675db36e736c71bfb00389e5f44cca07bd164407f5201be71748614b9e4514c8c80e0a191a782b75effb79a570229ec5bf2825f5a7736bf3037dc143c792c6abc721aaaaf6a79fbb7a41fb933aab793c8a83ed71d37e09efd94854b9bfb636c8232ba6470d52797fa2c90fa791cf433205646045bd05bf232beae38497566bf2fefd38eca54c0de21010ecc0915db20c8dae65043b92173c6891bc238470cb3148fca0fcab5d1be6a338f5e05d989662e017117b6918b18c4d5422a5de021a08858e8279455c49f3a5994ebf9188603c36230966a73834aad9f183fd26c6252df1510849d41ce2207e7432346de602dbd26c6131f865dd2025992949ae0c019adfca52ac798f9b58cef471aab275719e5bc719d42141afee26e9e9a382bc8543b4b48bf8898fec0f3d1a03c984c275031e0d5df9550f5e53708ca6e302930824ec380170e591a941307fb5969c36f66b0931a3575324ca2f5524d55be47b35ec18a5104b9412ea48650fb90332b793e9fcc7ef02ceb72e587b317a04c61c962912d7185d9fd1736f9825aac2fa347461c5579d120c0f3ea86ebc76b1a75528b4632d6f4641a30f553c83400a849c899eb1bd81801caccecc6c1b1d1c38d58a81b1ba2d358ca3aae3ffbd92281c03f524e47473aece28013169880bc429f5196e3e0d4254302404e4aea0a8800a4938b687440c4c9b68b0ba708daaea53eeab30e00e7fb0d1614ba25aef36d06f66eea25de004a410e96223064ecb9cb9aeb5edb880a6e4aeba70cf6ee87f6d9aa95008f7f333e358107e06852bd9896bcb0f04bef3121ffb4aabeeddffaf23c2107769eb0df8a124932d94d4c05fc426d420cb60ca3849e14bf865bfe3a297b3d520801daa50292af0ae724f325e86e687ee7f13769c196c2fe6515c78519911592e08d5be0f62acebe453a7c15369b86e541ddb2551fc4baf8a87b053f60a73855f828d392e1dcfca9c3e62c226e0125b8bcffe078a03fc00b838f5005c02f838d0250f0148788077a73b61600b99c8c208c2e71ed85d6b03b2470bb26620f067c010591f6cca07546e6d3d43a341673814f5f61800c8c59f94fe2342d38a5248693e8f98e9a17cf324962a5f1f1aa1d136813273b217346c36164d002fd02cf60bd5ffa31950f41b3d5dbacbe31f1c886e95b43b16b8a9878cdb78f75c17eded733122f691fae89bf27279bace1e37d47f4827a6aacb1114d4be2b0c68bb301d40e7ff2ba657a761ddaa4109c62fb811ee79e5dcd8ca2bdb7676b920b9923c9e0710de2de6ff578a8d00713c2e56e6202e7735396da918ab7bba03f66db985de9ccd151b1718905db809d7672f296d6c997ae62924c2acb82f9a0d13899776841f2f8e47c525e9846d72f493af006e47d225662f65fe122cf6f82809f8840d1aa9d2e1f4b368fc1d734c1953020583c762887300b5a2515a801230c9c2971582c39730a403a8d1cdcafd670c3c7514541b0acb2b76a5e2154236413ee1beb37a1039e6a216783e3858fd86875a82945a8fc4ade88e75a074b60a3657733423536a3d9cb4968aca0bb4c42fff4503ba67b7590b883295d1ba7e76befd3847321732a86f11e5c274b651093dbb98efc9b0fb5592636984d9be57f75104120619672b88944acb263ac09e1e2dae0b5b624206560c9f66588c3adf06c7bd686a7ec400393caa6d50be48e7ced3b074c6da6b37b8e82151a0b6bbff1dbd4d6329858b3253a10551a7ae160c94aca540774b99ebaf20bf335d3e8b84697c85bb3575874106ee8c6c45aaa7d56130e85d529579eb345d61fef39e2c34bb28ab247010d22ead0d09f7af0406af9d6291d3c0c2365ee3d44b5912ed7c1ef236f2fe5bc6ade7d3449a9773da9dc46a8cc38270e8c0340e12d7cadc60c21be7151d50a8e8f8412996dc8ef203e01e91d87a27a0e062255d0b6222b022c3c68a73a691ef2393b72aab54aa1b7639206519f01321934823860548231f65408a1790330afde5f4d6ebd3cc45fbb9fee945a15d17d33a58f9ad5410c468f773c451dc5c2aced27bd9bb14cecc932f8d597b190edd1d6ab7b26a35b7726433f3d101b845decaa9e0c86cd5b93ae1982dae914c2daaa6be9533442d2bab9a98e30d9b558de809166b981acd3a01fe29ae8500a70ed7ada10645aa1ea852a921d2419fcd3367231b332b0ffa8182fb12d0bd17adaf2dc8c402f61b677838bbfc2698ebc2a47c58b552835a70e7ea3ab38e196e6b28c7655690a3e34aa415a5c80fa7975f74df9c60f971a3cc4006f347f9b6f9b3358d9f945ef687c9cc745afa6cf2d7ce866a2dfa674ae39c88ba521139ac7cbd16875d7632d5e173345343dae1939699e21531ede366da48522da8c6f6b1830f8b34849a73826814285124d7bf287d9f6efa263272dbfd256bf425803d2a7e38d890d9ce3bcc8eb858bc9145e16ac7e826342d968e3cf2f6e2325b3109a73f1a8ca17cd53a0b3ec2237ec9798be8b22d18c05b2a84860c3d84ad9a886019f9613598b9bdd22bb04c9cebec1be172a5babc0fc1fee9bc90b2673071ec1cd851f77f187348de8442faec9a7d51c78d8a3050c359366d2a172aea27f0004ace94b841d57dd3b8df6805fb438af070d7515ed4e7a793de53270682cd35e1742a7550890ff3cc9d5faa974c390371b9d1333dcebe123157779ab7d92117d7bb4409cf2c44a205179d20ca21e3df43440f94443976a71a5b61d82f463af4e9a57b74baaee01f59297a325fe1af08b07c76992dce4674e055bc4c74e090452f4c1288b14777d6c93fdd3c9e0828f1d9d89fc0be539d87ebb826c25ac36b78008bd8d0a07c1a225274a51df0a8353c51f84db49da08bf0422d01f142e641c8985cc48be1b41ecff2c0b473f445d59e67a7d90a0d79632ff74cb307bef661d727efbabc24dc80bee55dc605b4f8189975611d983fabb4f574680d05efeee99504ae13573b00ae472a1418fc5df465d056aa48dc805c13db6374f8027831090e41986003e1aff835f55f71fff8a9e904b22b6eccc1dcf8b759051ae89d00ddcee0c43d5134516f0f9234d7bd1c1efd32c47c30ae181e90a2305801d0143f9650b39b4c8d0d4482e36536f0325579a9c89aa12b7a87bec8062d42e2c2b89ce3546604cc04dd85a13a778e88a48ee7ea45111044ace957c0643c81c37b824a77805ae3e0f3978053eb7c769e27d8aaec0755d6ac0ed89c171225cfc78377cd86b428af5f7bd58c729e41530f052fdbdae3b0aae45df685386783bf58131ff2f924ef76e0882668fdd80a0f861cfaf540665895f5c76f62aa7df80d768c519eeea84150f25c986bd6f23e94497d898d2c77e040e3c4c7b74df2479247d8074f8b897701d0f0ba483b0a68d6bbaa6b6e087ddedc3d750133d6eeaf8399f5e7b71b0f7ff5a8acb3e6c1355d6237fb84be30411555130819fd73278e9c070c7346c3bf7ab0306ebf76c5a708b2bdf4ac60eea85237f972a3ec731e0daeaf55eb916ce6e0b9d9fe727bc0e1f90dae7b588621a4d59671c946c8fc0f714d6db148ea3ebcc1726937ed75a13ba6a3db02dfc0577d6bb5702dc5318fa93433c5888492d58ddb1fb67a6664f055dd9cb241a18f6df97b3e3ace63bd7df497cc25b3db19e209e8e3ff6802a699b02a0e167568737332a92ad7211387fa543ff44f1514891add936b5224993794ac3dfc658d8ab074968cd4b0c4e44a3a25cb7d2564ea3b8f136025e64f93388544c697074e3a1e604686d577ec42cd986f1fa7c1089741528d0e4b9cffe4b1b5dc89b9549567ae0362c5ac3ed4c24c9cdc17b8aadeac0eff7108ecc6daa71496dc8baedc69caae74998e3a8e65dab7a777a6fc90e7b09cff9242f982b60cec1d588485896138108566b115a33f3dcb10d370aa82e00b43e8b5063baeb514863fc592f2ccbb18e93c8a415b67eb5150b1798080324da6779154850c5e50cbd8e0d94dbaaa5562d090920109b55e848e6c3e3c26846f78da450fab8055e3712e1ca69c6d0c57b08f12ba1549b7ecf7ca6d15f29dec906bbf658f1511a6376d5d830c50204bcced2be01bd899334e8a2f75a8994f9249505a0179ad2c5022646edc065fd02be8577ae4ded058a6fc58b7d0236b5a64d1d23907e5f5f439a980f1e58d9445fb797468fb6350d1ccef42309533737f8369f53402a6049722eb6915d2f53005ce707ea0e75a6ac9ad3499fbaa9f587f8cbe39c3073da8c2dca2101718c76e6e32b298a38a4ccbaa93976d49d139ac5b20dce974bc7772c1753f6c9144bab4cf04cec66987df44dfd5053da13a9b5ad0c3e89a650b0338a1a3bc7ddfe466296b5cfe4ebe6f114fa08287773e93bba1fdba44dbbaa6e2167245aacbeb06058ba653d9f07cf90c7ef04f0e94faf3b8b9af52d511d0f1778c30ffac7b45a14aa5969eace6ea668fae2be2984eea1805a854914e1225c1b789c83096a625328fe483ff65cabe2710348797b678785434780c3c74c42aff15d10e19b3866f706a56e01666dd17cec9ba654779559c4cefa7d66a0b4be424dc6c30204858ec76606759dd5e7fd38a0743088c72f8d424e08a12147e9ab2e04c2f6781e2d899982f9b209a1a052cc25193763b2690e36320366eb69271ed6f5f0b814e0e1e68c1dc4fb9e181fffaf68a03b95589df29b5e61a3316116ae009feec8e07a44de0c749f94bda39236f43e3a2bcabe04af3f1d25ba71b3b48b5f1faf6424ef2d56cb669114f4d52dd0a9408bdfa57aa8015002da60b864f31e9b22ae0c8d7e28ab1c122328537f0f8f7734a9ce9da819ed4599b7e4af089aeec1f8dcb4a158e32e130515ffa08c886bff459f5efbd153a9f5b7044b918152c3b9c51453bc93e1c238759b67dbf795dcdc7158eba55acb6316c58b3f8f74e2fcda5c5d978c910e4f247f64505370770f97150818463f7f65b1492062d108373f054df91ca39276b6f94a26cfeacf4e535f93f57e7b48c69a4320b5ecd2362dcd3e8463d6e8b1060f39533e7b04d51e90c8071f770cf5a7ccf25f6f4a6bac04fd3b5be0d0e2be032c8609c8430df554396f12816ec69ef7e2b019d2a42f453093946234b86c41be070bc69aaaccf03eca5e459cbfedb9f4578f6b4a3263b365574d33d9bb620e946bf741c2414282443631a19f3e3610f453c742fac92eb8468d650e35e2296fb3d244cf8bca0d83d395b5233514f182a1ec1f8e3e2fa38719b9acd6a0f72ef2d355b9a5b822bcad7ce7a20a923ddf044fdeb3e78f94990b969d9ed6c8683ed36f70242a9bc003866f64df3c21035fd07081c7d99626c44ccc59bd86088805215471f69a81aa785ac483d692a1032d68d018e621946a173c9010ae506e01882d4caa3d3ebce421553d23a7eabf829e1f471ec8dc4907199b9ef01f48f82f9ead6cc36e585c1b015a2bfb0a2df117399d15ddb1c2452ebe6f61b746db28374152c643d78331097764be5fe93aeea6a3151256b9526846f494e5d4bc6b858b42c6ee7d8d869430258a39079b8cf8cb758bef3732fd0f844b16eadd8710ce48d33e9ff05cc1fab30667e7a3d9545cfda3719f35d2b9633104ff8c1bce598d46623957d25b700037efb675f72543c61e0f3071df93de4a1e556aa9ced9094b677ae14cf22954e92dd509b1af6995466a46180ddf673954dffaeb2c4e41333a60d1c8d765f248c9fda0a4559c5893c66f8719fe1fe2e701c227e3b5ea3a98c600e34104d32563912a8032a1fe3f4e87b14b083dd20b52e51236e1afbf68153ef2f316451d97d5c23f7375443382b18624d0a544399a4fb5f946e21c918899617cd19687628896c7f7ee77ea481433609b0ce1fcd38f47ec506333a11a6b3979b3e0634abfade7c51777f1065262ca32a52a3d63dc7606ba822ba62598b88912d9c4a251410b95a8083fcde1a3b79927dab62f909abf9e52dc0b5af9a0d28a8b5e6c466179421822183a6fd5926412436f97461ba66c96834e45a061ddb655802a22799d58e10b4f94d29c3994c35afa43783a36371b2c4b9b7418e0ec86da98996c5bb2db50aa00fdef0679c7e177df6679b49b07d33c88d9cfbb5e8614b0a5a9729f7a0e26373a1155c8cb174970c310a870176c94973670797d9d040bd4f54649ef3803ae3b289eccc73fa86699cbbe5839c3ded14222b36bd597e53bf57c630fb9152ed3cfb94f85231d6d419e1bac352d0f4211526ce026754c321d0156636a7a94c441464bd70b8a017dd27600cc3332d13506e3273a694868971b4781f9bea113b26664ab18cc8a780308ef86cb5b4ca1af6bfc0c0df770c885d9dd2aac6ae2913171c0c16a1a7292d8c8252a6ccaebc038310122d2e163dcc5f1ee66636ca79eda16ecfc82bea28ddd4b42017ad92476f6ec3f09ce5712c5bdb3d2edd2089e5c5b05e148c452e664222262c037b697844cf491dcf0c403fa6dfdf79c61723b1009a644c287a7617271edad8643bd56869c90fe379ab289876c5faa01fe9d878516eeb4dc3f6897c93d6668d97ad46f61f72d4d219571fe0ecf50059d68428f2f702d8d585cef596fdda2a29c375a1b92ccc5349a0b0a2c1e2b92b77ab2784d09386a26a15531dcdad35b5638f7a292800a235806d0ce48cf2d252f5df8d195fa758aa8e400c3369c45965d4909dbee8138ad910a2f80b04ffe337b54d654afe21d81cbf7be5687a5c6a443dbc0f2af884b9a57a6b314679580654343fcedda8e0d7c4ddc2812eb654ffe9ae52fb6cb07c703fa6d389167d45f4129657cae5adc7dde85ca64a9abdb737880273b4dc95a91ce02afc319fa5a1226a00f71204c43d37accd302a7f91d2315d9809db90eb89a24f4f1e678f8ad3ca3a90c1e609a9f461f99eaf6e6194569475991853b99c2442e2aab7ef635a3a72b4bf54dc3621594516134379a34f735248a2d7d2adadf060bbf9df2fb7fbec6ebc8853160d95bc851b598b865321b97c4285d3c8c5dddae748c94693abdb6b7a3133f182f50150348cb87dc416f07dcc54601b86612db0fc4be57027c4fd49e26de6e99d973eb36dcead8bd814b6dc8e2dcaacf98ed609239da75d41344a71525e4d50f45e21daa20b4bda8ccd3d33227e729c9d4207af6b446fc6c05f8dbeb651d31104c65f1b73488f92f7537da9a1b269440940192f0cb82d657a369e9bcb08a40e37debb9bf07ada80d91436fe8786064949aeb66d197c940bc5907e5b0950b5c667c2d0a9194fee821ba1b78215462d275c0f8b4c847a6429b2b44b38d53193a34f014d3ba719537ef4dc2199d9be159f56931a521a684b3f7e496eb25d9b0cc39bd85a64877bec07de759db841d46477d654c2364744ca242e481b63583e12580694a70c76d39fd396fa2cd8e007b4cd78b4c478177af07d1493fb9ff04369c200f7a4200e6f055041d86a0631be26fbc006d56df59f63d9b33869061b2650ff3f3365362474104e574d86b778cc984ac0a3b5d08b64fab192dc73e79befc42f2714366a788b3d028f6f0c0a304bc233f6066dcae9cd689f954cbd0b4bd17427b35b58e82b6ca437191567496f7c736a040f226b3a25c7003df6e45bcb5faef724ea3a3960591b99b769f1dc39bfa488641f857a565aa949ada37bdc2dde3af52f8228ebf691acb6d7d02fe1f40814dd6db0c006b91c0946bda4c05f207d5240b2ce8bb5eef3bbbbad0ba2887d46b9ddb079a9e7a6042c6418f425eee19a066071777df35b0c16675e5d970152478222997309c8665855e55125ce33ca3f4b099e78dfd1ad134f2b5082d66743b86bf98419e017da052e5b03a83d3d8ebfcba98f29bb7169240e59cf8bdd785f8976928be51c1c7872a87ba150cc8c80443097afdf5be34af8756de4d15b87040f541a0d337a17ecfdade9620e15b722776b6324ba387ed818c1068ff5b8f89d1ff0d6d3b895657db35afecbc474dc4a1169ade9444210851e7eae83e45887d61910a296e5a4e33776aa97e4d89def8f27e97ffa1b7f08668a73b773fbfd7bf85569debeb336cba67e557d4f4599e68af64148af80c6ca229005b2b7340e0bf901311c06da22d8505b0b554d29e5332c814651c39599b5fd1a1ec3e5a552cded20cea957f316d565071730157bde418621eb6bfe4fda04eaff77b1854baa7d02be96118b82f0fc1c7b2964f993024dc9834d02b81b73c3a6929d94fb684ded5931f74a59d0e19380a3491e2ab45c326faee7dd7480b556afd8905c036432240133044efb76fc27810b399680b9043f7df394f53f13ed9438e63b3940fe16ccdb0ab8ea9c7c82b915b42456dce194f89b0b711c4d3c7f17f3ba8490307f6fce5c6e79add83fadefb7ea0ac440503f028c831668743f48a9f1a3b87e93b339009945d146379f8a6fb4fd5d1020a0e396a8bfc57cfe99514c1b91ddfaa96cf2d1d5982cff20e06421f289ec58ee37afe23f51e03d99f3285eb96bffa8764dbb1e3f0b269ef3180fd6129d9d6119b972a24336e35127787e33810e9be7a0e85bc62dbc03b6511d925875ff04fc6dbc1e8b83d11406a181b3d88f0b3c3e880efad1d502ca17544eab3a59a82ad21aa1a981d61d601414587ed7412441ba0db4c9408dfa8fcb82b368a6ed535b082d0713a120502a18823b4363543a7303d138d6f876d4738ee41a0e689015476288bd31b9f08226a63ba842d1fcb3a436c0c997c5776f5a39838fc0164eedeefb1762c25a2632939574ed0dcc5c870b850258d278075adb9213c762830995f0c838b6c1ae5f4240d9a1ba8212c0f9836eee2a001892fb1186e3dad5286710698990df06a46e1cfa17d9a72f6e247e89074d53381166f247aa0c042ae807e2a7ceaaa0576346c2e0b05ea0c7377cbd8ede3f289ceceea774e3c0d64ddbc5d83529400d18c109574df9a6ec027e14996060f55ae42686ad14da957cb41aaea5216e47dca99b43620eb72a17e15c58314c4ae36832a2a0b697ad27d4c40c4eef0b18ef1aeb73289540c7b603209a25f46fbfccc4616cbd2e20e3f95052e1cfe4273195c426c63fb9ca7c7943a66ce6d7fcafdc39533272bc4a6ffd3ea078298059a1e14c5c1a8bd0e9652b7af43fae691d3897a79b6eca6179ce2bb732159c236a6d3629dca2c6ca2c7879b9c6e5a459f444f1fe2b195957aee25c573bffadab4d2b2f887f93fb435addb37155ad7909e39c44b31eb9d697e25895090fed2cfb58eafefb2655e3351bce93543395d528a57a693052844a531a2f4214d936681e4935de91b33749e585a63c0360f07bc879225f1b4716bf2f1cb812ddd6f5d2a70d1c92d6cb97ae8a3456b17fc0a5660fd53f11e0bb67da2e0824bf801b18e3db9bbd3c0f4b54d08274974cd547cf9c6220d5896e77b1fa6b8e873c9d5b728c80f69d24ca6d199956c4b74b27259397b1fd2a05ae9306989afaa057bd0f6dc7b0ea2688412e51f81eeb29dda2136124b53cd2d8baa60947eac4d443a7e7b772a135b65284fab7cb899933e1885c2837d4d2084e4b9e60f1f6fae35896df1b62d15df72cc656a4e59067765d8e5f43efd300cfb3f92db7fa565c36e38990c4e43d2a65d698b5863f13721c88b2d49180454149a0bcf74013e54caaa6118bf46b3f85c8b156aa9d3c29ae241059bc44025709266e988d98e2f5f91709c25c048d30ef0e0cf3c17fd04fe0ba53c0472c3f7dbf03c522767fc944be5851c896fe7c4346770f4567a49c1b3d83763955ad3c004d9b851ff17ce7627bb8bfb855297ead9de42424de1dcb9ae59b44509aff64311d448fc43c202babd37250c246551bbf895ea86738c900ddad16b9649b08e5245f79b771f7970063600eb0fd21bb8e3b0d14be4a10ec997eb1be576a01d7c52b75b6a085ca7879c2b7a48fef0cadedd244835c16eb41d1961f56dee9397d8bd6a45403e66d6a0e808c39c4455b7baa7390795559402b4040ce47889c224889c373427f65c6bf874891fc57384369de54afcc91bc5237b2749b7279164c19060db9873d64b79bf8a8d3fd191ccf7495dd853f6ea4cf05a0917a686fe180133fe467ee39ad5825c7ffcd1c7d31e0c48733ff0edf0fdb83b3bd727872c97e76d563f93120b7357c7d35c17544a0c47918c57a31c4740f3d88582d06e3a74ae7e18bb86db6b22b0e323fcba9aaecd4b79952c82c849a8da06af93a791faf48f1d35137e93ee2b97d08f02339da8c3d190cf4a68ccf8d23c9ce4f5d71b0e0a74ff550146bdcb05121832cec4730670ca26d93f8e101fda017d23081d3eb4053ed787b6797ed61fdafd0d1793bd9bcbd88db217351c8a080adc6bb5760f00a7887f8d93e791d2cf493b2bb39515cdb2b99ce25981e2cb601a472f6b45db2e8304122fd4502e710e2f2e4a2dfe10ffca2f12a69272a3c0b50dee7db9e8906727ee77051e3f7ab22bab24ff97fb56bbeeaa96722f0533e9fa6546c5795ec312631d0fbca33aed94c6d4b56a83c221f6d37cd697051b333c4a6d075d0383f388ece0491214f13d863e6a681f7d92b60d7bec7a84e813505d8939d5ccc26ec068734b7470bf3e2691da8f2fde57d625166e1f78d0b50a6c5522d1dd797ed4a33b4afb83ab23e2a4e305e2224606581e1b06a548b7d767db1d274c75339aba6a17c32124fd911e1bb6ebc1a741f932dac0752f154363915683dc32b9690dab235350fc4efafea4a89f81d6c3cfa50fae789746c8788fb36bc1df5adce1abd657745e24e698408e16fdbb286636496b5b5c72130b399e6e9548600a0c32decf1b6759af12633cffbfafb17bd2409073b55e1c129c03d421d203111282ae2ddc6268417a47a2f0ceb2ede2392ba147c3a7bdc06c358c0def6bedfb0d13e2c9c97722bd0a53e471007ad4b69683a941ee3691b9936f10c6a141a8655553ba3fbf246362139bf9dd93d322e8d21bc92cffaeddeb2561fa53febdb1206e721ea51f942453eeacda926143033a7991263bc101eab3edab4a592967a144f2d020961d4e84650d5553e5413c341a9db9972a04a1c7f7bf5dee62586724ae92621aa6fb884579f3dac1b0a94330af58614d98ec59a43847554650e3cd350a7a9b47df05820f1a6eb0d6552e7e0f71968b4d0dec8801a1fa22bddeb01324e5e12d12db4667d782eb9d6a62229a4639b17d0182516766021275ae711c9eadca845ed9b96be19c3d149c056b06a0b05d568ee7753bdefa15eb6b2f3ed4d6ef84572ee63c57605dac71dd2edd0b9badf5464d0c9d289d38c5caf30499d0826d0a55791b3d8ed912732dfe85ee3fd29b2d1521b915f2876e3865dd27babc538fbd49be2bc1bda202f13940e72d00fdaf084a6cdbb28154c1f41c4ae96c5180ad10f60c952231539cbec0fab0a54b2af606f4ed51a66bbf5fa62e4bcab74303251a36ef9f4327eb8cdd29907657e80b71d9d49f2647ac9a9adc4c3d781898d7529f980f411e5a7fca836c9d87f1f7808480b8c002ddcbe9bc673bfe85eb2ba273edfb24339be4c76fb5ef78ca77dfa45b8678b8987065acabb085d73b32d77a86d9c4f41b4f5c31a6416be4b937c771f27bd0e1d460357b1bb205bdf659344c1d11160fb333c04e4c9c295c5f52ebb4063abd74c919c592f4e3da6ffaed1d0f4c7d19abfb057d35dfbccf7452c974d5e5a170e01622cc64528c2dab50af2ee170676fe03bf402f663c443506777ceb8dfc7adf97483de3cde068012fcf8a9520bf07800bf501f378be0000204feb0450794f89a6d4f337d1ec260354aa1f98d128ddd99569effa02e591bfad2520db2410e2bddaaa0b1931ce1f658696579991cc6224881fe9e689df5b081f50df74667b3744c5b398ef4d661a6bf1374e64cf711354ec6704281758178f5cee0c7174f27c7ce79a7ef038711c59eafda41d393d9d7d255c7814022b4da07487d97fc2a675535973e6c0971efe4b319220efa6981e5cf136a9c284223c2042ab4ad6a7944b42c6f0c53805fa08060e42fef341825f963b1992f788064d722f7292d112408ab0f32d55c4a4cebe1384704c4c3e644763bdc5b5b0f5fa6172776369808786fb2944d1f9e93692e08ccfc6bf046fa449486ef72291fd0d2be863ff27b243ddd8c58703edcecd5e783fc012c78bd1874b219060d91b5ac78e49a61288eee1b92777cff49d7df5afcf44851a94ec122baa85370dd4bb2e6bf0aa46ce5400cb9bf95983afbf11138c4714d4b9c6d558578468772a2147ac8a12840f934d7911f20ae1db9fd5fbbe187879db6ebb195ac00b6bc1d3be4d191d9494eb62de27cdfdbb490438dba3f2eac5827fb606e1a06d7d783378329679500f248c28dc8cdfc64cc894f6d15007a5e5d55cc64db28f666ea388e472bacb92aa258f1db826103bc0bf87108cb908c5e9c8347059f45bf202abe3eb38a65f0bd92fd0d311ec1c62e9cbc2a87d462e4f79c7be550b656ea2cfa3a752a171d24acd41d69bcc76c8cb1114599b140af38fb762d1db2af87433b29a7bdeccb3dac7c5508b280b86914a9558663418505f2007d077bacd9b412df95f39aa101d89465750b23495b868a1e8bff7fa5911201f8b135198017087126ed209c3938d5ca00c71bfb7f944c0c26e1fde2cc1b984758f117963f341a0012b6b01264b5fe793d085d6b3ca19eb60efa7fd3153f2280e34fcdc19c49cc1e5d931fc956256b6321f86459b7ce47d3b4c5d9499aeae2ad5f4f975c0d7c9417af4327e99d62aeab978483e399a0644a38f6ad46e25e04e8df720629d09e2b441582eccacc3d655e2cea32a4728611c083be8c38b42c63c1bf62b96ce800fef6538234ab22ceaea7aa45c08a404d308acbad20297b751b05b0821e7fdc8b617eb4a5c6f86bd769f70ed03c1677d1c57f1edec1baf9a36f622c7651a75d3edb065b071b6343353e9b2ac1f16f19374a2a9021b39fafb06422a92a96da3e6dbcc01ca0a42eeeebb3b6b46ab194492ffd5f9f90d0c35fc885e7430a84710fff4c5c6c409fc60e7920f72d8aaf4ee38ae8e8487a45cc2c71de0b7269665ce0a643235362e8a58efcbe63ec4df8e1d0d6a374118518816dbe99d93ddf578389a68239ae7d0a496dc762b2acd6857d488aeaf0978aa7a8d20d2001c7f075b6d3b997ba39f2f875c75c7755043ee5a6d98858cd06a1b341e5769564968fae2c01a45acec692038e06a23be5dc3019f6ef9779e8eefdb9c86b2bc328014cc5189f7b3a32ef29ff15ef86786870e501cc2b2228938eca61568e1d62a041f6b4ebd2eb7a2aea1ce4bed467628e1ae669d756948aa242cdce83c1dbe5cbf250ac97a550fb6f0a58153e8d0da46b0f4de4f1798730832593aa76bc5acf92d6ef369e3b02bd8a4e8b5230ad3468dddb2eba35256bc0dae272475085a2e1da40df92f82b80a6e95f5b6039df5b16740ea9747eebe1f473d3499eaac7cd984a7f4079c76ba1827f89bbc451cfd09de789de5c2b3cb94d84685acdeb905d6ff8e11a5aaad457e81d1d9926d85bb389f3d96b7b9c52636965a82ecf1ceb5b8310d8c8a3ebaaaa74c513c02240da7a6ee5dd7578ada9ff79cc9c14db1fd874e6f07892d217f773ca1c0d339e34fe70f54a88e88864c69c903e7df22208dde63ca652f0218efcba03f5b6bbcf76114231a87ad10338ffd7e8eb80e56b24287520e8bdf5af5de0418aa5bbbf5b8fb23c2db5bde2a2e18e457ea296e04c22407bbd82154020d4d637a077bc21ad82e06530675eb5676bac82fc2caf2f2a60f7ffc22bc1be20401cf4efd28e75e8296a403505c7f0df1817c1488105f3a57370143d7406b1451b7810e5ed81347cf7dc9c14a2472a2b4f19fb14c00e08c1d592de6ff9bdc08d3882f106d22fcac7185b1cba5bad220ff83c00fab4ab5569923a7ffc67923edbd38c5efc076431b4061f663bfeb8b02ff4b753d18c46b3fcb6449804fe2f66cd1fef8e733580954b28975f819f1d88fec08a34b803e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
