<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"795de4fb8c3a39b178bca0ac1ac26d98b9db1de5a004d351b7daae172ee3a072e335d764bbef5be1f7865baab098be7191d8a07b82c09b41b359e3ae5e0118645bf08452bd0d56ea72dab87145da54c39fad50a8dba3abc49f09260c3857d9ff493a1cc2b93998cf612d56a4716b57255adb6babb44255053a749c6a73741a5df05426c35deb5b475e09dde530cae7206e42f0f92f29ce24d841020ab53e65e1f4c14a41c646b212e7f9b955587b5a3eddba432e98461cd287388d69a74faee60029c77ff67f0d820358db0103cc5347aaee666fca303570370127f870736eff339707f74186e5a1f05e864b9f536c24b5569fe53a091d8f327b0c718a4358a71cbd4f65481da4d60b1319be240326357d5cb1184b6c6ae2970f455eddf75291505a6d9dafce82e8a09ee21a55db6dc0b3f88446f5a4c0641a242ff999c6af7a88dddbc696f7274b078e7724f329d98523a011eb0ad7ab9eca8f8ddb4332c9f7d3ea8f2f2c18ecaa4f94f36aaf4affa1100d9a18070eff446b57ec841a6d495092033d6a5515401fd62fb395148958fba730511798091184cee4a7088cff1614fe490620b7747a26ec3fca61ab0b8c42070b2dd0336309ef5a15e7456884a9f07a1ff0d8360251656b73a58ffb4a56073a28920079f0471b3a5e390b0d9f7907bb50ee99148e6ad1bcb7c37f014fe1cbbe52c83aa67a491d1032df6b4a491319c7653d2b867caddd3c5b2a4bf8e81b4ab409b2ef93a44a8e39a11d2583783b5ae1678e576328de00d8942233f814d8d35ea2a9f5d1547f69c3bd076ab546cedd569e9da429e0bb0c0fc37a9189524021244e11de3426f6c5621ab785c913bcac4dd0e9c9c1eed6c9ca90fb8c30ec529011e3d05b08d90dfa75c662c99971700840e272d5eb7d9349a66bcbfb4b27c835939f6a8b826c20ab96bb942335876cc54b75c4139ffa7503620296fb11427d7ebc808f5a91c09e0f4beb3522ca188570548ada18ae4cdd98f5ca13b5c4d1f66a63a518258a1db31fcf3ab2d305a45ee1ac88769ad94043166fcc71afbb754a9310b0dbab84315ab0f6307bb05aabb351c09aa884259f5ddbc98271e0e3212ca58fae93bbf10f6aca4ffc0c2a5ec6c9f10d150ac908f2d054cd60ff5731d014f84bd110af4fdbaeb97f90387ecf89313721af06b80e4b10c81d469c709e9a850c7da00458b375124990e677c2b912947ece61c10c3d79749f435f03d7e2bc56e34aa6955546be83f04d08bd773119e3a6cfea0498375aaafe67cbdf67cf1cb9b46fe13b8163e9ea175fc09374a5e6a90f35007462a1c7ac98cb52da042c52404ce9843243e6d02f6d476a2bd98f8b3e26b86fdfc570ac32952adaf1177cecfd8f322dd63561c8a8f6335d276c9fdac5be16dbc21e3d3fb75c8dbe97fab6c37d71b5e4215f7422fa7a9db1c3d36b23e1e23f51d930eb92cf8bb3391d991311ee576e709947372ac58641f6df46985629b79eb2218039462b08dcb6c6ce3aaf91a079f5990530e86e8c5ec8fa21bbee1177c05f9a8b8ad0ffe24f7e8b6a39e21fce0b797e1502bb86ef426474ecfa150366a109793c0163044303095a911a87a044b06eaff3a523b56b7a29d1b416b73d1ef072be715c0f1e64b7fd65f3fc63b3c970347723124ab0a7a5c0c31dbfb449a9e0957d6674f5119687d2dd070dc4b3c492f465ad86c72e5a90e103427536e3dc9b9a2edfedf2438b3cd1bd715305ac8f7e5bde4e638d05490f55da119035dfac54e1f53187c3e9134024afa8ad2f82655488cd038debff52dbebf8a35105b0aefe18e825a4b8e05ec914a64363f9cba33f582c8f1b2c8b0a554620e62140177b350fb93950d3bf7abc5acb01fd7281516345d12c27e285d8c7c4e6979fe8992fa29f885c7bc99a76fd027a33ac1134eee71eb20c788244df4986f5ec7afb20c7fc0da8b391464b9c67f9ab3958438ea3ed5df4eb6155debc0282e0ef261f6e95a1bc678c0fe8b8b466ec908ca66c5f1f3278976fe51624fe97fd13e4a6841e53e68337d4eb94ebd5270516de8e66232e45026d4fc5d2532fb6826f8b3497fd53cb86e5444254ab2d6cbdcde30c90061393c94f666a13658d34139aafa424a2fce152876bfca2b5f27fb94ded7555e6cd5fddea72d10b8eaa45610b6a3b069f036119cf7254dfff840d26d1e0f27868a277f9e208fb9fbd4495ed33ea9a983db8d41eec615ddbb3c5e711c6b598111cb57ba5f8e583bb63bb271b3348dc11f043b8c6a06df844c9e8e49fa20df790b39cca9f807c96acf8f56f1a66cd952095260e9b3571f9094a03bd087a20fa1d2dc2d2a988440da06130d7da075b513c86517c3525d34e2773aab066fca063e6cfce903906367d5662f9ad133a5b274684784544e458fab051793e445fef0f31dae0b09a151c6172b1151a67c63458254dd01efacd8ec401c347e314244b44a5bbf6998311fa932b36bcab44d49ae19a2af42a978a0ee5b791c8ee4ed06f69be86ed58c260e6c60797ac2fd49573598872007d032b0c2bb935103a481f55d07cdd48b366826624da3fe00376bd79b4dfba1b2ec2c58f84637ddb5d95e99fe5641a95c09addedf3d3deb57497e5deb07bda2ec8e15fc3fd2cb79467a1d86c11658ff463d029eef3dc5bb0c8300e987d013fc0b15f9ea2bd504eb3c51acc1903bed35363799ae14d0c66db53594c38bb6a2ebb6c4ef5176f032f529d7f4e63ac5235187ec5d4b7de37a6cb0b8282a5ccde66051ebee4e94c715f37d3bc8eb5863a5b5faf71f62b689186ff31116bca7840926c3db5ae27445fd0d2b0201044ada49aa84fabd73f2248172f710eaf9602aacef38b784f3a4cb8f6a62423bfa67612e04c19f86b3a3701ca6f162524a401e51bb5eb5e62e4a20f571e466aea5e7fdf2d14b67b3935ebac48f80e5c71433968564480eb3681b06a5d1467a7b688bdee8f87ba3001378d32b2a479c58971821e3897a2436b612b0d19ad3a71449958ca9c9e90d976618c8252fd4d0b53e64bfd1a86074f3d8811ea2e3328fde693472d3b3d1acdace67c2c93fc67890f7e2c3be773559e5c9097a4fd24478f224859b04ece66c898102b86c9ec8584bcd683e3c0a7885701c63640dc5390eeb85155a7135376eabcbf3b6f4691f0436c5f71023bad9332d26a2a8fd2acaa1ee149c4d27bc749cce7fb884d1414c83b29b1e2b91167316da5d7f0ed0caa219cd8ad1144457f3385fa1bf075f9614a920bff79b74800fd5daea9d6a5b4fa355e1e03851c89c15fef80965b59ba97277947ce929c53bb715b63bc3b98c2de7c18911a1e84f7dee7ffad169d25ef79a9df2754289126a392222278be2811617a1c2eb021757b1da8b5ae3f9214250d703df9fc6c0b3081895cae318ea011b6dc2a2252e814b18c3ef1eb7e91d13246aa228c6a92482dd1f999b2ebb98d38fa0c6f87eceb27868d03869bd88e7c5d5139721750cb97f170f09e7bcfae98b6005f9e18022e26f068ca9bc159284f13d67b1989f524cef6c35c3cdc5d4160ba8125bb5a09d5841be05350d55e72c164e0aef0ed9dad6c54af1e86d6836be55b863458732300fb7703b87fbe2a055ca7e9ad1f6bf1d0bbab0c7ab7e9820ddf3c9b95d3a0255b4d1ad37d037a52708298482b197c696c7428a16e60f17db947261eb87a099454f51adaf59a792b8ba68a1caf2c551e2af1dae6860d266d38271835fe61aab523d3329e724c165dc8370011832a4042dbc1e1b81e67bd11577cf4eb150eb5f9bd9d1d92984a1e34e9ba6a44b78dd5a002cb62c1f30a71cc75c2954e4730f0317bc4a09d92295af73e7aa8eec181cf4ad2faefe2c327187a8939c6706d43b7b7b95021462004cf8ca0dce69a2845e6f9e836b77eb2f127feb312df2b3150990829fa69384905f1cb550c606a673b2bbcb36f556b8b32c3748136019ecbd8885738d9c7cd1390232d1ed3445a775b47febc1a4b35e54d339e6f7db20e1233c3b156fdbbe52a9d4716e335664d53bc65e154df728ead25b55ba4dd63395141a9fb2bae639389bd288d6fa888f66623392dd919d43fb7e43a9e176e8a76457aaf82646ed8df80131795f375c9225217093c4f8df82e43815d71321c1414f2e2fd2cea4b7707a24173c28416f42531e0c15a3055be7c3c3c51a7d38100e40ae41114caca40981c4cd0419f2a9b3671d37c7710dc59a2f2619d8f1e5974491f8f1a9b323eb88d605a037ef5deb64bfc280823ef1c98ece9efe4a1d924d2d241f889464c4bd68acc1c51fc5ff6e4defb357ef4e3dfe3f43deac66a71a633a2ebb980c513a0cada57297ad4d043f05315787a75e45e4cf10354de91a820807e644515ff17ce2e72d5290413189096fb683652d836d368e80ded350f29b4ad4e6c345a09b37060394b114bcc09c280a36489f0b65505163e8db0685910e7f6f025c354911bc98b25c26bf7feefcbfccac29ca17e34e510b74b20e740389192c04b4d5c13d54c0025ca1e2dc70d7729bdc8b52df55bd3eff5f80b1384960ae90f2269d6b379e928efbbacf513d0bdd53655f234eb55657090e84d3873b271a0c0546e2269097ead18c2551818add1d19d0d326fac435e98db355f86b8a661bb4080e3bee81ab5788a5d0ed5af4e6ebfafbba9045b7519e8c707606ab7984a7f5f9e1f38f1a0194fa4ac60c35c7b3268351146cd52fb82451844f039424c643e28d86b3b455cb654e9094612b16da18031b225056cbd93cd8ce8670cfcb1697b148c8bdd238c293a7973018b09fdc2f6ba84c54024bc47607367cbf1cdff314bd2a4d19167120e90c5060f482c4ece2a6d4cf8aa4e2d84c0285e376e02a5ca12953834a7f0e82927a07478eb89346e540c787531cc162d19d77ed4ca02ca15588484ae8c1b429745f239f243007cea8419050c1a43b3753a292b8214956a580fd972bb201dfb3e03cebcad42e480d644c1c352a966af99f2ec28af9f515a682c7c5e569d642a2f3889486aa4a4fe83db5f672dafad65913edf25c78f0e2b4969072ed93fda0a3e4e442cfae07981d8bb43ad16c842b7574f347f24056ba6d99d82cf53ecf854f789cf8d7368080f083a38cfe482eea7f7c6158c6589b03403f1c3156bba5e3920ec8c15e668906b2b1f0196a80b2e4c9c99b4e848004d8ee522a1f6566ca301fee0193ee81588db2bf6be257f0d2a6eab8216fe8351ac054b9c3de7c26d06f396bfa7ada711a87ba6bd7376a6862c88146560dcd033042d87a962cd38be7abc80da4d5ad81937aeca58cf20f3a4faa879c16245504baf0b22739bf6a776ceeae1d12d2d0a6f8b69d8e14b3e3b7e4923e8c839ebde3884abb59bf1d28374daf5d22f2bac2bb9b37470666c4eea26a4810212e35b1119099301c768b60210ab53a43ffc2084666afe8b4382490b597ab33e1e9e4ed71b50703e0d2f45cb19572e52c80235b1f0236d41ba3d53361eb7297756db787d96b068a9f3dc36cb5f29624d110ce897635ea99235ba86f4c7878fdfbc2adbf487ee533c5cbe941a413443eef8f2b27c33e8f7aa642d2b471544b13bfca8c8478e565d967b465a41c13d747b4a8d9b5addf175ff0e5e9d49f6c46b15b5dc2acd1c53d47951bf6bb5174cf6939063f47cd289a487116d980d4424a360a677f8a525c5d38f12366f6a42a0128563f6b1136313c66a6a212abc43d916c2c84eea9d3465650679c0861e9f591909138829b0df128ca8b8c5233bb779b6518fb40595f1e40ef31ce266f64a6b6d6e74f49f42bec5ce7154a04016b86bf3415fd967b6144f37532648ab8f299fa03de1ac1a86e6f8ff1609bcc40e728d9564c7eacc12da643011a55492cd1369d558dff9faf82127985f528e76cecc2feea787fb7c5140669f054c5d66ea7b5a526e21d5d74dbd9751ec332104f8de6dc0693d55f38531b530b35b6e3ee27ba7a29f30bbd78649369babc0400f66e45d0e3baac98d4e078ba2a1b857ecccf3c6897bdf4f418e187da1db872b73dbb1e4b9b6e656961e5b6283119e13a7532931ce33cf1d3c3a678f1ab8850068d47324b05247bee8d2a103140b5ace6f9d8af549352cdcd776ef8a3fee853951f548b7204a2aca4a4bfb55baaa95ee401e26236d01b6a4a01e9b2b40c274da223b7470f41befda00c8d03aef09beb478480e365f321ab57ab16b51a3365835fcaef91204e4f9eea33f915dc1199b433e7454bd61491e845aec3005d9d1be109ccfc11cdf5290af211ba19f729642a5f8113bad997c3215dfb30c982f7f751d46bc3a322507d95c5b202ca9e231581b0b4bcd00208b711412d589168126b9734850e0d23b86b1c9b9f8cb37462896dac81dd0f5ae1bd919f9e580bcbc207071cadd383ad0c7bdc0b0b1f4ff61435bbfd3ebfd93471ca47399869fcca2a84dc5161441b6d3e59fbf8effcec6d0b79e61ab2fe4cf498aa5b30fb3a379f0fb326bec93fb9e045340f11bd5f40b1772952bb8c70e39852b545034d9d510e075984b1d0ef14008ce37a97f2ad4e990608e3e009be1ac6a7f8a089e45f33726e6e3c85795635f8a7efff7c4747544f75106e76b716f3f67ffdc37af8cdf16613d6b469c19bbec4bd20a7eeb604b0b218bf9d3073345519d6e9907a88c3359b9e3550f9c0d30f97ac0e31225aa24737119914c7fad7a6173174ae1dda5f5e0f2bb93882be931e7b8271a72703662747d9cb44851bac48ed12e11f59b466cc2a505e81cee21251e516f86789658912ee2811ab238f874b809919eafb410dbb23cd7af91ebfa639b4edb0a1b3bada20453a2cd6699ce52a7f8b678a6fb209c5262e7584ad984a5f71b079ea3a5f969ab412a610b107d2a24ace823f33a8d9ecd3297bce9a9c82d9717806b84e9bd9de08bc30ba4efd9036cad3d391fda22cc516fc3cf690ef874d8084d6c70380336124311608433d2fefdbcd3dfc4b11985b826c39eed4928e4f9d7c8dca3db57bd97c22012d396df23da53d03e1200aa8cb513d7bf93848484d365bb23b5535f0a48d0e9f8151143c252886f3fc4fdbab848ac7a984f986829985401e3b40a1fa3f6aac7ea60fa9f5b8263f36fa5f468e790e1dba8bd1eadea7ac5176b1b026526618dd5b80ecde71a7fef7210c3c00869c8a22617600c53f9949a1b5896533575d859d30184a37cf6c8e810af2a5a4b32ed4b8ca8a3bbad3e8c1307043d8c3ea331a0841bae24d998ab962718064be0e1b73b4b8c1353ac211049ee63362e8b9336b2b7dff8e25104eeeac6b0c4358fd9747ec126fc3cbe4438c7332ce7c818900f3bdf0fc2f4b94b36e24437c602b02494c1d9a2958e9042d0c98f421fe35fb8cb3a076165017aedf7b73e194ad619173a2db2d7c55a63be3098a12ce407a26993f258445ae06aaf5b13d5b12ee5e91140d9946a6c9170286f1ccb29f2ab7e31323968721642ee82a0688f32b71c32b539260e39c4e98bf7e7c2247522e2fa0a978c2dcfca1c4079b6a34a91df5ed426ad1fdfaaa03d337d961d933a44e36232d32f85686f954988ce5bcb7d4a5ce5d7ad68845585e33e4886d343cb4a9577d00a4c139b7af9722d2897c84361423f2ca4e08c0ce2d017490342a07a4b2fab12661956b755f3700218e5e6d22f362527f28152f66ef06e92bcca48f027c3afa41da45d78b74a2898369d11f7326c0453f8b952bbe8ac1b5e7bc2b48d8011efaaf23788891ebc4062d6b4086e124615c72348d07d2e54fc0a682ac56fe8871ecaacc7209aecb8c8a7a24d651d1e6dde7f9d439f0fc26d030a416fa518bc46b29c60934f102eb89519ca8f613e1666391e36521717625ba661e3df927e7b17a51dfcb7f78f6ce2af86f4c399aa8e27ea5e01800caafcc0518b9b408bad70acca42838e0bd4d6a8101c148a2901c503914e9e6a499c5a2f36e827f9c3d795cfd06af4bde3139594d1cfeaec72d361883cf222189bf998feefaa113aa35bc097b35c95bb58b17ef5855b36cde6c48190b12851790b9e7d4f40b661fa70b2f2d9eb2218979faab7a15ff078c6a8929700f6b4ff0f74121262338f07750e837a86e5b9c81b91da424bf78cc1c6b27e10a65021bb523788f4a2d4639a69cee6af42f951dd55149bd47109847602ee350d7cccc57a7a8870dd5f782779a4db050d64082ccabb460260ff8387aa7ce1907ceb5dd26715fbdf947810bc47c2019caa5a8db6e89aebf6aa5241536ce12c3bd08c64928c037f6ec23441fb3a76dacd93842296d64de92c8c9ac4316c2efbad42888b6b979b7d6e1d14f7e8cc1a53fc838147e30a2f960bbfc997581472443a365c25e1374967d12898df1a552425f729e644150fbac0fc73bd0ceaf2ac43c45dd96947705b0b2aa33e964c2fba94951a734e5b60f996cd53976d0741dfa648ae2d68ee48b66d1f328e86f541dbc4546cc90e2b2bcb5e2da8267a65414eefbbd82a6eb4cdd62658ba3d5e651fda21d16352dbc8b69c5e1206e3ff5e12ea4ae2a233f37ab6a65389c60a4f4a7de5cf1238cb436436597f9245c7b5d577623ee82c6c7c707a7ef74ec19e123840b5927797314f37d2b91eca5333756744e2d633b24141f7669917aa0a39c3edc39bee4e2e9c22b28335dae6cb28fa1706630f8dfa8e514072ba881cdc094ecd61a43148b1541b5369be3a90239b1f6dcfee16e577e6a9a05f56ad2b890ba17ed85e59e048a12e77114b90a2d047fa88aaa41c002fe8648ff05c04b21a41a71a5ab117148012a9c1cdda8a6de9c380a75918f41ab12f04f47b6d328abfef87edd2f68bb14105371621318c21d66411f6863bf835a785e2e03e2064d34356643c5503a81746820e3262baf327c9600acc67ec835231b268f8ddf859d9e447796aa655972ee36af2a2677d1dce18f9136abeae8220456545d80a59dc3ade705a7cba03058860dfdad887c7cee0bcf7635d43c3df02986fc32fde5107d0bc76b3491b8c614e21fd184b515ec807d195b7eca9e98a8901de86994c5d91aa4649dc7fcdf0e413e78049d6d1d2d9a13836f47c937f2ea737a6c5b1a0803ddf5fe6e87f785444782cbc79b4fe96a31cd4557093c4cfa10fe2e5c2c3107426b4343e30db36f46b94ba2ba0b53fcf63a38c6533fdcccc8b2e4b8a4dc30b9e54cf7c62be5b77129ee62e8e66c48bb86a340cc722bfd784d4779ad0fcd883dfe8050917d06a9008a40236b0aba53a7efe971896cca0d2162e313b6a4fdfaff6f7b67a23487cabeff929d5096159ab3b465b0945190dffc0de7fd944553965dd9e1a09e89c9c4be3a4989fa12608218b0f004699ebd9d32629bff2fac2065c3cfa433ce14543594358ca2bfacaa0bbb1bd73a4b2cb54d1b35b3292d2b67e1586dbb877d8745a869817ac356aad9b9e4f651518d207d71cb9b53dac141875061c1dd785f1f6751e61e704605f50dc4e074e757b442f52dee371d84105fdb2fc2920bd821965b83f13801c57bb6a1e30b43df900b4d51afa2cdaa9cbb1b400c8ea770ff3b812a80f8b495bf921b3c4e2e917c08a4c50628e8909b87fc7189cf9654e0a70bdace1fa1991c57dea72664c057450343d0dc47f14b1b45d31e877ecb607499a87d3e147563fbdf0fe458da6cbac34880cf9ba4b1657bfcf62b72f62f2fdca8568a30abbe15a4551973c4c891a116d57177029fcaa189605e43ae77423cacd0a3941b8cf531d542f3d2755f5359011c7727ace38a4b715352bb9811ebb0d342d9d199742e524cdafafa259e8c13bc95de2a9cc358cd4d37f35c3c137a3113f89fb65a7979a62477f5e7a6af9df318a1b9fb4a17e4a9f16b2f6ea9d05fc0699f83074faac994c19246e07a4d14f7ef94840fd724c029afaae0b170962de85615f278f287a2c2c09eb791778dbf9ff26ee0248e775136cf555a5d5c8b33842b4c52226390b2f3a5e4dc9e2bfb428efbdded949cf89ed8dcfec3885c3aea36f77101cd2529a3bf3c490f8cfa46dc69f8f964e702662f9ac8aafe812c77da1be5b09cafcbacc43d6f2c682796bbc0de929b217af55a73073b78d2f0d8310bba6cc1ba96e38139b15983ee3127c6334f932cfefcdf6ac4c8cdb08e5ea2d8275744fdfa6295c2e92ca39968504fe05b16058f2c6f5c244d16c4c237b7cdf864922ac38b5e972d572d100f897f00b12ff33b8f667066bb69d178ca35c209f09da6f3132f3fba2e22c3919328228ae405f782e6c065047e3f8e2c5d87b51068a62c5c972ebe4a0e28c564c0ea7de63a055628c46667d6caf72d52fe8501e9ee0d435207226b8cefae414d3efdc3150c2635b65412d6665e5b0628308ed29294632863cdbead1c4644296bd787a89baeb06c6f5e2b393128557e816cf85f74778f03130490501c09ed37e0d5ffd1073cdd88dea96e70e593467e61ae09ac7bd84c990443b4c9e77854a3513a03d21ede627889b7889fd46bf871ee7656abfc2888b77837e901d354fc7a4fc1abc24b2099b67a4aedb4e7e3824f8b36d807f0dfd0e13d9a3eee4d9c2a927e1cb8ab98998f37f56c3d0b299b773fca6db211cc36320b4220cbaf65da5082bd2f9948af5f5ae98e33f3d502bff6fadb116d42b00efdc0313c278ccad8ab920833ea77a9681733b513dd618ad0660737b1e0c8e979815a532690909277da441c8839bf6409d4fea132935089156b12fec544a76a1b0945b92b438407d2531ba54834f084d2c4ea04d0fe912023f9747ecd3cf4599380edefa29c1e87f7380507231a02f157927a64c219fb427178e7c99e6045fd9f66fdd2280bf8a8e4b69466c82b85a966cf3ef73f526cef0a6a540364ad851ab4779be76e95131227c2248d5a20926b6518d983a3b6b068ea71d40360d495764a00198978152d272d498ff07951871eb085892238430b2d1128d2423158aef9f92aa861e9f27ce7cef6146fdf0a510203da8f0ffab0789df31663888a16f8df0bbcdb1c363b71b50fbe6e35c088891450b4697c89aa7ee0d82b73a3339bbf330dca428d760dde429ce8156a50b9a16717aa1edb925eb260f8aef47eef2bd7fb919ed517c80781120670f16517421917c940a1e0f76c00b55a72eb7915daa7ce5545c2b5730aa80df4a2b2efbfea300f8680c00d1abc481207ce7b675e6838b5fef09d763ddfb2981c0ae7a3f7ee1cc4e4a0f1dc305f98162cb41d91322f9e01ed254bfbc763ef6512f4388e079499c9fa6538f5399953106eb84d0dde609f284c14b5544bfc4514b82524aa8911c831a834ea3e4e66461785db677f10a10b1acee4357c05a951a8115258b9c55b02ec92a709c3c47860e5c198037d2527e614296475bf28126831352b8d019cc197757ff2caa36a211d08eacc52c6a19cf71300648640003df6b4bbea41ea9abe29f5108641963f239219a8fd75c1e09ef793afd6fe3c801aab6bab7f1cacd2569d7d7e1acd7482e9d9c9c7026ff113e7a39b7806e31958bd4acc362e8b1bb8df6aa57669791f87b4d29f6df35ce2b52bbe318f05092a4235c2559234c7c4ed8eb557070e080ea491cfb4a2f0e68e76ea25134875b21549fc7bc83e23fe20e31d807c9a32980a4eebf6d1eff2b23edf507964302599ddac114956b1c4d874c9f6d6c99afddf610c1d21fe93141cc33b64250d49b97c348c3494b4278a607d92cbb1ed581ba871e694bf7ac2f21cf895ddf0ae27432bf8ca08a49038be6389681a50e9c058c8378d0d7a2a5a0ba657f9c4484ae9d6127b291f6b599052f438d87ddbc7d5b494db126726237f28f7205f1e413e6a92c87822cc9d1237c2f78b191545f0aab1320ba068fa498986279d557292560c54c912a545a0d16df50fed4e58c2644ece820ba01688792e58c4f4321f42481acaafa379bb8cbc684bdf167a49c5c5551f5d5df0cef694ef08b39f72baca4a41b57d426461781c700a17462bb4044dcc77f32750557cfa32d0bdee0db29bbcc59553299b4a4a08b21aebf39cf72d38ce2c1ff26341e6add8385fbd793f1fca595ed8e7e3311b4349426304c450c3f643935a6c213c012a2cef6d8b5011e2d11944880df95f4e1cc302e04f82c004e70e01bfbfa58821e029e24f85ece7c9a76097b355ac8e90c2c011c382030baa31f05d2fea27bfbc4d1a4a2c88f12f62d0ac7b44521da4610dd41ad298261984dd72e30d6338a19c7ed179aa963776e5fc8137a3067b1b644487245ceac45fd1ed77734148f1156154fbffeb3411ce5c6c9f58a72ed7f0cbf3f0f49f131f1f5dd44de166d22d12613db4298ab7118a8259bdda9b7ed6001bdd0adb63d7e90fe29d0e0736b5a1968e33cfc9ba07056392da10d6e6077d6e17d8ea7ae41cc05853deb407573b5d554d2cc1f767d9abc0f8b278ef2773c5904d522a57e3798f7719a35e04095b24b7556c579388d9a6556d8a05e574047bfc66de5b8f03b87ec748c6764c2caf45bc5a987f6534148bfb49f1d2d6475758a12562cc4d3c687c54c085a4bce8e166576c77ba223fe3ae614b447fd780fd4626b4facc29155c84a0469a83009a53049cad7b2e0ac3eb347fba3e3b137583d96049a2a7fd1a0b55267456da1fe9dd5a3037398818f21e4917c3873bc3101b92cdfba54a1f286effd30a3a2ad0b855cbdd24edcd3c3cc59ec052182e52070391b5a2f7f1ebb2213f03877d60a78658fb72b48bc30558d86758d9a9c66fd2941a48e4ae427201c3817b40433bcf2c646b445bcbf5c41927ab9b370ba851d4a2754e300f4d135651ac5d18578a367251cf7d7192ec1b488fcb09fc42795145d25b57843b3588e72c87f873f4ff19913b43eb315f5f600f2e2d9437c556ff333fd14d31d5a4a55dd4c5e1ee3e4db7f498ba91d12a116ac00610e5e509bc15ca057cacd5d5a63ea953acf4f37fa26af133d59bd4af5d0c6c2a06cbf3aba6ad5dd7429e7905973c2f0b98ea96af97683eb42f60e609486daa226e0d37a55d169d7ce6e1232d319cafee3bcd435b06bd3299ded9873c9beb3a6318dcf4592970e5fab0b8a7becaeabfe0345d5e99946cd392a6d8768d5ab1a59bd1b1300b4af26e6da1c799d035fffa71442f6fb18aa4ea705e561bd94bf813ecbc249ef99fabf0f90db7dde649005db4dddf5a1e5f715afabb49414338046d6c8e0ff766a7426c542dc62ac6a651d458d570bb433f8ee6580cd8df4c7a69209c6a608858844be61764532f7d2c6e2dfb89d843bbe45e1138c36c38aaf7e831c778f994663d3f328f413dccb7a3afbb4cf36a220b89353a627b40165ae4722222abd93bdf91c3b723fa6e4f41d6caebdbe161c4192fef292e87a2a19d2b3c4459c22c0a6385bc8f3d9bcecf8f6cf80b077dcd498ef603514a98223c8758b610313ef4814a4e3d253369a7b09207e43c42887de789da7ff6b93c164560f6aa4a43afc93eb6fa073451c91a98e822bf39e5ec4832162e64a457a3650d17151ae27e14a47f05923d99ea15a8dff339411accf86ab6925c19630f39a77ecd5f9b59b2bb2177ce74c47c117cd348a4675188dd9e55bc04fc9e987b40ad88d2c8cbe9eafc6a734324233e91e4b6a282b2f68562710386f90ce0fb480fcb2d19a235fd63fc7afc63a476500c23f16c1bef5d45b7c24dec148878652ff3a4d29c4076a964f362a2a2cca8133c0a1aa4c435d24ccf7028f2f59ca781ac443d4ea25f049aa05ebff5df3548c510b09fc94c47ad7f71f88e7e15ad3a01a79d8d3d418b3b20c387d15861baaa7d2ad97ddc0def1b499ade873f8be699e4d8b9dea9e4a6abb86fec1a1e961b7181d8330b53a5e1e93261005158e1cce32207216ccb34a68210870d0a17ac486206089f35ce5fea71af6b4c05e268cdf9f60a57bd9dda6dd82b546b65f0aedd50c03fb7a6ae7df28c6a54d5d72e20f209901318d394170f5ab64d852a0f83d641a7fed3fa33e6206fbf72797e1553f2bcb7e942b45b9ac1aba4c822d3280b4bc57be839ce475f28c102a667cc842f77b3ee88a5ac94fbd9908fd6bd8eece083b2b0f704d567cb850a450203c295114f5f81c1efcfcd74d89323c55c6294563ef9795b095cc0fcc94e4119c37a2e4a7f250a06b424f7051ac98c06f04463a872eda918b5b4e33f1b54c6f8051a1efcbc05e9ef3c78ab8ab938cd8037b6190485d8ab93a5925f2d5b2f3d6f9c7520ffba7195cc68ec367793f73bdbd90bc116606097c8d1ac1fce24269bc1e64ee0a7d617a7ffb92327806f0747ce450788a52681ac8c39b39e000391a66e9ce9a2e1302c2f6f9aaed288cd310356938bf5a989db211170f4a94d8ad0181b08891a32f7f1af55ba66defb7683987ca5082b67f78d7317c3cb1e1c0fc7f650aaa004e5579fbee35c28faf38bf9bdbaf0b894e67526a6cc2aaa602eb2ce299f45295719c0e5286c40506f2873b6aa9f7b37c9cfd6b59bda57aa06f756f3e1b67e70e3399ccfb55946feebd438cbf55ad618b3c2b2aa6f6f3e4ac16312461b143a020dafe5fb24918ce8d1dbe4911b0d4df3586039474b3f105bc3b57cead173607b3b89f40e14d755dbc859b143fa8e9ad3a91c42e9f12f98073911a927fe3ba4acb3ed5c3ae0cf1244d78b28ab68fbbd6bb632ce27459067740cc40f1a0bf5d65d506211bfde2242b55e42f8351e81f97cec626b4f0a5e3a6542535006f716b9b3038784bba210a16ae2b52b2a023a3e4d57ab6fabfa8e38c0f788892f352dab7f79b5bf69cca3743385829c1a0f583972dd3d7bea0f6e966831f9a639407cd377ced57a7a81556164c0978f3dcb6199221d5a8c795d0481f136116abbf82338ec0696a764638c6c87f73e507008334f071815d7312c9e6052c11c50a0470c7dc84105e26c1520fe11993a6ad113bddc69b101236018c6732fba500eaf7c608703591844b8ede06c8806ca1aed37402a21ce1794f4ad03dbf05c8fe0e11a50e9c87a72b2bf2e99327c17222e0f1a35d02361062351ef7d181f011599a987cb78c7b0336e480c92da2d4481752c6533fd444dedea6904a476a67c9c972b4bf5bd016770131a349cec218431c744424a86a2192e73254bb98bcb25dfe3ca9e1b0c27420f47632b51e01d2f7d8124121779c1da23a275d775e83799dd398084ba24ce0b9d57178df909614ed4e73fd93eda70761dfc6ce3d402c25923fe539c45adc08d2ab77d1c21d499d75144d5af27fed46991da1b24f4489e6ee5bbc18eb6249c75dbbc7b8385cb86ab5674d76ab4164348d3a3df14bfd66bd7b4f36de381272a4d44682806ef6337c813651cc04b689282aae6fc7a5032ec1c227085b0fcfaea83cb7cf25bbc7f89fe3d70d5c507c8ddf5d84fa30e3608c0a59901e2426a5de8cead5021ba87d6f5ad22d119f4492dadca9f5cb54f177fe18e2ac17bb1e26a315bb2475a62651988129e71be24db96f1dffa4634cb3ef45dbef476ff4d7e2e1a15ef1e0d985d7833ef2027c95a1df4e72c3dde76c6966730ccd7e9dd096beafd4efe9643c9ea9c50e6f47bdd2b8b26c8dc4f2919e80805c3931698d2111f40a30dfb0aa4ca3f64992b8a940751fe0e35a6c6143e8493ee0f844b2936c470080a1823b2db227427f9d71bd1f0e219dda50d66542c561fbcd76c9b8e49aa7e02f290ff4e763901f25f336fded3d1c723bd15fc28a034a180b44e321a4c9f6554c009ca8de05b1c86969b6b4460c5ec04ee4e5e13b4150b672749687fbc9e29f67207548c93dbb29e2130e637ce270b9f7c379bedb87a5510e7a57caf96cb666ca18c59b5f08c4d14e6ecf1e06949fc51244421db405f9ff4b846e6cb08f78c23e621335e2cca18da24e28b6b1b7cad1d6ea2b8d13de4abbdddd4e1ff485c5c4707a884b761f558153413201bdf0e97a5e87f77b07095db2f91f77bceb2ac1c6bc090391a52159900b9c923f305ffbff8d8ab10126811166bc950ed5553246302fd109ea05cc7ee42164f65aed364cd26bd80181b0d61796723d1cb40c9aae655b89095d3869a302beaaf04448ddabc17fe1393d75a22c6f8d854ee8faeaae5e9077dbaa3cdee126ffd5945920eac03f692f556a1527b718c41aecd6aadde3d9bd1ff7b12ca7cb3b05dde22e247631281b04608fa8b51470eb39390834d5f4a243daa4d5df352ecb58f9ca275c573fb940d02b1013c1e24439dbcf3c0a4a291cf5661437e268e005b387a73e307455a81b71a737c3e369910282e6e92a7aaf5f3162f189b8324ba0f1f323974db5be2617b88c7db230b6602a3fad907f79af8ccc664c31da9d23361506087d781152ff31e10aeaa967bde7b11e61bc0fd876f71bf0a1e9611822c95351536495937c3982032fade7ebfa4b99ac0bfdd9d4cb783034169ee4b1c7d7222ede9b6a5bc33e7934a477c4143bd779483803aeeb3d7db015b1ec1b2d17a4e205c267817b9ffb728e20a27e56541fde11e3a6a6b64102ca89a83828f62e2e7b7a8a320aa74f0fcbeb9b51e77acddd191dbcfebcab72b86d219ced377293d901515c39f36b239bf7bf7f4148c4e103e4d353b17d05f533e2b5729f4bcb9e54cc5bad01263bcc9692b4d773282582e962eb1ec3616c250453e3b0a4e75630135f192136c49d91ed4c35f1c68e0d5be80b52b4ab8102cba8c26577e63c8e99a551c88dfee6198fefa37d301e384c5089d4991632f4d5ecab86b320abfbd7aae9eda035afdca3d6b760e2d04f7d2b4ae3b697acd320a15e6619efeab4eee5081f27332c903466e8d86c56a49bf7a62174810e31af862ae80631a9157018dc18b75fa296fe15b2471a075679e4231fdb16deb8af7a695dd43185d4374f3455fcfc606ca09abed80842b696386c5335b02512c7b56c7514aee7ad3d2750c476f2a0aec4e610089a8df4d6b555535357eae72b1583432808ba0dfca97c154a6484cb2ff1abbdae864971b3422061ba65c7071accf7134df3eedd7ce836abba060b20ead54cc6479888277602ac9edfbbc557dadc3fc13fc7465faca09ec50b8a009bccf410d953a8a69eaf955f9d02b2955595b944f3ebf5317c5170c7c6b2f5265ed6d9fffe9e4f89058052058c4787fdc13eacd931c530c1ef189e9979d1c4eb6cf61c15a3a3dac79d10ddad7df7d2741d9889564b70d59c69048bfcd09433e59cc628c4fada014affd198c06acbbedd333ceaa25a5e84155a2372ea2d8a108ae7086d26691d1e92219287aef4aea8d73bfc6302a2da1250ab2d6981b1f5659a7078ceff609f06697a972b4d1c6a897ece80b2263d3ff3258e6ba6f02d322b18f4b12d338e0234ebf98e9c19729150dd073d93d61e3af301ba414d8f4d0f6e9e403fe6ce6a883c109dcca52d10b5be2d256ab4c813521eb880c764001f4031fad3c5d087ad30ecf3655cfa5c3f926d30c40e370b1cab802f2bebc7e7f9d687f675568cbdb14913c947af6d98fc5fa7b1afdf1659e63b9e18cb265c8b711749133ab91ba4e8dd81417d3d0b8881d7d276d3ddb059803e12fa2a155ec3076c228b9961612d99f41bbb3ab19b2cc83efed99b44c80a78004ca08be5e74c9808f96f0debc7c616328db47d8a60538861aefb5bc0a5a69ec957835a2bd73e2043b35bf80a3a632a09f59997915ef528119beb90b8bb60af1bbf52896299f516e026ab6d707151398e9ba41b798a9d7af4be325b47d55f2eb2a639bf932e6e1716a2b99b25cfb6b32f33068748c5332329d5a0fc092656e681d02cb0f67a1f85b9eec806f0ae8e715abec6476b5feb532f027855ea96fb96e131c9af2711adce0441342d8a4783f8329d161388dcac137c4c252052854bd88555433c8e3b953fd4d6cc008e5c06450afc55eccf69dbfa28b8fe04567eb3dd00682be42060230f97de2eb925781bc8f0dd5e010f62ba3b85801881d2a0a7d2875e04c0a996e8d772e9128981385d03bf135043a9c316c2f01b5852b54eecf246ac548f6e0fe72c9ae6fb716b1217e1edbb8f8d8324c8401f5faa7a3f97ae9111429598ba9ea4b9b504a7a09dcdfdf2c05c4182c5f58953ab08594f5ea4055f01872e36871f8e68fd486ff93d66c446d3188b79fb5abf052cd25bc22d2a9ebcbed410de1f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
