<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"25f6ea550ae921f8039df19acc107cc310468485fbbe1f1011fcfea7ab4fd5c2cc3c2b2e6baec7d9e22a39d17a45252a6147439c8b06f9de78bf5f04e892ea3b9a178f5ca2db0f6d887c840ee070cc0ddf92d0e8d3fe5ac441d08e2707187044f820417bd8fcf2d356810c89ece4d54db606b7e59113fe9704f8cb06bcfdd309ad0ac4bdc5f28c51a3a6ae1693d0c0a69c1360b56cca25cf8cb830eefb95bbe468654cce04fa0ee500fdd4e12fdb07f7752802f5368063aaa0e2857d87d64fc6f05e25a80a539d9272e9cb31a9b266269fad63a50f6fd0669cd58256462ddc883a38fc211cee1d673ffea5a27cdc214078f796acd5d7f029c314a6d44154098aa8ddbfbed6623b00dce954be6543af54cd195a86b2256af628976c22c260d4ea432c3f28b1c7dd7d9022b91206456fb22ed5e038852bb2f5a8f6f74c4e8469412252933cfcd3846573a22bdc20b5aeba920aa6a41660eb96f3414a40e9ef790e8ee675c0aaf41069bb0bf07241040ffee3cc52844ef42378940448f59ac7716757652a4296f38ca8c82962e448677d9f467350b16f2561a06eadac615fde4a7abb1533c90093d4f06712088bbcf983abc77b96e44499e8a4ce0c15376873d172ae608133becf02beda4a014c97e9e72df6686d7d52fa589e596a5261c3e031d5ff86194da8081f3c4760cb766fb4a5baaf2e51989bdb181bf8fbd9b5c905ea0d1c0009db077a931bf7a1fe311fd6787a138378a8d2245a9b4f255a9bc2bcd922f1e0a61af525daed7db1f2b13eaae638aa63b0039b14a1f1beb0db666da91c16937cd4e9ba3b78b662c5f3327f25bc5f0bf2d9a7f137328c9a7913ef74df2c2080dc9843b4098d81b80b4f7c0d6a5e17111d9d377d54fe7eaf998c3de6f5bed8a3bc30ee6c5bad9afac4cc53c3414a07f8320cc50f734aa0cc3539214f8d483e43ea1118a0286a521e68be91104afcaba042702f839c5eea02a79d3f6a54467646e33a5777d8c3e826e3dc2b3588380741c3d34ce662a344ea588925321336f0229b0f848132e681056d571c66dadb99bac29e9d9af0b082f6144a73714de5dc5ca8053dd48f12b18c7002f7c6ff806fa11b9e2eb8899bc7b77c9b1564ba18722e9144046d0012226cfd6552d27d82c0aba0475eea08d3a4e98b9cc650dde8e110176cf840702ef00dacef0875b51ef76e48fbc12e9b9529fb37d5851531e5f5a7140312662960cd3f7c6ba7f93e76b2e049744beb0793cf4a3a5ea92a57afd032a465de62f6c9d9fcf9a373001cf36bcfdbc1f89464a308e872d75f54ee4c50dc2f9a99aa93bbbeaa9fd324f530ea98993aaba447bb1c6d7f251cac5b5fe65ecadaac04f3b9df70545f90f15de3edd8c11f78b6b8123bdefd8ce6828da0de943e4f69907eae456b4dbaafac8f1e353a66f0a275b0046724ab50ed9c791c5b425feb62d7e2fd8cbfb87618f907b168e7aaa596c2df80ef06790d5c40d2fca810d624f620f0ee54fc7e8344f891fdc3df6335af5fbc46d96b48e4576261ebbeb2ac33a2355d9cb81ff23618299c6d194a4c8dbcd3a9c28da5a88825a893174d48c4f53a506b765a1a16fccc02d0bef5d68e92d9b3798f996e596874fb97a2f17b1b1a45f7e818355ce7906c47d8783f1acaf35eac378eacf3d656b60a56ee79a8bd3ae36a22b40fe1b0ba6fe97904dae10ad82d3802f0a83e39ca71bbfd1e10e17010d609172b58a752bf6f591612f6d6bded3e431a6848006f139a3ed396c76889accb3862dc5cf4c5b21872d5ca34e500fa86275b80e7816fcff1881e4bfaf400c22a79bde5bbc15841ec7e238dd9ca794b364278f58652b967c711071203f61767130d365da63345e7d7ac1ec7b265a64330a2efcf80f75358687ff25153704d3c42b1874623b89e20a25607441f1da18aa050f64038f6aa921f0e982322b6682395075906fdfd3b6d3f4c169c14df82c5a596c74155e24acd05f04f2d4d97ecfd9212190146aa2c1b58a16914cc4d4a9ece728a06879792f7b67cdb75bee3ec60e549ba41722c70aa3fe0161452d695169b4534dd15a523ff3585bbce3b970d094aa7abcc7c7233e057c0c39a2a74f3b8eba60f98644d0138fa6270d5f9303057211be02e07a2c67ae2396a00719a12c5fb2ca745b24cf01c295d81130c7b3a316141fbf77355cf7641e349dc1fabc0f375587f38660944dd8f9886bbef041f37961172354f379e079ce0f19feca247ea37fcc61b6067cb2705638459fae568736900ead9811ac81271397f8f943b29289bb05d445331020bbc6b3c8bd9cb9e3b8abeaad894e505f92305bebc21b1227e2ad1f8a781a0f1ec2edd3b027e5b5b3efdd6e499ec0c574b2c54d1f1a1c87fab81dd3c13e46cdf353a6dbef1f19600c922d87a7e1e72bb76cee476104c385e5fe809b9cbdceabe31cebeca8707d081fdccbcbb3109b67ac7eea1fba6a0e202dcc8f268d178007b12615a8b8f4a3b49ae4f5486bc24b0c868ee2e7ba889a824480f809e9495daaf967e2878fd20a541ff92ac5b018ec39de4f9a1d2873723c6dc4ba6a0d485aa47e6b87c4a255c87756417bde32eae814d255a755ee4a632c3c8886842f0381f7faa34ee63f071f886fdcca16f7900a0101b7589135a247564637c5f02a54045d6332dff58104611d4cc5f7bb111795e0f35677f36a1840174d5f9452a595fba46a208fdb44add52e70cdfc6d0a387dcdfe62e6cc5ca5a2ad4e544cc70e37d26a73dd4a399bc4c25669096f2dba640ea82e15d559625b016f4afc9f9c584ae82633737c9fe268b3bf12ac3c952c1020dc0a2f244bcd0fc99df2f47b6181e33aea0414ccded0344cd95249e9538a96e96782abf07220c7a84583675f90562984a2fec2fb851ca390c3ec05c149db66e9f9eb2c822164e50fe7b0b35b671fa664dfd095bae59ff24174b59c891d96d5281bffc1b3769771778f5cc2cee3acf7de8de7f60b58b604be90ea4b2d777f6c4729653351c9c046e1a7119512094ebec5352e66c853583887a7132e045053d0604198f38155274f3a3ac9a8db1646c6c693f188d323f62629a5761c63eaa9bf6a9ced08721b217bc19bd9781923a77217c65cd0a6a811ac64a0f95805487497a0797f75f5654f866f9d561ab998f81deab9ad0cd4f7ed2096846437b1716a13f71a0d699be82190afe56a4dd2fd926a64f7dc00d40da5f74b1c9f8884098a53dcd84e1d9e2992bca14262ea56fdc72404c061e5f46368cb7715ebd10c115a9f37134b6b6479b7c7f3e313f0694bc1c4b04029390704e2d7f6a013187c04be14ef05057246810d67a622a20fbf967aa2e876e571e8e464a2f0f6d0b94f6087e8979f970a2b73e63d4da7094a87fbffc30b4b4173e22938ceb3075512807ee5f969f0c9137ace1fd2656fab5ff31adef3f791ffbdeb075245ce12ccc4de69918b8539dbfd2224379ce12449e281611ef3d280b1ad3daf7a934034167b61b5b7df900f1874e358560e5cc47d967d5bf7d57c401c0a00a8ba9303e3b2b730d34d3aadc3328fb0341263f046781bd1c035a14d9f24c1c43c73fcb065080fd9dec617e5adcf614f41cac75c925a9f7b46f4aa8ada36ab77f899b163612cb282f117cc06a9ebb02bad2330f218cc9ba669b6bee5a4c861ff7e14e43aaa2f98aae6041387e0f1346b8b8a2202df334ec5605017794eceb184d14a950b8cf0d2983b6d879c292abc9be2dc82c2f3d465dd9883b43485c19e03523cc50ce0d008c4097f48e3f0bd2032f6884250534bbe52d1a1bd7b704e6b51a0d2e84895da94a1e97a46dbc43d53a58c635c4a5843c93a91afbf27f6ae70e840a75385fc3edac677d3fcc739d9b7068cd75b638aebea8e2fb4e6338f8f71bff319b24fc3a2508c0083e00ab5fd5e483bacdd92eb50ecbb8641ce2478bd117f0137da3727e3a302d230ccd4dd3de176a518b0987e2190664b2aa726b3eee4e3cbf0fe5298b7cbd708ca2ba6418b4a34564ff70d1129ab503fe749c65179249d6d23d22371a35dc74d0e828fb512644acaf791251ceedc3ce372a37eb1ca37f6f4cb2a585d860fd84e5e07d5847851f910589779fb277ffcfa5c9ac9cab20a422904a72e739fb5153c7bca827b9694e2c976d85aa5db32361fbbcec87b0f8d31aaa307058549fc046b45be06697e39ee28385ce4fadb137e973fe427dfacdcef7f005e445c5249e32bf492a2bfce28b0e6160cfb3c31c5324029f957559976a324fbb3bc9dbcdf34ed74ee3046c467bdcab1c8468bf8296c4162eba9b4f00a19fa4a4012216b16f56900ddb8091597c35752e3396dd21597d4e1bfafb553c6fc302181c4af717306b5b7320243d1890c85b819b776b64e937d307e640691f414aa5d24b95b5f5fddeab95ed942e10e94d33364301fba28f5a67f53309dde2a2ad57ccf868d3462c765f8adb131fb63b0150e9964edda1837e81ae75f2d781e9bfdfd57f166ae54db9523f461eb0e2682bce19b2b348379842205190234a0d7c553bc5147b79160bb5095d713dd3569ae01d064f943da722c97422c732d780d3abd4a5a8bd947e47cec0fdad1832be5bda0044f20871a7e1ad2a22e9893dba0e56d4c4ab3586e91931964f39e73f6c6125ee349fbb39ef57d50425acb4a79594ff230de4e1483ef89d4a8b5f80c03aa1a8c148e19eea9e75018572bc551e10ce685087ee857c9ee3d336b1c6fa010de99902340accdabae49360775c1e8048bcf11df2c0e525f25c130d0cbbe9fc455785d390d9a53d9e48e4d6e58cc8995ddd1996b269836a5c2f9d55e9340e8c9293500a4dfb31194271e9972f4f62ad0b145c61c05bf9434bd37678606772454a062f0d63c6e48dd24fcd07ad76f441388ed27c7b894fc3ab06aaf6e29872eb282923817b638bff4d7ae229b297842d7372b9bb4415d0d28f285654d2ea2fc27d9b3088e42097964befa810462e68caec06471d4da5800c83f5b6a8b9a5f228a8eb2f798623384a6b2e160cf9ecba28169204c3113d9500c0e335c5817267eeb977146c91b68c4d45670be5eea162e41242dead30ad4bed383bd8684c3a33b1727c397dcbb78e13c1f6e3c6a0f7114057e35081c4f4e0ba44aba10c393c892a2cf5a92bdf0f519080fe745f4b83238ab3fa8f7edd8ff97bf24b88ac3ebdb3f0de9ec9f69b45de77406e27da0faf88532917d7c52b27fdc8e01e257eda6049506fb20e55c9adffb171fd40c941bf9e1168d044486794d2a4d78744bd4094130e7c8314f14ecdc042a588da2de1cbc40a42bbfb6a66cc240ea2ed483b2c9e64101503919abe628f4e9315bcc191a0a18e8d4009ee22c6558a9436bff87c82d2f5e423282350c10c1264c76d14a095c92dce3fb5fb576011032a3f75f3cea77c129026b10cbb80d19d8b0f0e19fd82865701362dbaf74b2bb23ace77b3c8680744733ee3202e016a30c1787feddc2c88899a04b769d96464c95046cc545d02c42f05f872fde9eab598d39edb2136a605921921dc5b6d81eed06c45ba346c17479abd18cdde4c5b1e6ccff17fdae5997f479a977c8dbef3de615d49e525c6fd2f5cb4ccb77fc49262655a9109991bed7be353df31cea284d982a76adf0807fe0da2dd343bfff37a05da70a780b7e0f263de5991b24d7bbd6fb1b46140fa06a1c8561ebe35c4e91da2867e88c1449b8856038ea0b2d92ad70b92a81450815b8c30c3a4fe0677df3bfcacd6419281362e5fc7a9daf413c30a4479c5defb82c2e3c833d3cf5cc43bd3cf3ce0a61c1590a4ec782a4fc54a0904abbf8339394b875a6f0dc361733ef11f3a56269a2b3e30f94d5b750c84d8887bb7c31ddc86415930a8688263f64b0f40d029a02b3572396463609411f5406f693c7e463ba7c4b5e9046da66ed4f76963064f0d010da070b7c11c8ae610ab860bcc9f94608e6a986fa79be6f4b3ce9313f66668720a3ae54906ad4445aa693fc3bcfcd368b8a2be071af573be988db99eb93c9f5bef1c5084a975a96fca3ddf7630b16acb4b89b7b29b97c43a750d7058243b29b76cbc85ec6c216179e87f1bd3640b408ba4413548b719e614320440ae4cd5666b15eca855094ea85a6d66d8d0750a2b5bf7b263476f0391e67d59dc344bd918c0f208340b23bfdc15603312fdbc13fa7f05f780178e71ba9b0f17f341a6ceea84ffa604245ec499fac5ae26ded6681b112b10f26ebcebdf283130c79aa0ea6b4c0a4e129648d1a7a911683ac9451a4940608499afe71ec84e74a7841cf7a1a76f31c680352c389f46ab3cbc6956e798e09a727422cc5b5a3e4c1228cdde9dd3bd1d3e8e6f28b9b2a5f09c7cdacc11d6d04493568cba5b79271018b25c8e5231c61ac59a5447142f08464fd7e1210922dadf32b7c764d9e635a5673be968adae74b6d593183082a44e913c5e3f505181da64e26167c4da8958b60302abc5bcbd0a64122756eb26d76440f194d5608ec665816bda9b974c9067dfc9c52c61bca71817b7f90248979308e5038cb8546346ae72e329236ce7fdd7330d45118e1df02a10581410711087c81f5a760dca914c1d6aee471a1119ab89190fc44cf0230253fcdc6db78ea3fa5217d57045021a14e553eae6f6649bc55f117414a8ec1ae359fafcd4f27f36998aa78a52f28fdfac16d464fb497662b2d003b37e4267da841bb767377f13a1be6e0f51d4a471a6242be2b59193f0f58fd3e807030a6e9a3613530ccb4898bf602feba6c3d8000938f42b66e0cef11ec313382e1f4a1420f7b581d662ec73b39d12e3ac7847795ec8363ff6bd290723732eadebb9a6574cfed56a14a469f2211ff20dc45399ef39413546ca6e87f8e32812befd7f875b6ad81012105208c72e3614d277aad162926b2db10e85e080844a36b54ec67bba9037ac128c1f52d364977353d45c292cbdc2bf13919ecec4ee2e1f33a2edfbe3d99705f71231569a0e174651069ebc84d82bb349d4d9deb588464ec065931b8d94e93911b691a86d8ab091a136bc3a5cc1f7cf5ef423a0599df34acdafef3c74cd366c36796e1525237aa9daf9d3eddbb2597e117dab86531466043cb48af67f06ac106c1693a7e8659214edff02c38fd63273692df76a53b018870368de119bc287ead5364355eac53cb9c98ea7d3bf08a34e17964ec05913aa92f8ab972860b6199c862898bc458e0db0fb47161f709f2e10c482f34126144c0e8236746fa9445657337e3ff3dc55b42d3350ef63f486a2be893e50b6dfe599b0f6ea6386024680a0af59ca0446ce2a52acefcf9ed60dc978bc3b0bd4562608c0a526911efa35d0b2000407101e3d519c020f79d83f4516e67f5b908ae3d665f12600dbca59efeb56e23029c9a651173529692460a8c69221a3754b5c7a7c75db677a2d38d27d2b1998cc7cbca5a4b46fe2d6438e2f340edcb0ac28959a51d36174fe98a9e1b0c2438871f9dac4ee13b551ca7eaf6145cc7168c6966b16a299bd1a91554783f778f2ebf883aa362507c784ba54dfd1cf22e8f104b97bda3d16b8139e2c3ed07e58959505b2f3da46557eef569e426a105e09e5e7082b5a788ea743c7f3b31ab790aeb5ddcf9e3977c166a245703020af276fd937b7b4c1f2fde29f54b76edf1a24578ecffb0442feddbbfbaca9f1ad676af028ccea8bb32e721ba921639bcd772dc985a7da870f7938b60d2c777a76027d4edd1ad01e79fd7cc7226c5bd7e219d067950531f68dd0dddd868f4457f354a7c0769b52d8b3e2a8656b34c9d5a28646b4ff1827d90c64557384e0f067ab4b1af95ca260b0b3ffc42af82ae95a6d95f1fff025cd54d42881f3ae0c39087a2d32ce93d643e67bdf12f3a18ec7cb17fe242d667171a95e535061f2ac079a4c3d8c9dd1e8cbd3eab02b9159cbaad9cb9b7ae2cd51bf4dd503763491cd47f05d3bd583c15ba4e68ab12840c7836d87ee08d7b7ee2ca9b728131f97d54d8a1b2dd1a9d93d95ce7a25afd0b02ce4280eae874783d3eb4f915e16cbd187936162cdd6de193300f2661606ec4fd4b3a4197390f34dde1b63021dc70e916a1500bfd93f7455dc655a3afa50da5afecd9f49f01c8976764ea809b5f4fc6074775f5a274e0d5d02b9835c86f4a7b0758d0a604423faa257cdb587489e288196415a9a3c784776803723f1964f860e374e27956fc53e8d7ebc0fe1e205d5cd0702f170797106d333e79073ba0da67f3fa63d63da127d4e29796bf47ec4e4a55be06b023a27fd0c367f36b5301ff9df8cf7935f3aff4905552a3669d1f08503cfa6dc54a3b12e8fd0f76639b37628819a9ef10c8fa132ff831ddebc9b1ddbfc0d4bb9fd5239a13c58d48a953d0fe51e4dc3ada61a211234cf8d7503dbf0639fa74abadae198c042c1ba0667e265e7d570da48bd0bcfd44f606df81cda84b117cd3ea26c608cb6f829f9f188b2f892663ef21c12a9236b0f2e9cc2e6f31c85d6553ad8702fa61f53944b35bb40c3bb56cb3deb387b8c2ab5dfa81b29a1c5192cd95414b62f2c746f051536bb908c16a0e067019bdcdab85f51a65e9efcd2351fb60d34f684207a26b5bc2057fe0329495616f5d0cb6e6ec165dd4cd6b6fe268f9334436f5f6f5750796297f65b569744bc9b7a4c5d815684b196bde32d42f4f4dd0860554897ef68e3f913b9c11c73a8898af83694d5e0093002188443ad87eb43e3b9b009bee13b595218f3b1e7d7042848577e3db8a43340a9275f02ed00fc4575d02263d4ea7a267868b840243a04e5407719bf7af98d427b312f2995b10d0d39f1a01abc0b6cab7bb935c3a5e1073c24891c2263bb33ad8df2cfcf34cf1783bc2f916b33620dba0f6a11037d90a7bbc5be07a5d238349ce1e4ce1defd2a615318d744506dd39fccc57d7a4b81979b925ce76229426fac1df49b0a00e73d77d05f99fd2f8843415aebcfb61d8991b0c7af7d4a348a6ffb35fd2b3d1e9d20d4725573ef1b04b3d25291721b10970c648ea60ec6068c8af2c198bc6ecd29ca412762b5d3adb5a48ca552a3794a86de415e3a207d440c3bbcd25ec8dfe5974a6003d5f4e7534d082ad63cf90c1eee9cd9f2c817fcae1e122b6ec47aaf658af851baf499c08be3f144ebca5e28b74a79c51144e574bed2aafca63fa1b0f781e0302623fc3d8dae2b7537b945f03bbf487fd57e18d8a3262dfcf9ed41c49445ae3e22f66c59a3e431310fa4efb3b3911b9eaf4e723f405b840983dfc4fda7f641423c93acaef44a0ebd12320e8af4c8003049e0f683d68c44aa315048a7ad0c90bb173c652a035d35d8f445925cf78fd074f10c407b536f7e9f73e7686a0cd95f4fc66acae36207d1ddf0e54b28c243e61dd7d1078c8ee93d3dbced10db2f01e17eeebb5b5c54b1454fa11766864388062042369ab48e6ab52fa17312aea3c180901ba1709a9f2a8766d92bf9446e5063aa2e6b1214c0fb5edf266e315487954154b70db36fc1f893992033d1b3a8d0e8aa809ca1830c35e61516ff8fbb7d8f6e63c53eb20cf3aa555a3aeb4f257b8fd0f169fe6e190082bb05d6a0216a7744a7910fd30d73c9c9cf87914fbc88be87ae3841a0460a95e82c192fa2fd0a79812366e13d5138918c2f1079c1592891b3fe675639f0b8e3d054e5e1d9c8d5230d708849ec4ec50c638df83a2f42fdd295dd20dc15b57dd6caf57713a067096abc3f528aa192ab0cd0890117e5a78653fe62a1db291ff2be2db585ed0e6d5ac2759d8bb8e91ff783d471d52604c81cfb878cc654d856e23f9d7b69c81b1f573ef6f83b8f8ff1bf66b69c170d9b8c079b0cbc12c2c39fe9a0e1d4268abf87b097741bbb35c025f17b3d97a97b2232ec567716f6cfcdd3992d6988400bb4f926595b096fd5a93c5ba1a0c9b5dc9b986566ab5f7997af0324a587fc3dec1c3fafbf5d908e2f1875d44ef4231279788c06699ce94996ac181801394a2e72170cd5f86a71c5aa8c31e68a9a9a86f3cc2b9a8d0e7ea91acbf2beea927e768c9dde72e18d96aa530607a1eeae8534adb780ea1b4e917ef2a35e8591d135013e8864388364fe4149158a0ba389e2075b592a161191063de9cdf57950ace2723615efe69e64d7327b0f30d76de016be185942a8c4eed7a39c5ac75daed68837f0e1f2af9a49d15e5e5f22b13bef5ac44054e03567c0702aeee67a36a6cd8ea0e30daa252675b21c2664890d8407738846dd8d9225d6dd903f4ad17e6c3e41ebd6708c67f9d5ed24ee87676a3014267ee5e89e73092967b402f331ceadad2b5894b24e311ebd39e780a2e43b11f33cc4fc2eb26160f0ea3162d2c0f5a9cc21a5820de17201a5c32a2b9cc3bd2a7017cd4420140caae73d9e63d5d2c894983aa5074bdb234df08cafb0d928ea2be31c6fecb54b4c19d1efa7ba839502316676e9431804e0a159ca402da175826776bf4f65d7d0d128cea51d334f7e9fa5bfaacd83b4b5be7de5d741c29dddfea535be8669d2f88e0f53aeb97d4f5d5976eb2bc0aca41009971ea38dacd0ee9911e20f72cec3357bfb2e6365d4b540b8000daaaa9b192d8e4450199d6324353663c013ef32a28598502170c0373e5da72ee2b3a04b8fa60d5b0112b04309eec7e40bbfdeb901e8df26deb63db6e41a0544bf66733ef653ed6422f08ef353c0dfbf820e61a6b523536b56852a905f9fae3a9ead89fc5e31deedafc919216ad2873f65e0a1212225ab97ca35deb0fa3d02a6dde09d223ce99a4de39af88459bcbc737713242fec96fb19ccac7b340760d500ac2f5336506d33226d63d99d46e1a8b1e51c074be1e95265f0fccb7cf960467fdb6ca0d7b9ea2e707a53cc1089483d1e08f5270ccffbb17b20fcc67325d0150d3166b16eac2f4ea7e84b01cb98ac00907f2f0b73e9e81d5a3b07849dafad3243c093dd53fe61047a65259cc30babcec988f31fea01cf8ac14cffef4b91b6c5ce0f57a9e13d9880dc81ab2dd0a9995d88355ef389a7981321cfc8e784ca34646af45c9d0c40ea1ad142a2f96417453c721a59387beaf5882f450f374f920295c1bd02d9bd0ceec97e788067025958327ca4b40d65e5733da17ac1d4869214f0d1b17268253d17a942fb54dc9658c91b89c7f23bd11480b51852a792f3064d940d7a13c0bd4fbe3462dc2cba8a5792faeeafd48c2b34acda1acc206fa3c1d3f5a0508196bc3436acaafc4d363862d8cfac9ef39eef3c344456889a8ff8be02cd631a2f2e8a5f9290d46c154d16af08db9f7b80d3d18de442acfa96a2eda0248ab9c0a824d4027174b119bd6dbe77e2225a9d8260b35493adeaf9dc81f2640df9d6ba1b0be0760469cc58d45b2a5160722581d3d342019b0ea1ed10b583e2662c916a276415582186e1f3b96240e7722417e2b2fe720ad7110185af199eebbd12d5f3e176a2ab8546130439cf2f0a30385bde01ae78d4b26d38e7b2557bb11facf5661a29fa20280ad596c11f973ae04f96f6e1875f2cf21fcb57738bd1674b2c002009fcbd02fe4f622682529622c6523a57da37fc9743c6dab53833dbd155a33ead76986e84bb4ba17ff0d9605835c374201813d37c3adb17824264e1599ea4b37d471df0cbf9061008c48dd07ec98b920699a73bc3b25ea4230624fac43366b3f42860fd6dceea3eec7517fbc7952bb86ab4bc94ae4e113f4a31d58ddb294a1192d468feda1943cddf6482eea3c94fe19fa5f2ff1575663142d53003b8cab19321611651da7d6cbc5eb3b0e16d4e4892370a254f530c382cddb0d8530e9099108a9dd03d9b591c5f68ef34f993af6c8987400b97ee86df2fbcc7248d965adeb22138abf91bfd6ef377764e1d8eb885c84feac9c86e0871882d5c89b8764d7ae7a6fd598520d56a16f65ddab06f5b933d50f83885e01c5018a4d34070ebe37c94c87e457a59bd0906375eac50f5924be3dacd899a17c9e30493a7875fce70224dddb1260e12edd81439e75a5e81a09047bb230e1bbadb0fdd585ca3d8064d72459fccc3793e62cd806b2944e4e76097e7d895ed1e229f3614c17e52a16397a94c140ff5e6479175b1f821b171190b6713a2476eb6835f412c81a7f0f772be9764bf856e93b15d79deeddbb78f2b10ef77f5fb434b57f0f5936cc137359782db25278375baee88b5679f173043dd94a127e6c0dfe55bf41ec0b727c86c2e3cf9c2aacb81b81b5c45de483e1f9bb67354c953b1aac7185b365204ee737fb720a63fee50f68a3c7173a8d16d2447f91db00af40175fe28ed3b67a55e1f142aa0f22fbc30befe91e399b1b67b44e17b0f446836e0b96aa4ba27a8e358c4c48341ffa2d6b185a1b96eafbc0d1616b60896b06bccb4730d296e1dd8444321267c8bd618e95a083d438cf0332ede8a8e145ee67ceb559cc7b60b20833be5592b2c8fb186510816459dc126a065493fec56c643af76717e95f9b148c3f4b1291fd61313a46173fae663da6b5ea5beb6c2f81d90dd47d34e3e7438ef34da63b02be520e452923a599ae083fd0c0fb590a14e868a57d5f575d9292020f57fa5c9b902e589f53b97126419271368f747cf3ee3bdbef2a74d96e2d36ad86e8c443c72e723b88405d6877baa8896c5b746312a665e49205070a6febb756806bbde74945bc096ab2fe168c1c04f1b78a064eeeb27eda1fe0510cf130d147686ef88b34c2602a41f46f2a0d2a81f5f907dbe4682ec7b37f2cd470cd5573cab3a5b60f56e5e2d6dcf0c9a322c116ce847158afc64830fa2332ba75ee3c1e762702d338c095896960b0ae903315c2c26f5c12ff804159d8ad46fab9c93b14d99a2fc06a26dab81ed85dbaf499e267f09e0a7199c2d3b2d217274f32f88de3d55a70da13e3bdf87d9284401f1956ebbf6c67eefb8b74bc0d577abfeb03bc021bc21ce0a063ad05303ba73ce815d03cdc331b8dcd2135bcaee75c5b24a484723fc7c743d350e72715650ff749ec797cd6bf22525b29ff38c62de071e53d67a2784c78798f0ff5d41513cfa4be3a8f854fca587ecc3e28a00678cec3b515e20c9a24990ae3278572534f95087997bf3ef1782c3d264ad1742c3b6b66b3bde22b34915b53da40b7e25e9ca16504d2382ca4bc25a54c214413772cbbc0822375ef8321c18b8438090b83e30a09b8a88075d3656a05b891fdc2fe57ce557dde2006ecf3531bf43e2fcdf44bee75709fc83437a8f922706286f8466b1197cb57c60e83883988d982f37dd62caf62e4f162503079f1299f973721973d97bc9142a0d54d377305ce3e51d7503ed2d0ab8cf4ffd896cc913b7de4297873b20b12ccb2d9220b40dfeeb00cc82af360e22583c73bce64fdda9fd4320523548dc9dad07a0704295333f31e4d89fe758f27b9233d2f3161295e2ddafc2be4c214c22c98af0fb5bf5bbe244b4131210d02291d441aedd2958f6e5987716eacd14fca452788c49b043510206cd61e301003d035c3e30d7e549eeaac37e43203ce55134468df9ea56652ecd4ab80d7a6097e4eb9f508555048c295bf66554ecc648b09bd3e688f22b873aba242391adf2b44b305d6a33ade5b56b34d4304be58b9a04750345781b9feede5da7b4b9a9b7f1be1454850e77fb4434d99903e4ee4902a017b59b1976a59391e861f1889b0ba03836784d4d958420c6bbefd87d1961b08571e225f65a15d47538a0a6e47808a6995194dfb9c6d9b95ca6dcbdde25c730def9d1e07e2361d1e106d2489bfc4c4e5da67558a8435ed85eb6645fd9675df04d23a830903f3e59647b02b0f4171bbdf4ce1183434b34ab7a1063f6d17c5d3c0d9593180710aa8b8e495a91d612036b03b838e39f048a94c69ddfdfd5c9ff88e501bf8ae289cf6d76e3f5182e1321988759c483982132d93b0c686e7033edf72d003304377cca0faf26b84c4c259c0f354a7d7c62cab0258f8d1f6f63c3fd3cd6aab6a865fa5e920f06e33e85865c5ccda21ed1b1a157218f7a2dc3a49ab5d16d5ca34460e4703aabf18d3eadec2d3496641f716f69c34e809ff6661bafb6027c9896f5339246caa5e923c0aa002eb9e951d0860c180197e480d8d0bac05448b8a7fc3062bafd6312026c7483782628d9cec7395c38e67221f8e1bf7a65674a0cf8fdfc01835924aad9aed6592c0031c95a1a3cca7088cadc96964a4966cc28aaf0d35039b6281a6a7080f063070639a84bc67a69bca2708737ff9e21a22cc79c77385f9a6801d1bf6f10401d0a925bcf9d8be309af936efbf79e94d908eea7b8ac346b4ee20e74060ea6a58c0fc584051af43a15c4fb4dd81f1fa2200ed3e07a3acbd51653ee4bf6f94009362cb25aa30eed23e573c2581ef1faf0a50a94859cdebd4979381286d75073970a533f93c90ca7ee33353a68ba97524bbc2a56ee6079e59deb3dd20ecc2b1824acbce16cc3e7d6710fa5279839e61afbb2ff6a54cd27112a18cf5c43462ed8d553fcd7b50f185073a6dc4d4c666a7e5e3bddd09373fd449eacd6f8ca95f785eadd23c8ffeba34e9da4f11eb2a238902c9e500ee5fbac08dfab77675f8060ae54d529e8585e3c0358f7b863e246e72a2d9aeccc255e29c42bd785f3976853ae484d42d2e76e6677ef889bd5fa5bcb5de62bcdef1256011bc7fa17bb62d5fdb61e046829fa767101bef21426e076a0c2055557219d889a878071bbccd944c278fe31d03b4b5a1d69ffcf1332064f4656ff773f2a1fd83e9e214887483a6905bdf12951ee659a35839169a93b4682ce1686c9b45a77259096f4c7cc1dc5363a58d7c1b2f860bfa85889bddb9277ae31757e7eb4745fb5103b2403724af6a4159a97d8af76b2be73afd6a258be24f55e7c6a43883f0f8a79947ff70de8291277a9d4517387956acb9d32b73a4282e13ea919db820c1fc2ba7b40ca093bd3a66170d21481119703a3a9cf9ead21e43f7f9d1f9cc8a59d3992febb3fd04cebb5a922b4dffa22709b83e0d05588e5a184174f316cd4a5a78cac8a3d0538d19f2b9a7569a1e160146632afea81e749b54f555f6784c884132a0e53dae7f33cc6e611a9af6203629dfeb0d95363cda056249657ae8ed69435e819a071ecf7f67f961de8b4edb19e770fd62b2531fb8a60f715b1ca2bc75ab6b9c5f489ba4d0aede939871925b4d10ee76c61d74ea33fa153b17bcbe23b043","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
