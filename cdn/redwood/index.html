<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"4fc8df7a34df804fac4db507307e08bb4886c2db70dc096e4d5339312c5dcbae9d4549f3f1b818d4773c9306a7fadfe752fb2ce3c6103057036e5d580d2cbfb14e80deeb426e7a154c19fe00ff5709e3de5434130a1f9042c7f4c7cf8c249ef33013e80ab125b33ca241f3605efc418bfc4607b350545fcc748396c98a4266a8f86e9caa0639addb0246bba2c60649a2ec23d50be7593623bc92038ca88e2c07196df2c8b413b450ada338b93aa32af41f96b76f1fa4bc7d7bb7e8374826835984169985fc3aa046f197025e215937a344177d19f353bd536853010e1858c8efbf8d5cffe33d0afc49d468df344ac69d5966132b8a02a0b5939798a9b2ee4479c3f0621eb25a679b0b3c70ca9a3efef98f9772d52fbc3fee18f44c36c00fbb2838694684962ccaace4581ccf457dcdbf7a3d9eb9353a07922d5407190600d0507018161783c0ddb7f19ac9798b508be5dc0bce749b371d4af77e080095001cc0d8e3d38c7cbece98dd25835b7868b78fed36a0d0e283a502730f0cbd391e8d37331ad2d1f53c8ca486342096512ed8621e207f195d3b71282d2ac10272440f53c63632306099d0917fedc7e356427a714fe0e6ce9b168fc39bc95882901e213ef8c4c1eaa674495db47aea2394258ee41b455bd8fe4118a9d2af8f043b438b47da29c37f00a0295b8d1ef3970b48feefa796490c0e27cce21035fc39a6031a8ce12822ee0485faddb489a53db23951ff57c977225f502f0c065812e1354fd12b5a19fd08737969314e368194dedb44289aab37b20d48791578ac75f1508de10781e41d883e01568fdad89273da5ad39f60f9233b44cd23b24ac97eba5cbb5799d1e2aaab6d7730051c3f7a092b5fc8911e8b91eb5dba49f034928a3e6130222a730de423d0e8c4f354b2b3d1fb9f3ffadd289849be1efa8a1cc71b92d3c216b6031c4bee23b4abcb4a2349683c917661ba8b39f79f4c559e9ac11fbb8bf9b200c446213514e7677a74e40964277e83d459bae4aa208635a81b3946fb7b96a481e0be38c60334fa61e46956d1c71df4ca817e6522b11e9b64911aaa6885b5fb9a8a1f94a2b0f4434ff921edb0b183bedf12a42dc1ba266b8352c97c92557212c604feadbeca5d4d9ce358ed5040393a84f2fafbf8d04431972540d6541ecb8f70331dc3be1fbfd3ed0ead1c7f2c8aa6cf23eba1788d75d297b71112fbfc9b799c66794d263f9625c0d8ef5a81b30c3c879fc332f2b834f8aa36c67b5e79285a93bf14c7158647a00c50bc0f0bb9c7d6fd725415d7b7011c810133d3081866391703a76b4a078c71bc41ce0f26b2bab07135cb42658782d9e200d3d55e8a386a19968bcb5a38c317db9df1dc7b4b40fa98389fcfd5168dc57283a03c94ae387556040af26ad99a5d79ce02994876b925156df24dd8a328d091ddd2fc387c1b3d2c0854d66389c50cadde1c1ee8ea680aaf90846fb1babe2e1e19ffb7695566b9f252d6a2353143678c3e24edd581783e8be0c1b52bad8277bdb5e1402a8db447dd5f43ff6abf8a584d4dfa0019abf8b670a4b2f6949f76f9d3cd59c0cc890a5fbbd093d1d96afcd8896603ad20b86749ea0dd32014d4cbb27fab91403ceb8adf4fb8aa1e4edadc83788938fa83bf06c8801d0e3e01f8a34f4a3362e65b2460162271f7c181e75a4123319b7916beec3a50ba030287eee66f0fec3cbd80f98ae557da461eb868d283a3e4d258190553285a7bc3de8d46eaf46a29617aa0e8fc10a07c8eca20d6098577d81b8c8e0def1ffc6a3a980f1ff2bc1d51a065cd0a8a76b8d112781363406ed97d1e01efc161168eb7918bf5300c2dd1f83d304df71c79447aa08e2d40eedc9a1528bec912dc8685e429e4d3e5ada7591ecd0c767440e058e9aa9f5773a703d09faf3ede33287b9126f049f130d349229c27ee0a33f44d63830b67368ece15e696c905c1670ce71abc4fa670c4569309e572c1bb1b8e3e36f4ba1925af405136d60b4ad2a1db2da14de2b166d4239bde8d3d241e0e12816a91bbd696678dd392fdbd187211bcfb64f77c917473a5805ea6ce44319d3cdc8dd968180a840a5bf39545610a0ce11aa3a547bf0fb04dba4c6ad2a89b7ad77c8dd574fb754fdf08d6484d06b8b7d042ca7e2a1b94a80a23dc635fabab2633c4564ebcb5ae7edc5f4903c77d2de52be01ad4135764cdc0d4445e543fcd922e14cce697f77ed8428eb36a637d7f91ddc462d084019149cff18312518f440b3e0273784b94a2f8dbdb17ae0ab3c8cbf3066d305ae3e58202a818343b8a29c12640e0c7ae21e2c3de3e02a89d479012a7addc37919026c03558b01b9f6fcc12b2eec35c5a19f914032cbe6f33b509b841dabffdecd3faf038b80eb9fcec4b0eaa0d80f567a4db6eea4bc2da0c4099c3b312547b36b5f3d2ebd1640fb4b680392b6e3900600be66bde8f45eea30a762dbe5164aca6975ede12d8027ec6e1c203c75d77ae9182ccb75f6cb03233fd142730b812ddf25f8b3c77755a1f9e15e62943c5eecbb94c49d070aa36a92fd15f3b73655bd500f744ecf1214254f764e90e225cda2d5adb7c9b4bf129e324a4ea36013bd570b33d07030347d14343ce3a8f1545491e66ab9fec7f83f79af089e7806d9e27a4ef5922f48b94e28e058a7593929782c5b7f7e52022b10ecfd98ae23600c3f854e29aaae494e49860ea7170e520d64d84bd40c50c65a2424a5fb516a0d31ec99bbf97c50ec4c513b5f00cbf724023153b0c8dbfddc51dd84a3f5a80b334fc9233e9081b19d65c0d056ffcc06829e8cfcf64a58c3fe461c7b60d28ec13201594cf472aa2cf59bcfab88cb3bcc01faed448d4a0e6b7813d45b3f1b090306f8f7752cfc9cc2b932364d51f6fb54c97eb47e5c35d4e162a2e46008f7bc764238e0e8168be9e0ff1804f6b5c225d9b426582eb2adbe4e74945e637588f999213d862721b5c56fae38059c2387b955a612a750b02b69a420049edd08ae0634af2850fe11b0d1c1684ef85f0f17be69aad85e4c4c4799d8c1ea6b5d1dba54df4172bf9de89667b9ca69cba323b47831fccfb2167d9765eb781b5bbbe61aea53b5155bbeea64528625a020108c2b92335eeb21ad5929f779e9104dbe1bd603e2d649b70d2c09964edc021881fdb24029cdea652602478d98efd74d6f82f093bdec33420912655a6521d44e32ab608cc7fa0fc5df7d5a960c3a8f15eace1f97c38b413187882859b66fed16c2553f0ddd9ed915c0fbdd23ebf11d914f255cedacd98f81b798f7b07e82ad6ba277a39c2b0c90f4acf2ae6d187a9e0a2dc59e1561a225df8c2152e25b0fdde334f7d39e3320fff24f6da64cd2fbe1db147e9f00e7424e04c683dbf55c7f08b87bf8670e508c2e244b82747c6e574a65e3efad1b2e4a2f702513c0f59a47acf24792204a075740146ddf8ab5a1da2b327143d24a1e8730d4760b0af782cbe10da1bea8431149c81f88e234bfeccb645f82dedfaeb31acf1318565411cc09eed3decc895dd7e8998e748cb0ea8cdbbecf23c13b24204760021984210a70f9eb8a006cb612aa889b9611a54b784473763a54bcc1ff37ca2f6ccdc3a1ec44ef394b107de8e1d29c8e087faa44d6bfbb4743e6f124e5066b3b57c19a82d8ec31fa2ffcfbbb55fad5f9470e2be3f2b356ed7db50f4f6a49c11eb37dff9b2fbbb18f025fc1ee3f7d2d453305701e762e53ecc82d89ddf0616114265a7aacf1faf08915af73125300e4d2b10ca4fa28567d7203441d2578d03c9eedc82f0d034536fbdcad034a531299b23ea4e62749248d93b57b43d50d7332d2c00c47ed194cf9cab025094a42fe584da768f3d06c21d50c1c8feb5d8a99ca3e5af7871dc89cdb014bea906f01d31a991973015ae34ebfc0c6764e428b1ba7fd9805a30dbe2ad9b72c47cd80bd3d3f8f732b89cb704e0212b495e9a0822a2d9f5361c7b859000737c727fb51202fd682aa7e29dd4e80a6b7dce0b59af01957a8f489fa03b6afb254a6dc7d218d85f2b526ef7a0d71d183ab67507b305c9348733a6772fea4b6a31a07a7a84ba9f40fcd793673560197c66c9b47c407ebad7f7104dbf028e91c47ad4a2b1d882d1cd72711a5744a2fbf73431bf2c5357d9220f092d028977f5778322b51d1d1c5c0506ddf6297c2597db4ab16579717a71e1de089040c99163923dd5bef3ecd8dab3ed0b596c308211dd41f454670087124c20528b2b543f2e511ce24b5e08ff18c35ff9937ce434cfae9f1fa2d7e66abcd312cd2a145e7011e6438ba6b3239fd4fdf23617b6c601bb416fb323fb7d777cc714773147f47aa3cd17633f4306baa312a28e90f9f6814f94089daebd6a0fb7856e4f89b1f2a60485693fce2cb185f6c2eabc9b47cd3aaf707ea9cbd61e699362bc44be131ab7672fdf6c8547080927530bec357eba4b1b6f322e7b537d4166d752d39bc7a851895044a934da734ca78e4dd99b57381c9638d28164ef1fe35591dcc2ffe118cf4a58fd19bf16b40a6f84744091d654300443dfd56bf749e57da5ff937a12859ffa13a51f5a5e4fd9731c0ae44b976e999d16fbc32e5ef44610bf8b5afe8f4a4fbd0383d770f666308cda0a09c9961d6f0f37362582eb50ea1c669c50839aba316b780c7fe9627126a30c94490a31761a3abde0591a73b181daec0ecf0010a52bb6f6d208e052f16e9f08a467b47a7becdf2477797386f268ac939af7b252c4c2c7c8882bd009ab1878a593ab6964c76c4e043d85bc54dc367432c228390872edb04a04c3f74b42c39a8133d06a520d65f1086b7023ad5b43ae99b4357220fa91988a527dd5fc94f635e555a72b240a972d3a5d65abeaa107a1acad67bdf51d2e593e482e546149f0f878a3c97fba3f0a44ede6388ee1a093a3018449c6f547c95700357e086ba3132caf92db83cbf2a571e638df8847b05c8f70deb03b92bf7a34a87a0aa5ec30945f661e9eea7914a000bf9957923de8bfc4199ce77e0c94b5fdd7b163f1bcdb02e2dc71bcb17a76190803558126eb545035f9c16edb4cdabc50601b6950bd773387883e0d4fb70e8bcf99c43875c919857c43ba666fd3c0154e1b9d41a55ce21b1c94fe79a0b8008ab0d1467182dcbbd63ac5c02366d6b0195f2d24e938f97995aa1dd6398dae606fed1a7e09b40233ccac7da9c93c7069c74814417706ef99638567c7914a73bb27fdcd460cb256f8555858cb7c6afecae56546b865152ae148530a1aa0e96b12511ab6bd847d1736d5d827801e580185e5054d58adea9a453fd72901b7e234a34ab6f24b6317e40364b0e8e011dbaae800adf3be87a31aa21e7fd90524ddb60ab0c1d9f6cc8b2bceea0dddf77dee455830ab90e4d44b8c54582a93d8ee15330b4cb172a0ffab7e69f2bdfb8eb653d5505e7e37b3705f1813bb4ab8921efabe5aae4c36c94be898ab63347ecd7c92ea12bb5315e7d12d7e9194fa99bb199ee930b77a34b917ac3d83ba232eecf8e9a079b2fa201e3e48ff02b45d03e16c155ab1aef25b80c720cd16046036e565e9ec59fbeef9c09e803dfe31da94a671de529ef08046fb00135f81d08658be12da1a7dfa99d968cfd587fbcb852890ad23bd0c71301a368c004562a9e8c207e8a96eee32107f01efd86095061feac258ad061b2a8d13ddab1dab17862a5603fde364fa914710ea616b28211af54a734dc43b8c07bf6156d2faade8efb7e5e3e6ae1a7206120ea7e6d18d1ccdff2635269de2119c73d003fdcbb20567ebaff14ace7ba8785aadb80eaaf0d2f7a7da4599e2703bb3b4f97bbfa68c2a95daa53f43c045d4a86d6693e39837468b68707e7d9ed734d5d8eb65662ac118fa3e710a99729a7ccbde50bb5a488f6b05fbfffce81b63e5e2f765388dba4f951324607a1b7b547f88d1703be108e9d4a1785fe1712a6f510ebfabda2c93495b080b6e7ee24f1ebd319c40c7eea684c82bdcf60c9fdf73e5a0fa0ee533ccc0d4db3dfec8073ac919253c0c98a3e89f8b3f630bb46543979e04ecbf9d8282241b32327a1f2dcc6e56b27c54c5b386d06a7521065670489260e190a84ee7798ab453370565914022a7abbac4e2d00b22a5c6f9c91b30912feb2ec7af3a5a1747d6f77e6746fb658702322bc91a698b4d8f52b442f8a1d87401a96f7f7abdaa08fa43f6e0cddef03e640db4e7b7ab9dbe1a0e67d6a2beff41b38865d14635b023f75154feb1527927f682ed498dafe221d5fa7f05f9fb98a98061051a5e544dede7c623a989fc060fbce8a38f6086c7640779fea40d68cbf7d5e6a252fe6c453c7d005ca62904e261e339dd36184c4d15b600e8bdb92c723664a9d8ff2fefdbd1887142331a435fa9a6364df8084ade0d035d4d1071aeedfbfe80ecf8e2de064a20ea01946f5bd3af55884c14ee5cb37b2039005091515a6da0ac2a072ca557d6554a78c6712d4ca685e36a29f8f9760f89650f7c51a969b9c78494f0acb1135a5adbeef373b87d5e68110e98c6f6464c7799066b68fc6da680befac4e90c3989af2864b581d3fea01574558661b0aafe5aa9cd7d5d938a04694126544ae4f92e472d2e65fc9aba49ab44470920e6285dd95e9cd4627b15e217301d5373a61d375a76813e6903aa28faf4998433eb37c6e61af7617643c8c2e2db65ef456ea0881b22e732c9511a14f94e8f13a90b019a3e651be69ae23790ec4ecaabd83dc89ae2ea69ca144e4f721609cd4369adaf734eed9adaacd0f40b6ff6d582f411107237f6d1641ec68efaad79fa2a99d47074fdc496d37562095f507909e4d17f006783888aaa876889109568a2c4f98e817ed8eedfa2593df034c4eaa98c386e5adda5023bdbd513509698d26fea16afd53592ef343e80b22cd50da4335b148c795694366f8680fa9f0e057d2098cada82472eb83319f15f7a22e01147e714109b1f12c35cc2cd099f40161f7bfe2751fc94383bae665111a4e69f0901766d693db96a42be008fd40f45bb8df9d898e1f146f4c9255866c26d1858967c230fc34e9f6befafb11b661b7bcf74c1946445f831c0a4c4837b4a74b6268468050fdfc1ce424405aeb6bc1bcd8e1e71abb1515c6ee84453adcf8764a522f536a9b53d5ccdc25d3d411bc89bc2640de22f225a7c8b6a19ad5f24d7b17776eeb3973d74c7a960791cf5b540167547e03e9a8ce14275c6546634d4c6c11338ea5ece168cb59911cb2f541d3d74abfb256f52b40ef8ad4100b1443dc6c4e32c7fcfe7cf86cdcf72dc90789135bd7b884a7a319b2eb0d4a1dcb6fba46c1522940d13c1772f249514b03722121efa77b35c6ea51840b26d92f32351f948c1f51181fdea35965c3aa276b14dc179c365b8889ea75e80002c028672bf716675edd3d1cb6d194313a6a4b2e9c72ae701605e50de2139f91fb0006f8dd555fa1e5baca159343786664ec8823536cd7f43507c3ccb9d69cd9b5f442c1ab0ba84f19e52dc75c22dbd83e15dd239bfc816c00e3127cadb5712516971cc6a8f57f1f7318f9b122e2e04affb5d7537bbd2bc8d3db71141e743828b4341f5f8f99f2eb4f6392bab66c33feb2e5ec45af6ff07450790a11c89bfed8f9ec22c3a2f098a4c2ca6af2468d08042c4bd11583e0cf05139a13af02c35a13c20e72dec1b49bb778377eaaf0fe38431d5bd9130a5634b272877f27a0e2c5bd30eeb68979f75400fb0a6966ae0fa46a2e78e6c5489a07dd4a0d6d61dd0ff74afbb0d6771df7da35b92528459e0cbbb4b7e6e4611e40875eb9bc4efae79138a0986658a16ead33d28cd328c04f0b0db19c8f51c59605b3ab4d58bef4628f9e9a53334a16baec8542a710b2d63b3a7a4ca67ad9fc5476eef71f00188adc345778532a43cfa85c0f598326e01f3aa7e198d58ed53c6bd564cae9aa7d6c98db1991b8ef18778a3a0dec152d2c5386ab07c32892935690e3ec8623983a1f198eb096ced5eb51c2e8a7e8c4660b560349d241413e2eaef44dee721e86c81ba9776ca140b1b7ecb7e49d9b71fcbb6672d50a96edbdfa527aa3b8d80c641d44c9ff3971bad4035437fe7e152b9b8f75563114ee18a8bb99148045256787ea0850c44df427c4438f8ec7340bb71b0461a29511ff767b17641a3200b8fd33d6b2146d1a7d2fcd4f3a6f1e908922fe6bdbb79705b6c875acde69d93c4c974e74619e8f93456e7706e4e4786b9dabfb785a69cb2321dd2b859cf44d1565fc0f4a39c099dbc2bc3cae33317f02d0991ade12a380a824b735396f57bcd03d62113b1ecdcf7e160bb547f692a25a4145d38b0b8833bdba56be964e88af55beb6340a1ced34ee574e70d76c7aefb79da586aa920bf7a33c3f307d514bec26b4b21cd21ce8f9879cb75ebfaa742559e156e4d2f43944ceaf3b4a2e5d339c2f54ec2408f9c90740104d5f9e0af08c27082c9c6f6ca5f47e59e8a72c153ff6a220d17ba144e1a6d92f97103e901222b001bbb0013c497ef8b2db1b64a3823784a3036ea068c42713c8c6a15c13b5caeae2b57b44f4cca42eaac653886078b6aa71a6e84904fdfb67f18f14d3d7de9ceb0e0797c3888d5a2e502214ccde1dab0d1920c05adc42593fa20e4aa502c8cf9ab9ebe39a4cb5f6482637c7726ad8d621d2ddfcc05b246f155835ff24659ffc5d0a994d703156521d777c1a263c3c9eeafa0d30a9d2dc82397008df67f3703d84344ac63084d6e90ce95ff8d01c8110f895204a10f1c68a7a4d9508925fd7e88c1784c102d86f9cde233ae4886befc5a544299a2f8b6c1f78a5f31f94e78accfe04065f9f6379ff49c383d7574eb41a3177041ab987bc039c4a94340c1fef4a683b78b1b43f8cb0564b5d8f20b54d388115265a06c2083f16281d5ea7780d7e9a27f35c01ff4dcb5b85f84445039bacce1de32efd3af0f4271bff435ebfbfdf85d67cf83060b4e9aae3006d9cc62404dc4e624b2d045be8249a74cfae5f34901918a5ccc445f6ee394321433deef4a801874c43cd3f069fe4e04b75d21ad023be9b70d40e98d8066d1a59ec22f8b3443602e1eb04f96fde01c705ab856e7bbb874cb08e5b7e3127e3c7682ef572da426e356a0ea909df0904baeb19c9e43c3c5a5fa613f327ecc0fa5239329d7c27ff477e7bca5f2d9b26801f4fd35a28cd4715f0d8508ac0f37878d93d9f2a45f5127b47d9384c1aa8396c3a01ab94057a74f308e74175ddff869ff2805c9278d3d7ec3ecd033b352c2c21df9782a5c609082431f929a2694611a812b6f2b1acc58876284c717514e83e5d0c6605a2ee86e7bcaf00c850c919b73cd4edfead1532078389d300f3021a4d18131aa8de00cb5c5c806f6023326f0ec43ff14c441b5bf0b529bef8a4cc48d3e964c55e33294b6e5379d4fda1af7fea56cf111ab868dfdc7ffd6e45d5a308a96cb4b351381318362805ffc99180b169941a28880b4a0cbe9dfb1315ce68b78e14c06e5b885ac012c62d7ba2f790abfa9f7541099d7645bc5557bb1308a4160129aaebe250dc5a0df5530c5c90b23591dae5e99f71fefcac38811b55c79a262ee2e834b03f50e3ccf7443cb3ecd339ab918e6b2321a1c87075de97cd2a269e70e61300998dc68fe13ba21e4884e79d3302f2a590a84797b2ce6c980cc24a3c313534b3c49c7772f5719b4f7f82ed9385304ee3b2d7816182cbe8b96f1d7216a233f15d8252da52b010da9457798c797a63e75ca5192a223b077ae1c4a8fa31da6a4bbfa16e62bc3bd6f6e066f7feb68219f8ac6f860caf98e2088cb225dce3b1d1ef5874822f8317cb2f44d9bb6199b9ca07a7ea6d66fc4034be9e647837cc58e7e88e1f46051f329320e712297dc8ed36496d3ff2687c2092ede67363b3b554bbefe0cba7f2badd799a0f4b921536984fc58790cd8adc455191194ba27173d8a98c8d105f3463a7510c3986d19a9dade621d5a999b5bca735338f061b2bde2e6a908a865c25292fff84ffe007b708e67fa44144738957d1b1696d087081836393ffe5e241a7836d931a0774dac9688b64029fee4e5eec74abfcfb5ccd6cd090937947e89196f16c0e1dc8d5e62394e3505097a71344a930cde0b05c792a9616529c8c602dac8c5931fba2c317ec7a69f901eabf120c6c731e1484324b9480950e67cf7d76fe66946a5b9747d7794e93cb3dc018242d889e6cca1ce08cd40ee238acf3d682024663430d2af97917b1f0b8e92f70603aaf7af0a26cc3fcd23c12599ffb2ac5c712eb07a7d1936e5ee9d5246be4ff1b024466843a775bbe3c6e2f3aa24345cf3abeda252fc1b0bf022cf5643021c13f471b23f92dbce2b06f35b321c60b2c028b1bfa2e72b63c20fd272ffe3d5b2fc9e615ceff790d51c02c4f2a07deabd32e9f93b5717d86874b0ba1797f4e4b38d0ab4c275fc48195123ffe2e56c3ce75ddb876beada4b6038c840d819ed798718788ea29a66112ecce70eecfa8d620f8a7c2f3943e2faeca19dd47c687fe3a8448bb98764dea770e1cbbc4e88987fa6f7d4c5fc8f498053d1aed76eb4f8318c1a53f3b8b16dde9a0220c06653ecd7e5dd4d458c7f067b1e79043a68914e349814fc61b208e0856c8af0f97a42f2cb338388b9104d6e79a08127793d64ec29605385f9a80215f13c378e3525ffdb27dddd130bc92a607e9f20a21885fa5468ae8721bb0f94e4774d24a51d9f86d1ec264b8d7f9094e6c2ffd00a0559d398e065b1233235d4726c7eccc7241d4ee0b8fade64ecce7d52b8fc26a0687610a109f2278da1e7d38652d024c4f3d6ba1fb15886158d6c97a7740cd3d891270d158089248fdd82a70cbd834bf8d02a07f02326f1bb5cb76082d9df4db6b5c97bd965d72ec0217008b6cff4f19e1703933e2b20b1d9bec5b9393f1f7f7121b8ad60ccf1f0c3432f4591ea1758c1596f14b569d0b76b766806bb50052b120f9685bc8338b0b34e3ffc7d752e3f16c30fecd74abaf8e43ffd599b8bc3d57ac1bf6e3b9d1a12bb13966e9dad3c5ecb772c6edacb1057e3ea54895c6c9d325df0cfe0db899693c2731998cf11fbbf9f05f32559743a833d20dd8779187f6a899b71496bbf20e1ff40e67032eb2cd625a11bd45c19dd362b0e027c7cf7995731c2f0ec6ade1dc5adafefda276beafde351722a50be4a5931344bd23963354623119ce87e01f8160801bf6f9099603ce8002c39942b176c4bc0b49dd6ddd93355c9182f196aa1681de4401082781c612d62d5b3be425fe96b5a0cd89cb489afbbf7c73486ff19a316703d3f7d9a1d171a0c6e69b4926cd5b74c930109ff35269ed1b8c02057ea78daff6032eb14a3fe70cf00ecddfeac9b0f895a9ff3bf7c62da86c874ff9eda409be4f54d8a430383b5f878c5bb2c8dec6d6a007c657f41eee913855cd5754753637b37de646154a5deaac49f9d65b69f3b12e606101c67457019b4aadfe89d63b896c4b500af4ba14c4c7bb28944f57cc0664cdec9b9e3c9de9bf9120c5e0bc540bb389cf3d9b217e364ff0adcfc0bd4bce08c0fe426f04588a91cdbd663662370d9fb92265ac36b8d88ce8dc7cd108208bd9488837ba7890ec5bfd26c70e8b0541213b5a5ee450eb9803dc1a314adb67660b8eee4da82da1a18a97ebd886757298821a8e34628bffe8429d484de30d010ab39269cd75b3661ae266531c6271d1b769c179ad0342c5d22c0cc5e968c082586a84b33d99850f929e04070f86205e7ba3068125d3250ea7871febdbad492668f2951c4cc563264f24fb69b7a85c08e5ef46781c97501453b6bbf0a7c955a8f50eaa5749fd119576d1bfac4c653312b3cbf1bc9ed02abc44875b65dd0ba01003e778ee3b847766a3dc62250088385e555f532d689a2682b3882c30843e8a51490950fdf30cb558862c335233821b4379bef01c0cfa9ce4ccd395ed407f233368bb4317041e83e677a302abb18563e470f4f9b375bbe1b39f7e06c3450e743b720c0c078cd036e38a9ee2ef13be15d0dbf3a6e8f76a28b84dd76f762e4deb05b30ae2fff61731e7c44535241bf10b296670130a2a9644116f86e232454a8d7b49742a98dd5935cc11ae58c15421f5d16cbe677ab3091716aa0816738f2ce77d081a59daf8ace30db29ff7a9568d4007433495a6a3a0c47f3d59995ac6e01c7365f8765557948dccac418357cd7865d712debf11f07fff5ffbfbfea6dbe0972f740f70475d528313bbc5d680e93aa56da7d39b744cc97f99043355f9586b88895fb7aeffb288fd56a4dfdf0f56743186aeb281210baa1750d4829895a5dee3becbe86db3d7c7955d7f8c1fb909ec1b091e49cb6ce5dcdc723a7660e98da0a4dad27bec7d50deb32680fa479793ad1794bb16657ffc6e3a77a373995288708e149016a58e97c13d69fad5560d5774f072378b79f4f92ecaf0042fa368c06056b17b623007b18da5ceb0c67c54677113eb1090dcb2bb762d46ac69c6ebe99981a3bde658052260c02509de81caaf1e96cafe339fe6e055c3ea01fcebe06dd6907b8abcec643510c6a01ef2a68d6fd0386fa5743d22794a8c59a14418f80a9a8e644464f3b9d18797d7834833bd76f44070c0327c19404a447a714e0309067b69d6bd6c8afb19997062d68d698350d4b97d827c83ae7c898297acf03ad4cfad57f1e104b162ff85da5287c84f3a0a6ca00c97b670d349ea531ac8336872b88c095ec308d56424eaaaea47181a83e187e92dbe9e598439d5bc57c16c4440f622624f0a530380e912ca948b07f4ab1e11aafb4e9615b8c385c6d23c33d1fbcdf51b7b7fc3e90cda050824dbe73935e8e9ddc88bfb0f9a396fa43e8bce8d50e7e877dea88a1243a93ed525e7013973660d0b1de4450818c51ad2e538d470401827ee7b2ceb3af7dbf0430fc74b27cda3f1a1dad4d8c80a88de15fb3b36745fb9ccd86d74566087ef07f4e682657b32e353e7753d06048c8fc9d4746227a85d4683f5fb752c9d863b5523cba7d831c5bfd9dd5240bb75e44af263a968bfc43cac7a1b6c5f3578d5fe1a123da909c67b97dc5a48f1f28064de7bd326553c65c75e662b2cae6db9fa69f5e83d2ff4001d63da5b81b4c1d85a475c0d72caee5dc7f6a3be376fd348cc81e0cc0c7f31eb9ecebed14d59c08ab37ce02603a715874934b24c508f7050accfdc0aeb9246dd678c0813303953ee6191784f5806786021cbb26a899e3fce9bca9def400ac58526992137f828237afa3fe7870e35ceed7226bcb5b5a6297f0655362ab1744afe7164e5ac6a041fef2ebef66762fed0873d39e123050713ef2d78bdbd7aa5f076304190d870e911f4616fb4980b7a10731f0ca2a759e1ec5edffa1ef47bbd2b37b8da4be477eabffddab3a2efb624d3f897017380e0070bc4fb890f81ba0cd780f62ee8d5112910ac9b4584c93d3a9a89ceded8e872cc4790e0fcaf7e7481ffaf71a8576181b7a71ed67a24801bf11267af512260ccf2cf919497ef6fa5af145a43d9d0ef836db6e3e2e96394078ca4edf87cbc9dbe4e4247b72a2cee7513567f328459ef5d14fa9c1d8b3c18c3303c41f73a35e98a2c8e569135f44dc9d915c3d9c1219e8c6dadb5ff4c612f460e85da223c1e5faf02093c395be74755aca751d2e2dac163b42a5b1bf7876225586377f684e326b5cb2863aaa34aa3338b106d45c2fa7e6455763b625034f89635b80bac730631b1267134f522543bcca1ad18852e456b62a8e336cdacb22bbcc91f194d0155658af841aa2e143cca7f9220887199ed149b7936bc7fca34fd47416a7982e35cd4a461866bab96ac3e375eba118b98716e761dc34a35a379c2e981d823c7f95175fe26055b44c4218a6286ae3911d561ae46f6c70909e93a0c97540ae7020351b4d0a7cb6d0f10f92d5ff65a46213b53ef9db15f89bd57b6613d9a290b20f2e0c9381e711f56f7d3a7ac19349820a8d9a0c46864a512ea0b1cc165f2be257c6eb4a73365f3f7eb7f74cf18b6eaac7127a782fd386fe8bf1df5bacffc1e8fc9782311f5e18699927e63927e92fa89515b577cd9c8e595fb5aa81d4e8c8e696360a0ebeaf768359ee858c6d804c4e4fa0821e40f7b6976a2a5d62a0836ee542dd1413454d914e4244a18993fa7f75740c45ed456a85aa2405a43657b40d6fbf64146b5c1c5e4e87b3201c2f006f65e37adb1d0627ec5d8a2dabc3977cd7664637449fecf7ad892a67ea7d6541ff800519d3101ec06c953f54502bd070d5770aec2137332e205381241d003d9c560beba5ec1379c5c5485f5e01f4288712e973dd182faa790da8938bd6830db43397f5f1e90f5eb93749c09d6db2abea3b6fc9a19d1643e28ce77cffd0774b352c4da5e470389d795a13874bc981ca293ae47525df32e3b1b4ece84e455853bf4fb81c0882f67a16e1135f551b0b6e9f42b20f7f98d9281fbe4361b50025ee080cd71190f59403faf6491a48bd54b8a5255c471bcd27e3f28a7df718d978d0b8c50a4ea162f6aacbd1cd72d8be9ca0e04b85364a0f52905b9be771deae68c010515b8628101574eb9d32164e43f84ba637dc23968a3fd335028de06fe8eed9d72df42f560ddccbb294cf930f2b1063cee12180476182ae6fd5b2de4e853a22ad5196616780f53a63d728f1b4d4e19e2953b33f934dc646dd07003e860b6b542c49b30dc7638e42c08b00e8aa51121722fe46af95b5a400c97df49e5e242a0a1226afc52c033a2d8cc941ec64d41c7680169842b55676a83a4892c9a78637b648807f4cdb54724a88dc4b57801a6941a7c70a89ae686fe3332f7850e287615054b868a3b3d53414e38a13183e40ed7814f8f0de3e7cde86e41e623b99d90f76dc90ed6947402be51d39a0a1e5ebf0395db71cb5dfe7fcaf584fb57b638c917b82729496c80ef4338e1bb32a877f071828f6ebedbeed10566af5e6a768ab7f0ef7423b67063c75afcf0fd9950b8308bc4674b56b656249471ccb01708cd96ed4c965843e85a1f7a866029a84bdda24b5b8fc69a5a71c7932ec14b3e59b2f08e407246405e9a06163d5a4cd5ead67d9a009f2f0b62ce6aff49c7ffe68447e64144bdcdf0c004f88e4bb9986014f04bdd98b7be01ffb4e3d92af6fbba601e469c5b9881cf93408b677830677bab1e6f163f9f35178a9799d9b1b5361d3add47e8d126e455bdfe0c2512bcf05e78bbc164552cb0cba8b722af1844731e06374f18f58ed5cce007eaa5d5228d8ccfc02a4c886e536a41d1976d8d17fe06b4d048f60b110cccdd0a932d2afb1c0cf2d6a4e112cb58d54e938f9954c8c47936cfe897562b98514d2f23b357fb3cc55e418986172d3e7a05eee35e07820b1eb703617ead150153f049576e492b4ac8146a7896a25c17b1f86957fb029f0978ee0c12e0d722606533895868df72a06e91c6f779fa19458f9132c28788681b727f088ff6bb1c07e30df027a08ae54af16c31f25941564a2466b186148a4cf044f56f948c9c15de6a0d6c2c7046cbc725fc62e5c8043ebef27da2bb10ca9b296f0efb95a8cd8f1f6481453210f81230f07f0bee2068a86210f20c45039c49a2678e552db698c07038a4295bd61f0d681302633cc5afe75af030b9aa9cd1d5d9aa90306f376faec2cb4331a155659d755937cddfd100db43d5f80cd164b481ecdbff2ad09ad864a4fdca9904e332cbee0d55cb0c9bc8669ffc106281317192dd366fb51a87da3fa37678718f2b6e9f4bc42c47dd1d5d1a445255b076a0773fe83569402a0c0a6f70e22b86c07b5b47d9967177143388c5ddcd96189e12b718b6a9e6b5e93ce83319df2c59ae00c3aa73d998bfb0f31f1d64a55c0c0ce67c75bd85f778042eadd540a890e3c595cf4ef9cc9b7c63644e18ece68fbd6924eb2f7536e4d59b092e6adbfa30c3e97834fed8d1dd02b9298163c3aee2cbbc5648096edd7352e0532f7884c51cece881830aed57b4ccf3b79d766f4b254c3a719c8eb30f3be38b5a723d35ada55017aa85949af05e2c16dbb3cbb0c7be65a2d10c15dddab9ec8ab28cbcf03a2cafb87b53bd9054b0c56b0b85178de21cc0a67599cf4ae42ea1f3cd9660f5c93140d1c40fcac6842c6f0855c6f9578e85b228c1e55225ad75eb14dff7796049d01bffe12d22b0003e72f77a2462c56065ee3184d8db0d40cc425a5ed656b5c945ee25cdda99ff93151c9e20bc8fc249696f2b0bef6ae32d4c385c16465fd9949cfba28d93c89f57aa0d38ce4b687756093f8cb0ac9c10742d8dd0bbff2ce930b534358d6b0a948531a28959b32fdbee51d520e8bed12e53af902845824a8890991755780daceb773c01592b9696c73424fde21bf4ea236a0647f3ee61ed1689027428b9c2e69aa19659398e72df3103b3c3c816cce46716ce80c4623e5c65155469a1ff45eb0052681187e9626efd5e5677f28c3b58ff2cb3f6673ced62131a17065c9ada97faa5a257bb3a66a5171c61b7623a9cb75be4840b8cd5179930eea3955800e627a21836309c85fd869b3fa6d7cb935265cf12891ae31ff1d6b409e3a527ba89d8bb19c4e4fdd3ac3ccb6c92a660822bdf3b1f38a515a62f6cab92dbaefcdf46cb4ac98ec7a4c4b2d3a2b731dacf00eb14914b96cf0765f8de5503156e2e707c6745524baaaa6f937cab5df886cc17ff8a859b7e90c870e46ff9a22bb805139a4928b5a839764e0b00f42c2398cd9f015216394f97722fad78b5ab51f30e2cdd2b492b96f53469a77f608d198fb8d6f409602b994483d0e27e489395171d21dbbfb399b33d4ffd125737717a1ba328e1aeee63dd006a86eef188cf85d6cb223c71e90d78d60d065773457aee51f13f9f564d4a7f87e0b9a76da5a091fd2c01a15010fe7f4d609174dcefcdf82a480fa45b5ff72fe73ae580f6c8945399024735e1dc7936d0197b86ff3eca72288559a080a94541dba512d3b895b571459cc549a2e8e6dc4836eec03112d99b783f252d0dafc0cee58f4da5850d0f185f41f3b09f630cb5f6e40e78b31091f4996dd944164f70a617b0da1542c5606fc4abb9778b67228b46beb5981a0dba46d43ccee9a194cb5f6438bb55fb1a96a29cdb4d2d513ab9a0d152ffc07bf7b4a95d3c665f1d48e6ade30b5effa56784a729384db0c4e5d09ce65217bdf5d8ad861f8c39aa13c0a97cdd1e94919c44ba88d9cd8d77d3b72354840d1cac925bbeef1703c5e5f6d3bb1bb343add27a8a707873388aada2ac2365305fe7953cfc1324116f8e13994664b5e6ec5118d48a64804a89c414b888ea552cad3bbebbb62ce70d538072dcf9d62ea3941f1423331dc1e38c52953d2505a718a1813df07fa639503178b5abffb145514e354f9fdce87c232a279149e5cacbbd966fdf1cba643fa12161e3c56ca11883d54754ecd7ab0d510aba86d692e2fb63afb31e6243805075cae1314c829bc1ca737a2ef61d1259675505d4a5bf6c30b6b52b50cf88d90624b20ef259952cb0c5f247f8fdb1bdd6d42db048192f71abde75779ce3282d57d735a1cc37e6283b0a64454624db18278dddc73cdda1d6fcd8e7056e735a8cbbdfa0e05a45ef1ea456d8babf354746cfc28cdf11001bb97e26b03429e08c841c62c6bb2e722cf25e28f25b673ee1026c5b0e8eaefa52d078c955a86d395dc8dd72d58af0f8931361d210209b2dabf041876a8ab824112d5efd46f175247d81a331b22610fb73e2fa5805bec8d323531a33e199b20caf799fb2cd7893101e3640e31e709872db980cca129c983339fecf53339e6c47e62e0817b4984506f5e8632a125a3cf7816dd82083d333e68cbc3b68f2cd4c9eb3d4a3f4b4c1459cc25cd365c088808b84478c1bdb00d15969f2fcc44e193f145c3212ea8320d13c2556807870491fefa6e5b998945bceed05d2fc07b7c35c498e0516a3b097495814d5b9560370b2d2a810d79cd08a7fb741bd89bef803d0e134fe4e78617a3cb3105e926e23c1ecd6ecb73655a6ad3c04bb6721f14a7e599b202577c2c5c751e9a23644544fcdc238850436a7ebdf674c7929d8f1ac65fc7986d36e6f162b5a6b6d684053b5f01f82747a41b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
