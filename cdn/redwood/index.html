<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"17447f1a1c13fb0a02d85131ae49d57fb09b3ffdc8de59de4f97e994e4ba1e32a5b8f77af97c8e94ae5d5272c6522ce7313578b9ac8f8239975fa797e2dfad4dbd30b3014bcb1bed729b8f8081af969121d5c53daa7b95cb015377e8248c480116b8a6d0ce40c54e3bb6d310e24520d8101d9857b9cf6e83022a41e10c7bd757f89a68bdcd35886e25c5f8d729b3eb88ef6d9f457c9aec988fb0ca7e727aa011d67bbbd975edb05551ef59835dea055c958f006c5cf1ee7afefd0de03dd21435c931c032996a635aaa3a2b2752b2b5e45e2885015907b2b388e2b139224073d921c612979dcebce971fea777827e91b2661f8987482e01a90fb94670b6dbfcb017d54cfd27b785e4909a21512cf29c90766598788ef05a6e5ea164dc7f63cfd3d5b29a8704066863411d6f611bfa630cfff806a4b6adcbc97755ad2d59c8c9323c115fbeb2b7034e515ca02126c4cc4e5c2d0925264eb3785de7f288fa913fae180dfe7e384e26e57f60426fbd0847f7fdd5bb5018481882e085272dc751ac750bacc1f607a41637088494e7e9b8caebaf2831867343dd4063b6cbec1a6e42243cb5f8613c9537852181998d64b05307cc38beec65e3c87c3b0b33a9b85cf69a60a6ee42b77911bc6da90e690cdb06b08c5d278bbf7e4dbcb684f782eb95e91d68b17e36aaa613b810278d30b42181aed745a8166b25c62cfcda9b053cd2c82c6ad3906a4a68b72cd6b7971af7016d180be330248d428954346455f0b666382ebf6e1ae1cfd1934fa71cad9227aaa70ac59e774b9a48d35f0313c13ca3a9d5e8af31956cb7ae07e14a930877ebb37a309e3180feddb655196b9cb5811800993214b4dfca7f6e6108db55793f3c19bfa878b7ef2f495845364ebc5140421a3f42358c4fd763fabee26ee759f37bbf49cbda7c539288890e4e1568d17c46441a0ca405bdc3083bb91b8e83a6754fdb5666922ea4f7928451ac47655f1d2260db4d1be8e3adf84f2c8f2681a2205ce3697f77e822853d654b8fc62b635c952f6c8493a67bdf19378a8f4cc228a0baf764b42fa7dc79d4f569df72e818a5cfd71d7dcc2a9bb00148b2fa0b4e38873ce6f2de7b43226b038ae77c48c3be06c34993ec2b581c1eb4d34ac724d76851bb24add78f0ea914a0be03ed16d30b5c4d9882b2c9396eccc54f0564a761d4864487ea1f6e5a972ba5c4647831b11e4abc0e76be6f4de1ea511b2f507aba10b1d9289d3446a33d9785f5d673fc1b292deff54e11874b3584115988fe162ffc84cb1e01679e88c3032f9e9eb2dd201ab5a9b6ad6745905f6f864ad4bcda12501677b2382c5784c381e7e04799a2e76929a275d50ee72ab236ecde93c7eeb57e3097a7034a9715091b706b20373cad4c965f033279d6c3c15a994d0894f0e3dabc6c82f7500ad2b3c9ff9b9a2d1f0c3fb3acaf01918917c92a7c0e967bc3b338f20b1e583d9a883641489d3c6d769cca954ea1c43f2af1331094936c78dec80b371e4609225e16042041eb0bc5b56580abf3d3097295baf79ad7a3599f32b964edbfed0735c67f7855d8c42139ddef02c9701b48978a382e53d2ba4748b76374b1989b9d44fae31a3aa7e000485d50e8ef7724d666743c6dff39d5258fecad9f9e7007bd30918bc66406837cda3e3e0981562bceb189da9979a131b484c2e3d034ad338176eb44e4511f5dc30c952a4d53b7c28defabca854fb205f064b6c00ac8a4571a5ab1b199a8df10fc91613ea7d703dcb021ba7c8ecb303aba7e698393bb14160c4c7e6a778ffe684df4312714a996ffd2bb1299939a8ce5ee68e46fceb613d0ceefe43c7c7d51ca881f50b43e5320cf9d9ddfe1b85515942ea94b2dc0d242525bd4e6605b04d5ce24c4dffecad3042cca0aebbd25ee3392811f863839f4428198c7c2df6d13d2a875827d89c6c4c7fef789c79968eaba7245f86c4f5012f30b2dad3cbbbe76891728001a00bd314ff4a9d5f28846f42b55b2bf0268408d98366e9f8bd3c4a117d799cfd89e62de5f42f6ac1aaf91a5e4076003493a1d1eb3938cdba20cd8606d1cca9df4285c84832f4abc38d36c143ca73465a7e136eb1d53b31eabb68e2ee7fdd4cd080bdc332310afd4b2813dd5ce15b6c4e315cce0d829ca13d60f7f729791477304745b3f49ccda0d53510ba2dbb3113720632ecd93316974b8991e7850776f4e963e48d9a1860601867f47ed85e335532d88a77efa76a58bd7bc21f9669f4f4ddb1fb883646d24ecb20ecec8e1861e4224d62c886faf422493d051574800528f8dd47403eb906a4e51e4d6deb9d5d5c548a60fddc6e71b514e185933f949616302ef472965134819e7a616207acf08643e7eeb24620b6488a9fe48c27c3aa5e5514aa9a8d34eea2fc396df3c37933981ff184b6ebe53f62c77f9ebbc5ca4c99ea5b755a5c434daa4a4e20e983fec22ef20d4f97ba93316e32efc7fe8b01bede9dc6d8cf0337680a4c31ba9d7d67bba14f71826f3e0015fca86d28b4d0c5e16e03eceb8fe91f044f43d9664e8b1a46a545b2b4ba1e9da91057a644a5eddfb1d131515b4bf94b676d1ca862544c1cf34224b912bc0ebd58e501203b4ffef7da6abbf09ce05ff8be93d8f1e820f73e8c4dc95ae42852275bfaa4f7b31ccbea021bbbb19779f87f9c8c5d34e466a950107faec61038170d3ce05ca9e1ff3e80397626827552c8e79a081bf97e94f1c1bb2f5af31f5da5b8a2ac320ac401c569f0466ee36519bd08b3c0e3cab4169a8f3333a204958ce29282d409a67d70d2520a4adece9d7d763cf2e4b6169b9d76511936ff3d4c484dbf27d68a5a0fa022a824b754098ebff07c6333b9f4180d1182ce144551d19437501a70d54b1a3760df7f848c054691941963bba658b785dc02bcee2be4401c25537ccc2ce215f93849d1d1e10f0c10a7a64b0457d7f3f5536f105efd1a04e0263db7725ba166559f2e5640b08033cc85390c6bbc40a105d094f0ed1ed0d5597b2dd87e806707465965f1ef97a75cbb2652cd320e49337908e05741f13452adcb061ffc723016f8647cdd5866b8a09332af64becbc584d0c42e30f5ba5c01a50c53dfbe2c64a02f9a716b43e3e4908a6f54ea582b02172fee18b86426c37a7819804d9fffe6a0616e5a58875db9880b948a576c6a622ee3d942787de0a506d5738ae04ced8074f17e8d2cab44fdfbeed2d9937660514bb89c6304aabf6423e4a72ef9604f80638f4d20be3456fe48e434b4e96164e095aeb9e69981f69c7d109f42a08e2fb15c60feb6cdc2327b96a69722aee22111670ec1a854605822617f64d1b1c443055f06982e4659f8fb94cea1945791f349b1e4c83c6f70040f71efae09548918e9c21cea4e5948072216809d0f829b8b9d8a4a8aec829a847fa586d78eaefce769543926ab004259bfb6eb0789e57cd10827eac18b8b240b36ee4cd190a27c302a52bfa07993a1c78b60407ab383d298ff04717c1c551e81588a5745526bcab12d7c1359ea4287ca3c28e6c08dff601d6d213ec62b59e32212ed42fddfccd7e3f5b17a35b963046fa37a32da7cd709123e775b6848a0177ac6e95c3e358cc50fbc8e99153d72d13ed22dd6ae8669bf212bf8c2e1e605ce1247434ae5e0f453f3fb4db71f1dc2a5aa920de6f96a79094d09d4d29eeb4c33aede678e027e641bab9d54343c8f7121d9b8d53746b02f44854d40d1762e0969427908662f9e6630b7b67fc3e09718439586483b3f388bd26549d80580b167d6ffd7c1806484a4bd1b21ccb083ac3273d616f90f8204e2efa1e4e50b401d5f83da8b7cc12cc4bedf94b10a0b03446f14615b08e756f7a68fad1e10299fb8a0137f4d5ceb63ca494cb8bebb4dbd36148ec26cee1d7a41f7f0d2a19f7a5dfbb677065a693a42a1d83fedc13d2f5735596f33e902a6ddeae84aa65fb740d66b18b7afd5c1ae3d8893bc89f55505742a66207d35f8758caee52de143cf2d53df874deb3a5ac69a13084fc0af05755c4d620ce484e06f152b2ce78d3bb0c4e273ae1e9fd2fba7c2c9376168e0e1608245382450c8e3c9ab91561e45fb2332edcb065897251513a6831f4f3bf10cf14d146615e1e698a26bb5591911307ccfa34e7d8fd465530921e16cb7ba47fe9cf11cd477c62a7f11abe968fb632042f770436d0ec11862416bcf1b9f2697242cab301d036668c31fb2e085226253e5556eac3f1bcf18d5de3727d2f1dc764f73d3959507ee0db805bf255b3992e713b6595f81b777e81682d6576b0d586f5c76adb4059a9cbc9aa353706cc993bacf6c6d57182a768db3053a5a681ab7cef845d172ab4eedbab92f105ab4a447a846c607e68a6cbed8599cdd36167b1dab09a28a5de0691f80aa98d95ef928be2986171403bedeb7343dab8d1f82b86a99c98405cc7f8f7f04be6c737b5750f24c3f2bd53c567bc9337318860f0aea9c8ef2f0c05c0dfe89ce66d334b2786b7eb0e2a8cf979479218995d1cf26187bd06e1908624a381abeaedfc1e8eaea44a5df4f8f1facae517882dc8832a889d3fadacb1ca11f866f6fd21a767bf9a9c1a95a46c5ed2f878e6bba97950463c328cecbfa4084297b969173766b879f25fe3c37159d67ef3d4a32e9450197d8bf77527017db75ada5c1f7e98facd436fedecf8fbeb84da989967ac26a2182c3396ba232cab547ea9dc49150691760410d6e778f4ddea40057c3e302e1a063d75a58e4545d5e4b7415e94ff7ed04ceb536304da76d32ebe47fbba287daa215aa67ac9739bcd2df04aa1633c3cc9e4383505d040f51268be9aa68382f806271ffd9db5ea24c0cfc6aa1690cc8261d9b59328a6b560468072015f9d04e51cdcb5a64120454f7f69d613da44e1f6a2a09b6e16a6372e97d1da1f93d0a50b536cd3c0cb737fbdd4b7f9a56d02255c4bcd37cb742ccee976b0fa8b1750de1b2f127d59c8112479205fa02ced38f4e7e22b2923775639d434661e8f6c385c576966f62098e23095fdba7cc3c513ebc8ad5f12af98552326f44624fea2ce67c5b3f61ca7144706686d1d28b2e1e7810ac90d9c07ac9853ab151caa02cacb9ad8e828cbfe254e0dea0a08703e016822b07eb05b9a6ab5e0483c8e0d710e11f275e538d09865349323b0696401b9a0dffc79ceb37b7c14d04cc690ff949997102ee1cfc88763fc608a0a6c893fa13a5109127a6fb3b6ae7fa7c0523f755fc97f0baba1708dffa52684e00db5c49775ec8777d27ab38c917ec2f4737eb455ba34e9a9a0aa15228be3eab77a37c1a8fe39712c6ba17eb72906715a7d1867ca29c1ad60dfb33765265e861691bbdfd370f30ae0db3cc18d8d4a3401ef5997876ab10facc7cf266b7f71a03f8d24a95f3f0c8a31f66435fab120c2d08dae461f885e728f683d3da0f23c4df9f0878cf016ff4f3f0cf5d1da493f979a8b8036223673a54b8bc16ea71e2a986ab27965fc04f34bbc2caad9e2f4526135f39bd876a925612c170804e6a5850d4b1991f469539082f0fcd3e9c3be585f0a7f4dd52837ae09878a3c1a68463b8c82784df7f37e89aef0b3456802b2727dab02d99b263d4c32e58532df6f6241757a604a941f712959c4cc0ad300017eb2245d28c7844c2ca9d98d00bc59835a13a60d9e76d1be1d5d08958915a7b859e610eebefce50dd5e9a6506ca9e84d353aba5ec3af989f4a975ad6f492f1ce188c397057520be4e4307bb293cbc87abba2b75ad8f9d3f703640c2469dadc3d2f1d8e057fc25476b2482a1a58a9af561e572ade15b5847f7aed316a72c316fc2a74650b3e047a71ceed8ea151b11ef76e49f77ceaa3298cdf0f75f09d38984bd353910fe1ea63a18b269bb6c179fd2349cacbd7555a35deb65f2bab732d0edca053dcdc740b64c0be8aed578b210baea287426238e3066f182c4b2fcb90214faebadcc66e05a60718b207030691985f229a8f5b592d92b92e34a47c5423feb1647e552f95fb51f8a754eb4d7d97654bf808f81d9bfecaf1c4f73bb1be4d4a67e2250c1096ad924fcf4331e74d70d381f7f44d8686380758c5ec959b53bf17b079507876e641de172356e4495683ae8c8a4da7bb00f9281a21c4b07691230ea3fbe03cdb0f4512b2d9b42d39c13f7a8a5d23c83d3f26d692e30d5afddf207179369a0c1619dace2b7db50545a444f376e58e5d31a42b30a42dfab44ffc6ff0fb338b4cf1ae2c8c7098b8b7d6bf4028eb0924bb32bb9704d356848b88a91efe69f80eb4532b31964732d0e38c456c96d35d37c83ff9a73915e9b6bc27059538f5bc61560cec3719add31bc1d35ff0b59a9b3cf68712276cd21133884603906e81f0fc5530368b3a90eb3fc584c35a5df439fbe9b52ce713576a0f89c1d6b2d7566cd24b52b2da35f135802723a760ff8100eaf10a3843e84ee54e6c31414429593f98a98a23d5f7db0207d06c55d019e57f6bbf7ad4a6e0fe2f27296155add4fed389f8d3014bb4180353ba1c67531eac0758308d3b9e578c1585dcd06d0f6568dd90cbdc7dd98a9bce0e55b4706849be89f62f78b102e47e17771ecf16a8a536227243c193a09dd7d72408a68377cb54501d55dee85ecbb64876d6e86267d09ae6ebe4a9aaf11106d64f412f7450c753c4cbd02ced2748fa19acfea715b6db9b357d912b10e476cc3e2220b0d49d827129acaba0b2e3f4b1eb148a2c85479a4ce926690d8d5274da1c2fe14a462db6b8c5c96f5c3fd6739d1faf22524d57ec21dcd63195461e450bf5155a927712db58180afbeb59da0d66880cb22f4c554e5d923c15845b5ffb77978e556c7006cd816ab466e32eb0ba7466a6755ad4f477c4fec8094b7ec7ddc30123a2aac24082aa9f3e5d3c025ed1d29281084e6d7a17c52fcd660dbb7eac0766b3a649036efbb55b7b7e6233c527acdb6f2728551166fb7df253e811dfffbd3f4439b28d6ed9318145966abc217297cae4fb9ead64f6866523e4307344ce790d8595c54862f568c0ed12b39c6a2710339407865f673025f419fe83a66cf7b3a6cdee31132f327289ac416c048eba457f4dd302cac97215a94090197bbb01fdd1e6ece95dc60d7ba9372c01aa404e00fb25ef310c38ec5fb9010885e2477f46bf3208a17c95f100c4cd95dab4bf27de61fa6b8f6529e92d0433acf79506d54509464fae563a95e6a5396ac6bda976645fb8aa04e5f4c707e46214a8bd971ee06b24cdfa83d9e3cca260957ae17258b9b23fcf0fa87135b517d9bcdc66ebea1415749999a29485c9a3a70461145af6277b6fb67aab9e4b48f9de636291be1301fe0b599f32c88cea2f6442b853a58cf760af66cfcad079f750a87f7d6b2e6831230e3a187f87b19a9dcc49d0b6ede11b16a8fc50258c6e28fffca9f6fe8b2ee47d9ff154b7b844f2f271dd1a3d47fe945e09e52a13645cb77fba82e7b89b366eac3e3c4a781bb8a0bcf3f0c64a3a626e9b511852a1470733f69862b9921dbf94612dd7a1e9cfb9f761fd038242690a2ab0c52cdc27813c65d08711644a46e70033026c0517a87fd584d712f2d3df86dcb7cddae0193f597fe274d02330bca84e79d49fdff663bd3cab4f136699a144bb21fb1a017422219190f2e0418a47753ae13d021ebcd189de2dd6c1904853132b86f8ce7f12f54d6fc808ec1090d556eda7c7964ca2f5ef55152637b207e13dbd4ead91f287cd209abe7194ffda99ede86e44a652af37c33226b1d398458af1bb016656b692a548d0ff38db18625d28ccd8ca4b50c26b87e4ef7a383cc4e16c17bebdafb01fea4303ee4e55b4aba827c444380b814873072c83d59404a27612887e773663ce467cf666dccd9d5a335c0734d45daa9ac9a37708708c233287c2f0b8b4ebb4a002d13ede548d4c72cc43ede4c6b47c608a94995e1c070147e892048d0cf2a1b3a6606add50b94feeafe1d1b16f09d320bece03b460d12a4133d34553450202b5a6ee5edbf24f89103d75a8b56abb282d273da23c39f4fa8128e649bc15c6571a5e61cbe3dfdf696a0bab7568b06c2506e1e52cfd70a06efde9c956f9939deeee946cf421ce73210f6cc958a52fc7bf90c8f5ab92b6aef42e1d5f3a35aacde5e7e6f634f00085a90813b91c905d05c28c399bdbdbbf47aa65c10fa7d9df1d27566375328408bb5a6640921405baf6464cdfbd4803b44d55ebebe41b11143d9dada21ee0455c98ac77ebf2709fa2babf920992a9bd85aef9b169f906278384acaa7556c1c358b7e4519dbbf4d770aa9650a35ad497579b2ab4b0a830b3199a9262936bae0b74c9091206d4049868951e5fdacad64fd0f52ef18198ad6a8e6f14c853995ac7305cde450d1ae565f9f353caae0e96394c27178ebdaffd270e42279bc4c2ee41cd637a9d02017b8b2cfd73ab96a3e18c095a3a9546b865374dd685abe782c85ef04ce350661089d2c4510fc99c7a84572fe3d879e7e0455e0820efa2492a206e1132fdfb01f15c5238b68e099fc4cc79655b960d6dd98f1060301ce975cba25f0717e169c88fd99019127e9d4a5a07bc3326ab4b8278291ace4b3af710f78676288c5d69682f0d9ed098cd785c275bd9ac7885795d13e1e45222089ca5c4ad95de5eb77e53106400f7836235a1e180d482ca9cd5f2f34f341d3f306c78b5847429a33df1e37472a20acc77ef61702728d6a2a322e46b58a01f9b1ef918f0004a42ac72bca9fa3538f91c603d01f30d60457fd66931171eec2a57f39306cab2f046a3b2a51a846e757b585b1b561f442f27b966c5713dc63268906da3ab5deafaed2a0c1d7132cf7afac5b9f8077b6ab3d3ad7561961d261683cd3eb32f028dbbfd94534417e2f9d1eb697254c9bc818fdff4889c679700e784d99d1a3468dcfbcade7430b490ee7a90800e057a5f9e13dd684d5e9ae481007239109bbe5b2f7409e6168a76d82e61eb9253532bb73a219b864aee9e610ff78673441df32c98abf6d39b9c6125e806ab3930fcd75f1fc45881da16beb89150634ad4b4c1fe1c4e2ea4612751efa3eb7cc6bd1e3a6503ca5b4085fa23a44312d5f13672be0df7f4fdff17b45bd7d30e7fb1e89c4f84d04d8de38451f59186d47be5e5a93d5ffe7887575a77dece33be21e54a73f8f008af1820ae5a5cb053e81af061f10a71c2c904748a931a5bff5dc16411a384ec2b01ad4b14981a1207d67856325023ff88aa8fdc4a5b0bd54ffa1dc4a7376cf9e67e136a9becdb40c657496e431d48c35982967b72222ff6684bb3e090832577adf055f27c8aad5cca51c2aeddff4529e644f15e6126c693369a5d17ea3cc60e83079e243152451f65a0a3277f2934cbf1e3374c2c2a274ab6f5dc78a53169adc231d50b1c44336296dbe2a2c256dd4c0ad6ffeb1dfc57e811b1f1df03610b958698ef6362c804ce13531e2cd9b8579e5bbe25a8ee2a3adc2c4f30c248c18435556a3676aa277e6e147fc9150c35912e6dbac17ad9ce6fb5949142a6b0ecec1078f53f52a75bab634a0dba178c4ff3ab989acc55368209f78887e498346f88267b310b1b97c6795a2d2b4bd3d29ff47292b455e223053e9abf6a184dc877730cb79a7b8e80b79c10366dc567dee5fd4bb2cc9238654d4f3ce6e682ff89320915e86ffa395c98456055701f31b01cf692ab35d2ee543fa8dcb75afb81abd46844b2d140780d25da2dbc4a29917e6c6ff0ebff85ba0a2df04b0f515d1e3cc559dfd8c1ee1fdf2709f6e84e940ac5f0113319add9e13b0e7b7ae02e2ce2723356b3615d59e36f9ffbba0d8e4c19706568b30f10cc953c1af4c075b09c87119ddc413b21951f18d164b0b21761ce402d042a0018bd8503959792085a46b2892b5119d5fa4fa8e9b046d927664c7112a70e48329a8e0d860f03bcb9982d8b000ece5d80f7e477ffd3b3417d4f800759b04e6a547743bb512a8944ff420e79bd70732dcf53da9d2635f60dd1db2bad7232b11da587b88bc367b08b1468f1e86cdf4087d9e841cea5b53e7972157aba0f93a247ababaec9abdd891137daae5ae5cf3257c6f7216a687a2ec4dd3139f485a5cdaded60bd27a9cb5242a18abaeff5004edb4c3f759bfaa6d3a651652d653f9743895deaf2c4942042061c786706098c6d33ebfecf0a9e48ac417f16ae37a2dc5bbd6f7517cb035ec1bb12ca14a4c7cbd1536cf0ab9af96e9026e9e2dfb0a219d47124d70653e5b81ff57a75ad0006c2726396b21f6c2c3af07b60be44149ea5a1e8235c0be3444e8a511b437a8e371a6bd4901142dd6f14a6b31370ac8556e51b0c233d9d1c5d0f6934c362f748be8ae22c56c79590a47d5c36ea63298a186be16fc8fba2de7807dcb613a649f90cd1b00d7fec1879cd384e49204fdc2548d96dd0a125dcbac02d4433d65e2fbbb9ecf31925deb0a166e9f30bcb45e94cdb98b5bd1a826be9b8976cb73c3e7a0379dc8505255beebb647f4687029839b482220a2d20cc8ac84133f0e1122bf1ffa1185b40f08b5d29d67c4c3fc7be4abb4e404a750693be4fefd7fc46bcc252ce38ad0577d7e22a0a26dfc438c7a24810567b59f05c047bf2ab799c29ede2e3888638020f912c39f1ebfebf5fb4262eaf3dc49ec837f21d17c9e5e64c905c5026c1dfc41dd27f69966eb5611b8e69d4c4c1d68cc65315d0573771dca89ae189641e493f4d39064268dcbda8635dab499be9af93b911c9df621df5ffdad9e36ed5fd60eb5aa1f9ccde7e26c69e757d05e407a7c71eee3a6f0201c454e57c2b53e48aceda2285ab01e701b8d07feb889647a4106c7dd3b7f9f301075fc785e53453cbe72642acafff1ef5d369fb3f06481fb5d34c224e4a4f7852e3189dc44b45651f8753b5e2c79760fc3c75216ce97f4f551a30ac617002f69d8e38886685e4cc660ab570bdb45aa90831151b1572af493e993e0800294dd645e229461219b4e661552a4a6bbc17de3107c9616e137badbf1c716d747b37fb7e3365e414aaa4e2f5b21f0fd65c9d75c6e1d4fce672885450ebfe54ad27dec73e4143f2909b601f3fa0c41c877cbc31c18225280f6db0016e516bfa57c92bda491fa57c0065805536b3f9ec3968bfec482c68c6c5a2a71f2b067bea00874a3aee53aec1ff8febf242f800ede1602016df26a2a803eab4d56306d2551e1cef61bbdf529fd0615b6a425faa07b804cad0f01e2132e71f8b2fa92bef477396c1777dcb95ed5112f33454cfa3d0cb0c3615933009dd049f50f2a5f4828c3f080f15d715fe1e267c93e48fdcacfa2fe0f7b603945a221ad81e1382393a4e8a3f7b64eec74296863887b86c0edff8e1004f6a17286df98d04e34482ca4adafa941a4588224965531110a94851fa57b398064c04f6e9c0def01f94898616546df22be84ccccca2f14243f6b9ac9a513883c8c8d93ceea7a0c44a8afd9aeb36976fd33b80f73c0489cb2b20928da4069fc21d9cc7ca2b1907ce1f2593923ba68a6a2ee42cf5fe8dada29a545f2aa3ad2cea88e7748a6d51c0b297e6dafbd838ff25aebaa5de132ce6cac97005f047c75e9101f5a6bf34f4330705cd10777454b6d46b7241cae269a866a0a301183f483acce178df62bb10d85bcf00824aa954ded2e762566dab630b1acbcd4db6ec0f86e123109a0e721c665ba153e76bb0d43065e4b9c6dc72de949b3f56b17ea28ec11d8ffa5bb8991decd0cf29439d05da481e2e444fd0f31b4892570038194c458e38d85e35b4b189af46678792b9fd97d6ce29731d517b1a5119d344a7c8d3ec76ccc37824f2433368e5d737e6e8933262ee62dbe261b7f4a3842644f20d583ae7bcca2cdf4d1bd08b6aff7a658238c76019adc4e7cc7d343c717f519bc89f0eafdbb93f8daef3ae91c789e500dc9d89b0cdf13035b6271e4b0a376f91af52ebc35af29dbbfc24dd858565cb9345fa29fbd66d2ca4a70a14825d1ea6948dd0f022a62d767db0de0e356207bc902e2f20645301c726c0817f4654db1e5c9c27bf936d7af6de409a3a9136bf6cbbc5d8bbedcf654f13d14b251e50ca7e0bb98d835cbcaa27ae9608bb0958edc6580e06fafa6cf3f1494e60d0bbea672684a65dfbbc18c020182730df5bcd915cf4d72bedcf16d4606d543acb6a1268c35ac622ab34e4c2cbc33b164ed00b21ecb9c5428b0311a4051ed30fd55851425fdc583169bb9abd19ed8d82b85accfee6eac7f28981e8de6243db324f4b17cebef1bc9b24b9a9469ba2f7ca4aa8efa4fcf5f8707f7e39666bef3259d2ae8c649dca93d0fe3ca4a763139cfa0e550a205d6f3ad7ee01d391111cab9f11715b1df20f759515a66891f63a2d2392ef361aafd1462537556186fe9f5a97fd75f8be4c27a6291d6c3d9829084dbe9ec72a30fccf82006f73bf3c12e489d6c22e50adc4f5e120eb0f556284a4a4d0199f03e1e6096804828d2bd192b70e5b1f3dd3d0e1c9e44ece8bd787717a80950daef535453e13d9486f8ea8d9b3d0c4c313f53b620a91578d38c7461abdb2d898a6591992ac41a477c6f3a3e576d1eba53a29a7410d8c501f9bdc985412be12c5739fd40befe4b6ade124b87cbcaf0da9ab420288a00c500a262e86c16a37a72e446d8f89fb9faae0668b712b12d31d6db355998da1f529507751c9872a3f67d59d3dd20dcbead10918240903fddd25eaa6bd01d7e70a95090f79d2a9b15ac747240b3296bc0d6330731427ae9af6800f2495f2e86c623020b5833bab2fdc6b388330687a3280e0754124e947866629fa289ffd3bbdef49f59fa591ee9b0cba484af3c0dd3075ae3174677246b90403af9d2ef837d5813607c071628e96749fb4fecb31bb27cd63c21079e3820dde19b8b0696adcbdde82b99e3dc65b6fcec4bec6848810cac8ae10ae1e1c01495cb1c26c995ccf0c304f8b7665d64f2a4b583295a292dc6d26f61c40d6a79c6abe9a5d2c7491a542793fa1db4b605cbc6d1b1eb36607163341c4bf258e8755bc443953c9b1c995fbb4b5b82f1e08c593161ff2293e124d2cfc4cae8ca76b5ad54fed6f7f90e0e72ef68c19ecf320ea4c544d288468c0efe70b20533f275d293d1f964fcb445b7902d672a5b2b2ae34c9343e5e35f1229682ca51ac9591a4cd23416bdf508c4d34176cd13b1816a77cb995d223afa5a3896c0a9d5ac3ca8fcada1112f7c378882db452dc5f9337ea0db3635da06ea5cb2b9e0cf200510c65ca14b84643612c491b1bb195f78e579c02bf036ae178a52f7e0386dcfe90655083ad7f9798251c3461aa4bf368bfada26c3d271f258433c9c0af4bae3b63f7c6822f48699a60ad84313e5931e9461cf1d1f912c01030c61ad0f3d5c31843c1f34387ea29345e7923c16fca758bf3de3d9cca8c15fda0ae7efd552ce21f69566ec6eaa94a85baa7ba592edaeac0ae916556f37929e1700053f0a615a1cc08e3a013752d7b0cfdc0d4dcda54d008308b2d713b456776c52e0a90d5210553f15eea94b2b31b9a9d2cf9b43a1f9fb85ef3aac9efed7421b9ec68987a582440141decb90e73d5464af85657ee8aa82f5220119d603d1e1add3116acdf586667fbf4f3f539d8b5f997b4f2dee25e2f324bfb3f03bbbfb40ce5e93fe60f878aa7dc92b46684da367543191849ca8f965838abf3408cde2e7ae1b4502426cbbced74b302cc0bdf359c1b0829ad3f26370d7479c3ec4bc9ac9c7ae96f7f49dbf278c27f4e596576021f87e337168697d06bc81c6053a4ea198cba9f13c0499b9547e2764636c863ce5b994e184f22a79d6b465ddbe22c539e962b4dfaeab3aee9a38fcd26fb78cb498a3782722cac0097a921aa71ebd4fc5a29af874898530456785aec9ff6f0bddbf424d9ef417c2b2cfc133f1a8be90987741c7f25f5b9f9b5ce60fe00ee441e30de2df718f66b6f668ccabeaabcc63e7a6fd3ffb67963984722a3f4b790c3f8318d2e9489bb65923559ca4657124a6614be27fb486ae888049bd0b2c3b99e56ecc791d03fbcab2c002ad6842f26fe4a6d2dee4c0a866ef37d8b4f0b37b4a42c14af175038a58ed58019a5c455b17e14ac25943b1525c03fc710eb1edd78bc18bc726b0bb85009ad6f41778691ee711d59da056c7436ed1bf2930fd8adc106cfacf3441e69f94da8552b3c43e644768aba33263a3bcb362d1a497a6ccea2d472907ad6c24a694f368b83b502a4eec83a3c36b35df83ad142cfda70b6e8f54cf80340165cbc0b14e304ac5baea072e6045a5161f5761d72c57094a5cfd2677dd1eb3f4611e4cc3fd7a6837667ec9a3f52e45c0729acf47a5e3793ea2b5e08c4e306ad277e10fc900dc332d5e95a4e1457f8e5efaf434ca41dc6502fd7d0f0b1b83d27d6e93111f81fdfff1e0e80edd3c65b85e751843d2b7177ed38bc7355e11abe2330e7f805861e7b401e3efafe768b2508b727c9be92e6fd568682b498f9dc6146b580a8c5a6710c37e44c7abf79b88396af905d2e2bafa9db90e90d126e0da48c02f1c69eb0222c9b7ca5a92fa07a67d1c210e17b2c685ba0cd517cdd01722a6ac31206ccf943942e0497cb5ddbd20c3b750358dfcc1dd09537ff1319450994be27c878fd5b3d99e16d2b5913f77af32d23657ebbd4b3d968c2d9afc06be8c4ebff327ef949ceedb6e176e7c4e55bdbac358ce62f795e5932047d0e72db1b34059d0e6459542cab454325e82960c4ddf191c56695aafbdec9ef741b89afe6cad47aec768b2296053797eb24500ffaa343efb57edcc0e47451d74f55f0a765d8426830d8e8da51fef43306b8407ac0f077486a1c6e6b124b9b9424af1f5ae228018cd14455ad26a995774f95ea95e8ca23dce52021a9215d3420277c64f954cd0163a8530399ee74e911aaf3bbeb299f19eb2fec45d0598a9dbd79caefbcd8a4fd39e581b067ca6fc48992b6629fe7bdd57ed6191a7c813716db91dc2038aa01d6e1e00c0fef45c58c837e6fb5b7bce05077852434d6fff37e79dd8c1b0968a24f6a3be62ae9e77895ee11c3a463c64fa5f04775502ccd8b40ced3f549dc59238cc6c6b29e709bbdfc3bf8e0f44b8d344a02c5b15a065fac6259c98cea75c821fcdf79e5044a37984ce8efd4fac630f993b191ce53a9205e9ca402ad4355378e1c7e453e145ffba2c02ae472ed5e633d614b670dce0b5a3b8f1fe13553fc98cbe3b81b1a9bee9cc537e85c13d45c4e5ed6857209b84534a6befd211d5cabd2315fa5f7361b68a9af6141e357521d2dac9e456239f516a972f83903fbb0130f0b0a21dcbfc70a34818b4bcb35c7a22fd65ac6cf5625e7db9a2fa199fa78060fd3c899b999e07aa942c60585053e53f103e0a7e52a0003fdf53ef8fd21c3e728947652b12a4cd960189c56e70b1b4f416d400b372100b29a83f296d0c282b77fff2fd8ae55b717e91c6bcb05051cbda94849a90f4c8be3a9bbbc6f4cd87e4359774d9e9d5f4e5b10ef6cad2bdff24cc4f3d3206050fc5a7ce631ae26105005bc637ab81438ed0a7b19d285e68ef0bbf768805dcc863f31a6a6be6989ea6af08588ee80223fbc03a78f7f6102df4a1ba38395d91214470fbfd9c68d32f70dc17c2f8d3afa087eb12e7daa18c65ae541312469e9617c7d45bb70707310539a7539f78e65691d07de5a819c3f8f6abe6cb1308e21f03fea280d99b0db2107941675d216efb828775ecc7108ff2c0597ef13890ef89a89a67dddc1ceabf07c09ca0a783e7b717f5bd4f1a1013a8e0c374e8b923e0ee231e115dfcb591b3176fa91885131d01816199c612348aa2a1c9b5783a0e968bf9c83cdd105d59cdaef3b6705de0855645d0f60d2b731203dfa4b7c3a320e5ce783da8faea54db10905ffcbbc2dc5be31e5aae876b5dcdbe83eb2cec47fbbcd2847f620581ef60301faf9c7bdd7bd74bbcf22fbaf150acf5428e522f9d2364f2e63d5c8a69b1c8a17498082a37ddc9657b33dd4a34378deafe13df59552f3c2017e1cf3bb801728d1afa21596579610996f2643eb1ec7d9aa8d68bfa39b533a48bcd2409e85a1eb8cda11eb643aa00a4083ba49be2ebfbb83f6a8468a830ab333398bf537ec8f701d35a63fa06b43d5ab827d5374f973308d352490cfa3de5aafb89b138ef09cc4849977541295269f7cf078ee1685a016750e7ac998d77eec56da39ced2a51380e0ee43f5b41def429455b4066ee3a56b6bc21b922cff2ece52ae8d003cc4c14c8f6d1fa7d007d14df8ddd79f841b38a1f6c2689ec1066dc2a026c822fe9941e7b15022ce6011fdf64111e291c8961c0f0836316faea5b67d8a0c51bf64238ad49ff25b17970822ab8b631f05499cd53d3046b3db83d38f21140f76465bc9329453889f0c82149d4132ef70dcf37a4f4b661f8e4d1327314973bd45f5628fb79d671c52ff723c9f2b60c29fa667b5f4a581d5e8c2e5e2391bf2acb0be7e2670ff2e6b41c6d6d66c19d2230db10d36635f3ac60905e6b483d121c12632df3c8a349eca90cb603ef19e7a45cb138ba8d95007a2f62485a81ef0b77dad2a24e3527439929c0161993b42087ce2e4671e342967e19c22e9410f565334fe959227ad04fcb7e7e06d6b99b918659ce4c344704027529ccafc2dfc2f3811f65640bd8c4a5ea9a7915a645c5290d4fdacfd5f69e6540da39ca9cc1897e02b1bba0e18f123a9e6510a3cf324d212293bd0fa6786646e8852c2be08f0182759c7a772cdb7374c9ea0589bb98756c397308b4a805c30add79e7a9f5463a8bec9e02e9e08e87b67af43588285989d420e7a9a5dd3df7f32d3b690a7066f1b617ee015f99719d208096502ecf1b82ee4f14a6a53063cc29d231e1853568312bf7ee5d223c06a7ff69fd8a5e7a0449b4e4536baff204325020e44ddd9e7c0e7f48f461e4e786cc9cdb58335d4236dcedfd0e4cc56f34ee4259532972e947e5f5346812829db36bda38979b1a32e06a3471c203522dbb5c16a553186d1e4f0c0869935c2c66c2f93a0fac875a704444013e4b0f962b5b3bf2780e8ca71132f6206e0e04f1f9ed393c2bca96b71c6468b2b93569ea8debdc29f0a897ce6e9677270e4c4b7e190b3fee75bc4a9aba674c5f04f0d62c1953011cba0140a13ff27484c94ed334e47c36abc8844b3c7ec03920b9d567177edd194c5c1199bc1c38e0fe98ed5ef27e3d105b2cebb61495e734a808b42775ef092803cab57e5e2e8f77f7cd1621e992541a612dae385a15e4be4a2f5a6c4091240e7b01944d776ce44a945d3ad1e259b0995257024f23f4b5a40ed6bf1f245ecc3dbe7303118d8731484c4ca4dafd4012594364d5fc6ff81b9ed9488cc0e091bfc52cf93ab42d79be1b20496c29aa210add6fc18fb598fa68ba08ed18ac9abcd5d175b5f78fc904fb9e8935d83845e47bb3bc95d2cc4cfc152c582a9d5e1d232d8b6a558e7743236a28dfc6c61ff081fd199d14ac16a36b439fce939a9711b258f6492ae883b3147f76245adad1edadd1165da66b4d73ded59252620288f47198badd5b336813846d500d602f2d7c61c91a9ef2e3309497003aa266137a78ec378279f1b1f0ebb71f687590a753882fcb40c73e4fbfee04a740980c43ed384f0a0b54facbd99acbcf42a5809e24c09e8cfbf51e03f2f35f0de740ad6450b3517cc861dec30eb169295958c69649974735374685766aac5327fef20f7f8626555e095933cf849e33ce42c35a1ffcb6aa81c87f80585b2f137666ee63645ff87368ea86834f9a53aa80c2e97621fd56aa4ca6ef00faf69213ac29a2b4d072378ad2d724e71fb448bb8ec88eed4eba2c2a179df15b08778ef884483c82e30c065dc458d53354c7584a118cf9def151469dcc297c61e7b791229ec977a5da530f3ee8dd32cc4afb7eb8a8da490e6a5df6d2ce6b5eb6bd904342b32d8bbfc6f8f34f32bb44280b2493852f3fe9232e59a99c6781676557ad8401aa34aeeb6b2e579ae0635c25dd36ae2b63b5ee3fe3c477f233b9bff0abf0029d72300e84390c4989c597167e03486fa6f6e8de177db61b43c72e09727e089e7c37da78404edc514ddccb392dfe56ed5f26fd96bf585439b0a0f72","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
