<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a01d9f1a8e2b034a34d36eeae34d10a723ae865e758273f1345c4a1a05e5583b4e4435ed500250560823eb2662d171421d2d6d34fc9d857fec630a269c3499285cdf316058b5c8ec76e91bbb00e769402e4bca6b45167b3d735ab643dae3a9b9a66461438bc47ae34a4ebb82ce734d1485948dbd9e11aec32f987c0f3480233896a1d14d85be6e2b365cdbe7774b83d003f668604d824cfba4b458212a027dfe6d220f7c200121d85e7d307d0b16f79ff39042f9996694d732e1353b13ff15d8de987b3040bd0190a54976879ec30f46b911a7ffa4902f8697b658a99ec0f1d0c5fd3ce4969147f4de3933a497075960e18b3d3bdef0643d96f36875c992aecf8ab281cc12b6e89e3c782edc58c882af1e5edc2eb457056fad615fa6e601c156ecf77b0d8e7068144017c360101ffc900105c905cbb91a70327cd2724b08d70817cc1e23952c4d9cf46d84535a3b34fc4b18333ed3831034f6ebd9f115d36a97a0ffc5518e8652856dd7aa69c00e347fe4913837b4858a69a295526a012aaa1771a5dabe211c9ba3b004c8e00bf79334f2ed094ed37dcfb90eeadf471115cce14858cb2d5ad9aa424a74cfd0bc0a39713a7aa7ae5c0aed70f76093b837dbe0454e0c7170419d13856b4df3d1c2be82122311a09f04ce1f770bb56e844ad4a42547705fff7bf997eb6d2920754077de936b454e176215b1a1cf0571a954b825ed5f9de8276611ab54b044f9f7daa0d23c660f1825726b891f4f9deb749a14f200dcf4558b8143fc559347fd75c78a0c552bcb87d68f06b56853cb73b29c484dafef950a69707a22496e0f4a0ca2320df553d19afecbef1dbb023f7c295b0ec8f7d85a06238bf4442a5cab37c65db6052d9b0aec213a5a734b74c79733b61055562bc51f86e380fe1df02bc1f3e247095adb73ccebf203ab97001a5907aa229b66442d427b2cc3682a9267dd466fe98b77b2ad238579c06c122a5e247bebc4eedddd7a850af257d98f764bc925569bca164d6aab937ed1062ea9980677b211079148caf823091a36cd179f5e76e4d1502b80e32c14a4950413e31af591037d8cfa9e235e7ac15ca7606c434ec456f8705e507c94436fbee1b67f26dee8d0a37b83dc3cb26d5fbd39c573968b81e71a0a9e1921c2caff37dceb6fa0f57d99761109b52d5354c1135cb63b78673d67f9c296bc8f03f5536cfcf5a08890f6f74a4f52d8f2157522e3ab94e9961c3f677951b019737efa0951ed07a125909c5b9c1576d17c34b5bdb1453da6b503b557cbc78ed0403762d0b63410632a0458db1611b1c5017c5d7f7740fb5792962f40a90dd79927d6f7a777232608236c43fa00bad9a4de3dabf46302d2c7c6bce98bdb403a11b20acf8f8cf0856ca3f7ea7cc05abe261fbdb207e414e5aaa6a7c81a6a89507fae3c67540b8e0df2435885ae72b807ac4bd08bf27490dfbd3f2d3b2e45225737340a5f75ea6862d03abbeb785d189ebe0d61c526feec5712f806abaab830814385a4919f172c0c5a6c2932181fec82bbaac9bed1bda8f2db3688802fbed81a465995b71229e85eaee3ff8636c5d8c87c0f8a52f702a2e830b77755a31ba80c2611dc50b72b473118dba33518dbb5fcbf29bb6ff87fb261fa7910a95e00056468ee30eedd412746e33b7ce2398e52f5bb4bbb27768a053f0fa0224e9cd7907c83d91c5740b2027f8c749e65fe0fa1e40889e052e76cd5859380ff3916bd00642084fe06c86dfd19228b8c6475fc4910d1a157f96a170eaeffadd58d1de90ae1dc60ec209f2e02275582e73f6b5fd2f558aec96b93b0ad460a533588dd3d536d44de4c9f1100f46a2c29e7ede74072761d55baa61ab2712f4d7beae3d273f82cfccd7c691659bd983fe9c98492f545ab7ba349895c72b0e7a5d1390ccadcef2cdc42b3d55cb8281142948b87bf22124ca5321a0ece2145fe79f4578f3738e8a37d1c95d818079a9c781f65f09f8445bdd547ee8c7ef20e487e266de88ee6a72ea0e4f8b4f6a5c661402725da34b87f2d6c32caa117d76a186082828fab7d42fa6b8a31cda1a6643723580f2660be80ef7acfe65ba6ac1b73304c2ea748c5ddeb2963a313f9510632883d9441116e24a908b7c38a791c3f035d0d16b3a8c8d784a6e7b7c4f6cf4a6e1ebfb57eda49070d64b8a56bf4ca30917599ab6aa33a9a791bcd51d1f20a124fce527d11a907cf3f6108974883aa2dd5fd724a17ab4a778a4323acf99e96cc7a630983b0d4db5a216cc6d254d43b0d1619b513b6ecb85e17758d815b03ea05b7f257d87246642afba3d084d6139dc9bd5a2d041c8d0e02178a156bd15178a1c709cc29b375e00cd61b99e09fe6b2e97c5421f7124fb330c7cfeb09472987b34a1c34a1807a47b6915a6b7beaf7abcf8fd48e36898160a5b34c5b907fa3a29bad666907b6b1462ec48da70850c023538fc408fedb54102fb2ac014525d179928d6c09fcc4e99db1d8536ba4fd8e47ad17ee8c6bf7601247e406be1c2ac8bb9d67c862e754711fbf4cc8a5affc26a878220d480ab3e2ca25eb73fd01572e616d67ce1c49f504a72cff8575585d5f936c4e155d4d2d335c3a8c6a5fe6dfa5fe32d4ae2c4c15f3ef6dee4fd00d1d69560085ffedb37158069219dfbf6ac2d43e82e892d1a178e2d6062dc7250850e8043bb36598229d71892c148f9548ae0d334d739b95ed5bf4578230899176b74aeee31406669e4ac3521d05696f6a3012f24cd86b7895e95c3f6b20e58e15e349dd61d120f2946d42543d7e9e93f08aecbedf74e8a12bd990254771a99d1650dcb23955f4c427a41dc564fe290e1450066733211c0260e0fda22303000d665009918478c8ebf158203244a2b9e122f83d58a2632b3f818a207d80e91be3d08cea4d0fd9714b34387c22e1ca2abb9be68ea1e6802106ba9f475f82e35e9ec5001abe8923bcad445ea52eebec7c1ca1504b5d83064cf3123d14bfc6e5426d05312900fd5f897468818c53c555ff85135baba6e50475480af24b77b0f0a6869e4493e1411fe2de1301aadbb1a8729393710494d02cc17a5cb74a7c0f9d233ff99da1cc2f05eceb76eb853485531e4da94973e1ebfd1c5508c4c3911895e48f8e2f812cf188fe0a48660311c85614d5003bbbf32a836bdb78fbc70ba3a8e8e5399a57602e43db848ad3486dc2102bad39168f9addddc299894b6ca1861b02d63e589b4b5b88291c556027b45119cdcf7cff1e0b3494b18384f7c0bf26066514ad418acf127f531deb9c67026b79bcece77424b710dd4b33893e0364b04759aa0d039e891ee2254a74fecdf60f173374d21c872f78c3451122aa588b6bc6752e0d9104f778423514ab1e0051da6dfb09b58de97438367828f9af36a8e90c69c7eb0a563f2da0f6afdd482fee26360eafec2d32d2305046ddf7e8f0088f2ee2110c0d88e587b598d096411c57eac411f7d39fea4ce10873069541717a5261e94e2bb21dd9cab2e8c67b70ffe323b31f2dd1060d89e0661c9dd3b1a70fb396ef1030096c428e7434af704289a9cc291960beef7a97bc5a8dbee952ee5c5c4a54396d7c71f16572ed50caa671f46dfa3ed74fbd0c30966d22cf2056540292b9a6d9fc231e79fab0039ab02c4c2f135f54fd2e14ed8aeb4e73e5f13479b4cb0ed2c340bf6588a1fc03158903fce9f6f14241af065326bda4ff985166ed4be0d755ce84496bdaf9f28174bc1e6302199d5457b89306c53be565339701a963baadc3dbada42516e23b9fd7acc49f12d59e0d3af6bca7fe5ba2cdcc50129e5a9d8efec425c20fd143d0071b2e6fb12ca878275c2e7e884f7de4b00b8f663f7765bebe0fdafd0e8a803640af8b2683d246fffae647ed87fd513d5f367a8d4ebd95db46e7bdbc53ca962f5693b3b010502583ff8fdc17a8a61b717d8bd651ecc53dd2925d5c31996c1523c96704dc969c98950b40c32fc20f93d2cef7ec861134e5a5bda7c63e778a692e39e55271bd8df1f0f3b57419d54b4e4c762adc565b34c9eeb8783fc8fafe953c6d380da14ffb0be6d910e4d4ed7d93a25e819114deb4af36c4961db8dc327c5c612617302c3b7612ea2eb691cc03d4be36e05c6d7fe07f720dc54c53ba8e649f538134a8e453fdb50078d8838f40429997b91f65e40b9967a73566f3f69ff3094ba1f7204254a302528b88de533d0c5dba92717df016095f5d779d5986717d21baea0abe201feaa76dc031759dbd9a0f5c6c7e7f9e673e57da9d6ff28a4d934cf2aa4b92c44da8d4691540fdeda34500ebe065cff7089c59016e0c3f49b269788257f96b8fba7ae501f5b6afcf504c510ab5693148a773205d88b0a21c23c2c5073e62509de9561708de7bd4be3048163bcef5dbe23857134a0abab9ebd5423684eb0551b343d540a02d339c4847225f94f6ddda1ec1d10412f570e4532247642263990b3dc86060e1d8eb06edfc6399963b52b18f6ea382003c68ed9904252a6afbb4556c1fc4928323b6031e4310250a51ce53801255a4fe017b53ecec96b165a42c84d6ada9fcc4554678d5f8a83b5390b4b26b43cc8574e8a3ea83a22501c6aa94da4bf7b69881de16778a92d82d00152a74f603bd205d30ac342e78f49d3a273dc92f36263682780c1b262a0b11d018cb44901b1b325bfe4ea44411b06685cdfcb86db20018fca018d6faddeec0912c3b2ddb921d313fa372c29898f9d6ef108eb2dff42ec72b8d08c87124d50d64be6403753ca9b6a14f6cb99a5572694a59de839a06a4150edf4063c6138de9c4873f55987d7a0841951b577bcc983580e5fc88241cfcab616238103ab69a639711a6fd45a15601407b1a4cd67192db56e47901ded61a30242583fe6f8407e4a549ae13fcb8481dcd23119d8505b8c6b736af33236a84c1505667fcfb98d88a7b2ba486dd9bc7ff6da6ae95bbd4f3d0e2c32a0ad5fb289b120e2fb5f9be1cfaea1c87d97aba9e3edd2fea53e0c696e3b0a2f08f1ae14457e55523785fefb09f5a59452631e46b9eae342ddf28e849b0f1e515170e388b9bab0b91e0e775e71ef22a098b269d58dc1610927442278dc85633f7be17935001aa745e531f2c51609613641872042b563cc02eb1d6458af70bfcf80de8a71976b80746fa2f33624a88942acc4421de02cb3ae8d59fb183a73c833c118d3daa3bd840f58f9f7244436d21703cdaea06ae9d9d4b85cbfeec268dc11d1e280e31df40eb50ae7d2dffc8010da63a9fdf06758ebe92d2cfeaad3916ccfcce961d1488e2cf6fc1be6cbfb102c394e30be2ae2f99906025a1dc801f7d440079ee032fa2aa83d05a7e1abd391327477684ee4556ff171dd79d7d21ed91a3d5f467cd7a2666da4b26c019423ca79f3014cf2a018a76ba4768b5f78eeef8346c253051e3fea602878b0b26a36670f4d30eab98ecc8c31b7ccc978c868794894072fbb7be36a89aa6440ec935cf6d9ebfc03a4ac579a2362c802a91e8a5293fe8a8668e294b845df367fcdf7178b862bca3c5e91631bcffd28491788f93b731df67fc13c1c07b0069041cdb7b24579b2d28c5efdee03ead7545df0ff481b0484910afbb1fdbc3a68e2f16a09494b877c4ebde4a5d481f2d3cdf32f82500495c0b29702229eb31864d592c218d171326631deb5820374be9539163965046f6f5a02282d204ec6c00d4371766dc82c35edbbc60952543ec89e82736a1a36517614940cd3f6a77b72e0fc70bfe2253ebf1c052b5ac60d1d569b6cdbcf09aaa98d9d44c2118e71839ab92fb98f24aeb6ac4f98f3a3b3ccf6ca8f0188561354e9630ed962bb021e504b9f089d0cf97b801459a43991a874e0825a0c58953d6a84b839e4c3fbc943033af959a12c9f35f850e756b51812083ec29f13d6ae647307409dbfadede1ad126ef096b7ad0e4d840af96c4e251799f212b80e50f43f35c5ba1ee1a89f84495967e527cc22b9f18aad1be024dbe8483dc68da4aa4b0b555ce97c01feb1b74fdd591a3f46e4e36148c1c396ef0a33e52ce78ed5a614c3a051ead08b9323f17c37b2309ad02b40b2d2906ca1720c965b7d5ab0643ba932cf97af8d9953a690f8c4b17dcf856619ee8e4942887e5dfd0aabc4bce3e0fb6b55fd9bf9c763d780ea9748978c715de02fcb0f36f985a54fe7f12a0d1dd26c3f89e772792da837668b0214b4f1a586d93290d7c9879f28747d35b3d57568a8ce455ba198d646d14e8728a228b595e23e650913c564b841863c265b734bce0f32eeea8b1efe829ba777b96b3d362a5c1f3904c84112396524fa191fc5f13ce98b03e7d0b0a0ab97d57681eef8fab709dd69acc4e80b15c41c7374bc6d157b6295fcba78eb20137451d9ad62393b6b702cf84cd4551f4a8652e65264db1a8f9a3642aea5b8729aed2b26e794d1f6bdb46d279d531dc1b0caa1f7506cf22473d96d366ae9d2c380c43b59bd8f2f276271293a8860f9740a066d52b342d410b1806f5398c057ac776df03bacf84b08f0414dc16ec88124188ab46d8e0a579408ce65a6932c594a710002dabcce867b7828c07e71acf30895b6b65958cd176d85994b97bddf686879d0325cad891f01090312834606f87f7a8423f94d82a52e76c4ed17911566859fdc868b3b3157d3b5f719b0f66339cb901413db7af9a24f03ab097a4260592452d2a108da3c964198e82faa307c0cc41ec0f808af2c5a17b46662a5dd09ce99b6b13f951985161c99bc89b24e817f61d3e70f747f1748b07aa89c4d63c33f42357a46de9f1bb109e9d7df093142cc2feff67ead1f8aa7d42a95bb748f6dfbae1f1f25df7feb5c47b27db314e6ed795f6b05d95b2ab48a0a939a3f9156d864d5d6b5c3c11b959ac673dc47ff67eab8861a987181e514ca2b2841f839706607998fc3b10ec8d4ce4318fd5fcc07f91fb25bf02227be2e0b481719d3163f792803dc3cd256137197d9ee6354562e4c8b838130d7de690c2f96ceebd344fd693decbf62188848afd60e422f8da0234562260bef8fee08e86674324758b416d546a172fd816db46067e0ec8ba9292275f79b05dddeae25e9adb03cca1c839724894be2a7e4238d1301d92aa9942b62912746145f8c6796f2f4512beffe440c0e772b120755102ec05647240e12eb5d9bf398f812911f4b29d79b8e4da4520a095e74ff95ebc61f617d54929ce768da98e548f8677b2d0be1a48aa1bc3c8cc5c3ee3255d7c9f66565b6c6b1ca3af9e408a2b9c789d31f090d24aa202aa2bb6fe0057b4ed201b7a12aeadf843c5a76c5fbfb5d22f16611d3a4f4c6c54e10a04df8ff1bd2051bc426fe756898232163665bacde1a184839a70cee0e0049badb1661e087e26d2dc39c6c6ba8791a503b522df450e116d770ea776166825d6c199e0c42fa6ed2e6a42cd240e897555d47fa7b17483657eafc9cc10861031cfe1596094d810e6153bde6fcd4ce79e46a2f77cb23e708261116d486bff4c7274cf783869502e6ede5394fb88fe6f7f2338d2e10bfd2c1037bb94483902fadd713989519d3ec662407214f4bb7e91f4f5a61736bcd60414da8de2d45e6fb425c1389d213ea39f767e4e5f843fad1dcba6fcea73276a0574e71a8f7f6628d62f6d99057c0c994a2c4ed82acd93cecd6cffdc8ebf25d1cf61fa0ea399ce1c635ce71e7f4b09b44f1d35d92b62020aecd2385b6014f9aae043e7f63ef347acac1fe576742053537d0bc8e15533358edaab40435cb13401acf9dc4373c521eef37b5be8c6431de2c16d4e02a12bf01c00a21d06766f6b882e09cbaf047b5d25652c7bec6701c83090cc1ec295eeca6934e08dedf5e61249844e9e2794fcdede0b1ea14be35f1d3eaff0b4a5421242aea1be44eb90749dad5e47e6ca6e2cce1642a529f7660753075dd8c29dacb0e08b6131167ed277a7bbdac7159065a8ac084f143683b47a4ff551502b66e84903324788d80c9271014aaea980483ff2dc57a32e42b95ba0c96dccf13dc19207e87339dd70f77adeaebbbd4578bd2bbcfd8963bf45429572199c98bd695452ab3c3e0706e5a4436a3e06a7ab36f21632f0d6fea3bc0fd0d3baf05972c40f58d053c79d78e3d3263ec187cf18765095885dadad91f7298638aead769d15ac0ff4644a26ae9e4908a49c84b3837d60dbe21442166b2aed191ad84dc4dabc672266e0d98210f527f63e12434e0c72965813079d895524de9695c7ac24de67a35cb89bf4bfb6ebff67b90b8f992012297a6e612af9fd8988eee7d38abedd4af819f9d260769c9484c9047715569fb8bb180947366df5589667831ed8c9ea7a88c29318f54a07feecc4276ad8bc8b74f64537aa6380f3a5e94382c93e8d7c9967e5aa4e492053e646476638de3cf14e6fbe42945f845fe3810f47e7fe561dbfa01efc5305dc42b73a23903ae9ae9e4861b18f72865bc350bf5fe594d3d7d66ad355e335afd12a70e3d13eb536f8dd7b3279d042cfdb70f66cf65e11a37ed7f557c8571085eac1bc03b44e55ea73370f7855e4d0428e7873dcb364201c0f1bea8267e10900701cafd091d89f5c9361e98b3682e45d767430bb3a8190bbe8521df64e6e9e6a70923a3b9cf9432e1e2c9bf5a00305a90cac06aebf758eb5d3b6ef873d97c0196604e0712ac1867af5040bd9fc5805cad031da33fe7be49beb8bec115272531cc9cac11bb1f99dea938ab277f4cd3aa39a7e49ecf2391a35c08fff6bd6965bd7f07ff06e1bd4c63e919438e1247235f8c74415596beb1eb76ff9577ba92c9285d1da89302520e9070d58ac7a27402c0a7a60c95657e465c05864ee256a35680c2a996c7f98da1ccf07b7da45567f7ac6e67fc7ae3653a6610c513d5d88826e700bc1f8a506b1a39392e355a17ad5e655307bc7bb1bcb58c7c34a3751a0b2ead97faacdaadc9839d6a8912497201d2fdd5c2b0b47663b65be11891bd5c8ef07467dfe9390dd000ff63e9a12f6315f3b896107d7c654c3135b86c88a84403f98640d4c1a4f7e3847f6d9fb576f947d7251fbbe5b9633c184374ef4a8d3c4bd0eb725f38519757733efef12be3735995115d455fdde69e0a1e3727b9d6e639e5a8780d8f34d7da6dd4ce71cb0d12bc22e76ad8adf43065610b49bb37f7e9a04969d937cebfdb803c032b62d8cef19164b07d1258861a88d36227929b724cb749823d046689cd19b3ac4f85577a0834d333ecbbaf34359ddc8e0be2b3cde698245b82eb02f297d30510d7ae65e811040e08e9b38924b002a449ad24c5868224c656f1a8484d3f2ea230af0483ff3ea1b07dcf412da124159276e2be0079e046f92a99db1a3c1874e7208f3c78c23e0ea6fad29d512ced1f60762529c972b99fd720a3b929dbd589417e58426fa88a55dc949593dbe13db84b3a48a0ab28906cd6565245e0d189952d0cc673cb2e38f3b5235c2de597992fefaf14287be93c24cddeb38d6fe90c9ac16087fbd830d31cb1b430a305bdc701c1e32683eaac6db7c603dafe742cdc56f4f6bb1aae9ab45643f9d2adbc95fbef928e271995f741f204d0ba2aef153c7735bfd7d8f060692bc7cce5842a85d267358105b8798d740b9d569b643a7a63ec994f18e529f76acb7343fd075df1fc52da5daf396bd8ed6fe34353f8b2a99fb4afbb430402ec3bc494fca2941c97cbcd751c8a4d5de05d97d05901be58ab9373d3d2ae913dc1ba29815dc390c111cafb5ea036d0a5ba77b964feb9e876698f0400cc1b5b47f0d3623c7eb730f7c57a9c084a1266b89310e1af368d91ae197f9c9acc1306cb3c6e39648fa240b65a1cb1ab4252b810dcf0433d4c4a6c992934432354dcd8dbf75ea2c4611d6642962d01f616c2ec8566b753d45838c818b1a95fd0f56ef69b9ff26400238cc318ffd5f0de4d7a84cfa991ebdb51282706a5519285a1195d4fb7c0f22c41e8007ad5753942dd4435ee2b717e63735b8ee6af4f93c780dd4b3f4ac812e4f80fac631c7b5524c19c87f3a5732bf6dd8d202722d51a2ee6bbe8c439c4a808475b29773dd577279dea13cef35d742a8ad928d42e228866fc4377f08d8fc13f7cc3b9b547f782742419cbfbc0ad335f7a9f9f44401986cca416bdfb061da87f872f24b0232493164ea2dbe73188544abaf37af8701a9a4dc626120b673f182b42a0d81d49f8b1bc34897a75bafc869ab747cd4854caeed3a14c74c6f61492fd1f01bac9a35ec94954d7f9bcaa5181dcd79a84f39335ee2ad1b560c0ef53bb1dda9b824f205d5368ff0bb678c4c9b2c15ece324faa00dbf6c1d6e940d38e1ee026397ea5d623a12db837aebef276ddf585d6254b402d105543c7207718beef901423387eeb30b3d9fbb64c02faecbcf092049b1397082d6ccd6c9dfa6f44d2a9d127f8c0a1ee47cd5c177d2aa5a400961306270a8033ab44d9cd290c51af383c030f89ae804ee00cabc1798e2e1f9d700039e5fd261dd3365adf3fe2596d379883bcc9da08b463b3f1f91622b533e7b66b079e3ffc0531fce22e124ee900fbb36176bedfbb7ae15b232fe06c3a693f64dbff855f133544a7ea6e252de7d8961b4ed9e261e1a3cdd1084f89be6c5126ea06bc8cfba5a6622d3aa239de9dff77b39b55bffa7d0d59730ab697b49cad101f9bd94439565aee7354d54445819274ddc924228ac8d095170570c9ce260b9acf9887d24aefff71097c9ab18b0d36ac51ebff538acc2355c5322c5e6543f46c23bd3e90a9e6659566a35b1cc3599a422386595c2ddbc10354b6c5a08272c8349865543b2d0f30b646cfda209b38051d61a8c777e75e94d590e7597051c0812bb45a6d28b86b55aa3bb96210b3513a22cc7df50be4ee7643c10d3d17044ff4ccb588bdb35a732c67f3ba89d1af7f89553242796828e5a60cef7e123163e049b51c75828f46de471c3d5040944f40fa3fa317db85e48c160ed05de707bf22acfe63c48db456d9af80c8925f01f5cb45640f43a17a085dbe30b4c2c9a490d14a9c400263465a46924c45b08ebe9a887c87ac02626f9d0bcf3b8339609e77c5e0678fa400f96889f69a082014798597f79fc4857b7558779e814014238d0d78815b42bdd824ecc30307c6213cec9ecc020876a779c2d8cf8df07d732604cd8de1837ddbe6174596b681c4ba4d1af52413e5fbd575745a13c12a9d78f7e2c63a206a44fbc939ea734a14429dbfb8e97c7ce5fdcfc28777532714f2867046517371dea46c6970cfc71564d99029e8e8ad5071fb198b6adf67baac419d5dc99b54900302b630b16d1b70b7f737b8d239e846a9c9fa74c62161dba9c4794f043420861e25246062bdfcd29d5672a1e8a833960bacd19b8eb4767928596f26fcf51a7730c768a975a71cc5d0a7cb075c7f2f3e04ba03f0d65e79ff97c2fa7f4658a8df8e862e06af0625fbd43837fe2576e3bf1db30aad20d6fae5d224e9dc69a55a73f1c90d85689e78fbceadefb753495e31240f9f3a84e3723f74990b73662e5570ea6534789ea526337db14ef51e212dabe2eff99c4bdc6cc9cc809b1d9cbf45260706ca04e3eee40d7f5dd85de8584780f720f8c127e756ae476bffe16f60c4312eb47eeec7e4f9262c5914d378f68d0c5343676ab24053c8f90e5a69832a14341fc43e4d759a62d013e6dccd79900558dbd14307be6914a525369093cc6b2a49c81e2a123bd3d8c559d2184c6716c5479c0225797510124badbc00f3310acaa89324e24a51396605a41d17f6125b6e05bd3cfba3ae64d45749de5becbd6610e7dab3c9a0dfeb4e71a5f6f71503c6ef65bbbdd40cbcbe3283bd4621ba4c329a1372e5f3f571f644ab1b11a241df4164dce9c3b3ead93c14b4f3117bd13a8868e473f754e2d60c4dc92b9261f8203cbf2a413540904594454edf937d324fb982d31b0e13fc3b06f02247134e3eba3bfade9ec6f0eae25d3e09b93863b142deedb961d16fc0e4fa07b639b1ef67abfe98c6da13c270c215a2f0c467ae9d1ce4ccce3360ad8e3713f341b5fddc1d617c6a269ccbd5f8a0ede56e3db08329cd3565775f307cc15d150b4e26ae859d5e8a6dfd689c8d47f5e7631eda505ade6fb07db92344d0f7fd8e87356f8d810145d1f57cb8953773fb4961d2f7129ac401b963feae986d50e90519a663f1815f6c25e6c83347b7ae63512f88d6839c08db72bd97927aeff7331784019099378f21787c3d19ea3f8745b9548f2314a058a84807bbb023811a98666d4116f92c352d0c6e4a70044e3cfb8f6a8f76c87fa8e0a0a68dceaa082e28bbf72122c6d3c2f882c9dab5068bb96db0ddd6f1723a1318633f770a9297a36600506185a22b14426e83accbb7090b765a1e47d88ce2806aa1a898a64bac288d6fc7320547d73b228af740505e2dfc49f8381f73ee0da8eb0756cefbe8cf995a0a1fb6ede65061dea13f351a00231fa84e1116713ae3f44f3ddea2711a4c685ddce1efa6ada4610487f01fd740dbe26eb95b422a7fbd8894ecfa387ee0c3af68eef85e2a71dc648ae2b358015e685c6566b3f2e7474e177c3cbb06d179a183d438bc541922b24aed6106d6c1523b13610d87864621d34e30ef96da68752026b05b9217c545c2bfd9624e9ebf176d511eeb5a31adea1c615022673ac8e714a8a83b1e761ebd6ec2a58a01dfa3a4c528bf95b878dcd9a375af2c29b87c29696e9255522f9aea4f983c68d83da5eaa23dc94e0b4bf0d56990c37539d06aa06871db3d01ea3c7f57d0c57e3af8798d149beda524a407269bd26e166d010797e8fdd725f4ff5b4f09ca2123ae4556aeaaf842c0d01bd5e300cb903f06100c12c52d75967286dcad2309276af828508ff277603ca8c075e1cd9c87eb5827a33696075e823d5dac29f124b3a3ceb9c0697850a4f4d718def554857baace573d579623d849a8d4a66510d526e836bc8f6cd14ac01d997c84e69696facb4e86ccd4dcd2733de42e2c882058195498baaa7d81e1bc8e72348ab71f7124e326f63c0c064a2207d7e1d5c9172453ced9f989d67067fac70fae925154f5b19479a3b09b23905c160a748a41985c0d1b217fa94f724d51f56d3258c5c9a4e72954142bba577ed2af4965c683ea20a969c705b05d10d102a63de56cf415f08a74f2bdeccfb7bf922eb9de6e5641e603cff52e5261eaa9004e23f860053451889597927ec8a4e800277a556b9304c06787a22309961724fd1a78e4a5f114a837913f72708d61b3915bf6fe39e0e371241669077517eac91eb9b57297f82a81444ebbff14e59638468e426757bea371f6fef87b3ce479ca42bf53580992eb15c2407deaa5f31a48f3bea25a488926f765991b8b9715205ee25009ef01f678e148463046f1d7f2e43f7c29401111a18f0fffdca98b58e5b6ab6b10163fb86d3c088100bc1f920b0c9bc60171a91a55af5f5acc7c3800a0d68bee74ee3c4e6b6efe95464fb78ca4390945235746b895e9a78c30259b9b483caf981d18c9eb8b799f67bf306bdc6fda6425b41a743914aa6f1cbf3c38d0eca0f7c80e268d480468379ab8f4fcbf913ad1c081662cd15a0b38f7a13dbaf4db299eb1a8d64d24205bdb3dd2f315e4532fc18b99fbdfcdd9cc0fa20fd2c578038d4769287a9ac638c7f7ade30dd4a68afe7e05d966a08bb9f5bea3e22a2f4cab449a40f003e33e8d99d4e5bba1e3398ab5b5e967beddca54a59e6b62eccc23e9575383a292fb73dc83ecec3fea13c2e6485581d22d4685a7a41a1dc6443d6efd03a81efadd8571d77eccf38ade0745c497e31692cd73653f1c4184dd187fd69b154b2b9a9e06c15225df4dd4245f611f151747f486a9809115be5dbdcb2d71f3825b9c91f7f4fa0054ef0a563ba61b2b17b7036b35418945c45fa8b76c6519314073b0e0cdb111849ae552516c368bd707efdab46d4daf56cc720f90e1a08996dd1007d0693e6ae810236e33f4cdf40bc60bb47b89b373dce4983111dc59052e3c325186660df2fad770b0f3d0a0811561da59fff0ffbdeef40b962f9c16a12871af9acb4fabd1e580b942ffd45924a9d74f392cc06b9a3e60518b2db82d9581401a7d65ca9560957493b37e6683c12abee4277c08760fa7e77123e78867b4b27b189850a15a3bc6f8159b5503f49a5aa5d9f86e7dfe772baef5bb461627dffe2b551842fc7d4d4d5c41b299177523cc70fda5207805af99b9c5e73d274e2ea5b522ca0c11a63e0654caa2becbe022c55c01dd6e3275e36549db42f855b1534359d7141e6042519b9a1cb45b365eff8a9a6b43352bcb5f51bd356305eb2db9dbb9baa1e5198b36d865ae82a51ac3a46ce6a607ae869a09468dad34c03b54a9144f545a08748932ce0096856d38d4ae6a8dd249a052f6696ce9499e953e0240b02172f8add945b5b239d9cc4075417ad737d12cb810ad038440602daf27c4c4fa63527b78ce5bcae19638e01df583d0f57a3377cfba7ebd0dc3d1a5ddf20a3c79f6d34335964e644a816e1726670d6848ddaf5fad2ed334d7f4de60ed2af52ab7f3af0856099751bbf5ca5754c4b8a5ed2b4ef0100465f8d575f53dfe014021cbb82f9b25ba4807318dd323e47b7c74e969a0ee912437902c1967d1ec2db21780543eb9abad5df1df3124f080582679c481590c4db6873ef48150491f02a9a7c3e5578eb948455198a21b7af4ca8e72d93c1fe97eb677cf1860966769d69550b31cef686a35b800cb5770d57fed6841084f456c0b35ba7c5f23d9878dda33e2a4691f2cdaaca694660b01aef3559cc1be3b94c1dbcafdb216ff22660e2e833999e16813039d8fb88ef3626060eb2191284c994167dd37a72741edea94f623ee331aefd73bc8a8d519c2d57d15432d60dfda8b40a8fe495a6e3f0fd0ef3bc861e691c17240e14b1ee9826e8e3061d7e8209306d3b03e99bb56a421a1314b362a9a985eda23a98e3a2516ff1f48b8bb7233f8a76f61b977f11e39fd87ee2c177188a47e650f14c3be19d1106e9d3fff8afd1e8813f9b0a36d8ed0d74c94a0e2cdc75cdaa99cf7b6b1f119c9244dd1ee695502e69660ed9bb30db5cdf3a002a4475d6f20160409b0a056170818f4d58d19b44f47b4ce10116599157ba64911913532d54bcc1b7274a700165f582a97a07f1e1861ef6c346f96cf0c55db266c8","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
