<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7335a2f14bf92f58fae04641a5570f3e7eea8b5e851be7c5baa095fef106446f92d751e3d7da854dd8a9536e0599cb953ec8fdb51ac731e9aeff3be3f5985a5e4372d115efc79d53ad38d758dccca2fb9e0ea92f774f91ce363c5e000f9deb3b2052973c735ccc71c18017ce75ecced39c62645de7f6dfdc62c2cda27cb7dcbf34e54a8b29868ad3a1f203203c01f3205e365f4c0001a91a1a7b11d91642565d120f93919e053bc7ebb715c223b2e80900b1ebd254aa6eb23ff8073e56ac2b897ff0cf2fc4f406aaaa980aa24d434a863762c039e056e375e9b9fbb916ead5b7dd73db3e1e77baa517a17f7af51fd3e8db7c810d04d606fd60daf5102c3aafe7e43118041e3a7497805cf52f2ee454bb6108e456791321283f34482d0e3298241a5143ed2ccc047795bbd9244fcbde6cc987045e2ce3ca5038ff543dd6c1d514d0906f01301d9a25f18ac4e62104b1a02ed3e9eb8877d02a3e277aa693881c5034ce0399c76d7438ab52f3409224abedb00f92b3ef7eeafac064e67bfe8dd3de83da29445c57bc273048eb522a392ea807f4f4dd6ffabb88d451b8314da369d1c39e5a8be3982c675f984d9b53675d87063da68fe06a93fe99cb267689786e762cf24546dddaa5a8bfb7edcc8d2b8d705abf7bdfc4a5f3284279bfc05396ec29a0916e47c5d0b9800fb99d16ea0eff235112e456eefdf7dabd4f485eff8276de6851d46133647282b6471979c2a4c79666cc91d87c6d6682b7c7c3fc0ce886c9bf43e889b861a7705e080dd35c163596950005984d5fac2d1976bff8d5f11cdc8a28ef19933ce871783da47cbe9e24bca06f575b27f301f635510b4480ad2a835c814fbe2beee2946d0275914cb08e460da4e88c916efe6659f68986e5f44fcad1d8c11932e47361e61a76e583b5ca43d61079cfa16bbf4e19995de097732153135ada02c9e9b3cc00031a163b322c723b49c807a41c89c2a4011c5a37dc6ed0c8cdd7c4724eca208aedcb30ed51149e1c24a2ea12cb126a82c577e7dae65e6db1f4cab76bb7d9e695bb961486a3058bc0e26720de6872341f75b0d66cc8de4f05933f367c8439a5fe8f37bf8ba65b1e0e11a8d1febdb3f43ee74239ecf8dcf242c00147ceee90af43b809c7ec6226262b0ef91f58c2f235f03bf4f01c6751c32c0b4433e01aae166ac6278976a50086cb3c82561d052b7d9bf03198c6645cfb04bd92a84232c26fa0cb857aaf68d58be251e1ee5e0e4663028c5b2b8f25fd2ab7cc88c9f4ea616a747c732669b53aea8119c9e9f9a84000fe0b3e47e4df2244f7adadbc1c5dc8aaf3b2cc13f8e066e7e0bfc59d661b7db5ba766b1c6860cfae7dc09576deed11951629b30a5d81ba686ea346725aa4685ca75031740e5c400341cbdaff9038e9428e9483122e2d911882b046398126a4987b346a5df59e4acadacdebc62908e08d4f88df98e38a8c6c18abae2e5ed9c2b5a2b48b275b54edecee0b307b4f0c445d0cec2698752a01a3cb6b373815526e8b2b379c31a687cbf6f908838f0455026c677c3bb86a9c3eca1a9b54f9c5a2af9454eae40dc9fd2096e003dcc5c17a35a121d3de00b354e7f6992920ab3d7d0945607e14b431ff32ca561ffd1abadd275e2b01bd5d09698800b69597246e0e55843b480b483606b61b4f865455f8e9d5b820327ad0117f69be5c91720fffd11b4d0f13b1d034fd3961c47f63a8094ea0ee9ab577944ad07e0fc7f77abcd454c8fc4a879d43556de2faf46db50d3e37b1ddb83c9d991d0afea2f299c63fd756c2b45987adb099f867c915eb2bef9ca72ec030bb204685ee5dfb902e72127987f14352a81bb03e55bf22ab66f39bf6f4b6b63a570f874bc5fb7b14e6601bdff5c900de8968e2153921006570426301b22e94ad00fc35c481e37d4c0358de4e625c2d875a33e8164f3b2410ba707ceac68fa22f16f2c267b6276edf6ea706823034573aeff6cf951b4d0beb418c2aa4861a86a19fb801c03ff6229304aeaf80cc4b57063843b5397e030b50d15283aed218b4e731630a53abb8dbfe8235dd7e254a434307641071b2e8931dd929d7b2fb150ccbca6608e1ce4e27462cbec3fb2946b8bdacacebe9085291efd7d2e442cf79ba669b3b40a9977da9f79a92566952a35f4770b7204f65e3e7b75330c6be9871a34c5871ae37f7b38674552237f2475d645103c9c828aa29ea711d6fa6d055b475e892fe9be722bab788c19e5692c264293a1b610650c161afd45ef61b229f77d581092dae306cdaa118f85be7f7ce1cbd6d26363a5841ee57680fc6fd14b2c4ef4a0bf557e34bd234b812b736bd549f38843e4d2bbbafc954bbdcaf4c1f2085e123ee16a72c0380b76b9e698d3d04cbb257b01a28b6822bdbac52a2a93523d86cd605ce6f2d138b1f914770673251c3ef95518029b9f1ea5e3003678da03a34ca00388f77342e991d48b5328c647ec798886bb930c1db5568258699bdfc2848980939dda49a94825416451d90f9b6b38115ab384829d19d086b0585369fa74a98c9f5788bb61890639e1a2a27d66ef653d9402618e06991f3b4dc816c26a447c4f5b10c7e31026704ac17d682a9fac47cbe221dc1e6d7bab3bda48d4cba56675139ea8217cc1c8b696e7eef6b69e2b622eb8b09a7014031e66a7c6b6560b8158c65b059229a2d29b6840aa7b0399c1e58c597c38037e596fc4e5582edfaa61bfe45ed46cf526e42503ac19305a000403f1bde99537795f3bceb1edfda33c245a23a8e3b75d95d6d2a19f9dc2d076045dbd4c4c9ff9b27ec7a848ea00319b6afdbafa9e51a52d9cb6f636af95659891b0ec4d6c3fbdb79b9ca5996f1be62ecd6d8149f013d3f44a5636df3c944165b5aa2f15a75525b4a514c73083fd27ada79c736c4d4c58b4549a6372a1e89e00379fbfe672d1d300955b6e6e64123e1a15959a2b417cc011f2b8e44405f9106aa29c7ab57713f404f3f616b9a3db9597d2c1aa986d7c0e8d4e4ca4ef883aa6c004c4514e05aa578b7224b6ec32a5c1433ae5e9b0a0cd7af1ac3f69e0fc2372fb6d5127e27e73990e0c7b41c8c7bbffe622fb35c3bfcad106c455acf22421c76c89a8afedfde827a431da8b0f0c075078399b4f4fc97e2522da05883a23300dab7ec836e7f860fa4492f2f0c50e45f0f89899871e4b6fd2ba15e1e4fb10ca6a7512d08e39d5426f14e5f39d326f704aadb151d848cd948bc87463b093ba119c51e45ae1b59161356f116453c6238a9c155e5bda9aad05320d262bb9bbf37019532093b490bc5fa88aca0ee91705211a2d65b2919ee33de9ca8977938eb2a863fad23e0b38b9b90d213f09d05860d7172d03719a6c7f26c88a96b4470795b6c268de64ec25347793e6ddaad5104356145ca44ac371f7430bcb0c11cff5ab085920b9e949da6b70e99a238d254287f20c8408a14017be4d1d21ccc7cccb00082681b099f350479955ab147519e63ca81508abd597e7b49920f02b41568017da6ddb429ca8165493a116898c7864342d658244a6d170809a149be0502c8eee4c460b443c5fcb78fd5e80754e0a8d585262bf0b417ca2845e46aac22109fd26106661a8c49b524d5d6961f7336684ec50f7727279d164e4adda420303c755ceb7194645b58bc14cb8ad7f6d8b0ede726969e070653dd75ee0b4172a2b158d5e6b06bde043e4f283e149244653040824d680fdc12e1d88093f929de7b7e010c1f68333913e76c2a4517277f509106ca51f1cc7b17ae31fd15cb7db6aecccf67007db8b7d8445f849061662c4e0ecdaaba8ca45af2434f0d4f56ecaea7f007e48d5be2bf6a21a2b478b6e00d6e9f53b482d500e6fa4e4797326f3e93776bafe861bc715e8a7bbc10edc8c5dc6673ee68c555fb6aec8768a890680c0c9da8b294f744efa4ee65c3eaa3661560c95a346456bc9687046aad08e524a14ed4333012395ca6a2749fcabd448d9bff468bf410ca3396ca621f253b4b3a6be1765ee090f75728fc29151281af843b14f0fe913996599008d3e6f5e8408c8bb99b4788faba7b56d5adfbe0af1888399d71e7441d82dc3fc535fa5b28fa5bbc59a89cb5b7d40e86f886d4987cee710442e01fc064d970912942c782790513678f99a395174be9d2535327e93171b589eb3557259c9959b81b141d52bad84bebc5bcd88f42f13ec9873977ca3c6d7e224fb6a56b0c20a902a87f8587d81d2f05e788f62e94eb2010306a3df186f26af6a2f747030f8147cb1618f0e8f12f0ebb5b9801a6d5b17b9f50dadfe1ba9e693218affcb3d5054296b83b90130cce41d6ddde4b36fd8e233320648adda9c54286527073a818584d4da4893265367cbd5073ae82522ebece808e232e8fa87a70a58a5d5acb0ac23ae2925caa10016b6dbd7e57f37eceba0560e4c2ee394dc87ea7619b1436acfacda0570d9c184376f9d89ebc49d28079a411ff5dd56082f5c14aad717f280efccf3556a977c71d441338ff4752ecf8674366f001edc3ad3f230ca05fc386e9adfce8565c66acd193a22e307acbfbb508d4f03641f4fe89be380b45bc9153d3fa4047ebcd7023c820c4bd87dcc6c0e963f9715bbb5e5cbe6883f7f5ddfbdeee664fa1899ba832b37ea5bcefebca3daf0c040c55219a3cb5668730e255a0da9b06819186cd0e8a6d4a4424225796f47ad326e0479efd9d571ed366329a28494a4374d186a648a5a67099735b2b2a0a8a643c55d51528437155daa03b3c55d94b3415b6191db8b2942ccf0defb5673a3832c951bdc9a81ec9c042533b0975c9123d20ce2b3821bd5a83456d1474e6707a600345d7b09643efeab2d9d68216ba810e6ac058a8331dafc0bde08489f9b0cbd311a1f12eb71a251cd903730e04f2b7c401115d1700c9126fcfe5d8b13a281a6ca0f4a3d3564a4caab9958fd3eef8c5086c35cce909fbf259cdc0c92ea9af69f1dbed41acf40ed3d210ffbddead8174f7ffb5016d986768dc182f4efa482ba5dc4cc4101a091375b02c0deebf8ed1ba7a1b490f1a9484234b8c26c811cb97ae5b51c783ab7d7e52d2171b3bdca118fd0c57d9d3b059b18385fb998bf156464ca1c96ee73cbae5790515c096529481c4101d160e520219afb4ad547fa303e037cdcef991e9c62ad7228d25803087e456e4be017b31186af3824b6b2a5ac0c59275f8267c53a8c16aed294b1beb71760c10cfa17dce32fe53c57dc8a583c23e9822a09b7ec46399855d5ed3d48f45f196e0d51efabb3db5d13b812df653ca4d8d0825ab64d3f7be4ccce5ab9fea29ee6ddbb036ae938cf7084b84799dc5f12ad4566b23e9d9c2acbc6eb5dca74d1d03b2ba965c69ccc40e331a8676b865c00294c1ec8782e3af8899750a53f824196f3a310be84344843598403f75424f56965a63e8ad96e72003b6066776855f6d0c1629f9261e2dafba114c7395b8017f8d44a60ae6712627714ad77f2d947fa73c8fa0ac5961c8beaad0c3d7f911be38df32a5dd37ab321c736b1919ab77413261177b0f2600682e249701a2be8eacd8cf917fea4f1af79253dfb12e2843495843883c9e31390632b31b14ac9bada18d24e2a38088c0a048967136261d1e7aa9e7b267154069c6054c5aa9d373d8aa7cafdc777510cbcd1d2f85d6ccc67d93afdb55c3aa640745267ec8592eef6732b97e373e65c0f8f399fec5b392e052e89f4c910114232cf8ead574731b05d10b899b0209719fa28870061658f503523038555ac145b24cec016d82656d220a7daf046278158d6b1434432a43f7708b4768d7f869fcb744836858fd8215d29f2b62088695c842a89e4539bacc32fd097a5dfd1394453c6e8be68a914f3414d80a9de223f3edb8e831ee2846c01dab9ede962feeaae42cd59ec7b178773ef4cbbf16d531451e7c6d76dde819dbdd9715d01022493e4557d4cfc39717f8f04ca0915382285551e64c6577d63ee859d2ed136cd3ef5262c722f273e64fa8f134b8f95490ec0cbecc6c636a856984ef8e65936ee1d629ac6f2b5c4405cfb645e65e0236d1103b5779e47f9b65f0bf0d9283e8de9c7f20a6e3974bf55150176ab0db0665a7bd33cacad75d88c692991e9bb8454e591c75abd46b841af1a14e177ad02c09b14363670146536769d31509fe553656377395c5e23806adafe94b9a6d0e67ad87a699af325aafcc4b8652084d2cde9f06682a41606563d28042d0f0d09bf04162f2e108d19af57261c14ea8c12bae81157f85ab9698f47e7b229f0f9b14e777828dd4f05497b72f6029faa9cb965658cd210f4b51544bccfe81f7145439253af0b78b38e4b2e7ab876d70fe6fd1a84face92eec7828059fa5b254c963530797b2b1bd4db47c323162f336f6392d0f327016eef2b8af12301dfd3351228905224f4634fecf889f5f56111fc5284aa87b0419af36bb9346ea6d4354166b434fb6c32904143e36301a061f1ce2de99d1975612502892074f1d3029c4a59bce9bab8ef3299839fd5b74777924c3507bed41910d5a07bff2db9eb6748506fa5e7b954bcdbba8e73ce458b2985c23735124ccdafe464f5f31119cd25ee456d138cccbd3de865fbbd45d1d8bb28cd2a16ac113c261dfc3941b9beefc62c4225bd81743a4f4d39b79f6c22975a4abb2ec9bcaefd256c72e4147410ff6f28dff7781950619a05bbeb69f85662db34f46eb47ee4dafd24b6d72619f36319ec94d7db619097582050c0a52e0900eb73a7f2838046d8b7d40efdae9fe15eda9e843981d193cc77530d288a331db0e5d64ea965b15a2bf4e7e907478ce796a0f4044be89c5f2b6488501b70ec8a8e8773032202ba01c1b2c3ddd4cb59667db8ff790f4fc8f6f33e5ac48cc7989b284225f82931741c744bb21673f1c00cf55ffcc9dc04d33f06f25938904b78f692ba5098f2fd2738784a40946b4c953397da4589ad92cbdecec977f9970fca3a315498e88c8f1cf909a4d757ac2e9115a4af934f0bcb90973979b2d72285e3648562059b860adab63ef428205b073b34bf925738046155f3bb483278e4ffe59c4bdc8644c57a7f1ff7efc349776a8a484c11d729b787430f0fc5a346966a30de7db44b8756050199fd42dc03455e4472e2c163aff310a1167b5b16150cce0a8dd5374e86a7ac4637cb60443c824002d6ccc49b7735a909289c0c703fbf92014b82570bd7e1eec7339358444d2237d722c91050bd1bb4f7bd619f61c7f75249381e9a4c7efb6993bf63558e3e0c59432720976e1d1510ec8ebcb473997cfc7744fbe84bb3622056ae9f68a46daa056cdfe6484b9c5512a97f2df2a4a9fe9aef5afa36d21047c00d306aa4f397dbf941a960e675c34129f030eeaa7d4351d58a1d201edd4d2c285186991ad832657673f6716bb3d2daf93b101a45b03dc9bc8402cbc57a4a0343b9badefe0e95cdc66174b99c3b514596e628d954381bef5d085412d19a392703783ec47eca9710acf64fb913189d979645e10c4e71d0cdacb7f5199717e529ed2d9021384f149e7d212ae8a38aa9975251ea89c6290f92d9ce89e517d164fd6fced58c8e75948990b07cdefbada0796fc1708c29456a6dd2191e67e4a944a56cf1bde87f1984b3c85880c2d7dd66dc631b1b830333aa57089166138058e32f2fa74b199619b3f8dbefe3dc8d20e21dd41e07131c61788c678e9f6f86960482c313bed3fcb65d24e920e71db22fad2f4db05ccaf66a20f61193ee7bf7cd5931667f2b77dad4eff9cfcc3b9f4ac98e27ab6706f77df2c225f72446bcc9afec399d9bb022e999031767643e438166a4c4e1bec56d9bcad790051f7bc2bcca920e83b5b977398c491f0a12f6d38fc6859bdf279e947711663e95bb65448f985123976f3f63270a1d35e30b435cd4ea7fde5bb6bf77673482f7114d579247e4273d7d7c93f8d6293dee58a5baf5d288c59770d4415e23eba8606f971a849fdc0907ac4cdb6fa5197d79cd95d8d167bd420b93e6b9138aa00a8ff46b4a3570267f2c0d82b2cb862f30fe5d70ab4bf0023b585419b7cf8127044dfa16630cc36eeff4fec3d899547acbccf6a113751cd9a8efc9cfa634ebd684f0b17863bb78c370b37bffcdfd25b3d8c0c0a7d4ec82405aef181c75e9d44774cc51397384e55526574363de77c673988e4e4b4706787aa66e853b0464537da2a4ac178a0b2d1a1edb1fb792be8c66a04df9601709a1c3f9ca339d31810739ec3480d5a25bfc84485e071c49736dcbe43df2346b40d53bc00a19b6969da0cfca0a6985f340713da34e71efb85135529dab758768b9a3718fd42f3d57155d7ec957142f16c6ec9cd8295d506b90603d04f33d06bb52846a92b2a59bc2a69731250eaf886db639e1e915204302576d882fdca78bab8d62402da7a5e9efce093576f9f2fa8ce17ae8a5fbd9cac147fefe431f4e9ee0c3b959ce8c983441a8849ad63762b4187c22f8f0638fadf475dba3a5bf45fff75facd907e79a7e6fb4b21b10f80c17083562cb8b3a39db040f8ec41fd1ea6b4d025cfcb73dddefa172ffa42feaa03f99fc001d80e87192331c6707a03609a840c240a35b3be410809d84d2078a22ed6dc1dba188974776888307517fd35a479d9c64874c8bd77304ad8e4542290447eee7215046174cd9587a414f68221cfb3cb7b5af0e78c440c35dc72a4097c83562b46144530acce5dfc11b2c1725eb864b5b815ac50f722c5cec2c1ae944483e300f8d6e1c37d1a7f897ded4f61c413ed0639baf838642b25f192f2790d6211e0e6bbbeae28580385e0265a2e3d20871a3ec6ce9232a2fbb662f3033c45332b6d1c85ffafa166563b4e33187d1b76abc6e754ec84322342287471871d53977a581174e32580f7954ac69a0dd4dabd26d66f32eec8ae2bcf97f30c57b8caaaaaeaf4efc3258d9265208038ee7feec551da9abb06633876941145f4ba90e4e9ec7afee214e28deec12d58c8c2491e16be93c1c8538f3c1a118ca2a7745a83b5d457a27541f75aea815a77582a1c8ed33317433a7921bee73284e035f3bc5b323676e829d84ab3d93720fda3b0c3a7522530d5f605f9a3e9e84dfdec0c9c0d0ea9ba941ead6784bc4625f5ac74fe2d9226871e8b55a38e7806efd1e41746b4a5fed36a348984d490953b49889ff9502c09c58bef8957bf3cbdbf91426e391c41b42c4e6de74a9ce3e82ec4a28ecd8b7018a8d39509f1646790460f76c35a2f712fe0e9d1642ab0125e5a08c89757d6e0469a377c1ec8c1aec7e4496560d6851c0d5e7934c5ab7c8e83337a48688cda251ead61c4ec6d2f88bf55bfd8938936bf6bbe8f2a50c6bb646afadb6d6842b1cccb3b98cbff20ec5f8250c0d72129be75f25d810dddf24586cf0d1af2393e4cbe2ee0772ae54d0cee6b1c87c8874d628eaed1f1ed038535ebb9af2bf0e57f52109c1880d4d3d51f4575e1845dd7b7d1f0983b5da76fa45432aa30e0197fa004710202754252d9537b836b51da929209cbbc451c2174f1924a29dac6d31f2fc8261d457d2f009069c5e53eed24d1a88de14203ad8e0d7abe460dd6d2abf7f93aa2ffb5e8657e89abb49ca31dd1eea8cd00fdfe427e6602f7237bd3e2dad3f65a9b7766fd511929b08fccb26e3a86fef941f68feedf04dcc4961777d37c49c688165764595901320c573b65b62a44802c932a132ffaf413bb8c0287efa945f53c5f9d669fbea00dbbe28eda92aec29c4016d880174e77ba37880dc756fee3dfc82a90fdc9fc8ef1cf5fc72f76999b47119f53526b64c9bee4453de8d10e2a09efde9125082343d4fab575e3bebff42608211ea62a17db11eada8ad87dfc377ada2f07effdf5f80ce2b74ff9d535285a2a1b92bc7f0ac86ea1e224439c9df1f5aa8850b54deb1402e10fbbc14fd9db882f3c3195caeddf4c787a4262c6add1ca993e56c0a8963b2bd4fa1398a5c0b65e6ef8723cd486322784a7edb4b0512ad93090440c3cd1aecec66587710fa3191439944e6cbc701d76764c735c0091b0f6fcc8d3be86724ffa0c1d47646ff106bbf9c155d20b415e150145546c6ded1e30b0ea762c990e23779d074a19c133c918635f62bc3823f1207bb67f1cb066923ff1e0fe586d2103759c85ea195786c4aee4a406d99608cb003b9e36819df141230ee5bdb58b00bf3d3775615b62b3102c7e949dc00b1b7371a53678d6e3378905629fd43e6daae32c378614b4458d3e8d6886b4694ffc8826c0e09bbfad6ab5089198228dccaec099c45c92845ec29496afb042e7bcf0942ddcc6cbba034163f352ae982f05b7d00ef901b0dfec335743caa733b28dd4dae8fea11bd454c6b72db354b584f7970841bc3cd03de4380bede66fe0e69d00146e2d4b096865fd06de3db17a5d9e29b9f53947fc4e37d33a058854981219e2271547420abb4cd58e2ae215463451e33d1545e171eb51c5122c8af82f8132a36f1e55742a1b9e55dc6bb853eac463a709e47557f393701db579d3a167ed3d91ad0117ac118af5bbb91f7f31628a341d18ac9501f843680752959dbd01f04fde65ab01335d0bce7a6debf4d48c3d2487d873806ddb2cfe703768cf8d161ae73611dbb069e479eb1fd15d6ba0d4b2279d5562a5e554ba055c3a1624fa7cec146c62a79ff566338e5c703800b7ad1f9f48f69bd3aefca4871338ad4a1647da1c5bd6d9ab2678ceeda61a4c0a6062a888f24435f5ab14dda9f4fa10c699989646401b14607d60d14325cd359ab0d6242be384e30bf4fd2f0e9505dfc4e775f3a50c3a7882299a327050daa78843567451636e755760174f9957675876b2c676249aecd06da3f61bdf5b7bac742f2b9b0d1e56e86b475ac7050c8b4820e109db33828af40ac0fb8ab5407003186efe310e52cba5081ab185bbb0f27713459d557b37688c6bdbe89c63453743f517bc434159e0dd07ff52fc6c32f9955f0b642f1fa85ff6d6b96be12945b61d944f58fb0483c62851136f4199ac82522d2ec92e220d77cb87b32f0f58440d0347b0d97607f834f3ae36271809daa3a9ee00c438d492a36ab31a7e21c090b3f6fbd1411f13899bc497318dee096709a5bc214c8fab6b4d2e94ec0c1a40efb0d34ee51208b95f315c4e1bf31b291641276c49bfaf644dc405916c624ec48d2c8c5a8e56d5ce9a52dc19beac642f25bab4c4b58d2fa33da9eacef5ed346a4f4cceda6bd4fd4af43271223b8a1ce2a8d97e829b73d9de376d007a5a1961107d1eefcbb477a2ded2cfe67ffa6d2b5a7984c0c08055eda5a9d97cac4d544544932aff1ee59d23935160e2da111b8ce52d62f39a7da56b14cd313bb14d8bb560b9fde50c5debbade73e42c3e831baf21e981606919c5406a84e37c88a2a0847361771a34ae292b09272d093734f208c1fea97a3d979fd7e6b3ddf20920d3820800221d6b68c28fe0f8404f10d3fd8030d67abb133316743c76cd806a8e08c97ea4b16f48ae9e352bc415fc683090228987cd6038140ea0a108f430b8588f8ce13fc168ce11d881b75616def163022a2d62f50441e7dda45ce10bba816d3bc2fc65d1986b9ba6a055e630288d30e7a383a2433775bad612ca4ebeffff54c243a81ecddccd069c3a6b8f9c25d947db94fd8a1a1cb567e510540cc1bf8a3c20f8f2f39046469b310d783d47d727515ddbe6effb02f7bb5401efdbd4acc64e268babb1beee9901ca749c397b80ab71975f1f8519dd0a35ea8a7e07bbad79cb7448167b6f58cbd8dd303b7bb30e769eba62c58790e2f97478b167b4d593caaad3763a52871f8b75b1607abdd6d6587fa92f1e763761bdeb9c48740a0d230af4c8811c32d38e8a2baa7194e045349312468864c7850a54ed7a5d2eaffe9e0ec146bc5f03dd01a21cb07b11745d1f8d528dc5c172f559bc9f02363c0eca63779245e5fe62eab97a67d718730c44c7b49309eb067925c85d14d49e649c3227c40299df526e282def7b0420d1d657b6e8c2abbc757d79498a5598f21a933a1e37aa384873d7a112f3917bd30e152dfee07f2c28bad78ea15061f9d4b6a85c50b65d05fb6e9907e24245c16c973aa2683eef94d79f2b75f92dc56b333d116348888eab9e0e2877de580606f5c41e0af4349108a0a0bed45cd5b55c5bc92e328df9f44a939cdffc69f23571103e89ee0f7fd3f3d72b18d872c0e24d0cf37a91793dc973f652a1bbc4c46830e57e41b9da201bf5605d77f144a961f6f80de5869115aeb07ce14520063053a33b6e04bd40567ce2a7fb1ff08c28291f063dd3d0bd7e6d783d1ea7884c735ed629f59d1c5646defb043be7dbf5e90cc39497837359df4ad27f84e939480713aae45285a69d69a4b874ce18cb28a56e20660ea732cf97831ec1eedd438e43f916b6a63e112eed0f794e61920e7de1f96bf446c2e84979d3204f13b6e81dbb0163bc28bbdbe79682d5fc72d2cf681173f2222590ec6782d38979e8c68c570a02dce1734804ba913685aae87ac947105f4a287e61a6c01a852e45de5015f29f18f6324d4aa40dd8c4e8a9e9281f4c2f8ccdb905596f467fd8a8e2e3a86b8150b5cef45ec28a749dc930b0942a82f18ce2d17f8894b205b7b69b722de9e512eed89e1afbd78a8c349ef38a57a6491664aa62911f381cb510f76c392bba44d34bb1f8b4070595f546df011535a74bfaadc9bc52c1911ebea60f4bcbeed69535062ea763d9a2efc2b1b485f2b83201ec97ca8b86551615dffab5333139b7ed7204e65be7afae341a74e5e2f74d329cb1ba782f3664219e0f4c62e7127573c4711d353eb37f70c6382bab465bde76001d87206e27b788455bb4d6a24e3f5c4b04ba03568dcf3749ee4083469634d8882f0660342e3aa540213071f583a9da91121d0423cc2b28ae64d2074b83c469104caaf41bfbd46d2f4cf344ea4954b3304790f0542ad7d3928ee801a3dfdd84a381170c7b844c1b32ba66f72d7c6127f61d67a5237fbc263fd8725b35daa1726d50a5432b675455b2b6156810dfcdcae949f2b88b8a88d3d8e31f9b0d1808a817e0a7d35d77e9b9d8d93be6985c6200fa209e855acfb54b054b8b80286c765899247a5713b83e0c5807e1cdb4712899171c6ffb6e42dd32d47a77d1f052a5f0746f394a810fda6d58a5233ef5e4ee470c9ee3b527f0b41106374559873e90d187f132acc330e2046f2dadc110a56b2a6b0c06b364a8d7e253e384d0d1d07be4444f5f1ca5572556f5ea9070f736342fb3c342bc82299e1794eb906d0b4fa1c7ae3a6d4e01d128a5538f800d28a668d1c10d2f7f2569696b4ce44223bc33b7aaeaea8837402fc889b7ba8dda144c9fcde85b17ec7158a68390a1a134423d919d305258a772f91d74ebe13003d60d179882065be2106b012ea9becf887bcabbf7b46580ad8019d6394e9c1e83d2d063d9b06a006997dc089f909bad6a990702502c018d4a46aae5a0307f5e7e6ebae8f33509b853617c62647f3a4dedc84248fb3166899d8389a7bedad46991d5b269cd3e68d9df65712953ad5f66b4ba1833f6bbedfb89bb1d89215d7d1d260aba54cbb0c42e3de2bc1d00fcb263c4c520fe51fa850a1bef86c1953d8b6a2d7854ca88b848e9ee293deca259f3560fed352d9c7f062b022224b487333f00ac8c9e7e1b772948e0681c91d03b8f2f1187e4ec06cb8261824feec3c83bb975e3dcd22387001585a20f75553d37c7988442a4d405340162888b75d701f7db5ed150b8a71c9b0b4c512a26aea6e3814f55232e5262246c1d7591ccd21a0d907853dbfa8f87250eff1fcae7f73e52e458dd605ed98cb337ad94d998fbe1c0294552162f7db720b7ef3c4584e7c707143fad0b8c94377b5884b862afdbf5506cc1102fd2036741d977190d0bced7d534e7562026117519852bf4038d01965b6006e33f83cecf0b1ce26f9886d1f1a8df784b5a9d41e795f06b1d5b08b08524773e5c49b98442bcabcacb12c8773b93d4dab3e98007056ac951c55d8de67a405f75378a4ff2cfe35d85abee479039c9ba52dd221acf069d24755b2a088c9e33ae1ed20b17c187e75bd1f628cf4b647b1c91125f0bbd4222e02ea40f33fc2d6d85bf2f4ece8412d72d48f81a39703a4891804aba2f1a03b9c701b4989506f487e6b12cdf49aa2470e2de0fac99f0ab51315e80cb47cb09aa5d41ec63ed4853dcbafb5abf37ae77a9f57e14d1849f40fad4dbe31207f91ebdf0fb6ca386abf80785e0a8c4f5a0d118df481c9202009c0a685f53877b2875d6c55ec2cbed291d81bdd3028f8fde350dcc0b0898e1b788e09df74d2e012901a8344c9f6be779fafacb53b0d2bd8027e7ddd9a2a635e402b7cc89ed699fa30cbbf90e7e82846395a09b03d7e8fe0567d0a4fedc804ac4bda5d175000306b90e3e5ecac26a92e536a7f4d75ad5c37f9334041edda1f268b6bfbde770f4220df8bc8021b4c1b374c02c548350ee570914816fe044eaee023377b30964d07ccc23b90be86ef9db806a60e7cb62a3c06d5e7c8e333838f233439053672b2514dac7610f940b4c11ba8d873b11cc98f4c31e9245bd2770fbfbe5e17b9ce2465b5151f7c2ca104aee286b517f671cb889ddf0e26b14f4704b0bfa61cafcf2712e9e591aa8986cde10ed1d41c18a1b07e210b8e379588f9844ddfd53458b574c15ea211044cba9475eae4c68c5894c4d263f5f2cefbe18d959c2b258eb3409c1455cf4f554cc49b6489fcc4c5cb1a2f6d88541e3868e4645b096819cbc55fdb53bfc1d4c36bd807c8da55e248b0419446d9c0753a05386e22fbab36228a2a22509bbfcb1cadde264fdd8c299cc7a750232415026820b7757e06a49404f35192085bd282ae9d1ade40a9ab2d8b9efeb1b405463d0ec08e450f32b02fcef2d3ac0a0a336e13b6c7cdca66dcaa65d6aada17ae2fdafc2d27050b28f7539ac0fe2856a6a694ab6458f49a87e3d0231ac49be7dc62c854edacba199610390afecb8357ce9148a71bb1d5b5ca6224cdcf41cede0ff27503fe25f17fdd9ace417263de6aba2c0c1c61fd216cd4b03143d0df81f260b2a1ee08f104d4037f709a56e1e4d824d1d38174fee07faf9e4f9b576c2f090a3b4792d0d14ff19201a5b30f33f051551ff2c334cb8cf4cb9edd6a7a5acfbd900439cadc1b1d480700390bbb753a9ef51ff9fa80ff76b1574e016900cb538e48466d546a50d0b6f3ccaf3f38b777d1c142dc99ec01c0c39d5cb32e070423f87b9a7b7a2214c98c22d8e5083c609a6b8ddb4fcd3318b7dd4db25f165bdee82a98bc5756c2764bdaf6a029be1b58a1795a94991e51bd87b15a0e20f1c00bfb05bd73518399408bdc6dae9b1e74bec0680b74b8c5df4ef026d783c167feebc634b6e78bd27ad7d88ec9b08eddc345f66bf6f95be8ce1bcf8defb50f341717fea65d7daaf4ceaa7befd8a3282d6195dad425dde3c66d22885feb588663b2780062014426e2672dbf207635f74930db621028243bc7d31881f9773b6182a24a16695abfbda8bd6dd0d6de1aca56ac8909b18a23abb7f8eaf738cf7a11c934a91baced42cffc94857c91673f2dc4a101f0c3f701e49cc924dc4211c301d2bf4c4b1ed733a2ac9fcf66727bce7aae5e673f125cbf86f6a1018bca913a166b9df66112024d1a1d88691cf85dc2cccee502bdf503fdb6f31fbe860a046f7041cc8983b34a2d873e22ba66cb5074a68cdd8727f6de1ebd6a697e9eef0049bfc27b223b93731d21cd26925d1e61592a6967c0df6a0e377f25d775e58a8715154b96901f0df57970f9db4a208e4d8a8ca5837748f202b68160c81d1f56d8d4c8b3d2b955560f0821b97ed6fbe55081298920135632465a6d513e6e0520837d731c29277848cbdf90fd07f144eb597dd4e5683a4923009e7a8a5b5ed14c80e0be60536d495b28a5ef89d69d86dfef3df9643280e06af21d3d39958acd1d3b523f05bef8a388f813e94a2b3c31df44c66652c2ae618afe8e882e8a5b6672598084ef38fcf6172b4910240856da85149228592e1ad8d48442e0a6c8655aa9888e8b3e523f073189e2adb5aa0ffab44754bfaefde4d9052e3af56f73aff509e0400b2e4182dfc4dd4b8d28a41569f5fa00322498c1ecb0827addde408ed71a577109e51c2b6891bdd2e7c99f699a59e8fac3671a07449c85dfe69d5c6cafa7df17f71464a40c203af0892d94101a3651d3d499051603f1257cfe78d6db762e4b27c0d794784eb01f18f89d6f971c8190aca75ef68c6acb640f908fa8fd92e2118ccfda2c17ca92ac4d853132d9866474bd3d9b797c78050e6fbc4523e6232d6e20dc424e7578f1f3cd3f977733822d834b0e27fe145ea97b305c8fcde3b21d0c4a025c18052e663e19b3a9bcd15d3034caa88209ab98bef1b292320ae40fe2f3400e79f5f17e0d7b8b9d4f745beb9d7308f17dd0c8545f80a398622e1956f50b7522cb31b5cde1e01f4f47ae1fc974e2d8caef65c4910e9adaf148954d8c1a236c65177a0a661a0f8c5d10ecc0550d805721971cf7866dacae41b004e198ef3ae9491dd9cd2a79d59d0fc79071cbe311d78facafdb683fd379b36b70ffcbba53f9006aecf82540b1849ec4ccc58a30c6503c08df7b7c8366f4abff50711ba52f53f2a22a88888a949f40b900c32f567568ba7af325d9906e6481e0dbeb872c5cb5518d3c8d34249e5e328273da251633249a92344ba392b3f041007b333d55fb47060b35a35344aef63d5944eeae3e60529f1d10c6e87667b8c2c7273637b5aad5b5694ec929002b4e906ed65353c513def108a5c9e5cdba7c32b52a76b77072fd628832fa54304849f549524e29fd65354a836685ea3ae401bf39c250083f4c5c923a375cd550f71b4ece07c1fbbcdb123d54254770d01f5cf61626e96182ffdf31451b6ad67b2374f6f7159f5784e4fdc1acfcbb756c24088cc09cb47b30fb0c3b375469052a5fa744e1fe46caa9a7d692353791e371b064d6ab0f6cd7c9c93ad203c83c9aa7b509650ac0ebb2cc4c4490d268c4dd6ab77abf0cc7ad004bba07aa287edb84f1e64869798a2b403513595830c8984c886c4a4539290752a4bbd660d36f4e1948c45b2fd5b90b4ee7574bbc699d06ec7c707c27ae5795a1a73a8be26b69321ad7bdb3a0692ac4464139a3426fd077e083a124a6cf95dee4cba618910b920e16e601a3e6d60b91dba4b4186f51fb4d2c860a14e4dd287213ffb1f3213eadbb511c7dd9e4919280f733bb2f819e6045ce11c64c0f1940736126f1ecfc90381edf239fc835b214efc6aa301ab7b687fbaf5e6344a28dbcd05850cc52e723cbb1dc0ff034922933fc6a50bbbbd203acb942c9cd260142f34bd161191b3edbfca72125a81d43c7d2e1b384fc925bb69c869069ae25fd1ed2cf27edf6eaef0c59c20fc886c3a381de7276941deea4fa52c52076d53d523ae30bd00b0ef3d5029b5a8f85efbb583e8d9b915ba88afab5658035a94075149848f7520ffc8dcf7172d2e5bcdedf7f5ea6d4519a4e8aaeba7b51338c721c42d7cf5f472dbc4498d536e9851bd94a0e952a25ed3615ef5d76dbba1320d8f86840ce74f729ae2e14a4c63b0ef06bebe3d6dba79d22acecb0b4912fc0291818d2222668b9066f8009237ab7b5b1b00a835ef51af0c32c04eb936f505a0559aaf49db456a31b254216b8fe4e8a277fa82076b718370e37e2f340ba6dff1553a82d2fc498c9303c04fec329cb50193cefed86ba81747997f4e475a0db32dba3b6d4081839ee72670888c528401ed373dad0f2ce57dd3b5bca008f1ddc9a2bd4d87263eeba646f03b8d73e879ffc2e548ec021f79acdca5b292665d119f83c04594073f5439ebd4fd3b3b79e2e38bd2ede7834842e0891e69da2b491b4b5f647916c066bbb9ecc5f916f012e160bead5bbe171d4fc302b19878346e71654c06ec5b2627a8e0c0e985895ff8adcc89505b99a241dc820af54933ef00f090adc33f08e20e244c12de908305550096973b29ecb277367d8e63e0667a0ddca5fdec92cd35082dfe162b3b829fbd4cf1490970","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
