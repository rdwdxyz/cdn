<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"74bfba0d2eeb2279de0e51b343e1fdf9ffad9a9cdde1c2ff55ef300381f4fbd940afd6047ab7e5451bbef8c3650ceaed0684a5ee56a65b3ba523c269ea0055beaf7595be00e053238ffd345ca271cb3a736cc04f45871b7fcec533d075167072c115286ae65139c631d2d1d3dc71b222ec7bd2dac6c45686767248ae7788b29e38ddba688ada1ba5d2168ef0f900cc7e8c66ae51854d1898d3a6a438c61ea3a952e25a15f6616c4314e04f1a2b0ed96a9055d87bbc28dce779edb6b8d9201bd9595fce68fd2ddb83fa4a892ac7d980083277465b07a60b7223cfc328cd978bd9cbf5bc6a0b50df05e557112f4bf0289ef371569724055f549b126de8ef104568202399d2ac0351c1297cb09219d8ab15606b5eb9c9b17a0d687d17e40a3264c9cf3fd887c1ad30c5309d4bcc9ba820ae482a22f6372afef4bc4582c2dfa0733af6340635c7a56ce467417faf2fcfd7c2157d7fcff929a4537a3c22bd63c6b573d16ab7c6af464a138beca733940077c0f9a0438a394887595b4bbf3ada361f994102002d33c8c378d0a47b5efa5716dd4531e2c310c199e4d8ced11cd0fbdb99d129b02c08e0c484ccc75d25a13d696adfa21bf1b33c741ef81116cf60892e029c155b19fc464fbd5bac0632b538fb0de5493db6e250b2c1ac208a1877701fb0b2ac797bef8863d50a717f7b465414f037767d858a901291e9009634d4ae63d7af34e3b65c452e5ada91ce491e53c8801ea66c26030d068878691e84a5620658120e052ef88528470166ae3661080ad4d2d68d2f85bad45c5cc3e9c5a63f1f2f1baac227037decacb286b71fcce96e46c303ac86fe9950d36b52997ec8b68ea1052d37f22bfc5c90d54eeebc07ccd91adc256f1019ae794580e826db155eb5cdb7a9a5813d8fea898b994709d627a5e015789a36b48ec1d0460654780a212d2f4320f96061a16968f9dcaf5e9091b788f6e7d9ff2639ccfdca5cdbf5eed4664e5ba0d299cf682fd0d366d80e0f7476daafe736a71bebe609729cbcc4abb804c1bbcd7887dc559cffe9e51cb8bcfd7436291765cca96eee56352eb54c4f3ae532ddc48cf4efcfc35326e80c4759fbdaa1482a65ebd23fa589ffc36f4324d0172e33a07ff1f2661c435285c7d858b3f2c871311092924bfd2c5b4218f5140393aa9a9e9f0b3c9bddad110414433db1c35818b4b7f027a7359941635dc9e1df61f4ffcb2b44fffadabfd8a44a3f0878a6800ffb63240d68c1e8632f6c5655f53179fc8dbc33066cab76b360f44ce84b2299b1c319e0045f4d76ecd95eb997917564df8f916a6544d0967e179517bc64be1058f8384cf5a80a05f5eee8aad25216a016e7814f2ae1d38966c3288f830c01fac3d71cbf87583c738872974e043ce3f5ca4b1aed56296f414f094621a12ae14de82747daa52c2f9ed1ba8f9a856a0f7beaf2b36cbe7b6a0b331642babce72f43a1678c7dd0e3c17c3743e832c6baa22f5ae3f05cedd2fc70adc6cff731df7d3a14cd90e2aeaf50983b9783fb8140b9588380dc0844f035a589dc1ddc8b65e8f9c033b6c27ddcbca29f8f8225c135f5deab1d1b2948a7f4527239ef80ccf0adf2eed2e9ad9d0b13aa432581eb5f40fb9c778ddcb9155aa1387416c7ca8b34d7394cfc9a8d7b077449dd0e55cb00cf8b1bdf5691a8935b1ed7fc588da571ffabab42702e009dbab68f8cab79b1d23ff1f641e78d72bd344d7eac4ed0fae006bb0f935dfb33470c07c8765693870d30439a1251138c785c0667e185829d8365262abf00975fdc3df313b48bce3506d62a3c87179ab6d8333a357cac64e2c772b6e094b8f3a5322034873e23164ce2ec5d6398f77ad590fc62a0e5e7fdf7dfd532f95e97172834389054eee9c7761bb39926eb3fce6f9a3546d24aecd6d3a2989f92d14fcb7a4e73dea028f6e3ead3d050a75960d7ef09aaa87befb464ee794e8e57bb27c14192b6fcdd393900783fa049707085fe87e30a4f66d01cfda165f3324d91b1436be0f7aea874e3d32bfa5fc6afb4badaddc29a37488ffb2dd9afc422dbabd514cf948138d78c8dc8c182ecc3d12478fccce311ac7a277b8183eec89aa559b4efde84df9b27072a32568720e02d57ba840cf29822246497eb53220a7e7a77aecc491699c76b1c62479fdad81c8a871f54f8d810b1b0589743864b043b52a825aaf5d01a04757c1de4912839455fc8aa129dc6883f073e925e596eb959bf22c185c826a26f977429b64369b666b2f523d62ccfd7debc2c7ce568b61d42434528508bec0b59edad44c036e23188bb418b9ef3f75281ec64188b8cda8961ecfbd81fd633403761551abaf80bdc9af310dd5f9ac4495136e323029ad26559b91fbfa0b30b19053f7bfba64182295eb62eacfdbe36caea3995773965d7661098e9194010eeaccceff5fc9f38de8ffa14d5ea819cbe21f6b610347f27e412c463c023b08de4a3ac81878b3b1b34293587b08a2caa7998ad6d73b80db48bf49982d46bd373099450e8b0379f016ae8abbf8af40758b3d0aa99fff58555da68c19d7d654ba69dc52bbfb123c8a5970aa66aa9490588095ada24f245e7c7eb17ac1b198e2a128a8febb90a4ce51fd5ae4434c1f013a9d1052d53d0363381b90e2416cbdcefec977f2152d84792f7c9a5f5ff1c57a1e0f6b3abf94d46a088f589b731846eb6aaa920b75baed110176ffc534d584d8573b8153bb7042c36d5318bb3eaeec4b1bcc09617044960ea6310424e0fb8d8f1a70ccbd558fe47c8fa45551fb2a460005257ad5007b631a8ddfa546f6467a3f5a9f0873f3c0761c887f4919c4e3dfb8ef7089111a35807b1afd8273b51c73e5b261ddcbd9ba8ff33fbb2b1bd1c2608a90a084930b0d81086140235ef97d5a33dcab58bef3a4fdaf9bd9d56e49ab14b4126dc667e7c80be71f21ded9557a48785e0af1fb784d8f7dc0974f57c459cae537b146aaca8fd75a2eebbf6d74955b8dcab77738d0340dd8d43af63f20f7df143f6b5d02f208e7354cc6ad083bf608961a4aafd32e95f48ae1e6412dc78ef1ab0aad513af6ce1e44f26eb8a368a8530cc3ce2bd2506a5b54da85ee219b200b0a776a4825c9d18c7a81bd9dcc7db3b977b50b9f7de612e12f468e74a85affaeaa8917aad7cb0e3bf606aaa9cccae793e0b4e879ee858a6e7894dad5b753ea9a9a1d737753fc0380e1ec46b7c2f7ea63c0ae5bb7d8c98fa702e29253349e8741030277052cd103789ab71214ce53242c1c91ceea85b8bcb869d628a9e12724298614aa40cb8f87e688190836cd15631d547390d3eb1746efbfb01b27ee5f3c44944b3192dacb448a397f1864a4d0ca9e71888d4dd438cf5d736f08bbbb80662fe3cbc65694ad16fe60ff835146b4ab3bd6afff6e254b9e01f84deab5d0f63444341ca7a55abc2dd7416fceb9c95d94fb1b6fbcdc4cda4185a612f1cd23d578f96f96323fa18eca3ca178555b85b3af21505167d0decc4c0e5716615250f37520220ee02b6c3d1a13b5f293c5a38a23b2c4689ccd532f80704918d5a37f72b6162f63eceb114172e8504eebd8778efcb232d1f2bfcb837af59d933c018d13e89788a17c8d850baee9fd9de2ee08e7fd63e14fba363567e1ab54a65f2396750a331b76ac2f6fe7be4b662fce84166668fa3c6f4ab8dc25dd80b4aeb26c44425056dd796a18eed5b5349c593999f2dd7b5d7685ae1f0511b6f9adcbe8c2470f86e6e2efa7f2cfcfb30df1486a4ac35ea22e6f7c83cf20b3a2cbed15e5c07e8878e71cd2803ac2a2412d8dfce25f797e852439ba1ed6149e360bdaaabbde5badb72e1f0d2416b76a7130329f14f6f727582bddd295db0b432277170621a319018c21904f774574e8430baa717470f3e4a4f76a3b0cf02d067058d3467ab08a3299b94ff3eda2c42adb8ca75cd017c4649f9a2edebed9d8d9240296acbf07db013de4fe65b3f264b4ac4db9df865716b1492b5a314945459d1d3b15d79b79fccca47d502eaf0d16583b3ec2506e5a17356c573a799a54787e8e5a11057c60aead29db45deb97a3d42f50f75df6ca74fc3095a0955f0e67686cc9c5ce3f674df557f12a41c197b1b066e6487300ba59b82135673bc5261c0c77f08107129b8f27d2788441a5d6c8be653e61ebb96a22e1aed2eb7a44bba9e1ae93129c9ef06db9979bac0a28675898163d6cddb46bab28ff0c84acd36eef1cfc694cf0fcdc5b5a0fd4e565b490f40a58ed71ec26c3d580f9ec8799909c6a1bff0b273a8abe323a92baae00bd25a46438557152a5cdff96c9b3f10b668e77297cbc6204cfe37f2a582546e44da249dc543a8fe85cdd05fe78a66472c1c1a53045b58576c18571960015caf603fbd3f14607d540012e2afb586190c10c1ce9e117fbf54683ebe2f47455e2bfd69dee1e92db7e4ed7a677100306e0574e8c1c8d1d04359b638009f131e55c0471e8c736a1d4fd4753c2fbb7e125db8e2963e0020771f9da8d397c104eb9379fa7973eeae170a7b8e7c55fd66d954f397b0803a4ef428b120d31c40bf46e1f687c691e4075b61fbbcfec3809d9172062e6de9a10843fc5ade0be96a4fd18c410b7c253456c67e0c8ab04620833d49a359afdc70d39dd65f7f10d71a159429d0ab4049c126020a2dc7d41adc0d1b6b46204d86854ba886d51d9394c5a045de9585d33325c6a4960eb2418e11b23fb3e7a457e261580c1163bcc03d85fdcc7eeba30162218da45c7342d6a5a03a9c7ec8126bf840a2e050c7b060b0d8760bda26840e2774ddd6366f4d5900c96f1a46c65809bb0835021693ae9bbb4c83ae6c628fdf443672caae3b2828ee6ccfd439cf84155610f95771ea3d6ec00a1a339ff74fc0e4c163c49a0b1b78f8bef0f82ebcd9ed8769ffac463fe896923809936906810c6fc0bd93479b75934692fa8029e561cae0778f14b6694cde7b7ebc6d931b178f0a2342d6184c046d935c44fe639532d879e0f3c4dc86fd70a2cc9a03e91078a1213d8ba9dceeadce6132fe7132d886fbdb45db4238fb7c70abc21d8c10c2236551632bdcc34d8d7eca416c273664f3bb0150c883c407ab8e84686ed552100c0fb00cac01509134005c5a279f432a9d2b08666db0115feb621e0717f65655b5781159d3be07a836295ee7e64e4c0a36947e0be6cf969000ebb17fd7da384c812ee688d5cc5697c78c882af390998b4fd5d4c20699794da416c4bbc0e439807707ac8a05d1484c90bf3500a96621f37ee734e9d13b43f25fefa66cfbff39efaa8d7690d0c3d39bd1390ee0aafa5c009f5c42947ffc19aa7f519440bd67c3efb953d05b6727f4fb0b6653395a3e5de780142360c418ffcdd4bc11a6d01ad558bc6062f71b20a4dbab573e13eb4326e3f79783a7ba4fd8215d4eef6f9c4bbbfa7d8db474d13c5f0940cf3cdcc77a59c8c9dd1872de3dd43d28165143954d9a34bb788e31e35ee2a675abeae53cc3038998cef1cb209221bde441e95799b3eb57105646317bd193bb12c7e08e9ba2069a62dc071d5c3043b2e2c58baa931973d03f668ca5bef231df8ac3d017a5108c74749bd80d2e89f58ad0e5c66e69754e6ee4d4b6e31aa4bddc8090edbc6ca79bcb77dd8cf7dd9665f1dc2452a8eacfd9b6b523d57b4614375ddc537e05d72fd324a6f2a1cc913b4eb366ce8e8a165f2190fef8d3facc4aeafa58e4ec17713be0132b3cc34e31bbe90e5edb7443ad5f531a1ea280b30c6f779dd59a8176da9c198326267c7f64b44f775227187aea195f7a0e08d69679ffb1e62e57758d966b962e6526ef1dc7923c25495ec414cac22d628c6acb7b18d4904ba78f12a8055ba56ec92800f9618acfb8fc5dbe059b6dd8bb60c24fed5767b3ffbeb70ac98bd220c619bb8e1b756f200c3861e28bb3cb523c0315c9819578b7af736359a71d9721052a85b87fdd5a7914901214c3374eab2778639f5689c778117302da939df7c7a24eeac7523c907177a6aca4b4fb9d3d75c84fe0ca508c267aa20ed70abb53b5635336a5b1d4613872b31af67f5aa4740deb0c74630814086813953083f441a397f313a1a5f5ef31242650f9ccbec9d58e8c9226c6c5c113f982dc4b355bdcf02ef3cf6ff68220d14693348615218776b06c31d8b18087b0d4b78875cd4f4e9f2bd20fd1aebf8f54a225d3154e01c731690653032446ca8b65a3ab25d054cc7b12034445fd4bb9d1fb107041cbad3e6f8ab2eb62e64c242a34150dfefcb96fb146a796a8dad3675b1e0f357a9b40311b4ba903f3b16c91f8ba92ce14bc37dd42f6f58d4c697ba2891fa0733d2b5445ce88817304fc02a87a9e60b3671006a2c56878b6386f09f15785687f735df694c01dfb6793e535dc4708e4f0f93a287073636122c0f6b8cb54d6f4834fc035f13c85aef3ea4d702a6e8586c949b7b497945f1b396eb347728228e30c23eaeec41d00a74ca2d81d84991fb28e28ca27cdb3e764d1c4e45f9939afc61327257b6b9a0b1c6ec4b31fa5e41c1179c94da90986ee8c949bd4ac9b7b47291004a292f8450ac39dd306092f86ee78250d266b05421983657c77729db8b347e93d5ad4dc807e53a885536b45e88cd7c2916c568d599d5e33709547db27e0051fd3e91bbb4260f664e2b05e2e21f65806fdbb8effabe1aa1dbca1fe11fc78479ac97b8931e7c692bc9b3328072279cb1120c300420871c6ba2b374552af4d90997d3d2ea066b324543d4ba2362a3023903643e54ec12b692ad81e7b7cd92b1440a9e0f1ccf9dc1af6f065a9fd13c831a7b98e26304b46ca2a65f7b6cb718934a08eb7912b78e6976f8b24cc6839cac3d998930f0588088c1dfffaa25453f40873fdf3306476c4e30daf2bcfa3575e7f8d07744c6b144e1540f0526b79a35adcd64c298d99c40f188e4c0bbc358ef8fa51772ae5dc075db28bfd557d8a341fe3c469c785fecd41080048696458d1deb7d06e876d0c87c391f972be2770652605e4d28725e97eb63ebe32c8b39c0cc762b4cd1f802b4b325998c5d84f89c6d360eab108fab95d538d6dcbc215834f2d139f1d87dae8e8d935741543632936f01743c183edd1716e913b7d6fe1cd6a6b255c507f63af8fcab4425b6efb4b57ec9b600244ac909bc6c76efeeacfcbd289a3848f7bf58311208422d4ac119cc1b819db75e50ab9c0b503c04e1da4fa726716ab20c93457c80d8c6b41208f8e1e4f7149f6f5a7ddd1067c26b4f88bd10d9782e08eb812591e75387c526adb0b1922b1b1e809b3d0b7c99438e22f262672b9f06f0a684d8ff98736bc646443d961df57a525e5beea25a7c0bbac890b6618e7d74fae7e7d35e018ec84b288f39fcaabeaf8db44ee0126172ba9b6a846026f951de3de010143e37dfcf8c4b275217c66e6060e52ff338418b45871d6fa412f2b683ab9444bcb4a91cf65dea30ba654e64254732cfe784e0966cfe0316b34975c059624adddb53268521bf97c83e6900d4a85cf846c1be91f9e557d85bbe807f7339cc10a1c736aeeeaa2060efe795c93c6f2a9f602261027dadf35e3b6160e2c610fc4a5281c4de5dd9f900bc97c62ea97c05c65ad492cdf73f4971b11f142c4cbc88c60a5212ad7c188f6fe681c531fd2a8160a14519952d7fd2f4b6033771722e1fc62b01a75a368de22b409e7e9cca0314ef26d3aa7ba9059eeff01c2eed9b7860b072a030c546d2c52800862383598f73d509b291ce62b1586e2a2c0e4951526782592f614014f2d4824ebddbe551757c50a492cdeccf012cb0ebdfb9eb1ff86c02a7a18a5b6b6064399531c6e6f775bdeacf6315d681ec3797d43638478bd693b814e2b046d7bb3a9578e635652a93bfe83a08870a0ee8476b40c9433eb184965fd8995d14ba2f0c586de5ab8e3050f77dc651533c52e6f9abbe1dad9ba900c5a1dd4d25f7cb8c8b6c4a674e4a6484f11f0c1d6b304c8097203e8f4376b3e36e6ae7c038980d5f5a3c69e81ae0eece4ce5e30a6f604a224ee9ace68727325f7c7e74d5aef4d5bcd52844fcc6cda7700a755ba5bcf4131f19b95d51aeb51b629f2116cf8b8577ea1a5066479dcbd8cd44e62556ef09d1784f1136b1ab78adfed9e833e442fd9c109c28994f3042e8f30b82078c74780f77b7ad75f2320b7676e9590a6619c5e0110c635890756fb27020da5f8aba7ed1135c7ccff7fbef63dc36b89db4b849f5441d7910187a38a61e6f15f413cdda06530f5237642ca309d5034c71f6e7250b463afbd8390e91dc9fc5cdee2e26dcc48e15a1c3de6fa3c758d584aed43df1a18b4c144b7ce70d91906fe37b2f7d7a4a159b4034f9c746206011d99b3c50a636ae0ff9864eb8630347f875efd57c9653b63152a2b093b88e20b1ac6011c87aac6d5bffcfb1f238270232496e6a08ebcc0b7519a083b37c49eec4812ae769df29295b8fed30d4bbe441ff46b67adac90e358ca718a5c83902b4b26a5d79a220cbe304152a378f877cc7bf7768ce10f39dcd990802c4a473f574deef7cb2da8a9691733cc7629d09aaba359c73f2143d8811f5030a1a5ec755391544c848be93eabf5965a1d3be579a0d2328c9710c144845da29cae1208f8d411ce5cffc2709c219a26112c9bc148d123f6820f6d8b09de2aa0b932730e4948a68ca856a8f8eb091f07632dd343a4d175fcc7d83b7e353b91030f1bf26b2c076ea2932144dc49d0a2001864554a22af62ce1703f46486e914f69f6fd67e80df3adc4faf2369ad85d8c3cea84a83155a53e5d80fdbaa91f1f21d60b84e23e978689ba74f98f1d7d506f6cd847f6a74cd79dc318dd2affab1c7fc74ed3d956913eb99b2317e0c54094b6de67560033b63424718b4ea73a7c45d6177885b174059a8e53be7387811bb99ae434ed9a13a1c4f7f6b9e03260fa0bd31c01f8ece29e338e401efcb3a8edbfb3ee3c91edc9bb9cf7b2d5142a237ce2ae6d6f5d92c560f100c964685cb2609798b8a17da58e67e4739781baad69e6d62775faf3b96f30c54d08ce9354b9ce84cfe95ff715078a1c5a7dfacea86cae41affef292c9a84f8c4bda173edb6bc0ef71d3251824da38789df07e94d601a38abe16128004208d30a04f53852532abb7f709d979686e67bc7e3a04434fc7eb3dc576c1a02edafee3a8e6e988e03167c7dc37771876602530e5760c605355a393c98ab50887742eb74629d7f36be0d86d6d8f40d3ff8ce01ce4c5cf1983711958537626e5c20081cb6801754428bcee821f9b6b5ad0fc22f6da6f199eb9c5a9345889d14dfcf22353262262a5d6e2403689458e1308bae452e8beb9624a5cc157b9d0a60e5e86f1b9f86c606564181bb5e3c613c3b3d06d2868decb6d145026f3f7e75873b236463783497ee6637bf7ac2e19d861305081d214f3dc41a7568ab1300d8120c6ddf9b2ab623ee9e2329367942c74f89334a8a4f78540e570c50b1552be498c3d15873fcae6107fd06a52c40421c1dbb0f1c0ba48ed5b3c9a7a74466d4425dbd1cb784dd4b72939caafcbc8ad00b5695cc13cf2d55683379a743556008ef2eb6d70984b212f982858f30c6032ba2eb7668d7dbd102f4043d13dbccf11e9d726cf3f036c1272fcc662870145ef4bb0296f279654cbb6cd2ecb4603656f7a184d67d127ac48df359a85245ee19b7fd72934d1109f4c0c3b8cc99f7a297b6c00e63fe5b4bcc07fec6a3ea82edbfc559ac2ce55b394c39e9b40d00aaffc9bbd1e44d422267443a0c183848fbc1161a77b8b493f79e56574d7703f3ec3819be2e4f501592375319c2e812d5a3351051c6c3cb4174e9b2513a33da23408b7b58171a671d76bff9138f6b9de5bc605ac7c1b7feeb274fb77069ae6c6d6a118dd33cad41079a800626143c76da5c5a87d1e7d2abaf35bbd7fbb8bd615fd162be40306eebbded869dc5b833208bffe098db1eb99af52f2123d5bb92eeab90d4063691f653dbfeb60ba1450314ee6c4f0d1114d6ddefef2974082d1ae0a8e33ddfabe0bae1589671df97045d04ce991530e5608154f78e3cdf42fbdc7bc482b49aee557fce108b03d9538d77576399ee24905c777774ec0ca72ce7671145ddea0709758346bb1d55fc724c40541bbd11c67f381e077bcfe65db3cf6a41c38797dc9419b562657260c7a7b7d8b7f38548703d9af04bcfcd4524c33d8860715ab50be7cfa2e3d6b3e7f270b7a2fcd5146852d69f6d60196dc143d99e525931b53f16ae5e89c79353ca14bb94b866cba781001e24a21d09025aaec7e36bcfddcdc8b920f6fed6ca332bc4c8947162850c69690ac4c5159ba30915f2824618c12edeb59856ddd090c81dc136f3a58b7496aa87511fea5e7feafb35db013cd60f0120902c5e00d58d57b28ca525441cbc50a81df1127f4d83e152cc566e35b800fd8ab4c33d23da833ab0645d36d6299363b634d95c3723191676c54bd37d9a69e0762a96cfa0f746e2c3d98060610e6f45a9fab1b357d4b1b573ed9213254813db333513cdafe058b44e000fb0c59144fc747c8b1d2c7db459e90b2a2db3205e4bd2be73bff78d4802d9c837db031ef2befbd6f93939078870a78a904a13763cb87f5f0e3275fec5bfc056a938a2eca529370c0fbdb400798e20012df7b1f0add19f05b721fbe95c57d99c5093e4c870d7e39615198418c234a275dfe4f557256ebe4f0121d0088cd5eca1c6f878e9307d76b2eb79363571633f2f577c2439065c1739e18ce938c60d50f1edb1a83eb9798b88b8192d6caf3a3e2f96dd7c4787f16be893920e1986c1b05c13b7481bb38e8c18dc3caa2ca3ad0a97a2fc95702b81f9c5b8478c3c4b508ce31194aa8981069b1218c1ebe02570025283737602564f6b1a9cb9f8a9d3d2a49c320bd3eafcfd631f001e1e3cd6c8e456a97b376689a9d3a465656997497e9a5e53905b0ea2b6cec131fa03e02dd26c66dc4b0208b0fc572b6d31686615d76175375ca5aab04a489cb79041b6acb24ef091becb802b0b8a8d98b66c15dd7812994b19a1c456432abb8154034c9e48ee3b7abd7c981645f1aaee744de9d1c6510b36f6cd9baffb2653927808cf2c3f7aaebf8bfba3ff97be5a68a84b6788f7e620773aebcfc09e6250f9ee32f172053c6d663a39d449d7e942142babf2202cc692121c66dc8a8b1101862c6f135fa75f75f7edd50d0a5b8eda201709c066a6cc2dda14e36b3444c50e3c7f07698133db0721c1f71a3fe988ecc8b8affc009538493d3e4269c5e7cb4671f3486201bc938b43124a8e080b6c88c6ffdc466ddc38f87c34db53f2a0d64be81833c332097a2377c8d6c0d078a1bb10cd2e9feb42b36de3d4c66f8d2d45449f9a37a1a51952f697fef3ae9e1971a5face45681f789424c18dba1482e8f18867d05f21fc3385ecdfb642e310b4a149a38018c5e7bc97c26a3dbe98e4ee6084a1d6809836d8aa4234ab82633891c4d9f2dcc109d62a9c02105ae4c1a489ba31029b6c4ea50b4e84ab6cee9e3279ca4f9196f29b38b2d5a6f9b436a461ba8d16f239fe1644051c3fa903ca46d786134b3d8c88480b84aafa72467927e6cd2b5c7517c1187ddee8a014a157c6ec7d76b7ecc78e6586d34f9d06fbad6e5e96ffd3e1e764c206dd5548f2f42c85324645640f23cc5127ccd0b20383f6493446f953c0a2ad9063838a0f1c20b3a70fe4f1525c7ab30f940a51d9e91059c3fe4088f294ee1c156215352f1507d791b639e97379a68286d0b7a6a1d64154474c20bcd93c9ab8355ac2df5ff1f0f514d89fcabc6e28b1fbfd28438e1cd04b93d0f3226e4d10826f99c4df1b8b3c855aa7391f08601b2d133d47f54b77c5b5805ed47614dd35955e4e54824f14b88b85cc0e6887fa1e8ce876f0886b4f3e1a536738533c5839aaa5ab5d1b4a2757a15f5f04fceb53375b9b17519adc00f37a46e2d457dc36b3ebad7397760a40413cbab9e7db25a86767482b0208c94a1a58f78ae5beb51f52b82cc12e73d5964427ab87ae2b6e4693c9f27f19ccf583395dc514b796a002d43771f57ce11a9ed09c0a25f6b703eca33f9942978064bc646c54c3a3e3a4428a00e241147e7bec6e9ec03067e072e71ab8157bd9011238bf670315833043bbb4a76bc075fa56a970523f329bfc0084fec4e64c17aba804cf868005db81fd7ca561c2a672ed66610b3fbfcd8fb65dbd6d7f1fb17449b6fb8c12e1f7682954420196f15d9b54830e2e87d0f16484e00d48c278e5e668d18403ac670bec33c206e39f57ee3458e73418e526a0b0e4d64f09de147b5055d36d662985783e140d57f1f9423a6ae10d173bd27f6dbe2af812570d4c35e0216e11c546735be56c0047aa94611a7f5111d54f59e6f91f80de4cfae75b2958857a752e780e417dec5256e11abea89f72fae3e6e71dd46951dd436febd98a6ceb461f57f8078cb300b785b018e74e79b482518a0ff6c8fad9640feaf706e66b9d9953f775c01fa8a896a7b2706ce8a11460ca50295afc93a9d186cf66405e08cdd6c8ce6e7a2ae9c79974655be3b5daeb0d8e568ad03ed6fceeff208fe35ad9469880b39176db53084f93a8a076905fada92ed390a5c10b5923bd751483d4b7e2d4b7309d2ead261ad1f5fdbc7f33e4e91934660bec4eef3cbae35b932951ee6c7449516bd99982f8a527552467c0ef0529ec73db7d0c6133df6c80d24616b1d39819c97991c67efc9f9d31377f1250b0e378b2baf4325258243091dbae85f4e177b748bcf18ee0df5586a6ec49a85c94d4be9570fe24be51b82290a4ed0065d7ab69ffe88c18d4b348db3ab969d07eb6d42c29e167afe2a1fbead422436bc3dfbb90e360ad438561ce6ddd7aa2fce174246259503fe3762bb9c4276ca2810b48942ff2e5c2910de44fb76bfee8ff82c937419d1fcab059b65a22666ac839a842d9c7a5d3c38d326ecc8476bcaabdcbd4d73ed0729ab23b13c2c11eae43f8bbb6b77c7d45117335734a609d7f64017c48f018347432005b7babd187b37adaa2582ebc76d4fd1edcaa430c989205645174e64054a48ffe928cd55a8ce5b36bb25f8f0d033c1b39bc4ea3d0e87107c25ecca9e4ca02d5fbe9fd4bf11dad8a8aeb9b8e0b6b3c8930fd27a89d873c21c92cd33270fdc9743e4cb27935813d6ffa37717387eb2af2438e4eed6a6622a9693e97ffb7b27ddf229fe4076042bdf16c8446024ef4c5faafb7aadef54002c8a82f599842424f38c0e529add53c7113f7deecfde2eb0ac6bcd626168b19b3fb1f1498f432f8b7e98fc8e5ff47030df50737bd37e1eea1455ab21ea736a40fb8e98f97e263807ccf4e858a7eef1293c9cd1e57b110b7ac1a844e13aa9007b9e029d59922adb9b536fe3413ed0b865a1f6b61cb351b3ad898aa1b04874ec6b27fd80cc3c848160681e0534c5b4d0466944c98adb32184be3587293552c78a114a670dbed218b144af8c2f12248d11b999817e7345d918a35e7376a974b70301bb1838f14cdb12ffe4b8fe6ee420aeae6a41c9b409796089b6d0e249464f7b6c5d9451f5f4d4788b8e34d730fd4bbe7aadf073960bc6df63207b059605a33c4b044759ecc5066ba4039686817723e26b6fd11784f80671b7f2cf2751f0555007632f88efe46cc4088695572f35d59154e222080c7111620e366d482ea50e6af5f0f88e72653683d8184616784398b60b447fe939a545923fc0e8dd13dc417af822398b39cde7c42b1a33ef617313907a77e41e8123e9be41694a9fd58e6b440b82aca23b1484232a034a1ee0ddcba326009f0e256e69e432ed4aaa1dbefe2c33ed66fa08bd17f336f1ad3b185f0c3e91746aa05c8dfa29cc792876eae2b666e600383a1add78149f01c75464e8ef59f37c3a62a3b2df2c443d999c7c7178cd56a239ef45d960c98597a9eae2a19dd7b68467c8eb563f9924f047cb7f9369b3dbc28c2d9c4c16147d5c83e48de3980a2e1cbcec0e9bad33c5b222c07442e0b6bf50b62c0d1204e26d83e5d3a2ee4b341ea1fa53446f67e84d02a3f338a266ccb4882c3a0386a9720ad62a15e620033458598a2996bb498d0d565f823f2521dac2e8219a50c9d77517930ffa0411e66f5207f9b55fcb8f294413afc8260c88e33ba1c01fc42bc0c69e0806226c795fcf44ae0f7894cfda2d4fbf8de54c6108f75edc2c68fc374bc05f522a164885d75937d413890710972c1a4ce91a09394890e04aae33ea365a44725b74b6eaa34684f0363e66f292a2004d6ffa00c77f3f6239e108c0616d0e44e8ae832507160eb889bee23a38ddfeaf8b5a4068204a630440e6cbf5180ffcedaa49bc01dae362c0e2d066599beebb976ad1db3fdda75f88a53a6d255efe011fae32811181dc993458439ff1c76e33446579e05f6e2b5b298584b5b314cf0629adda7fc8425db6f96f05f9f568cedd18b09b496e28df60999aa60cc180de9e5fa77b3265fca21537207d5567cc2982099f49bd6e2038be4be158f0ba2f252a76a9e4012ddda583cc7c36d00d4b61a0cdf50871ffd6d2d56a4bc75b28d39587ce1313101f04eef46276c7817d79ee45ddddbec2fb921dcba467f093973fcde44117d6f58cdc7278c497dba39d4cf8624b489428592e3c875d9061b685398f499e93789f30cd0ed3781613729fd4c707b70d9603b94341e2a95a58b938ec4e9c3dd3fb676b355e1e7364bb009ac4e8faeec9d6a58ff0a75c586d759dd8e08c72abc86ef88f70934e35ae6a92cdf99624fcb3b0e3799dbf57d4c8de8ffa723340cef066f271be27158f5aa0e10ebb3a7e0b2c2f409197728915184ea27f8b2988e5f11357a48874f914a0931dcb79423a51f3a5140ace8e0fa76728205ec41ab1e9ef8454b7cb937cfa53b4489c9976231eee18556b5caa6f787b23cb6d50b38a9a16c13857211314128f49a18e1b86037d03e0d9c316866ad3f3dc57858f9da4c8312d4e9226150bfa72323ad4a9342cbfdfb83942ebd3a54e68e2362a75bc5cb71cd6de81f1af6cded0d40e25f0ffcacb78a5bcc7b65b25cfc66ed9a0a6e4458baafb63f0219b61dfa367044aceb6798fe41e82273208c1c44e1be16a824b2fa73495caf3a8b668f0107b7db6239b3deefcb5b1f54da0e77f724f5bc03828e2a5987bcd857d93df269dc0f3bec9ca9e4f08cf1f90da6f2b7e782edd4ee8d148809c09a9f17ccb4c25e73c3fd22a67010b619abf79fa8bba62f5227ddbd3ba05c4d4aa2b1250b7d2a586a5fab581d3f50b804d803dd397c48dc2e85b79fcb0eedd3b30d7e0a48eff6ae1c06585b751dc9f1b416529d410afb7ad1af539ef7cb19bcc9400c01b7fef9eeba8e3fff9433f563a436aef5ee4f412d6846b27dcdca27ed454639433e532d19dad301ebbe42b1a4dd132f1bff155094cc69f0025137147540d69a74eb182cdeeabfdf9ca4f41073d7b451b05085d1656fbd7b636c044dc10367ea36e92c0f2c2d66c826898b6c6f6440a821ad272a68bdc03799b7ae251cfa92d710d9215fcef5bf5efc483feb26ae9f749cf6021af081083ac275545044d6fcf9e469e792e908948001445e1ec1fbbabec8f2befd4355f17c01f7047943d3be5d213c530c3d3cac0104e4671074f1bb3f8fe777fb993713f8f47c7a85d0637680ef6a9c1f7f003795914517403325c1dd90f22f4956e5369d583c8e52ceec9f477e4110f8a48a5cb8c9be5e870e77fef15ee4ef8ab6596a18a678d494e2834f34e64a5874dc92459836fa10cb0125195d92bc556bda382212439d680502083250ead68d80818ed45a8ca97fdba845574e110cd3bb4959a7cbba04f3dc8040639670f6cb9951509e23d41213032bbf6f6b8b49b9e763e956c6f7c337b594742ff4e2b615ee020037057c162ca37e409c8226318fcdd24217733d5de562026390df601d4aa5a15130955d66f7cab8a9ab92d5dbca60a9c875b03a5bf8ecd94f2c9e38abb4c6b482df93846e60a62e0d21249001d5c1b631033c2913e44870ce6917e9c1b5fe92522a60f0a5e962e7b610a62e5e5788c0dd8843a38c3edb91e4c6eb35eefe10e8f011b7e3f6ac766551a6181ba44e743ea5f8fb05d2512e40014c9b3d0423dd84bd076ad343c38590022c2e8d3ea1799c51041a045d90b9a2f9dcc30745d2abb9d3695076c6c425ed222eb2135acbca8e56f77126deec7e4684dd149da69a15b920d4e3d833cb7c511a422cc28350b045057f16f960e663fea13bc601560429f431685eef55e3e4fa62b299609594034d10ae4e1eb1afd35776719774ca8e9159340e4218bbd08277a65c947607c1ff951b215183f71a5f3451fda9dcef2f7bdf351379f85c9cf10e5b1baddcb5670df963594f3dba3fb7e9cce9a4ae9b846c2b6d7743dd7a730e3d8ba3ddd4dd7c7f500e004cce5820c592a07127bfe3a3a878bca407a15e89e576e225c4f7a64682917c14062eaf3d0ecc3a6adb07700d72eedf3bae3d487a970d87147df938dd6b62dc72b0d114a42cdd186fc9309144c373a7a73a9a640a270ce8f7baf51e8d67927383bfc591800388399824436c8df0ca8c2548bd06422617e59e4655632969b190b65a1ab5d725523efb3782390513493b7a54c14010d257ada180b3b141d4b82702d92fd6140c9adebabf84af92176d33999f8aeffebed70e958912b38f7896d956795ae0fb4a7c2d48b2f5a489d6a775c4ff7d0d72422fbb5ad5e5e77039c53357b073794cb0a888b0132eaf8ee1854c10913778b902ab8368ced7a8bcd364e3fb17de35e6fc97bfd47e8ae28c7a881bde57cd31cc5a596bdc0bc3c7d8b7ce8539547ca74899123b7f1eb261dc6c9ec2e0a738c4e543cefebd9a9804726d80ec3bb066804c3fa61225a1bc489b8e8a346794a1e4f55f6f40db71770bec2ff97b89a33895e8e2430cf45b932761504cdb635b47d5d1ff8d658307f60f212669c151d71e76bea0cf85b87defb4b7925e5c387585f4aa60f35862ef69bb9b897d0f4ddeff181c6e83a2312959c332054cb6a3aac780966d13760018ce2e2fd7d04c302228c127c7661d80659210cc54bab0b28c4e34d843547731192a84937d349e825fad3853b95301432080ee909d27f12d468a930d4d151fb1ccaf22eeb5a4dd09e3bcc93a69f8a71c1d9af1be5f11e7f9c7c11f9ad3798b7f6fb911f95b1bc442841cc8895c9809cf6796369522e5204259284f822553db9b89fd1cec5858a39c507ff8fe8478965b793e1c1a4baca946cac1b163b83e697ef9863ecc1c486b2bae36e1ba4f5e380b0e4d00fc31851ce36f2fca759ec64d136fbc93c454697f02ea1484dc8075024f0483b5ab435565d9263c25a97e07c0e193d067d606e9e5b93a076fd9b2fa35a475be0c8dcdd9dacac07882789a41affed129df543a0e227ea085978746c708d68f44c88693904041c2b8e9d78f379aae260a9e7948eb47140c70127d0825dac2fe3a586cd7cc49aef939e93f4fdc4490a393387ec73c953c388803d637666b58e15f64ac035b98215e08e140238061e8086809b79cb7c285678d8dc5ec4950ca4db932f447af7ea419ffe1d5f6dafe70aceffa99b40068b53a9e21fa3016e2cbd935834d32c40a1d4eeeaf837fc97c6a0382298660fda44382d77499dbbf59e77e9408996734488af4895bdfb71513d598f124f44000a356e6aa359fde5833b987ebd3c5b456416d915d299b812a2ea780a4bb9138de1ed1948110d9efcf76643c7441135cfb65aec79507e26520bb6f1b0631ea1c09ca6f156f2ca244568f3cd387fc1eb7278ea8e3a166ee487c0569bb38fea8ed33e57801be89db8b89284ec83637dca78302c0255fac4b7bc7b6ac07a1f3a23de765669f1b6abb678fd9c88ec2622dc978a5ccb4400cef37cbbdc33a82f62e6487df8f035143805ff866b29881da89059239ad58bc719977de0a14db90de83c02ce1be1754bac52be9774b0d3b6f198f94f7703e29dba354d5dd3199a4ca2e529c519e1a416b2f8939b565e51b21513b4cda301380df7289b81d4e88450f3146c7a2412745063a1b69a62d604e62b625148898fa91af65a8d4d9","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
