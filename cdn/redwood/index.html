<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b8bd424a3f719b55952f0fabf33aa7bef8cee27a187e92301ea08f1e5ef3a47156d3e16b4614606fbdfe58d7bb441e37f9b19fa79bdad1b2fc5a772a0d3ffbfc53500fe79f1a045ef75a9b75c351afb20b73c9f3467ed9fb7c736a32e05c5a1558b04ccb771c2742c3f96fadb9a44a72b31a9a8803c5d99585eab3abf82707a8cdc70069bb4abc561de84fcba20c1cfd4db84f7e6274718e06820ef4dfb78c593c98c74932d5b9f019a8fd6604cea299ab582ee70c410045f30be78eb73ba75ec3aa294ff44ad5fdd9f12a115fefa02410cb8198fca636833315e23a25ea4b63dda0c4e3051d9c0fe8e1f63d1e8848a58d5462859982e2de4ee0c1f913d7f7289d52f3371d7f9a1cf272c422329132d6dfd9902cd2d0878db3dbd0a38df55392f45ad641dae6cefe2989fbb64be6a596851b1f7964dd6dbba2476501a7f07b2070a72b0dabc93439e5d4bf27843a67fe6989cf8bcdf36c359975c1e86689d36e5868297ab47aedd42e7a18253f3fb8485b22225ba3fe07276fd136fe1244408094d532939b3fd9a10c22d7741502212c116e65449c42318d29020aa4c378fb774dc04e7219ea578e159be6e6f610bf951665041c9a6d0d90500f00650299132e2d9e51f504c939e6ef82a8e37eca48bf33b98845c5e48cb60fbb29c35443bdd30837a36b3c81f16127ae2a802d31f7e72565fe028a178a633c59dec306bb3e7565f173eeffb953c05bc90bfcded49630d78399b75163a764af9970bbaf29ca2470318bb6e66d743226258817c43a91a67e3b410840b09e484e5c7de8e45d684e016c326d0ceb73e0735ff0f8c1230d1a46fdd8ffb29994a3bfcbcabbe9f6ca82684da6f7f4bd13057d44880ccafb529cc95890df6b05b7f17bd1fa435fa37477ed1a85c59204dda5358f4686728ec98014ebbb6fff9d7293f477022fe9887aa94aaa39f8db07b8b519c63a4b1771d4605ee136ad3de87dc2ce30929051feadba64737fe2fb331d0a75c7afb0da15605320ada5b4d5d0d1b9694a85e92cff82b05aa0d91df063295e7af44b7345ccab8788b873957286d36934a4f2e8e6e4e3258142f82ca5006a03b211e51d9823ed08321934a1f653cadfb15797ca404b2be60832ef0dcade392679c4a994f7e46b6417478a905e6655d117b12326ae30f0ec1cbd1915c7f7fb6c691eff1a474d9cd931901ccf98ff9b351a0486f234ea8be301438c2bceaf7d18cb582c9f1a23bb9fe8b6f46887a87ee1c474b7154d5980d63f83f007c3afc180dddd73b79e9d664c9fdf37592dbe24091d0769ccd05de5e917c4e2f8a4337b4b144fc83e66407e0b03a31b5bc0eee3cc58a9568880d61ee1b8dce093dcafb1034f213602c6f30b96ccd44d61604307f1b193cdf092b7d43770807f39bc211e17127dacc30278c34741c8487492ad1c611bb11d283d86fa9782c016cfee71156f4f44b092fc44bc6213ff28db37fed76201447ea4bddf9d3e37a816dc7d878848c65fe8ff076e91a89dfd11c16b6e29533258983b4552b6ecdf52ef5d503a95fa6bd7fd1740e3ff2c0c5d43ae903272c80bee89f851e5634a0ff28a1fa2c36d6814d0d75c8089ecf24096a16869671c3c3f634c2fc4290d5b9d86a55fd5b27f832726de561a378392c3151eebf0a440ed7f3589885b5cab3909120ace17736352e6d7aa49fdd97a092a71eb45f041af7d38a608588e92e27594057d36214bfe8502f69b90dbcb6f99d8924484d5fce27b10f6657722ab0253ffd49f71a7e22f93d184ae90c5044056fe7709ac7824f3a2f518e3136c441f4302320c5d73197fd05c84e3223865612c0633a11ed89949345a8d7e852a601b90f678a8fbd26ec9380de12b33b8cb3bf93726642cedc6745bca043dc1e01a4bca413474e2e586641f21d9d0d3dd0fdffbd35be72776d746e6de10c8bd3eedda42668911c44f540658ec4a1919e8e276b15fbc014025f4ac857bc3ac05694c6a98e7f35e712433cedd04918fa511917777d1c3385bd2ba361a4ed62819dec07b95cb799851a2c21826afe4409c6d6ab9cd0fb4cbff0bfa4264b894f3e533d6a4f20acb8ae4024130cb038288d53161913cf1dbbe9b24d013077bec77d8d1d7444df1a59ea9218d6b06ada5a33769fa5f2ef7b8436c437588be4b941907a0a15b04c9a05625153bb40417cc1cf52308182757b1877ea80856488c6171242a19dd8ee3fc0eebf9f0fc86db568d568b3ef7f5c2fe309175a578fd0535ba7503027769f727af84bfd0f85f03560de0718e494f2b984f2a5ed0701bab7e445bbf3d5bda8bda321e9371028aebd2ad8db26250183058078b32c84557850405de02a3a2c9f3451415d9ec74632fb7bfd21f4bb5f78a6c36ee3e07c3a6a52fe71d76e81e4a94f0aa01b2e512bbe4ead687290367e77419d0a363d995cce5bc0b0bfe86438cf254287b0eb2943890fd556c591c28b40c3a7bbc1bc8ef014206ec90c9f3dc4810bd161d9f59f0fe2e9cc6e263412e33e75031198c1af85c7722b51aa16731d7ea04011a314dd0a892621f0c008ffe291d8be1e4c5cdd181dd291829e05f13d2d236e3b2a1b546a808f5c65bf8b28280309cf5fb5614033b8e69ccb4d76e1c99cc5ce7921fda1ccf69e434b6457fd97d048253afc3a7e852fd8bba833f9b929007b735bca723037771f43bb0701dc174566668a7f036c3f7030d0c5bb96b38c3c465e1e1425c9f850eae988270c8fdeb6319f94ad7dd46ee8b9026ea661b7a3db154f81aaef22a388543650cfc80cbbd6b3dfdd026ecab402bcf3a11adabba451e5bfc6f6b611a23cb670438f7cdc774820c403969e35f64c4d4081d23229b0f9c30a941c80cff1e6bfb3bacbf1f5c04096346f8364fd57b565df0562d23a733e099b242d304b60cd1a1bc8b9a5e4728fd06c0f94330692206f9c2abebdc67a82dafc3ffc02a7db9d11175a531750a6c011a7818bc4fba5bf3330f994ff7b1dca09ec1541ea8246e8593f20f9a1415d7e7a0ea66a16beed064abc58a5ea0d361072736cc651a0ca32c41f768705911a3d7c6bcf6c2282b59a72f360a46aafe7114b8aa67db87884514d8764248f806ae1d52093f8092eab505f94a4a5c9fce2829aa55bcb0adf9d7694bcb6596d5f2a515ba2da85a571185665923af5de96697e80cbf1214b710e48d66dd9adac3b0dcb7c64fd1840484bcc87c0b9f3c29cde3d1804d3dd24d1b2a74ba5412ed0df0bbc518bb413f59dca835b238f445da9eb20dd7b9ae269b97a4aee211fd02c72ff31bf5beac6536429bbc86d0302bb2a5c014f76620304cf3be82ee07a5a01e84ba9748969d688dc843346b081f0f696b9a5d844db0d5e7e00e32bc82047752c4812f2b199e2803874a78e40f0835b8fe12991899147038bbea5fbf2479d2a60baed3e915859012fd1d7a08b2f8a0c38b31a11064b6835cdac37daec44949e06e4acc099938c2fe5b6a376496ed596405a9d55c63f76dca2625a950138b30a4d257627151ccb5d58e3a517191b6ca325eda0b61d4a860cc60fbd24ef441f6c8adbdb2cadb17673268b5fffa36c89a1682f153c9035da927152440d2112ae2c4096dcddf78ff8b711548196404e9ed4590ed5851e09bd38f7dccf47acde049eb8b8dcf207d0642b6c1dc145c4e3e2c3d04c3b7b1e4357fd3b66498e229229dd35dfbe25d0f7335ff955fc48ecfbde0456cc8846a87d56d047096d277c2cd264d85784eb628a5d7682302eafa52fcbf4730a299aaa0141b760ccda06c100035ae6413f9d36432c39007d680f90a5badce8d7571b3a67996152e02e539763a65bb3dfecd44d489191214e4e1d624549275ff4ea3cbfe868be5f086d73cd5946d8b55676d38639abd3ad2b16a920142ade2a2cf85c13538e7c84ecc8eddb2b9b0d0c75e35ecf16b0625325347153bb3323e3712668e7ac31147df1a782472f4ba952998b51f74d3b84a8fed3e57f498d6e7b0b4d36edec9714270c809eb32e977f20327ab7e4c36903ba2d8334b031b8efcac3d93f5c6eb8d532bf9b4021b640adfc0bb93698cd39c5671c1570f8cf6ad6e4005821c772dead9d6fcc53a3dcf80972b28c13cba2251beada3f9e7da494f1e85975c33ef90d6fdf2f96183ebbb04959175cc9f9f09886e9bdc4c8707d0f6ac46351af24e69426216aa39b6eb7e3255809f59f65d4827fba97c0ab3d989da08c0168b0b9e5024117e49a0d89a2b0487fa746a2aa7eaf77aad0ea1f850a1ceb77bab33c69fc5000e10601b1a45175a3ed9be771a1c4b7996af1bbbc9daf5513ab918acdae269c4064c85ece6279f14440521ec9d4b87609f6277bb09bec0c05c9351ad83ff0c4173e2c22333ee101ed69e490029da92ee1297422664e2f27ed730e47f6fd8bd8bddc476c4aa98a3e9ec2c08fd55c080fa169f67ce6d8215e5951981e61f55592515bfb5522f4724ff39fdc34dbd82f53446bfd805393db955c4e3cadb1847e8f00bd0a7b776acdda7cc5eefcfb13e71bbe6dca4486d5fc525929e0550e6eb414f70b0d5591a36c7b839167a5a915d3a948b4a12add642a26a4ab1bf1aeb2da416997b07a39a81ef32648633e1111904b86672d95edbee62f47649896ec89faaaadf863189e061fdc7a31d702a5895182cc9114b982cf47ce2031d4617df990fe9c3ff194da88ed273ecf38dc2844d44ee0538c72ec045ca798a42c57aba797a830bd87c84c2d766ad448237f81542c1af60f73765c9034129de865b6987a11cfa3427129a0eac533bd2398cafe0f63ec6591bd6b0a44829a578ee5e67fdce8bc203b0b82698fc64785264f0865dff6c0f66c8ff53769c88ec79259a8fefee52b172244dc7ec971c55c11628654adcbad52e5f6bc533ebc1f23c9e1ae086cf0d09ef34d372d2bac0f9db45c2ebbc37819d4cff0c560da721e066a967cbe7a9d4830889ec2df403581aeb7a71f039e2f6a0fd619ace61ee0d407daab4d4bc492934a2001d4be7e2a4bacf3dc351f477a631b59c3933ec9c4a3e146f9f8114c4ea4d13c26ebde6dd8a119d92000c7ba6f81b7a2bad8936d391e2e66e57120889c6bf1214f614b274875e928d6806a0b18bdc373cc958eb96867ba2e5ded273cdcff50f13bc48255864227ef62f0a61cad7112b803423b565d24f8ed9294c72e3d0d516bb05564f02619ecfeab22ee614f8dc8b8edf0a71cc7c7b07ca9af8e4b14eb8695c71622820e55e48c8fa8e9d809a25fbe271f88d01a87fbd006caf90156ac576b54186567c97f6a8f00f611e2625c027ff387b1d53f0e3e69f4a7cf35bbbfffa2cd9011b70fd0185c5a41866db765f324b1b0f46f7856a5a200666bc76540b9592d1ebbc71f9baa95745dcdc8fd432769bedb49dad6433de8a0dc55d5032e428fc1c1a567b5d1ec20e3e22946e92b8ce3cc3637879441d18e2d11784f613effbaf953536c428a7e2809c3bce7c01a5e65e44f132e744ce7494ecd258b22779df321015e318c0c92fab3870d201c7009a06615238649ee5a2f2a84291aded5792000e264a1fba6a0a5b9cb841b65154cfc922ea9eb3450d53a01552b73f9ff5260f6006d389a14ee16e2742d6ab16c2d3c62927b98c1447218e21ee1af0636f610988500de84fd42dccfe75cda908f4dd8fa8d798833a0c89b85fee21d0c299bd8dfd1b5afcf8c69172d457f2920e11a2d8d8bb8ce3dec32cd2ac2a271ad9793a3e0722dc3c4ff72095716790b761a66866e9fe634444c2b5c8ccda0a6766cfa621236228a192aa38db3cb68acf59c41af7a8bd1e3c4946e759eb4c201398d96670c770e63272e79973b37d8204eda0e1763d96b84be44c4bd46d66674cdb1dd6533f9884ad6da7c4c5509070e9c50b099aa23721a9aa000a0d31b2e6c3f5cecf307e3f40ef0ad246b99e805af5c4a56a757c1bda49b8f0255bc054bb1884acf98a4c5af45465abb3bb3336bf009ca19c71faaad9bcfe3cd026bb7f6785b4820167019da42790fe809be22572f306d86ef344e9d51642f3f452b111619b2839991a7680496d6c843dea6cc583bff2647597638bb323d8f1b7d4e0dd951e7b0c950246eda09d7aa36f866be2ac47695f5d2185ef304b84d700a55a114936b4a22d09b4825ad98e8a50c764c3e54cc06e7ce75939542a63921c4d29b71f7ed6a8d793bf3c2103fe274b4c35ce719c23172d2173ff42ee510ac46c7da73876f81d83aebe9111aa749ad6f5a199669c44c9d8e3ad9b8a0582ad57748d52decfd9d6b830e1bda51b1bfe1165b6ba64bf49e919e8f36a28351dabab5d3401887082bdbfd299687e19697efa627d8310dfb5b56e1666296a8764604cab3345c8e3f8604e63ac446e7800c5d08a224118a2568df72a7f53faa00456ecadab8e91a12b2f54ae3eccee48776d7dfe1a0a2274120b650502caca219af22dd4d25ed0629f3a3b603d1295db4db4521befd3125650d1f66224c18e655fc81a10da9cd6b6f16059c27664a7c73459a277ccb0403492444e7833fcaa2bc6e068d0aa2264e5c44834841bd97486b63838e035005d041320d8d56744e5059d62deafd787400dce964223929f20cc3ed563033d397f5ae28bc2d1f355b3e568f2fbf0c39ad909e4d1deb901dc29a0beb4cbab2fa41d1aad5ca1e90c4a7be26935764519adf3f9ed135a550791e798cd7197cea749be1322abddb684f4aea0b39150bf731ec80ee15aa9cae2ce7e93e1d0340105b1ee800ac77ee830c951cec34f98303032fc906ef3b3d8b0dce27340485e474924547f6e1d6240237c5b194475d404171e0460ed3eb16950da81b3b20931a7149b744989c18a5580c6748d73d17a1cb5beb4967eb70efb1a7dc737080687517cd27c7e00253b9b7d1e87a7dec20e66fad3d5ed70c8eb801dfdc4335c4ae1e0c66d634d342085e0af4d3083b8d8325fa18c0a729a25ac12b1d3159147c86ffd00f671affc785d514731f97bb0013ed6210587ed6b91710b8fdaebe7196b41a57b7ebd7113644f98fbf2df07a3ce2551b5c914463992146e8e990df91c5e3173c31f8640fbd124b2d9088c0fd5040b0c460498828224da60979ddd9432e55e37646c4ff0861d09b8032e00b065531d323ebfb3d1d5716c4230a3dd30a4ea7bd5319dc289d8448302a39b91f7fc88f5c9dba6cf495c808bf35aeed83b687717c0917269e637101878e74d54ffe199009463277722a2e033a0e1846c140c0cafe6578ad6565f9dde187eeb86f09bae728cc6506678a0e25cd4edbf9168988cfaf9b1f6dd8a1b98662bddee620687766880aedea4d248cfb03d672a61ce48cfd834a9a1d20adabd9242b18a8665832bd0c4fdcc043624e52a4dd36f35ad1c3e7c76998aafebba942eb5fab012003e1c6cce86e596c780b6631416ff5508cb67d85142bd2244bff0ff51b486d6aaea9c0b339f3bbcff8f5ec93ea2b713d6c3a15c481a3a7f33d7a50f374245f8b1d70c3fd7b5b576786933fb8160a47f557bfbb8f1e030aedbd7aef86053284787e2f21e0d0ef731cb74f6beaa3b86cbf27fe1bc4fe9ab51568d6453add4d212f710940530451d1d1206cbf8487d2d4d187c1efdf33797c1c8f4524c30164582db238a3e78858b106140b16822b24ae3e40f47419276add13d53ed1a4ac1ddbcde2c6782835bdfde0d028f26ddcb2295492367c3e1c07899024a5efab4af1bc9bf899b9da186a1a17d9ea9e870539c3bc70adde3bb036bda0b5bb54d99bc7af4844d6e67e566c53e77291e871a2ea46564b6e41240ed34cf13ee2ac768cb2b8a3ac6ee01d43008165906c5803742b7eab0c228c3fa4b8e9a73b1fd0c9a7f5370a25e94032ba6090fab9b6f909b298524fa00485b4b11e1595e7a790d03bcf4d12cbdc33e43aec0f6f48b493454a9f3e5732accccadb4dcb72f5083e8e8581f121d60b2da031ab9360f08b3f36946c9e15815ce53398a6f80ff029bac9d59ab9345cc2967652f6c8d8c2430d59f498122547833ad8ce1f26c0a41b4c2a6260a17be750144a4ef915938158adc3339da572528174d73c182023652bce80bff3737877a0d6aae8fc9a9ad80ef64998d93bbe0c5a304e75a483b486689f463e2615948aac000d784253f6e46083aea8332a5d70041437918fbee070dbb1af8cb94a80c1b2398daf2d6ec09e61cfee541c4c6e0faf75db8f1ae04f71935691edf7c940290aa011849de5606fbb1e93a0e75b60d8cd58471a0bcc1ec5517901a37a5f060ef2b208713d01d1932712490a8e1808d7b916d3102f97bbf2c75599b4b8366d590e539278c7b7cd8b28718e38980c2d3d07ebe701038bab4a5c97985f52c92c737d5a1c8254f5c21dda1b529a387aa446c70afa63ec509e4c2078dc5c84a44c43606b2f2960704905e88180b86a6f30c21de83ac19f5e0eb29fcf86012d17aa9467b6ded658d7004a476c9e8c4d2c4a2f13ee32b21ffa20210ac398e3f30d25bd96ea058934a9de05ccab69272d56f64fac6550e57606aaa74bcaef86836973703f1d32d55375dac57d08eb46e8ceed163c965053aaae3272b387d370b296f8fe30f99628768641f6261e1593743ae7c7eada0a5b3ecade8072b9a521383ff0095d17d0892122dd78464dc8302b22d6a4040029b7fc27da647a36c017a6a634748c53b6027032cb6e627c53290d94609a758c1429709bf3fab4ebf9768b5696532d2db2846890e1fd32b61d49d336e9272fc65c111651f5ed4c48ddd485a40b2a40ce5d2e51016729c72153105a960a908ca2362044374229c24fe851c2c94eac7e1f4129cb792688f13c88d9c10f3b8f3f22f1578c165a00d6d98f8f08e89262b0b000c3d96ab915e1ad8b581bc593477f7b718c9ab826eabc505071cccbeac019f44bb5fa591dbb2da19c265950846d511fdbf492d9f5c867be57302a7f145d0c592c9d6ed0e889a4309858ddcaeec314a29f43380e810b0479daaa3d23083b22a4666c3b1a31ef1565e41d4e77541f60aab555eba5d35687ba5db9e707bbd66b42482b644a01c27faafd1fc37243dc8233d4bb1a1f1b7b54db38b8ffe200fd997f64873d75137aa8202f05ff4ff7cdd3fb055db16016f18af5cf8db135bc25aa46a5fe4cd04c2890678f6c3db9e27e1fc9d6cfa9ecc83ffb58010cc6ab72d3fb0e6bc08d58819fd43cda0d10be8bec23d0271f7e3fb75e800ace98afe4154c5b9488f36901ee3c2f2ccc403a4ae0843e8094a2ce077d081ef78d39d231394bf9bd2192f19c42d6171a716060bce3a03e5933cdc59ad3b828a42ae9b87d4869e83e94dc85569583c97989c1f1b1573199301736eac49f131c459c6f7d5f3b9c34c5dd4a323ffadb383a551ef302a7095ccfac9fa6a443c0ba695a544459293ad87bd5f216cddffed81a2e16bc0a2b46beec591593db038c61943d586327903ceaa0f8e94d6ec6370055a5816f4892d93515c0c28c798ae268d69dd74bf566a9fa229b0e48e780d2f24ca64faad7b9ac3cfc16cd4728a91b10f16014c6ee20fcb74bf876f3b035fd5593df994f3f634ff8d26ee6bf7f5bdcc71623ef046126cfc9f265665eccffe12ae3b55b9510f30fa28473a81cb32a9fbb51f672454b333b997c0ecda137c9fba3c2d2c6652fa05167b202121e31b43b04bca5680ebd81c57bdff6f2e70fbf6665b848469a9cd9f71ee8d3c4bc8d33b74c98f0dcee3776be13763e423cb64337688bb30f71e1b9093bca9cd84c644ff3e37bc1899fb70ed0d1608041a1671bba20c49a8debb68cef58206e9fe5b9c7c31cdee8efbc45342b6b9fa3a5d159af9b4542dd63066e898f42ee53110ea8f9586815dc41246122595ab173aadf474f53018d5174c85fa8083c6c7823e257b7fe042a5290db9ffc27f1fdcce8533767807ec43dff97d3231a8e0e85a0ca2099e1f8befe5368d20218f27c61dd5f6ded4ddafa1666afd685d9332e37497fe16618cc98dd6484c4f59b2c35e801738e67b78e9b42fd2103f852cc52f979425251633331ca965400f5a013f2cfb2930a64a34555d3707656977aca9095dc045293d9e6042b7bc7b451562fe7c265b17f82c173591f1eeb431c5d30e1817f468dde4931f65ab09da8edfc22ccb925f342ecd0bb5c9c3ae4ca2caef266619cc3e59f746c377740fb91e68275b5f166cc04f6c09e323d430721706a08cad6f0460a93cd22d05f6eed1fef8b5337c4167cdda23cc3dced45bc5c61d0e6cd6772e13e04fe0cdb139610c043ccd98d954eac40e81ca772a3c47457cee4919c4321fcd5ad6a67553e949ba52cc080fce394931c3aea336783184a79cc7460c862d7f06aa956db591e4d696df4dcec218149d6f2a301929eac9a7bf60ad8dde0e66fe418b010861b1a6d42c119fababd9af0ca7c029c65c69cbfa755810bd87570e7591d35dc43dd59d5b84134b707f2d4ef7163b80895512e070712100507eb1e204d0aa7d30bc3d8fafa65659dee9dbfb9475bc52e6969e2413b2c1ab49f0135fc9f68b450fee359fd25e5f94b8ce622ab0ffd6a95e8020baf5e822a8d3cbd4d7e3a8452355a6b44f5fd1159ffbaa1d6a06d150d120ba68cbf232565736f4f1c7e51d894a358ac802c23d03ee1c531dd74b15311d1fcfa097972006ff7308f466dd5daad41e2df75bf0b2decf153df0a7aa52a5a835c1665be19d25b9a9b8f079f008739d473d1c52b7192a256316df69d837791fd36d40fa942fe34212bbc10f582583e0e3e9b1449ba24171647f937adac6196e0f2ccfa871f0e0ed40b00019e16cf5b6705a3badb157b184c7fabaf1404d2bc1e4546c2ff28692fb2280edff003042ca4e3137a869f320e91b801af5560fc5318d4449e7045b8ce981c5961333125ff5ae232359dbfa970c31d7e618fe2eb315a447c298f71349d3e365009c67829674289f755c084fab1f74e03838723e0836daff9436dc32188b4bb46738ac9af2948e1efc4af707fc3bc7978bf54b503e97b83bef420afab71ebf91111550455e4572fc166d0096da71f2d5735730888101ce93bd8e25c637a3f9dac1a62ac0dc6bd6f9e4142465998b0a6cb5df0a44a59584bd349128cc6bc6be62fb450626b225b900448a4971629d0cc4e9f169ba1c9be3bd7610663eb489da86a9bc3daa4c2d9d6662f62752d5f99deb599c5024a1149c9033cd87a0955612e263a4bb46b083b83e4fc093a6bf975962043668ee91d8988b8adc9ec3d7ef2dbd261cabc916542baa1f9aa1e263fe5d7faf8528e8155c59c92d5cf2c30cd504d3322063f890ca4d0fd3c314fbde469ef2bc89596c81916e980d0f1ce0a32a3b703961de8161f27ffab96416d4d265a082afe085b7f5f2b8872934e137379a6fe429e991907c7f2767c9863b240f379f0a9c7f24f40281144d3d1c7519fca22432f8e7038757d75cfa0b43785534ccb2a9d0a73b424fc785d1e850ec6116df419bd1fd6613ab1fbbf84873edb088dcf1787bac35a09e547bbaa2b4a5341fcdf0aede53ad5cf3e9696e38baecb2c556a2305862ae15612064611a1436a7c000e0de0e6bc617da8ee195891351115d493933cabd1ec6b16efdc490660b0d9d243dfee36dd05a118d1fbfa6ed3ddb6600fe83dc17d3dd2c3e50ac9d831a886569340b6455d8acdf278aa8b83ed9738ec4f36739c1c093f4a1c77e44d4e67168782d95ded8bd9b95655700778959a77153279ee5eca4ea1dfea8a32ff4ebedb7e6bf4f5f8907fe5a9b864b76ca2ae02a0cb0636d01d6d8cba0fd0626eac6ba5a25254cd80466f55f9fd4a297831a1d74327a381f0b3637e6905b8634996a4f1fea5aaf972fe747fe283e4cfed11284add387f94504caa83e3680de5baf6d3929fc51a0de8709b7b6234822e722c032a6f0755277c8c98bf8232313698d8aee6d844c8a42a52a6e7aabb24ce9dea115a6adef47313bf6d9aa02dbd9c7ffbadd387747772afbf2b5f2934b03be8d5a38cd4245033241d5960560a6555405cc0896bd7b8d3f5375f2885b88319d9888f1e24004ca5dcb42cf41e24af6051e5443443d37235371ebd5bcc4fc8f86445a1eb927c0f08eac553cdd28cce55e205e5425f6145ab87ec844cac84080a0a9b3c4f5ff69a72f07b3774da4bc918cd1be98aa6dc57dba22c9f625706cb6286bf7dafaf1b634803df9e0eded26ded94de3fbf77c55626576f717c9fa710020c86f96c4c2883b439d53480cff6c8fb6dee13804c794b20ba78b88682da12268532f2860809bdfd095fe41882752526c3fdc70a5ab966a8edcde243b7b48ea1a6ae1959dec6616907600cc37275c0e3a09e6ce25afc5f6aee5993bb449190f7b74024eddc945bae7f6a2d1e8db5394e2e41664bb8d0b49e044083d704f3ce300b236d5d3160bf17097d563d80388dc831d61086cd4c1494dcde6ef220819329b8bf9cc27801a31a7168ed22500b4ccc580875d8421951e6ab12144beda7c1afc903e7a0f32a0026d8366725411dc2063a33a2e244ab45e17e0cf7d1cae4c323d0765ee0c42ebce5df082015c6d4860b023c15de90a3791fe9d3cfc2dda356a230768797c4847f948650acf9b50583701cef644acea5eb31062f60d5c8ba004e5e9ee3d15225e417c6ef79f4c29add77674c18a14b84e5b38ece842391e28ca23b877e1c75f599ed9dc491b2bc62459cf2c8e402e097931b06c1bc5eaf458af09a580f04cba7dbe9d393f21c78090cebc87f5fd39e89ec14a15f92fbbcad17a949e7fc7c2425834fc21336fae8770f0a6798791f1e2101851abf12f42b1e9e765a720139765ba2ac732e9418c87abff34175ffe2d4fd0c3f19f0a8e4261bc0979f95fb457ef80335065b6a195aa10ed0a2ce207b666817ec37b8888b0769743d462c55abe7477a46be8527d83b16d1ccd2631d108a48117cb37fb07321baac6c61953dd0d6ec05c9bcff9989b2634c63b6078aa9a00dd55943d4edee0b41e951733e84bde55a71c65fc4e9aab5c1cae7736d66960fa938cbccc78efb70245d0d4f8abe534a1aa7eed529aa73e8e0c96f9e658bd94e17b082fb7e7c9111fe8b8d9e701d538fbe5f41613aa7ea83232d8040a91add94779e69cfd1b69d4cea7101798a4b15c16901373c349fbcf1b821a29c59d65d9ec90b5abda59fc73091f7cbdc2965c15f0d36393088a54be1b0bad744d6fe34f5a507d3b57d8aa2b5b7e63c52e717d138d5f62f83f712b87454bc4cb1051dedadc59b2ea4b181a18fcc3ebb81376c9944745e59b5028e71069a7e92428d8a2e25aa99ef6c36a3510c650507aefd98456bd63fa96c77218df3da469907291ab52b28db497fe7e0cf79d0cea47313494f5ac604ae1683ff2edab0d652879acc375a45d29c81cf0d2a88b515f07130cf3de0eec0793df4b6f948b2a0c3f825fecfe89bd86f5e2edfbc7e4f1babb427aa3343730ee4b0820749821ea571d63b945f06bcbab09211546a6d6d27abb70d3583f9761f2b43239439546b8f63db05e712748cfe48a8c41e1e5ca4e47f5dd7583c259c7c2ce4aa3efd978e8eeb735394c5e58c2ded69de16e157518b3e54ac1686d2da29bb6d2721133b7d4f7232e5e583c24bc89fe720571005e9ef065d92cad3a9d1d63736b51a7258a59711d83c139a8f1bf0eee31b66f039e2328a335e20e63764d45794543e03af795be78c03b7be57203fa8cbbfd2c5e28564bead03711793ede46a53b62933aa808d336465306016d103472b3831c700a42d7e748c264e8dd01b4396ca16d7b6308ccb408165515166a4b700c7dc79a9a2e69142995f4af1b9e393275f272691cb0a9393a4b99c6e4f9caa8bcf3e8a0a5fdc4fcfd5f14186c369993f2cb43d455eb8e342aa8fa551a68239ceac51446c11077bb9f69915c6b0e3320794f5223ee2aca1d46099a5fd735eea98528e1a77ef645c4657cbb870fcfaa467e225ff847d2f2b9d0e8985fe7ffd159e47b86d6ba7c23c6561346a08358f699821c7239acfd7536be94327eb3d222e595275d2d7c2d5b937ad2f950beaa24643d8fa95a19ee86c45615f3499dc171c9c8235ca2726795ba26aff005ea4feff61a8c4bbde9891db43639ca0a1a36aa7a7015a3adedc53880d7045cdd599b4a7070d79094fce7c821e1ca22b4644299fe5de43bc29c7d39a404b94440589b162d4c76ce3b7e928f20e5c0e7b92b4813b99ba99c94b4536659dbc58bf43ce8ef2a52265ca7cc696ee56db5a3599e0f65e364c2314f26961f2f4bd0e7c16432723ad57ce7ccee8ba6ed8ccf5ec96402bbfb5c1e767d80010b93d2379bd8259731b82a1c0507fc64f06f18cfbc88a0221e5a754b0822ca650f98c863e2345969b30ded3e4ae503f0ee3944dfe9d8ff16b1a0636f45d90349df2ce7e33e29685703a95b776b139285c494e878e3f280b91bd355ba485998d0ca3a496ddb4e75e7b4af0d79b03b513254beaace85a94e1dab972de73ce3bd84ae5d40182c82cf485b5fb9337fba3f127f7b4c01f570976819dbf59538c65c820c94cad9a1701285e4cd52359a21941d92010733aeedd390ab3380bc21e28b3c2b15205900267de0fbf5a4bae9812ef6701aeed0964db5cd0cfd19cdaadf471360e7ba81ca8538ca944ce70382f2cd671c12a5806d514bfb45bb03a437b3c36714025d42a9b03416ad394c5d3a4623c1751fcb6d3fbe33a60c51483582c241d222d3d747d3ec33735b6e9450aaa2aeb389b7b2007e6558ff8cafd5207493de51787f84f98d0f2647b9d4bb36edcba8f5db249a0bc6bca32718fd1f553b4ed363c06d315d9fd0bbbc70fdeabe0bef356d1218d876376b25a59a2c57704941a75e6cdf3cb2ddbc7dbb45c98ea92b27b06f9cf3015f75fe44c701392b629d793ca6714eabc9cdc5c58d97e69b74d680a00304ef7392f15c4edfd27f474f3117d1f63408adb058352f86720d440ad26b960ec9fde8f36cb88ee1a88cc1372a6fdf91313698a7ace7127226892a1c72366b70682b1183eb22e7b6828e2175e7b292359722afe90045eb63564b6b3649b61a950728b9a956cf20d373296a4001c55316372a77dc34d66f31fae724df5af7c73ca47556a54d80b25b870f3cfc4725c05794e0fa893be341fcd0df157b33190feda75853a503fb86f7d24e4145416dfc47952b56c9fb4b2291346d8335079bd6b6a744d7e8570d882a0cf6005052bdb9ecc04b6b46e21f85fec0916082a12b41e9c3f4cefd401765a944d2eddee325c9b3637e2be8dfa92ce0a0dccece766f31ac797e2caf25cbd06db938e9213ad866c3f117d9654f986157e2098c3f09f413de5203b6974c7e11ed319237f3a84351e78010c5ea466d5a8b914e41733ec3704b6989b1ed261393add9c86bd6db427804fe3799b85b84c412d53097a8ed61fcccb1b37a26ce341ba6a6ed61c9bf9bba1f45c4090ae63acc17534640a24ccb6e2c608682e12b470013da14217659c9d01f7dcea9318df6162619ba6735c5f43d1ff9c4d681e707dadadf49270b4f152ee0d4e926385ebd1ce00e5a5340671ef3033d1076184f37fa64de97a0543cdc7747d0c8a70dd57f7bcfdb173451af4728b014dd46f75503884a15ae59b59530e8e27607e7dd3baa23a6033342883cee73a066d1da30861cd983d6959d538b2d0f3bc968c9aacc9432caf783fe8ec4f6d78b25a73b95195483fdcadd83d740b4070b87c3041748a7873b4bc847c467b479052c6b6e258bed3b77fbe77e4cdb36948c318d7365edb0d16e0cf205ab6637b129f04aaa9de967ec4d5fb76c8c51245dbf677a60214bbd119b8f2682088de417c9fb15b4d277bfc426679278b1c227d9fabd9c9fec70c9d0868e9f623b986e9c31f4d064744ec6b116fb271b7d4ed62f840d10bcff40d6f9a8387dcc63034ae1e7400cb36d1503e7b49a7b5a5ee3314cd4ffe74ffce2dd2561a18c2a0f231da7fabb3151077b133c8bc9e1fca8470cb367ef3b4c2a271366e065faead73aa6eea75377942c7509d122538049e0b0458c8ea8e4f8de99dca35364ab0d70f7795779b5df26dd7f1fda065a8e8054d9f55627df5476711d25a930b50f5f518cb234ff63ed3a0d11f3d75a3ed7a83be59ce42924663ce7e065668cb0274dc9c25bdc82ff8d057456ab0095684c6e3c9e396fdba1c75dc80536de3189dfcc2921691a20f5a9800283c10b546ba00fbcc28ccb970c0070152c7bf8e3bf36c10543de79f6b827f23fcc48a9b07a6b0d1e22c7847e65765a7508f8fb603b63bccc53c528d357ff8d3f025dd70bab84a8dbbc30b03d52ed7ce0608e0a041a8bb42c5ac76ec977cdd4cbdb4e48e4a8d9d324c820ef6a3a8f5b014c158b4a7559d7dac72a51194022cc128b192eddc90406e952231083d1ce06ad5791137ca3bb3d47039b1008e5f38d78b6d3f190e7d510ccfba5ea0ecc1d1e2e177a45f872a64cfa6d2e9f2954a2cd415b53112b6e3065e54c400b8a6bb3d45f6824351b12775cc4ece8871010dfe6952f16d59e9a9f627769c7b3bf582be1046735fbfe050684bbc33c0b2821a9420e0d1c26fedceb1767295ff190e524099d129cb9c9cd750507612ca9e6052b23c28b5b483bc138c0028a9572b8a2a1de9ed7f90ba059a78e4726ec4beae1a55e10097f43e74000d594879f8dbfd108a073d631973b512daae97e9b09e6068a464e9c80b6a0f7421ea91d8e33de098879cd953d2e8b359ecac61f896220cceb8b610924396626773eea92b834312d5785ee3ab6be72c634d81c420c4e1960e38f95afcfa180f910025e1376a099530c9b4ca00776778c8811b7bb4d59e3910a024b6c82c560f90063c6bce33dc86b8b810c4c0e0c8264140e8cc8394cfb5b7400651127284ef3a81aa3196cf077948433b11f698b209e2b16b3c2491e3f6048ad9d3907b8b203b156622baa5ca52b750c77509539ce705583e47bbbb4365488504e6bf8ab99f8e808e510b8a4c8abe996360cd7b340524c971bc520b7218e634d6f0a3e61abba29ea24d67e650722e6414f4f9ae9a5d0ee6be542ee52a3304805d2838ac394b3de4d1097eb4123556a211ecc9cdcc15ad4ddbcadbfd7046cf106aeae8abd6572606f36e641eb1e6fb19149a0acfd0b351bbb336853a53d2e859732daf19f8c982fb970b851f68f78694abd131d57a2a6444c9f5bd2a200529da57a3af30fa28ccbec8546d9e9177ec3b3303e2440e10de785574b32ff6d916beadad6845905c3b2babaae61b47b910f0cc4dfd727a74e3d584a1c493f6497c35f3a302d39c05a634ba01ea5f07f17149452342e0cbf065182ef1088c109667db4c5e397b9b266c009b96e2fc6230df060ac2d674fc6e720066972912d4d81b0761a992d048d3e4e26959ac9f93e3c73a51428bfbb5c7126bd3a9eff66e1a96862ea21ae5e1c68606fcc958f070d453c68ab09063e2cf79fb98b29ea7c6bec5cea4ef7000aa2469fcbaf6b7be91e7daef748faa06fc31c957933186de898fb7d2061d03a71869b3b15f6fb4978ffe351b5b517495a7f912ff87cef141eb5e767f0608524148eaceece6a5789d48ebcb0fb275f24a3547333de63f9ba6c255c97f8f526d2e638594e3e59b2198e73531a71bda1582ec505222c7af47789af7d62b3409f9251adac868aa454e4cec7cdf91ec833482fff669b665c9e6dff4411b040f0f07b55a79ca1910a9ca8cb1982fb787a43858f20d527cbbeb5d9b4843334c36dab4754b3a67d23f216fe341ae1d41d8f27404777d46287efc40ad2d85a712359546cfcb596e6e9ccd1c8452793719e0c3bfd96b838b517bc408940b6a91e3403d82f97cd0ae3828b9bbc5cf11201fb3fbbf945b535cf6b594a4ccbc85f150771f3d291ddd0e11d2d33874924c9a0a1d6faad8ff5ce987fab589ddac07bce11a74e299c91aa3857840adf927afe6bcffc4f1cdddb5ec12d0a1ba17294a032e6065aae93e843196c2601d908423eb15a314f88e5fad651ffc3d916969cc0b0f1d004d88be963be08d4e3c12769ab89079474d05597d0868215bf4df5d116c3532074f4ac84c4b48e07cc33b1577c678773790c1be103341b52","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
