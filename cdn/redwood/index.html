<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d900f5fb274fe34f9b4f15dd14a5b4ae254a82b60f533e98a6d51ca75d4e277f0d886d4c50a5aac39ae9e6fc526299e73c715811d873742d72f33872cdb52a72447f03d2da2a3e2d075f451b53c39f42677ba07bbb35effd6e235f5414ef2e1044654149af2b33466475f903435a334d8b434cf137361b9772b9e92b1c44157a923770c2b3c94f422ec66e299c0450caccc7310d020a37c7f1de68bc2b1c004de52e4726138b82cc73e0f1497418967d193e2e346d000450186001d4ca99be7ef37be160c2dfc1c800b4a9d1d5c65c091733b964f7a6a2b559cfc6796d73ea840026b73f8cdb85a96d40344aa5dfc0de2b1748396170e977a6d012e6fe9a771c9425fb65e091859dcbd148ed0ccf33480c7090e1146fb256084e93c268cc2f92e811f9fc8dab5b8ef93beab0e427352365d9fb97830deb6388b348742063cc4af6959dd06bb860a3fb2cc3fa0fa142b05e39373ec27c3ed7033c71db5545fb6b1b63d2cc291f2e441852042d2bdcc3f8dae8a1e8ac0e3027aebed3a17060d3f46c73c285e8d977af89668c028d5430f223010fec4cce573b7439f20350a042dff0d56e3c53a2384f7eaa06f156e68aa393f79810a33c1fac5d4ee0f3fd6aa220688a178f95476a4c3ac930be46ceec2e4663efeec47e46b19e871dc385ccbe71484c58f7983f173e8cfff19629df60bb5b055252626888e76e15cd833a65c9249c0eb3d331701101fc0ebbbc73da57b61873f623455b4981ce7a3c3b5b81bed2dc1326205e4d0a089a3fdf2aadf9bfb04a86c4eea54b19a4c2c0d3a2a9da65f802a7d15c1d3e55eedcffaccacfc7efea321395a3f2fc98cd7071af40ca20de00d04a15c58dde2b214ba56fd82345428ec847bbbda529fc4d088581869f10a4c0d5c0768a710ce85fb17404b1206191ff79d5b018e921c6e022605279bee3661436b43faa60b2e5e2310a30d2a10265365ce12201a91c918cc8c24140cda9d6bcdfba205774a8cb3abb655bbee5a65948312cd56b8531c447170e50c0cd57d113347b0eaa58e93f8c1a79facfee5433b003928e42196fe67c4c02a638762f23042f8285b4269ca041552c48738059a2bc068f8d216bb1446ecd7ca6e3770bbd54af645e0c502b7126878169821cfa0c9c5dd60d3be3397dd00711dd55932474b38572b26acb658a42991458fe91457e8e558791068252f6c3895d31f4a1e9f246f90e929a9ea338d883ec5f88709df2eb43fa9d7a7dc7f74212c5077a1d9c673cd47ecd0855f9962529951539c9313676d36b1cfd0bc9946d3b45be4a12fba61d8c240c0d2a51e566fdaec4976874fbb73acf81b81db047904b17cba7ffe3113036326b0f932408a56f0cf84b7102301597e111c25f6fae373b9dba2501db49fc485b28c6cf31fed4f0bdf2e5b6593cc2efbdc6c238d0c5cbff7df6c88aa4a10e2a77276bbcd1eeeb62d8c0ea0419826ec96198501e1f3c168d808d178647861db85702b7ba602819de7aed1903769404527251615df7d1d4d47f95e3cff5b30bb416fd122031a7ec56a912b7cb267725d2bad07949daac7943ea6dc65aeaaf395e87365dee9632756566e9c914860090c1c9b540dcf05a691515c7e34d94226425f3c37901e9c61d18e9e72bfc0a2ce99864138d5d2ba97645a2ed2d8e5af338862fa607ca9428749ba9a2ec3cacb0d8bffb1bfddcf9d6eb591e7c3b8fe8039ebfa505cd50196f640f092d06eb3253132c278e24f0388bf824b56bf5dd89bf253e0af99ce012c282b65dede74e9e311eca5f77672e00b0c60c44398fbab3f8123114c1834bfaef6b2caf02c7ba2114eb7640a226acd1ccb6b6dc480c3850f2a67a8a4217464ed49c75268a28d81d4850951a5a6234a083124bda2e7c6967f47a16eef50b730f61e4d3cc7ec451a6e96e6c7c76add16abb4076b137deb63de30f9cf9a405748c20eab4bd124a31a11245e373d0962b2a5afd5885f95c02486dab4a767311fde1754e27ae3eb13c7c5514f1344993721eafc9fbd5b8584cd1520634e585fbcf59383b0e4c1b841cedacc7ca3dab680465f0d905a9a9162406ab05cd593fbb2d2fbc43250714500642bda8a42d3e00bb0ed875284454a8420d590d94316e5c0f5a173359102a5b5a93306452649842849c9962b0ce96c402696833bfc5362d0a185dbefceca965b7aa2fe4369157afa28992e2bdd0d9d585cd311b8046f1dcbbdbfb014fed6249bb04180dab11962940790f0028e9faacdc6482cc49878828e028208689c67b47cf0de88b212733a561e49a5367d2fa7b8db2ee571644e1b1bbbeabef0d9029e1933d374a22d4f8ea961b6bdf3c9a9484acf9a46300bafca195da7127cfaa845148ace8825684ae1956340af669e99058972bf01d7aa890b9c0d871732234b30bfdefaa94d9cf02f640cc82b794ecbd14b7dd96b506ce0505078ca5a45b46b9f5cf9deef385666c6a6ccf2f0cecdf66328abecc737b62ea7cbe8c2027bf3dd558b7332c22a06fdca5c8b9f46ff26cd23a2cb9116e9d5e6f5f32f2c3609e91276671fd1912ef1d7e133b469f723ac52304a92599e592acb5f812e7d556c8e0786f8c98c9ebb49506c9dc0d4128222835cff1637b00d0ca513ba3d5da5d322b054891428f7aaf609290c452d8403c4278f939cfdd3cfd1e92d62755772eb57e98a329445f1134e851dfd5e5dee33bece3beccc939643819bd697e3eca31e178f81a20ccd9f8cfb471d13c0e4071cd2881244711cd98c93537eaec165ef7f66377959a42018fbc9f37610693f493747d9312bfe87490da8efff2baa624298290d1e16959f9bbe49cfd7085654fffb5fbbc64f90ad0e618aa276997fe7cd969e808e4e9fab909d67d8ee2ce89986afab3086e2ea7c5511e1cb1985b2530f67606a984cf80a8f8f0e72ff2a52d7e0eee831a49e2e4d2b698b06275868866d74e6d8f81ad3ee1826352467952577ed4416f00e381be8e586b5311f8eefabeb32ef4b9c690d9f87754f4aa437a1c548b77b9288492b35cf8c1d572bd5738290b84fc52bf825f415ce8373001d70fa7e275c6a542386212258e60f058bed7155e6508eabf26908082ca27f546e8e7a611452e35f2f769a427f5e3f329a5a6f2fff6b0d91791771b9b653ad905f82b2aa3e13f6f96a19653059efaca489fd9aa41c2425503d83c1e18947f1a4ea564f4430f789518e869350e6eda38bd583e3484ae22a2ddbf23b294359537dfa466d87dd426705a0da798ca63c60fde5d60cc0d8fe2759bb39355f5c9ce8fd9bb504bfe9f2d0878a085933fe54039142eb1621d447a0dff4ed825868060189320120516d4baca0e928e8a313c3ae2d221ec3f400fcf01e918c0e40f9d47ce0eb5159f3b1dfe19e051518d486695ee186ddb06042980c3c09a08a9529eb482a87e1901d3a5c7b60f9ef1ae20eb62be64f9af415866f4670cced9b5842bcd0a58d98b443558d372aecbdb902055a773d9754f05dbf546a00ed2919ba1d6d64da25decd3fb4719f22480e818bbbd971f0585fc8e7fec54b4f7e8d488da8462a9b4530a181b6c0a63df29881084e3df2849cea6747b093ab83595755cf322d20be1b2f24a90e0616523dcc0a5027c37a851111a6dec9e6e0bbbfc2b91e2356a5227c73e4c2c9746e3d58bbd344f0bbf28a88344a50adc0bb5be60e684e85acaadedf697d92f33d6685f569e62a7a18b8d4c5d1e90aacb06e609b5c13260c93374f3fd912ac0fbd146fd256a3c680b6674207a7d289498b01d9811c913223f9c22bcffbbc0861c8e96d1728d8173466be156bb9ae991fe3bcb20dd50bf44bcae489ff569ef0ef339faee398b8a1605113a04e6a9ee9dd79bd9b0edc6d02f1c0365e91b6bba6b57a387cf9dc56402869410c5b9645007025110a1ffdc75bd78befdb2fe1f034163cd6e2b8344dc0b4dc05b25bcdeceeb25305aac20f6541794a2bc45c4f30921bcdcb2d71b80782946e4ca3007f2e66251e0142bd3ac1da0bf74108188b8d3cdd104c07ff1cb2caef8eabaae31ed8ce1bf3b959ee11ef6c64c758787fdd4de695ec5820d66ec00bc0cda38906157a8fb03d2791543052af3eeb87ba675605e991dfe94aa30b25acf2c602d3f94a4681a292e924cd918457666a9525fe267a2af19c777338f49dbcef0eed7c8503cfe05b73aa5317b6a89defc6eaa0fff2cfe19a615fd337976c202b0545a96b1570b2e28e45bb6716596418b611dfba6b8b48cd4be27540d4ce9afdd59bd07698d9de7959e16b65ab70ebb1f459097480c898d12ab5d9a180b77614f1973ebee3f27c718b54888fbc6dab4b8ce1ea4dcf9630a78d600ebb97d27fa584cbd563e781e1b656cba58dd695d63e89187a0d5193a8125d796ddfcfc15995860eb0c77b2a1f7f4a5872156e44193c4381ec08910ec2a33be5311b81a18b4f3c078b85cebcbc3238f3a8d8e154a8b4e5f01e146ee0ce6436c824157906e736c32d9799e47cf87662ec08d4529596da9dd09ca2b3ef236073ef95b0b12d4012d7d34687001679d2560a249fc869102cc92934ef6bae742c528d76df4e60c9d167c98b7e562028702084b19439765a4f234758fc178a1aa7e029012928925ece7e1b7f1d2f4b3150c8459ae5b6600fe7a9419ae28cf953e8a0979cddaf9d2596c3899ed951bcbf514c10b155c5af932d77e575496c37caf5c4614963e28667fa8871287598d33e6c7591e7b7330fb6a3e6d498671fb4d2c6a0310ccaa4e64741a0edce28bf911069ce00e033170255a967163f83ba11a29740eaa5281041341f5e51f6ec84071d2e742527e22b90a3f7d2b37768745931dbeaeb5d5ca57971ce7da835cef1ee7d1865deaef749ef327da528cc2da6c67fa3cbbeedc964f955ae2e755add6076515a35244622b4073c1aa3b8e5402ee254c11af1a961fcfe9aa750f8f2d6d37244295bf2a6db71ed0d2d60c582c666d02f141ae0e7f90069afb069129d5cf13c3ae5b763572162fbe1e5896a43e42ce5f649e85bb8fa89d591f21c0377721b92ba67f499664b00433abbb236ee37a2ac7f9350a85cead575e978b47c3ca543345eb16168e1c6452d05dec1a5b62ea61f5e79a03a8ab7b46843001039881ced79aeaf6891caee37f8b41f57423c8f940393c2c90bd17a837591325b99a41b5cb781d3dd0a4c59a0db7acb3cf493d402c815798a7608091e5d06b18e313862d733cb332a4f5c28e4702742b024630c1f45ac8a4bb6cfa5bc4128101be9a6c674b4d45d6ece7e66b7d632bfe3cb214029232ac1ca939dfa2f0bf4c84d5d805b2525117826e09d388e6134de6706a181ac086044ebc25aef8ec2dc011912f09a029747512a287e5600223a0fb4ce002d8224d8f0196b88d57f677902e8aa7fddbc6b1019ff57bb823b8823abce04e1afd4d030cc955e76211890b73542c54f99724436e8a2128ffa6125ecc05f1e477750277ea15883dce265750da570225df441da3a8936875b8bf1182c31bd70af05ec62640fe1bf09efe237f67e3ea06fbdb644f68ad5718d8e15d56ebef11ccd36c64dd92a2e2d8e635fd893534916eef48bfdd1e884ec404e0c71b9c7ff8be56459470f17336f2f43978598c4895ec9cdc4b39ad39e032304f6e19085ced3d9823368be45c017fe9fa78e38e12678d40ba58e716e2892fa7a55601163c413d681e0d30d903ac0ac5cb55076131f1a2f3f3d70bebff2535d750ebeb504e100b3dfb2a946a51b9a4423e82c8ca1f504ba34c4a90a310fab01c04e450c439d62f3547176e77d0ff16ef10d15ec0c73c99fb763a14d56eb016be915cf40fc51c57287cd9ea87128f8b48204a80997a0815994651742c7eb72036e2444c99607eb476bad5e2e64f85c0b29b2228886bdf4df2dc9fdeb9fe9a7a881aeeeb23d3bfe2195b829a7db0c09ad86d6cdba2139e406fda78bfcfa08f2e9912a188d791b7c802ee9b9926bfb20e3cb83ff21708eb7f6aa73a00a0f2b125e75c0eb9d6a4c14e5d6b828737b3b9a61a0b4132eb37cec706fc9179fefad82a57d8f376052eaf19d7ef1546d30387320c6d09e0c53b6caaddf70acab1fa7ad5656f9773869a7b787709f65e4ddce91e2d59a3e47f7ca7ddb785acd171eaf1a1c50aa9ed064a595b6920eb68da0578646e0275ccbaceff52ca25b0d20a02092f06a5fc971e262ab85cabeaeac98c571cb29d0feb0dde71773edd2861c91eb952ea7005fded63df9404762eefb14ffaf90167b1f8e84538de7a99e1c58173ec8503f4e312465ff08217e1703579fc4aad7dd1df804331a29d8521350616ff92de14503ef25d1ef428193885e758658c5bff3be1d82c053d3c5341f4b6665922504d441e571e91da846a26262bc7c739c0e5ab617603afa277765616f54daf04b33766ecdce98443bee32907a869890d81b1f7cdc4b63575f00143650c49d7eb45dd4ae1cb38ae60d7897a394b9c4e9c7a5878ed3a6a678cf239e7bc9e8ee29379773f6b51cc02734154cfa0ff77f743741d435b940050fc4e0d2a3c7b9be1e890fb4741bb61085a2c18e7e08e85fe91c9718f3e1d00d76ea63c904fc1477d6b30d1303d1d900f31a7a98fa9015a95fd89698f0d5f48a47cb81eee2c23e803b71508bfe8820c153b0229556f877c8b1e668498d6fa2a24fb7a1244b7ead30bf3d6e35b076b0b7ac77130d4ab6ca7290ef634e5a2823946d2993431312167fdf40c2cf31c34849438bfa96cfe2b8c91f32392c89830892f7632b07d3b99de5266cfba95730a5a52e04fc78e32a68c8d2952264e83e24a7ffd651ca429fb3d1ccb05b3afd8b1271e44b05434e817f5faac6c266453a7a8e86c66f0670f1d93a5ddcf9a15ee2627709ac71103734f0dd0ccddd6bd821b63a0213ced567e390adced9cc67d9cf7aa5371ec0b7517131bbe8b1ca1fe0d7303241ae06bc20de0c8acf4a9b1cc904d994faa5ef8fcffd57f54fafc0cf44adbadeaaed208e4b6d6eb1e2237eb2e64ea0e8f0ed85ae4639a268ce1ef96148c0e6bf46de465102d7efabf1f981210bf3ae463b85f572da068f1877af192889c59247a11f7d2665a9d21f7570905b02c856977143ac5066704d4f9f2b8a9922ff2eeba9c352fdb0d4a1ab10a032a4c7e008d5182ef1bc40b5a9a31b0c7d98fbe6b7d1119e1979b593110cf17e29d24789dcb1929a0f841c5483b828512d72236ade785bf3eeec21b3ce0f286cb9fab38129f5997f8e197b2fcdec887a6bb47780457912199fdd27d1b0e203a30566544730731c8a2388086b6ec8c0e85b22c0b4b069d92bb1821e73f6a8d6943e501410da5365092e959a00186c2e6370d1cde94ec4a842ebd84cdf8566c41b854cf1fdeba61a4f31c295d3f596db93ab0737fc835546a2ee01d2d8cdfb966845a8a9e983136e8b8b6d8166f7334ccfc2917ba2f48790c94ffa9f88425e9f8822dbcd26ab0401aa8aa375b77a6f21d0f5049b1384a02556eda17d19c8291f8313b02d952e7ec22b1c4d5d51deea03fdacd16029e44b41e6d9d5dd9140dc39766de8cf93adf08702fa527c87bbaa25737e3a4ed663ea17a3df78479889458241286c5a6ddcf8f1183c63439e69309e688cf78d318cfe9f30fd18c82d9a835a62b6db6862ae4931e04135a135c00edf1c4b2fea5462a74041c1e25e02e3784d7b073b5fb606bdc90607815140c6524fc0617222f7f570ed580d10910848f41140b22b80d848c76ab81dd15c6ac0e0d29af44d517be1b6be9961fd521524c4955e43c37f51499270f84dd50e1dca3e6ee19299d932a07bcb156d7f1c32a8cbba39ab07ba44370a6f5ef1fde00d870353e85201069de4ce62e39331de8b81861a95d734094daddcca5a2eb65836c683731d7de81835adf27230eb21db95664e686207aaed08ae34ccb903908e1ca292de47070766e0e3a0f922308fc7011303bdac49b1edab52f30b5750f2b16b9eb53ab81dc2a59db89baa5bd569463db92ee51074d466ce70445a7b83f9d4294f64aaf26a1dadc3b6a3927d100c12887f39ad11f81518a2854732425ac768db00c2ed90140f5c1a33b0027b1dbbe56ec1e5eb483cd7eef435a3b1592c73d38b82f7cd8da537bde725cfbb19368803eaa2fff8d3591207ba5a8ef13bee70839397fcae36ef1da9d2dcff98119c9f04ebdcf8bdcba344794baee8b1ed349b8b24763176565800b3ec3313f8ca8794395f24a63caec689bfea38897ff2dfb699c4d6f45377ec1318086d6aead32d4f3966641bfe5dc36e3c6f914e34b72b72e5f08f959399b9a1b3c4e949f49745ae8a6e121f3d96691da1211090e0603d7eee62bfd7cf7a344b24d4aa402d4c9a413a7e9d3abb260f880040cc1e89f61528d633df763b0c437a04aba6b2b0ecef72334515702b041bc9e93bcce6ab72f1bde0aa0dbc21fe221acbdc632b3e22e9c90eece7407c5cc3a4370b6feaa76482654fd3f07bf60f13d7be2e6021214b664f0d1cea01d9c0ef22733049b9855effeb722ec0b479fd1c3021a4929e6eb05392eeb1735bdfab84f278784340c768ae50aaeb692bc001c8f057e7c955201cf294164611db14a342efa56bad163e9864c84c81bb0cb4359908a3269b1216ec15d483218c55d5fc18d50f96034e906fc9c49af11ccb269f7cd3297f5b3aa3c1918a5f2e700d83926fa386065efa9b15c271b146d48d0473e06c22e9ecfef76ed0ad024972afa553c012b04a0f052ca445fa1f6cd4251c9b4c007b742470cee74841eb92bfb21d628fcf5919516762792cdfb49d2e1555587fbd057f942b637bdbbfc1757a6f0e22e6522339fc762ba8f4602b9520051eaf67f6bf2a27d47a3af0e13e1d5cfca9398ab8b1fa9ba0c22be020910f29af2956be8b477e3782b84d81d97d055f9d29413bbd517b89de2663927d931f6f4fe6eec2d5f593e96429a5eaaa5accb2f83ec9efc26370469a1040f88b9301f46cc1f2d6ddf3fefd1d3611df7b8e19946f5ae150b84b825c93fad308391b1d4eb870ea8b2069fd989030d5c53287d03d8d304357a1bc35f7fa4e8a46eada6d765987c9ef303f6728f4adcf1001861249c4af81550692dd61dbb4cd28a1752df9701206cfb403c6297ee2582e6ee5c0b0ab5b185b05aa6a6aa8856c7f880e06464e2b7870ad1c10a7ebd04c74af6828cd293b4e23015a4d7dcf4f840d6cf07836207d9bd1147902326352590982841550242cbdcd98ec55eb784376b3aef87282ebc90e23b9c401d491981246fd551cace160bb820c6030282654b8f0870ce0e587fa90ee517e1d24def0c6f00be9abdc0ce3f9fd66b45739e27282939daeb42186591618eec3f4e760c4a482f827406ba67f8ce9b967ffd180fa1e38d48ccad529ef2da4bdb05ed98caf5980121cb7cc78ed9ab400191611ad22ff7effd1b0673d01e0d62f7712ed5f844d0591dcb11622074c7b90a7600bebabc12f4c7e9dcd4a298172bc2d4ca945b3b152a32e062be2aba8368a0c913b8e63e8c09809440722f71c83a70e69f177eb61efedd55f0542dcd93910ef0bc92586963016caa7b2068b025dc6d1332a2b567e7e7f84ddee2165a1afcf95785a6ffb67e49feb422dc574300f3508cce48ddf0e5cbc90a250484665b117be50b40117d256a81e3d9b6a048f3e57c601f06a2d7c3105b82d54ea93aaf61f06c2838423f61170d12e9195cbd1f3ec2378c01fe4c5824bcf2893ce56e888eba62265ef7113b2d5fc2ff08373222c2a65f070dff9280ef5e7b5334d511b65d2b4416cacc8c60340a89ac601092a99a078adf2cd7d19704a7f9fc2a0b4d1c3bd37aec805415406aa1456b04ff076c5d4677a46c23fd7371bc799e15d54a2078608421c902705cb15cb328515a055a3a4b51a088e8d397e8479938639c37e7475d083d333ceffc2993bd38becacbe5467c161fc512486c9e49741deca02645e7cc9e8da8384ca32295d0a8c8d061c1f3fee358c2758661c2ec7f650e42848581059c6c57494da61b2fff7db3552eb091a8d1c2726a622336e1937b7ace1f1604399656daeaa9f1aed6a0f4d91dacd70720fa7e3725dc52f095a3b3ff72c8cfb8f2cc6d6a81b1febec80278674ad17852a831fc0cfe3fb333eb33399b12bbdc8ee15514e5be7d79c2fc2d84590ec2bd43ac94d5fef1bf6473208cb04ceb28ea4eb381d2c621917a439468389d71f1b1a5aca85cad7d7dd13091de41cdd1d834ed663a75c2f026a68f2c89a90cb6474228d9a2b77d86e4525dac6488efd781bee7f14f38f408f03ce84dbf594907eb4ccc7bb7704e00d077ee804cec757e3396efbe7aecad8f46d67c13e467a0af887dc2a914d2c7900407ad193a33821d9b70aeba4bc232119ccdf82fe1e381aace03cc50619a1bafabd9083da683f5365f0c7f2479af2ede2692e72e6e549c37cab73a4bfab081a514a4ef3ad66b35f21a48b04d39c86b03e7bcfc385002704ba8c7f2c85bf09db8ef7697ae60abc3fcbe7c4cced844a2c7e65c1434c05e3cc884237c6f13098d0c825bbbee9c280a76ee63866ef133e3ee77894c4608a2e5785981ef4c1be5eaf2bc983622c46d63563bef5bbcc736fc1ee11cfb8d363bca22182a77c9d697e8f1f356ff92afa22852178c3ac3479e3ff39270b4f4743134db02cc3efe174e7719d6e6027d03cee6429e9338912590fc5bfffd1f4aaa4ca8e24c0cd7f245b231bcecd10affca7221de36fe668d5154b6e4d0408cc45cd8265b66b83736e0319a5d63377f8f0eee25c372ee18e6d5b7dc1a6855e0b3a79988c07ff3ef88102affd262d1cda46ca97c412b55f1a115c2398e0b9b94f8d36e69d8a05733b6da4895bdb0aaf4c4689daa4eaa9690d85aed78a78d39abe134e448aac438160d4a24710cd3c645f4378eea676f7346c350b8be3a22aa17e34eda0e35e3c994a41fff4aa2d372896e8faed448c6b9aa063159d1d26c4be53876cfdaf7058bbd7f410e7a39bfa0737b12fbc63127dd3d5d97f322c8d49b244bf761e6ffcaecd4d857064a46930a3f925e87c3e71cc2649b6f79822f563c30d5c6abad892a36a7fa2bfd15c3c0061b10786fb214d072b26c38a0ab3b6083c9483ccb031375f3e1085415be949a1b2d1b7289d74539937fa62aed2d0dccbc454433e46d8d73afdd97f0a7cabb8178256153bd862290669b25db4b305a4518498d3be0d2c5a362a711ae335cd39df8c96a8b272282842ec02e0a2cf5129aae42ed10b5e4b4779335b32a5dc376112961b56011c7ddd381e7c42e2dd59dbb131f280fd9ac06e7f298b03a8dc5e8c37b054218b09a02f433327f4b1070ce967c7aeb8b4013842a0bacb3c8dbf05120ed99a98f6565a50502116b7371b64c7b60be31db716da89969f9b8d5a6defa082af0e3765a4719e6ac231baa9c4938787c35d06d55dab466034081098b0bd5121c44b2023d96291f9b26d1c725afd8f76b5db128f20546e7121c28e6d9194921cf7c4b3bc4e9edad67f505679accddef7f3b74d9483b354aafb663154114c117b77912dccf7a6504c09aa06f9e7080b646040885bdb5690a10b7e0eba2722fb6eb12890235ddc3f2d3ff3d910d0bfc3a997612024b081ad4f423dc5e4440e39ee47e3323a8376542d7f6611fd8a71a66e132865245c2e34322b7a7694b2a7fb61ea3cd4af0dd4c471a2af89cea1da4e38652803c78e0054507220483a0373307205550531d5bfc580677c9bae6b161b7aabf27fd30a20e6df0d002a9ae6621d574facb8ff4587869fbd162fe4ca51d18ae4c073ef707a52d2ca1b64a9ade7bece172bb14b9fa58de9a25868752d47c92986e75090282cbacd4578f4ddc858865570b105d0ccf7c8cf422d8c5b3b736f87af0ef705bca5eea48487c1603f1313dd5ede4c65b2cefa98b7a1535b6543e8bdf6bc92e189e6a597b6780cb864f74e12b331b3e8f7d00d700617664777e7615880dc3f51163c158bfc252c3f34841a2137f18d4586d54be9402455f6d0069bd4841b3349c3f3c0ca3df4a10afee7372f5b2fc6439b0d5c1d0fa0cab8b4acbbc4deb32e90f62f04f206e704b3b935b117a0f7af91c59ba0e7bdc529d6447aa759118a02b0542845dc1d4ca6965eeef578b5fc9096f9a047f40dacfcaec5d37c4de295e26bfb95141419caf646499c0b58552a08a5dda740ac3d28d59080fcdddeb195f6267ec8e9600abba1ea394ef762aca66e3f093b8826c2ab278474c6d5391e93c2cf81e4ab63f8fe9eac62f643aac6c27e57aa48b0fc65b1943541507f91978ee1b32690aee8563441b9ad8fb94ad6cfc7f3159e931f946d61a07ae6e6416a7c2a0590207d13087acf45ea885e624c296c92bc2bc927a0c022a220abd3fcf6dcd1e2130a76914982ed787e441a098354c4966f1d816e4dead0a931ff6ac2e4bf1b95a423c4f7ae4affe19681d9fe4b0a6a076043dd3d3791e6435a6c8c457d1d11843793666df545d30f16dbca0702cb69d5e714b03d2b3e3076010549eb90041e1aab9b119d7f3d5aecf2837b59443d5b9ebb876c2d7e61287398fdf1ddf804247225c26f8ef46de0757a57bfa9c1c054afb97ee3835298b5c047eda56ebc6ab8f6175e2f3c69ee9fd799267c29082c7dd18de4ca8ec70d7d7947be708af8d637d5c6f48e6bc3420ec9b7ce97fa7d75af9ce2b575883bad1bbeba7097560d8554b9d65794edafbcc6b6d827ec51720b3b5bb9d71fcea6bb7fc90391dedd184be78fcd655fb921dc239b942482a838a9358057d43c42c2c39295530c2b56686b333d883ac4ed189926a5aa422707ed6837228da6989b4f856e0bc5b4e79f8725b2dd3ceecc755f7ff7944e8fb04ac96a36fab1af73054594787e1c1858ce3674f82e7eb73384fecc4e8959532bfc16aba3965fa128a06325a94fee46f933bd83cc289af306f4232a5dac9843e488745b8bff346192472d2315173dfe350ef7d94eca37a00152a451c5a97e1bd6b1151c152b19cbde296d0b9b8201eea93e2ad5791425444ef2785b77a86f8b901cf67d09e75a7a2bfae56eb46e22a902bb045c426aa02d16d6a6a7bd92a12c11771cea486aa889401e9935009ed26c9d1f4dd4bc22f5e6a2ab77d85e0288d575283dcebcfe9594504103096b6a07ab13310b8ee52f4dcb7cc37f35a1abe98067f8b7fb2d37584ffe26779d98fa8c7e464fcd2950feb0fd47c589cdb3635d543de0d91f5647e0d1dc2ae209f61ebee320dca5adad492339e02a2effee2c2196a73cf266d404502a7026113659e98901d4259cb70aaf358d1451955d72cb8167d5c2b77c9d0271ea73f7b9f7ad587c1783b4a0b32a0580e9b14b7bbff10c2994570e38dbcfdbe16d936e52fc7413814759d2e475197522f249a04aa9859fe41a07bff5c18d3e989013199b68f5618e61df67c3eff90530b548a9952a2087269348dc5496bd59f9e338fb7f117c551be899d94f300039f4f89ddcd0c24f48ff798158563302d9c95b3bd0a30f662eff3ffac5872f24bb1cc0053ba74dc50b735a3dc0854cc703615e461d45315122a6bf560235c2fb3e6d2a52c6bf2bed0c2a17ae0371a3e9e987ca13ad4580bc78c0519acff6e2a465882eb15af657758630f5ed440f8de0d07b1bfebbe5020394d8ce4527c637b596e402a6e9f6543589c23ea10f10dc22b5da1a89a20940a4170f1d6ca0309eb84fb7be990787925f613f57dbb9b4a6f83af7a2b519ed436941387dbec91e58e81f0050481b69c99770bc69cccbbf2474f75b375ee68aa3bc9af4848ca4e172f59e65ea2c6cc2a14facfacd741e4ab4cb947eea00ba49a48fdc6e8fc7e001d2c6d8d9c207e233631167800a5536d69c8887c98e150d8468043113572f065a977ec6a5d799ec7942c07f377c4250f5aa8abe4bd4e89570842cdd99c90673764dc1328aad9d5d448a6b13c11002a25d717d2a1a2462ec4a506cbf79db46ad8a52c8b4ed9c57561d6ed1316c110627e32f1eb0cd8830d65a5cc8199501cb55811b194f095221aa628bc304b765fe3a50bd8451656828e0c16f37b253cbf9edac07a57b8bbd62373fced8ac0cca6293f1d2b4cdca80ffbb4a80aff92106ee41a7c0328229e4b41bf827b54c027f270ff21b305db329706660757ad5665dde0f4f00e733bc2e14c4629a06e76c72179d8d7e9b6e683b43ead511b28c9e5312fa4cd5e3f6ea8f33daa5cef6f7042670290166bcad940203ac6271dc7bc6082c6e706ceb33af000d5ab93b1b4281ebcdc3366cf6001a5a1cdb247e387460155e063813023a63b5c6d7d13acedb7cda55d1971a8b4efca7a7c91a55b8ad2595078ff940ca055713bb2f163ef2fbb1f7c2d83088ad8939831c6f4c07a31c331e23513db49988966c22a596fa1923138df494afd265a734070182ea222fe92e46ede4d7df3868ed274bcc816be1bc0c76bf8a91aff99cc33f8d36975570c9513817856b1b3270c579382ffd7cef14fa90ddc17babc0656c3cbe9fab4fa75203635b869f8ad707de501cb94d27aac8127748d00f4641dff79635898fc6d5da02f2ad45dcd6be45a68aac82b73b95636c2457edd067f3f9bc56b575cb059a866684be1c93df0490b85efdc83e523361297ba650382faa46b7b7094b5a22cefe47b9284397bfbf5262cfae1292f9efc224daff3fef908ed49df37919718eab5daf3afbcd00f139fd3deb2f7d548ee63a0ec2edaadc8f7546789f4bf5e0b277101e04a9bcd5ce30600c9b145364f28a857aff85e37e5a3649f8a7a28d8c14f6f2e3c5a11555bf4c72323fa420f67638f78039335b4dee4c5ef05c12c3c3ba769f36eb6b384ee4556ce436f2cad16e1989a9a0507ea3fb81e7a94396559bf56d4e650d3221a0a423213f5567ba05f140a04b3bdca0f4e181bbb65b96f44ac5a2d8264d706121c3aa901c25500fba1bbca7a940e991dd813cbcfba3803653e8426ef6e223066397b2b425fb1a1b942e07aef03c6ea2a554adc84df8f1d791c51153b5c8ea21c62c9876dbbfa5dfb7084d24a71a32756b03a6be822d2f6e03f7ac82d60c618f97fc973557c0ad24bbb6af979a2fd6349c08e206a53a7572171ee9424647dde078219ae82ef4021b4ad330153b75df6b3a934d224b8cb5d2cdade9b56de220eff0ebe21e3dc320a53fe2d7f438d39babf12aa0b1c3a67e6e4de517859fddda4d2082046100dab174765bf94f655d154205d788f24f100108eac0769f8c6e17e5f89be489d567a019a0b1e2e7556883210034a34212aa9c0ee4cfbe233e086a15d9a546426d4a7d158e5e8333f4d01e63e9c737df63060bfddd467191c943cd615b68076b7d6d3df3d98ce63a5da985eeeb253c424b12bbdc36b4ef1386c43c114368a7db03ec616d1c971c51f656a6f32891472461ad982238c912bcb923a03885f9b08d0300166ac7a481d3beced69983e183bf1db3236542d007ac05051a2641d5e438e97380fade588654870d5973a666d3cfbcb59c5cf99a06e626fb2c0ca3c676ab746eca491193698aec125beb553b6e0b0f387b045a9e227f1e498d65b764a91ada657a44d1250a8223c91d99ef58f2d025015c40d6d4af748d90f78d37a916bb0b63aae92f4169ad139136d794bf811c739ee5a8f5af18b0ef98789bcff2c619c53724df8221e9aba9fbee9fd1031c4d3b906a1bab23b7876e5a207a52cb340f16c03ae0a6d7f7757809a82e76dd69ba5e0651453827b36d04b1bb55914c95a7609f2ccc70f328b4dd1c48b378b348293ffbcca4832580af0d9c71312dc94e4ca9951dd03f042d66dc8e8002b85d58b7d2bf27a4513c33320b3dcfc051e409315ba4cf0c1bc72b4610b1604a64dc1a9aa849e2780a9735a15cbd32c72d1192b9961b530d545e0c025d6a266427cad82b849c3dce1aecc504b6e01898de46f5033c38444dacd5baa37019410628a4e621e92df4f786178c4ec39b5c9055bb15d886f0d40915bc39ed11b6919c3ab666ce1327c951fcd365f255f1f7b947d7f514110381a7495387089c07f8878c5c17d8d81d98fe639526f8b6901e25862b2dd42bfc0b742dd95a1b4a55f656ebb6390c8bfa3c847f187f4902cbf9d4231b6e29b4ee5f2583f54e50e531c9667e609302aaa96a1f2f2ca5d493b83178fc5ced7d70fa614e5602f2a7ef68155b1970dfe66b9a034df03dce790839d7cdc237828f29abc237c05fc906b80f0f0a493685515d9aab8b1271254dd9972b907a576e0e9036eb2714d2b14738d24f69e4c85c125e6bfbb9b7b8a17126a99db8787ad00d83c3c56e48a9a2999b6318a02cb8595cdb6306d7f70a6de58cf928cb506c309ebd5b9ffaad4a428d100268438cccd678f995be5f70f62db886070aecf15bbb8bc9d19b6c58c53e56892d1c4e4ecafb1b660bba7396cbefc138e4cb7e13fc4cce1214b770d0ec05670d85158cad3e1cf1d03b2bbe26bbb0d26ad90b9e4c16ede2e3b34fc07238f5efe0350c2e90ad078ce219e93b9b96821aba7ce55eb7158935840da2361ef49322335ef82c04fa6f3da16d50e1b547b668239864d6bc7ca51af9e1fcc2c163e8edd90fa6c56b6a0119c6c3a3243141b36863da8738679b337feca393cde00965b1cc55a4eedadaed0de91a86be1d9132712e470c882e1d351817d37c3946953461eee3faa5b9eaa518bbb0805727fc07ed6a249b14b76cd405eecf5bb8ad1ef3cc8be535fdef8fc4166537e1b95756831d0809fd8fbbb5719b2647944b97c63dd3f8eecc8593750a38b2e5ea65ec72d7084b130332b4d6f2825a2af618f97e41487e4bce26d9525251823ee046b06726e10024e419e57c8ec8f14640556f8fadcec5cfebb415edbba19054ce222037d76442a44920491d9e510d6e048179b93905756e4c90a4e96ee8fd0a76a76858a345e9695d881e3840c92094dc8c96239342da1907e60a77fc94849cfad475c4cd4126a21a2e53c839ad94604917259909c0c8194919ddc84719ebf808a3b95135d517922789692eb20a01576dc32081bf7f005fcd0bcab6f490446a3e859b9ea9e75fb511e215dae6ce5556d0ad27fc534896f8201251678f7fa688918e2c117c578a66d621c511af75de16ed7423d0bbd2afdc679c9a8978fafca122c1cd867765c0e956a1c0d97e264f34967d9b0278c1339e37fb4784417cd7e910bcb280871fef91acbd614968b0676f5f93c96c6df9bb2249068a7b6ea521627a0c5d11e38a63da7e6d31647f9b38b153e9651b4c444c00b3850abd9f850ed0c9262139387330eac35ae9661f15874dc784a5342115666f19858758353ef727e21faf4ba48832157572104bdbabdd1d0a8352d20a6e0dcc02d6740e83a6ad0c9459ce8eb875163eae9fd7880eb1c312e4ebabb6d41e966f88274068b87deea606ae9750acd60018171bc355f70c2a52542f47f0d90f6996f998a36bad70f61d97dc248b57a8bd719ced093e31fd5847b09de5a011b0adfceb3e913476f926d30472163a9cde56adbb1fcb8381635e2c5c4bd8d27df3328301d1c21bcd7e7c6aba560524716104d46625758c7dc0f16cefaa4519b724817beb650ae4d59c631eec33a9ee859485651a565e423d5f746596b5567b1b8cbf683b61e95506319e989c7084f635aea65e073a0bef91c6c43a3624622b09e7e8ac3fcb21144b80a4ded0588a392a16cd1bf106aae4fef6c61abb5f41fe4e6c94d54a6042948261dedc0a99ce951de1d8641805248478d57b0e03465607a4b1f248b8193eb2f55e71b8c9f51a2d248b0b89345752797c50b0a479dc987cdf8222ef65019a9b436e04e6193e2e3c69865f35de061f50dc07a9b330bc04330ebe8f38ffcddf6724a5e7bc100da741a8389de13f515debb65aed5f994f5cfa09b5b7706f39b6dd33d4e8bcf4c986b76875dab21e9a4f2be4afa84760a083f1d4d534b5904295ed098ef05d820177c50c2f285b8720f7b1145f656dccf0c191256e17c68160d7455ecb19458b8db581a939aff3fa019890201836dd52a282d4b317f8a37ff8ceac5d27899a44c70be9cb70520cc79eb095a136b49c3679fa11a992e29","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
