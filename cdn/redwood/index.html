<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"4064591c2899c2e6b3d4cfdbababadf6ec98b46f7283e3b95d094dd3092ef9e512f1fb05ff037556bdd3e71a36d185cd6b280945cd466ac989c299df1b4c95440c53e8f4f2e6ec48ca4950bcea3496d93a58cd6084e3bb4ba35f018cb9c58aa55f9f62527c7b917ccd9bc7b71287aa428a9da1ae176f0c78c29d6131f474a9dbc3b3bff1292b0755d62ff5f539f8b7cc3174cf00528bc329994e6b1001452828e2f8059482ed15edbbd731187b47f46064982d456244d53a18bae3f9e08367b68ab1ee0f26878a851ebc06128c62e8f797fb0c1c691ffdc6eda55f4a9adc3bb405198b457f1d77c96affac2aecb8f511925bae6ffb0495009989f9d081b7dc337fbd34312174d28acb9645709e8f110c08a6a3258240e54ff94434743dc4141a6f1f3933ebcdb87f1c9cba8ff42858dfff151d00fac7d6c09b26e607cdb83c53ac01fd8eb1cc0aeed7500f0a82dc19b5c2fbd348880158a3c10c6240525fd5aee4f8b2366b6f2f9c70189a05c6e0cf4ea3d1596e4b58dd9d0cb5b54aaeb2df0a8f7dd3fe11eb97c9b87038571a1a818008d6ec7c3f5f7e8f21ffa545ac3d48d479183f558f05f44eac9e7da67c77e45664e8fa0b5feaebc202c0ab98b6afec29378a494c7f7b07bbc98f68b55030057c6fb64204a1cf90c94daa2a6e3439548e29bf6d37432e7042f9d3455a2f702517a128ec09ad5eb5ca4896f6f82c93bd2892f5d448bf3ed90c428bd3c669829a5795bad20005b1e0dfeac058e88375c0dbf97f4214ddcf9e80a8a6e387789c490086a93fcb1df1414e90c7d064bf4a46017dfda48cfc20a886ffa62bc821c51e1cd8e0953ad9296c65a72f0ebf92fdd5c903fcc6bd22ac5a6372579ee32c6b415813c321bff77dd43c23350a4d1cc8581f6de1bd9cd19ebcbb38ce12557c4a1e536c69a7b0d3fd9e6046308b33b87d76edaec3addd012679ff40799385852ba286d23b60531c9716df905726c7ee0062b754686024b268b395cb66451a601cf84ee595401a80335b04933e88df7e13b5f4debc0f2f87bfbdbb26b10a8593485e96eabfec668c3766567882546207f750ffdf486f629969f66a32a3e441cc18ad7400793114b06c9a9647f04fc741fa3d6ad1c566943842e86f3701627ba3c063b1454d23a565642c9651313a343d4bef169fbb3bde67c2550359c10fd0eae9be2d171b0fde6e43be64a2aae27d03c7160c35e00d13f0e323a8f44b18216a4665b16c912e4b68e14e308657edbdddf79ec0726e5d596adbad68dde623d8bc9f90023b48395727262a821b21e403b592d127bf086712e81144f357bef1ca70c78e74aa502eaaf53b4f3c8e66ec08cf9d81b9a4bbd2918c5286386408c077a56ab2ce35f39d14aca84d5dfdb3bb95e4cce8aa29b67d8c5e40055e0d14d83262cc9d371ff2f5c47d4a67eee10882e870a1e0718b8f857aed7ebf0e41e1dde89326cee6999a72dbe7b79a753217ab24252be21c83f4f69040ad981b4da55d5e770d5f3e0f67df30edc6b441f78cda31a7b5b754cc36e8948a4945bc70a7e6d37db5ae194d8c2f3a68159e1d826d636d4e3ca94665ee3f6520ed9e31145fac5bc398ed517ca50f361f4291471cbc118ff1f718e0e267051b7cb578cdc5d09e6e72252b98442a7d146409cf7b77a7dfc6c31656fea17138f2dba49cd9352398dc7a4df0031fcff37946d8f4a1050da771f995f7320ff22cb6a01ad5d0ee065b1fc6c11e05f91f943333cadefed66f3a696271fa98ec1a43a6cede4cbae7ced60597489f9f824d56c868b7412ba5cf01114f541d03894605382b0443e4bcd1b7d43a1f70ae60662f1da3ba7cf91ecdf58bc15c7ce3341ae42a94fd319560033cb521855f85c0e9fa8769f2107edc5879b699a0d21b11798be7498609c25800465d1ab1517d3d6145660a90c42a6afcd6926a6e8677124716078b6cc416bf12319ec4ce47fc97b404240e3af78463e1d2f7641b6188abfe0259d067679737dd95af2a9a37ac6b16068258d12e5f8d8fd146db759f77d3f225e546c95d761cda22f9a718f27a914fc4ad5126373c867a6e3ec644616a23ca85b785ec492700888e9d366617b141c32a1ecea62de5bb5873dfdb5d1fc337362333851d6c895665c2969ad61418d2ba582b534623c6e59d87aa13b87f2c3e0667b0eb99b084e5890b4304a6da79429c6a9a9a7682cb80d2778fb0d3f0d371bca4672bb41d2642950847cc5d3ab4c5b5ff746de5e8a2eb782c5fb0bceec643d3699fd58f240704b76182e263434df404db144cbb421e0e91049711c5148658c9faf8390ebe5355513bffc8e5dcfe6c899e43ad114c60069a15f5398be080816ded255711f4bc4be3fa9a833a812dbf0cba3d466d139506254abd106ad152fa8b5ba7afb45fcc251bfaa678a19a562590dc6701e56555cce095dd6a93fc2a8f3098aa1a3d6fdab5d0bcdcaa88cd399e66370a4a1765c5b2a37156c753944a2574f7fc656ecddf1bc62612090536e146ece4e50cfaa6a0800f02c6bdaa42d6cf7f2c59cae8ce44336dbdbbba6c7640ab033eb79d4ecf2a1494a1f5d2f4550b233edd9f53b289888b8b5c86bc4cffe198e5564428f7df6dff81475983df52c7d74abf82349ad6dc94833e80697ca79b51ba7868b9fb1f14dfb8edda6f5f17d689f271a02d6cd393a3e5f077e555733bb4b1f4aed1b7f08ef8cea803059ef9b139c512cdf8caf0d08816ed2451df8cf6c96c4268dc25c001ecaea2ad7bd737bdb5c3f6f36a1140967e478b1425609b6b54f4663bcd8f9d4401890691ec53a8a6c02765e50175416b18f18e6d9cf9d9daa995477c9653842a3d600d79d637a9ae7ddcd067021ceb61b79a298dfd4f7537f079bb593e52c12665a485669a298a95af54714193f63aaceb186e815c7757e66870567417e671861cdc6b93b81258a0e23a3841c0f3d63a3f9115a814fbd5a28f81bf0d085ca6ae154e04fe86a68eecf32cafc6f5d7e6ee6342fcbe4974b3dcdd9dfee59c05162e68b495bcce28f3e5620c4562a2566d3f0b453d616d828965122347cb9ff2ca932f92b91f1491613f275360470018721221894b66c8066681aab91b9301ce2fef2f7f47c48ff69e62d075a627adfaeefe478a97084b9668b2cca9019db4155e781f87210660beacb3689721c9f4a4d74e85947f1f362becfc7c5e967b74171c343fed2946710bbba8e13f67dfc61e035413c0ec779a698419274d75022bc2fdc6faf49620c880919d64fb67e301f59b347166befe3728418baff0dfc16d55b9f5a050255f095faef8de351d5468e5fa4c5d62d1159167b4d8145bb8fb38ef6481a8d7619f3ecb07fcb07f9cd61f0b16858a8b81964196462561c5beb999996a00367f767a434e07220c1f815522af471023799b425af709705cc09f4e964b8923bac82315476c8789ea90af56c34c61c1ec11ad916699f4bebb07d2d6413f8384a45c1e23f3222e45f442a0161509939cf9ab932a35a5290b0317cb94277cec29568eb44b0a793d32ceaccb56151075fafff791f0812e2faa7a218c11383c65c00810de9551feb3c2eee4dd6c98e3ee86f3c5a74f885cbd43f7cf2b5c54c8f228a100aba432740092455e9048aafbc966abe3c814eaff5251289fe7d83abcb1a923c2815d9d12c0fee5abbb958d9eec6fbfc179de652064504cc9639a7ee4c118e24d7a708bfc8cce5d09ce4113f248c887d16d46c353aefaab9f3784502f852c850b3b8bcf6ac08c4679843000421898be8f825ff6606314e66d9931576919cb30eba24a0c4e40c339eb88b2256dd400176c37fb9e8e403167a867f0bc074b45a66cf028f01d8631d72627af793c5a77d91959c7b415d43d0adcb287466ac443e3b1bf5536445ef3739abb96223a59f9f1f2cc55d5243d3b273a3f5d839ea26a5e0f302e49ec01eb9a54535141cc5a6217ef3873c55c95dcaaf3b222f0b203d35424f483050f00e7ebecc8900e97c8e5effe41220f56ad8929a887d2191947a74fdb4fff6019b8a7219bb4e9a35e6fa6914769475f2d1a0b63dfcd4d10ce72a901920648b9fb07673315b48c8e31328bf33410fbe50a9c716bb1844a43ae5beab58ba2489be92c25abc4710309020d7d9196aeac4149b8f50c8d684ed6543045d32c9b4d96f0ef8ff480a953d9a06989e7974c48d7ee887bece237048499f72270486bd720b5b441bab05e6a036c77479dddb67add99c706fabd05af65b399ed2030af28a4ccec3ef50d8f9e5e6acc910e512d528e4411a0ac323592e067ea469feddf93e128117359741795e798fb2474d0e422e44408eb927ca52d318fe70ea3a978619c4e3c525c2921c788149a96f44ab35d3877def092fd7b6b36ef5370755740dd07d1d9a2d0612124d92e638a834103e38b88a6ca3e89a9ba93826ebe399f3ae5797d8b296638e6b040830f14ea00f523583326f04643b6007093986e9583cb39dcbe3284c5d91f5a3316f86efdc5573731eab69f3fdd5abf17c9b736e30d5003195e2de1a459c042105456d7003ca5ef7c37e1dada6f456e082ff13c149d720ce7b3f630d021d03ea5e8d4150ab0664de4db35ab76d20d775b880847123e63eac064a924b048c842661285d51da5dfe0d516aaa9a2573ff8d38d65ba9fde9fb6971e8962934962c2c1299b21ecefc97fc91e2a85b9a2e5a58c99d79458cb25f517510929e5cc1be181a53955357efb2ebd7c5e6ed98b3706329026f3fa887c8021b04e48b71a4150088b5826d9ed06936c889a14042f2df5ac9b0ed5d5520a42c0c57dad4dde90d8d9bd382d083e921d0c0045b3acc3a003503ddecda62cf50db8377a941b3fe183416827fcb856202e32a2cd3eb1a55fb77602206e6361745cd8fe792604c8f09a0628324bbd17239fc3bd5e9d8906d0cfd4d8da9ad1ef6457b79c6c1793ee0d72c248fb4bb350f108cbaafc90385c68ff4cebb4364a5d59719fcbaf2374e1cd9014c836e74ae24b28c739db2bf9857f9193e45347417b681f1224cb42d28fb70f1febe8492fe8205955a1ff506da78b26df61f053cc6a15b950317c20e1bc6bdb01a892b8488b6b169af3eadd06e8516cb89c3f1aa3929b7b1121a65d42f7494944184acd19b40b05597d274ebea2ca029535cda0f408a69934642c90be2c9c57cf4c885db5f8bf7568504024420ab6cb05cdd035eb105118f930f64ef4fb66e9ba0095314093d2cb0cf2dc432fcd176c956d0389e54e9df909be83107fb6c90e6c8f209fd1860dda4dec16982b4ac426300a78dbbf4760bd6c2c0c30ab22ba4c97afe91d63ad8d656082fd96b1b978e48819e4a6c8b2462381fb773e6070a0b659b7bb7069e3e79a6b68c324db65d8f124b976e68a3f9c4203ed3f5e9bef0184d6f1a20ada6b9690153f91d0a9a1b503267d3447bd302414f3de75fc161b76942cc1f695bb7ce5ce100c93a79d9a114f807482afc0cd6ece0a3a968fdc9be54811bc0bc697c079b8f3fe88933891f03fe6754679dc3fd996de4f05902c25035063bb4858dc0c572be956236eb1fb18d500db332818ba44960e6c9bbe22920b9d2201ade831c656dcd7327ea9f7977715b4e461483087f7a3b7220b1bf11597f7ad3e5374e24f78a1afbe727f02699973547bb7b5664c5dac04d9a3af64691968c0edbacd3b22f3fb26ea3c84e2ab8b6fa1ead3f043c6fddb75316acf26bb52c01dd8140ba592489ad1635d8bdacea2f7597fd21a5be7aded9727630105328798bcb2e0e09c60aad7b5f9ffaaef7416646635ab0c5988ad504600d01157b67f31a13d96d1762199d0f9458d37967ebc16361187f7a82dc11e7cbbf61997e16428a74cb57339bd6de70177cf4dca84be428d06d683541a7a687bd8d070a3a8e86d8761c015e152f60bcd4166222e181afe9d8802791571baf1b36f6a179ad70c70f389770993f2392c8dc33d1b76d57fa3e4229c5ff5f65a1ad42e06f9501f883482db244daee085f03886866263f78d9d71028d36b2a66a26d3ab1db358a292d9b589c4456a66e31b006572f9b83798071b7ec563a15ed4e59f1333b93af91dec38f66d9a8ece0e0b86c38eefc011e53abcfb404bc5c869354f0746abc40b67206536fe01ab8c1324a72bf5a43f106f0a7525bdcde70de71a6a52242fcf4afff2cb3d526635fb06010bf3f12fb9f3a276df44bd94f07839ebe85e6ca23106b1c11c14ff25d8663f2e762b83b5f52d2a2a2f61c6f8c9431a8586dc1f5d5063c2da738865a2c2b7f808de06ab905c1246fe6bcc303be5961dc42d360dd40e3c529b83bb306d154966496a16aebeceb58e8663309e8567c1bf6c783c2507df759bf62164127afa49cf8f3cef782ebb2fe3cc103a59cf4d860f3348098aaa114200959fcf16cf72cbb4caae67624637c5b6db7302726b7ba83bd276ea72a092638c1a5dfc546aebfedebef11d3a500b6eee613ca8aa522315c27f044c94f17389ba84bfdee7af0d1af2929797f6f1a76743f0a55e1c527d930db70aef4297a45fd0ea6f0ccb42a11c8ca6edbc06430e0c425a4496920f8b64bf6a7933f82e07c48284884a89a08f10f66c3aa1c4599e6811416c89716cf047c7876bbd6486e852fa3c53dee8af2c12206ce654cb6fa92c4a5ad3430c1fdd4f8ec632cca2f756cf279acbd1bcd87244449e7bfbd0499bc3db04cdc660251432bb09ed1ab36d5f7c307bc03a87c0392b85ff10dc58000ee3c12da86650060251b86f94b251efb9d73d3c863c181b0a50ec27ff5dfe6d9cfafdccc31ff1b4fa7ac253af941451a474c3e450560f00c5198f42e14a7171d95c48ac680551777699a9f62678bb4d09cf6fa1131abf183ec26fc6a71285ca8d384e4f9ec33d664683f84b0074f7305e879db1f6ccb617340317f466b7b839baf3abf1d8c09d2791ce7dc01afab27bf85f2ee04fa031ba5bbd88198f53955eca9022e2c6ff29bc3b847e0ea54ccf52732e046f939ae96ae7541bf9354aefce8e1d7b5c2ba2b37789b5432b933db518878c25947db4dd4e364e5a9a283f44451862311a44d2119482ff49be4dfb908d50b900c564681c0a0e6578ddcd304ec8668b7aa6cb33248acadad68b29ad0417fc5fd992d72ee218b1eafe71914be1162b053f29a37bbaf0f04a708e5ed8ba0cbdbdbd22312377fa296393a9cb47229cbb6a43c9aadf9a08bb9e69394f4a9c377e900c7a81ea51f65f2a3ad98dbaa14509dcb52fd3f990cce75871f0ee47505cb2aaa9ebfba5df21bee4c5b45928077ab5bb031b919a97cbff6226072b942434bd7352400ea09843337e24a8c13d0508fc2ccd77b2f64401171ded7875cef0909d08b05623d34b4283e50c1474cb5eb3f9dce0808456111ebed7969569ede48f26135e4115d7f9aeb6d1e946c435f7f4cbd3df81e2183c94efef8af7790518d5ffca7d472d3689f95e74e658a9563637c9ecdf2ca4829f0b5d8d15d3ca6a69e1b870edb074fcd9fc4600886314d6284384aee1a562e26f1e97e667f18ff9a6d63e4e767e191c427a193cd9f74384e5c4af7894215a9a2c40ead1b7550a17171a6eee19da4b9946d52fa44060cbaca9a995a32d7cfe225ce4ea15195af93f8943bae4364461a736b2f9fc4d5bf9adcae812aa75a728c1ae43193a3333df06d06beeb367c87d95b3bffdea9352374d4d801a4cf68af196c38552a1760a859587abb3b4de541b8806f9f44f7aa66b226ca3c9b0f5a846ca2a2127360e67480042c13fa2e2725bbe10ea8a00dc373e1f32f5e407e1c86f9bcc455c73764a742032921d22d9e0e7d80f4c1d7fe91d705506527af611504494b36aa34be49bfbbb5757ce38369adf93e92333792bcee4c45403d9f7861b51463f858d049f7e3dc3de233ee287e0ef0186ffae722230b83d525cfe4c2e80f73a4856d5e2eb49c5e5e93fc965447ef16a5aa0ca7cb3210abab19ab95aa50704a4daee5db972b0ed2cbaf2f6a33405e81e4229c6110c3baa12c91dfd941676aadb9d9891f5d1f5db620e69a59bd8d786af6a063216809a1a8153f688db5ea1436fcfb7c220cf9e5cb5a3986db006da0f379a67fa67ebd3695d52e4512254aa27ac13a638fe65e79e4e7883e2688744f8640964d5d735ae772403cf0932e18d04f5978c6724d3f9a38038f04ebcc94912f5f899d3614137cfe7f10d4e9d30f2746bf8042e326672fc9b0aa2dc11fbf2ae4a1be9a0819f0363a9669c0aecd563ac5439ab937ec6132503de6a9d477c7d9c58609a416ff154e903208f11e9e6bc7cb18c0cc55ba8e7ca4e8ae3995baf6aea362bbf6af2c13c0fec2f967b7eb2b693630e52e4aa5776a38be838c13b3c3eac61501a9c38d3607bafd34e3f6d0e110da86e60101bbf4b220bcc3f2de6c3836ce352a4085b4c75180e21fd3f31155ead405cb4445080f851bc9d9983d811fa5bf0d5129dd6724243380ea1e33b0460333474b3e4ecec7f88af8fc5c0d44bb1c551dc2a1a9ff16152f9b828fd9e11b22273a4a57b356fc27ee7a427eb9981307b237dd31fdfb07d3cc95a6dee71c7f7a30eb1e416810274e73a0a1c3c9a75e6308dc51fbc50bbdeef97f775c1d69364e40c2d40a34d4212f7e07a6228cab7afa60d5f9c4bd0a7997900de686032dee772696fadc3cdb2f22bfa0bb9d3e1f6e7559ec2d888bf95d13e52b3c9e96a27912294cbd77046321cd6dcf08ec5b95b85729b5953661723882fedd1b0feb17bbb541c31a1ee70b3febe732ad6e8fa3997958b738136d50d9e7c8425c21e106ecacd60831fac119e8be212cd1e20596f5bba8e287d5c1475f258638a944de534135c2819a432c40427141e844181eb1b319e9cfa1de66e38620e7af751748e9ae3e9ef3bf2c43f89e139554a07430112d01513c0f0e850318c3d517a1964fbcfc26766c1d6e171e257fa41bd34fba10f4eba5c0694231af6c3dd88eef381dbe6dd5a4ab926ed3c9f1132155b4b51cc0c2e027800eba9ce002503abe8736b9d2ccd8f80df37b8f8f67df66d407fedb5a4c38e4bf7e088fd413996a41b8384170bb9a1cbf059c2477dcde751b526d02fb6dcc0375a05de6547722229179347ae058633202f2c00b6c77adc0904809e6745583b0f86ed8313d3bcf723f3322f1573c81463f28ac2cc6021df1ed9ceb7458eec6bcd4de697f3c9e4dd98e66989313993d54382521594ed3df338247e3d16b841ba1e06a7f468671681164e59d13a8ea8fac4774113711151ddb27402b88e322cee3cdb2e49cded81773a5817c88305d0eb9e47b68c658ba571bf779fc310b9dece0c4c84039389e43e306e92352ffa6fb8716146cdc7ebd484f7bfedc22fb535b46fa53227107c9da1d2eb1519075a02d642e1c465ef13c53cb7625230072f92fae52bba69188467308fa33e02e04365f523b668016f7b19c68ac62c5e18e9d515f2a8106ccb3ff4eccd27b96d5dd36cf3fd542a5fcb7be45d41948a57463bae6014c7809f27633f4fb515260768a3ce9b545314e6558c2efc24a8d46ba74f2766f33ae8aecb27ea42742402d6f2a40c17b64c4adffa006db9ad8b17b74fd16fff188b1558bacef610a347dfdb9e5360260cb6f1a1d0b7baa44e1c2e5e1be6061d4e2abe8b0d1eb230bbba8cb43eb10ff19983e9088c06002b5bf24d1e0c0a8e89005885c5d222e65b00563fbfe2cefefb01d6e3efde05a505ed01264dfb1cf1385c38af42018e2cf2b1977c20409b658d558a6eaf65c91204a7f254a30ca85faa5ddcd054712409e0c981d64f44e5cdb0abc0c304d102e0b5cf60c411dc34e3f45b228c1dab4cf389152c4e1b488eb40dc78fbb466b778119adebec4c101204e80aaf692c584c56e15c4bd6a2f8fc88e75fe345a6dae03b1def8dbea66331e4578d7dca171ecb46b76c1e2d2b8bd75badbba99a1e774061d0b9dd5e5122ce372d5b5b0e389c21340ee5b18380f4676cd5d9e34ec3257028119f68afd36fbe7278d1fae20bf1fd5377d3e0f96fb8dc75591ae1462a223dcbb6ed142538804fd8665c80a29be9c864617f863f3f124bea334d5d33f1c8daf0fdb4660acb998dbba138b44463d4bd834d400213a5b15c63076ab1bb8c2d0d8c966a57fd1cd5cdf94e56d2dffb1d6014f9980993d23423996d11b6d13c618c0227fa9303e7deecdf06cc10df3e5ff813b6eb66916b6619dd88a89810f9cc7ba835676c5486f95bbd7a6715db8691d42b3f0fa55f0288245f9d930a5b03e7c7fd4ab1d6c9c5b168e9fae4bd38b64108e6a68860ed197220140c7459454df72a37a06e5709c17988f305cbf064759d3cdadc28af7427ac2e6afcc88cd83c2b5ab6cb32fb3fb09241a62609e94de10444937b096c1ea221a376f516556f29448a69b656124ca2c7a18b07492f43476ec09647a133f5cc69a0b27993becbb83d0113978767343c109a8ac94d51cf123cf03dbde985d5912b25af7fd5fb8e77a1ce4c153032e0557bb6df73861d9bd65532f7368a8b3f3dbafcd2107aa03eb764df9ca24e8b79e79f9d316033e5ac74134baf26810ad92e7595ec6ab07693a0005a05848c430fefb31d4f56b7d704dba7f6fa2b8276395d3d7070f77651867c8ca0021d4073b98077ecbdce734ecd598e4e513145d5a15df77d470e85c48b82c7ece5db3bd9a7d121b080e8f90154ae85205ccec3559bd0afbd8a4d493e9c4e20bb6ecc8f99c62f0236f2b8b68c23d0dddf12b40c3e812c5bc2e56dd976023b25c862163945018893a6be0702820b5a78082f32c0bdc3b1a7578b9fd30deb7d1391e90e7f12426ff624fb43debb8ce90c709391c6b1111d01b5fef37ba1fedead17b932c4241eee1e389dc929647f9c995c0f3693a84c713ef934638cde45bb129266eab220a7e341aaf1a75c0126f8a9d0f2f01fe1f42f94d048e2a8f82ad7b530876e164d798d9d9e1b30a978a1ae9257be8be49e1bc4ad9271550dcbf6b2f9a327c50b0a3ff0dca9e5c26f4488ad4a71775d4add48b9c683c21fb85f2393b3100a47d60c4844fbd7ff5f5a3fe437d366b2296a9685d00e7e84ffeee7118f70c8d359acea96e42781bc7d52045e040fb0966cb6a4f2649f4314ae65b8bbe3bef70dc777b9d47332ac90ada7300b03648eb5d620288d46288d3b2403da10bae3b27ba34db5337fd3e32a757ad0a54f7c716351c332a218aacdb902e3825b367baa5e0328ed4ac71043009ed5f9d3c1cd30edadfe14d341284bfda86f0738cb687cc29b0a07b32a1eb883f8c75b068ddf1d34b3c19f1862bf26934c8ce159c1a4b7d284be4211c083e15e4c84ac54ca9d9a470e6da751a38e856cea776d43e53ebc04837de81f370b582c45e64ebad6009eaeff6a9e07dffbea1b6ad88a3fbadbc4cefa7aca45c0fefa57cbf392d253fac37605c0d2a4d4be7ab66b7bf09170b197dd52e1632270b73c792eb4897ff0c721973b9131a98392aa5c46bd93b98ba0e6295b6d2f167ff55cdeaaf5ed5f66d460bdddc498ef082cd5807f1ddee88fc4932bc581db00ccee3acf5dc86a9e4cd2981efcf3a82af6c7b9297fc223578753484f93aafe23ae13479ff0fcf4935c042a3182c2a4ed39f5867c2a00a36bdb2d85db3b6c36b195402fd8530152250e17d2b0c536da1fcc4ab95fb324e40ffc7d3bfa45c7034aaba2f5e77e285eec07d707f0f87a323f91e7bfb8b323cfccbf65ba8d01d446b16dfbc8be7dc77659bd9f9f09c04c657278bc087144f94506258722069611e8257b258daaeb76ed9ff61f80158870abeb5751a306d3632e4264e9f23024ba54a5cdc0919c30960bde536f69e5fc521f6e7c6d27fba9bfd0cf2dde37591259895bdc07cce116e61a4eb865765cc6cf8f8ba056f166e5be8113c6f88164c2066d39402f4c5322a01a7177f0581e6636d7b6fb39b3443ca8cc32a5e77b69ac74584dabb9f7e88128ccaaba355ca1ee9b00cf1b5bab69729db2a923c9635f01fc0fe6539e43dbd68c853e9bc757a624fdd8bfb07c851083518cc3f2c3252c8f9efaf8247ddfd83a53888978f69be0bf6206c8566c95e3370991f0e016e7112b288d70709dd9869afb8e4ffd22226a75c8289c80009a9355e01f57ef7f3787dba16492c94c0f5f39618da11b1509d7333493cabfb56c88c911075db137caa83c7fea7b85aa505af425a1a11115b993a8c6481427ff13919fc5f1132e18e63ee31b23d1a16faa447acabe43ddfcb910699cb1e29ba77a62ec997919124f50721bcc72e091f77b6ef501b96c27e3252e90f18966b75c71ebfb55c88d4a0f358fed17e545ee1c7a6b7b9eb6281cb7c3dc562ceb91899d1f375e461a60066e74241feea66cf8d5290610e152f968adfc2897d9723ddc1ef7559128b3e150ae7791716b561f0c818b69292117232452b2a9d1254121f80d71af48bc2fea8e279d18755e130134e742427e57ca7b68e129ba77082b365bcd7455a0267d2f9beb6c9f65b08a4e2d23d1960b55326adc83a9c51b25b808cbcf21926e1860387cfec866b6ab3d0b66d2abfa70cead0d05978bce1ad38e46949c26b6c05d581dd128e7e44cc33493abc6b84e10a680692c98446a8b0ff672c5519f69a86a4ad74d29c4b016e9293b3fd825d55c80089ac8ea28f038f008a587ada0d4331c6de09a0da3e2f81887005df3e3f8c9496a8f22a08ada91bdf1305d7b98ca68368876aff124e64d702fd0504b015bfd0a9e09a7de54ba9336ed92f40d166caa68a6ec66a5e3bf39237db0892e88e0d4a67d57e425f1fa4b590b20491a1947985e6a6b12d310e1e3d387e4ee5387be7d69cc9e43eae6f4514ade268ea7bcb9043ed8d3e2084e44ec0735f39b1940ffecdea23c26a3a971328832bf8e122ecea7ea73b4f942d27cbd49d563ac8fe107b33d61aed1a457f8164fd734bf075b18a4c3eb7ea5e9169601fd87b5288234708598b8e7870d8a0143a7bdf552941f5fcc1e9479b0319e142fc7deba9c8184a863b2502935f9a55734d9007336eab63e8df1b487077a30272bb4cd4dddd10b1089e504307a6dd26a2cc3437676364e19cc2078e225929424576659e8802c7b0fd4e08ae3282612d66deed095b0a254685c917c4d96fa762bdf2d5055e36c00caccb94fd9357bfa82eecaec7c006aa8777bb16dbec5cc40f41675e3fc884ab162c36855c668d6071fa398735daa0ff82f37027efedf63bfc8c50ffe5580271c91833c2cbc7567378f9d4ecb13ce4cd6f73dafcef7a4125ce3b64a7d60baf1704c32ee2f5c2fe72c22fd96930f2635a9b16e5cc8366c169e946f4027f31f258d4b7850eb85a7a59cd6adb841da6d61bbd06c259cf2cf2916f1ec0c71c32bbb41808952ec2bca88a846178f6811005182ed3e07316a534e2097775f69256e8742347b46f3dd20bef1deab0b9564fc8e9a302d8d655d084d59011cafb28107c3d151ddd571fde5e9546b712aebc35e9edf9fc5cb04374152c007d30b82fe29e67ee2eec1a5b61b5621429e39faf8e27ee6d730365bae17e5b29cc4c71b73877c84ae8bd880153f17db4b7c16599e509379f9c9e8491fbe7b2b09d944908dd5cb4c0ca5740b3fccf6acefd888f982d0bd1e6ca73df54def7be52a8cf5c923f3fb29c8d951cd86fc3be0d42476d1bfe0b71d8a00316784e500f569d6c4fa4f9f74cd2f4b7e7ef55896a301e24218f283cf19aa1e66b594a701f8ac9d426ef8766b93eb6f8179164a3e6149953688db9726aee3743e6fa9c0b34087d038725c0e83c998150aa72af80dfe04a25b183ccec5758ec470ccbc4867bb7750fad4f7c02ca6fb2a86bf3d3b7268de420d45d79b98e98edb0f23da8ad004156e42b44a7cccf9d5dbe1d1f191754f8159030dc67720e8737a85980c8f01473225fc3243ef3228f388dd36d656eabaafef00b94802cbed8d15b8024d1dac42f582b427cd157537ba70e68362dcff61ff298bb400a67be81be210bc9a50aafd09ee7cca2011fb97ec8c5b21b11a5c9734a12104857cd8dd822ee136d45c26e62f801d325852a23f822260ed290d7e384757b500fa955f841572add84d04cc7160038fd7418cd93d8095d7ccb07222bcae66041ad153759a3fe343a05b2956324f6abfb3916f55bc86295d848849f33a1dc893aecced9ab4e552707cc5a7a5da1ce77114307f1dd1abc17a91f7e20d261250a18fa9f02e17b95ae16c792401293a296c990ec241ef1b2767e3005d507ea515c581a12ccecc9f40594585884e5753665e9aa4c5ac90bdcb2a2e5755c3a46ecacecdc36fc81b4fa1a6f00784b944e6479965f1a1d8c254750ad50a0e24e9c37147e147ea7e7518b0709ad8d3569cd7b4eafb4939663e27a7bcd9c4fc9ef11e8dc350db8009ebc71770e1ee6dcda544093701c08924939338e36d07095b4468d3fe948d2dbe1343393b2e36968ecebbd7ed2904b468dd620b23cbee11bad99eb59887dcdf21c589c5cc7e776ea279d2f681b656d2f71dbde9c7a174c0b2054f84377b282c38acecda26eff1b5d19cd276fca034000a12c7cadef1cae8f381b75716b2c613fc8481b00b35d2bf90a18603868d2af2b3edb6614dc71f69245dc5e7f15ee5891f19d15fbfd48a9c381c80eca569d5823a217c2da4349d4c2e94ce439dbeee092f471ffed2ecf7af72a7ae46a2ddbe9b70890ac4e7dd0b1c3566856adeb1d327a9f24e0b24e55d6789ba83908859bdfa4e1786fbb24091d6fa020e726a927230de3d000cc002028319ab3c409813e87ee3bb9994b53ebb043f472447ed4687b21e185ffc6e9de7bce6ec6049644b333b573c85e2cecdedff014d84f57059944614124483d1787e9b12fb8cafdff2589b467887ef049ef5398b8b9e67dd96fd5fec79db439bc1905f16f98f910e61e2dd4cc41cd3514bcfab9f72819f5390cda73048986c493befdce281879d3b285538f07edafb074b14b0ce7cd37b9f8ddc63700ab362dd4d35821ac5926e21ca7219f85fd4698cf5442b33b92dc93e6cdf48efd0f7e393e8a2e3eeebc4013d59e27c3e2b72a1f716f868d31465668ce16d2696d217a52ab3064ff5919c162e4b3f7856aa2542c28241ac8f27df0a4284471c86ec5ff0921372aeba68260d06a7116735dcff27f635e512071613b295ac68a8b52aa9b5bf290a2424f99007b07a968e001cad7c675886f89750c9232738ff396bcf970348f988c39911ede14ea2c4994a3353afe5fe8d12853bf0e5361a3efae0d0b886ac8da5b2b6eff5a59d2fe0dfe5f8c169297e5002ebdbf7492ee377f47e2503a44b13edb423fb5c8b7763a0f030d49f0021e7ab67d9534080189867a4d0cedac1455d0203d52a14a021abdb761d2944e715b357348a916e70e32595f9b778bad75b9179dc500bc14cff9a0505c7452ec2dd093494fc0116d339db81f702ba375542c2ef528352777b3731b25fe8c43dca60f817798fb375008c34ae14a1bc9a7322bea90b1b9f3fcd248a84d03bf8fef3c89cee6461411766763b67673ef5137c6bd33555e32d6814d9e9a98aae5ed10783c4053af4c187c50bba59606813c963454e1c7f6921867f806b10d328c7d09e75e031b808abc458e6c03a24cb68c71481525b696ff765d780ec14252a3f5320608ef5a8bd9a571283bdf28abb81f132e3318c376474460a4867c4e0609789f38fa62539d7e753b087d97c0526e805109f251b6f896882ed908715fe13750befa26ad3f656f12800a580639354550ee8807579bde7a9e52660336910c286c92dc63b6a84d10b818e405e2aad033b2c5e3aa1b45c9e7f37cd46c3988e0505afb296a1624402f482a0e5e6da3610d1ca0d3b248597632db1b5f2946f6524866c47a32936f554aaa540589ec55cd4559b0f23de6b36dffd4618e5df23fd6feb22bc396552225afd0c35a8ffe71483bf12e6330ef67d07b828ff7e2044e200b2030901bb18d0a810582ccd32096be8182bafed3926dab32c3e1c2e46a0b071877186ef0966e84c5936c7ebd0cf3cd339f524f0d6fc09156cdeed0db541314da2d384c41eec342cfb2821c55600699fc488b259275292ac5bb28b85322fca1a883cd7355eec9bf26af7241ee5c3be1cb05f0ab1499a761c324e94b48c0db8b15768217ac4f5eec8a92733b78e52d5c8df40ccf8240f887c138592b161ee92795bfd5c344ddf4924f557ac7d851dd1036f1d8f01b6c9d3502a575dd5458532081f3700ff747816beb590dd9e50d74ac6a09b44264519b81f43c9578cbb9dfd7e1b1a91ea34125426d1b23fd321ab6333a848908be7a2142345536a1e47431c3b5b87ab5fadb2708918c62d116df52764fe88218a225c590963540c279004b549ad11fb793870caa6dd446031710beef20e01336016cb9e33d2d6bd34aacbd18d20b94bb5ea6d8dd9fda240dfe51733862f71a6c652091c4aa2a12cbcf2f27f97b6a6f1402e7927f2db99206396c9bac8cc9827035e209d42ec27190f4913875a3e963573f26c3b29fd791731e551cfd68f5b2de7831e72204c6222039fc9af3d38c4b03b05082d083e3972980359cce0d53b434c29e5d1754c7971d6c99b73c4b6be4428fb732fadee4137b1e81adef484531f959cefd4f7127c30394d70725fc7ccc61f22c7275b8cad989642454ea82ff6c81de3694e86ef8db7f5d3068aaa550dbcba23618292c8ad1a4e54fe24e30efb3c64bdeb07f52c96adf8813e2fbe7dcf2b593b291c0c3450ee0c5a5846a0c6437991cd5179c7f1e1f23cf91cc2375d17b0ca303de4901423b42ef3784d823fea2bec788d06b396a526cf6ba39217f488251499231070e63fd0e9989bb1577856e6fd0bbcd6d98ef746942f49fce7357d9660edbd0e629112a10cb47c539b0f9764fccc97fa41d841924efc80672c0e05e9b379b2b20717ebfeb647647d12f486790e4bab3014afff49e9d909ce7b739aebf134220c9c949fa6deb1b8dd412b8a7aaa238b7ecebb3ac61cc0abaa3d00473b45f7406099397902a2596a94a9ab586c3a4862f98b86a8ef2d6c09b0570ee489ec3ec084acb0cb194edba7d3953467e1c14c2859522db5f7b457a3437dd727194f1b2a4dccbfc0547eb64b6a5e3768bcfcca35122a283a231e58d9bb7ba23264257657fbcf6598c4a99964eadced87f3099de5cefdf61344ad916f8f0b936dee7d65f44b083d737a8162fa0f44a1b06764d0316e40ca09afe8c3dab2dd2e99a5aec676d32bba7a9646a0122eeab1c1e53f987cc1f33b55d237923d912e351d320060859a62a58a8f2f44bd5b431bcc25ac108871001fc5bb722ba3228899ef587f58a374fe15379a3e3f880e5b3e20c75f071b0d7cddfe5045f73b649435edb5e35813fee82b22c10df2e28c28a3af937b056c36d8f926b129ac7a2f6763a08617df88e9f133ac8fef56b11d8f5d3aafd9dd8efd534882b29deecd779d40f1d181fb9cf92bd542facb55f138770a90865e277275538672c4336b1236511ee82d87e4a5b1421c584195daf70dd20502c4955cc5ab421a04aa733dcf77ad27a757b5a0aac1e0ec658c14f0ce24d9222cd70980b9605afb0ce11ab920edd068d6be0b3b720472a93ce1e85777efdd8a16aa36ad866dcfb858d4a0be115f62989e310ed6977b4d0cfac63b37994f0d014cc9378f06c0d87c9ad5b15422eb4c82a0c4b8df8df3e6c7d5322d3f480e97612f59394ad451ee62afc3d736b70b5184e2b35b23a88c69d0598fa56c6da0379ad95ace52bffd418c7d8bcd16f75c00552de32ffb93bd22ff01161abf1ed567e46c3591d8c01fa8fd0ce9f9557f17a623e447b2406900f00886967be18a0667e6e56637798af19e04384dee2608210ebb3a57e85bb5ec7532a8f13d4489fc0a856ef843f5a2076bdc47463b937f0e2805527f34da855b1224d94809e8c13e337225dc3c5449958c38d9714ce9320ef8b61bce45cd25f7e7a459a135cee2515dbcc63d0d843ac664cc1a9e2150f1e383783f832917bffca7caebfe8e4a0c2fa8593f835614d6ec67427a5b8add569aa1c127760591aa68391a0d91e07a02a11b7104bcde1a1495fadf002c03030e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
