<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9788bac5c29ef48edb74c77e84e602a5b6f7e44c9ccf3dae18e6685dda489d1d211a8607e9ab2f2e6a451430e281db1968c218d891cddbe24c494b668e85fbba8da06b022c93bf94f03f2138c4d50754949337f87851d0e0d3f1d1a7e22a835d7c50d63aed6c84b77cce07863cab861d7887cdd97f42c0c7faf7880113ec405410a0905c78520000f96d38d1e8a7e3824863d0c0e3ed79b536f1d5e7b25ef9a7a626e1c2a6f1cb821fa0a4fe1fe72fd1df4c8f1068a689d1680f5caccca3d915b91910dbf95b2131163ff84b18f5595db5eb9cda27f54ec328c6fa5c08ac99dcf2b7f3a10a4d5cd8c1742f6e1de4385b3b4668ae2166cd02153e361205bf9d3edaab404de88368244b8adbb9c5ca7f4f257f9fe531ad1d6f05c3f3c004f73940cb985449e282d50494c9cd0ad555b5353309336b08f42735132d6064e8d909c18ce41ed3ce69725b2a102d4be42efc93fa1f947bd985d4079501fe45cad4c4094488e84d45a723bc00ed2195f7ade24568932a9f62110c874d8d88f3c4614eb76a96cde6c25dc8e2f3c0f560229f1a3924fb166a405dc7b9f277f9f7d69df9e4aa875b420fe55fb15a4f8bac5b23c9a6125b02973d8f0ca481d5907fb4b7e728fedbeeff29cf31df6cd4a9eb3eeb908b01408edad463e78ab8f17ebcd44f31ef094f6f46f2c19bd204ed2c4f804554314720af4ce2caee5e15baf6344f5d8e4f1c412f178ac0275b45d64548f464be615bb4040d88bcfd9113949203407c9712b6e5dbb98fa5f94d542b537fb10ccc7cc3aa88ba7291a7352ec17c9457a08cbe4934da982d8a17858b83082d1537e381ad144d819aefce1b6278d9cc76f693b1de1e26a4bd47d712fd3ea9a1ea9431f4319142c7479aa02a528f971c5376446cd49a524474fe4057c470e039fc1a3b460cc91a8e62fab438ffabca681d00ba6acfbd21cca0e1b73d1284f6178b1be439742b3a85934a0be68d1a6a9e98e1ddceb9c8abb066f6ee9ddf53994b468d1a30cd461c2815b6ae4a2989291ea16ec290f0e2193e6fc98301411a3e63aecb5c8a565a066ac771dddc5d7a8c1628e12fc7b1a929e683c260825aad5e4302135b5631d0b5fa34707ca411c53be54504dfac22a4da0eaaa703bb80a73f0adf37f242b3c311de87a61daced6eaeacb6500ffaeaefe19a93f1f4ef5296119c8c1f05d02b3632de4917ce2f9264758a8b1943812b244947de047e74e3934142cd4f3cdb4b7d3d3ecfa43223b981596f5a7a48a933e68b1a559a6c9354cd966550428a75acad6b6dbf5f76672345159062802c3b031c15bb4dd3defd6348b49ec6398437584ecc5487cb20bc419ce8ecc353ecb5ae1db8310a0f87cdd589c1f33b6e546c29b2dd5af4e4dead21b3af86c765741cb5ad9eb2a4dea57d1fddd1f9a0cb91af8ff56d1e5f68ef80d9e819aa16711e671e16d6da7e581ed932f1833277aee8986b459a987ea2d6821f94c6407ec64efa0be8b0257581002622a4b61f873b8059c12af8d57febbbf400be546b7866114b90ec62cf4b70317848007e36a916967e6f28599d0715186c3fc7a24b826c19b08bd5c063c186f9f4192e83610bf191111c2a39e7227c0eaf70f8dd90d6ae4a7082d6ff6a33a3893eb22fc8bf508dde12668090d5d12c2a0890e5ea6488ca5e9f418ce55b1f5aba040625382b43d313b3e88ad20457b96ddf3e51e82ca62d29c5046160e2a13e4c1b6ab36d2c8925eea1af59347af8de8b9b908f473b02143cf0367cf1653ef955ccab2260cda716ce75c894f1650d3ba0c98e5a539fd325435f0d2881ff30e191a6cdb4a97a0026818b3a388f9e136699662acf6a6db3417179df1988e1bd5d0b98b5afc1ee031f567e6fd5252ea61da7d8b4da96de9f498e52d41fc71a483f4556a50eb35924016926cfc033de3dd7ea15c2d80f5d7137e0b60067535fe00c42e80daa5083f070d4af2ca50250683a026758ebd2569b360ec2389ead853f1444be0c5a841e633548d6b6baa231d3e5cdb0cb80f9993a2b7e52622c353438c9118337d2dea91bb69a154f9d37604e83f91d26ead8d9a7866366a65034898f454ce346d2b12b8edacfb4278c6c327dd4a5fd93d2d51aed62cb72c70d06d27641ec9ac0c23241c18a60c354ec47c5ac0ee6a7a2e0025b47bbbe6d79a2b9ba77a50ed10dde2d7100b8f701f824f47b665eb252da95bdf8008f70c7e41a4ff9b7c2da3fd52d4154676f79c0eefaace6494323566a71cff7c1dc8ab4f3a156022765552dc9c85b68a6fb0341caeb9e07ea43dd00de169fc0ca7aec4fd6f20abcf0f7cbdedf7bdc535afedfd2c25c439a70bce47774096746c9d099a6c537d29535e16ae4d2fad693ced4347e29a2a76757e54c05052cb9b71242af78a3c7c2dddbb7ae97915e9efc9fe690009060ea1a90e935b1ec247bd3fad73a0aa6fea53d7f77fe73b08d36f5b6df2be33eec4b4613c5632c4782166fe5fd8054f277aefb599426bdbbcf600904de4d2bc92a5a56fd87b90d268e6f817d7ce1a21bea39dee8caf16a1711593718930d394f4b4d3f59a1f97d40174df16e756ee7f894755e06b3029ac91a0ac9887df4d6a2e940f93593eb50cb2bba03419413b5cddcf68f35f092e35f92402dbe8c805c1b8787fdd837339d851c0d3da2b65361ed841be7e69bb325a4e8300ed41ee175a278142c41cdadd700d1651a764360d14d00aa27fa174cf8c4fc9e14a855cf4b449cbf77ee052639323e5b0f7aa27909c17ac66eda48a1fab9b03315e1a11c57b2ba03d4a7cd3dd04c480f6bf1d3a9b6e137c54f6120a18c6c6a0b6f9f6a29810c65a33d03a7320ead343f72a4c2932840d5394bdb8e1639aa743158d5d97d239ab89ff3fe16c6ee192209a1576ca75e8c4906b963a9f27e751c233185e142bf937ee82231da4712a6cd014dd8d0e8d0d7240c22f1866faabdaa71a7fcb1a7061764820d4cddd2ad6ab0f23d2b09c731f266972f55c7005f0c31577c98a3f9ba55eac022545c1127a2ef722be765e9622b82e14bb96c12c6b60d7335d50f4cf9cf12edf87cdbff349b25da0997975d51ee41a964899dcfadbef9c06b6af13e123c0835e7063e32120cc522b60bb453116886ee53c816e9674b21a8ad4a461805a7a309a39fbfe3cd64e129cbfdd59325b113bc187a007968290de602eee82e7d5db85f17e6bd575fec9a1d8b34c8ff89225e2a683dee9debb711c91bed8f93527f1a319f526822f370c7594b944a3c80b9dce79944c912bbad5f3082b134fbccf9a67c8ef817f6d51e7318f38cbf0c98bc58ca82171d93e83fb4e7d84462a6fcfaebe84de6b2928541f34e145af62d4ee35764bc0fb712c6881e84599dd2d5b60d0b9248259845c1c147262409dd7a67f6f7c5763e4234f66d5d429de12e78d79bd13acddd0a6ad1a4c2e02e89484639f4e07b60fdee0cf6e7a45b27f80366cfed5d5916d353836e5d56f79fe526735f7fbaf1e8e16b12e48c63421a232f2c4f58950fab031bd75088449bd2d045d430fe674c32c3f17d9c537329e41c70ad78487952344a961b7647ebad91e33257f2f8059258805a20ac5f25d4527de9c116dde0ecdbe6cbbdfa1afde12e74398532e9a6d6325fa41591155f3b71a93f9846c615ba9c6c2807dc048b876c203c4c803b0de8f1862b40bc1b304f2f233719fbc6ced2d467401dbc5ec7da690e2801e0cbc75b3f0c5ae54051403213729a8ec00fc7eb43b51569e3aa3940ffef003983a9a12ab7412c785876af98e3ba0b9af4dd8ef0c945a1785711fede9f7e632ae4f2953c112df6c25facc1c006fb94752bd6e48937dbc11ef4351a69cda8f12b5464d61b98c6f2eef185b1e3039089796e389460e0bd15ef7a8ceb1841a666d23ef68c61d61074ba46f0b4ac48f0a06ba8bd137f118fc3a487ad2e5bedd63bb0653ee605c53e9e34200d64454924209e9e988453f515057b5b1a7f6172a9a0950b3bb8130e7ce3d8f90e7ccb20188df2ad9f198ef7c1a1a5e68059f819f312446f2f0d3e62fe183bbe071b9ee8258a294aa378a0cb2c7ff31df21581cde092127d062070c7c3aa6f1a757ee4069cc64f965b4a2a8646e26e262f2272e0388514adb4c9da38b6df7839a7f56a92279e4b72ee2b4b609f973e7009ff4693ff3dfa9eee632d73b92b411630b630f8b6fa8962f3c853aef4ea20a36b6f030daf1ba6ec83bf448dbb76ff93f4a9f57586a4afbec505fa8fef1fd41262c631ac4ea605a816e6db52adb427dde471a755e0917c19106467ee43a38a88a9d4edfd424f638d157a675c35663a9e0ad1a7c6994c4f3dc11b24782c52ca4013ad59a9e04690dd3e723dd643e4a3e7b65a4b3e7f27a6e0827f718ceb31fe50979d2d833728ece0946577388bbe86327f061c991bc0e3661460a85de82c894d13d4147e61b36083eb675a855805ff6bb74e088bd4887111e044b970ea3ba1b508c64c7d558c1f7ed4bef4969aa0018cb9bbca99dff38e02c1feeb503901537708a434729563bf327ee5c5e02dbc6a8fb31e8c5362727169deadcacb44a0b22adbbbef1fa8421ad321ab62299d50919e8d7f6baa16157a69e3daf47336277f04398432bb55153a19830028ec7311bf038875b4e62c9bd00b5908393c373feee899029e8c53e80c5f20c812d7a5b59f286abb9d0b0a52835924aaf3bb7b46f3c87c6ffcde1611d4f687ea259f80cf9779885931a34fd78e4bcaeba7d4db393b38549297258189b43a2dee95ceae11097889a1487e5672bb4058936c489fb31b6399a0d158844b3750641bbc6d0478ab8c9e1dd6695d11d31a4e85666f7b674d1521e7cd27be0d97cb0c28e22e849360abee2aaf2e8c5750f9bae5ef4f0b9f010d4ad3a63affc843117e36383e1042b9563c77d3cc382fb687659801335bbde3c981cc7bcf16ad84e8beec06e8ccf76511588c3b640513c76c4e7422442cdc222d310a70adb8d370f7c3cb748d6424010992a19a68000e7b3530e36a6668c673e78ce3a797c5c3847690d4678707b79f46695bc52a79aeba2a147fdba955a0e8aeab7b6a4896cf0335b3b66d441314ad0d9044a8610a46df9e4f27d1f07b5955458a952f746485ea4a88e6d88baef74b8f5514a5d9984edd1686a224e41c02978663d892535fba4c465644a4779aee797efae95354b6fe20e97b4482c88fb5e5320951e7407dab631402b2a59a9557258e2e80ec580b89467ab74ab6ed96b4e2e93469a14f1bb134371489f6ea8e4cd98db10de70505d1b0391152fcb52ff9d69374536d6f52f638191d58feee8e9a399cc11b3e93b4e4f325733a9efc7349e86e2ae7504b3490d6d8a3d5ee1b872f2c40dee781e537b6fb74425ebd0ba44a3690e39bb087b5ead3b11e8b615980450624c35e1c875e6308be0436939c4fcfbbaf76b4f2afb96963339e6e29334c268326a940e6873727b8249548e6417e2479f8f411c94dbc462b69caf4f07591f6d3c587fb6c93c792519a4d55d0485b8de2795649478f50fcbfa9e9cdd11b8b94ea5e123148fd0c18df29f58e37f1a4c7ac2016242923b5e5e97d68093ff596ec146e493ee560c6ca667615c4b4f38b19e5462cf900e0ac6bc0f21005712d42c768553b48879519f5e457b794d32428708f0ec8303a37aca6cba6e1899c5884b3e0054d5cf7460519083550b5b6605b8257b75f2aaf2881df88e84bb701556cc682a98354dac93b67122560e825206c87bfe4f3f6c5b301a267ce95dc998d52c69310eb2d7244a5feeb0f6a42692e112b1cba3bb66f85f4c4084fd479146eb0e86c4b52ea325c5273d73104523e410a16aceca7ec7c683b99279b6a9ce788cc3f143dbcd83cafe9d9a9cb3d2e4ddd1f00c5cb87c65d2b612d22c0768479d00f11cd2111166ca0551abb4bf74143cf9427ca5eaad7ec4da64e2c36d6252d4be666be04a00c0527d1e730eed864858e27ba32ae08874fec678ad4f03cf14df74713c9bdf97fb2e8dd4d85b6e7c7df0a28369ebb8bae237a13e1c633484190c2edf99073dc60d7217163cfb84492883474fcefec2f26291d4ffb851396c238ef7f2e73579384902dc9dcaa3888686be6fb3c7db266abc5fa578bf19ff565683b20df9e23c806e6113ce7af36ededf88d3a0756f6e27f002b2f8abdc66ec8fee221834957da77fc62e3963b2d260a8b632cc77cff1e7853bfe5b31a714dfe88b04a5dab9186808f4cdbe7442313463bf68f3b8c075a4798fa22e0cd127ac34f22ad3b5ca1ecdf9788a1048b861f5c49f80b121544d7abef2297a34ee35dacc2cfe16241b2205d27774d137988549b51324bc9419a53a3f5ca34ac9480f8cdbccd377ca319b5f685664693a535ec39a3c6bcb8bb5b231a8399376731494442022eafb35b8ab8ac04b40d478e06421c187a8ec8cfe1af8223b9c202ba0354fb1ce12852e9ad26236b5eb1a9d686bb0b50653fc7e8d1d5b7d258ef145c13555655503c3a6573c26b59e464703d1b3c38d5172a6c2bd4e31d1705208a828cdce58f1ea5b0f8f5a5ad7f92c3c0cb7f163bdc63e76381ee97a0326c66e2b1e580fed510969a1307ff54fa8c895b22bae5c2fd1e967750f2e2b93d67e4be90408d76807b3562955120858e6683862e43bf2e7c2e8282a27b7e4475031b17198d39b2fda5a4aa70c3f9b93d1acb7b3257ddb6e45fffe52663ab12afb904b7fb8dd9bf2249ef7ef7e4614bf55f58381e647bee29e4bb15279934dcc1e4f7a17ba51da1792d0407f1dd3808f1dbd899c8cbefe8f2e0d3be31eeac928254a4d688bee5b67f3454640045b93555b551c6a8700540d3b0a9b8c7ff4dd76a0f4ccfcc84455ab186e44962c3013ca02bffa1545d49c1a2aac450457dc674514253927f916ec976c378c1b732ed7cd9d8ff4868328ed5684617153eae8ed5b31eb6ca9e72dafe93e7773a4a343ee5d904057c7b024606eb44f16cf3e6d2eae5d69e4375ead503357bf4e8e3e5439478179b3e2bbf03bfc0880e8c3b5d92f14763d9022bba67292c67ebb13a02686060439a73aaed5106abf28c0ad144ba4aadeb015ad6480eebc5ed0fa33367ab391ae334414d9201bee1a1726444362b1ab0339a77cb1056faf21050afc942a79ca92a67a33029cb062eb2580095bd2c1def96acb159ec58ae712cfae929c7ac688ed813e853f2886d70d7450e90441e4a5a2332354fddb1c00dfc6d7e53cc8ad14afa24b9556654fe28ed8a6f6eaeb66c60987a5d887f0791bcb12b5101523784c7a99d1beb795ac265e530870fd1a2282c0c10e99c7e96af217ace82f16a27faab319d84bb32301be716349da61ee994ce5910b49f68e36fcdba7266b8f552f627a206d71ef0e624c9e3acd0c050a32ac7b3ba27b08cb0250d2d58e12f6241e70de361011a326383a5a54498e65ab32b3f906b2fccdf222c064147b1c9cda780579e806941f6d5eef6038b017fa7d641fc8a32aebeae4ef19ba3256982e50a10306fbbf065a9fe4aed80ceb9de566bfd5b4a4a21cf9bd46b0c78626921e121aeb7d2b2fe4797d3206b0b488b103167962809c7ac804af7eacb56423faadb4031e2e78c101b5cb1355712fbbb00e8fa3b2abc2f87816226c8b13b59a5d9411b1a9cc4bba4bec8145940d8ebbcc661ff3478cdbd685716363d7acbc82d2e5f8f64de04ea2606cfab5a4fdd1016648c0947cb84368de17dfc3d0095c149c94a88957f0da660de13ef818015a08db14546cb298a65c29009e924406308e6864922bcce7822c013ea1d429f62ead5a33c572fea6e36b8a484080f233c2c44dbe4aab870f5f565fde9fbb717d834aaca06c2363470690f8f49bf7ef324639f001bbfc53aaaa430fa2045f4f5886301d6d75b39b2f74055eb2d002738a9ef423bc5ec76eb68deb33c7650960f9bce2959a36e708ccf480788986c840cb8390b167498a11659771c4cbc2b96090db4afa02586d2662e62017e4e25c949b23c5cda8aa5ea2bdd82ab09315ae6c8bacca30464edffeb0d9859807e4a640be7adba1b2de7a4e8340619c46cd928056aa4ece3331daa732d485a9884811579ce5232aed89a6854e74763acdf4b5292eb1d749a60e8a7e8459febbe4e070ba539b2f1eb8f4217eaef155bb31bce4503081c5541476144cba43c49f77e7a17c0a4a7de8bd6a9e2803bb0c1a85bb96988fb8caedcb5784c0773f66bf31643aac469633f38dba188c20ade89996544674cb3e67c774ecd6346ca3a7ee20467fa4fb109dafc69205f40780df5e588448760dfea1b3d0377135981b686d60b04063b67e4fa3382a19ba0d9f9f8576e132c8f1ef8b6947068becaa1a253ec77db9d9b5dd302409c27ba3e46a55ffec1ad9920d7e805c3647d5f431408914d62f1dee9af5b3ccea8bfadf591ef47641906b119ed95d9a82908cb35e816f641a6c14b6b6b8ad0ecfdd2cdec948045ad91cf0250d11e204e77748953ff527d32ec441bb20175784da2b8deec6d723a5f5a0a418cc9fa29e2bf91b0d6178a5e03be76b41d4b134e9121b551faf0caaaf0be7cc3ffd0a1ed28dfeb76efe5d624d839bd19a4920c9fabe323039383f3e21a96286374fc73ec721492180f87f528099d737101b2c2f090da57803d27a10f5aac4c87d02818b9694a7a82bbfc4ed33dab28d90c244d4c03ab48fff8582cda457bcb15b83992cba2a48c5cdec00ca6bc36ef9d4dcedcd0c232c4c45be6c24076ac5b64f62b1f8e86d4a3c54c6ad8a53200070bb45959043ad6a1ef2df68117620ef2fe7b19f1f2651f45dbf14047f5c4c8f31d50d02b82ea851aa534dfcc45e2126380b231a2381184ec744b31537a69664bb5ad340c03359fc7961e1c41f7190ecba3db8cf04109357ce47e909d46cfdb97c188a408a712813bc0b0b34b821aa3d305664e7e62d74d0cd3f31545704ea5cdacde6ee4913169f07b352382c2f67e7dc6abee19c340b3d85df894e9ba7ab25e62f02a9d97e169b2ff65c1d37d1c02369ce99eb072bc2c217a514be653163e895d2e86f5c9de099bf6c3adfaefbc01da5277eb5968774f8ff3c2b8a1e9902822a6623ba285a61a1786b6c99a17eb2bc65f8f90797472bfbecab55bc0433ff60d5980f98617926c8ab1193d7e7d6585140a8d8094bf2d06bd26ce578b2bdf4e8b549fbfb7bad86b3f5c5563f09850d951c7999b8dc7dd6309ee5c12a52067b4f052aef85ff57de505211c27ef54258780aaada8679f514232fb434594fc47a1c651de1279de6300234cba1e4e69bcbdadf6764630310a70e6c89f3b405f17fee84cebd8107a163dfd3cf76194df3bbff7a2a77cedc0c9ae7db27878dbfd8ed196f904a65673a804881ab7b02a08bbc10b0ff59d8b0ffc353a58fb22f3f606db3b884966e6a852364f373ba7d784fdec5215c780e93a0b77b8dc3bff9a4a6c1d849d362f6129a8aebe2701635eaf679e96c590317b7212ff364d424ad5b7443e1278cc38f642e3122a218600e63691be795cc4fe3473981aeb3a1e912c59b9b7cdd2c80a7ad95b858db0c6e2170fa48a433bd8fa20df1cccbe469002148e05abdbf30de983ccceb8fefb7093867128959471e65afa2a5ed6adeaa5a54f216cad8f5905125b11f53553ea0efbd5dcdc607a8981e883fb37ef2ead1569099feb701cd014c122643f1b53cbe84f6ff6a89e00a4e89349c1da5bf62881a5dc2eead16e48e4481da8a62a2aad1e675f11eff5bd08b0599864bd37935e4b0c6f6b38a7f4cc6709e2ec89884ee23ff415d9bb9b627481d7ef140c87a6b67e243ad212691462ac2bac490ef783d831a8abe75fd8bc155f17ff75f5aad5d01e93e7eb0d1e12c63e0578157e2530f7c7bd53cfebdf60e6c89b9814b274c63a826f710ff06a665f518c420d3ef6d670d120036956ceb3e1908a002ebec319492378ac9d648877f5dac30f4e458b4c2298930a5e29ad4e82c484447636a9eb4a62cec965ce5a460be857983295db82296f6e9da60576fa0be8e18c75a0b35415eca3895f5832b73c190d40717aebc709939cbfefdad26ffbb2d6cab64e63bc5f79baf37d0f74e062aa8171e009a1fd267cfaea36a853793b8ec448f9a4baaf7417832ba7610cb020a80feb3fabbc874c001548a7680244a186c511dce4ae87320e0b0e6827cd26a82aa68366d04646bf8f862db1e7bd97d5960d1abbb5e976612e00060c826327b7c8b337ad9cdc03905e5eaf1d200f8a458a7a96e7a503b6fddf19745338b76b8aeb76e7ec4f3216cc52b8563cbdba05429755763de702ea2c2ef5e753258e159fcfbe77c63a4821df67bc48da80ec2082d67fb210b77b451f1e23f001303f2e0d61d071f7dde338566b09cecba5313b8fa75de2c6af8579520af9dad35d8286ee0ef95d21351b7d95b302d5278db710e65408e90036c162c10d61173cee052a010f40028693e6ff80ccb4a86ec0a58324b9e48d280887aa9fe5d8e5c2514075bd5347b6e01f1192985d77bf6fddc66bccaff17cf6f7bd10c13efd3249dddc4674b6e33d1019fb181fb0e6515b309ccbc6134b05a8a3eec9feee2ae416ac9887aa6e7f6d0f636f0e2bedadbe1b3a0f6ba0ffba2f15641cb667c20903089c3e361155b1019e311092617a18b0d01592f54faf93c6e4e01e702d0ce3994fed844644f51a22c8d69f812efafa2295d6b93f78c7ed94a975681071883510d017959e8555bab511267abf7c884dfe0701920d6c3419b4856e3bd30df85fdd8c170c8d4918fe6d5cdc45645f871af695dd621f4bf640a74c942797cf441a88d76897e1fcae682e04c65cab4eb1625f165016c643c0169c1da7a25932a9085da316b831c902ca87edcbddf6bb4d027c3158de5fff8e5bded1e141ea30ff84ea1b478a6133dbc782a19352d7396e5e2c7b8bb7f0a3e8faa5f901fc4dadb8d1bd7dbbecb53fcdba76b8e732e4fc3d67e8ce838c5a89994779256093af76d0d6c966459bb622ae52792a6a415a5fd8aaea894f6ae6a84c8d3789e4670e879ef39bcc9b488938f9d356798e86e50369b38978ef093318c0ee6286172723e0d9f5d652e6f0acb59126168197044e5f658df44cd6a3bf2ed49ca1c41a531216c17ee0f39e713b5816939988a7dea025a32a011f01d321b49465edc9fb1b343882587480e56dec21a55a7f640ad203586143e1ca997d7441dea423e5fdbb97c9d9f6db1f06c5c393418e328b2e4b6598e1b71766ea8842657f919d74cbabd14643346b0a04f5b30044587e94fe7a5df8aaf3b0f048b74a3db207b7e93432cd102ffe6d6f181d949632313bb2aa6acf19b15e7d7c5e23d0c246eb38097b381ee4dc4de2321428ca5fe26088b0de43a02543bf3baa5038e6f501723354607948cc6041f909f5d72a7db1f06037ad5f860d8e9dcede645368f3fca6285183598755d5413610d34539b2c811ebc45e7ce3019d48dbe4b59d512bb2013f781ac2c13ac3be59cccefc7e236c7cf938c092c919b38c202566928cb256af73074f2c47d8aae789afdc0588073ce6a30f6c5b317d27d995e8f4d5072be0bf161a829a7c8ca27de79ebb0bb6b705c5e7504ecb05ee3f4687fe14113a39cf975f56d97d658e095bbbf1486cf742beac56416858727471c12d656dfcc69ea7c7a7423280254bd8d6162b96f7e3738eb457aeb76010c7eab04c4d04d180ab22cdcc1523883019f5c17b60fccd4f359cb956c151d7e36e891e3395a0e6ec94f50a361346da194a22c28b609a8ebc2b97f6a4c225f5d6f552f6393f4d1ceee555c46b381221d215de28c50b06acb0f762ad4f388f9eb8caf034ae987ea9f534da23963ece12429542dc954aec133f9c031f1bb2f5774a07fad9f0e7e4d2d08fe27f429d22620c2aff2274aaef0d94b2d2ae9278e8eb211ba950625d2acf6d6eec1ff7debeb18b347ed27926daece5325568d7a3f9816b03bb155cd5f85d621b4330ebaa31545bcf16234862329333fd0a875c4966739bccd0d161dbe99654c6fdde521510b46ad79e5056ff703b5bc2fd71ee59cad4f0083153be5194f2e13180878cb74ccaa3f90d299250dd1cde648d2cd504663e651144f485561f8a03ba0058ccafe0986f121efc2f6df6e50fa5700b9cb8019c431b6c27807cceed3214a39a5ad8f876bdd2f0ed1aada365b38a1d010167cf65fb0934ecc60ceb7016d713001fdd7af7c6695d3f59f5718f34ace7f1e94bea8980806010c31fa8248c6fc658b879e3c33b9e21a32c6855e21826c0f246240e8e1bac9793e6930a2a627a4222319848790ee05706284af2a554245fdad8a87dcb0e431c646282f5561834740723ff363f2c4e8b134961a695ece57e37a36ee8da6b77aba948090687fa0da689fd2cfbbf252d54cf3eb3938dde84bdf77c42499622b3fcba84d0800ab2b6d7ce43a777992f9dca8cbe9d2aa2c02cc63593f4d18aeaa528dd495fbe8dc054c9281175fd733daed864e1a4dd13d3a22df5f37658c51c7b886623a1d27aaf48cd14dc2abf40ac9fd969fc69ff076c58e6e0004a1089c05762d00a329e40c0b0ae061297f4279e0dbc28d178cd3f7444cbfea5b74f9a22f380b522dfb1cd3a4546e4dfff795f15ca3b945afe6dbb0026bcc8c8b4045f6a87bbac0264adb5cbc8134cdd42d1784df86b1d4e8fac8b865c8a8a7d7e4e687a897c89243642147b13fb3b6a88ab98563c0490e83bce78c1e551c4c39bcec3b4b5df11ffff20cf265c86a027bc997c7ed04d6dbd82e298001e0d99f26fc990cbd03edf4a4c4b24714c1f50de98cd90875f4dab516b719d7f65ade3261771ce0bdde654516f6238b95605b138a6e5b82b61066aad066951117be3b7f24da65012b23f39a2808681d14040f74b35ea648bb54861594310cc086ae99e589269fc77e5725c36e67384973903363baff5935d95a70a365497cbcf99dfd18d07894ca01e19441cd84fc993eee70d1b311f687d4bb248412c68619cfcdc7b4a165dbe799191f6ca0ec073643c410537aa6e43776992e24478eb2154e27df1c1de946e15dfdbf8b7cc611f74848c8cc2067e785744992022481546205a482b6df50cbe57ab56c314cf435c6d7197bdf2659e412f12109630cf7423ae52466693052a7feb764a04a67649e1056a32e9ddf08cc6c102c5fe1269cba0d91aa0e23b568e2db5c9a88a91f04d10473017323c30f095a0cd3be5f1e94f368e2fa163f8e4de1ad67570bf0535fab4b166f4c8a268235a8ec99366bd503f66fddcb02a454694b91a0c7dae5a64a08ce127b3c217b8014cedf515625d1228f84874c34917ab22dc4debd055cbd86cd2d962b4a59f5dc566b6d30bb1324fb952f295a9441eea7116f32eb806ae38cc1283f7e185bb2d9dad960b6b40abd67f0886afd09a185f06955162b7c3eb288a673cb3e74e11dbe2038e33c070ccfb6cc414d4a1147bede8087f4e9b08e4957cdb23a533a1d3c54abd5c61ab4beedd38e92259089b809e334cec6689c5a8df03c8f72a56e2d1baf0de97d8403135171495aa00637acdc4d1da6f21549006f65b2472a7188d0d0b5a090885d7c2db8a5f412f592da3232bcb67a963619ca0a95da27e5ee9e6b292801cfdf1791472be655b9012dc433ed4779b6c8395e2afe2f0dfe49ba7138397485c23031e8b23ef45563453261d107065091ef501a2b5ceb86768c4cc841405a8f9f4f0e691239fbea195ad395f52407ba98442857745b0104e19c9f37a9b668fffc03ab21da83c8a254bb6fe197913b3648492daa09f131888da63c5769a7ae6c15bc3a509de69759ab7a85ed1c716ee799db2564a3a09942045875cdef38bb9143043b1b53f77df512cfd3aae5ef00dabf4f849843f88e71b2593895b4cf9174990243619b3507f83cf1d78abbc73a761f214e068e211dd02ced29ecacab915047dd65f3dee3f8c62fe136dbedc5931720c1b0cc71985967113091f8ab4889735c9dfb3c1eca8d83cd96468d9dbbec65f022ea10aad4380925d8df5efd86084b533ab3409d863b380fd2eca96f63d73da2fdad30ebd1a8f3984540db4e5c07ce6ce4a40f6d161ff232d6391490f7c6da004611d9a891a8f1875904f54b3a17b7220aed9ccaa404207e143253631754857565f9832a7ad1ec04d4c727ccec1816ca6bc5f6687814971499349f27e18251ad8baf2e0267fa374a013a1ffe6a994c2932dcc945f4b985b9ae2f5a28834980e4b2c7a2c11427b33ef3172b94c78f6891705863d5d7265ac0ea84303b38e41deb2e9868941cf9c29d2fbf2dc326e22ad43816b8093d467d5441586dff7789a2c79f7d2d6137fe1df43e9adbf0d99812e9fda43d704722a4699fc1f405b6b44980a47d996441832d00cdf4111ca82111b02e5d2be9d720ccfd98c5fcdecf8e3aaf52f4e8616ca6198dfe80658ccd91a5bec390f2082da204f6fe5f43e6ee56510c4098c4412c0902600da2cbfef18608add952b56a33d9d44120e0d387dd147e72ed070c74deb3ed04b714440eb4c2126cb58f7b520cc3f88bd2cf0501fd433f3226be64d2ef0ee9ef0a83f34f509d0867820149c66f3147b02ed96bb2b79473fb62eacb7554f8a3a7093bdf5752aa89213445af0aa91067fbaeac9520caef7b1eb8eef11202e24f32be3df8867f7f10bcef8c985ff0bb546fcb13b77f163de75aabe217a6cee62d6f7a94cc9ccdef4a37e21b81f9b1f97ba0646af279d910ac52e4dfa33429203f3349c038d0ef0139ebf9a7ec4c0794905c621b539d5db34a45a3a7450faeddc444f171b99149c77d3a9f5112ce130b403fe7d7c4c2eebaaadd5f7084c04f399dc560d10d498fe53ff0aa1f75a04514d15795ecff745c2888613d03414606cdd41b994fb22892992f9dc080971ca03ddcc64aacff276cbdbb6a8340f05f06aedd03f798ba0b0388c89086e335aacd216762eafd743643d060933fd3050bc5f98ca8bfc01a0d0ca62d4bf3bf9b5529f7452c29f9d9fb375a83a8698a8b32426f18329e3480ec8ad836f58786750a4c1de9035a74a3cb6111817a916e83065c4980b6e675d82962a0c358e50c610f055b3d8f1e9d5c3aa80a28ca35f4ad0da9049a905568c77f931f76baa25c8b229a08941194fd6a7b987c28052f3798ba034b752","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
