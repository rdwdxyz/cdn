<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f5d60f502278f4cce9038776dd694e763641c398d4552d79bc70544a62f445b48d19cdfc6a03cb53c74e910490dffea357553c2961e71ab4ee53b6b4c6b6f6dbd1ffb68314a3d12adcc1101a9c012f454ba555a88c26e6d4714c08472df2d4c3d08745c8a3996a0035fe6db63bca77898b3543aca6017d9d5b7e041b0859b5f3f1145533c7fc456b55d96fb093061577a8c705e0fd96e8fddbd3d9a1d35b2bd307564f130d987394ea789b1c782baabb5557b70253dca1b1e730bf678a5433f2b0e6da6937a33070a258c5060ee4ec753a205ff33d7affd4b9e8ec901e8dbe357c2debd7afa78c58eb06a3e9cf94a3d940172352d9e0ed758003795321109e763eb27ba35c48e7b7957401b13026925a2d5f0c30a3602b758994fc490b8642fc0b721e8c2f63e32179faa2b8b67718c2ba55623b35741e79751fefaa666d439018063fe809f5d369ffd629d2eae8e96fe4ebb0caa3b51ce185cef2c33c87e97044f15a79b3ce779e469683d5bbaf563d2c1e244e58f1d3482359cee4167dc96a0c65c88b0f71dd1c2eed1327c7c5d8539385159f57bee53b83cc8bdc2ddecfa867218545ff5e2170b318bfb9b654e0691214b777aeb0e619881d4fe5f9a45eee1a3faaf472f23c3d6f743f5081cdeca1a355be69de68a5dc8af395b0ea1adb97e732dce5f20b9ee85299db14bd56fb3d5b09da2352861161c97fd6b14375e5dcb870da2d7a64bfbc65ca92f920951b522efdaa57017f750e2aabe823bc7422fea3ba4014ea13cec94b10bef54688d4a212a3b705f705e976ce847305cebdf7802a68bb71e0deca20fd16ece8ebb7b75bb9f07981330a3af9cb38d0086d8ff3df0ebd159e5808dd4ff78abe696fc59448d643027608d1286804caa2eb410948d980d61a9dbe8af36b8a8bb43b0867945aaf504daa2e324eb5e84757de080dbcd60e39396e9132cd9827e84ec6734151c8c1caa830d0c35071abd90f137ae994570cf90887dff5689b0e64fb0f89341c0246722a2d45852860c426ba177b00f29e5369cc3fcc3a0da87548dde525d81373635bc3f0147ae283c8eef91c2360bd2e0510928f5360c1d2105f29d46954ff2d21b5dd624b159631402ffe57d44034a3cf8439e5a1853397fefd291e9d9195d78d785ef8e1d64d90e51c009ffa7e69cbd5599429f655d666eec5b91fee402a9e96f713383ef26f5d550c4facc7c189cdc7d03fc8df24f7297b5802560d9934edd34087d0776d7daa5b8a5003ad0c678925c4cadced1b37a7decc6c3009715add418f319a3b789ca8ae73b983da9cdbac7a30745cbe3979c8aab60e3a245ca2b8d5300c5d7291de0e17ad3579c81925948635035c9fe81e7e4e6bb8d69fb368f26519e0ee7bec9aea5aaf83e826dc7da74aff791821b94debc48c153991391974ed0fe3535a5d19829cb78c59d29aea5e22cfbaa750ec07c8805f468f93d5d939bb8255710fbdc373b5a4440d9f8cea9449543abc09c76bfe8532a1b689e2fe9f728a943741ce291d05802aac4b6e299cca7e39863ddc1b022b08ec88662006b7d7d909349f9143cfe1a04dc9ddb169c85ad070836d51cb64916dd71022ed1665b6a004fae8c1df38b43831e5c5f9aa19d1b244fb8d54adc8d8166711d8066926cc09a830237ed17b46e1358f901d83de7fbb6471ddab7f4094687d2c9f13857659ec8e8563de4607b675a368f3148425bbde739910691c270eb1c94fbfec0a794b7aec4613bb3b8e48147b3605db1520090f5673066008fca5cddbdf235c339b191a6198dba7184e76d2d8c4c0b8beb9e9bff09e27d9ec860fae3decebd363fff12bc45a6ae50399bf55efd29c5004940b616cb62d600e366623edb0ecae97402bc89b44a337dd74047a8fc93b9c09090f05d4cde3f1eaf68e2edbd095de12092443d86d58e216c97f5673a41cfb9b15ba99296e1e474da2ccff84de858d43ae6fb16e74d67fb08f1a7c3bf05c3e0a6a1b0201557e971db4b3fd6843f419e15d337875cebefa41931b155d49ace1fb0b4c0c7d4b4ef4b0de3475f2c39387b859fb2dafc56d9a011362ab8e1752d541c9bb0c0b4ce93ec00b75557a4a93ed0e5192bfde757aacd9d40f7fb5e40f721997a9d956ac61a90d4b74d64f70666f315c6d1fe6df9c68aab8b8fee7b6e617b34969f7ce62a842ac90ef1cd65fe26edfbcae318aef533f934790bccac85bee276421c0377a91ba28d3db548af0fede3f6986c3b60bb8604da14e27dc2509042f0cefa965affa5784e53ba80905cda289a9274291088cca5dfccdb7b43b50aeb92aeff7a5e3d2d48b80d7a8c6261d9de3d6da0bb625b81159feb173d9ea24f453e95521ff2d786bad91ddde79f1bbe1310b0c00627960ff0fcc146c8bd0c165a3a8d1227529c3d7eb60dec3df66a2120f47c099bff3e9fdb2aa0baf3ff2561c97039279893c2cd519d20d3a99ef6380a25282811cac12016333710ede227b85715ed700ab712949c09b38ac481cb974782d552205e85e39486f77b5cdb289400c5323e1a232ad2fcb522dacd629c247a7741cfad7d8b82ae81f1bc44ac65d89107513f31569c081388f3de52f9a6ad12016fa828b076db5d8ce46f1e9c038f6ce15c3f2b47e96b1cf76df15c88e81f569c463c384d1f501ef8b0add68bd8129cc5c64755a7c80a0b22538ac696914b712cf300c33b7dc5cbfe72c19d745483f57ff4833dbfc497a1a770000f894dca3aaa912d07ba5442af6ccbfde51d555507d329aa83d6469087ee3dfc760561cac3455870e4ad43946496d1b9a1b1eb18829ad4d1608a75336e21831244c5c8ea135372700b6de5ef9ff56a2d852f09ec3a8884486d563a124981676a8c1a0da33e61aa9fb7cb9370d974426a62a7dd4319dcda8d24ac8b552cfd0576c4a7f644118150003f169999bdd34e310a94bd5bc483c5ec284a619ae8f78b0928ce1ada5e527e22ff3b6d391f7d90ac5a99cc11dbae1d12494d1918598c46d6b02a1296b7f80b0a60868efc9124f51e667af80bd003512972a39203bd0548976f5e5471f7dd660d211572ebdbc0d8a0eebe28d0081fb030fb18b29b160016ee496d1a49144519cb3f6f222861035a60451da41dbef10db278b19832f9eb35950eac061d206106e4fc348868a070a50b01e4b245d955ab5b170ce970791fe85bfc84c351fa7e37bc5e2aed0436cd3bac316e3c8fe6e7d7e81c61239959b8f90139c8eccbe9c5899d2323684ff3c7b7e0b22900157569271f7f3d827e6ebb4d945fb54a51c599ac0c6cafa9366a0f3deabf38f07cba52444a867cb4c780990b136a16d07235ffe252a580e2af256aa2ec3c2ec3f0a460b44bb1d889221ab3d03f8a349d94eff14a8d032cc9c8857640d3d3e9aee0cc6440adcbd20b2513e21f94413da7b0457fd66ac74cd19a99466de5ce75c776baa7a3a9775d9974c4c9fd0e3a0e3c6cbe33ef048aba1329faaa90d23bf88396288184ada4ce5d972edd32e301aa375ff8a6c22162ff91bbfd07647a8bd49f0ea66a9269dc8f82a1bfee04efa812927d699fb2a91761e8479adcd6a18422b9e2e704a26586606f3f7e23b44c08d6d4898ef96fa87e4bb7939934439e5dc092c289a79436924b8e66b4b76494551948bc10a152b9ed06ce6227b037626c1f4a02fce6ad6010655e96fbd7c051e133052166c376b30cd00c8a09e180f161a082294ec853a5228b9e8b95387c2176314d6a352565d0343175a09d47471680e6b912e9c3d70695e080a9a6da8842cb941351857186e21be97945b787996a9cd97812623408b2bdae42656967899682718b89628b4e24267a78bb1d61f42e79a158ab55520e878646fb5dc1dc9b2d5f29acff4c44ceec23595f0f15226a3f24b56422a8dfa76363110bc255c4f9e5104da810564a1069b6e1ef90a841e35926972246bea4b4af63c08a67ad633431df8966478ad997b74287cab09d7008b506e7915a66fbea83d2445b91a907c6aba674ebc8a561887be048fa208064801c46a1194d938678ba3b1025486439f04d9413c9c28ac00b91af96f982a550e8896bb51dc9f9e841de210c655a04760ae113e0ff45bb8f7d7e12dee6fbe41b693b335c1eee9459f10343fcfe55c869a1b04e6cdacef5f49e389b14ea44799c2add93cc740566c2c83e14dc8216f9e9db2c4d18253eb0a8a5eab3edf96b3f464c42fdbc4a82e32cf1633a186029c00ed3cbf123e7b0a36ef5dc0171a25b798f66d3b763bbc49a780718e573681cd149283222e2c9ad84912f792d3727f214f1bd315a6200f6a27f226161f4539654240fd9959a31a9e2af320ae2db71ec708a3cd0081c3391a2618c7910f522836f039646c548f16e9677becc7056ab68b6dc24a3fb3dcb233aeb6a62d49ce648f1766379976a61e69a31a459729186b7e95d6124b7f4c7414d418c5f6682d4ea6aa1ce9348da17b4df024cf619e82e47ad4d1e5125187885bdfaee1a95d9af82fddc11760e13b7b14c90574f80a9535b13fd1dd1ddc9ea11fadc788cb5498c70a71f0cf641207917f4144e4cead6457b4980799013ce1d421da19a84365c1107bd2fb6cbdee039d56d9bfc648e610852fdc9bc0d575af36f0e08a58f5e11910a3fc890cd9fd3f8981048e644e0f994300b586e288325723d4c4a0efeda358b645bfa88132e4da93d483a60704e699d01d158851307ef27d4042fcdb95acc81837c162a17dc3d6bd8859271578bc380a266da446314308552fae8793df9ee7b1609d3f245a31e9c3e4b9a40099a771e9910113f31ad43f10c67a3a2c15199a5dc59dabe4b0d83a4e6751ed6b710f94605db85781a5ae328e6bd9034f2079aefbc432a15861c615989f9cec53810717ff305462cc73b36d7fd9e6d290d45a286a79eaf115b6ed8fad5434017ce41c7efc63d79bc61f2c6d708bd7e1255995802bea9c0ee969df45eb4361196dd793be44b0dc7826ecfbee8475cd864a255fdddf637124498db00999c2d0c3450c679f35c1b0e36bec4dc1e21170422f5ba30866e99f8f35e7c5f25e16da00e6a3a681d54e8f929569283f2c3418fe25a01c9ccf7bcedacad0da1cb96e3e85f17e320adf4c5bde5c656d0adbe91885c3a597ef76b4f0020fb815671f9a9e185aed4ecd34dd84361136a4283882604b711952f389215f0240ae1af06f32ff37a73450340288a0480d2af63b1b24c3ca82ca7ec50bd5ef13277457a7d306d0107902fbdc8e446fc91a99681656e18f6ed7bb660ec3314766b6ddc5ffe7419d550d4c8e5f0ffa154c869514c461ec8d0fea63191bd9e1063a319ed2134471c435fde245786ca9f9ccf616076412b5a58ca2130e1394a1d4a1844488e31e80df91d9e26f2822b31f37d72fb5ef4ad09156f7a43b7c9b222d40af7f3e01ab6f0b07a45d2310fe9dc8c30f74c1337ff0675e10544bb60a859fe64a1a01f24caf8ddde7fa5f2648ab427bcae5be2a193cac602bdd725de25d20463bf87d34790bd10e967080c0ab6004bff4325956d8156a2c9dbfd60fb8b49633c7c0c0cc5e9b0423070221a6cc5d22c6b0a4645c659fd5f4a1fe796c9caa748d8478d8e936d9e27b9f6c8ef6dde52ae505021e73a7607e1e5988cd1edd2dae71aa30f56764e5bdca8d084c411bb739075bc161d9a5713c71e09b1fef5a1144f1c392f18839218319b0d2a97add6d9dfbb283894960bbfc6698723ae8171e27127fce2b01142d9ab250d37de6885623ea52121463388527e4192d91f8aaf04d4c278fce439866cee4b0dc4d336d69120f2c4a3d608d2538a8837e1a9f5900f742303c42fe9b5dd4853c1d452c26f456424e6eb3b1b7a9b0359c7ae089c0fd9f257987ce53a2641ba4eb0caa7d3736835546f3ccf6a974cbdd32bd55c4269a14eeb16114422eba519b1448b939688b069c4432821eb25d7d05a18d42462e864f869aa848eaf07caeee13db2e00727f800697679f331f5ee1009c91742759be822d23083d14ba1e3357c057a32eab05602f031358be2b0d804eb8b000b7c421713a8fff00b9ecfb742b53c5a31380d14914e878b5a009f6f16ee40eb6827f18fa3502310af5eedd1a72876d9745bab014a124f068b51e63ab168fec815e9523570a4934b27c3c3300cd44fd2dc9edc5bb1b236bbb858819025ecb12be058b89ddda43b0f1c48bcd28b51ca0d28c67be8c9312067d8dd44149ad9f9150cb4482ffb5df550ab87e75464f68b43f7e5a690bb7cdb6a537c23b0c88bb616dbd671260c467457fe0151e8539a1c7c7d4af2bed0cf69832227170e507c94320909bfd784e2bcd3de07e0e775a3c2555b62c329235063f2b450f31542595700e3e46caa82774cea21f804ada3ec356b13886060f718e9c813def35f6c185857a041d9146d6a553898e5ac099030cad02582bdb3e88601c1dc585f23ddc2cb18ca7a314840465e127122b2481c83015aacb2bb2259b213a60f4ee5a501e75665325db2ea5f4dff1c6b58db556b3a0cfa4cdfa6af892e11401bfa905dc746068f3bc8003151ac4306f4020299a68de9d2bec4f661862639a58eab8571d7fa161590e8685ee3d610579753e956597b151fb51dea200665ffbb0a451a3ba7b5c084c0ad8b48031909a94a050ab4f85275f88bed0778c21fb3219499e174967d3149cfd0ec6b113453c2a04a8c31c802e665f800e8c0cd2192edcd66b49f3d52057cca7f21cbd8efe94424d8eb0a807255a2f80129b803fca9667a4e3052b43614e7015729de6b71353473cbab31248b59ce3cadd808ddd589f0d4061c2237784b642172d873086e4eb981390d5f26307d4c40ff0283455a5fd3369da1ee2080a3563928b55e29413c2959931249291fe28bbe74fc88031bd56990a153a74392a94c34e5fa9a11bf950ac27ba5930ecf3fae5434dcd8f378091117845e50b0d685a24b06328720236b4a0a58f82dc6e84446e5a770c5953fd880ac4ca2d74372db9ef31c356d2767e37238cce86a3fcd49587a1345e44e337921bf03f09fdb5c26f60658c2d440ddac20a45410c101af4c19c665b7d299342f43ab71b28ce686f7d0d44c37a74c24eb3d9c1df325ca2563d599125e1a5df1946b2664770c776572bae2a18324e2db977234f65db23dd4a5fdcf5d8dd6604c6c8b4c4b9e41670ffedde045afe04a14f3518d146f7f514d7e961eddd12be8d60cf991403ee59efbb7e88ca1faf5d3d8a2a08ff31ceb4b578114b7c3d390fd25a934cb6ac2b2c69498b8d0400133a59234958979fd0ac944b2e2a37830cad4419bcadd1eefe510dae2160e0486ae3fb58ec3780a9ed13943ede82a04135b83855bc96fe1c4f30ec7ddc15e2b12a3da5984837d5e6a4536ef8538196b25408ece8fbb5f59111d5bb8e10d5c6ec34ab1d456901c05a6645b7493155512d0f5e879bbfba9cd040dd261e5db7abe412c8b259278999ba1f5e4d988b1035260875230cfaf0c0da830cf151d5bb77c7735227e9d7cc7930479e47e2e4fa3fa6081868da3e95ead9a55c4fa4b21b333929646ce2fa22948edea947cdd45260a91c20f339408a6447b8e5f00ba4f5ed8b98f0afbfab4ab29783902b5466c4ec3a25f011a8c4d27fe185ae4c537931e997560be9353221d9164cf790922a042da07746f62d5c91508454f26334390e5fa844a692aa87e26bc538bcbeee22d4cf4b04392ca2f1c8105a4577f3e3b2911c38d3460c7acfa1ee76a5200d39bbb53eddcf0c96ffbceb1248319ac671958b7c026412e70ba72714627eef23979b5bc3f04897088ccf430af5d91233ad8e39e70ee85b384267ec5b390ef4f35331d8727f2d0e356e2276ff5e96c130d7ab4658b0e9cd541070bc0d279405fdc55fb4f0fc626b8963c6e5f3b0bacf38f5fcaa0ebfcb655e6a725d76b0d3cf20cfcbb34ee7675d2fd89c12b9c8e644b1256bfa4abd494644b33518049280cd5f041668704212fa23f777a701f74afc8cc1dfb57edf44c20609dd3e3c96b01df344efb935895867f25ec185c16951989e8c064ec706cd48729eac400f7e1ad0b3199c00ce5df62f51ce98c791fcd8a539cdf0a6b3474181f36bcf2bf9246702a2428cf852fb908ae234390a57687894bf82649ed71a3a245d6d184afedced5e2992eeb98ec685d68874d88dde0d0c48706c91371866c9e729f0829137c30209d9ee9a9c3bc0ab76e4a02008fb8ad5dc3318dfd21a04fb49d3d1a28d4b51717c320736b2715f800939c5d5c2fe9b37b3b70e83532df5a32d69c4f53d953038c9c9941b7e316b5239eef8086851258a536f76696cf3f8ead7d0f653f1e4a8c6c2603c62229941d6e731cfea06545169fd809ba11684c9ba18a33f78865bb5ae324372bafec6a2eea92bfd010a8f9a3f466d0bbf15e0e1dd8ae41268c0d56ca0ec6bd3a4e2169f0047a25a4905e4eeb40b0cc4a17daefe251d980c515b500053188f9544df33a5737edf9f0742ff1c295c311138d9660d82ab78b96a08f9a6965e4ae66c454e7ce3c812166c8a6d50d0857a2288eb644a509c7ddd23813428568da2a5a3aa55cd4604abb1bd37ce678efb3f08da39bebf695f2a5c872ecd3f449e1efc115d948aa860c7b293c0bd42b84fd28f47f3e2238fdce19c731cc4352d9ee82620896a333dad2c426e616254c299febe2acacff78ef149dc2376712cdea5dfbe9ffeeb139996827ecfc1e5120c48686bfeb6b5d1fd300b5463ab1ea7f5b461446cfa28adba9c479e742f02b6b05d28069f207c51e1da77805c97a85b3a32b6db45a458e7cb60a095c53e382f1084a6fb139f3790887e3ad9113967ea87d76e476d17a30f8ab9ee821d90bdfcb264aa1fd0cea8aa4cd6c5f87e80807d8dbfb7697d7fd48c8140672441dfc71f4e3a3ea1fce63d9690820cd339125142d3c97da4e19ba271fce5500fecb0a88daa8fd974edb28baae3e63eb6e63d50006bb1fb3f678d626057aea479767818571f7119f7b9ed588903f0d7c634a5a21ab950957dae2b8af28dfee1763ffa107c145be1d5ba41b6ab57c1dbda02da0bf2dbc711be94ffd371d28ec669bbe7ebe4a97f3a3b16e17176079c064c2958c079545148c3e978d1aa9321cd68303fa8557f9360049612070d3b536f328d771d9fe12c333ce0cc026579bb753bf521071802407d3adc4109eeb55e09457a35eb18fc8969b61feaa082dbea918fc2fd2692d1f75fcb180e8d2a64eefab2a58ee0502a6d644ecfd050199f62b0ada55cffc9ede555b6b4772db49b5d671c88d53749a07438261125cba96c599fdbc9cd96bd2d2fa513b1ec81facb87dd9c23bce03b26d79884770c2218fa2ab0ab2789131738c82b9f04d085648383e7002984079b9e16fc8fa7f2495922da16d43cb093e302cd6ebdd34a7a1c3751d6fcaa64375b2685280291cc7ae03d60270262d00d1a3f605406efa55ed87ee96772a8f7bdf1c7b8aa53f7452ab560b279283860729cbb7186b9dc203bf382d17faf865e04ab079c5d764ef9c7a14030c40c4fbe43c375c739c088d0ea10ab14edf232934bd1d938ccbc4583d68f7cedeae95aff36ff6d93440b510e7bd9616c811b7f204a487b858cd2ecb2eb6ff9defd4168f313590057a7f8eaddc669e699edded64d5983a4797277c2fd792be7177fb898a99fed6ac4515e6221aa2f04c143e79f215b459b843ccc5247010a752b1460c60fdcf39c0598f7f3cba29ddde497d36162e8f5b68f4daf2bef6287ab5d97bc7e38028e2eb80bd0e4a80ad7d9fcf98b659a0f71f9062e109ed72ae019abe5a1d6f2995414c96c44a6b8d9178a0f83bf84f90ecd381fb9fa788bfe3a2f80ba0b9d1cc693ade69da5abaffd39319ac13e956a4ac27692779b8b4da1d0b3e9573d208f95e60025bc2ada2e7c48cef60f6dba1535fa1ceec445afd17f0f868e6120406a2fa335653f789a805ff03e598e1aca18c814f0ac1f3ebaca1453f2bbb49f0067d49b4a34dee514e8f0592a62f5533f2b22fa9f83d6a666df815b65d4df7afeeaab5851882ba911c12f736bb67585fe9f15124b0e7c67da738555b0f49eb7a4fb1b1aa4f7b3f72153977ffd4eb632ce937f21784681b3dd1afdf7d8407032dd7b9d65ae62cb07bbaa8947ccffca40f3b326732e8aaaff219a716358706cab9fc199336b0fe932bfd2e21cbc0eada96c8314330013e268274888dddb2134c1c8f406f67bde681a57ac22d13073289248f00540f93ed06171647d3314fcee7bf571f375bb18d6f40a745cf6e310db241e443577d53c0728d2b02b14d43a1e8b81e82ef551c6c16897e2ab666a0785a19491ad5e450a0aa325951914b5e3f10059efbdb410c4a4786a08f4021f8feb70ddc545ba0ef740375375f96b000b71a790cedcd8c8ef86a40e2e4b12f0ced33243ea1c8d26cd155ea3f7bd1b5b3e147d5b12d9036019e7643b4c7a90aef0bfbdf5ff6bcf67775bec759e3434ad53a28cb4812e5aa2b99868ad345397048f820ddf17b0b184bda39299946b03cb7a3f8dd063b09effabb193919cb8294490f29955c6e4fa184859cbdeead722dcb11f200c60fa464ae10ee06ce58eee5d38490fbd6ae533ae16ae3e646ee8af013a2d1eec15b5a21170353084eacb770cf4c8df6fd8d1863212363a445ff4445ce988c935a88339e7185a7ea4b439421541e52f62be45d0491bb6ab13f5325bc407f6da0e6a56d62e76363092aa9406c8f8cb4008c59489f866ea3c0d7f4bc702ff7c702640f20f1c8100ff0a87321ff92f69fef7fe8a4a690f5ffc2f03f67c745c70881b0ba0d64005198e671c1d414e8b1a46dd89fc7ca1ddda2cccf971f2f8c0066d0bbd366ccc9c151237e9667af7b68cb60a1bc054e4b8ba2218babf2057b2be51f08e43ddb23d42460a247ba2e0e13a09fe618ff259e2fa1de79d0e2fe59243a004e7d8e4b629addde933645c7e402db7c2f8d085d7129e072dfcbcf0ab6b89d98278242b65194814ac5b3e36bc65e9815016d6add8b1670d47298979534c87fe13ef45dd59810c48b650a79fb78daba9712cb28752cd93bae999c3e3f8c7083f681892a002b8c4e1ad3c74683a4a31d8c7c37b68cb394066bd93756693385083af295439bd4f4a0f8b1271e8fe81ca1f0a92f003c51df85f0441ebeebf6689e91f19c0816e3373d0a1a0910c5c78a67918113f52b2ff1fb64df5eae6097c923478360c0179a1b53092315a85a2da565f3727309ec149858d21222c2793e381bd0171fb519254476d78363f2684e64afb71741e637a482c8c6646a4fd92ce4782901be7f2e1677935f96851d321e0a6b58abb69a5e869c0d6c6defb40e74382ff131f82e83514ac198cd885196f0d6631237dd2f46c337fe9e367b9b9450b2af0a96ca9f836a5190b3f0ed72d7388e64c696cdcddb380069bfc9fcaa5478b370fc4bcbfb008eceb1553581d0cabbd0309bfe987082716bb70efa94ad053e9d81aadbaef774a4be08710df6b8b4a18422083f7d1ed51109d8a29613af150ce681a084077ea45c41e0b4a3e63f82d7af9e036a76c66667272db1858c7c0429d2aa018a7d57dfedd2f5ad00348519e52d94eb4a24b3fb76e5cbb737ab671cc52879ceb445278f825870232fe0be4ef9f29e8e99773a0d13a0a1b274a2e39b18676d8ea94d63fabd3a0eb023a6b4b31a1f9aff36ee85525433276997fb6eaa626a283cb7bc4bbc592cb8074a8d746484e8ec15cbf4453fcec139ada2fb083853dc8c26fb049126ab5a3a573bd6a96b9b34cd69901fb7e3178406714910a9d97c35ef3b397d1d37dd24b3102b459ec5677d366a50e9556abf5a7d353d8b2c0366f28eb5e822596aa943b5f9b7100853f3b5365adab569a9e48c676690a8dc481c93c46573533d4a48198e9fa1dc28b74db688f94fac3e6dec02dae51032e3a4baf489f98f9dc6bc232e59b2011edcff49d5d3314d7faaabd4b5caaaf0de3c90ba683726685ecfc3226d93b4658c74ff1dbcabd62d4492c87955cc702de47252dd0bee8c2694c11574e3f4b76c9c67bccab1d39c0dfe7443474c16efa9fc5f560d8fc8d083195fd6fbd68859172abfb0f1fa07c32861751b1a3d01b45c316e0467a2df9992617b77a296ea11900a7d52a6e596ae7a17b65ca5b66374a2600dadb4bae075afb668a098982f564e703a0a71cf0370a452b33840bc5c997f56052cb9a1a877b1da532a4254b2916399e451e3ed8ad517238743e2069bd9a384ecf9a80f7726b935949f2549318db62f15c080e267e06210649a1fd1fc192d94bac11d26390bd15b8313aeedd4c4ae40d20cfbadf53563d194270b397de80d1f0c2edb8a62a39d9c8fd3f086e15bb430e3101430331a386938ed07d00e0a574bb8d37d8d8173e297cb3d304387c7a930d6e32d49026442ab11e0b28d280bfcd4dff56963248916a07da1d1a107334f8ae4be5610612cf505ff03b503930abd586b86cb35ffcd154df6b7f898e9b7622ce840c45c9bf0c06ce170259dae13ff7dd061bc83f7069b04912f1dd8d7ab169380daf79a3c952d1345147c4d9e3e1a0baade175bad9674d2c00524ce2b24a22b6bc200cc477a727bba2c5ce30390c281109635a3d8b35485fa7d721464e61570fca4b7419d96ada53867a4429aa183e301775493e0fea537fb3a0ffae0a9f2f1db5c9b33831ce07f53b3461d288770719aaa3028bf7bb51d85850c234bae1ffad2e978a4fab5991f7759f4c21c1c677cf06ab4191d119752a6e020680dfef06c75452ccfa2d6c3affdbc2ef247281468833315bdebd52f3ec8ce65a2d75b822912f0d2092649bec7a02d11a17f798ca82472d5e52df1a42e9286b6ebf5b52721c8287025baa756b2eeca9028fb987e3962d37b7943e6f556394a5ef734cee9c50f1c1d5b297cd12994ff5ec7f49906524d866af4627714d1a9a495b99eab2882db7ccd8daaae50854c750febb098112dcbbe90bd422d0c993adf55337a4a31d167e72352978f0e1f5588f597900b890475aaa0a512595cff6a63234ebf7c13b3583fd285c3cf15507fbfe171c35a7e9d4e87c851c9952c8cece245f4689127cbaef68ca91c9d518c91720166d7208413c968b93c1b07491a77c1225a2a9eae1b78e950841a5068b7e74de45d4972050ee89eace0f486a1fbe8b48c071ec7e400aeef1bd192894024e2e2f293e4aee89d25e98ffca3f92c722ecd022411bfadeccc4b161f46933da2e032bfdbc3a163a36adf366473b16b9fb6e17d9c778e34f701f59b8f88f586c9c39b1f142e4e8b7191a64d38d25f9c6a33a04eb46545397033acb791d00445e874ac68147ac17f9eba040092e847d7a9ef258fa616e2d4fa7a202c49f582c058decea66a497e07f3da0532fc7808e06d72c071d4e6f5954e938a2fd806bcb1fa8bd9c267aba599e8d2709e4a52bcd32dc8bdc2715681e630c32f8ebf1af9bb14e32bc37fdf9a458b3b4f6309745b75f1b7b1a31644cd1adb66261c3038d1c1198a8cff62dfba54c3156a3444bbfc0cae8b299a173ab4b99c0a806b57e1ce6be3324dc11d38cf167370921cf2f394395f326e5034360e4c6e8218a9655c2b0c75b15b43d1629f375d95db919606062d58026f99b39f95701d9e49872d6236d10ebdd42d3929530d36ec12c2eef389c8eefef809ab324f58757e5f3b6bc04ca05124b9d8beb3577b5060732f7a3120979cc67528d0419f641d5aff5928d396ae723e1f77e9b4b02b3f872afa016dff12946cda579cc1b643b859e0b47ab07fe3100f9cb30a1a42ef313b30129d1965f79ca8f7e1c2c799d339e2cb1cfc4959cf7b7ee66490489b69842f78843e0cafc8115ea69fc03d0f972afe3bac8edc3ce184d9a528ea89767ba6a867946a5c99e887e9b1b461ceeddbfaae758c2e5c9acd676a6c95f8a584420f8d5d8e17c38faff6d22f65ebe8088bade4f038d53a4c32bdc932b52535ec3673962520d6279643f41579d8cbb0a7e04c81d26c3db1ef18b79f775b24a032f856bf5610bcafcee97c546bf1757e86e8e20749315f9c776060c5131b92153efb6912145dc531558da2196ad7d0a408df1d3502cb016a29d9a1a86418f61398dc7db904e5473d1cf6caa8406ce61c0e0abfd50dc7788662f9ecdacbb45a217b5ee452e51aa250e3c105abe25f81a8ae3fea4ad62b8e14c58ea0bdd996f951454ce1cb3a7e9484f8acb8647fc48970d87292c5f50489f8ef5abe8740180324be07b1f9cfd0075d43ee44b2cd07173670029f64421f7ef2b2fa0903ee1d31277a19299ed360e168bce0af0345860bcb10d81187ac007a056989cb11875b4dc573a7b129ea621f7ed66c92918f8a07f2bbadae255c4ded51578bc9cb7a76916340a7c58c4252476a301be544f7a050204def550836617db1f2e714ec5277cb6a4cf9a181cc076552ad400544f35fcdb2221b137017fa3a66802dd81131c252f4a3c392e8827da5eb3dcc709097f1e12759490a32068bf1ad7242af0a0ad9b2dce01db1f111d48bd8c227962524b4de0b49fb0052de22d6859025d2163e87154ca4fcea029ca2f1c59acf6ff21f12f1c2876c49ec989cc8da6cf915c8d175a40f437b2312393e9db7c7cc5776e7a7196d143ebc582cccc57ad473f3655d8ad496796c3beebe59d0b87da91a6796f30ef0c0c20cab7f629599a55d3f2856cb52fb91b70c8f93f4abef290935336f59f5b5d04eed6516fbf4f2f18f883ef7abbe2c6eb29a6d320bdc8b897566c1e890cc5df4c6635c0ac36dbf650b198db794a22e77e29b796e984b1e4c9809666ca04a65ede851979edcda1200e980ec62a8cf8b92b6451391281945d1b09583c9ed7cae9b7e368c37b696aeeb9776d5ebd4383890d74a5148a1389a95ce50255ba2fda22cd65d547cce0d1c3cc6c7d20ca14e6aeff691087e36fb9ecf83d450bd85157de512aae0ce16af0c16f1ccddba7e55e330f8d1ec890a72d13bf72be2b85875d8294f7c35d764d1746a5775edca2f629f704a00e9d6fc1c1abb3688862ea8307e4968e79a52d93b1f08527179d17686f1c6c66cc19220f5561814ef4227f6b05ec1b3a7821dda631aff40c8558d53dcc49877541a0fb234a5992f1f37d3e88357873b3c3ff2726cade21cb3d2e34ef91e20d9a6196834cccbed4fcd629a49d409d66eb622212af7c88bad9c51c78dbe4c9f5bda223737e7683fda4c271be97af137ae8b0f09bc23ba968382fa15db7a476053efb5d13e533134f0f37907e922d6853ff8beca7f6bdf292166fa2b4df6b5a472350a2e99d76fc6265a8496ee9140305303a15eec23c48b2e360d9097d9c1eb3da01d747d817c4d2914cb400ecb14bfa8ef2dfe3c7218280c6fb83a65dd7eebc88f8db6af7bda2eebe2dbe3c54e9c45047e6cc16ae3b665e3f2c48a56dcb5556fec27831b4d7cefc9f1b72d81d926b762d214f324fb53e8528de862d836e8602f6a92099b8250c27497542b1259894314e95d8877818b3e30fe60b2081fed318f84ec0bede27e22b17452c98b3d8f4c82d863a72489777ad3679c00b9ef533f64e96abeea56a848bda7ee7fb7e2efb718b0e0ad5002742d10eef94e9fcf3fcc564f858314388fbc29364fb3d477440bf6dd328c417844f5054fa6aeb6ecdba401d00fd2722ebdb06f8a502b59c791ce930183a7486955915d11e085fa364f136ece51df0fe2de55eb8025194b5c0a006b992de3eabe3093d3c3470fd8ee003a3aad3c33e9cc79b6150cdc9ddd2036913fde60118090094136e691acd9c289c7a36f52cdf8bbec02bd2151dcdc510714c1757a9a74be3618268eb91a67a6a46690f5d70b45b7feb51ab89dc83f634374797d84c7960e93b895a6c81f74aafb6b3e27a327b541ac581012d79693a0f8acc50503982aa8880573889027b655fc63bc08031ad58397680329edd2d8f97b5b09245e7f15377674c4483c6e94bd9e575ec6e18293c236509e750754fcb1949003730a3dbd2a4f7be5c9846b8844c920b15e768ed5a4a4c42d84f84db7d59e69b39fd547a962e190046d132e9457aa15ca92d9f816018afdff86bb31787f2d1f67e5259c31a86ef7fc4b38389ffa18b9b17e7706a5c729bb58053cd376eabe61bdcc4b52b1afdf7d2d68d16f2d052a98d9b53a8d851fe2a0b6d7072eb392302fcc7eb9f9274866c44b8f476164229790d65d23af951029ae46398a68a1b61f3418c47bd8ed5cd36f090fef96e96a6a0aadf8732d63d99567b5d5aa69ebd6d275b75fd6b1f1887584fd65140a9d080cdb210100e9c98685dd9994553bd995cef5c30a9543dc45eb838b2a83935fb01f4e381fdac73f441945cb3c5385d550f4d2dc81aaa56312e740b341bba1d7e86bcb81ca1c374930b2f44760b37f9d257aa70e3173b55057871703cbfa03bac58e70af3a69276ee17661137b168657de7a51491af3914e3963f730baee21343cde5714075f4608eb84a0556a522dbc1c80dbdfb6cb1bcd4b8b131f3f9b2967717dff047e14ea3da691fb4bf6b88ce2884f8df3571404d45f10d3e3160ca2f25e0fe608647f7d213faafc88e86955e05e52293894beb1851779327080b7cf6f0fed3d9b60433f51451416835f709e891c9781c1058ec0efa287837f81c1a50d65db6223e39a7fe426d0f0a51e424f45eff137b010c06f9c2764f5b4a1a92d44ae3fb2b23b64b536607f99aa63eaaef5b0e906ce48bd905e56a4299ef910aabdaa0ac91f08f4149fc39f91b11a09dd431c0a8603cb958ffd7c1ab285f4f29f833848ebc5f28eb1bba53030532ac1c0cfba060201d4e1a558a8591e827f6f1e9b6464e19992dfc0e44b7817fe25e5223703791084c25100e0a04b3a184304fef3f669463997b6204ce7cdc9b95a1a0ed9eca615f6c7f86acddfea0bb426a7a27386e0bce66f640597bf9af2a7bd7ebe836c8b0edc6169c808891357915d47b1f9b1b30e539ba4abdc3372399ce38914a8c9df73459f4dddacfbc590762b57625de1f1307d45e3690b1345719f2cf4ae349633f062144cef99783817d6ebad65afe186d50f1734e9de436fad5cadd044a61169cee7efb5a80848b6535e8a2252a217c7f8fcaf6582645ea989302dfd9c59c9b53858c5aaecfc8edc7c3e44f19f9cd4b6d78ac5781a704035f789d3850fd198858466a6da9c7484938483845076fb635e2b2e19fe447ef00845c2f5003c76a0ce69d23fa9568dc7962e3679486633f02c1d34c0aad2218e6ac5839f604f866c790cc6c1fbecfb8968fa4116579ccf14b61f28ab29724784cd40e46cf2c5b9900f4031f57723599d4be257d29281b8b07a9a16ab40e46a2ffb3d18f6cdf3111a88cfcba0749b4e998a37c7e8b30bf9d99fed37e21b51e988633c38372a677767171bd59a104b3b0bebf4058793aef15ed93db2efe743e2b88c7a2ae4d7808b1096f42178f043aef3e523456f092f7b755c9d5286e8c1478964224c5f5bea8e62f03796b8bd21e7714698283842885b6a538ce1fafc4ff3035d27dba196802741a88309434d2350bb8b81f6fe784f0d24a9a964ec02ebec8a5fad2d7a96e8b12c92ec090938b39d1ee1b0782cd1e5d9dc1178ec9a0800cd5e29942e1977c694f8821cb86e437a5a7b293aa3c0e0f92c32a87e911258633424ba4eed3020092d66c7b1e897a77c3389b00c556b657b34684885966ca989d6a364643a3f818770662c3a33ec49509dc158defabc8a7bf3a411962cd22d3efda5e051e76f5e7900d5a8dd96b36a340115e84873942e73ce756087ce2f7a34a41c5a0f23ba874d84bf57d49849a55a85dce874f684c4422ecb9d207a9fafa07fff72a36f2629b5aea0de6495cf4251395f9d58babf9007a11157dbcfa8985e174b06622eab6b0e23c54ff613279886d78653ed31c41feefd1d7d5a1969bdf716f693f9a466d75f14ae71d7987cc85d4a774d87f2fcd5e8c172478ca2233e77f622a6e14cf2248cd8ee6dc140ecb2606a68b2e6dc827d763bda37b1cfe20e32fb34d90e24abd2c140085bf177c29b63a5fecb0df85cc4e47be46b532aefe70955333af5a2e3e628a9619","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
