<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"4582b3cc3657cc092d0c347d9d63701465e8c8c8393ed1063b7cb060122710299fb309d354febdbda51f8f2e29773017159d5b721c872737453fe90c612829819cf257a0d33e8dc1518a110c66c590779ab8fe0a8afd9348da0b0ca2a21a2b94547f2482c7e9865d340b5ec1f7e85ccd3ad0bc9d5a7faff4c99525b80d58f9df6b94766db8453c7a5dc434b4abd885ca54b0d7f3cb7660b083b6bb10e6486e274c39e2ec428812a8f54b92b4f7ab28cbeb5ea5a06bd58f354e61422e4d05b785491f7a50f52408971337c797caaa340e4a94824e2fd7b245b1ee0b747644c7379a0dbc01f3710c27e81ef750cacc8885ce527876e218c6baf3867ef08e5acd5ec7ac9dfb7e069e80a44a38f13f1c865e1162c68ace059c55129a1b7a13285cdcc32154be8bb46a94b30ca1ff8ba93a80d4f6630b9da854dfee3e29a833ba13a07776febde7e2621c9a4283fb4cc848229fb43bf0d2d57cb3a05a1f2a3ad83deb7bf78e79d73702598564eb20416655d7539f503073ecb18bb6e6b6d34ce5db3b0469ec462f9962d8a36cefa2ec1d44d1ca3e62c7021ce366081ece179aee89564e0cd7af4022989557bb4c131bf9327b3c225f529f01e449e0f4839e67d0e9c4675d91d55324b389a867228c027b70788a54b0cf5d66919f92ccc028fa45b050105567103cc866b6e75cc53eaba99403393d31be0d552c98ac8ab31d009976f14de0a1559cb9b74d91923fe5ce3bce2503dd486e4b6cd1584fcaed301b635462fc91b57aa22cf5a7b2f909d65f3a7086c392ec7e6664173efcdb262adc26109b37b6653d38925812c5f94e1b30a1963ac59e5769485d2d7ab0daa0a55c14f9d4d3f86bdd5b619ce78e593aad164ed8fa970c0b2063d4e57d3488cfab311932b43784f2fd30de3f9983674eafe356529f13afdc45d63b17a51bff062931a2c9078acea5b9ea75895d2024e9fc170e2ba62a104fbee2815126a76c480b5b4f8f8ee85e350a36aa3c049e1ad55df8767b88fda5b84614f5cd88fd9c2f988de95d955e85d8ea789a90edb006a85ec6820ed7b8ccd6dcc1626b186b86f3033ce26e678b6ddc6924f48781d65898e9b88283d07bdace093452bfa780618b57e20e6a52ffc038295f4da607a02e0db1c59f91c5b678a66b12403650fb791019e5af67b3a6e9cd29cf8cbe2f03f91c7e99e1e508b098e0dc82590db0a0c4e5b73e63da816c67ebbf7e70e7d40c8a99ec32d8d4f40af8e4a4f8e092d46c64c1c309d6a51542e36c08f92092af7b49e876099c94921d0d5e145efddf51dddfd00c87d08215ba7aa631f6da6bd3af3e254cbc10ef2daf7a6031ebcad5c948f7a199cd790eef257c65523a0eb1af8e86041c9ae4f84016ec70d1959ac86358815ff7d1c73c27047a5a61202afe0dd290025dabe33ba5e8ee745952fe3271403225aa380aa77ab8bacb412371f8492105a088bcdef083af93cc13b5d34865062258e65031273d833a4d59f4475ea1813e524270f6d999b8c7c3227e7c42741146de9256ffa1df81435933299e20cfd95a5a5f22ceb9c3ce25ed27d35fb10124c008adbc11f1cead0cd02c784955247806f288a0c4d1752cb3cb64b70c349bc7912f4fdd7dc9d5f72ae72522544cbf0ffe5773fa77d8ef144a248863d99382e2eaceb58e7054688a3f6c8edea309c3f1469799603d7eb4faf3d1467195b1eeaf001a9573409e1dcbd1bcfc4eae8b932e34a0364a6f54d5c9813a395a2fd8cc49fd76f825fa8c01cc3d067e8319baee197b60c0ba2e7e310482960708b49bea8ff18ba10ce2e05afd7f2bcff896db8e9c922907d6545e423732ace250e901eebf1604dfa036cab9b37fa0b4cdce0147bb3b16a5609f444b26de3c9e1f363eaa8cc04bf32e2e8ea4bfd137690c3a94a37dbe6d8e9391931394cde39676c0e681b861e06fc4777883c0e94b6f14144e7c7ed92e86e5a71b52f6b4fba7c8ae027391b1aee6fb568a2cd7d935720e5fb6372502dcd66f559ca76a23c038e1787c390cd100719d55f9e5e1fce45b5b3f7037b0348daa99df34af309ef3fc7558adc84db0b81f28f3914c34187f9b71b14b9fd192fbaf525103c314379739fa4eb08957e1b3eb3b7d51d934a833b1b8e4be8d9941d4ff555e0f568c2ec9d71b2c1c4dd4365b4928000fbb8fd5368de39bd53443bb80421156c5cbf3ee79f3601d8f48cee1b143a05bd6b8695bcf8c1e0269be4be04310646a393ae81400b38e5ed8e7f56c3522bf2b5681e156dfb24ceaa173d91de961d0a290b2b455d9e7a2f3c73353b18ba71898e3df9682c00f0997324b66a0ecccb1931f54834618dde49c23b952c49174a0b22bfbc5b115cc43764c58ed1411c74fe42bca1182a824bcd4378dfa1a488b8faf8b2a80627af9b3363534d541f357f1017b4858eb546cc0820f56c16092e1089b993537b613e3a70c722dfcbf6c5317a8b9b9fc9c44a7afa1c79894ea93cb4f8d61c0976c79c640784cb6434e7d516a226a5806894b96a9325b0c02b2252db60a3759f7e0a5e124d6c2114ab8d13388657be85933e7c67dc62b4f4a0f43056889a6cd7ad451fd53936bd9a8fc36228d287c5de38fb4846faa566b8a21bf8e6bdce88e61fcbbe344a239025ae3befeb33525c94924f706f39f803af1c2cfdc41f61d83e0b5bce7dfdad96f82c0c7f2cc984975271d300cdf06f5c3c3f51c2dcbc4301c87b55b551822062ebd8d313dec01c16b87561ccc1ffd548e432154abe8534b009deb29384eb7fe29923fb1897183f15da7f89224f0bf52192b3486590caede76b1356ffa6b5f09a6b61337034b63a1ce176bd1f86d9aacd8c62d86d6ac145df214a0310e6cef23cefdf7ca3c684ee42213b746b2ba79508225df4711976d744d93fc02278d4b3acfd76da7e5137245efe00807f30b0f0e48f9cd3a28859a138b4200b15d6933c6b03501c08802fe4fc0bc7eaf9d0c535aa51eab214e12c3658a4e99f19020431d6243b903a3e25f8b9d01fc7884008d250fe8eeace265189a07801126bae204a962cdf604cafd371f91c551e5e901ee3e622b9b152350b53e873f55c69461b7e6f4e4022dd3fad6be63794bf674ad4f2e3510e80e7baab1c843ad122ca0668c045e5c976d1b5d64c987386070b43fc5d939212c01b1f50db4419e26fdde0cc4aba5e620ef88eb9564b93522928b12d05fff45b85259fdaa288521d8c841f8e6f92c06f67741ba184e21479b1f41a5c603ba045a400755ffae4b678476092ba359fed679c908a23a01d8575beedb0c1c326463903f03b1b54d9d33ef26063470b9c30d0b203f6b29fab7938fb61a19464148e2f714afb535c219d4bd36ee0d1c15a47a2cbf7ef18aae9155a233b9c4837b890ff59d461f60d5e65bd5e9fa23e67ffce3177bedd8eba6d8ab005365d392a4693b94531118570f2d21e168f3ff1f9c3befe9bf196aecff5c033f0b4e0b3fe9d45a916d2d0b3c62e51a0c4dc4c3d150bb277245ecbf820c4c84176cf3b401c509c16cff91bfbe0c1fe6a014f9fa79529feb51e0593694a92edda8965c9e66e909c4b4fb9888145c1575ec4e0eda64971e16ab443709af5363cf1499e765c38334916b69120e4ef58d84dfdbf7c2cced73ba864e84503861aeba9387006f8656f5bd1bbdb022c1015a1ae2cd348fbcd710ca9fa97bfbd2f4ec8f2a9b0bca3c2002b8b95aa63d7694fe9fee23ca2c747b96293942f0e41d6dcd66beed29044b67cac2a965dd28543d21b8f2c6e0a0a16bb2ad3a4740e275dccbee87a0b47161073e731e0eb7dd01ce27644bf5b1531c804dc4d3c233b7259406b4d4822b026101761889f1e0a2454bd93562568860dc2b8b408cad03e88d426109823d359daf347317c3df644e9bf41fc19bf3dbbf227c9fb2b99f6c4dec0856a5105d2deb1b77eb957d345d7d2e4261b23fb69d48a25d37b85f5483ddf7b7b89318cf65cb6bb9356b51ae48a2dda6d523582ed2e193560676a0b51629abe641ff5cd5bffb745a6fa244b2893a066a532c05936cc952c79273d13c2693400e0d839277fa341e2dbac66fb09ce8df04d2d4de19aa4f899fd4da62448fae200659cea52144308de522f5ac376fbd52c76d26b346ad704325ad8144b01ce716cd667bc0b858b9a535ecc6097a4279577f4cbd1d0234661ed2ac627303ea953529fee1e8b42b6662578553076c66677c98d41ce77daf40ba54c0d9b17330d9056bc25467bfea44b28ceca78e8785b47b4231405c5b821ec6defb59c8ee93b3cde81065ae61b1bbd65e53a54e0841e9140a5b98d6c02312b6111efcd44a266427e3466b296b21ebb9cb67fa452a7f3404a896d1334aec042343eda20892e10ee69ccba7013b0b02e8d462d631f672703bc618a62156a440f00df5fe2801c248c7042c05bf8d65cf3dafc5fa2a27448b47de95008457fcee5963ab1cb3cdfa737d7cac2394da21ba08bd1298550580769ffbc2cfd3e5545bbb1f3f13a74a36b70e779bd27d0583c13db8f6a39eff019e0f01150112aaebc1252791a8d546f6740152b4db58c2c77837f7d762e9670e16a01c7b4b7fc8ca2b861aff45dbc469567ce484cdc92ccaadd89582ab36d7f5e15145c987592df34edf0976512a8c3b6bc4a91559eee3e309a27d8020026e8ec402b4eac2e127a303e54ebab6f722ddc76fa5c43ed59369e784b23294393aab620e2b7e3ef42e0e65effbc2353b99ce6149324c7924ac72f9f9751ef04ae5d09da2afa7362445831b83e222b2591554036f4d9931ea6e955729dac110c24526ffb757a6b95d3911d1e512078ed5405b34577a519bf999d50b1e7ce56c248c00124be5ecdd8c9556b00653829e3f31794fe8e7e350c5888fbf4562173f382936297938d5986776aa5089b0b5a5391992e644a779e2453645b1bc28c3a6dc6ae8adf6a3d00d50f2ea17b7df6d365b8879b721dac794733f8a8a2aa4d827850a08398c7af066d81b1661e65f599d76353153f8f3278ff7061244818ef40b15227dccafc7e29c9a233483c2576f1e0bcb880fce244a676c32fbbe60f3b622a33730bf66c2d2739036f67fc9c383c26c52b144c9452603eb8e78778ff77300ca3532887a07219cca4cf82bf6a0422ad3590702c46e2147748c479cfa9afd6c2ad61f34e23e3fabf8b7727baae68190c3878899cf95e239fdb15da149e2d0b99ca4ff2d69421afbfe370954fb3650479cfe2d8f360154d1a724849066ea7f47dd435d8bdd9d263a4ee10da8da6e206ecd54648a9a9e6d3970919c27e4d9680a510c69d16805516a817d56c9eec460570bc140073029a1d4e72c8374ef0cadbdbc9ce2b40b43e1732e3ee0840493fc6c040e09573e8183c66d399a2a406680829fdcd7f0ec542fc1c90d7a9a4d87ddc322f3109c3de7d212c653e4a7594d9c5e7b873b58ba40fb6f6b1854e53d9af5c0c2e544af982e20a2b0c6a098a32366ef1efca43ef81f8289257655eccef97115a012b4e352512727bee40572861286c500a57775e1e20b4c9badcd6293bbed7ae6bda5ef695bd0a9373f944ba4f8dd2dc53e6925df03c9004c3c94cb64d7704b269e5ab8083c529a42d711ae289ee33f52a7545d91556bd9d098645ba02673d7ba8450e58dd471c2799f238de2db9a89d7e69f73713315bc324661a3e5ef8ca0c3cfae23e7b67f297821909d5452ba1a369c66ca3d221460ccade65ae86fe807ed7ff652a07bb37f167a9fb587be645d8e7e8488fe2a2a916e2e5795202b9b732ec2b6c22cba68a5016c45ed01be008b4cf1b4247688163066bc32012c7a45af0711dc99b1ac49373794c3018a3a8af0d59e0e3758e2773bf632c1211162ba74eb0bc8dd9ea4f2387b863088fdaf0cdaffe8fea87ac37f2dcf6ed4cd1bf5f2a88bc4df8cfe2d196acb2e2eb8ed445d204d6c3fe0d667b076a641a1bbec21d3c9f26df920b427b140295c151bd8e87e6b60ad1094e596f8ed665e0512ad6cdfc981914d7432acce24638b81000dccbe4f8c4b5a32e8ada630a19ae5429007a68e49b886e280a8188ad6a8bafee5cf759647b8466b6a6a6b003e04512db31b9e3a4cae300edc0bf6127b1c136c044f652a33433d7734ae09de4b6c30143fecfb5e236bb54522e2508205ac4d666565acf2b6ade72c79ad001d8039b2cab41a28ee86ee27c37ad899032b959db67260d39bea675f4750cdb06a7592f58a4d6e126f4280bf34a8189f30e75bb7c45fd2b0e9b0bacd1dcdf603dd6cb087c384e999ee78348f693490630a6e12342d21a0bea61c3cb33dd2c6e2b1e8611d10debf0a265efa4d07b8808cc6126e209e19eed91290d504fff3298e5ce1c79f11730bca95bb29610f47a1ceeb7dcd24255c0337ed1ec2425481da21cfd5194d0480a160df86d4f1f4983b1ce112624f471d324193f9fe287029f18e6ed7fe813dfa9666cf4c36bb0aafc72c956bc6ee0b7a4d5b47c6354fa5a0c6792b78fc2464a98b69382e605e6604b7a39fdb37829be9703178836d23f65e1a0184be46648d2d77e4b8abfb90680e67846c19c3f06661d95a9e8e615d9b4f0f0f8c09ef53b1e37dc988afa35c2453d2be9e10079d66cb3e04ada61fef3acad79ee265b0ed6feaa40524d41e27cb778351c256f281b92ced318dfef29d82531b10e610c5a2b926d53ab2bb813dd9435f06dec22af5eb07ff24c0a1e447cf23897949bf1de156822bc7ef2cc2bac625c652b39439856ae9e63149f5b4f5715dd93cd7a1e161f6005da0698ffff60d24ec4fb4101ef74028f7feafad3c154738d117e3ec514bd90e85eb2f9d22b546439cf1a026a69df3a821d3ce8742b5e29523555dd4814e1b161a452207fef6d51cc52ae455cf0ba532003fddb5ad81a3fdad599332f2e4446f3b696dc3b43dd0b34ed5c76bb212436fb0c030654cf672b967d4d093ef24edb05d78a441834613b480e0eeed30b924644d2d45e6e4a115a8fa59e8d3ad6b35406f79c60a90eaa97c75b406b74ca2f9e7d5978bcac2d2363b312ef1469716e480c2456f5e21e5532260949cfae29c4340d203f6cc06f96ea835d049fecdea1884c2216248e5f4f9d4381556d6e1f827d129e0a7c537315f37eb22406fb6685d3a6598cc39b4a45233842bd1eaa8e785093a8e63886e8a8c4f302e35e89299b8c60e0e1b6ccdc32cdd1a9d298e8094a77d4f7bf532eebba08d3d75b40b266eab99b49f51fa3b190768153b08c80f24d219994f6bf102a1afe78315e5a5f8152cdc725b821b4776b3f645a20b54f014337c0d8a19ecc5109ebb6dc433c6747b702d74a4174e2b72f11648865ec7d091aef81a3ba3fe1ed4c45eca5b987bdf583efdbf7a4a34747b6a4a01094456d742a9b323c615b54ea350d0252e7a2e70570bdfd1f559a5d0f6836430293193b641c8837114724aa9e6798c17e7be8b6a0c00c32d44c338a4c3279bf98612730ceb75605d293b9f3c1fe38a015e8bedca93347aa7a3b84db5c6ccb64274562b643b1e15d0b9b2da42b68bed9899f88ff3afafee916463f611ab5c39a252ca74e9a0479e4f1fab0d8b360c3c7061cca8ee9c63d105a6e847b27a6b6ebee0b6378ab557e1f43fd8a3a53f2002fa8390390c4f304e66b0d068870ba8a95ce34a24fa410e6b1b28f0b90815b4f382d82de3fc5d67a140e86963cd4a85c21ea4c50b8a9d4f39c2709091cc6ec036601ce0e2ff8c0304894a85447d60934c3c3ea424d470fe79d93aec8d57e1b549a222f2d63e4ef9717577350fb47a2bb6cccff5f965ffb325f96a421e440fc43f4aab41c79832888113d6d6202d6a9636b0074302e496062e8b79626743baaf33f1ea8a97e8a3584759875d9f8f9efef77553f4e925fda707695b207732c33b1db0697658f260cbaa4c3117cb169e249d6b725928357956642399517a995b6b4416a20f5251d2e857389184d132aa546a9279c37e319a5a6bf5f1c0aa543127d872134c55ff651ff7e898448327a109943fbcf1f09dbb87cdb7cddd1c340a26f4254c859c9ded93ac150432c36c6673de787cc56fd642ae7cf739962e67dd6630d86fcd70bf7215ae7a148ecbed0f0640f48771ed2dccfc6d0d226d14863a3a74c82a6bcadcc6790280a9000b3c438e66ddd865e0ca5dc2a5562bd60c92c2d7d0600d67a835fcd12dec602100a0f08b7300be22f1914d7e27538e036e77fa481549ed21d74047409b877765436e98ca5168fe0da51f3b93d3665d7f857826e22e7eecd2fe25ee446df7a1941369a213eaa021e1a2e41f8e2cd889daac1c24189ce5b1bf788b3b61c1ca7746ec1e23fb3b25a5ef36e66b3d3e34140bd9f20f2caf0daff25cc5564555c4bd40de021634e54f6c1ab98308a9b636d2207b24cd4350f311a2c10ed1135c2c347e99c9e3a71053e47a6fce3a4b8400e0aece8251ac25e89a1ae2589786893bdb024bdd87ff0870225f035e539557f12e4292fbcbfaa4f015a358bb62b0fe2cb73663888ad0cadeff2bba762aa07263d0fcf5683449c2bf8d4142b78be4fd3f3f88b94c07d2a420e5a21fdccc6f5dce563bb8452b06d34c8dbcf697fbda9759ed0d1fde5c96e461de69998805cb137e88348442af9c279594729e67ea44c9d1099989d460ed8e24305ace5eccbf423dcac87b2aaba0cecdb27ab907250724a6481b55834292975a5c5e89a5151c04e88da7e31bb09011c255360a8f582eb3ad47a682a0cd0eba79645013aea77fa3757d6fa3ba2d0ab748c1869b2d4746a89e26e4247bb5dc54d35f6ada9ed94d3066602ba13c91f7e3ce3b029de55587c332da51732238b7d28b7a9f838a8ad862b0f6493785ddbeac901174eec0848965e38d40eafb11c0514dcc6e20bf224bd3253d0a461737a9143e85bb29163df2b01fb6c1d0adecc53d77ef1edf275d4cf7eda30ad20f8d21694ccdbe7f48c9157bd71060c5e5bb3fc5289a8574b596be2b5f3ce8186a82615c84e40a4fd5a4bb3d1b1880c347c5afbfed1f870d84dfc3317977401d3dc4a9b83532cf4149a099546f04a5aaea5aefcce3b9c0096fcc23f005eeb3deeae209b341fb11dffc931a1623ba99609bed4904fd8bf901c54a154a1dbf2594761c2c5ade0efd4f5be807d9467a65f6fdc20e2ee05ab8541ee991999002349499bd323b657962e2e964ef6a8a8cf95aa175c2efe0a03511069a71226d86008637a98b1dd287f01aabd139d30bbff9754bb94f7f237adb9ae2499879aa075823bc1409e9d8e9e3fd959adb221855643a412d70316623fcd180fab742396dde7aa79bd736a7fe71a40d66b4c4c0a31dba88df6f2c5136fb19c17112348cf7ccd58ec6c05e3b227841d7622d388786c6493752156ebafc65bcb8d4e36c9a28e838f4f8b2dffdc06a875599cfd52ba73a11001c38c1a08b022769216699a7a5d967e669c150542e5b28a00eedd70335e5ded06d33e3c6331e6256d3acb0f01bea8103d850620d01d06d24f116ee19af039a1e8dc5f7ef345a06d8ab4aef2a00b12484917e1adc2823b48bc965beb9091e9369b6ff61c93cdd55dfd68ee1cc87aa67ee6dcbb7ee87c8b6aa2376e9246c202b74fbeda7dcddc4519bb71ba28cd63139ea76fd27cd1824860e90457b98a3f4a96fe6824c8a9ae129ba617f1a4ad4a6398de5390a660fb8a90b21e0ec53fb6adc707e9adf28ac98e2916c6c695da235047b23a32573f570b9cac175ec81d4cef5fc12dc0b7c0f98b2c1dcb436aa8369f3266ae2be2c60ae2f5d16baa0fe8fc256489fffd5e81d2bdc2750ae5c96eaeee9870b1bd331e27d58cc5b2de1d1d53b51da5a3523aee22925ef38bf9a96565161214f48cbd0195823e76f4a7179e73ebe9c4ebc1210393193c0116c6e59d26709b522278f5b0ba4160dcc4fd13d447bdc4910e6f4416c99203b303a5791171ace4122f8c7d2a5abf2b088bf7455f4248a82f45edca1a19c1d347e056f65ebbab450b7c9945a0127400320b2800cac17cc722aaa61810e3eacf3aaec964f87ecd4c55f50feb445df7a0163b30e3d47860357682fada81619d3294513f52b5de242f660f6c80009d4730da8225f21ece6b3eb8299e20371d2434bfc4f03724ff4b5f91d7ee087b2da5a8e40384f7fa33dfadcda6ad107fa66d1908debdbdb8cde80d8a0f47c1f4290a730fb5f7513a3e7dc4c9440b712e5add8bb29edb4770b74860e56c89a3ea4140c2d85a10ec8fc039dd07c1b174e1134565386f1d15514ba68cbfafc8447f884b8954d431a2873e650ae4dd8de5b81ed22e0e421fe466ca9d2332396cf497b9e89aa0b965e78ec3235e50d04866ed2ed1803bcc7d9dcd3fa1a39a169f5a890d93e4ea7e522b4125ef7daac4be2a74441373f154e23b0e1c8d5b0e8d2eb5685db1338e49927d27bc9bed4c9ee763328288862fd73eb91c1ecc2cd1f8bd152a6c4c97a9b3e0b4d8bae6431e74e0b7bdb43c7e9c8d1f4e7ceb9545e77327466a986878512bc82d781893aba37b683ffc714b9225e98a1788be57c22f15e8febdc1e59f3925463a63b0c19b1931079f0741bdcd84c9f458904b208c96638b9234e09395be90fce0c13e3b73026ca808728384bb97bcdbf3697aa88649d3cff6fc0c246cce13f85171d1195c24e45129ed168af4db53896ee47d84d49fa21c4be6fa225ef72bf2055b325e87bf94266bb2481cf87e0d9963a092dae80724101a3fb1e025d4bea2d69b8b5324d3f0bcaa14d0b0f96cd7a57fb6a38c88c7e45720668de2816d4827839f44d8b2165c08f4f68e6adfaf68bdab85bf44d705af9b2a2bf1023c93b7d05b61f3646b2ec11bd49673aafcbd084650a76452fd265be80a33b1d422b8f864941d90187b41e50eb346e665fe8994e841e9ac69dcd5affbe0589e87a2105b622d8218b7c7de80e07053ecdc71dec89e283941921777c6b3adfb08d0b2c607481d05a8c8bd2b016129b4946a79a81ff0d2dcd39c7482d2976d5567d937bccbbb70e9cf036928762236ddba10b56ee006bf0fa309675ca1b3688fe893c52ec93754bd4ebdb70543f804ac209e361fb4237a1da8167962d9368a78f19a39f2666b6bba5caae5c5efba02499ee38c7e0ebc5082a2662ff3d1dfd6235526d076b8e30787edddc2318adf12d1e4a539bc539f46077f35bfa97dee4573e05fbcd0baaa5c6c8fef035010725733b5f74a365965aeaf8bf11d4a0d952847362250e69f8d297642b570d620e0187806babc82db71b2b9252ef5917d6a1de2ca8b6802c461dc406e2d5604ca2e86baafd5423b8f504af58eccef6dfdbc685cb91e29b08412a28cc3f268727363661fb4d2df0f8852e0e7771cf8acd4d7b5de839daf0499693786978db3b339e9f67c91311c759f821439f27cb59e6a79b186b562a5fea799206b12e27cb6b60d37c22f3f888e25499b242ff2ee0dd2af45eaad27cd50697ab10629d5d79b12abbb1379afd39162ea50d6dca09a9dffdcb99e92447a8a399455afd2a2ceaf047d0c31e299ab9bfea832f2be347be5a9bd8ea6dfbe9bfe36ff144aa844d84d8dd7455e2d168f8b493cc7d2c1f129644e2a20701906a389825adb70c7aaeb5454ab35166b061e9a06b1a567671801a4a5c520a3e572000eaba9c910db5bd586db4240792085dd99808201fabd2cc06fd1aa5843a87def20e4d45a998639626e507b295bfe157671f23f00e782870794a21868b6b27854bdb557d133d24432a46e175368cc63b06c229519dd7ae8c84e2085c9ffa2365e57c3ba706c85f47b2cbc7ce3527495cadf217853366360b151409b9014be54563563c242f57a5d3cce16a5cad682802e729515999117153b4f4592861421007e0bfae675f92de56c251c997e54bb558f11e3bc9d506116ce8b25d1c3caf9ba41cf012a63ff2e2dbb6d18617384e34c80da6c45e99c9b70a3b14f5022cc3934979575f343367d15ad842ba0089e135bf96eb160a99d3db8059e3d568be19f20384c816aa79c9d99d3f54adc293e6c5efa5b729af8b821f25ef54b740c8762b4750ba3c442cc57d568a0a8366ad789b09e11f77f6459ec884b227da0b9ee24ab6e42dbfdb0e98b3abfba28fd5eb801375d98581edaa489d1e4f59150a2638270410a1958da5201a36b613ee953f3cb675f5ca21bb6a358ddbf82f0e56a02a70d4801974a2f60174c0cffea19822cf6535341eb4aee3f70dd91c9a5c379d842fadc8b9f483ce190035ef8625b6bd0ffcad162b3ca119885fa7164220fdba92caeb2a7b6df0a9e776846e9524ca565b7d6ec24ebc7e3574207281c6dc9457de3dd59c0e9dd4d35221877b5136542d15b3f6e52644e9b76b12e26af22d57ba39a8c3bd048d018c9a9812722663beff232b157176fbc74cb8243b19e3d4fbb1454e20a7a4ee78badc1cdecfaa5803642036b5cca3f8fe55c1c5b73a7e1e6144a973bee4d3055ae3076c8984ac66b6a870038f73da312ab7130fcb1fc84e5a0a52c2fa78887e225b9ed499e986be42c360b5d0376a14f3521475f3741f4b06a30e695a19e141f66ac26f04f6af3a99194d79ce71ba58bc3f8a76022a14552f2ec92887070ab3b8bc4dafc5ebf743434d151c76297e88e59234f170a881fadbe0900831dc34e42c986a7079abd6ace1efe52a4cfdcc6d9c951e4d5b7fadba0179c34e7648cb04b9d624848f6f5301a686c963efc1bcfeac176ca10850afb44a59895a029f08da3ba569f6776f149422131ad6e1dcb70ddc16787fcae8b200de181d3a7b09050e8ca502d287e2be3a805ced6a72bf1edac3e0066f16fa257b48310612c9c59abe88ee415c287b6040b7f80e77207ee710f88a73c2e1ff45a6125c5fb9e4835220294c74b4b4962d738b351276010d5ae5fedf3459986935da728eedd6b77c5bb70a077ce72d8f1a13466ccd3fecec1d3026d3f6d69bc4edba61adfca054e9ca831c705d47b2969e6d73b19081cdd3c02b051ea548db7fe9fe3cc8a6ba643a10ebde3e6d5216ef463cbbd9c7369385a22c1f619253c0e71250eacc2f159fbf9c2467f1c096680b288b3a479d01a010794751e4e88b5a6317f18f7d86b4406c08c76a86f9849faf9fd6ca00d6fc3d59694f1e3b04274a6f2c4156687f1e58d29d1640168ec1de74f31a937a23a403d296a747fcbb54e1b95bcfc65af8b7fae4c50abd2cc9cfef8f930ef003078984d2e98015d61d037c64dc6a7aa4940af95697a511b09ace5c7a055d029740a8c9ace650f006dbcb58b4825b14970f581a3c1817691b4c091a7a5cd374e823ececd623b0f8c1f6426ef39558fac3e464094e9ad22b9b0fd35640a021778ca4675f4434fedbd814913a6d6a618777cf4d96df7d0859690b5ee8c7252d729b14dc390b9c9e74c82a9ff57cbd41ace6a5db871fafedfbe1e5438490c04ba5116d7d9b1461efe51adc744fb0bbb31378b9bd698b324e4afe8feaf0c5b7fa615335800ee67f90dd13470e32399a3ea739344a0f87d69dfb364021658957adc6e5dff969703be29f58a32b061ab1d2a568205bfe6996a1db1df3250b1c00ecd4ada32962923098f43cdc325eaac60c9c57f662d93aceb5d5053e1fdfc94c1e73f8bc35cdaf391ef0ad4e19b961c95a9dbdbe533ce1c94a1ba69d8bc6df64d2a876b077a22d732bbb9d67563a1ea9926f912c0dbbaf575fa0a7cb99d7eb5f4b2132755b11a4b6ba7abd7d86a95601d5fe860ad02aad497e5f08620e245c612e1c3b0a0dc1f849133111bd3fb40965d19de555b8f1550db650ed5f3e89971f84ff815f2f80594c86f8a69914a19a2b14f1d5248f1711461a2be4fd5be52dd3663559841cecdb87a5db5f04da0fc60ffb0bcfe7b0b23aadc872c7b5c3d7f9456329484e8af95ca84bcf7016bbcce66e4b6efb6ed222f295f33a2606877d5053ab1ae179a4bcc06e124d011404798e52030b3bf1959bdbafc340b9a5b6609835564dc099f6b9185d6ecaeeacf79d5a35c7930a3451f174e2d38472c46b391e1c647b27f8a16835a353eaadb17d1c37c982de94ac529107efd367562a7b4756fbb9ddb9416f61d010dab010f60db78a8330f093c5974eb697418cdb52c0e5bdfa748d598111333e6fe147e0d65b47ee6ad3814359cd553f684436a3caed28c6fa18e03828f6ffb543c54dfa070acdf424a9aa05f2ac5e886f7df2de9a7241fedcbab83d73cfed0be576d0abacb38d0f622ce888bc764b61ca8eca72c1eab886d296705649c227b3df361ca1f6a868377500e8c16cffe0cac76a85e3844896b33a4f5f94f21dda3a3b46d9fd089a7b4818c29bdba3dbfe08906d180c5d5425047cea420d18247e8acd7ee707f7d9ead9249b67cfa44b417e42fa0ff93a27a3dc850de8aa31dcc073c62584e8a17acc37f181f39f6e88c280e008388284260ad41440746b6551973f6a95da9fd035e84b591b5635e95aa4afc73d0d2a80da31dffbc23bd33147d18ffadd6fc20145f5d0371f4159cc23e06120eacc7a4a33a3f62aa8a681705f136b5bec2344ffc3d837233360113d7f230c86c3a784f7e1f00606b50eaac89af5e2fd9e6477a42ab62b5418febc8378a42e213c44579e114d82bd35ecaa90679a648434212d4aa78b92d8bfed1b3452398ec284841f809318e738a2363a974fc009bb79e413cd1862062860ff92e311676cb63aeeb7ff7eb7d4e9733ea6374114c9f71b65ac7bfa0b93d7ead739ddaa6572b1a8fa9f4532a4f0d10ac83cf6fb18c42fbae252e8e4bf082dc756c47665ba3236d0911db497f0a2c2d2e49ff793ef940a11d33772c3f2c7798b97db4c4d1b3fb781ffac91e8453879b11af6b29f510acef0a417cf0eac34881357e8c942ae5db9ed83ef015e742178e99ae6aa29abff3363d70fc6a62d7e4dd89b83de7f2ece1c955487631ca808b9fa4c92a60f4f27418e97fb2ec4e6c945bb5ccafd3237fd2cdcc42adef81a1e6fd29d779d2619d42b3270f11a8958fe5f2c6a204a235a2cf68df5d5fb7d9d9cf6e25cedac431485071cc6f49b9c9514f181d281b6dd72edc80bffbf3b89271db5db89c84d44e8cb3222a80deca7a56b5df163ef7e6ee2c07cfa2a019b8989a62aa88c2c988fb69308f37dd62d1217344419ac156dea12f1ee14c19177d3a6ed95246402785cf6923e81577e7f4b0c2d781f084b6e90f9d9dc22bccb6cbde1d3a09ee97a62061ec8b0232909efdef7e7bf38924457284a37b51c12780edde51bfb5fad779b7475cf12cfd8fdd5b08455bb6a8a41c8fbdf9768d9697a4565284781089317c5cfcd7744fd1d55615be32ccd5fb75d4d3673d942f4d22dff8b666265a930a599edbc26cb0928599b10c39aae58e7a5d01997a015f1a54531ecacb1909e640a26c8b2d543b335467809c97c3a3f7032b1bc5d7cd5b26f20e2ac8c0e62ac5d431ee54be525021e871b9332d8d423e59a39d7ac99015870cae8a75dd9053600b97b51d1433b7b8678f1f26d9c4720e4c67ef92457a375383da0cdb4d8035a04faf299c0ca27f7a127462102d463863a4d506198428996cf917e982a08e282db1a62c7a9b9e91a07f0c4651c0f3ae6ec5e996f3e587683834cce288541b65089057bebd7934d16ffc5fc1c23b6ea5d15af4aed7b8c0aae83a26da33f28e3c5e782e3a8199e2816989060db83ed1a61938752f3c3c1987c2ebaa02052951f8747a4c262831910f9635cffd27639165b6e7c4eb3d07cec372ac63833f394a8927bf9425cfd69b384d603e80fdef2159450b9e3968d80c6af037544fcc5cbbb38356c7b4ad007a40c0143c8c0f62c9e8d0eea36165089c3de3cdb47c8bf2e9bf9c4ef2abf79a0392b154714923d727da9bd0099d93fa7f74cf51aac942a89210b116ad43c716bf8f995b19245dad51f157006fd80ec57d912295cef8705badbfce3eb2de1f9371b47aed81b02d7af0018536bb529fb4a18e15ebf76c38d88aa6ab6f2ab2f26af55d9ae15e9f67e621e40b72f68c7f9165f9734c85db20dc56e9373556cea9c10445b188f124aa3bab83fd869917f63ebde06ebf4496c3ca59601235f3d5a945ba9a2d051f164cdb51d249735cb34ace8792a33ea55cc078b0c2ac2b3b9eb1bb67058a409706df658fd193a07b59ff6f439892e8bfb59dd29f0f9b90af94376129a4e1cf88b2a1a23733cc01fc238d13e9ae05a2b3c72872fa598596a81ebdbf2bb16623dfc257a80fd4c3e3ba11d3832b6d737773bf136cc8035c41b0d4071db69152b56cc3d4f092e279a85d2410e27559d2d5b1b5ec389e5fbf550235dfef7c0af16b340d45470213a212aa4aa780a7105680f1f76eeca0a73fa49be16270cd4e140e5dbfe09bba71d354159220a67f8b9ff23984b6c1417e5a8a66d77d40a1940286c4147674932366ad0d127dd474ddf81f7af9e276e495c2f268a6e5013c7878965b12c0549c4814b2d01d0f4a7fee1e387631fd8a7a6a8dcc1c7b1619dd7df9b76885bd9878323f8ddd9029673f423b824a1a1d230c1daefc6bb6b3ffcd1d790479c9ac33654443258cadfc3babf362910650999a2c2abdbfebdacae5d2898c50f515f59b8ae78212746974729e4e44b4c0985f1cbfa279bd6829797cd4776e13850c7055a112159d08c5e3c5f1768e2908eb5f37ab2d464c9ef16f15d29fc24cccb438f750e880ccddc1d6b77569b391c0f1ab9a22b234ac9a26efd200a05e39e88d0a3876c54d67889ece922c3c88bc37b14954cd73782bacbb5d2191e73cf8fd5fcd396a514065615c4c3ea7794df5392f4e9a01d8703fa77c65f71967a5d842d86773a4557686ab4cbfce5894fad7b569e605b859806378b037a17eee4716afc20b3b9fa48601a645eca84893bbc2b11248841a899b1655a5091e75a79ef7832fc0ed376350648587646fb6d701af255b5e6cb34cb4ef61c07ba9f06dd607c96c3ba036fe3df9bf87f878782c6043d06db536f8b5c69f6499a0e37ee3982fe60f1110f885102d6221338069ea2ba26c879032b85d5cc7ddecc39a1a71ab3de167b29dcc3f5ec00c9d987364950a6dfee0c688dd635500cf3ff177aec3fe57be6151866797c975815a65fb61303398611d425cdaf9f5401180075038a1f853975044e8bc94c7a949ea5ac160c49df044e79a4c8164967afc7f2452c7739b4569252c0c45911ceba29ece166f146ccd5503ce698e722bd0d94d91bf640a851bc017c9128db4383aaade8309499fcbc11850c048ef3018c104a754e655fcbb3615a7bab4a2ce6ae48a50c3754dab3dc85761fe0eae774468d0045b2c142045d5865c0fe5a9d5b41ae7ee5250792a654bc6e94e8b15fbd8a3df8cebc5cc0557684cdfe7a181ec23e2e1385411f53168a20fdfa0dd86700863cbe4b176314a1221dd675d084552d2f9e5e677214ad03387b28a799f9801b3fd0b2b8ae068adbb85be51940a0f5fe4b0a66649842474f088d6c3fdb678539456bf64e7456d7dcf57903e733857c1d2ccc78d96d403e31e91bac39682e8bf1750b90ae4c5414994cac423b4bd16331204ba6da4205f13b8631e5de42a35311c472ee4b32529ab888faf8805cb8c700aaff95a1f57127be0814e26dfa636975a0fbe17bd784c44a3d53c83c17e6444eac971e7264010f3942d908d83fcd97718aafbfd508fde89b6e540ce6681ae4b37727e4995d76c0f54d1bf3c49f12d34fbc5a577a08a51d0b8060bd1c35dc27540c9a9709e8389ec1cfac3157ff41c85065731353e1bfe34fb8026a0e5600e377be5230e95111a5117f6e85f5f5f136a7f61fd571bed9b3350bccbd2ce230c7c1586c24b04a5cab9a78254cb853a345c26702f80b5bd4e72e2081dde1bb881ef86831fa30a74fbbaf5dcbee8d5f8cf008bf57131b601073bfa39da2fb533475888a035005c0e655081a5ad409f899d2e0f583d347a4972ca260bff5a4d11ec3c951fee2416f8cd764d90bda3bddf33b1d40d80a50bd47c11439212dcde4568cefafd37c75945e2fcf3d2a235483895cc7aa4ffbd8baaf4d6e7ec793eb92013c130702bae906070f7d551e63370d004d7f126357eabcd07321ed3b38b2181af6ee11100d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
