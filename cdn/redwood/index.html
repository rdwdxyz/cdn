<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"647d333f215dd4e6f4cb77d42059782c675b192c1158f7e0c25cf6bcd71a2c4ac0ead413f88a93b8dd3e4a3889187a8032dce988d00e247396796cdda6b980c3e512b7bfa569e1bff6e64f777cecb64834c9149de4b41d9dc53a46b4c947d0256d1e6ef182a9586a91d0c1bf38e75c4292be8b9f25c1f8d9cda87caae86acfd42f980bbd28bedd595142f333e7b9a25ecbc13be2f85e38fe30ef32b7baaf713a7c521e0e725c0e97a3832e237cdfa55962a5d7be59b1017d5a37411e935e51e9442d122ddbe3bf52219301ac5882d63dc52da32f46f1a1be4e1cb9cf1efee1064badcf4ed977474471b86b5e66c95724e2498697f83ee0e8378e00126b71af26cc08949f6bf0f28eafdc0733547b9d4be5aeecce6fc38b06fa08e812c150503ae257cf92128f0028940c830084435f9f740a61a55bb5b80e6640ae1d7c213d8138d94b267c2fa4b2e358a06adc879ec2d0267ab07d8d9ddaae0c6014198a77c30143b0ed505bccdb8c6fdcb6e1271997d4582cbf537dcd00745adea4dbe018135a7b61453e58e84a67da8140fb3e35a77ab441ebd6bcc3502faf50f0c4f0d916ee5e86214046c59e2d7002c2f492761a639530b23803bbdb090f30457f411ad0e517da86c9c2ccfb958243f387ecd34b375edb0fe0a169902ffc0146f6720f48e5c631bea5646ff6ca76853b635dea733296dc8adc3a7c2750db107f04ba42022bde3e8095eef8addf6bd4895512f6b3678136c70b4a30ddd14d39b270eb133bc3f9d51c10c7dbe1cf2e2d6ccfab2e032ef4f5bfdf730f981532767ce10c58e111f9998dfc4ff8d95824a557870e4da20c461cd5262199b6d80af71f5cc7a62bea74de086552bffa8f58a50fef205f10a68cc08f2964980f13e5facbbb313e97082133752e712c1b003c1f2967a1798bf5043465b0ad5b1fb324ebc773ed878e8ba0880a7647a9b9a1db18a3222dd84c4a7a8e634906dc59ab421c1932efda45e1020a3e9b826d86792a26baf19c764a84c730a6c8c288787f835f684aa708aa2076c9a53099d42de07f5c413249c61551a569ea54b9766412f6a39797b7a530d5033c2b6e2b02aa6a90f1987bd417c9c5c54a0eae7dfa2d95ed4cda03ba98c2aa26e42948f1fe4462f6d475c3ef249db327661aebd9f08de2931cc1d9185b7f4efe4614de12474252a54eb7af8a7c0f2659b08a7ea8b6d6fea907f61a6fce73d2b35dc09641f6b7c7980e4f611d14352b4347cced45cb348939857b51782779532a54b4a2084fc47e2f72f0252d98ffe54041ecbc419e1af44069c7db0f5518029cd8478fb41ce82020dc5d81cb6937c0c0d4a1a980fe25ed5c6f40156e6e0bdd32c3df4994f61a2f6d4a6254da75d0d8664f268bd4356cade65daad085d2fc7806c729bc80ee0dc12fe3b4383071999545f2915cfbc2bf49e5c9cd364b724dd29192f638ecf0fc1d24f9beb879528c13aa64d177600f8d0f94757e2c522c540d0dfb8e12c6cfdc336432cf423668c9818ffa0eabf8e6813eaa73c02ba3347c1766f49f8a2c2ce4bd610b9f3e3066792c34c8d0bdc42b62fe32bc66264dc0ec7868975d578f6c5e8f0772f690a0607f18f244f325d2f2f94c842f2201a4c0e4d60115f7f2f6b0b33c3b799871f0989f8668c14e1e5e38e2f3ced89dcf0b212ca61c411212e79b70971396673a13a57fdc533adde2509cb9c77de1a3944274718fecfb554e1d11ad42044901e6e6ab918faf126a377e022dbd21fe13bb8e03ef7bbd10a428f7e6b2ac1ae0c71c058d680709c12db0af6072014980ea27d50770c6c7e3480896387de90982244b0409aee7d545f6abb955870e3460691fba535a7d3f79ee1096e86bcebfe540a4dff6d5eca14f0defaf8437559ee3bc6d10e09bc3fd872ed0997105f040f42c378ffde754d829c4826d0c04cdd5858156de8d106fa1b31bb92ea26190b060976b40fcc9d30575763db2410a09e72b8dc754cfab19e072cc78a3525c2f3949b74a5b0d6ebd3061b481e673ca68b27d784ab36420e72a5bb77f3877ccfb322cf0761095dc84f79085009d4b11690771cf2e2197b6c2b7c39bc0cb4f8852cbb2df92458169e95364c14d91242a41f1f844c38252f9c27b9084cde4b41db20b983983ad72e6847f9b6a5a0d49ad42b6fd5522e47f2e785cf239bfa01823bbc12210f6e552815ee2dee5dd69d645905351d4b6782d204eafd79cc87bd38577db105ea6385c425e7060c71a67e43ea2a3839db907ef4591903d3cd4a9aa44ab5233f019dcac40f619413eb0b1de7dde3ad3580004dbbbd5977fc52e4095d4d39270d5690efc5f9fde22805e4de7e71a4f1949930770bb240368ebbd509312abb041131a7640d151f8a99271ee84fceacc407acca62f4f45678622a14ddd5ee23658f9e5c807e5d9870a301e2ffb582fc4187db833b1b716332f30776bbdba5b50b0d86f80aa2ffae23e67168e8b05e428f04da6e40b70cae2b787a6319c90da0224468dcc4a1fa39e56e6c55b9efa0d8552e6d5836c950c6ba116a05840ffbeeb025a2600fcff172b3cfc70dfe3b9ac20090ef4cc5de04e5ccf0507d5c6df5304e85a18ec41c10b3cb54a53d7a66e0341b84a78146efc3d3f9a138966a06a95bc736e7afe3cfd54eb725c1d30100235bf51c802439cc4216906bb114279c9ab08a12602debc753f99713641d28e2f0a67a876bd26727e446a72db09b46c12508a251c73dcb595679be19d7879dcfd4b97fcedc0a8550b9168c40de075959e04bc1d0d702a13342e4e019cdefb5feb21c08fef4e1d2a77f31dbc1f02f4a8b615636261ba3891801aca6078d2b0ebb5d89acc9996279acb09072b6027a7da5c391be865e658a1ca85f9c098cc24192e15c9f7ca66f5c8c89afe9fa251f98426e42bd025e37a3a71cf18a086cc057064f0f1babfa72e3a654053f070c90f8e39a5d67117326e6d380d6d1d5fd2d986fb32d47519f4330858dd328ba724d3d067855604fa8ed587a27f631064260b423e5b9bad772ae41bbc26fbf2a0d50f5cb4fa4646e14571ab7870a851e08b895fd4bca64789e83275c6d5b10feaa1a1819dfdfa2a710843011391f5926f51fee9af9f64235f0d2b6478701c907e4b3cf97fb57c8dce7a037a8ddba9d0204973fd36b4159b4215268a34c78e5265ec8fc872a7f4e2af5f06f8e44dbfb4a902da07ffce1b2a11df1ab53b2f8e867ec70161325b76a8ff994f7e516d9868523d67e1ad9b864f85d5aa1cf5476a2dc13a72f49ffb03267ec546ca574efc937120475c9b0f03f78a1920a0d0f5806fd085d64d75137ba8ede0926897b04fbe12f3f481bd915b37e7048376926641dec08bbe73c2f8f6d544a0d94c67856dd5944c77df514d953a7e36f5221dbdcf0ba0acb41442ee7809ec05837dcf2d2507f614ce51c7ded500c8754e6dab05dac47b60f025c8763daab99aebf88d73369479ddd5c38c6c036ba2ecc5142bc82810269207b7e55e05a813f643d7258cc5be0d5667dab1d70e150c4c0bc4a6b60f68c613991a47c59e2f58ce0c1478cffa20ce6d15c713fbf4a11ada950b15deb8ff701e068c7e2f864467168df2919cb216254daea5df862d6b1bdfb3620ef885ddd560cc77ca84b0af21330a10fbec1ba49daa640042190bc928b0ff743ffd7acf5626a3e80f05108397b5fc9ccc1f3d142cc52fd45b849bb7d39b95977ec5a9c4a1c50e2ec3ac5759b50163f99cc2746b85a29df582ab65b601fedc01cb1a374831c642a527d3d79e394192b92ad3d423e3c523ba02758bdea5c3c939ee4896ef119c4beac6654039a82f3264cadf0b75a26cfaa95751bdca5ae9f95f3da991fb8dfa72290feb83123ffa29a063d19e19f50dd3cfe69cf173db36e8c0d2d931a0d6fedd963f058f694b03f0bc498667d5535da2ecbae25c0ec669880efe022c0b88168e0a1ce4490e42e7090e7d2eb462a7819c49d18e2e7b1cdac47a2dd1f1b645a804880e58a74dc97e29f29b3ae4095e000041a65984b8d5920b6478072263aa1ec6ab861b6aac93a32503ee4386d27eec9d4c7e1f4716a43c9378461ae1a6af4bd50ea07966aa06aba81739eb4b9f81ebd849b787e662e3648890d3dc1ffb4aecf2654feba8cee0b666fe7530e9b3cade9a3e7212df176f4d00cbb53912d09ca0c5693af52372ed05513653523a34260c7846304821d4a13c4840f9073a7b643240ee4ebf814c88be77000adb2c239348c6af22c3745371b793d6b772021e58a9258f63ebaa1cae5f9e5bfbbf695b7f71f4bfdfcd4fdbb4b71b5494f6cd487565906c90284e25f7e95c83cae4a3a8a9b509af9a2f5305b797a3e9ca7c435b3a8f93ae383f1a97c95ea7ee245fcfa09b6f660509357332023b0f252085a92d42f15eda035de38ecb0715be628e3f420a9942e178e52e1b412c802f5e1992d57012ee7560696778de10546eed7ccf453ebc00ba15596882e18ac0621e23a8c5c617827a4fc146d4f49e2fdd329fdfdba087eea1959c68e47816418a507297dc46cacd1f94bb449dc86fed1ef8915a55886a27c7aa8ff0f82dfa05963d80468789598da65e585786def70e986583e07ee4866c6e5b5773dbb75e5246469295b7ab3af15dafe8f25b2ad0f944f4fb04bcbc2e9d95874a21728dc720110b1fb89d95e16256ea9963f9a7031d7117ae901917678595ec3fe5eaa89cec74c0f9d02baefadfb513df1874e0acebd79273fb4eaf0ab80e3302c05b088b3f1df72ce6d29e038b30142a07c87fa7dd19b2a4fef2a84747898f6521bbf93313874b2e0cc3f794369a2aa61613de2828b9d65b5c7d4ae33832dd9d85f3335188a45f3a7aaab593bfee019cddc7d584810d4d45d6c94f917600c97d5c617f08f2ee42ab4a25499302b85e2d636699813d85be19d5fff3ffa575f67339309d86e8caca3052205e385fc946bcaec7078e3e5799a6e6bc4039fa094cba57f06985a8be5549dedc49b487f7303edbc26f2a1dfa107307ae68f7c5b6d6dd7ba6f3ee40ff4155a113f8320238cf35bc0fcf0b2b52d4220421bc793fb12d552376744888e76813b2f10d484d92a126d900958f9b56e8e3547d84a1fd629ec71a202aa454f79c30be983acb39e85d0436116fdc3194750312ddeddf8e1481864639f32027b71b9178a32827fe36c10035b8d83e4fc7cc8919a26e733ed69be99cda58582a7bdc4eff855fd55ac6ddc337a64add8509a582a21bff3c07b6db2307a089e9fe9db5aaac92078da98bb8ecb8c58faaaa606baa705cd25b10901f4f50738e4b95b71609077efbbe709428cbe9fc24fa1b790d6e55fd91667f8d995d1c459faf16b9a29ef3d5c5082154dde33f07720fa995a580b320f627a561daaa390a70f7c754ec03689f2c01b7e62c1f18b52e627d9325612856a48626cc6d1316db33c478eee298ff7195c39e53ced76061ffdc7f7869140afeb39a39511dc4624f6eda066ad08a2a64ea9d0d7b703b4f6a57a366b53bf964c6b1e992250a7b8c8e65f0ed5c79be8044c2cf055b19924fc9d8f95a232064144e564861bbeaff1520dc4f1576fe569e012d010e666952e364939dddef7e30b6a6d31476e687c3d6893e065a580d4a08840446cf279ce641669e914a4f6ead33f093856db52d0f7bb367a5999d4c8ff76c0ffd36576c4e752ee2cfab13cd811044d890005736395257c8e803e96de53871bb97a91f46156919f57cae664f51eaed211162c250f43d43c3a946367d34a82e37fdf935892762a7af73e8bce6f8bb82b2e9ba3889f518eac115e7491ecf856274b4e12c3dd6cdf27b1226b482606405d5587462c83312820c1715deb07da041c71fb848e5b82d03ab0e14a169f4f96ce0ed25bd29352c99a14dfdc21849102c74b4d0ae41e346aa190c87838f2dd08842b53b035fa4be8d039b913b2b2f1e7ac5b9b434ddbf3acc3d153aa5b71a7e1a028e56935e582363dedcd0cc3dfb5a2fc7bdea6d9ca55b29c6cd62f744c69662f4138fcd2d75a40ace7491fec06350325560b8215bc3461a498d416284cceec37fb4b9831f956fae11b7c6817733de07a5f72eb6e33c9ebd541575dcf1d77495d89118f1fcd6f426c219d705b0fbf3c81cd58268e66eb37ea048fe8d5aae3a33a8dcfbf9a3d90bb6ea67983bad9c904980b3520d3bffdbe0425c6f7ab358422d695a02366f221b52af917e53d4182427cb9d618f723eb3663e92e2474bebc830718d5ba94bbd3348c5d941b8a42e6825273af4164c68dbac7246e49f74b100c3da658e22bb09c7cf2ec2e999e7a37485f4b63d7757147abc2831e585a7036d81b8bdcdd3bee616e87cb99423c4d13891e7ce6aa37c8837fb91f4fe7b1131ce08a94123db2acd5eb80957cdf426671dbdebb67c7a2f3324d39a32e0a81455d2dc5ef93382faadb2b557264d4d2f7d6bea2dda3e9ea24f12597c43540ff26a37469d9396d7159f92e266180b424434c2d9f6c9cb80734308e518d70e45b6cc30d9017b6cb9a053b636a5b5ca757c903fbb056c4199012b0f21c4e316b8155e24a03c1bd61082391265e740dc69101a4d984167e7c43cd22b5433ee4d31d2ce21568093cf151aac9086552cb71c657762fdc6283e9535e48d599f8a178cf0ce9213b1b7472cefcb62b6f015a7429399e131285ebf9f696ec4f8f47c648f9f6a68547c44df0247c9ebd4cfd4dab757685c5e010c4c0db0ecf9c555e728ea6042b6f79f574d1f78247a50cd6f812707d3d9c4863215d7bb8d9e1430f22989f7d0907f9af91842fc0ddde0880b35e05fa98bb67b178d8c35fb18c5265af0fbd46db47d0ea5051b3b6c8dd7d708d59524cbb0f076855f9ec77d7e425f40a35d97fc5e0795d9e932c26b2e3640c2f6d141917b585a2b2e284748f7160fecdad26ff49ec0fa075e9871cf09be4ef3a6f29d01f51d02ecb839ec6756016ab600e5adf0340564ade32d5e37f0becb5e936b97e2021cf26816e70dca8ea458ff8378729f6c3b41801406300df93aede6aff52545a90d25e744f974e099286284dd370ea5d752da621a0e5dab4208b0f16a2fd73dc0eceee3ef9d51aad07465b52d4c734f286414a06a00b0d00b2ec31fdf0ea1d45d647354b8c5f199afa510b4b1488acbe40d43e61e2a3c1826eeb89b9ed94328e839db850068b6c621a9bfd40aca352a0c296688c354642d036697ec264a105a79544c951bcf34bc8c52ac64a7426354411660cbe6b6f47ec27d8ff273674f0a13c7884ccd727aea60c37b03cd6782de7b02e4fb50b8524d7bc71b426c7e07c2163cdb8e0effb0141a4c07f46ba6b1d19da983aeb9fc8250cc1c4038e7961bc7634b8a8a46c4b021cf709290321b38a9e1a064144fb575eb5c6118cdeb87ea2815fbf415b170614d35f94bed2ff148c37d20730b9bc7001a220892efb3c8cce0df5b64daae1b2b320e92f3e29e480b9031583fa8cb02204af81ddfc11fb77025b6957388580e168b0c52bb20c50825821096a7513d56e2dde294c58c52c82763923f3d8dbe550466c7503cac9e0079545ecef265c9c19c0ea1155a22343ec6d15be754714b48e357776daa97e96763e166be8f4c57e25d9e6ef3a56a1c9dab7c27dffbf509b57f1f08bea7d94775138fa574fa6513a34ba832c5489050a7ccdefae82d956223ae0febd7afed9bb93d9aabb0a33b40f9f952e869a2792c91a8d8b38072c1ad55daf30b811fab7767f2fb56b49f7d3f59cdf08b6d6fda6a3c79d46d4b61a8c82405201db369bfa586cb722e38425690c531d63a198dc54d8539993eeaf73df0bf7e9f8d2e327f7ffbf279853fe2bd580a8adaab8f3401d64c279727beca395a5d7d55b687e7be47691a0ca6089c2adbf8a8451c567166fe403342f3b5edb52ccb7b09a246495b572d54f414acbc40657c97c2c5772909de6e26c566df00df86e45849cbd89270be28ef61d4f6ac3a7aaf7d19fb588f2bee111c07d5cc3c443cd5e138da601ca92fbeb41f0deda6251082c1e747de8bf8eca83e616a85f07ddb5e20b210336f7d6d39adff5fea411c3af93b70c24d8fe0b27707b862c0551856ad6ff033eea69188b264da3903c902ca946d7c309a4174ad3f7c2c7560b976828bfb0207322ef5296c81fb3d6b238d772834e110f73484f81089af03ce2904dd02ba3aaa949ccc5f162fbea5810616b5cbb61b090a03a4ecd362b922e3c9ac147b72ceb48e0a635f9a78d570ea677012e3bc3c57b66767cf032d3dc5f645babdcc3b635dd5a66b35c6ab2e87b900eaaa17ead8480d547e3b1e4e970319185ccab014181a121ad667e280680392033243faacc9d04f82ca868ee811581968b8c9da6fa0085e10c80c7b5f1d3a4e228e10b20a76871d7cbb8deffeb417c48e0641ebabaaccdc4a5dd4b713315f83b385ebef99415dc265be04b516df8364bdbe8e8198cc2e92a7a737e6b11ac671a0732fcc13e104a53d7edaead4dca14c78164d2a978bec469c01a1b13fd641850e0abeea7a8fdae8a21ff6eeb0c623db54cbe86acd3995458c614251694f91d4202d36f3261eb926f5897f9b21df3fa86ac4e0c6e4c5a0f48d5d2e21521050bf1a270af5959bccd9a9a830ac53bdc1da611e97e43946dce31438eea0092d04244ade8b61701f6585b8d9bf2c37bb63c6e727f9ca360e15d7323d49bd47b7e8c80842acb2f2dad7976b76a506cfcbda1b18341690ee7ec69620b3e1e068e8487b7d95c30f65294a4e9e7cb1e615a733d2f918d45c1f3caae77cadd1ed9ea24f30365111756cb4755b4dd7f002aa4c8088410cc8966fda59590fcc96ab7f22f3281271701f69fd70193f104d74dbb29fecf049bf8f381588edd274adcc45f981034f0698d95d703265f09beedb5f62c070392cccf1991887de5f38a752e7147f783e9c0f67d362306b5526e7d8346deca28a7c3ecead89e2d6ee040cbec4743be2d5cd1df0628075bb3061973a516633a561f5890c0749afaffebf5da6764447db73e826de142ad26d0e6bb20da4b91d5fa6c72c34f0cc1a25410e3cf7765bd8db8071f4fa6f70055a6eb8a8f936bc2660a42e2640d625d6595fb6907517a03288baeef009f3708722139404b1acf37fcf90d7aa414964129de32be9141e59d54da6337c5d50a65ac855413bcbe55d569a981ef0ef4097f9c7eb4da19d2b2e71e25ceba9150651bcdd384eba01bc333160cb6adc2bfb648c03f11d3352a069aec6d5a7db82aa76201a75d5a7772c266dbeffb6d6497214ac20aeebbd0ec14b4b466bbe720186e9784d50d6cecd6f6764989a5201ee89aeae14a75d066240c24c81b5e200f12c15bc0fc2a0cc6a6c0ec4b441d4765cf4f5f0987a3ee57207412c0a36fc9dab1ffab94f6ae8e8db9b0ef22b44b18c670094fc16b266b51c24744bcb1e2fbfde6f023dd68dd4c4d61cfd4238fa8b004ac6ce8ee12ac9a3cbc1d6cd72938cffb8c0b08d75cdc537900fc6cb59487cf02fe872953d541af74c16968abc7bb7db142653d51d867fc85231c4e3355f320cb79351129b2fc365a5ebc9ce843ee00fc8ae2c39e3bae3dfa1ec5695f8acf56ccd2fc8d6c0fa9e19ef7e6371ca34303198e83703789524408ff697cc9757d0caedeb609b37c1a538cb126dad951303e9ff6f7e85b7d440edb8c4080afe587a3d2baa74595680c18fb8510c11ed70088251944ff61897c6b537bd41c42047fd27852f0f2de19869a221c9dc78bc9f237f5d2fa851b432403c28146cecc39bba95ede9586b6aaa1fa4d2b2bcddc8e609d31185f7b8fb68c8bfc46ff8666325f1080be35e5e9af7ad006ca78a2cd590903c6d4a339b930fb3a144c8439ccc80b95daa9d9ac958f9105889fee5d160a29881910cefb69113c7daff82285f1ca96641bde12149402ea96e77e2c27c6444cfd54cf281e4c6772e8ff6a1f9ad2ad785b364ce6282a7468e33b21121f2d97ea116e63f42c113d75757992f6ff257ab4324df7f3e7497313a1189385959d2bff3488b38fcd8a36ea216fb867a28f03cf30e520fc0c3d8baff0ee55bcf88bc5fbdb79ed0de8dbb82989704317ad69d9ea29910a3b1a031ff7e3f8ee99fd717e6ffe6f6518a206259d929a51d8e1785320af257afaf8e51cac3d56a3d3a87ad3046199fa95040bf9bc445abf8a1958e050ca5868879037b6aa868332839de0d27ad9f2373976888caa6744dbd32fa2307f0390092be9143d3c55152a27f0165b941214f62296c1427534f0397a2d243051c3002360a89fd295b53d83092d27944db6afcff30a7990d3590c50df13cc49044301ef8568c5f2411f8c1671cad2b09e8d0d8074daf273d1e8255f02f5b282a406d229407c0dcb452bda1ea6d1f31831cd8f5cdbefcc17b09985802afb6fff5c4ef568c7e903a13da3f582a4c7250f7c7f9923e3b57d70c5f05cacdfaea1b52d98cd685085ffc5c60fbc32e4d7c4f174d7f8eec8d2d8fc07da5055699197591121295ed34504ae5395a52d2b49d67c161b2361d897d4d8b70de7f15c9a002ae9d7ca5553f3612353eaf33d2491120aa8c7456bd5d0624c6bb3b4a98505e14d7df0c5802888252cc44222bf86fa52d7c4467c980fe629d282717d575f9eafce880dcadde5cb5ff73c2e3159277bf2a49ffd45608732e926bccfb4a69daa6f15e7ac338f63469de33424ccc000733a9a01c1cafeb59b919ae01538564a6be7899a0379b33153f988e6c7520e5034d918df10c70af92153795185cba93c2f8e44c63b9af299594ab99260ec83cd1c56af06d5553589832b8945f08e93d89663c60f9ee7b534264d73a9ab260ab72a87ee4753c2d9a24e5773de29e415a890e99e68ee3922647b6a3aca41288cfd440eaf64bd0831324db9444c9830e7c875630865bb00d487bb609dab8ef664de833597f609e4e40effff1ca0d92862013569b26b45f4d97f4511a29782368b22aa1cb318a58ec242954c00d0e1ce418ef5506343793537fb5afe2f742d0a87c93ff9fb09968a0c256cc653305fed74f18ef4927901ff84d0609b05cd221f2cf9bb746d2b9854601047bb229aa87fe8230855f99a610f8ba93fcdc40c050c421ac100ce2d700ca72508984c43491d366687d16a5043e657b44cdc3e413e10cd6d59b358a74f49f206ae170f486df0de509f4f7d6dc3271dfdcf1506c6bbf6553bf19fc4ca8821fe8571ce754ab4d0f28e8eb9d2528161676d1b34d92510e7d23d8bc25e6c091688afb3345ccd2d4350ae10c98b2bdd2b610aac47be523d6b41fac61b717c217bf96f2af8ff764d983b1ea4d0295b7ca9abe7158fca654479c75adf438ca50a0955a7cf50365653ffa889d0229cf329b96d000819fd339bf64830b209d9d5ab40b5e8478368bc43448c7a8ac3b2430f8344e2eb633680b0b76480d6861a1630948062a4659f458464704881eab472e6be34cd37eb3172972222852bd57da4f038e680819f48d024aaeab2b0209fb060933331e7bfd4eb2172486d42326f0f144297eb3101fcef15623128266ffe5f9ad1d011a9595c54ac11c338e2d6720bc34e5eacb8a10397418839e1e0fee11f8a8e6cf720c039dc05c5885af16a6b3888cfa28e2828cd2fdba76b171569a78b2d1e9a645d4f2cc8ea8d27910ab8732c175c01ec861659baff174c5c56fd750f33754783da5d73589a021e8d25b1bf52550bf83f9341274cd855c1667516e7edd15828201b7fe22b3a67ec79acd50a5da1a7ef4cbea7b62d6d78680b4a92f7939a9762e8065c133fabe36719ed9ff99372a936a7a3dd1db5367bafcd44d9087907de2b2797848d255a543061998dcdecbbbfaf207e50194a2829e22112731516af1b3c6993380d2ac98b37bb412f1f507ede24dde1b15cffa31df5edda072369723323521353e8cf2bac789757d9731831c9e9c71c71c2873205a015475e14bd2e35d7a8bd09f1ae2bbda4a86f295dbf0f93a79e43a55ea73e17263d138ada2c251c6dfcd8b283125d6d5d9cacf0a9a20ff6140735eb93cf42c7413287136a55595bb385c875a61b3259e09de70a0b07ca6e96e6e0665deb082b95fb493f12f6f3f2801ccfeef9a6cfffe1c844712f2a351359a63acfc0bdba410ad5926ffb5451ebf94721f835758176ad25221b22dd7f343b2b8e52dd48c2ebce2eca8862639f9ed19ebcf5e0bff394abdadd2b50bcf16d2faf7937e25d3f1c00b7d86bae323a4dada0d2b4253566b981603c0f1a1d2b5ee86de674223e730d5ae19008e790ebb36fcbff00c4681bc5ac0efde0726e30ba618868bb22bc1f3a00ad1d3f6c17f549215ba5f6723346b4446891f759196a8b421e77e983468b49fe9c0b53cefae38c312b6d6a33064bbf142ac3932da273abb5ea6bedd73b13d9156a66b3288d05fed371378844454cfd4356c14a8af4fc45047b27168a7a91c7faee34b361c78b644db7971673ecca3f1dd7af3628dc84cb17d59a1aa4bb98367bbe51b29da8b465bfb8bca75cfcbfd4d4526d7d40e32d359655bf93128a77dc4526ffcbf469c5ae5b2d70c5596dbf735f3b631c5f0e77c860bf5e82d5ab879adedc228615d53bf68ff33c8e3af43df53e00a130db823827f2407660a318f158a14d0d82b40f094bbf2cdeebac721237ff9a26b901410c5c82dfcebcc5355e96020564a5506e00632556ccf0c43549e40d5b2542bacc484e67366aa2c14c66096719b06c06b33773e85b394d18fb4c664c839594bb1f2272e406323f1ef5b7ea72dd47bef79e0ebad96132bda9ba2eeb0bb80a87bc8636f54d7276abf8c1552f0674c7b01149a0b09543ddec64b235a46b8ebb610fb7223ca0dfdc6089d784414565febe9d83ab377e3c7c62aca1761f2145eab7c9d86fc5a00c5095a3b323ed616176ef076574c234cfa684279d76a4d6f8f6f8136d6edff0ed0550dffd98d5e892fbc67bff61aedb575e7b81dd1971ee89bf85f5ca4b718ffa075fdd3533c782f2064e3a85f039192f13795008a50e203f7019d8893953b4e7de02f6b0ff8f55d1df6c95035809864f145bf4e0b6c274bf18782a4d58d49bd6587970835bffe5f5bda27d302205cb1a39acddef5c70847a9c4ad5197203ca7f63a6fdafdf7046ac66b19b5539a372b95b279df99ceeeec35036d1f2c19314272c3ebffe321746eb0572dbf3fdf450b99b7aca1bffeb846effa493cbced432071f2a0d1121a37e74013dd00cccc51daedb6fb9654d9971fa720bfc177c866a4dab8570e5ac87072c537b3c19d26a65e5990e09b3f8863452ece3d7d9e82adcb306fc9b5e081c42a15654fd1ef6cc0d4e1e1897ac57cb4240ecf185d0f8bf46cf1a6b65a9f8506e26fe295109336c0ffc05799d0d459004bc4aa1a20535456c97150faddc5c14f0aaad479c18210e3792d2e2fe02d8d32b6380945a610136997ab1a9bb1538ce4b610d776838ca5230e9e8aa01622a6109fac2a007e5540d8f1f2ff497fae64d975e15855b4a552d06fa1f69bf9f5225815436a90fcb5e79ab5a45ddf0d36316eab08cbc40ada8c7e40d9965fb76244199274c248bd99f5b8f71835a458049c04d08eecf20a20a5d8be0342714a52114de00ffa3b770eb6421ff2d97f7ebfd3aabdc1a8ab811f42e4a28aca0f10b68021c8258df90a96385ef4f1eb366544f99158e45f7ecab8fb6247abef93021d6f17a4fed46482127c2146df40c3c28510602dd6ba8c8a23dce860b1f00230628a30e6846acfcf06addc71d4359d12af16968dd91849b7cb5582962d4fe4894d1f1f4d9a0bebdc36fc7d6b128f583278b9fbbe645b58541a6750b1b2feb718d64879317f2b7a53f7a7218a4d04fa9756b1fab77022b05c74f6a99b0b6dfa79c8ad32ae905ebbb0a11a1156c084e3cd0d24e4e1661a747fba0cd1e7e16c0e170484b6d588c2568c5bd70c5cad90b8ead8584e12e5e10cffad99b61dd7e0ae716a7d28b59bba7ce0240b48ff1f6949e5cdff11110c420a37329599895eb5d8e4beb17930971996571cc1d275f458d04287d4eedcf5e301d867d3aafba1c461a0f199d22ace24544c0dd208530d33630fa58cf60a526d465882799b6a6eb7ca81eb1b5bb94fde8d431aabb4450fe577ea4db77c12956ac37c90d6b80c29417e8ff1bb88e51289b38ce28a4588a9796e4d6cc90c70737b69936408d558acc9a1334fda451fee612550f9def95843b68fd938b99f602065dad5aa917abeef38148ba9e5f2d90af11aec0f0a5463579a70396554085ca88f64bf820d79ad8261db11769dd8b368c04ecfd3d72713893db2fc1b1e746839789970c6f4a882d61555b0a785ce9e9bf44c40dff9e78cb59fcfb5433328d46c66ae48c1ac83367f96470e51e884e38645815a3391b99d9fd0910a0e4f48f7df7701457d590bf5c430abdd6eb1a418b37a3ac7d06c43886a791866beac2f4b773b7fbb51e81036e78d72fb124cfffe5cc2e4138e21ed55bf78e1dce01efcb4f67c3c47b3b83a17e8d226af86b04c84654549f45900f5b7c7522668d10dc9e4b9d8de4b22c84d94721a3ed7906778bb0eee4e9e0e20ae48229f58e3abf379942bbaca5794e9a4b9cf4592c761b77686559291ceb6814b6d7d3828f3abc596b007743ab69a42f837b4a608378e605d30a27b456599f3f7acca5eac9819fad50d9476ef74d3076103e56be04d9c757b3f62a3703f972ddb8528b2338f0a3b6395dc54b731bcb9f8d2b7074ecf0cfdf43be6a668c03f7777d4fdfd6a56b6417ca0fac8f910d52cdb4ff2e14f7508019d920e09994094bc9f05cdd6b52caa146a20a595534f11314c0ac8b4a5b0320fa906d9ab0b2694f8e96d0b3e49ad84a88d4c57c28a1f4183c04555645dc39e2dad06c05cb49498cd16b91e7caeeb8191ddd360d1ee731f4b04454eb598488278a0ec57b8c2f8f2890026b528b75423639619bd333e9f91a700942fa1b50cba0f349e5de9982a66d71d20f683d7f8bb4e4841fbb8abb9587d6845454f40ec60ad8278713d8af836dae83f80832868eb8d84f058f2db47c3e4922195e0b6c1c34a95b3b419188acec15af0f1271084a2a80fdf3cebd59c7b6840559751185353eeed10654610e2a0b8c7675cb1368d36cae7f13000e8eaf06d66055d67aa434026329e60b5e26eb3270ea4c776adb1ae3e58620c3ab7a6f14209a5c2af8591027d99a154f5110d4f969b5c66b71b382ee95ba2aa9051c3815aea8ddac841b44be88fa2364651cd291f12fecf450b1b68ff44e8c9d4add57e4d16275bdd664c1d0a9b46c2bde38885cc7b495bbd88351d6615901f15621b9caa725440364b56d537d6bb1ad0b5a9790c09029b1291ce89cd0e828ac364af92cb36ce70a253ee400c662ec18d6daaac655ecb5e0abc39b95d5a655a8266556f7a12220a759c2178c198f524f740e3fe0eb380c937969b89355a734c96544731a73d3c5e1cf5ed0bc5e810a1e371517ebb16695b667119e83ff1733870c3dd0aae8ccbb8d4f9281a7c1226ebd40fb27a346ea21226fe4d85b5138110f398d23b352086cd03e3862f33ddf7c2dcd8350943473f6eacd79ac40ba4e59357e5dd58de3ef4d68b61390944f2ba97e9dd01cb52ada73a6819089ea05b9a8f187c0f90a9ab0d58ed2fdc90e37c6feaf36da8bba35fb1616609e568542cd139563e0383c6e16696e9dbbb3e34969cd4c6c855261b4ad125929aa13b1703bdd3c162536aede8c07e720aa75e59750bc2c4684b5ea622e6905163e6243a0bb800ff7229fd8e99412499e4678f729c2525609a29c2b31954fc3b2671ae19c22e40fc39a52b4d07d79893aa590bca8e99802eea10a0e66b8bdd35b78627e381166f69d88b04fe68c2ad0e9e8f788df79f6d9d55d06b995f764065333f1b774d010547480f63976b0c4cd3bb3037d38b87a383bf188dcd569c5722580930af680d769e62ad5bebf323c7e6f6cb33b796e08a7a346ede4a6b8957945179a6951ba9514a7fd8ab9c71ec89780000d990b66bfc8df169d9d79a468f7f5fc7341c236be3c942e9b69444beb6ddd203986023f0c12a542e48b9f219ed1a209520d21c98322262ef3ffbeb0d05001389be36ec6caf66b6caea28cbec3fe49e2a27d517a9efbc33d3930b09c04159bf19b1d77aa062534c13adbd6a2619d6f248a53c8b1860954bc988c74d645ff09fb3b8ea8255857a27c4a8111c89bb6b8e5221887c0209a1efa3bf5fe5e86d089461cb8492e4b4d55411420de1e04d148f3729f35180e847a454946e377e06667b5375a54bf88287dcc4f7335df184efde8f4e104b99b1da20f44a1071295aa92365caa3e653ba75ba435ae0e7357970270f6ce11a5a3acd5aae8f519c04ad4f6dfe52c1d65563f8b9ffb4b4fa1f96b00b2c2200d65e8789675e7b2c300d4a18454cf3afc9d2f3eed5fcef6f48d0d3d6b6989a9be2a78b3a536d70cf598f13c7685a20588f4c91054e657ccfb64cf8ea9ebd5a82478d57f57bbe7b266b875ec1f64bad9e88f91fe014918fc59ab0c572c3ecf9112b7b444b3846b66c129740be3c55fa8b43cc828c263454e90e7a7a3e355ab2645d6a4b55debdeb7de2c4fa61f7bfabf5271cc534bb45c6db89f7e28b57e55e57113d3ebc8a8129c3c3b2c42a5906729f15fb1ea63a8e2162f705bb216fdf329091a9d935f44bcf67e22f57cb8552574b5e4991141e597b0f1264f2bab8c4e06aab1c58cc0e40a5f84832007c7cf7f10519c1f97ea546a0cb3dc403869fef3e4ffb539bcf1cc7c2c2565c8ff0a2a2135cb2ef0ef9675e6d7f69e9f9f09addc6ad4eee75d75d7a72b03f87da797037bd410711148cac00a149b55f3d07bc1d379907e43bdc984c844d4710c3e740f7f995678de888ca66b04253f20cbc246e726758ca94ff02b88c5b6871d9cb6f5440f41d47da3f1dc67c2bf4888d03195727bf0d24f98466895e492de17a93567ea0717ca9e1bde70c8f4371203f3fd2d645198565a8cd02f2c2270cbf3de0f74dfc5bc6a7e2bea236433e9bcdb6a23343c3f175179b0763e767ab168232c090c1c4b34031a0fbc129dd5582bab6632ba37cd5dbf2db30271aa5aeae3f68d4453dd1be96373029b49c13ebad24fe0c99557ac1a3cc6b6395aee142f7be2ed93d935a98cd73864690d41d95d2a6bfb8141cf6dde233f96a2adc54e758eccd2045c182da97f27722d6a15ca29e97da84cc9655c85a9032090cd483eed145b0bfbd05a1b6c0f95fbbff95c907df47035ccd5eccb9c3eb99e4f436020a26f990d154e94b5e6bd1bef1b143346021b4136f9d499003e910c4d241601a19fbab7307f7908241f81b3616fba3a620d5f2a0f986a948cdda4fc8f76d2197b69538c4858c6921a0c493bb1711832bd7a51304aecab0683c395a6efb2ba84df430501ae459fdb2c837f8a32947887b7dfc60442b50f2c4cfbaf965601c72bc5e4c213d48de1e6bdd8db20223e8fff35f7b01b6d5cc9dd20e39c9da3c88175dd19737f49100227d16309ecfbb910d17d580bb00c25fa47ff0e20c86fc7feeb28625c6e05fc82b5498b4bb512798ce0e4ce48b3f4d07201aa4691088cc84893b6858890acf69908816b5bb29bb1720b54cd71f27ceb34a3177f15c756a72bd93355e1bcea82de07ba5ea33c8ca0a52347baf1a6aa31b6c19866a1bde87b70b176ec6c634c3e7288c8a532b6f2b7430d95353d81134312b7a28a7acd31801d10ef24dcfd7e521e7c17b6f368717b840dc9ec2fb27c35b2c3a62a68835a786286e1e02de33ef184619a4d3f671b643d3170207367ee2e9ce5488f68f9c9fab6525d179f95a9707406bf6489771d2e2d81523a08d866456642db95685fbf49c3e268f9be7ab73b180ab46a1c1c6c7b0473813e50702185e6e1052bbdb61a01e235791462d8efa12bb6340b4923a0c002da1a87b29ad9a8b39a1e0fa03403e337e8d692c9162ec1dbd6fe2c0ba0b3ec740a9315937235e63220e69db8947b256842a12276c0d5c301ef5879801bcda65558d0527262d2cab6ba0d54a7d04981faad6c16cd0571b29991cff8a7c5833fe8fea55266b80e0c0dfd5255983","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
