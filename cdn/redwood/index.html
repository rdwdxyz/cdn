<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"de5e4eb15cfa198c14e2307d24cd77e861dc69a9f6d4f6ef6b498002ea60d9c8cf8c5911e48058a87803d6ed70700980a49931ca200bd50ab0ed884e252c6da38b1298b7c5700c3f10496ebe4a6332b2770d7e5d50315779e38b90df9e15a515aa2622355591d0af10a7725dc1bf097643bcab00f82031b0d6a08cb8d4eb30d405e198e721f23732445c996cd0be240bd3ef5530cb6fe483a124c71e8a3ec47ece797a1b3ac24f1a1acf5825c24bb7e2c34481f8e195569c53e411197a03be580d54b5c60bd397ac2cdc1d9300c146a962a03700b362c14f3c9484974325f9254396c3b912e9d4213fa5a481fdbf44f8894097b9bcbc1029590f2308d25e73778ce4f3364ab621ff3c3c4acbbe7cd24c5d380cd5a90b6c0df77fa3a9e9a15b0ced7fbf581d9457ef65c04375a8ebd90c2e4915ee565055ed23a1786e2ad77acf08b9f9b8e5da9aec6a4f9b3a964ced85137a88e9a96a96b97df1557eca9581cbcaaa23cb95fd763403772f111ae30d63d68c9b8ff6c364df4036da944b4929a94dda0059c81901174820582c84a16baf375b4670a6cb674f079d9bfccbe1987c4f0af02aa78492a6030f957bbc6e5b33d1f2d3addadeb1ee2a987804c6307c350b28960c79a4e9ec4c2be398da4103def7a0687fbd182d291f5722daeaf3ef6a64f02deff763239ea2ee9986c55e6a7c51bf55ffb807ee4e7b4e676145b150e1d7b5568b3825b8a3229421f3b7a98050fefad9ceb6fe3578d915db7a5b8d12109ab9c0e46cac54c3844b757eb76acf561013d0d38a2d662a0b1e7172c1dff2d5c63efcbb632752ca63c575d078b06a17dcb793863d6be31c38ea35019f09a157ba31c6e6b59f503e06f63efa2f6e3ed80733252a2a39690e72592bbe018550715ee18e9e9fe5a35db2e4136895ec19bcda27a0650d0605425976782a03846d14dba668820430a7d42a47bf05c45a8241c4291b5f983202edb6dde84c8cdb14c2bc0b967c26d5ff8c4a75ffc90ebbd6a86ce3c4df77fb6eb8d3bfbaa01e2d0deba60c028fe46d11009071a96eba238f2420fc1607c808bdb46da291b809f79077afd871c8f8dc69e2bccead780563679a8b34d1674d72944e0f96fa013d34e204660be1d1c0b82799ae53e0ee0457d89c1bfc9957c492a9541ca8e70d113f619dfd74a378c3bfac69cf3028ed34db83e95f12bfb72943d3dcc28cd266699dad8bb0a71f51675929c2aae12ad071b505d92cdd0ac9619b9916987fba09eec12fdbdfae0528db9caa250c396a452f0db22d4aec03427485eae0c0d199d1cffbdae7d19a8382c2b736c6cc717ec672e426e7ac20798ecabfbd5c5b57a6c979525255028081ad2236ed98726ede9e1bfdb140dc782790243bae1b7a0497899ca0c75e9b40b8f08b0db54f7b289d6116a4099e93ff2ab34c49a565e4f0e7cdb3ee8e09732499c644d7b883dc399d22c6a6c1753eb05ed6224a2f19a4d5bc67d4c0c8e689e6ca1d5651a1f7bf4045c9ea0797f6562489a20511827e89da2554a9e15c4a561b34978a6835da8900ebc58b43df72a661435cacbf80c5c055329cfa2aba3c1fc2dca1752902e9e323be1b8250913378bfabe77ce10e076aea3acb594f33438f98918835b4d9ccec4c798c1a3321493f5fff0c968192995df0b60f1d8959a4f8a008b58c1aa09045868716a947bbb6b5c142fa5bb003c6664888d70c333f70bc31a27dd035a1183a522d9ced8d1ab51baa9f642e7e9fe7b76771beec8b1a2b40b09daec980ec79d5c4f1893b502df89e2954117b957eb1578b816c2b11b62303b11410f623218f25e120bc42de5ee7e8019148caccaf01ac934611b9bb1aea6ad13fe86a63eca72ec09f1f6c79134785220de29c322ba869940d2a0b89eb10514223e50f0c1d838b4a1d1e3c9a25e5142a19ad7adac4b44cce6efda08ea1810f04c78cc4cc8229dcd300074e81c0a9f860ee657ec482230c5bf9ef81f660f38528d47d3652c5f311381ea16fe3a7dc06558781e672922ab491e5f5a11c5aaa72cb62a69a80a464b965788692e0a9e3beda90c171f127d646887e0d45381dd48234319fbefa4745c6ff0ffecd97c9084135224bdd4850b3dc078d0ca4ce90e35a0ed09e96cf85ce8fef6a98272e09d83fdfed54b2da85a8d1c68602fd0f3d0d5bad439e30e540d4e7d43d028dd44b31de3d3c8a264b8094f4502b45954d87db0804b14012c654b4692c1473a48d2cfb743568586a0d3a4e90780003c43d680d533b9524a401608f4934c1c378064b732de1dc3eb82ddf50c3c467238dc690810b9a8aa1b0ef018a8710d645574025c43b103ce8bd836fc256e56eada82b2f42e921a0b2006829e9b1d2544eead3ade7a1c79190182e8f9c923f26d085aa5e8cde105ccb295a646d87a3b2de2101b31e279e8469d9391d6908e79c7db64aaeb116ea69eec407fd89cf33b881edd9fd8acfd11e23ca5892810054e8d3e9c044afe7b992003278d3d3bc1c4fa7d766fa42896cac7b48627d43d35b5d8ee43903e694f59e379fe111c3b972ceec83160d3cc392a85e6b698e61ef012225c5e028163ccc6eeef6f15cb28eaee4a3fa26ed52143532fd5be1edd912c3b6b23aac8550a96322e586abb854f8eebc752f45a01439c29e8bb8fbd9a5225105fde38fed1be7c53d9c028dbe43e3569450c0af9bae0d0a7fe796c2f4ecf66048be9277cdf8cf45fb53cd3c3aa53fd6da807df53e0e805026499421db68caaa60fb41cfc6d7101ff221556a0ceefedd8a5d626769dc1309b87b08d436eefc7de33d0109a6eed765097ad40d13829aa508a9f9dec361ea56793c5786cf45535b193a917cc5c3ee16ee36cb54044b32f7ee8b507e621bf7e0cf2c5e6b76035c1a451bfe24e1def891ec12756fbd8b8556af1ce12c2802303a4d2816f1814d453cd419dad3fef379eed05da3814c123eb43f73dd9163059ad5a1f496fad74ebc86823939e9b9c90d3d92b390c5251e2c40deabadffe0b16b90cc4bc1bee23c161739ffac6b3668abc0fb34f7260c7da47682fa7595d46fa4923c0a1f09f85b845ca430cb9ea229bbb40257855397aaac2720639a800605bd4d45a021eae44884f7cedb93cdc7277049913cdffe9f9c34209b19bf42e7cd65d108357eb348c7d4ff1d81e6546080c77ccfe9609031f7e1ac9b3789bd563dfa4a244767d89389e297daeb1d45a87fabe309592130e80ffb138d08ad35cf889ae0ebf7ef7bec1f4a95234870138fc6338eaa7a6930251afca71f94b2f53734f2829198eed9799752a391614c55fc7011e3f25a7267ecd425f9039331dbe882a8c0fc0c4c75e4639241594585df826babb6722889c69094636e4fd71be1771fc532ab1ee40c5055cd0cb9afe45fc4130ee2c9fcaf750196c9718bf915f7acc29f717990f3dec79ffc550012db4bb432fd86cee51fcdf58fc2b03aef65d13cefa2a712a8f566df2311c51bfe975ed441bbce5ec20b59d2b49d139d727a41c9b7247fc6517b8ca477524d6eac418cb97fb4f59c371eb7b0472dbce6a38bf67e3c186e440832f06f2b0dc6ac9011b3cb471d9452f39cfa3b7a84c5b5396647eee4a99388135d1915841d97af75d3dfbf2a2f950b969bc123a30ebbfc1529f90e29f355d02f98d889e28aeeb8eff3ea028c62f7d52a37f0b919fb3e3f212822a2d09649f91bef7a68e8280cd1bdec9233c0a0677eb4a9324ff1f2470c3b9de8038d156840b65bab7a987a5de95514c2f3c32b563b632a842ad8f9f201af21882eff3da2824b84b69036330e27a3544aa904bebded9c114acd074949df76bfdd9df9663242b9af092fdf2ed9a2b2304dd8bc048748fbbc0bf2b94849098420bdcddcd171b4a1d64cc2d92b10d2892efee6e8df0b329ea512f8603e82ff936dbd71235d45194331df0a9fde78348c671bc3c53bae79c8c97360f9a43ca1acb3efa6b421b1b978ba67b28d185b1912a3d5488779fafcc75a5487fd1e5fc997e8821f4b835ec5ba5ef32facdefff3bd1447b557e03e2db34152ea20c43a52e4c2c4d68313af3b313409983d5e0f3214ab8f4024ee8cb3e349c396ae0f9386d0a1d16f5fccb2a1d82b193053d1d3792b28ff85214782d79e8357efdff9fb98edf0ed7246f21cb883b68e7a0b159734effaa41b2a41e89a14c4dac7b3238eccfb231098ef49e227d79eb3dd1bcedebeefcfa77463045e72449fe105a33d702ca60456cba39bf679d8ede6234fe7783f9ac1bf1a84be6922fc9d5a06e35103c8a4d823a3b1fd262bfe22b1155900dc9308336ee0e2acdfba4e48ddb91c8e2b122fa8629985571973a873ee4861c0110659c17b841fcdd235696b3442eb3d8425407772a84918d47700c3c0d31e697ab5f7eb33222742ebef19f7a59e9b3e5a2bea63a59791784978c0de3c2660d274cb69560e6f9916b8ab260c03e03ae6534ec13fea4bd703b7c394593416da72d1341f114ddc02fb5c37f836b51c668dc80c67c220b9622648fed2c505a17c498c1c933e64c7785a4f4b3b9043e3c89fa9c73e3bdd58931b800d64cb8a5b88df6c222c28a59dd57857e6ae8e2502299d7058197185738481cf7b61bbc4bcaa5491cc5a4241d501edfd75643e3955b5d7f794fce966c777eb708805979cea624590f45149ec0aa22ea11fad299b8a61f45fa8e2a6ee89d606bc339f7104d6af91c493a57c0a2088c5d1d4ae629684eeaa1222e30907e2140d73977b5ff61c9f61ba336fc4269eee59dbeadafdd3ab6a0e58abd44b038304d6951939cc9748bce63c7f4981586ed2ca7e5ec13ce6b5c97e5e852f701529185983dbd2b10de5778cceb30903fbdf2629b52018ae4101c5d429faef54cba83bc0839d80553a515c1e1758dce7738faf5db37b5a7c5d5ec3a1472782d617dd8e8d26690a9aed06b76060368fb66247a3d1c3c285fe8463fec3b531b492df9eb7b57865480a1028142286625682089a3b48ca979b72973b17f4a79ed55f6dabd6fcecc6c22a4b7cd6b21e3ae0aa9f359db13c9c096374dd0d1c286ae7646c631681a463194228da705b030b0c4fa03ece05cbc0ff65708ab40ae89d8aba30fa7302f10390c841729a9f13852301aa266e690f9d2f2bc375e133d9790bad2242bc1bcd346c7a464905bdfc3d5d5f0ffec451460fba0e58aeb5cb11e4eb007aedcca498e11bc0df5be71c9725b49acf9cd85ba80517b28becebd7f074eab81e216806776ca90557ee0d238830eaa89daf7023cbb846fe8ca825507d2c20d000a00bc0f22ae9381d4d5792aef3dc3c8f09ae9e689b30511e91a5eacc8fa56e624d2827f836ebbf85babd1fcc1f0fc992b6166ba9ee07d7b51baefcdc4bc6409145e2c574010996f86c6f8edbb9abd97358858f630c99e096b0f832f8ebed17eff71497b11573e40d425b7871d1378efd2db8448cb241cbe17e4677984cdeee675bfabbfbfd35d69b857b475ee52cc3ee8890e9722f99339469bb44c5d6a8569ce1aab0135bc9e811f44c391c75864946b1afc78794c53da0ca466e5115c89de977b4fac1471ee58a3ef06a1f1f6a6e2c5128f6287d9a9f51c98a3673e38d00be2b1843f53c202a0439c672c18602e15b85911b75a705c2a2be05b551eabbc76b74d584fe42e511b0c441eea958cd4aef6f4a1ede583c56f2f74157ff8d3d4361115eb54a78650d7efb90a25d15faae809c036c66cf844d0092b9f9ddd544ec079c198b63675366fb9fd864514ba6342655317cf97e3abda12f8a98a24757e860347ca09a6afc39ca2f41e1266c99fa738e223546ed56e0f06308c372ef37373e80f502585eba1ef0153cc9e8fb9fd5a4c0104a0a7421b0aa31f7d2271c4df2d8876f1ad349c1c5334c19388cea881ea0da34fb11e0e3dd78defb64a7c5dc686723083cb3a8d7d5090b5be4ad91c82447b5daf096b7f5b955b7159a1ac14b5e724cd6a54543a27145b340bc2ae5b9df46df4a0e92a2edc4022bfa3f1999c05e783656204799376465d806073ca2e0c52ca4ba8f845714936d15cd265ae0533a7dee58d3052d6c661ee4381ccaeca03f2ff4f718e98fe49f1b2db997b3c5513b397eda8ba3789a86143515902e3c64c386fd112251100378a202ef13528cfd0930904d531d7d41e461e8d27fea1d8dcbf9c2056802d9612429d415f880e666e428575eb1c4efa4a5f83fee23e4898f25cee8b8606507386abf461da1f416187746738b17a67cf790e6811e02e171dfeccc9e98af589c8a3d4eb0ef49c81e77eab7dcf1fc71cb43d8e02eeb49f24bb7842de1c5ed98d3dcfd933255ffcbe99d91a31121d97a55c4a8c9cb8d6483a0dbbaad76ef301dcc49a0efec72480b06053969b61d17070c6ee895eb395b9071a69c92c867eaedeb62ee3ce7c6fecfee683591986fce18a91b682b00eb0a0ba0685c7a385df821b9b18110faec066ba189b2ad9cbb1d83609c4d352351270a1cd83b1335806082907d884992f9b45e66979e67c1c6a6e0719f6bdae276bcbae39d7cc34bca635e703d19e1b9560cd177261006243281d327f1255ea72922bd4bfef31d7e761af0e4862d19a85fc47fb8d937208b75fefc003890d13df2ee3f0b114a39a5c92c7c6ca58b1f60600d39995baef05005e75bf0280ea1abb48cd80c45ea88bc895ad05d6cfe9fa9c7186487aa1dff2d3460339db523776f2e9a7d8d42991242e67c9ca8fa49a8dcd983c6ecbce894213833d66ff2f03f97dc3649076b982837b1357612cdaec302f0b8cb39fae8e799eb03b2c413b43afcdece6349217efba271ad13acc61387b85bd0b0b97eb3eddecd32d9d3e8b4b50b938b11f43db6f10540b809273c59b99d337bb8210c31b1d8cd9a587d07887235698d6017e54dc2e6fd8ab9fcb8554b80dc1384041e80c276fda76daaf27f35fd9020a3eea9e96176396335451e9a560061a60d95c6085b6b8b9c8fb01e159c4b49006621d063f584675779032579e207b9e92d2e6a82397c25afa1e44fd76e389e0e3a15f1de3c0dd9a2b436766b9b2e9d6b516c3ce5a93dba2d4157639c117dcbf6c928fd232b4cd620ccab565dc2cd29b38b16d7c9610a9452485f653d118f979dc66c331631fc1449b8fae39a9506535bdd895c980f29a5342f032ddc570aba7e9b9946d419e107a73c7ec3e9ac6953f172484e063d174372baa48d66cf401a7ea1827620fbfda2b7a371cf744e338b86d63c191f5349597020fb2355a21ca236c8e61b25461916ada289f9e30cc4653a86e31f60b1fd4eb30972d7452feab57bedd1af483f47897bf9cabf98fee7305e9146da05f9acc7d6577fca73f85d513832706a0df079eacfc7f9957ef63f2a5feb3c17c872e4389811c0a681d075534a9eb3d1557ed7d32cba72136608254d8a1019f95d147aa6d17313d8fa63a22eedd822875b0964641aeda7cb3a8ab92d4520331488007559a0a04b4e66be60eca9c1465ca137c61a3d37dc4b5fa72f0fbc408acfa95890517655688eb5d0c59481ae39091ea5b0d1f263573ca4de49c8c3c25c7c83591324bfb332fd14e66f8bfe5e4b9f7980c9d1679a068876b1bb201dbe2cc161b7054c2277c56edc9932ff22b726b8e0ccc4ba305d706f11d1b22f61185290b29811bd75a86bb94b28d29bdaf1172235c50fa63f06831dc86e4cb0ceb7dee77b8c33c9022374708477f9571b3b4850e3e1ad982be9e6e8749cfd79383b954ed03fed8f27154473e8037978633569a2b1226e9599a65d20dbe004952baa16440b1fc7c38afbff579207174de47e66ee665d10b90bfe856a1f19120a81577990869a6eb91b6d3b9da7a4425f9f8b5d61a14d0eb07dedbfbd3d35053ca32ffdf5f774b4a2eeeabb0cc31467fe3148d14bdc4b2c0966775571f3ac7805f0d4146d86ca50394e80116845bd8f81c93983957cb4f3562d97d15d01ef47016fbb2c9bdb198f6d312ca73dcaa8eba0bd280dae3e8188fdf79c5b019a7efd8403d71d74a2cabf9bfd591b40c8029c4a2116fbb655a2489e31d7346ae3d53b814b86e6b832e373503b352f2681c83f13f06762146be6d4ad0f3fec0efaf4d3b00a4f7272ae68fd52f75bed0ca7a8854c17b0937147b8c65bd0d8fc2326bc0bb5232681a86bfb3a42eb50e6792f6bf60d964e54ffd994adc004e708a64151bbc07197ce12d46b0bcf76d4fde015028e3518126c26d9aa9c371b4682018d45fd7166d3968ed8151cbc39647cd94f8f16ba8e8db52cd5672137aa7b059b0f1df8b7de60c6c5c16294192b65abb4773fb3d39f12ac7075dd3b7529e9556a06d6c1b84e4b25c03bcb781e77397dc45aab27525f37a7ea5ce1e216342d2481e6e8011a4922ce79327af2fe0cfc707318f518ac2f04b136021dd485b69a793ca507df47399de6520e94903d977210bb453498f555a318a9cc2c4501a30c71130aec1eaa001f4c9d195ebefcd7dcc14ceff80bd29a16686e470131e5679e5ba1a93e984cab2f1dc8a6e885898d9a2ced8e6244e21fc8f4e87182b48cbdc30f8fff15ba7750d7fa56770cdbe7c3a89c713b24f79426b51b1790ec2d900a8ee70ee076d317b9fb4b7dcc9f46b2be318e2e70af684ff164ee722d1ab1cbf9614e76a83d69590865fcb28b729b639c2109ea2284314ec1c7a444d346034d9a1fcdb702717115b8e0d26d491c57cd7d04565cc141a97165bef03062f6c20a27cfbf7ac4b38016d72910ddd3a122245483007415109ada444827bc63e84046d76c10431125d86cf22060e46001d8e6d13cabc022c4b23e2d1597f976ae3160d74e32a4a73197de4937f36628ef755a728ee4f696205cd8974396bae93e57975c0ca5baef68640b5a93fa07c552678d8e77844d5b71ea19432f66536257a6031ac95faa27f18f177124a94d5cbea3b67448aed2aeb7fe7be6a7390abb3fc3d4702c7006298af456146ba1c809afcd979f853ea4e06a0a34c88eec6729b305f3a0ce591b8d60ebabd988c76bde7b9319aa24988f38087dccc14c8c423f688bc3cce19d11295bf4615b9fd24749da50579aaf4a686484b9eb9e65d1397290866b9540b621da755b77a6700cd188e315b16ab07cd0d1eb0bdc18e949a854cbfd1e174ffd121b8cbe4d6ccf9287145d1eea535b959b6ca27b4b72054b3fd59343a8d3103644e4496e89395d3fd0399ea1f593c72f4643857a1a31e833fdf00b93b25556e276fa27628ef688cf6c5a42eec2eedbf25ec82793bfa78adfc8ff5d7e2b4e613e0068dc6da219bc60b99fa3b62f05ead5c01bbab2c8684feeec275f34cd442b662e07bff40a1b0cd82c32ca47755ef898ef08a658f76cccd25aa9fe8d49d4a02d7873c08fb10b75a71c88f7e2d7a0ac118007416f5ab793fb4f45c726dc9f67fcd9b08581678168c3bf9371e6daa8f503a26b7ac33e48d3fb7e846c82ef7491a1d23bfefe94cf99f679a27c03c299a7e18cb488f5405841c7b1be441958691eda434d18e70b7f5c7d629d0f04487aa8c452924be95534877fb6de2c3e620808019ab3d481b5baf08679eca2fdb6a68671c4a5e6adc3641315caf4029d0a8fb406a59bbef7a765d48a8f00b1b03348a5f20b3d435fda02bb4725754c000f07b4b20409095971ab92ac1eab0715e51412836d1701aaf86224cbba4952a24d23b388bbff60178971bb25227c94d46062f7c326ecedd495de1639b6110f0e90918b3ebd6edc9a48fd34ef1230e6160d06a848ab26a37ac682128e8298eb0246b63bb45230949d3907d12c65074c737ec08cb60a2749ac5c351aa63bd590c5f08fe72f8d3c19ec81210910b7668aaf58bdd82684a2456bd6d1d8d9719247bf59b2db30004a08f7e62e5cfc8176a5757e4e213dcbbb43628e2490866049605f30579d07249fabf566a43dd3845766383dea3174e0786f320041f305277c59a5e0f3a3e35caa9e8c99d10d04cb184f2aee80e99292613b549768701fde042b52d18f55f97486d25ca5ee45b1f6b66fd451c56d098cf69e0a5a86c37f1d3ece96655edfc58f0382e567c4183426d07d8c35b3f980adc4019146441082da3a6faba97ade1072d6c4600f57462f4db5d451049694cbf802c8ccf9d382fb123f18df9d59d3a4ac48f820956a30ee7b9c355e37aebf1df68366b7954b79cde580549e1b437f033c033b28e969c23c0e640216f9cd4b6a248dab2306b0d32792ca356139337dc41ed9331a98f10ef0d41bc646e86decd100ff6bf7689ebd53d483fd5021ddd9e4170496678cd24d884f35a8550fdad5db644c6a763e6d313dbc8520ee4b548edd9cba2daf43bb478cd4f5d8cee60cc9fd6b9c181661ce8a1f7c6e9c4cb92a0c836a4570e444d78a4d5a85936d0836b41d988810e981cb9966f8993b23f5cde07ac68e1af12c7386602637b10e0218341ad596539ef0843bac453860ef601323cfe90ec1f5e81551abf6ed515f594189f4c6e1f181828e040b3abd930a1fc8991ec79fca6ea54cdfddc15d9ebd9894fe9ae1aaede45741a9b6cd6e6a1486f8e45f17a87ed0f7946c6bb7bfc6545546971aae9f8796bfaeaccf2d35347535e0f6ab1e710ecd8ed4ae2c1ed8751db629f65037a684acd0a26fe96c825e903a233bd4604e8826827b4d1be5e1e77fbfb84df83ec1a6c40ab1f52b2de97d02a718e5213ebc42deb858c5f7eff1b9de864b9d0917dff082d4383964c44a490b41d980033ab2266b11c6d4fcf53741cf495db25dfadf40e3410665bc0d23d7edf8d4e524372dc39f1e930c1d53ca89980261ae4c7ca1af4ab2bd86f56a85300322f28b57c6ac10bb2c698097f3644b39ad41b30775a4eb4db362c20ed4bb12961e73d428f0cf3049fa4e705039d10b4b175998410c1c4113a468ddebd86e8933e9cf98141e52e40b882d058f276b8de144987f8b4489ce72a376b37911dbf7d78d8eb13c5dcf45e119427e8700b75e4b1f087867cc5a4e2397ab1efccef68c9718bd0bb77748c96e73b55384eb009abe8d37e11be56b365f008e20b8511fe1ad15645d547e02ac09d74e8228462ac665b797caa3d178da7f6db3da4871283b6c33bd7e8ba1ba5ade67a6be840dc6e2e68204771ff4e95f904c5acfadfc409ecaa38862e1257f0be339af9ac717554ac57d1e3736283969422aa9adb18190703f119a5e01f781f435ff7334cfb23fd0a2a12c7c8c6d1dbd961e6b1e557da8dc5e6528865eda659f220e61d18e20dbf1dc66c4ce70ccf31f6e6a00276aa2c6aee727b9748c0def9da7a830793339887d4c07879f6cfb8dc55c1e2247cde82c079a4dbecb7b14c71c97922746fefd7adf5919b0c8f63704124ed80716691bc5aa07a9a497cd4cee895a0880833c7fa3940f30c774619062242f60028bf1e45f5bc9abe198a27ae84f3edd44581d7beb8e7acf6de1dabba75519f263338a9cabef6696aa1c4f0044c4d911eab24d3e81e5892d25f9357e58323d051d943d5d989291d65118e22562af2ccb3422cc666ce496f1e214409abe850efcef5bd5e01593781c328f35ef7f1e2f4aab7bb7d9e1c52dad2e15e5881611c0e40509ff705dc4a0c760f74c49a493d63ec5164384afff7e0bb7a04f1e40895ddcbc66ad02ca5857546ce7e882022cb056385cdd76cdc375137265b9f917699d62e76039a4c5acc37e89dd876dd8780baf77fdfdf2aa4c4c43d7a21c947b69d5cae3cd440b0c97e60833d52c70dc2f6160e71a02686c500ae8038a90b33e049e33f59aa4748356f9faed542401202ba99b4758fb3850172a3bc182836f876e940e360d82c2f79081866e0d9365cf1c56c6a1444e32ff9588afde33a9aec0f2daf93fd800b85b04f119ac57d89dec7adbb5fe586f717734b76ef9d9a6e3bd4b4cae07692bdf5e82ba81ebd46e79419e74b109653f390cbffcc9cc9ca168ebcdd2db722d4fc460ad4ea128309e39deea5171cccb70e18b731a64e4eb448fa29c603a87e5d30cb9d631945e610399a402975fb19e0f41f2d2f0490bd0ffef392bcce9bd7868241832463f7c039329a755164d34cd41d1fa5e7af596a25ab9ca8c5c2f4bec19e3122c579d41e9d3086313c8c1c5e012ebff07642bf9860293cbc4c752c49511f3a0e121961f8d5425adb9e2ba02e236092e2826f1d3ee7e1ef4867252db08fccfe0491c104f33b1e26864432646bcbf7e8d480401de44fc9d52a23286deef1dcb1cf2441f715fea779205767bfba850f6eab84faba783eac476db4b960179bb5db862e3d2d28c4bcba703cf416839cf7e7718aa0d081ae4a27e36e4e7be062f5afd52d916ce50761264f168b742d3dbe88b0d08d69f4b59babf4414d2d28db86a80a7e60c3f2e8c1ea11e0deabd251579b3f99385872e973fb2c0129fff1fb2ac264f5e165a78534264385437a2188255d1fd5eea5dfb55c144daa8af56fcf9516d1936ff9b220cb4cd48a62b06b429c19d631bc0d092f8810847a0ee2359bfc25da26f6fabee24bf6b1a661e92a3fdde0a535e2b678dcd6b425ebb02d339e33becd35995c16e768530c066399dbf02c113faac8a4bcfb4fd8b8fc7ed166ebbd67ef34d667dbee2f49f318b71eafbd19075b92db4c066f57c2b5774bc0c363b68681a4216494f3945aadb9df5eb5c5b06126e041d611af27143e2e7b76604a0a9de0012c888e2423049bdf051a635d09d50e240fef57fc80db660d2d0f59fcd59eac164d2d6aed6a8f65b5c07741c3973b2f42998eda07163008fb8fc4fe074073feac3f8a2e23b9a2ddc308dbf49cdcdb1b214c81568b2fb1d3e9c00ec31ac8c945792fc19c3ac7591f8715bcf7ab8b1fd5c293c76d3c22aac4f93290968913db2fea4a9486db80325914f5abd6871f0fe9202246d7ce692562a45c9f64dec219a8758e834ae6cbbb62bc9c0b50c35f35d2efc258d75c6400a0c7bea2ef1e240feb405e9c686de2f14943ccdc95a8c6cf13e1c33a1f970df7f4062ce6027cb3ad7c1a8ea45bcfa838a12c5b2bea5abd9a26d52aff9c294c7f7c620ca8bba56026ae4a02f3dafeff6203ddd6e21e2c48172b4276ad27bcc00314164d077fcf0d5ac41240a973127f991f50e2c638da11f0ad2908d85aa36127fb488e612c71f5150e9d3a9d97d046259cf6b51f985e6f073128ba868143e296ef1d0c9fd8e7c4f020e7cd49203306d9800f574207dd5c9e91a1bc8d97d3cdde7b15e0703042c0556fce039162e15d00da9860e802d84476b14f36a2391a283dfbacefeec6fae6b768a55c1c0bb347af63beb01fa8c572d8e88615459e68c88e5fc3a3009fb5512471bb295733a2299917d406063058e6495f308a60487cd5e9d6de1870257da168db0f35b97d913cc9c1af93c655019a7ecc274598a4ac436c0307aee5345bce1cfebd1958f8b3c2ff02287e9d4b8403d40ce2c40ba56f0b427eb1762c74efe364d597ba58e95d575dfd70fddff11d5dadf2505ac42eb7303c7f934362c6e830c7ac969ee102e93cd6b35d7919abd40bbaf0ac18e7c8796bf701354e8a1a9960a89c14e6b64abe2028a61f0320620ce81c66c854a703d181ff2cbb3b7da5fefcaf7b5a4df94688256d309e16626da7e3c7036c7e7d6c04b664da8c59162d7eedbc023e11399d11064ee2a6afda86dffcfe2fa8ed9d52c4eda8a2d3863564c03210f6bb8f7c7c887a559ffdf7ef090e707d777b95deac71154092e5466aab4d49aca3485d5ba31e995adfc0fdb0b71179aa9707c7160a2f9760d643f6d29359e8d6833070489426c0ca57207aa1433a47325fa654ba5997a23c5989600401f5a22084e0d4f729187ea03bd1ec6f4de66d6a4e2ccc719b9e4a1d2873f2449531471fd90876691831b11cebfe499a58b84d25ac8582f41c7c8a76ad926e9e1f9303cd8c31b60b8fe748503a3e0df8377db3afc9dd920bf3de56ab3e5be148d4828db7cbe560ce5dcd7e412274a103d48f2706cf8acbc18ac430d93610d1d70e5d90dcdae8d436b6039fe704fdf26a7f89a10b9e0d38cf8f163e0c1f729d79927543eaf9eb3700f5efc3921a8f291e5e57a1eaebca52627cbbe3e2a4feb485c3c666fdead1d17c2052b7378df8b9e0beff89e2c28a6f276e24597290379ab6c9e3e1dea6c1ec493201b0510b2233beb4e2ea5bab616d7ab5cd21e864a337b1befa49f63189e1a49fb9be152de3d06bded63356c924130a07d09e2dafff3c9d43a25c982fb96e1446b77843a5b86b0de753994fc99a8bbd802eaa1f98db921f54c7284606f62b500fd7b3b4a842d9c3b483388439ba5b711c2c94dc8b63b02538d571ffce86b8a62c66eb41448df5ac76e1d0bbdcadd5cff30ece47755e67404c501bb59bf41d7a7c0f5628470493cbee38c29d347b9bb9596bc620905626aa00a4039e0f763c28131875c816483e81ca58a3151e68e29984acc0fea3adf89401615f31becc635cfdc0f8c8bafe76e48742546128021b252f3b464fd880c2f42034d9400f769f607147e6719e0e353678c06a625b6678ae3e6428f1c0cf5aa21012fecbcf5f34d81a048d9d7edba540e85e1221a152dffe498d307abc4f8d1076bdbf81ad3286819e787c60960d2ba042069a55a4cba028e5c18bd2bc2cce674ccb19e12baf6ee9f26bfc0b361aab7522063e38628f279127a15375aed28d30a04f5b449773d2812c3d1f855344ebe5f53dd5cc8e3955075909fd008d096a8fd2509dca1c60f823afaefc535b2d96a785e44feab60e25706c08c901711c4030694b9edf32045997398f41bf7b2bd4a80e7870428c528615deed6e8c006306d0bac12b3326fc80c719c9b1b83aef106ad8ea27145304dc4350749bb9fb30edcad581dab6f64fec109ca02a419de9e3f30b61f23a9a292cc938271dadc6889213579ac698a2322cb0fdff84b0712e773563148b61bd5bfccf92f6214cd1af1a299af61320387539f40dda6c94e3889a1603bd47716d5bb9e37d7d76fccf1f598e79ff35c57a130df37d71ad3fb90d258729f7230e790bf500d14723291d0253a551d58db544e6896fe7993c3828ca219ed6c17664388fe6df04fdf36be41547fb890b4ea724b281565d98f9c46c8611063d840826665082d9e2ae9d02eb05a2ac8f087aee04fd9f1cb9d1e39af8aff4c29644140df81fa5a61ce40f61fe07e7e660bb78d0a445ebeda62795981015a4a5ce6ecffd59ee5b401ef8ed3407d908871f8f68ca66c627138858418ecb955a0a06717bcb5b8b73428b9bdd86889ae64db1da11307fc154562bbda632fc68e37cb18fd9fffaf945be76eaf2d5a087904dfb151839fbb65a1b75f2212a923db2d2584bd8fe628a5a2504e7035a29aa654ac210855a3fd3768e286445b31fc3cc77a61b14a5a493883b02155a80c54aa2e0185e3080aa05a4eda87cda0a1b6230e4119582fb0ff364098c605bee8126061d6b05a53922399d0b6051f8cd95ae63779064565c3c2311453735ac87cef72eef6419d2606241122a2b87dc0745c0eda90254a3216eae926a2b2dbec71310ac9fc7be2e1b0f60219aca370bd2408262732e70f307070260dfce0aa3b47c176f285017073e8e71bf372963b21a537c2adfd284cd85f23a38333a484a965566379fb91e68a46f7f33f8daad4626041361abe3dd480c697ade5bf9f67fd0f78d170b5ece36e628166dba713f30c09bee9517b19faa3889f8a90b6ed0323951ae5774fa1d5ad2cd6bf2abac9a52b9b8d29513775a70ffb1982e36bc5ee65e3a5c79b77c77ab5f20348a8d94190a09aeb84560b2fcbe23336bf1d9b94f2edc39c79b6c798a1ad9f5d0394b58ee3206ef891b60afa93f050a7c07bdf2ff3766f2c59765b74ea4009d182e637ab011d626bf2b47b0c44b89a873deeb13282b98602d54990843f7b27234b03122ad9eeec0c997a65f72ae7bb8c8694b37d4b226329409be88433097d5b8cfbede5f2350f9ad06e5223e6b54c4f319af4e9790f0cf9116829c1669cb5f784fc24aa85de6075752b5b1bba1bd6238173ba8910176f249f0b2c25fb7beb5fee17ac5d7dfc4b3b0c009beb35963f19a6e45e9f5c74379a0d0aa941a6cfdd65c9af67551a73b132814f4be460a5ef36204710e2ebf3bd9ed4ce816ccda696f1139e39c6a596348dc9b37a13226e112848f53026d9b4c96c075378e41f5c365ff7ef0e2473058e40a09219a09ab53aad207d731f053ea3d909c3bfb6661e03c32d0fef0c3b6c9e02aa6235f7d010f6905ec4637176d28d7ac45107fda7e51a5d4fa517561534f06ec5b10656b5482581ea04525d9a068853417155bd13f27b6fc4b71b54521db3664885574f022961339e1ab91f93a50c32705ce86f9be84dc72795c02af84d9febf31bb319423f6d0a53ae063942760dfa8262923f9f7f4b6905c8f9dc513551693bb550a2870d19e3b32ce990cf31f05a29828d2e5245ef629ce6b0683b9c4b8a4aea5d88b16090f283544dde8ce3cebc53e50559ddaf15a3bdb9cc54cb69a6acd09f1b2e340f5ace1270252d505e79e4686d612239baea55d58291159e363381b23e089164b5b0a27f6a374f9b897612ef35347747d0b2a99e41617de6a925c7508bf6b9afab31c4fcac952471180bb750db64472358bfe2c48e4146f87aed48065cec13709fa5d35a206f3548e685ab8257c4fab829e6f308b3ca22fd0b7becf18389a98deaca47a8cffd0df53d5ab02e8fdd6407da2b5be53a18b3f9ffd6a6d32b3b48b69be7cf455704de5fa8861a7d0a202cb282f1b0ca057916f9747f5d35d3027e91ca278dd585bf26b9a23096cbb92d6c560015d4c89b1ca003dc57aef2c5d20dce5bb977d4c8c289901e1e3fa397270bad1689fc529325768dd3c3085f42415132c7df390b5ba938e3bd0bb2d85278cd8a1fc657b63d434a9e0096bb45893baea6792b5d55ae8ebc94086b52e597184e102f398e02303e5b50261bc9fe3a613475c992bab000f738aa0d8b5b53946aa7d40c80b32c8330bb5d076f48c39a34c77341e987cf92ebe689da6efd503a6617e97a2bc2147723fccdfc40ffb0d58b148dcd8ca02c3842ae1441246f44bd86abbcc41560a9def9911371a5ae405e7466882b04a6fd1d735997bd765d15ab8dca08f9fe896bd5fbe5df9150a349cb918d236b81420d3d553aa2e4935910a44a322cc154b125e521d10ff5536ef2e7827e8e53bb40c8220002cad5532c045071500d823ee3284b431765f3bf9cc1c2f6ca3ca40324f0e882e02e0aeb4f2714fcb3ecd48d4926dc428ab78d07f6623c62e009b05628a93d9ba110bf0d63473a4eecd2b68cc3ab362f6e69c8e7401b605ee35c8e838e319279a7005a3cbd471900aef40a945dba52ec6690b2ffab98970f34a118c234a04e57aabefdaa36ac60feceba630b2ed5292adcab6b42c153e0bfe87466980740109c2ba412000be7b94fc01f7d920473ab8493a159c59ab380d920fc11fdb15704c7f5f1aa715f360980ded74345dfa6a831a32f328a066810c4bc12a8457bd2e3c5e5bc0e3d71d4259f71ab0341ff68c64e7faaaaaaf6d0f6f782131658db0597524fa7fd4b6dd93a2c4b7f730f29fa097c3d0e8b50bb9619f2b7f2b49acb4c9d9afb7f9f867e6b18c5686486fe68a62d1b804fae88b0ac74c790cef77a744b7a3225d9daeb687726f7a9121cc5fc28e0a807ce97c97a656f1bbf1113fcc598502b6b75ab8ef93157ef94e0ef5b557cd57012676253f548ca3edbf367211f79a6274ecf1c4d55732532288918639a1b98ba1fc1c8429ad9902d107479466d6bd17b3455a4fb7b7ab0b7e00f5026925563250e513c04a2cbd524f529664ee8719a41808e7d34018fb5755c8c9b51f6de72125fd47888465a7c06145721adcc9fbc616558fa1482abde5c7aff1bc01f68d137f43f3f68b93a73392a70cd4aa7ee696f27abea3c4ff823d243779f72b28d207b10fcc9622a177872dda8a4328679867b761159fe1bc3ee90025a6feeed1b56a9795c86c76f4cd298b2e08d6a7550096c795bd7c0b48198f3b049ae13f7c816b3e6b5d57aa3b9015bfc42690c37d6464ac641fbeb27cf6d5ba927d156294478","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
