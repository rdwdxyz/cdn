<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2da3f345ca6821ffce228616d81aeaedf18fc9eb22d245885228036d759c45ce91f02cc04fa4bcb084c302025af0319c2eadd895106b9a52b53d6a4011655328e54189174fa9752497071649acf8e01852a330d918792c71a6c13833ec849e3d729a281472955f2e9508924313c3c9b2da372aa58bae4b25ee8a9671237e407381cc9b16c38a62c5d37af078b26ca1eb72386629195d58a5f6dae89648daa19a84a4c1d8fb161274bc892c0d86bad3ac0fce8b9fe1a636eb42b59796942c54ff31ffb831e5d2f49861945f5a5daf333b12021ed23b76ac08245bdde3af2341ef34ea0579cb6a618582fa724ff01ad1fbae7793bfe81e7aef7db1305d1dc4e2032ecc112e4d7de586919a29a44a2ed580260456167e241a1a14fd106415668dfe005ab06527a541ab8a7cf41db485419ba7ed4af7c84c05ba4aa38b710ac777d5b5411cc64d401fd62a415748e821e48f6127b232a2d7b890af49944a5ef44a435e05d41b0dfc62811bebbf41bd3b91201ac11fcbe5b31cad9e137f33b27f9c12b0464930096dcb11b38e9ce9853ebb435df6a0b0b94dab22508495c42b936e2635b58ea86ca9fec6415bac5d065c5606fff2b53ecedb237cd926f46bd692f4733834389f04d0db10f38d1b3af757ffe2b4cd8e4f5cbf8b5e4bb5e7f93bb5dbed4c6c32a34e9349870e1fa6332c09a2fd721104f11609913ccdb4bd14030cf8e66261b3009f65e1a0ec27218a6a78ab987958feebca7f9c142c13a717e2cb1750d07b00955d822ec63cea041ec93ea383dc2c8de7d1dc963124428e750f2e38da113503666b50fac9728324563bbf9e4d932860b91c78d72588c49f9211a398a9d337ec856357f3a6a4d335925455a3b697fd65d3c3f1521b1a7534f62de52a04e0c77ab0505a15d9883f73d1acf2284948f349d9b57d1ba5076b5e952adcc7fe23edbe0f7c477d89ae38edc1f565aec46fc37d1c82ef2b3298cd0f5fa49e28b9fff642d6fc873b61a8b02a3dfa913316a36c44971f842ad2e3ee0babe31c128d003bc375d07f32f4d6269440a53c843efc4a2196a2d02e2ae10bffa49a54b13c00f8b82f6e05dc8d98cd773bbc500c502b19f12e7917b2e893376a94633bf39d35e7b689c029404fbb4215799fc8daff270fbbc5a25795c1f42cf263b160e8f46fb3bb0118db7b7b4fa697d6f4eeef3711c10c2f72d396fa2929d7a6948f8be45f65f44574479ccda8fec131ea5c087d31933976841f34d0be2cd884413d91135b7afe2a191fda904751018fedb9829e743fc582ecc514e00b88210fbfe7e55a9599d1c9fb7007028fd5f806b3190aa66b5e22a781e22edb72e604ccafbb33b08175651abb85792aab088939cca8adc08e8b42268dd4fea92a4b5efc54a9bbbe35d84423648d4f88ddebc9a021040ddfbcd4803f70098bfbdc28a0d208a3418a9e86528404f118b222512a169edf5506ade136d180bd761bd04e6f262a7099f5bbb86b531ec659e9b2436eaeb6f4beacd23c9ee0c6110fd078fe5eb6eb224139381bcd01a5879acbc4f88ccb78f634b4633d1fd6a7d2955613e7710d9b7074e65af56f8e1bb4e8834b044c3e930dfacc33d2b438371f20555fd06a482b35020b88884e212251b4b4c7fcc1c648a291ab7185a6531edb04a2eaa395fe3bb9ce23230a7ba72c25674f90bfed760b674c2949b44733b3265159ac5722d7c56d0e2bfba2005225524972c461c6ea62864565b286ca725df4baa91877a1e2dd66af5b65621c234f23c80638bb848589c46c4f103252df786f2c0cb1e171a275f5a0b9a7aff5882a3c8e9fe0b5522e7c24b7ae42d51c5e811d29a212a7e821308def0f5b7ddab7b7ea5d2f279f97b575dfc50b297ec7183a84da2a316113997381b7357550c6223cf0388a8ec07ce42f452f25dcea3f7ab3b4d66059b3b8fcb5caa17732e20c078ee7a7e5ff88a9bf5e3329b077536d598504aeb48fb05aca19da7ae60a83dbb93ea8a58240d4179c4155d02117d0fa30828f8765ec54693bf3e7e3933acaa54f4627103aa295019621462c42dcb6bb3547d70f4f09c945d343c57a34273d358cc0894b789a3d8d32603216ac5921c8b0ae5fb0183412fbd313d3bdac67a25856a263a04f5daf16813d9f1f65f3e021d580230c477bee5c1905f8eb47163f3ccc4d924f0d485fb8e234cb4d94581b8fb5e316233a1ecacfc24fa062c0d3c4b85aa1f2f9090bb442cb3422b9a322fa5f250d198de9383974173636b440946bb902adc7e6cdd68b38b411cefcfaa0f27d0f44b5ca72845d6a7674a96dc8454f2152029b41996fc7ad20fd9e3665c803eb7bfd18f54d2d4d585ecd8411bdfcf06c34688d8bbd4f517f0d99af13d0dc8dc4c338dd82fdfeee5ac28a7d75d7689310fa6376b5852ff59b76f2e4af031f0bd14ed0623d02603f3d406390a9d28f4fb9a1eee32354f0fbc40b20cf699c6f74bc66b085fa6ac842b0f93dc66a4b2e6aace68bbfa7f54253732b46d3990762d42cb1d49f923b6016b58a8fdfa84ce609c3f2062fede32d5941bf996923a3311866e509f8b9b29139cf617ad46921ced806ccf36de1ce52fa77f0a46c7be97eca9584c7d3685c8cd10e9ca8544ad9e1b2b8bbb5407646096d063c3eea4d600e2e8d2a53a421528a70f44e1b2fe56197b13685f5088b5691ea65fdc87b59fd30c3b3f0c361e61191e8aa6760d9a3af578098f047dd7eed0194cdd5ba0a148fbad8cb511e6e9bc4bf570ebaac137135be01d4c56b053aaf3e703033002d90afa2e1aca259a2465e667beae9e0ebcec4654dfd0b5aeeb4f24c53df473ba9b36764392f2e9ce3ab49d283ded814e25be24bc1697931c7f31c7eeea851920eecafd9ee4653a2b79a0515099bc7ff3a5b3187b734936b5af993ee1aa04eda0c37c3fe36f193927fd90edcd713e8131ecd05b8725d2b031be263fe0d1ee0499e15a1f3c7d64f8cba54a28112f347ff51ddb1cb8f60599c534eccf876d89c44a6c705b13d193bf3d38d0a193acdd1a912fdf8c2bcc6f9a46c53c25e89ff83033cac7a0035bfe4251311ff4b310aed1f272a49977e782b12a0d241c141d915fc4d09786efd3f735c8af64c4166668eee5f80bd10ec106afdf9c3233f7ff819f788f3f65234be37070f6ad5e28975c87899490f0d41cef82e7e1ae63a13711ee9ba85c0c468475630b683da7a6aee75b07d6b85025d990d43db8b8494988543a3d9ded0391c3b3a6c85c9154ab97c32eced1b9316bbeb2271cac8b92bfd5dc2bb40037c4b38aff08768c9a56365b79640c29b734c039a156570745117d2f5449a1c66d1923b89ff91346e78aab5a808e025cb6dcde22a558210677b9d33e17125ce4a3061e3f9afab978e61236a08205339e07b5e2a24855d44e5247067f42259fc1138107528ef68694e8f57b806bebef640a1585e5976f2d4b42acd2f78bf266efe56db8270194f43451ee16b7ffa4593eeb3d7570246e7e4ccc47bf1972b57244fd0b97991a6c1f25d8ba3ef2766ec14881b490089e2379d406169443609f8c79fcecba3f7df756657ed4770d57b07e87a0ef5751ca42bb2714821efd5ba0b016d5d5168334520d93895353822d4c63dccb7a0a984e3b9e89a54567c8a56010e4e3753948cd01e0ac49dc1c46a4fc508fb66010ffe7e5fcb9b53feb59bb664496c5db2cd1fa10af6a4b37e1e9fa3bc0e71e0a29d131433e2a8b7d6baf503dee10c9f6ed2df1a0dca3765af18cde1884094cf3a044e58916db9822c8266cb046033eb18e320e14c0c5eae7a4f2ba7f5e78777590ba1748e68594a23393b49e60c37f8398599f7fe053296e625910d2d2661a8b65d07a9b1249f5a96f27a56850ee4fe29868973d15162169e1f26e9527efdc8508a250153d264594fc31b72891c04f139e326d0e47309fab6687a642b8aa5518a5e4311b88288ec6cb7dc00f1797c5a34ce6e3f5adc83f5162e002115727b04ee6656dc58bf5e72fc31ce4c7d50ec0ea41c9219b30d623e08c49c7419977b78d3136deb3118ef78d89c88430236d89cbfcb1e59cf5567491f58f8cd4ff3278db8b53e81bfe6d84885a62c551b9924f48df4d0d4c60ae344f0430d134f42c676c71b0cb432ac91ae5968591faf838091d334c48ca01fe772860fdd72c03ee050a764e9d5eb02fa5d6f36cb096a512e3eeccc1fe1d27036c48487c2738f7b1e9ed05247419c10f1af8194b8c42d903bd335fc3d6453a1ae1d60860c025af0c14d260043c34417813c47e1e691c527959b698552b7cd8dadab12de9ce05aafe2f250c60adaba35b03ffef365b3d0be9f055fd5be01efa77df989a73b8e09ef5b94b5ab254d8b4b74d987aabc0135aae61f1b7247c20e180691c7ca2904bceb71087035ae492d4428800773591b6f9ad18a602bebfb6ac3f84a2c0777be9f5056af68516b95edf5c86409f4008b4cd2035aa88d4c510cc7788672c0e68efdde847595a4f8c101f75b88514200f990bb77e8f59b414cbded26c5b4f7ddfc6ab88cd96c52b19d33e398721f225d231e27a11357cc32bb255788a508eeff12f4bccf4d150dab8c754856a62d76fdfe6ebb6c850f8d5754aee39fea77240a6c60144b0f4c370a59fc8cd2b3f6c79be80a041615a09c502d54698378a4c619d75817bbe8ba5e35921e9d860fdcb6f49b590fed3e3a360ae90438591ceb3e2b41355167ecd9af14ddf8a5428fc75f18f626fcb9259688d225cc43c5fc18075e8a690da5d28f656e9bbc410045e43cda38fc5ba7afdb0abfa531f089634703e56b79950dfafe0cc29afd42cca95becb4daafba90bd96227cecfadd25dc2d4b5ef43813b62ed08258e741c95e3b78b22802f459bfee0efeeba2e9d38a390e1198467141ea0dbad3a5553358a523fc3f8d0bf46f5d3e04833afd7e7a74c9e6468cf238ed62034c49aec01613857144a17397e09d3bf140b40232754288d0d28231f08526e74dfd369b22ed890e0c7c03d6de07a98a771ebf670830378bc28de7dfea590d732a87af03a9ca1e694050c063878941edfcbe712ff309f05e622c6973046cc266066a9d651f7791471e16af89efd567b14816cb0eb709a6342457e8b3a18fc9f4804c9132b75ddb2d5a93923e05a7a527ed57f59ee174b74ea50a07ee4b04300934d87635bf02f420c5f30be1107f5c8f9e65767221d86bb114581a1566923377ffbe0579a841e8db781fa25027e6f89987d925d31b9898ff43ee6e36228fedcb56a4046264661301c13b039fed5bab5cee3cce41b77d49f9997049811feef636ceb6bd891615a14a0de6ab1fdb04079e1032099fa22b950b2d7e0466ff0a4836e753428d96c882e12126a2c68443c0dafd6d62d1f5f089cf6663b7878147174366e02719f47bf914b2b2b0180f887761639f54ea463ff1166b3aa17e5be060dfa913dba1d02bd8963d15f3c7524bb7829fbee6a66987113e1430548a21e2ad1d616aad21b942632d7790ffbc584de4ce7741866e241cda336ae5e7ff82bb0f7c5422341d3d104e41676e0abbcb553e1ead2cc639b43f7afe7cb49ebafc08405b4fdbe27de5a5d47679cde5cdb514235c21868a8f45e7a3455c734b516d640a7e12074fcc1518f54dc1bf80b0fcb2521956aa1206785ac02072e3670f4e2fa38f32d4fbd458fc05eb314d1b8b9d7534b0dadc3897b8c71fadbc3b370161e63d60d816c22ffd4d6941500939b14559a1325cf2a5e35d642f67d76b56dbe5bf1742523c6bc017e3916f8fcc80929b8fb8a167f2f77da632cd8c5194fc32d318267c9806035f2c7257d984cdf54f22a972ad4c6fd76a865af53068d617d5655a3b32374eb65e9a40b623e21dbb1a30bcf828194542101a7b9d3370fd8f407644cd37890cbe0e3c5e2839d6338b9153a3611fd089326a3759619d2bc59c5219f5257e523a5341be075ce2ec9a06ecec54827aca331db3a78746d1bcaadea3550ceff9835555216d31e7a34405c072d2cd9e7f6ff13a2b58b81b866365609b43a281f947b014ec1ce1d2156ebefc3d5a390da2a3a26ea34894544426035c0f9098365cf90bc5cfe3ae9e939dd6e9db9ebf64be6d8576e23dd8a212bb3d82c6488c99335fc190cafb95368ae992a703e4a31429a3dff4c68bf9e14429e101c0983550f2c12d4186161d62cfbf72d375f6eaa7769c516a3e30903cc7982a210e2e72ed9ba28aa45d62b0e385c43e7828655c6418d1a8db6201b02c0ea54794e6ac2a8a6b575a650b6e2308b632baf7a20cb355ee478ad12905b119d38a1ab9136e373fb53cc694e8fcd37904b54647e58d878af9dd02605bf4ea1f5cf015e954c36f109082ab2e3d70321964442cbc23ae27c07cd930ebb6e3000d683efe2230fd1bebd71f2acaba70fa708997b6644015c6437c0d7c9f4f3b9bf16931d71069a24cbc204f3ac6e87ab55dbe783bbae8da37224d789b4a4607f7971552c40d191e5a7f3c989ce9c3f031368e5a7acd2d148f6e1c035f7f3d843c29646ccfe2b990a2645f7e00d5025430ada3f0c4671ca8aaa47851a9b37edc457caa5518a89b82575d786abd5c16c7aa4696c044f0e1da61c6c72253bbb804eaac359b958ebd485a94d81297cef6a3d88c2de7fd6863c6675717fda18b2c1d0ad658b9d6b77bd268be2627563fca9777029dd58e34c0c54b2cd4871baaf6587c7d1151d6ed8fbe7e13d391bb2e278d7995c1fa8e7d561c806e92644fe825a60d9d304aff94a57c1d66037e1e35ab83a4bfe8a5f17c6725b0e2a4f274a51f7d16c072997cb698c1dbc275c2053c4f18f3b6d0644f3de687cb05091b48f5ea8f1f7571aad3660ea1a16d64d47a743362c225de317e55d53784cfea207bf96d1ba274ebe8125ea1ecb56441560f83d7e5a221aa4efe2a8a8955c54740ea74257da6dd45995a84a3b22b672c70717ca6b3ed74e4a088edd03aeccfc64f3a2e09ba44cd8305788f036731a6fcccda44f2e8dd19cb067f951cbe9d7de86ef0b103b2e64b2e745f71453d58aa92124e41ef479b41e02286688cbf91d15d0c040e9eb96a4b9bc2838671afac1554fdfa09feeba051bc8e7b65218338bcff8dfdeed4a92d2a20f45243275d7e4f1efd44b705d080bc8dec4480d3a06858ac8bc235518e4f99cb91b1fee888f22c41e15d7802f3c880876891f980edd972fae4efc8a6d574a1707c9f685732c48f31464434b45c5ff45b753e8164cfcc46f166ec7fe016818c657595fc92bf2133992ea3ba3c574fa4f7874daf42f8efc2ea5e3606b04ba557fd2f86b476d59118caaeca1d62a35b4c36a4c7694a50938ab725d7f280ddf747559a212dbc472a4efa348c4eae410a59192ca4839461808db6d521316f8eb256a61a547ae06fb1da7dd591e51b47701e38b38843804b06c8ff11e5cb427f983536aaf9a15d336a9fc2d08b275087bd8e49e026b9d6e08acf6164c2212c96e2edc31515479f098ab1a5c9066711a6d1068c31f3e2e2bcb4a6f809d170a7967a352fa1151e448a4db33ff11ff7f6dcbd8236477529a20b4f20c1d4919b24c4b689416e3d8657d32d6e2e888db3f673dfefe12fa10bc1258556c19f64e6ceeacc45110329baedcb86ef8f696fc59721e0ec115554fc2909b6f4db2b0a250628acff2a7fb52693ca4213813e53290c5b20c4ca97f41c8836c174a9b8e6c2594b9c883f41780e84f79465acebf1c46252be95abc0c4ce802acf01413c66fc60c46a3ae04d8e9852f1d288756dedf469b3b6dfcdd50b6d23bba1a18ad8cb68513584cb0996995b2906b2d37a3b016fd27b1be3f2c2c2ea43b10707a27b1dd0f40ee831b63eab57b6726768fb919c67b18665183b5c6aab1a20c7f23becf33f648c52eabcb576503a26a24555a7de7e5fccf8cf86fdd3286c7a8d89b1f249abe9294a604c0677c6c843c6f9154a8c73e1de1b4e8d4e4bdacccc001107f09b83d614d2dc24d334163805acc808b3d25988544017cebb8375ce23eff1c5125aa922b99332668b5801d4dc18d1cf508cfbba549143d6c92f631d335738c775b6f1ecf87cfa789220a7627bf58c87bc9f3bad5277233fe1ce8b39af517e11f5b58a352e33703d83d3c978cc72f7af1d5d247255c153851410bf9cd1e548942150d9d0be218066d122d0176aedd95f3e30c5143b221da1375cdc4c293afd684cdafc1945917ad9f9ef00d262e2cb8f488e65df42f08eee343b13a09497609934a347f0c4f60eb69560654e8f368ae893a98c64053a0e4c6af629d488f18a1936d92bdb28947a38dc5f8a7bdedfe79833bca28caf018877d10c8244a8ad87387dc677ea54d5022258271be41f9ca087a57ceb2580d30fa666b7ce9a5861eb6f38686be6a9bf894145fd687ee9f3e0cbd97f419b38abe20541d8c36d6cabc0a623338d4302b82d4472407611b2db7b49b570453dc3ef0f950d5fd9b8cbc64e1ccdcfa37c6040ab9f044ac0621e51fbced2a3a968093b7493fc7e3d52fbfb95e3937a2e85036c88f93ba234cd76e0973947e1647067a9c0983e077887f9439e7b54fb7a1325ab67a3a157227014f39b76824eb7c449b0c7b5dd351c949c556cc238f67e08f72eb8b5272461150276304dbab4211a24234871b307a714a63e0511c9060bec057563b2c6042d350d7eb52964f0e9e52c3da614fd1eb9585b00e4b3849a6206bf14724eb2f3f930fe7fc1db6672db2829703c5c8dc47f4dcb1a5ba1ce8cc9777b10d001d25e84de6f92c575c8b98af74be512765809dd29d8421f0730183fac212c1ae4d290e15caa6272ba4c879457437a692da8b791690c09484e31f5cf844136094db9714a0d238ba38bec84bae961fab99ae5d17a79d47f2db7e3630bbcb899c82e4a8273ec1f5664efde47c9819b39df86024fd3a0d2347c8d8cba103447ec6a89c256f459e8e5a8118fd028a1ccdeb0f8be46648d41aa28b971a90ca3ac8b8b39dfbccb875385cf2f6719dd9a73837507bcbaadbf422ec660ab67c502b1d9408d48dc88ef59b46595bc77859dcaf1d735160643d283f8ee6fbde9bf1df51815dc617ea07a6993f0d05885b96ea5c8f6d4b71152101a2499fcf17d5d5d8c4594cfb5a210834432f12cfd11203deb7b3ec3acfb09b6ac34ae08e3665bf6ec427cead76191cbca593a2932de51edbf39d2b721a73c89e160160fbb6a61e087ac89e64a41b4d2cf1ba4afae1e1af6d1483571341cc4c341d791f01d047073e6eb2605cc8a5361f4a1dc49a24bb6af16f5db5a11c8cb8fbe2a787755126a3f90cd9ff989e5e46796c18fdaef438b96c16b41ffcdb8f0dd31099b2ba56bd8c86da9ec059cd0aa8de9880afd4ec71f8bad8c4a76b7314106846872b89f49dc8e73250284336679ec224429edcb7901999e861ede0b406006ab3731f858876c0e0abad33289934f633a054a63f08f12d519347285bba69c04397f06eabb51afe96f764fd7691c8300bf9c2a46bf4314840aae5cdaf3af1ca5643ba461faccdc3d82abd630d7d235316e743b44c4ea9a7617ed749e276154bf2c31711073a32bde375048857b735895e9c7a43c7f4a2106bf7d9036aebca5aeff7951ef491feb1930effa0d5478714af019225ec36611ec4c48bf403a21c4ee0634100d600a3b0783d86e4ce4292ee2f73c44e06df8bf95b62cb71760a3dce002e4a7aae8c7353d521a933409513641f082b6941bced2bdb84747ec4676fdfe4504cdaafc3f13e9899a5562f2d83ed182d9487b08ec10b4743cab4024db6e6dcce14015da7762b8055c42301b11674161f4066af4575b0fc712374c0612d397b9a93232cae77c33349dfaf9d9872af8689f60cf6291f76607e9f879365131ab5520e57cbf6d4e4bd3e9c1cb9b8aa35031fb4452436ef03505869b81d6e28accd43ed1592be8bed8cd717b62ea6df1ff03959b757f12852107651731cc62fbc549f6c9953d0b3aa514fd4fc707f7d315456bac8c10d2c1b75fb5af8d1a58ba59689e83dc3ed86c25a13cd9cd930cb90d4c556b00602bd5667419a8886868511a9f28a4896fa3e0a62115407781fed7caea45d2b33a7145ad6229873c7e60d9d7bb3880fa542085de6ca56ec644b1fb5c46e48354484450fa666ac6e252be13efa2d614065639333b9a2101a6b461af7ae862a80e1cdca0b14d656b7b90f895f392ff9e0276ed1749059970b9e87af416be4166cc32f584c9234ddbe0abe62a0243032e0f77ce965bb56e8fd7b1975ea6cc725a3cc1f76af4c77f523881f265fbfb945ca8aa4df286fbea0871bc0962762b3402d97f5a5912a8484d178993f5d755969f310e30862fddfb30438b4e4ba45c7d61a17ad19849eea05f9327b6334d5dfff7790d9dcf1d88a8dc4ff6f8113dc5d773c16fcb6798b68f7e803bd67305c70ad9b0025c26942a3b184b2cc40151314cea237723f6c45d4ec522163e399995ec72d1a328f91ca24b3771e82274d70026091f75d28f57babf200030ed4e082583347835f333c17d3b4a4c9f4f8ca18260d761c9a4afa98666afb8ba9aa2403f6aa4008d256668fa26860aab83ff1eaf68c79030bd4ad1183266ba0e59fc408f6dc4b23270e08b8f81168add0d5c53bd0fffda85e968a788b3bc41300243f2e4ca27eebcb30ab7db205ee960e13fb7bb03802faf1c72306750e389a8eb426313108e73b1b4d67582880b763b2200022d65269fa235eafa0632edebbce21348a41e1c7e8c130a2ce593b2eb801429d84467a9bdd32700569d854deaff90ada0ff8ddec5da602c830f2dc2343a936cb512fdef0db91cf57c67b5fa4478afe176b0e826fc3cd803d80b4f07ea706f66471ab3d139ab11021f850d31ccb3d1230760f932be43b41a6d334dcb5b2c8355543b4b834e604b8cdc9b504d2cc6921af9faf184e0ba46f0bf0dda1a7bc0fce51958afecadecb40801cd5eac98e68ab9937052bda9595991ebb889f20ac535153c88bd89e3cba1237d30c8d6d0c8a77d9b88603ae3733fdb88f3ff9f10d3a04228ea4f62962a1f429b28ed31a2f78f01ddf2e962f95d7a053d4529c21f4520335f4fb066a3c43960f7fa11981d172f3803a4e9b1e936c3d51d438a319a1c9a30c9b792eb19527334af13aab82fd315b26790de6c7354f2e36e2c3f88e4cc337ab89669198c784e49c86f8ac3241ae3de52be9d9bbdfac87ceeefe5fd6553ca957287624eb630b11ddb32caafdad4731e8f95ab45d05926ff00aa5ee866e3dd412266ccc9b8d957c74da1b934dff1039fa41fd535c960ea924921efe24c8adf2ea3904fa454718a6f49f63b00c977b09c436392f6ce45001129316d6386f5015d1518ee3b72fbe1ef70e2bde45de722bb3752334c9928e6bd19a203552296215022c4d12b39bbad77daf33b93d318e852ae15359d0ede23497f88460df306be91473f0adc4e7b08d76970fb8a10d6f713daf78318305ef789a876ee5da45fd983033413f746132f892befd3e8d037c00a2ce108c795123fbb9cc89c16a0f5d2cf7863e14936a8f476c2fc78937295fa7517617d8341f651a63bb73162577f8f9ae92213cd5cd5b2a1fb08d016e128c5ef14ae59ce2cfe9ce3e35fa54d7bb55ba6985bd4fde414cc74f49ef2c1ea8eb7ca52f2cf8926a91439c7e47028aeec51262700fd04f6cd82dfbfc3ef31d5e43db38d7727b20efaa664ba311efa9b850e52053c499e4c9386c47e13a0beb0cff8ff25d8c71c9d2c056a297e312c04280eed0dee3b06e8d581a37d656dd459d1c0a32499acddf3d5c6ec7457ce8f9ba62c6b9e46ccafbb995b0916d4a6d2fe1c458faf9d1c8e78981d90c2e16c0e429236ea82639c1ae5ed030e5326e444913f40d6abd243696c4859b7d642dd81292ca3982a2f4a1ce96504c0450840004f1d6c83b153b8e60f6591b961cc5e8291b051ac7e4998ff7587bc92f100cdda9bd57620071118908074cbbc6151ce9c28465962972dc7adb058cf7004e4e165804252a10899c28842263ca9b108830af476ca2139f6d26b619bc94815442f0d18903efd171984586d3e9ed629b5cc2a503695c084aef0ea7e302455a9f0e801b107ec04119bcef5933833d25203fd4fa3065b28b1512e4f2420d08494ba111be62bf092286ce6a394cf2346f6da27751be209c98c21c042b86f7c7e3381798c7ffccec854f85fe8ba5d44f69c02667f6ccb1114dc29c141887092c2b8b1dac9bb0e6891ab509d9fef9755a4ec0215710338112737bbe48568e3db44e57454d494d2b58bdc96153c4ed6276beaf037cfc66b9b450cedb5b23c6a6d44b52513593568dcf58e0fd21399c67535dfdaebbff92f5f9b6c7977e83deaf5bdd077a5fa45b6d0f035b9156e3f6f1d973460061cf6241a04dd77225db83031ff21ff0dc68458cd3f231991bddf92303f34651c928434c35e8d7a0793ef218fa2ac71e1f22a2a691695a063a067908f31b82caf9de46480794f98deefe857e0fb5e446dd6ef5069da40c388ed38b4c11482c509c3d8f4cb7975897d2478c1643b935fc1d14be5bffb3ef6a7b466d7eb3816d3e0539434e6633e61f68c18157140a1d700c597c7ec489fd3706614203113ca19e2c3e449e3598dbf3c795ea80cc6ba9e7bba887a22b53bedcb0afdf50cdbb4428f43b018be3633e27a52f8c06f777d9ff423dc3d2d987b0def1c2c95c3e386e84013b8762301b02f8892edce86657d32986d2ab5187c0ae316cf759aef3faf028018705428524a5fe7f159febbe7d65519ca8153c6fff4e2240b965877dd85aeb798f10350659ac22d940ec7ba2a10a4df6505d8b31e363c3a9d2eb18f0fa7de7b5f81293fdfb46feb1dc2bb9f90527ea2fd4d58d28273581f19b274ef348ffed6f75cdd7eff75b840bc7197d4e2f079489031a66f6cf96c5f45426a2eb39195ca5d692b509b1eda015633c7692e0b7727481ac1cc9af6debf5e0a6ccc00f98fa3a93d21c3679aabfa1c98ac9afa00afe8f293d70945767b1e50958f458c0e5298dd15ec542b728bff3ac76a5893f46f41aadba9f3e4f15f691d4127e6072141e436ecd0cfee30ad1d82bd509ecbdb32411840d0f1fd7e501f139d922ed83c08d0afd2a050d97d88c0c597b3f8035a4b2eaed62da8e9d55acbec87e2f122d2860119b164423381835beb8b7b89815ecaf9d508efaf9776bedb2254d85c44da77ccfa35b0430efb221929f2181fc4fa454ca0a00fff699970ed7a5dadb618804f2617aa968f701cd9cd4c2fae3da899cea4fd34c9ad54f36790a81925fe7e6593e5f016ba946387e9cc47bd1e2f6d75b4b0dca044691d9ebff5dee34e31b76ab4a76ef5e9944c61100cba6635ecca88e6e9404ee18d3f4997c619f00c3b9cdc6c67b6a00d55569e2e44615801adec747b8994f0f0f5923d6bf6f0e55b6ef62151665cc4df5d1afd46178d4de45a9adfe65140186abe8301837be42e6fcf644b0e4d135b290bdffe9a1dd08a8446f6083f6cc0892a8fe2ba0d18987373cfba7b6fdadcc308357806abb90b65939caec36d2773c81b237896f7cf40d95b7c72774920d4914941fb283b408e7200000ef46996841b72a77382b0f5ce758b7a4c2f0cdfde4b5f1b69bc824d94f878699bfbf7534fed8447d6a3e0f3e26e4ed9848147309243ceb7392f3d8abd675d380ab7895dc678adc274b7ac5f0f4f231b343a21610a5fcb8e5bff04a70bbcae9dfa2627ad4bb60794800f6e370d1e651028951790090bace97da4bb76b03946b090a703c04ea610776d15d8dc850d024f204c5034a95005bec03309ca8eecef943fbf00cd5b5df3f2bc095c79e42c8c36a397d3137bc4b615377a086d3f6a0df28e1a4f15034db51a8bea19064fb54655c9c82e6151c1108320e1c644f9d39267c118f2866aa9707896fb2c23dec6dfe3cd7958c2d235a2934eebac5510fe763c7b16edf023c4875e196386b255d93e3cd486f26ffbcaf22c0fc319b774efff7ff8fe932184d1521a63340e0c3fa619aad180464e76385632adaa7ce5b9a1f7e582cb20ac51ae15aab5c181aaec8f064e9d07ad4e8355dd24dc8e7ec15d636bf33dba5995f840b3fceb3f3e3ece6e65b4fc482d066ae1e1c1f82bef4d329f82db2799fcf9a972786cfba2eb62126040fbb63575e1a8c5d2439f571b82284514df135cbf776ec0fb0271a7b283dd66beb4fdd639e84ea09388b074653199a4821b4200b81e27b2d03e7805e287ecfd369e0c6cfbe1af16e1754f6b1d6bb32973d54f21abd7b0efbdabec8b48de1a7af0454bb220b5b19f46f15bfcb48ce489c5b6f715c429891788c42e931b0995c5b9f67ffc24c7717c6173be3162d4a66b8fb9b8a4e6dadd608979f2edebeaaf16c9be424d5e71da3f88ca8416e8690db779b595e68dc724f90174e6a63922fe0c2cb4e8c6476346155426221dce6ff4817d21ce8461b88b52b9996a4899aa45edbf5bf3326d9444c5bb29019a96065febe26bff09c1609b476457b1a0281286e13eb053506859e5db9be9dc7dbe1c6596dc95e7de2894c1a65cf57dcda91ed07d9aeed69c2d82b39ac3daa381ef55342085311858b6704b5278803daa9b12d76d4fa0a955221cb15edb79371c41613ab7274c6753e9c673b6a4c18e3fbe9663a6923a9a728c0f72afcbe8e8a6b4abe168144dae58b084c5fbe716f2cffd8243b7e87031b83148d394f0f28211ca5cebde0e5e429bf29a166a559a65b95a6a99ad9836a9a5b0d55f4a5d4f52da94cef48d14ad3800661dced7db9d0ab9a05d515a3b8c706a10d5c4fcb69364085ffba25e69ab2ab13f2e26be14b0ab306e2a0e1e2a962c09a09ec42bea12366233eff5f8fa5b2ffa7f3a14aa559e7e30f13cf0af485c97d45de9e9773abfd6cc2fcf0e397464442df56f3a13ec2303c7dc35c00ddb667411ff0c1d6a049b83af075218f65573971218beff06f781140ef8ca64c2603da7e0ba051afc7f10037e3752606e79187d8fb5e6bba0272c0eba675da8bd7c0244c8fff985c21107a9f0015adbd77d3185970570acb14778ee20b285ce732e4fb969f07e1122c7c5bf44502731ade94ef8d29290fcac0760d5060c8d56b632f2936408674df9d316438b1866366c82607af3d4db804b086edac3fe44b17b5f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
