<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"98db1580eaf88bb19dbaa082293e15b04162b48ff98433f2de87004af7c4bae9fc1b81872fd3a51457e0c7cfcb44a9c35e54f88bdb610728bfdae1cfa9a9f385304cc3d51e369ccb289a254163768f157533f9c019d3c9364ad1f386999f3e27a08ce6aad41dd87f71879cf5db68148b073d934fbcad3f633ec8f4d1107084e75d1650ebeda9c1a20e636bff376678d572c4361d235083a4cd762ea47567dd10b6e27aefd86aedc1c7dfc4ee7163d50a69c5b07b76faecbe8f2cb97e6506a780c339fdbb3473b6ce8aa0e4dece740c645e42b7e65bf4f9d2ab6b9175448c870ae1ed4bc79e0922b2b0b21665214585b71a729ca9ae63d6a5c45b221abb82b2f21f19b3ec4dfc3fb94d893e607de6c8e20f08f3907e08bd57315d3cc0c8f96f9b17aaa4e6d80eb36a5e23f6dc37cf7fcbd468d0ed38f8216e0948d1f227e54d524bde4467dc7782c853b64b680b6847456be665eb814125901adb041874c859b7b60c21270182fcad3027686fde17cb76767746c1127bb4e0311393737c0566d0fd30f382a1351716a2a45abccd0dc70d5c65172e15c8da0d1a950533e9db0be7be5cdda6c2f2bdcde9e3bfacac3ea668cf084170e171569946b220cbf0fcf092f6bf43cc70cc9b7c9039a40f209859f7e78f7789bacf75f2c8caa4c4ef884f1f4ba73766dbb283618c9503990cf671e4eb4a7cb8e7069b5b4531e8b0a8a97baccfaba357d1ed54eaef821abff567a16c1141208c5121bd4f35017032d223a24d9c53f44d1cb7c66d19128eb79ccfdf7af2d93d0219ad6c333c5e24342339f7246834b441eb2349e1581988b134c9d4f6c92c5667ab5fc2aeaedfcf9cd630e7d1bb6825a9638bb94c08248fd5baed97b29d5fcb9e92726c716f4d245c629d05a47da0dbdea35969db7e68a20e7505c282f7352a0c85c0ac0fd264af425b393a1d45b0497a32361e46131ecd0efa0c25d55b0fc04629965e95e96b5392781b8991e0ab03fb350efa2487d115f7d946549f855136fbe84c776c7f5ee72d326b70df56f65f77a6dce5febb9e556a2c57b45880d1cb15fd162ecdf6a3e9fcaf9e279c3cd2e171c02323b5ca177e57c834836a929c27562864b004743d5d7a78d214fa341e235bc74acf977edef2af52ef355ed69274e7bd3ab776034b8dd7c145945778a733638e42d7b97de338508a981e42d736f1941d4eef0a1c8fcce88e04c88373348865804178cc9ddce39d83e8bc1ead2826a1b842aa567bc9ab6423ec6981b2c1dcc6158ddad2c3ccc68988d4d93d85e5311cddeac4b31e650ad663907bb11690cf9a6c521eafd737f55aeaa8edb5bf0a1ad7b0d77246b95e46e0d3721754eaa10b4b2e5c0ad79964c5a55f9304c41a85c7f9f30a9acbf3ead90d385c4695ca4785ba1d7df9ecf2a3eabd8fd824be17e35471e7297f6596d7e302276065131df9e993065bbe9b2d0f7b63bebf968768baee438ec4c0ed750d4c4602eab59c3b1c00701a647d8e1fc08ca8cc7f8dcb03c8038bb87bc650b0f6c14ec67823b851826da77e22ad7bead26d0bbfea4bdd945df1a4c5b8de47da01eb937b55dd1bf4ce0cb094dd35ef275d86027c908c790b6900af7f28381b864a31c0b64d747fe480bd3429216d79093060b2cc61da4a3aeec52db4faf4dab7ad40c205874d9ca69e29e29c08db5dae6c3d652418b0e16101106c25934c3653b90fa61c9affdbef88a8560e229442c1db745f18942a84f30192094c8ba1d3b8b2809a91523ca6d42c41f8c31218de144fd82c5ce22a18e328a90d584865cc9eb1fbe1a7d9216984e01225cd3652b19a9e748f431b0db176e748c98dd40472746af3aca280f51b3c9b0cc7ef0ddf45805e756833e716097cc6c583e7e7e4527d9be2a745b116234d28dff24b5c9640ca3c31e09f6ecfdc53569b8507839f0d0ce83bc41c280ffa043bb9751e6e5d28dae5c3d8c9af29da2f86727e3d1c8ec9522643f7cc2ce9faf4ae93aff96b6c4187546a7edea46b5daf75971abcd669f12c8d87e44dcbfd4ccb0807460b716fcc6e62eeaf76f5b4de4cf2763296575ab0e7dc93d14d0f20156377fde253c4c23670e2013b6565cf366d6a5c9902de377f5f6db364d0b460b64aaba5c9ccfff46f9cbaa6468a288d59560ca0d782039b619a25a5afc85c8eb1801a1c32672cef673901e8dcb5626254a7278c92663214bf40ff38428d5615048e76072e5494ba3faea11f5642fdf9ebb4d8fa22caa679823c321881c987854abb0955c848f60a021e26ac894a53c617fc512a531f54c6c02714a22291630f5ba26439aa4103e26c42df62d33a8485bdc75c03e4898ed603ffff718cd0d4027d42b36f3ceee8050692a8cbda08f9d804a19f00885bd2735956114b1c31a77e301a8895d47e2e6b2ab1ce3e7860e0bcd2fc0f381ef8ab9cbbcc5ba6d0fe8d991db1729e650ad4606350435d219d1426a4451ca86ba0fbca826c36debe63cd35c41580a2eb8462a082325cdcd927c9732535063e61018868f55fed626e5732ba254f99a7727f72ba33f2b5dde2398245aca7044a8c6ba12bbc016a950243fa6c6b1c8b8f0bafe1658df01fb8c49c01b485efad231bb1235b0f6cf0640403c469f92ab9f0cc5034acd7c7979ce6bb82a7d3916addb78ce86af4f1b33112d1a0f630259c8483d6d7f4bfd757ee9ec6713da49fd5b237969ce63458b3da660e3b0f84e3306c99dc2885e200f97d8f944e50d15d5915ad7feadedf67efc8e6d6d4a502f40665ded068f4aa081fe5aa25bfef91c36b89ea77bda5cf3b4a0281dab42a20e948a854ed74e4fc6e9057f9e6b101adf3538f0e369f71474fb6f2dcf19ac685f6c706de3d5414ebbd2a189e72b768fd3f75a850e5c4f5562eabf6c9faa3e8133aa8e48a13b742ebd8a17d23111910a356b8a2051f857598ed22918d739edf3c7c03fd7e33a849b9e62b2d4869588037977ba97d31f2c86a3263c9a1498f57c483ec0d8d02661dddd8941d8a3604cc0b36c0b20b4cec5c3887ae80c3885cba9a0a0d71442e4ea88f5bc96ad320f4669258c6695657977e82cce5273b32c6cecee1cfc100689658affbadf6c5c4ef3526161c4a8998e170a5a7b92caa2018aac7675449a3ababca3636f6dab089f1d87200def2494188b21528b377e43e8793ba1183f4af9dcc0281e8a9bf1b386cec383e6880ced599d17af175eecd203a10c727bfe30df7909b5b36f91efd05f8e0d9e846d091129ab5204102b785e38cb2ea738b5fda622530bbec851fc659a3538840e37c40a180dad7bca3abc50e04fee8edc91c142210f6f872d62ab5182d909fafb92acf904f6d251eeae592b1509ddafc998b6cbfb93b99f1bcf87cfd55416e3c51141c59fa95336bd7f62dff0d3c70edd962bbff178c29b8ae55d507380d4d8848741bb7bf390d9e49128cf6e8fe760c3770368a7108c6f35bfc2a458b3b9a4961f2c1dff4d1a79d3aa111a87cde60c8e138eb90865f3ef096a27c7935c23bb431a650750b2e9fddf0f80661601260ae45273758ec1ab79bdaf6c86966478527ef0874a1ce7a376c00a7fd89b2cbb1ddef12f8c3391ba742eed344297922ba2e41af9c720f2c3d12cb8f6a7bc41dc5c21e570b3ab4fb36b1bdee2a158eea2a3eedca863f955288df3122dcb2214958b27c63b3fdeae72f2084e7b999b06154c01ad2937397dc08b0a067392913ef4db8fb84975695d9bd0bd935e6444957f7803da31325153f6a2a6475f97ce8b7e1d5624102eae4f2686bf0130937fe18af09c8205d6fd4a3aa893011171a55361bb6e10b8247fb704c42c9252894e917917c8c34b28e39371d7eb72745ecafdc1888f8727ecb3895301e457f1a74b77fe15ad458b85bf4498ccc002bc9471392b7a484465a8e17a4a52d74131fc0f54c7b902c1610f5d9ed5579e03815815b4e206d8e94e1b3b6c86ec85ccf14672d36b8b32c2cdd587e73df8afc4f0cfb0972b92fdfe72a872954e50c9e52a00f9939ba4f8af72f17a841047b162bfbc54e409f4da608c2237729a51529337f2e5d718bb9e210358cb8263e6bbd34ef63563855b22e4f9c81b232d6e8d0ac48912b07ca952a2aba9121f58f8e482c77f2031edeed986b40cc5fb8771d8f905740bb6aadc154e864882e3aa1ccf742dec8fde9908b97b223f44dd4e1449d83592371ba12381dacdc3689285bcba57ff0fe15ed8d56944d1980dcfa309cbe3a31b483e7688e98ec99450425f6df8d1d11665190d27a9694defd5748c0f38bfb0911a70bfdb6ee49bdd0506b8dcdbc07ca2ffd19e405161705d06d6bd215997b8b9ebbca33032c036af53a411f84635a2f40de8d9988e54738cbce6b79dcd71b154c4e75e75179ec132bd5a9eb03ec112a7caca94dcafa6847305864f5cd57b13ad553ae50961d2983f9be0683432d76435e45bb06503f83e12929665d090553cb1e7ff63e55d2a95d4393c8d13c8747fbbe037d545b1ac70581935615e6f39bdb53eab38b4e164e7781d42beba0ec9c50221e9e86ea69dd1020f84405243ed6303b7f60d7ee2b8487e70d68619e043693b3ddcf90918e0eb4ff49a63272df9837bc9177982a80648d586a5bf7829d81d49d84af3cf99e78027fe2398337cd968241d0dc08f031ef7d2ccfc25072852a38de50b78b674a838d314a98434d7844125c7488e81bd287a38656395a51b81ef7fd2e86ab681524c5786885e412c7513af0aefb585815613647ac08abd38729c9923bd1077e57e305a6e33900115486e66e7dbefcac08f297e90e5841e96cd372a4a5137384f9d949788942b0ca0b728c90071c8e2cba3c23181c606ba87c7444329f2dc367582c58a29037a28bd3f357b9cb44fe1714fb31d5b17c3b966904c385ed784798c6d423a115b6fd26e5b565b257efe0554a387195365a1a6e0e193f923285e782fa1ead87d2c81041beeddb427b10a031320b0b749ed12fe581246f3c40efc881a275bf031b11e8da1e3ffb5d7642c98cc3d3d80a6523d978ae99cf626ad5316fc78e395d4d82d0993c33b75ff52336e3c45d760af39921cfa3e56aa844f060d9fa122b6b8b565becdf950448fa173b5aeab75bac80e01d999bf6b97f440f52b78ea0d1203896529914feb01ee144506c7200d2956865a8d6bb90aa2bc45277ab52c2b356aeb06e2e278b61f66f3dba8594e39c3afce3be681a1f0b0df6319c95d8f047ced831f740c073c68295838de170164c040a1e3ea6d87ff5725fac2ca0cc2c2846f6ddad787a9b8d0df45cdc990c3eb49bc5a96df94c8c051119a51cd8b21ee3a02e0fd40bd9c8cb7025b4e1404e4350addb76bc1feb6c4870cd691d033adb2dfbfa4b323b1747d5b2e0b317341f958b3ee36cc481d4070ebda560c10acccc06167178be532ba6ace31555d5d6734f0ee125aadc5e830ffe1eb93a8fbbae23fa9607fcb3ebbddbbbbd5abe13eab11e8acc66464ee55184836448bbdf81c790bc22c929fbf9fb261017dd830ec4d10edde94d5bf7ac012ad29f035b7ce6c83a30db4e387605f130168b41efd9c29b6472b9774998b6db26b7dc5538e2ce2fb4ac934912ee14d594d79e5005967e06ce9fea598b419c65c8e18cb965e14bad00690ca86631d36070c17fcac95ca61a96b9e57a52c483deed2397a32477328d93776b87fd9830503b7a26a01809bcadb12b0152dcb01ecc25d399571a4f91f9e9bc00f1d90730b76d8e1327e08a98bbd66dbf4b53c08823e9c4b6735a1e880604c326d64b4814a0572ddba41fa47168d127607863661d169e6b9958d4e730995b16d24d9ed3d60759d68c37893535e10578e818ebdd1e66e31bf5c943783ec96399956dca38c525cb1e11b79a9313a66b72599ded5fa784f92c73635029b0b9541d97c1409d031f1e4ac833b82113cd66935a05892feecec0a4d500412be9d4c69c1724acb1acf80ce30632be71634579796413682212c85d5b1dec04b736c9074114f3db0a9272a1f3a368450528d50ae815cef87f5b2f6e69459d9702dfd2c1e4020142ea36b14ece4b842a1c882c830669d0318bdd87d725b7ce6ab9e49e261f5b97614c10fb444762dda2d201b840c8145760899e8ebd44f4bedf02f4eed581e0e5fedd24cc95cac58a76fb576ce117fc85557b9e66d88d905ba585c28a845f9cfd91fdbef151e58404a07537d23f0ee006b638825d701dba817e741ba60a191b4834c6f83a77c91b94775ed78919086a83c2780417d0cfbb6d786a8f78d22f23dd796a9dcfe503df3fe21884255616884a18126cbe8f1a3ee66669894a4891366baea1418a03a9b38169a7b842bfcd6d0800b6eb364a6ce75b49e9fdb8f1177478a89bb1dcb681f39534da8c86ececf3adb409c8d79b5332715a1e43ddf80de7a1f79ac1d8e1b826f67200efeebf35b5244953943ed500b03de0a07d92a45ea41f75a3e419395781ccf2bf244d9afd763cd379acc92a14f50ac75e1a36a65c0547f0bb2a03a4f1d0b4ae8561b63c1c64c78a1a212877456f4f840ba9af0baf10dbd6c6ec66490b0a3b8783eb5b1a5f474d996790d3b584a1be5bff04710c74b2df9d68749674645cfc7447d42eb77bb2942d2502ea47dfbcdd5d12f96bdd8a37484f18bac64b2c8839eae17a61eaa27b493a9b5db5afdadc1e7a8ed23981c8ac0026180ee35655390bfa582dc2239fa8457aa9add52f429a9fe3ef8b93e2fcfa255b7c1df034403468cfd7db3ba86ba5374450cd3d5dcc3daf1c1e7fe1080f2e1c92deaabcb9112ce82116b97a82473a3690a80fc0e509629af66d8013394c77fee1114426a4354204221850d6168934208a8912b0d580068ab23155e4f15db74613bf4ca7a11314de38e825dafbe8a2a55db5ebd8f2c6076f886955175f0c2efe9d75d4c676d3ccca766b07bea81ca7a35ecc468a929983c28e88b4dce4d1103141d324f983eeaf653129e9ae9a547e4d17e6c108caab4bb42e76c5d14def3f80359e58fa5b742988ce40e5345c25462683f021800a0ff0043575c0b5afb5553b03d74666b40db2b56502f14e8c0704a2497097324e6b3512c9687b4733137a42b6bfb7142444db2b239d1b30f5b75ab159c9e9f2dad86383d53cb21b5c37fadfd63493facd153df6c40990f2b9f9163991dcef76e259ff868f72ad50958da1560eb4c776940317322cf4f5948368b9d5c5ff2e71ae8f60eb8baadcb97128d08c3a7687ce97b8b06b4f31b49fac8e3dd84c0e2e48c7c2141a8b5bd04f216727ba6c9d58173a0868e6885a5ef40b35ecf519ff328b38d1d855621daa3dc9317a87865f85a385d1a683b9835e798534625b8791bd5972b5ac70c915fc3714d0a87122891d363b401f2e94d8cd54498d7696bf0e0b77da671b476b5df09f6b4042e4f753795f1442d10f9b62bc3e103507c4380367ddbdb76e68557ed918a14ab2e86e6df6e36f12c81a9546925533419d84e8c7e5d780eb4786c1da173a4c3ae32466648dc3a05f4d207f006cd9139b7294ef44077854f5023e96fc72b92a1caa1652c54912bf74c73bbe01f48fe7960da4a2a03cb71e1291c2caa75f784057fcd5aa1b8b620a3753d768dd7aa352e318577d3d681aaf43c35b91750d888ff9408324864e64909e7cf626c4232236ec6dc0532fad939c3ba5daa9b45b17a107ab651a6fbd1b308dddb95df2ba98c2549a71b4c312b58b7f85b18e2dac3c9315bd5b4f4f65e87c2389d12bf57d268716f216887d2ad5239bfb304ef073e00279cf6a53e57cb3ba950cc3588e48ae67f1212515b82f3e7ebbc6f6cd36cf6d1d6ae293325a932066b4b99f4ec4cad1e644172f005bbf82aafa71884f6b7f5383c64b2c6b40aff0b74cf34328e84044598759726ee6baa2ba847fa661360ff70dc128572a28b36e2899a4c5624226b7d84cf519f9fe7ab8d89bb18e9de685c39493d0d0e0b14841025c81ba65f0c0dd6ae4eac0c2f406770de95f215bf6f8a633af37b03c91b0bcc8bed8b3bd1ee30e750297022ad37abeead11402a999ee599cb74167a40e85451887a7a16230429fd7aa4834d0dbf2aa8b39a10a33914016354f239188b0676e781b4cf45723bff565592d5013ae1d4ed0e1034b2d0302cb759e59f28bcb9ddd4486974c28fffa18c67661ae998d25ac74667017b0977c7837c063a48b09c9c04a034b41413acdacbb1076f51c9abebde69bfe604c7fa75cd7f4fe341e40003bd585c34324162b4bf68bc096c1d59664a60032b09d7e974d296d8a5e5b83664d3d2717f6be3f84fabceca291bc84ed9e808609dac79248fe0d08c4f95d3c21f193da6df4264da70899cd965231ee3ea7c5ed8281fd6919e365eee094430d82c8af83282da63cdae06ef319d24349c99965589c7b22b36e57ec844082ec93483a49c860e102d9355a5a5eb49fccbece6a85da02f2e93f67772cbc0755d26c229b7cca990ae491de29e04b0f1970eeb94861f3c849b5d1b1d98ad43d74df603e246445ba8420b3c8bde4bcab392a4588600ef0f9f2a7568cb4be3e60685bb1796666538d9f8cdc98708e495ab14e40326ca1331cbe4dca3dedcd313ead488de577e476eea43bf7aad2c0287b795a08803c7afe33026a54134e77716ea8c62d272ffaf7027cee5801b6c2a2e10918e18c020d3122e13acbb693f459317b9180858d3fcd592d85ac22e8b38be8ef83319965dd53c6a4785927e862e4dfee8dcbb3e2a6cfa1cbc0872b79f54d91f205fed9e9502d9df573f2e9bdee991d2bac59fa395025f7224f291f797861b1e11b1bd56787fcd138c146c26e878da4a6c0f931b774315555e5b6bdcb1f3d96257affda49429bca0dff660f930a7306d2711169b5a45ba3676ac4741d5c823b78939f64a6cb13faebdac881f47057a3308437bdbca9e2bd6e14e57b026309c21ffc7d9c410ffe15f860818a08775139295b7162d755e8db117acc9cfee237d59a2ffb0e7da0f99112c0e4a92d407369f9ae43fb23145562c54f216bfb33805145cd65b30aaf42e998ab6ceaea1c1fa1af6607de31429d0d00fce6d49fc43d18f950771d574152c9e1220f58d2e64876f638a21b1bd42af5c203f2d33c08a4b044add068e9ee4d3b8165f7867100321798ce461a7d3ab2c96411b90eb274ae3b85781f8ff7a50795f286095b1669fdf563631f8167fe73461f94b12e256f58385da62ee1148a900fbc440eb12e4aa358f3a090a6a9d50af3a374ff1bce4b374324486306274b4f60b25087636f858c45778a2491def30c23063628cdcbd886fc991e44ebf80b17bced7c523ce69f8038bcff34adbb973907d535946f802689e99d42113337f225abf5468b67b44c8d0143d86d4ca3f47ca25f1c23b5c1202339594334358fa11504717143aa09ae0c2b6afd6f796aa531df0f5c3a6851f571e16869ea84f751efc2acd08246736a07e0c3b30f7fa53920c909424b2fde6dbd386560c34e9ba220c2ec8f969d07d5c8e34f46f6a2404fc21ac9e7927c32c4e9f4a617d0bdbdc2e7a62f8ab355c0180a1d35732c3e666957674000b7d35a420ba8da8d8a52c576473e928805371cd315d0662f839506df1a5418a05e898b14651cee0e2459aaffbfe8cd3788225526c86ee3d6005377238687a378c234f8a6b75fe51354d1074199155d970792678ed866726dd17056c4c34ecc1851f26fb20fae111dbfba6eb4aca9cde5792a95be493c36f9435ff9bbf516181b86bdd1c5b526dabff0ef95c5b3d000bfaad0b9b3db63237b8225a310b365905bd3ae750e9c5ae0048f52d379cb1bc7b7213ac3e532ae08f2780c22c10b0a2ee834cd73d6d62e660b18a102f5597525d03a39eb23524f20134edc008f2d8523a51c29aca417064f31b2b026d59d9b7c0915cb46ca27924fc7e1fa48b148f33c6012cf7f979a78ef01f71aa991eff8c72fbf5f8bbd301f6c5d203aea009e0b6fcd9125219f0b85d0fa51ef4b1cae141979b8caaa029a96c9644c95b306bfdcded92c83dbf9b4dd7029dfb9723af1e1bd7048b961000a6b473f9ed245a396623b6f04c1b8a34987ea0d275d8fa4b10daae123edc17e06b6e275ab766dfd249184446dbbe3bd18265cce9fd1c28bc31bcb5defaefce25aa9efaf1c4f8c38546654ee10e04b7b2f4ad7c24ebd73afa7937346bfcc22e621c536daa8815009e88f4250b28662b3f49bd195f62894b23a7b31c01fc13f8f9bd9edf5b00a31c784d7365f8b93368e511c0e5083eef030990bc807af0a3835cc533f5c947eaa5e4bb1a3bcc8f3fbbfd9e150d9994c5bcd009bf308afa5e2aaa025da3d2e7c7204e19506a68d4651e62d06d3f94e9720fbc647e07e54cae73da967ac0416e2734f76cf49fa685ea6f0c18ca8f95ba6be3adc9c82c2ca563e28c694264c38943b019a744f3bf8730144c556513b25579f570a34220b854d136f46462c4f34ffa9b4bb56c731ef72d29fe30787830892ecb5ad9edadc452062f0d3a2560f33fc64ed5eaffc0c8276be5cbff727f116dbc0a81b4a8c209e55972b259c80d2398fe68d667df0c209b25dd0cc300e0daa2c1d0031391956820d9488e6275afd68e394a34de7fabdb219916a6643380c5bc90f3e438393386a888e9eb27428725ae5299fff6a044c8b199c246e8c07837c0d4c78178b7c5a0f18b09e176c3b29e5127ca2233446c0a505a1ab40f3e4648402d0e2e46f2492f034175ea0d00795cfce96deb5d182ce2bce0006eeae621e1029575f21dd822d32f1836e93579c91459c17ddf39625a7afcb0fe08a3fdb7e2e4c78c76dc8582d131ffa38294f774b6d03e362e4e0f9679edb974adf13ea1a9c7724b9145c49ef5d13c97cc0496720eb4d91a0d260f7184813120fbf56602b2c2d392c21e6a57520055d74986088c07bcd47153e1ccf24dbf7d8d6757ba5fff0a9219d84887fc518eb88d8ff3ebd42bb8b09a44fcc4a865c28bbf3b28609f98acb5d3c4878d324fd9a28c740271a80948085e0c069218bd59a3bd4d98d3edc8e49dc4b7a812c959f11959f685f99dfe64234968f59986992c311bc676a810d76301532424d94a228e82eeeeae2c02911f26cb8a50cfe13abead9bf1e56e4c68ea2c439f1f48a5c4047dffa59afc5afa4e7e3d3ad521c43a8bff75bcf08fd29732c835a48bf14977ba60edf8a9695855ab035ef3e397ab8a0af513f08d6aa33f1022bee81579251d8b483b302161afada68599dcdffee102c5b29884e431fd4aa1488169c1671da200b5965a89c01c6ef6e360b7d8e85d1ae7342db09d10b313b44cfe78bc8f1e7c910c6290d3193eb98ac53d2a102d8a2e51b49378662dc821ba2b5463b8b88e199d30a52c09dd0df8306d0929dc8ffa7c0d312536d8ee894e8dc4e6f53864314513bed646e6fba65765a4e51159c4161ecebf7ed5678c77cb7032db22b4efb9f29bf9d3338c890f2ee8ae1cf1739c63ad9b4ddbc120191d2139d07c8baae89ab9555cd783047af66a253734a4f6d7f08336030a957a4bb8920951bee592a19e528d0d40535877cd9cfeac449039777163c27a2375d7de933d7f11753e2ec7c634799f730c81c29b8e6b66d72bac02fffcc02d5a5cb4cbb2b6ee6847824d87300f854c1b398f98a64d417f7d01ec06899a3a7233c4a3e0fdba4a40305236342a201a945f6a969fc835bb79ec7c87f3217770d7b1d530562b7987013e315a3c7074d317d3a1e876e9f1fa6ef78a2854b691f46c61e5ae07f7f90fb0e6b9230772090a19417eff1c5c71d0c19ec7f578ce139cfa25600485db4bd43014dcf0315ae387bcbdb4457bd8c8a5c441916a2961b29b7ee1a5784d012acbaef8795da854d4e117b3cb415d3b5b8ce5a9e714869870a0a058317baa0a2bdeca6eb573e4df7ed9b10518d1b36ac670a1d388c0e859cc33a3c3e5cbaf6df80d079e0b40f20ed16fc1a3f2938bb99a709714e5ac1644f8dd2a47ca2ebf3fa4d71380a2a266d4e80c0bcca5c9f21ca7bb889db373e3e81a3d6edabd884725ef7485c22a7607034759346c1c915bd2d22977bf2374e61f6a3e4e81029f9c5dc156713a61c0a80a67d9efc3611fe04c4cd2386b1210397e029eb6fcd65fdf08e70f4f853ec8ddc3c941129d87aa37072438f5e7f05e43a19ce88864cfb04c63167265904ca050fbb1c942a804b4f74c0ed025438f03d4aae4304e7eb783548fbc1801658fa78d30f55ca1a289e44c706f413dc3d0e7e0f6adb9526601853e07bafe139e087452f7138ae462a0e3835c98ff146b411bdb21948fcd391de20711247975928dc1f00a9f488388a4069d6f85acfa94f0c471df0ee44f4f92a04978565a3d20ce5931b96527674468b5dc27ea4f55d78e48d07f0cd92887a2b589b434e9340c2f4ed232aa55e4d4c74e1233583fb8212036092fd04be417e0274673c5200c6a097ac93eabba6320256ec934b5abb57c0b2bb09e362281121ef082cbef8b9f584a32c79a79041acda4bd5a27cb4bf846bba148002cdd0f1556415ac40cec28afb2aa59c3de41a2565695709294661d1ef75e3eadebd8a3dbc6b36896fb02591b070aa7177b8627a51f8eae93ad5382d0f6d9e9dc60d44f58a6926f4a17f313771215cfe10c1a425ff3aee91ce50690621e9e5e7335c57d9cc650250a5847a2efe7f863f96a5a3c7c6a6802b6238b9f8c67a7a3e02aaba11f3c9022b0c5a38353eca07176474ed8e942eca683f777a31bf93e560047b4c529d5146c6082be1cef27c5aa23dc701125119bd0557b2f970387015cd39da0b0638744e595c720c24548d314682862e3854e9f089869eb2a21dfa8a251257f2c80be44238aacc773724e5d0d6d035cb75a69d9f969f47feb13af8e41948902eb8f7b3864e4142cd19852de2fcbf80159789f4e989e965f1f418f93a5eb94eb5ccce467de04750d26b2da412d055f56d639f0b7fdbae615575f0b6f617d15067856e1fdcb803768b0fda767afa9ef40d85e10fa83564b91a71c821f24d1a047b58da98f7fd2e42e968764a2efc1f694b29041481d520543aea8a8fc7e53fe0ac022e30d0c66697a66e983da815d62d3bf640ed006ee00b06cd527bbb137972bf6c32451204256c685a58bd6479ff2211172d22f27dca3108f3dedc5c318cbabe2b1cc5c649d73632f34b185bc597d90e8fb29e4d0a3ddffb3fef869de60d6018f0ab90ad323c3194ca5ee789c541f2650f5d1ea5e2e528000f3ec546311e42ac56abf1cf780f17425294bd07b568a892e462f752e273c4e86dff1f49cbc2d46eccfc6e669dacd00febc3488379b5f6d768d73e140d6b5b2ee62012042012fae9939ac6fed5cbbb38e6cbb07055f863efe7790ccf0dbee4807081b30fb537d9ccdfa73bea5c935daa483d223b22df769530f5b1e301e8d3d98582c2470c7b0901795bac9c9882d6453e08df6e4b39e27a8268710f0c1fcb6f66331c845e7435573c83c252ce110ca4a04926436a9f1dd5d7e2500d7ec9dd2908e9b189d71569cbde76c11773fefcec0869c49f280f352ef7bf7229e60a825505ce6c81aad93fd4853443d6799df65ceae4355480639a4c5adc8fcf32571fd42e63354c4ae73621c66862143c11f252a4e443e0ea1c61ac2794581b6c3bb35670456296da12393e97f508224a771d40cbd4c2dd21ab3bcfbdab06aed687528a767f43ad60bc3f585a693dd89606d250264b1cf2a84fc2c40e8bd64e475734bfd0c1e8f21af8074f7e29fff51d81992cf50a9d96d9b8b9366ae5f8c56252fbcf3609116e7500998bfea194a4ed6759928441ea19ccbdcc8896defd5a75a9c828da6dfd00552cb5f50e22553db7040e34c4956564dc2797b09d5954f1e38263dad73ea40e7d40177cc04ff28b15337585c20621a3d8f8cac990260db1a350481c683094d690ffcb1e0c8a0d0701e4c33712b195c24b9f6dc1f580bdfe8e213a5b5c54a5a7eaff12c46e6c9528c7cf23918e3aa807ded07621f37cb3bf9c78d9d6e0e5d3ad29b8ef306c69dac76975b071b82db2fd23194a487ec314780736221ef43f948ad8fe102e94b004d82db46490ec816cf5c93168746f09df7da5a751dd10327e53cc1cad963387e8e2b3f0320dd1793c6c1b239886bb4633c2dcee3f8e2ff97b30ec077bedf9856a595d27439abc5f05344d71b23e81b5e60d03cec950da7ed5aad181369500a8ab9d8f6a215bfc0a2733714154273a57e9dd55f891ba053a9f62abce55348e2155aac35648944b292ef777f7dffc21a6a70dbfafbfe0ab63e7452a69d4bffbb27e4998465b49fdf613347ad5c69d65ea7796d9f948a82f1de76fd8c815321272669de25c498a284f8ff417e9ddddfe2140b01e5c84c1677d8a060de0ef415ed06d506ce2e599d3ce3ea91a1c1fc732342066af73d2a71988e11cae2dd799ea2653648e4bfecbef896ff72c9f1afa48743791250c550f74e2ebaa31124ba9d2a6469c7bead1ca067f0356840a3651af857be5d2cdb6af0f972990dffffe84cb6b6773b93edf005596160eef09a77a3ffc2318e4268029f00e5a05116cbb2090be8c096348b8b9ea6ac1ae20575e0089b17a0a4e0f5933f1913bd81e43cd3819d4fe411a9ad7df51fe917e90e64c3b37fbabee7c18e5edb110c37b7393653c119dfc840528e79d8780bd360800932f52b10bc898cae176bcb2e00ae2a6ddf58dcc9141d62b1609d833c418658cf46a9f97c055ffb7c9ca446bb9aaf1692824dd6c117fa6f9023a479079ae85f8519ef27c72fd4cfaaecb68301eba4e9d120dffdd6c3fb94a80d734a81f1e4e188b5ce114682fc9bae222700d79144bccbda97e81d96abf339f56d8fa482d526e3b9be3487a74808ec87013595ee44082e7ea1c145705d03f209bd9a0e3eef6a9cc68afdae9e9870f376269275102de543e97dbf140f05de1140020938a91796367c2523152279a7ffbd5a61e2eb11ed47daaed2f1ad34a26d7d59891716fc3c559a336a27f9500a8a587c0905661521b061c9a97b9d4c66a4a3d8eabd41089b4272e91c0837529d91b2de9275b86fd7ec9e652168f91fd5228f0640cfe21ceb9bdac9272fd8b0e0fbea1be66680b07d673a537167d97723d4488ed25ac8a9d267d4a5fc71250621d432779eec80156201c43282f9cd3e778bfa437ba779024891dada9b2c051377b330cb41d1b7f17a1c074541b39eaed1fae1cfc7f1b5e9b0ad132d5b7014b24ea237cbb66d394ed6786359e06c2ecb2b47951e584a4a37e3c399fb58cd047a91afb7677e39076692db99c7f6a826d7139ba9bf16ae23c84ad909655b7753ed535f45ad89859e2e245934fd006033a786e0641de1d50210d3f2e102e416e4a4e3ea81a1bb1a5e0ecb2c59adf6c979336450bd1a87b5cf609056e0e02c459d5a43c228b90c90456599da32dbdab2e0f4ab9c0adb1df90586f0f7233e526fb38dadcb35691a04bffb1008d541f39f9d886fc69e11edfab9fc7d8ffcc9c1c40cd8adc78fb5a3e6de872ca458aa49daacd20fca21f286c79e5eb338303558ffce5c017c4fdebde066153342c65044e3bcc56e567b127b7b9b6a95b406fcd99f13b97a53b159c177b7f0bea1a4a1979c9c1827f434fc0646329d45cedd21cc5cb88640edc0ce2299f99e16a7bf169002da66b5b587f9814e9b969978ce57fc0425dfae395e2150e6c814442b042ca388d39252c89e6b8a1f53e088fc220eb76d2a4a4019b59d6b3368a89ebc01e7c968a60682002e4f1eb7a83d66875cd97549dc20cb064f158f46ca781ae0aeb73e764305d346c39700801326778722523b1870f9f06e6db2bf4363effdb644833705ef376d61aa1dd344e770e2131192adde5ecbdb150c89390b180d609469445ee3ec56265a75d9544bb0d2d7ee3604a8272a0c944b2eb6ff37eef5a6e3673736a74bf2d2ad35c9406804ef3afc75c7539ae3420389bc52de669901d529cc0509bf1b2e2ac78e2abd3ef274233660b0ed2ad7b3786f0e4db0a615c74b7ea4eaefeb69671d36df93ee78de96949d8764b2aaaa0510a923d1faeb3b58d0ebb1a0f2c03f65284db9c2328dc8286d9dfa208fa2832517f8e9962ddaaedd85f4940685d6fd8aa4cacbf5a66694ce0505d56e37e5f21fa991c233704ae02fcda43d0fac9c32aaa6c9859f4adeb1b657e26ceebac58e7c06dca6e23f0d124b08463afc018f2139a8939b14644db3820c12408e2fe5199d56f2285ccd01066b31532bd17a0a7e52de371330a65a5394b48786bede295ae5d827b675f4d9526e6e899343fa58a01b37c4523375ef5d29a6178da0602b95d034e6beef3a2ccbd0e54597bf598b45c32304f5fdea517d0d7ff822e0c33bc2cf78b5bd5746608d72783c2f55b44d686c6ce40832196c087789000db608f7a0e8bbad6315acbb46756aedef79aa5b5e58e25a0f8d471b82e04eabc3fc0c8a328ee8564ec2aca76e7a8b368f8c9dcd7e2dc6a17b8a43350d0b0ee17279bee8c5690d33db87ebf2180c5f2068ab6550e534aa5b37ee9e330cbca0f626885a32571189f9c0d9f53581d3eaa5d1701e1ded47e323a30d4c979a4d07ed81598fc70e1d7c5d9d41a4cb1049494915f45ada7907d7ff4d0f5d0e0835709073612bc0620d47848733f40eedbe2c5a2ce6e0c8f4d8d2278c1fc980dcb9ffb83981ab488cfb03d6b52e59664a3de8f1807b992f9341900ca1c8774184d5da196e0caea0eee134cdd5574ca077aeac0ab2e5206d2eeda57d316f743226833d74fcfcc2fd19a282eb9ccf48c914ccc3c4f2c710e3c0a68cea080008e7aa5a81329b8efc78f61f398889cba4ecc77f9109506e1a658331b585ca97f862a4247f6be4bc6656bdad9c785ab5b295b60aa32664427a65208d6f6a4bd1be548985d524bf736d54ad6897307e60bcdf0af28935f079d15e3f07ebdcf29a418c27b4fa4349ba0766e7d54e840d6b70dac6b7c56329ef9f2aab6eb26333bdfbef4733dc2c26a14b2c4893a29fb4969f2fbe64c2560f550e8bf1a675b8c6084928e9fc33c56247987f6678ebdb9e879092ca4a7728e7af9be8a148d3143d77aecc7c8c8cee867754e848bc152ea5752e072d31498a667197c30ac5003ef458b69b5f12457672f993b7c0ac830efd1e61bb77a2b64de2cb8ea927bbe8aad156f34e8d159ee3475a55cc693131ef4779a23f9785d00945b40abe91b2a94331397844da7b40576844cd368149719e9d950c2dbd2844cd7f47bda34d6604c12e5c7a8b79086f5f335958527e5db68f75dee4e7f93c53aa7811020f8f5077eb04948aae7c8225ec29cb52b87e5297986cfbfaecde73a6b69e3b07cef2feb0c82835b59442b78128ee8cd77c5821933119ac06f0e37fcd53301b50a67cdc65a383a2c2860699bb8654387c63d4698b1c14f573a973ba54ae0b6a505eb6071024ce0c5cad97f2837ec3d9be4fc13fbfc45e3baf3e271ecc48f65d35219be3e73cb0874ae37f2520cca9b9b19a674790a02f0bf7bc023507634077340f46800fbf8be4577f5de8e27b15886209f79468a1e61e806fac4906a3c682cbb1bfa36f538c461fc34b3ae86ca1b9e72b1c3bbed9ecaf4b5cd46e309a611f4b2c8b60d6434b7782ce373ee83da7b6312397037525753ee8513f841de821af08bbbf4e4fc7544f74a1de8f2378085f180ff0a676bdb3a4c349528fa00d6354508fe746f2f9420694d245a1b0db147e65258ac9f6b6d3adc1acfc74df7669994056c72a157ffa2ac9734101429d7797e91e0bcb3bf3826c4695b7e603473b423ec1c44e018870bca1a08316ce6f773b49f2fff773ec25edc7906d6e0e5787a279137eb5b39ffd09e669fc2790de316b19a6e45a4d7363266da7829c621d777bcd5abacf49ef769ec98f5494b82a871ab642109d20af32046fe6913cd9c06e12905f6ca6cc4775ea4cf5f3c61ed1b71eeb78d4aeefd72ec3497cae438b763050273bd53eeaff067b1c1493e860ae5ea51e7512be3aa7a37436bfef967b1e76c0628e03019a58d86435d691b7c78e2043ef3876ef13bfe8dc227476770b757f039b15ac078da6d32a784936172711b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
