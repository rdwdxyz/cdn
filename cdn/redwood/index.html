<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d6f8e37e87c6163540d1088421043747a3e9cedd97fc064a743c19d316d130d4716c8144028ef20fd7ec4e64f0bac74a1b3c2c21a6bdef33660c379fad0a3dd2c1c45c19ef908bf58bca09f0ee7b285f00cfea2df4caf6e95fcbe643566b516fe9706fc7df407a765e36ef65b37a5c17337f10296486c0fbb30e0e34f18104a0aa7f5bfbe7d46f1858ecc28c5f213b563832bae6f96621d16677b4806b6d573f1e1bb3b8ff716442b1c031797e7aaa0d16044c3d36868b9f07a459514a8af15d33df5499741b4f20d24d5b983250d73b11bdca01c99a6b3ead97528c4c609306cc81a6d8376721e8d3fe00632b78fe157f7eb9d270482c0e58d51c1b192d53fe5efbc18142bf36dc3610c367702fdfb51ca5dff09b1ffeeaac062ebeee4da67fdb70d01107ad4364de3862c3edeba7acb90d73d430ccfa0443360a73e85968259c7a5c89237957055b6a76ce37b77429a0412ebc61131c30369ea47e979add743dbaff5a8d2c188c61d7c1d3f8a8b8946d54f183410cffd1e0dcaba0468eb21f9d9586fdceaef1881bfa3f35021197cf5d3e25866a798fe737afda127e16310065bbc2990d2d52b83f0549a1ecefab61a5636f59b78c28f36969a8f01c68cad789a7259152a1ffa4b02b100041bd6ea01682e929b7dc12f5ac36902cbf8a1b475b6e315222eae62783a1754b89245f1555f7b7b711d0b0fab92675502c61ede25a501bd8624ae705455b24da2b7a2178a95ca6b62d4e8c5a42b4dc39e3b8792d68127340b1beaf5f657c67ec0aa9e152ede5ab27a3593a9ed7aefd6d5c189929f598a1bc9ce6e36d40d7e5925f5ff756289b34418d8b7ff62e9cb9319a89311440cf2c8bb9c89b73667bc251a9a2533d09d22222074728ce9072442b25699bb15c8cb83a3e00f2685d76dc618c878eaef65896df982615de8bee7674795850cb376878342c63d197a561db76afebac4e70a1c2b26b2e2c8d07ae93d2308220f8465f8c14b49c42bf3b057a9ea21e0d15e80086d6abadd6593c2242b6fd9cc6ccd2d5cf8dc54cb6b58036a9204feae4e34bceee77c9d9fe30c8bcd8f83a62ceb1f46f0711bd695363356bd5f047c5eb27683c4e2aecf513cfee2149302eb458460424683a485f6d783fec5ada75cfee1810813859fb5bfa92e8e46bfd608a0a938a0a2ad2d3c86703c09af3b126700c37f8d086843657be68406432177ea11d02f36cd2c78b9b17b56624131bbb7410f2085fc2e0de362325f444203ffee02933be4a448eb1ca50d57c69ed5a03ee65fac443e34ec1dda8fea94f9c45a66141a949c68f63a7032ea7ee0e09256abb0f1e7e010cfb6cc6c027df7e5fa0e15e53131b2fd610426a1afad8ca6fae702e8be9ed005b458202042e08dcc39517636cd50c7a811982e55edada0989b6809d6a848fbf142f30b92ed4c57b9d1e5fad49582cea4eba5f5a0f2ae19fe773a7d7833c412f68b2007b5ba221a424f9d221a2b27cc7e84fc7be62e03d6beda3ce68636cf3c0c96c377bdfbe87cec78484c93ffa51e4697ae54dcb8c4b9521ddfb1519537d16d75cd3b4da9f5e87fe641139a31348e9849c372954f1f77384b15861cd1e7ce3aca34d2552bfdd7e1dfaf44cf65db3c64ba7fe4135816ca11ed883a1d432e7f3329052998a1e2754406dae9860108f67b5fe3308cee1e46f8263230399e03c36823303cc85b9b73815ab47b4e32cb690adfd4e3051f47830876127b88e14daeb6cc1c7a12ff5e8ede55115e36357ff67ae2464e59492256deb15d82b1a73328d2498a1fbb520bfe627d2781a76d3e37109676e55387f69b682b11d66084de736b87fcfdbfe64cbcb6461c80c868d3df8138ac7df15d8e79774eb5c87862bd78d69eeb73a9490d403a3164ec9e36591afbd87c33f38a98b1d849a2b6277cfa249ded6c19c521914761bf35bdd2e1d58b4d5e19c837580c3dd9a98c76f84175761973972323b017db0dc8ae88d3874851ef8c389944b471a19eda1efe95caa5c8f3bc6fa3194607dcf3c68dba37efc2b7ead5e6060185f9cbe0864b6bbb64d61b23a4c87c56a6d2e7c20a8a2b6f6867f7972821c8476ad630e9d4b5593d89a7d948e99ad617f620f6e6188b82ccf628e429280c9cf8b1c707211ef1826d57339e5a755bc5b080d449ca9fcceac6ab39922e0401253dfa3613d757c45b7ed1ab70751d46c3008f32c98c8f5d3b3160a2b87ef06941f9a24919343d61395ba43a45db7c134cff3495f0b525d1c54cd405a3cf7d6569d1a4b017345d1a9ea3733fc3d534a27c4b9c6a239dc3723fd4b12d48c5c6721d6987673707305d5cb41a511fd2413c769e219e6aac56f92c54f884950dec566f6b00f7597f77ee633d9a0a8f7c8d014aa170a4e7a5704998a0b85f1d8b8d4b7190a21a55133b21068c4d02be1df5d71c97d03a8c9dc56f8c4f22a43a6e1592471dff7274d92a94918f4d35ec5490e07777eee11b7e38f3d5244c135342e5de72c9cbbf25a7f679d8ee536aa763310fa03ba09d05224eb19a0891695eeaa40815a3e9f65e4e5ba94f9381aea7a411f76ec606821a92092c2cc3825eefe7ed69d192f25529d2a8a896a6c6d2a6c46d26b2854f83478b6f2363e566129cfdd1bd14424d0364c7b78e2606ebb9608dbe6969a3d7ace0ff64261aa7788e7f689d3c22a912b8fd91461217a00cd4a8074f2e08ae3a72162130bdf4c8a5d1d6980a6ee84f76d1023147f52463781d4a6021e750826dec9266b41375c4b05d70d8ad531298199b44914844c5b0d91478610ed85a04988a480cdfc758c8e4979833ae50555576a07b342cab1d47cad27043509e96c6b8c08c260ef430681c5e4d7943db057efb39b975b31dc80665ee2ac35a69cc9977b9ca7e7befd243311466a8e613ad0c6a2c80f4ffd170ddafd558d3ccd11506d017ac6812856619fa75f5b36e51684ade61ac60632ec8082382b531de7255dbd9aae1dbbe3c1b6f9c4bc51cf25f0ff45caf464c347df6c47b4dc18a67ea4d1b061b97c501ef864418d2b366f0899809ebfdd31e661bbe975db19c198a466aad6e2c573117bd207d9995e5d9c87756a81772b0a6e2245702f6e2127a67f55a94af8a14fd3264ec88621b2fe3f5ed7210ed1cafe10d248a84be4b8c03a0a479faac3db6d4acb3c486aef4e10f9d5553d8f07ce47d3b437c508c3b9f462d2ad57a93ae0b62124281a12b4454460d4737884bbca57c49e3e232f7277b8ee1b1077f289c63510010b75de355d0c4da969f0cc71dcb38dd8f6cc1fc2b14d52df3d2f198509e05536e505d03bcba48b22e6633e629614aabea5920047668e5690f178fa5f8e9c0c2889f974ba7a4064c59b83d54aaa1dcb04e52cd45f0d3bcd029779e22ef49fc0041a27eecf5b0b62ba0e083694fcdcfe700e0b9076a9008cc851b63dc164f8139ef20c9190a247d723d4f9de476a13075ec99cef89459f6590ace27bf95e61b1ac6c1030d0ebb3dcf0754927a459f08db0e308de7b362aaf93f01cbc6ebaff99eb34bbdf4cd72a62356111a731cfc1d49bdaf04f9a2118d36dab71ddae011b04e0f9dc213e51c7a9350edd9cb74f14cfcf223b77e35649ad2f406867c3690afa8470bfb34126e5f5507667c08e9a627b1ecd100dd120fd4518c5d628475f13215b291c38a9990e017edb8a348262d47d202736f86ce3261bec0a3fdc0bb1e7a0b9d5ee2c85c4240e75ff1079b68c021bf515582f0e53cded02134a54824c86393591543a47b3db0243c2852e22611110160553a280b6a3f954d7bc936a36cda4d2439aeca151f3cc96786f3df102c04b52904caf6bb4a1e28a0097440a8fe23b605b2ad13e0a9cd111e3ba7176c9b56c0e8272fddd90195c3b34391cb0536559d240a85dc69583792ec0b63aa223ad40d75e6f6d0cc92ad73524ee2047e373844342e57df59647bb3d573c36d7394f908089b38c31b98d76e49b5b6bc00579f442e7697c401944df72f05d4699bfab2a435cb6706ab55e78d7d94c3ed763222d657049c693ab251228c8548c53c27b00d9b57334b391a53b97807e071f59762df169053227f359f6d373bdcc34588ce12fecdb42c29c4e48f1fa799271ffe5966d5ead3451b26469ddf3384a4394a66b3b97966598e67917c7b8721d93edda343358453a08f5b2586037d8d18f668c7e372dcf660206e00c6405e590ad06a5b1166e14d46a6c6c31811eeef9cfbf6c3703170f24db20094f40f345f8aa699fca24a68a8f73132d249b20a7eb7d9c45c5026de4925f8c415e70b58e97f55de6ab5bdd7a7b74da38416fcd79ac3d9600e14153355e2ffe49c81e490996d199b98b466713056dcb187041c508ccef26642ca4ae2729fa5e92ff5e5231d720dbd8734e8a397efb7b93dec558aacaa9ffa064ec30e1c1c304c182b0df81edc3c05991f6f3b1337f9567b43065182c20cb99843586b3553711f6a2a8f0901251f8c26d460881b39d4e0465304e059f61d2bfe1393c14660857c5d6b62b39b7dec8138c789edf8d6c0f3c027df4e1603d682f75a4b7b7d81126e7f3679e025a8945ed77137c8fb1b8a5b81c26cadaea99625eecd14f78d92b9034fffe1a981c2aefd9aa043b353c267cd6bc654cfe3f14ca86329dbc15d192797b4bbbd36ee88cda45a56b40d21f887d0810fb63db99890da0301441b381d3e056db745f863d818185d4518f47498310c58982ceb97d238b241d83b2cabd2384673acb8a03d7b8bd8cee1a84851a6047a27e616a6447cd694f2dc7f22457df97a41c91b52033919d6cec58e550848a3d88ccd0ceb18702abf01c89078d1c38b5610f3d9bb2aedb239423ae2cd648a85a9ab5e773d1541d0b63dc866df14b5d134a381812b2857b828f012f89dec32eb99ab24a86739847b432d7bbe8986634078d8a13ec51a870c1449bf010f58a3f65773427f7d866b251539331b19f1d3eba668bf1f792deea99ebb2c40eb079201970e0b8fb185cec481c624aade0a3887474734d898c0fc0f7bce034166edc05ec765a9fc82848d83f423830ec81f066816200bee5c56452a83aad4a32b8f631a7e6fc10b16793f76af00110a9cb2389b345b397d5b5a1f51c3d172ef7caad958adb71aa2b2cf367bf3e907432d0ca996a0e2dc882c43395de9676c98a16d22b554e0c0c3e0e872cc561c5617f59cb32452bc61acc9a49b283b620cd7e8846c3dc59c9da2b7fdff7e758ff5c40e362a40ce58916457d8ab5aaa62af05afd56a0ec75f966ec1f3a4a73c4f99fd95369de9766ddf9112c5b9d46702432aacd654d505ce02d2acdce9c203fd6519b27a8f40944c0bac45b8750029ea708cb9ad8625be249a174bd7cf1e009f86c3dd92269a788b13885e611b837c622d308ea71582d213edd3c60ce3ba9d2c7d6937347f55a87ca699605592bde345799b461982228bf352451ba8bcadb1eafc2e86c06d4870e724951a5334d5257fc45c5c7b928435f3680e5afde339027e3ee27f4ae641f84441b76247464b843a4d076027d6d10b6fee2c62f6251b358745e0ee88c42e234a21da300c79ffec9b0768fc9a863c06dc975c227b43e3c2d11129910f4cd3063b64bd6b32a21ccb72f555aee4945d1672d4cc240b545de10a918866fdd7b9fce407d4f8f24819f405a9a225d924751072f5681d8dce9d4365f30885377ed8c3efe897fa470466d85c32f6c40bc73b6eae591eb3dc892e22e96dc0aa135f3d1de62a49d38d5d633e7bdc669b8019ae38c6587303898a7be80d314b0c4e8f72fdff2150a10592ba4d884fe308e87c640247f04a0e3b8f0b39af97979600f9350c17530f6a7c007299e67a1de73d88f824ec07e573181a3c22655cebb98b9b0ac1022814e584c1f4c58f0af7e413cf32da3141e4e6957b44305f428ee4fbe92c80abfba400c43735c34fee324f1a88d653078e0c9db2e334c5674cd88f3cf412c8cc65825133ff4d76a550f5a80d76c1dc88a2f2523efe8a3d8abe99a03f1e89f0244716aec29e012e52c6d813123f9084ec33e87b000fe74bfe411a744484b6878585037c2170aeb4ab29874874c591c796ad1b5afc2c836ef80c010bef3210a5f37dc71357df22e1ea30a345ff289e984fef9b90e01d607f7dc893154c03a45929c1e81ad136196e1ab635c21ab46227e731dd2e7b28c899fd160e7bcd1113a922648c7679dcbe8365183f991e448418ab89eddb3d5b88c7f94132c9f9e1ab57b2cf68272e496ebe881be263d711f7fd392085c7c93432c2312e793e26d9af545ff298c186e55b9082da8ac05355778ec4f0fe824d241455564397871f999e3e6c39a73406a72c599d26db44dcc637cfbcff6c184de79fb982823cfc2a8de41f5b2fe4cc7551892be286ad6811857e61dd6fc02e534d806e930fde895aecd5186473993dd3be0e9bb2b1746d80b129e0a2ccb01bc9762de9ef627a66bfb3a9572c45697226b58a1fa89bc12d22bfa296c5ebba4c889b2bdd2b4854023112a86b4cc1be10de937dd049a905b6543a07bdb8ddcdfb84cad175dc625755180d817934128bf482b4d3f69ef5f839be73ca212682cfb400c7b4fa750e329461c42c0665feb70fe52ea5697dfb55c94a1bf7b8cdada226c6aff2a00af8b42fd89bef8fc5340f414d792916290326ea9567398644c7ad2398ba9826301c59b8c671144bcf681495edbaefcbee09992131d1fa6372a100dd3e8b81c79e371e2157a046ed4dbf56f0281780d4ddad15e9d1b0f83d276d368208d6e79753626d80fb6cd27cbcf53f6f649395a1d736f773f2bf190a34ec9ce9b3991823d0d1296ede1d387893b231ddaa67360aea1188174d0353191388669c0e0ef8ed19c8454e7827d6536ce741ac8cd4563461195cd67df26fbaef8cb7947ba7aa4deee7620e14dd9af8e714e25ba95dce116b24fe7ba27919c5cc26bbb12d7f6ad657f621160dec837a2a502d7d73a837178913e9ad31345a258f4962d1dbb6ffecea27b5c0d357e735f72c9ebdfaa771d0fbb572205f0404da2893c9d711da6a2ca971cc81c2077fca686c0e1a7e461fa33087089073e2e3d1ef3740498ada835d064db4976385de95178a7c4fee2287b8be07ecbde4d5dd2329b6cb42f31b0eefc266a78020e70f9c309439c9847e1e7fa8cb87b5fd9ac7e9f01cace0762c67ac404bf5d266fc19776fe0cf04b365b407c69e5559174bf55fad16db3db635218f12242dbce2d8c01eae0bb22d597631127983dd24ce8dd3e76558fc42cf88e69d6dccd22d0741c9bef5d216c5feffa559d2cdb4ed360b2135e673961c93007f4620e15874c263b2af3986065e52ae16671bd3ea3704cae3f4b19d054c80f60d6544986bd7f0135cc76058abe1622b7fd3ea6a74ab6d58aa1031057b2e282f95b576a48cce599bef2a24a05944db805b98c578066cca332c9b8421bae30c2ff193ac7f0fb20bb4f6756ddf9648e67178f5f3fba2cdf38d49d26bb08e4a11134fcc8167f8c97cf610fd7357917dfc83d9a7972a272b90172cc55d2b19e234e3066af362c8b3610f6bd235984c0f1e595a8483b79bf5b31f7925eb4ec857209493f952599740091f42a2c87fabd2f9d39adead8bb3964e8db9487d7818b4f4737bb17d5c2ada3fa80dd8d93f47542217980d0f74009d09c18e48ed47eea20dacd2af2a69b7d894bdff16cf18b7673f305c4fc4c9e4a531f4129ecf3325a5731e1593eb863bae94315183ff382726888bca608589b9731aa02ef55dac8ea914e12d07949d812bfb917686ef80d01dac46868899f8983d3813f325d650d14884e2332d7667ab64d97494f07c81f427b62d365238e312f772c95e41b5d06a59ab44963dd3779c8ea8b2a3cf6cc1969449af53cb088cba75e06e13c95645f25fb87d8dff493f75b59e55c8e10e2482ecf673cd8bc2a7eb0664b4b4f89545398715461ff2e2d7869cf7a7f6456ab0742d54f56c699ce7519344805a82fe09b739d21026bf8ae08cf63b8999d01a45e41abb8be4033ce9fd69882f7cf4750a2df983e7662347879fc37fd6c9bf20564cb26fa651b82383dc84fdbc7817d193094e7bbe0e3f7241b0b3846a0b65317d5bd601d9944cf41bd1a3d5eca8bca336e19d94512fe057cec2e6ba43b61bad654e3020c16923c8db0042cf022834394e1a8842fce76aaebe42b5989c783ddd37dc4c5f2b32f2d26f5af902499273aaf7a3137dd1bf4b948f5332bcb08f01a9b0fa371d865d50b4d8cc578f44deca6c2d50e055a2231c1fc9bc0b48532d8d0c50d7fce55e6ec53288616e8bcf441767f341ae7211b777795beee71e962b24ee38e5f5214b5d191b283e74fa0afb73305dc942198cca120628601944788e06c80bf0b2ea43fc3c0e9993e1b761c27a9fa67a57360e94eccdd82af6cdfceb94dbfd5748d72d03cdd186ebf12bdd30e0bdd54c166dd261dbe141335cf5bff50f6db8d87ee37a7580401bdfaa1561a5bf4b87c7ae0fa149ed0f3d642bc0db6bacf0a52b44a1e4eed72cb1d9f5d34260660e5d5211cc53d611e23142a567c230aa245e3daba7bf881a4007e5e19ed28347d0e8351b6196b313ba634f6c12db0a1ccd78d929f769146d4d264d5495de9089ec9899100dd702fd602265dc52253179d715840c4a02fc6d8168f1412fe85de176bc2a96acafc31c1c3d67860cdc8eb38a7590f5afbbc98568c5e06292a124b4b4ea5fd17043bc083ee0f56d4dcc5ea4f0cb534bbdb1e31f7393b105b5891d1ea18040ee8b93436b3980e3fdca21f999c345d085be150a19964ff2e9e2f2bf2ab2aa4d772e200a40bd168d0f38bac03cb6042d8a939e6ae9f1916405ed77abd6edff4bdaa1fdf8cf4ac372c9ef3bf6d2f1875e898920bf4a3d6e98cce9683c6ce69166d79faa7a7c6cbfccd33cf5ff56439a1592293f3ac0c35410d76eb1c1a776840703604291160b1bbd2820c81cac946e7b140fc415a6b53bb93ea6f5c3a6e83495e9cd8d391d87894707bfc067b70a1dd6e4881b0743ceee930976c3eb413b45cc15f8e3993df4aec4b954cab40af57d0f3c963ad2e1570c0db1dc43abf02dd9ba8b5d141b7b6a7d7fae0e1160ef58e5cef9b408ed360c7a89d34a0721e856d284e4288cb0c3a1c7c5d3fa04e73e48d41cf435b4f8e5f4aef014ac60b62ad3e0fdd0953ca7ad07fc3c91bd0df2b54a5b6698694582ef11847e11d5fcd8cd16355cd07ed9ac2b263003a04c7fb55c0c92212c38df0a3e3d1cbc327d9d099814039837f00ec45bbb76781b132d303f8542ee55f7d87ace9aa36d0f4a7353db89bff3e7ceed024d8f3df1d30f289396cb1f761408196ccfb601bbe32d8463fa5160122ffef33ca11196ea762e10c073b9185582058dee7a049e709cb6dfad816e239ef80aefbe5c3953b3b2156bbc851bf4f8de6d4e2605567943c53c192b50a2948d524f91b67c422ab092e92de00548c5acd6e9b0d54b81d4db2d28a07a9491926cee83803c4c24a9483d1fb7c4312d6f41106b5f0395d98c982c2ebc13b1a4c9ba81302d7c1c167978edd55b3642bfe2bb96764655b79b923d84c3e07c6b90cb380402e9605cebf098a3ea0eaa97e8681f3f62cce52a15ff3fbfd01b3bdfef2f110e77dc480ea00987ce33b2fc8e6146ea8100aeec98bbb131945159db10806785372dbae85176b591c065972cc27fee3fa14cde3a2535777ed0f7fd056ddf514bf6d233a074e2f3c12bc91fe4af65c6bc3e83c4b47dd3e22fab456f6694244b0fa428c2b9e175fa41e2f5f3617f8ed573ce70024dfa5963758d5718f43f7138dabd03a7df60c4b6f14e5b079fc9c40e2cbaba105e92e8b4c09b7fe5bf2198873005d9930bc537cd9a86683de8664af85ccb6877164ba3d268d54e810b06c163295bc55991a2b853c6ed7e64b698fe6ade00def88828125e25ebb0bc17c5e34b773c0b47a36aa2f4b6f3bdabe3d5b6ae5f99d92dababbe640e19e2ebf20e2f3d30ce01c4358f5b0f16b3fa747bfa8fe28446cf52619e074fe601a5fbb777871356382d6cf3a2ac76761da1e1b00a845d6e935d638154ac33dd7318efc05f0fa5f902215fb6a3975f7b1656630d2568de17707beacbf0957f8d46a9251cda04b326dbf9a723cb83e7dd774f19a76424d20ab9e002fc2a2489d558650b682485f630d264903de74ab390add5afc1bc433a7915f0077b740be980670e9f58d9bb1b1c8cd4f0a6e2af4385e3b34fa7770db6456c6ceaf37511f8a2ad2c9270532dce3b934cb79690116dea3949ebbc8aa7dae84d3294e0fb0bfed59ee5146a5f6a1e7aae19aadcfa3a94ed3ffaf2f2c4c8b0524ad61345fbf650752b0c3915a9a135ae633143754765188449c04c0075b4924f7b0a84434e48d100f2e621942c4985d6bbf7a2417ec983e13682193ebc9ffdfa1716735b9c4b322a32ff78f8b832dcba59c2bd694b6f40cc0e29d6351ba0ce8ba43228f96c40c179f06b15f8d67877ee9d53dd9b587474e378681ad9ddb0ca823c7006c9897a144c3d5100b1dd3c0bdd8e5f5501bc1c4fbb42999433fea523e29d23edbf7c4af6e5778793a8dc65aebe3ae7e1267d74d654c351953e7b3c8d77bd893a92c0273f091c9ca479285e3e61cd34a55536ecc08fc2073ffc20ecff167635f0f06de02a374dc5416fe7b5c4d9c5d722a936a47d30fc49357e6fa2e6b945cc5340a5121914af7c7e3e3c87be430342549f0123772ac9b71702123b6be6b0d12c2aa043bc89f0b82d96fa69630ce3686fe518ad2b6ecc36f5a09199ce640bcd565389d51d88a73c7df01a0ef57b1f41944a8b72c938d06591f78528b368e3923bb91863f6c0899cb26c2cb0ae0e04af41ded4567eebbf3e2345b996523397c06b92d10700c1b0a7c1ee1d058169ede02eaacb7252b3ad1428ccfbfebf5d06d44d7e9a03e16d30c150d6a70cf1e3cc6216c521f24f533cf1841ff4d76f6279c2f0ea69f9ac20f00bd070f6900db88523c32495fd552f7f596bb6ee8379ff044df4789b2a23bcde1d8db39089e7661f33efbe786977779a02354e5f0650b9497608b3d5dbf89a561a8fa0ea106a89ef94cd3d2b7b017af7cb368e77e11a5e11ba159fe66fdbfd1e68eff63484a09c3b3761886ef68d98fedbeb13db2e07273fbe1bd297bb1a8d02fd275c64f93acfb56a65b6db3479c4ec3b6523e57a7d2e23a083827f052b0b0b53e6452d638cd7dbb58170375b98522bdc063daf5f57ec8069cba4f83bbe8eaf7ffee1459099e183873430d1828a36a6b03a079dc3aa4e1aa2c17888c7597feff195cad93c9d3a9e364fef12605bd522b0cac1994eac303c139fd9050f6f06824cf810be2cae81c7315ca3e9ad89b8da3eebaa6723b16c0712abece16f9f14a81570bbd1ede6a4d622bad47fe8feb83aee4bdc895150eb6ca6e8d5a3bb7c5a5b4c0dcf5d850e393fa902c25bacad3c71c90231f9c2034c727d4e3151889ab9e405fca8b62b153a4d117f80a71cc40b424fbde74d49791a02c05fca204d94c4735c0bbc51601593bea57796f9b094693e6f3980a03160fdd50cc94fdea91e270cb90d2d457ba23477cd2c225069bd358796958c080c40d43a033aa6b431e7e3a0a072723171b43d7df847e582c925c0e26de671d7b56ac14bb5e376dcf0fc946d6174f907ead6f0785cff74b3a1561105939c33a9a8997cce3ad5fad003fe3edfb1a75ee21255e93c48de8dca6fe5e3cd909849639467fcbfe957fe2843115135292438b004ba56c089c3218f8c5cfe5bece840a7a8c3ec90023e3e88f9cc7cfb8594b78ea740d6e77be2730907fa1231989d3d1004e9504cbc787f90aaa8dd40ee9a88d5fffa084da71dcb70e05838f6b9c908b4f68612210e71d1ef6a40865825581d167468500c707bb0108ec4fa99d611c789125a8d6eda466c1273b6c638fbf5b499d18392d9209237ffed160ccb5a3c7ad3b5c26e3fa04ccdd9fdb8dc304569e31163bc78096aa9f65df2b2d503d1535c8226d7f593947ffe004dce05aeb9ddd7ff996e8a443ba28b308a8cae8fa951987df84fc295c3ea8ee3ae6e45e4a983c201acc1fb3369d55f9ff6f439341b73d335d929e97220ac6b20bc1857fefcf9f2c601c0738f473b122fbadf4069a3672e7314ad3c02324bd5dcea5c1f75eeba4e775d2e2a865273431aa6b28616e8ac6305b222571b6613d5a34fa04792a0375bb17e650a56dae99094bf3cc5872715224107faa8be383a2c6af1e2a862ea9c85a80059175da70502cc563946eaed7c53b20ae5f4ed6893c9ed98561a80a7705d3b9c359e4b3337da272eb0fcae824fa0e061e24a129ea8083c4f2e427aeacf2c50d607d7c48c71c9d0742237c6ebebbd10cef612167c97e637902c803b0f47fddfeaa29796246c28461095875aa27da8c262a808efa6b22846a2a3ae2f92f77e2a3128e26175e1af3645ae849ef148dc01661e6b06efb1a9a3f5f5e26e06fb677159dba543a9d4fba649583d7089adeb1faf0c3f82f1f764561be722494c5d76a3700d85bd366ce1ffeaaa73a476cf6e520dc79f2fc928b29f9800f7b20d380ff6e61fc36289247787fea2948c764e9b5de3af59b71d3e068e354fe28c2d83d35efaee7de96677b3d4acf32c9e822a58e7ad597e206fabbc8846a4c0285875ac295bcd498417bc0a7efdebc404719d8df47d723374ceea43ab39fa24c0b0fd21a99994dd3985f46de2ed58aa16f8df68461b41895e99762d130bfd4dc962462348b4ac210ef23d706096fe15195b831ded290fa644e20d310619d41fb2e2645789470eeac35bd9ccd149ef1c004dace0e0f6a83d7b35fd0e51db4460c2ae863a445207ed966657f808d978b86bda2dd4b05f56d10710f542cc1e68de3fddec3bab7f098b3b09ce0c1ef49835f1240aa05d2274234e473036b293cb5750455a16e7816404d2da434be7d5a8f66b2e9a23a2af6ba91e0bf1aed1462e68fc09dbea0c39292fabd4dfd24ee579f52278c7885db8deaeeb899909169a6191a67f6c7682838204e09cb39f4172bc83479cc6702ca3c9b829dfb1d6ce959ab9682c3dd376b6e6722a84dffeb1d0ed1fd622228385717e20c2a5d937b53778f0e285e72b399438185a182b74f411a252a98f35d46e35d7427ebe766b9be25c9b3f46554c71516c4827cc4d5cd410ffe282ddd6555c855539910bd5a03894d6d036f3b5322f2889246d5383b34e79ffdf9f907621748a370e88357615da9f3ec8cf19ed62e530d0251956b4877e743fecec7cf483a6ecad5170604b9e8eba251197d1f9f5f55cc9ff029b433cb8f7f62b29ddef9f4cc4c7d0c22b7ab502573800804b05ae1c06af4f4348aec3124b2290298c3ce02fa89244337bf302285c10a04eecdd809554f18863dfe2643bfc264b634ae2036fbdf452385851cdc7a886bdde5028071ea788a4f3f632d563cd91a899578de668366e83ba8285cff9d5c265ac6ee85b82fb2f729f45842063c32484e0e7879e94c34f071c43fe85326e98e9655a2ee6e62073f88cbf9475bbbeb673a89934354cfa293055e47588add8611f1276f6875bdc5fcc12627b0c1e4c24b7b8ec72d267bc2986dd00e7998d0c404436fdb4bbfd14fcf3719403f3fd58c33d6da810b6f11785f6598a34040e2460628c5fc8dbdb5009c4db596ea40e503d54577966f1fdf0ce7966695e36288b8111669bdd9869333953b7c92dc7dee8f35718ad6896137c2ab307f2571bc572787661152d29700b794fd3601bea006329135949267c3b367515a1e15cbc049ffecb44e6aed4cc208883c1c87a12ac186dfb0ad62695716ce708afd8e02d12fcabc83781e83bb08a07cc15fa369d697835ca40d96a72ee3c3769c6e017534d26b53f4847ae9898d862f9d6d37fa6c17bdb3c784cc289c824909e5ca57b5744724511a2886413cfc1fe8f62e4e1817e27115e7da3a43bf14d41230ca5c3b0b9a93747c994fa98c3573e61fe16e0bf409eb0cefe3bf33f827159a306bdbe5ef6bec70ad4eeeaceb59024fe48b1a045b7557590ae7fed9d6c3be663401f5f0daabba143633c3d04bcb024279ff60b9ced619b64788f1acfa1fa575d441d41a41a6b976e4e42e5bd273956732fd282abc9af14c0d8596b455582ab55b66b79b70081177af2bd36863a4ee18e5311af39d617a9a2532465171f814e340f69eed2eb2569c93b51c635846823887763957deb2b78e78ce3db34c2d4e9bddf55c00f5e0dbb27cb179dfcab6f3ed4b148fd5d4aaf62a227633fe147e7f20b8875fcd653ce58e3df3d5869bf2c7eb8ff48b03b3baabaff5a00512ac09aad32735b07b7aa25e1f699cac564540b05bfb6d053e933d9567fa56ad58843ee5a39e7d91e91249c31ce17536cbe80b66b109ed7ae959726ac495c825239ac99d40592181c18928a90eb257c36f5a848408a0a16f3e9b85bb2da98e0768340c6ee5c13562b3fc2f8e80919d3ba41481d967850a8b90fefd17d30a9f58fdf11564a8a0d7e882bd9ef71fd7e72d09128a3228089cf5628da23ce323f2ca86e153bc2b08c221737ec5d1b74df924b4999725f77f0a460ce07bc0b6edc1d2b4e72e39a51307c95a9b8a6f0f51c4423b65a4cd8eb5d4e0f2372ee28f7e0734ace743a19aa4c7db3a3e5929a905e65914aac2b51839190bb41cff207de87885f37005391f049b4f84d5674c799d6048f584966359d4a3098ee2e8349d7133295b1ab9c166aaaa2405008a4341ca0f04031f4547082f23bd7ec9df4aad69e7fbf227463d665abc098015f80b4bb80ee666482e33ab351b9630b8ef3828b3a8ef66f936a573a78b503570c645af5fa76cddda7ec9800d8ae7b3a4dcb31848bb1171db732c29d71eb3c7e2e8c24955c29c317b07aa79d7f44902a1a30d036496a0368962d622d05ad2642cd53db8c4ce7cf7cf9ee52f151972d69079caa60938d4769cc8fc6ff0b976e8af45eb2826150b3efe98b905e227d152034ef6325fbbedd5a51f6929a2522d6815779d5d93892ee49d75d036f606fa785f8fcb1f9c61c5ce8ff167ab511b29c7b7a6e08bc3df2ac88d0a369b08fc37cefd09997bc0d5dd8cbaad1c5492d4f6df3be4875c6f19a10ab9ef677c7454cf9522000b2d4ca905e71a26173f9a49e15a14145070e859e1c39b88ea8c8f198474902875052b5693168ab2c7a5b8745ebf1cb3978a6f653834efb485809f09516e34c5b69c540994d99b16739d52f98b733847fbaee00a3a0c07126b8086c7ddf027c022ece568e527310d43a52777cd77a2a6b6add378da3774d9fa6108098b01f6e4c6e8f7b6811543e45be6b1906a2271ce117fd0e48521f7faa4193cb6b8e9979c28fbfb99765436863c0b6a8523335d1795c4a9e79f8c804e290a1ccc27128a55f3c412572f19f8525d4857ad40e91015df70410f45fcb2bb666c74957018fc421b3d0be5cc3d734723e285ac15c4f01c1140277be964f542906919faca522db01842c12673ca51eb98704853627138ab7a19b27853c9b2409842292d250ddaf20f47fd319d8bf642f642b931075b7e6f87d4cd18b45f6b6df642f609cd8106197232b9175045cb70400aee3c2fbebe0ab903f0641d3b5a1fcdb4e8a95f89ca9c3d523c87b891db63759de7923087a3d708f24b2cdec62db44ebc6ce65df20cd8b1256f36b5ffa2154a93f91e841ab52f84c5b1216938af45a4ed7ed1c7fe7bf3dc4d39db1a9c9d27532478220cdd9973b37065e303ecb15904ec677a45ba644a02930f80a03bd51b43e3d91c4715669c6234e12fdd53841e844a7525b6189bf26d1f93cbdd26c04cb5efa1da259d67af83f4819c70607fced58df7604a51639e5b0b2ef71e911bdc393dae5ca6c3cc6022fac9d9c731e0b1fbfdebf5e79c7a788cb221218f60e253337e0e35047a7853af3d19ba3c3b1305c9bcae1e7ba1260791e9b200b241aed832e08b5c13312ff9c4135f4807b439706f2da8a7771d7d52706a3fe0de024a920bf8318adc8a3211639a67254fbbb232f34e48fc37e6be4c10f8eb7f19f1380b9b32a15b05620cf2934a58cf7186e13c83be6df59d73b4c1d4fb7453d15562614fa4eeeb91cd606393411fe95abe430bccd8af824feaafd6c8f1ec219d81608951838959d56198c962d22f72e6c282dc4d9fcb07f386f257f89c24406563e210aa1075cbd8931764748690704b181b494d091689270d402c0110ad221076165b0979e7d360051b234651da9010567a3d9903a3ed939aa4a87514f32f6857a340cac8f0ffe7fd9a7177902b0271a81c9f9c2193d624250609cae8caa8c1d34048f8cf6a656a456763c4f06a977b4b408d7ceab0a79832bae77bc76beb5d2d0d7814e920497edd678643fab6194b0f20f95275fb440a06245581e97367665d2accc56c9691a88f9d5ad94673815a0d8a2ca18386f8b10c6e77817811d6cee98308be38a4a6974ccd63e73be884185a98d8c468e0516ee4743ea83a46ad161cf4220d09faf184e392d0ba03e45e1585a73ec891c6cfc8233ad2736a09ea778e19925dfebb4ad822e8eb3adf0c68a9f168ccd8fc45e8419a1964a1f3f9c6538695b044b49cde8964d866dc32d54fb717b0a737a6354f4cf429105093b688aedff3e636b2d4e54f0317c9a93b856e3b50696d6b5edb8bae1a754668197d26958e1c3ffc3fb875c00768dfb7ad6e67f09e2e3b5ddd1756898e186906f079519d75bf5b6f2bb0cb9676405da07b91584d0fd0620996892fe022d459721dee77c46cfc2ae0baa48cabcb3874595a8603426a2ed37d7a96cec8a85e6a4a67e0d040f3f80b290f6e836c2f07e4566ec6d41130cb78da97e80f7861cfa0d9ebfcd768c05ee9db704e45933c153568d87b5bac20932b293fe0c4c7df875ae7a22c4cdd3d1c3fdda920692153070a1987a34f7213f7380d9481595d1327434e742c07528f52d05561472fe52c7038853f93437c1687c15c9272a273028b6fb9ea38424fad506206289996781a12e5f6dc7269d103805fb7aa8455f2f56d4c20a7b90f517c8bfeb1a3adf1a5a598efc8f0df56862bcb43aff80f3f36be31a32ca5926d774c6fff50a745ae7114dace3e879ec74cf855f0159ddda630bb06346d62d097d7c02e2bc423181c7e149fa72fb300494e5122cd9b13410d62f0abd3980e2e482af6e0372ce078c26e19b984f95843b26efe8e8d685d856c894fab28aa022ab7a27f173f9d1df7b32ebe084d4288e4dd85515859639108460ecbcbe60028d8e24cd2dffeda7ff5e0ae2fc19c3fab4987c39e33bc1ad028d30e1f74d251d7ce2f0316f17f8c82a53034f53d99bc90df20188107fde910bb1c57f66485a5aeea5cdcca7aae51203849cefb2a8c2b618e71ea9507acc083bccf27d3a76cee93987034cadbdfe8cca735840aafe8bb952ea166d40c2fff3df454c766ed662ba5ba5f4bfaa6a572d15599aaaa6a3f3a3fd060947fc250484359e7daf4bb8d078dffc12a11d1428f4bd78be2cd3365250d404b77e9a4464b4a0be45dec9216d2d38e387bbbd7bd3b1617c4e17451918a574a668f888e95b8d75f371fc7a493d9508fe4b13caf6cb989d7a4621f355c8c220a746986625204b7ab21d16de99db18be6f53283e43c469dbddf7d4104305797d0dc981346d7ba0d73e55d6bab89082f270608054bc8ad1b5812c17555223b76ef3b820b8be9d93b73a3416674b7e954fbfd48f375ce749649cadbf69c2947ead89c0ac534bf0aec0aac80bc53a0b569aa180210fcbaa979754097431e826142acce961d909eb93f46988ca89be8aeed2bc7068be715c91944d1569b27047b415d1dbe31f99f5723fd4f9066a84fab468198516e3dfb84599efceebd0a431f9cbd249cebe88a138dbe4521054abdfd53fb91a320b1570a27a1a4b970a6cf8fcaff07035601fc5911398c6127e868ca66669c1de47c13094243334da09e24d266b5a5ffa0efebc7dd919bfa8e9fb75792228156d9e3d216abc41d80f8fed8d1f0a21ecc21022523f71a1d73d9fad82505bbe38ab3fbeb899d38b938e36c48dd4b9730b87c","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
