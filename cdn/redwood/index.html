<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ede9486c3479cf6753e669adcf1ad9080c547783dba925d28f2a6cc7acc79af1d6641373406a354c206c1423742ed68b07b930ee807d803d2403e64f3d31b13a79505c94383ebe6f32a7f3fc52d8c7a207b168588488480867eb7e6a075fa85ecef366d30d16003874286319c37e8976de419eb1a03b9b497c060435c76568b08ca452716fcaa51de43d5efe537bebfa0209ce521bdf202758a0ece428da90fbe91c3e19d845df4df6d8b982dadc8ff49a41e852a4c05341f8d564de486a3b69d0df37fb2c34df31523812d926dc88560a261be62c804f67683f0cc5d331b81e15e0788e7c327ea1a0abb14c83c64d966ba655451327f7c8b8779faa5f2a6d2c2fbabe41968e23b90e98a95fb27a6370bb8ec31a31b85c950993cfb8005e037e9ad4182279d143a3c1a8acbdab2c2b7748e212c3bc2b81255255f7dd20b2f6e9896a2089628c07efe1dbdd5fd3d01ea52aadf09a989ccfb12be74afe7d6b581d7bd0f3a023140dbe975e6e36905601402b4c993144328f3ac54042485a98c1734920168d87ca5a813937e5ecf7b10d6cecacab6140f5aa4b19ebf413ce40ed28c7f57945f19d5c69add8f33aa4fdd3cdf82be6bace1cc46acb72ccd96b0ae1606d660e9f7bd0c8f09473d0c110bb2188490b9d96a0da90774e7ff9bf7e45adba06befbb9828c7f519b7f92ec91fe414f03315393befce325416fdcc6c2a2b27f0e9d53be6bb48f87de859fd9d4b67fe8c2c7fced41f6972c10de4587fcbdd5bc44c4a010bef35d2bd2f79a59bb6aefd69d39179612513bca883a56927c82477b94ea727d164c8027ba22994d3c7df410a5a7d863993ff9954faf7a037fdcf83d4a5a6ddfc4dca8f7c7111421bb5886a1327b76e92fd33c7886a17c3316ae11b7cfba62a8ec1f3412c0f2f25050526f8fed6748490f43d83941b74f128656ac0dcec52796d0749c18f62331d18f4541a77ac6cda2318e049d1322a3749172d11c4674bf3ced2949e23e283658e7dae212811fb5e3cd79aeab393aca6d7266d4bd6e23d1ad90df148f14001f785a9f2b3fe92bbe33ccb5352af0043b5033af5832e5c58bc4582eb1269213bf3cb88d087e9c84504c9a37eb39d91681ff442dbb7c999196d906e0a59663f5e605527de427830c7fe168052c414c7062c56773739e7c5ee829fb01c8aa939218f37e6361378476dcdec8d9adce36857dac799bfce6dc08903e5262e1a0aab001dbbe273d75a17cb3f50b7b9fa534439edbb5cc9b7fd1ebb5aa5b73e3bc8bef406fc045bcf4ad5f134de0c020c8c1b05b8858ecdb65deaffe66001d6475376e539bb32fe469681b61bc9d98fe8968740a66e0686142a3a15c20178add85b63508d32b5cf3ee2ac5b8fd0f1de09f207e615d1dfd4432bf690a699ed50c5b0005cbc88fab983b5ddaeb0264f8e5dd54bd3134968839bc76ec91fe2fb0ba6932366f5a984f42da8dba2b1d7377e88fbf27b9dd0e0411fa8f3abc666e1237bf5e5aa293d515b8247f2acb75b8bf0dbd2732fd2f0669d30501e2f982db7bf6e6300aaad9359a288ffbf4f9bb2854a8e18d59f2c168739cfd8803d371f98c92da60f920f0893b3ceb967acbee50cf64918b03c7fc32e5770c1146aff0ecf4f61d82cc2479861204f4c9546ee54aeafb4975b29f5bdbb24b10de48222d7de0b60fb074e19ff2ee3e6527b0b5feb602fdf137e8a1b84904f89427adf4c58d70dcb5574255e16a8690688a72b9f7e730079d98a1e8776645bcf6297c9b7e86a2eb987d97e63e000172d725090c326efdd161770af9d7a84d056c06ec4eaa4210e5798ab9386b2d275333c3a25e00c22ff7ee9f673212cb44e03ef00b48e20c6317b2fb37ee6ab05a9b4d229398600ae843550940493d90a761e1690b7a9bba363f94166ae875c7d21cb491224701d7cd5e516262ff905af97e794178871d1c1b715a0a6cd250571b4287663d1a43e331e50116573711db85b8fea2aae8b74beeae5de01199eed5f489f21f6db02ee61e6b15d516008a7c00d092ccaaf70d8d884d4d24cb5e023dea6c3791ef636460d62c136891b8c4e4afd0fa46b64d16c56454616bd7ca6b149d367df738efb68dbaed1ad5adf69e2bf216465b25eeb60af645c66cbc03a231bf794d205af8a1008395f0f8a1a292f5a7a9ac378d08f32e1f40dceda1c472e078deb7d5e1bafd68d028d21b7bbc2aba32f408f90f27544202a6150082e638fdd6d4d7d744ea09ad0f9362d9659e50dd7dd23d67497dd274237b64ddf3038c42c421fe005f53c397f61b5893ddaaa831a54876deeb6724726bfb512ccb89a1efee8fe1ac829329c32b1b217e9c9fe8c220be48dde497c49b6920d52d9bd28f4a04643f0a4a68e2f5ad26a97f01fa9e61b44e3378d8d16a47bc1f70fa736bf6146bf765dd0d6951547f8a519cbc960c2c23ccc5a43d0fb287f33fae643d8118e022f1fe30eabb40cbce204555757d734ade1965d2ad7406c2ae2610adfc7ab3e09f013f61855bb2773fe92845737cd38bf89fb8a0a7f2af0433c91dd476f905845d06a2738dcb9fb827245ea9abe9e408b80192d9e8f1c093ac08f2feafffb519ecbc385230134b8d188443c2839e3713da06d4b8032fc825de3e0c2683328b2fb36de8724537fe4daba20936097d91104e9f2820f4095b98bf2db5debe3e558fdd7ee40385667d025b6266352956076fff89b7bde616824c058975625c95e7451f7aba7f9d5f57b91dd3ca1d7adf18699e7bf97ab1692bd84abaf68660e2357dbe63aaf0e46d85b49382d090d7920b0b4f90366845839618036346ac733d37463eaba320d139c2ed28bc7fa3c3c29341fc1067c30926d90c947d25db8d6cd12d15b0c7eac3d5bebc5a22becb394ea7d31fc12b28b1de7a53c51a844a40c76f19bf9e545509115b6d2dc2309972d085de358129c46355200c607cce3fe1d78aa529eaa9dd2f0de79f350308c11cf160b32c2f2c8a7d880463836f0c12426b403884d6a8422142792ef96964629dafcb9aa65649adff2843e0bb467e3144acfdeccf2328f4a2ee081256ac304d6fa41d195ef331f92d137e4092d22a582dd0132715cc1332ad8a9878b31ac7518366279c3014c673fc31edbb4b450212d2e349e41dfd1f8850fa8be932fca1562068bc776cce1a7b3c9d2545fa448ff9bb06e75a369e5c4bbac73af8035e8d95b8348c70c772826d9436c4c2e16442de9c8f6e920ab2542f816b26d45743312d0d9f23baa15b9374bbf98e2c6069ee1e82011efae3f635951b67bb6a55b73ff544f6b7b8e70624de696af167b8692bf8a6642d9b9a7b442b3ecc24a81cbcae9cd4505e35c78865654909711e218ca240b69c877d18ef8c43681e436ac7ff2f11e331786e815f6bf9f1d6664f153c133560e6bfe06cccd9322e317d7c1f791ad16e0ca403c6026869201753c39e6a558b8d6cc5ec4d5942ddf532b0a2ca6b5847d361c31f2cbed322872d2e31472ee4e844d10e99bc029e152c3a1d59395c80a02cb29387f533357f7751df211815a2c741d7c65d74d88de231e69280a1c97ce322dc05447135e7f7d01f59632bf433c7d2acb1404f70de5d39b6f88d86e3733d6ce6708790d3574daa9bdc2e6f76a7d8b07ccef384d8e4c7ae253a506eb6523723822e4e3f5923f8fed80cea11c04b46d275ca08c7db366a4ea511f02f5cc6b72525280c836134a0c31a6f734a51aa3b3ff44780f50ecc2ceccf0a79df81caccf3feb51f03400f8e41aa19f8f96f158516ac51f7ae1081d53007b4f61f05b1712e01704c3b11224e85a099d8e7c4ae5624098faf809f527db16a9347e96160f9d6201e20c56a3b330c51e6af403304549e6ca9171094493663729f56dcff11f7be0e2dd25b379cb7c09c3869f7f8edde38565c034a2cdbbacb799ce596516fc61bd120a7b28313913c712f92956f76c9c230ec5fb05fd306b1175c633fa9f5494dfa8a58adda8270d8e96627c56b761feb16b006d817c41030f95530bb13f4a4a34103030fbd205e7125ebca8e6c3f686117113e7934c003bd6f756baab93b4f25fa03862dcb04ddae45ef05eff8e659f073b03d68d6c3c3295918e68feb7c9e791aaa33f9a0867ba12fe766b6a1f567d21e935f95b2723bf56a770db22d79a37036ffccf609d8adcb26c95e4bf714f6bb622b46e17a15b0552ad7a24ac05864aff849348c0799d6e81bd680878ea62bff29e8909514713484ec6a86f396af097c8c4fc4a95c16637dc3e6f26b4ede6edd3574a402bfc06296b4d20ce7fdc16cb12ecaf1db064c8f628418fc7d5b29ac92973cdfb01d21c82d8b9ba3b71611965b57b2b107d79122556b90b19f189163b621a46d00157c9c2e49079c7cece5862be380de5b9f3a8be7ecf1ba510704b2d7a034a78b6203cf9a71d7c5615a763342167f0a2294766b9eac55f7f09b40fa4efccc309bb769a02a2845465eda787ac0b1780f7dd0a03f07478008f77c4eead42cf5c5c8718644864d7091e5ca481a644d36debaf84db7dbbe599032e61f692a5414291eb8df5a1e459ac3469bc87dbd6e1ee826a2ce0379b749789d44e55c2897db8dce42c3d9372b31ed752ed894c7b1f6ec910101ba89a3d37ce0a1654f3f73ce886a873f327bc8e424e5b69badd0cb31d54bb988a5553fdf1b50ddb0e74a940acfcaf299cfa9b705de4a8370d40eae98c84a542d78a3dcffeab87ae92d56a4a2252303a3f30053857ee0591fa8a74d739a40a53825d6dec31dff7f9d81aec66951462436d10bf0981579fcde633fb67e6930ee8485045c593ab9f3ca72a8f6ce15ceb138bb37c9e2b68b17f65d3ee1aa45669ed9a27a770504a3f93e52a96c0bd29b8ef3cea4c7663a347ad87207014bad679357cfd3444af48cde18c417e2d3eec7b483e1e0c5bd51510c504dedad84d9c7aad8b6c35f3103a9b5890b204c28777e16e66e22935e7af99b90d1271bfa3f3a093e707d6676696649f6f3b4806b5915d25acc5d0432b63eca4e915373e362e293fdfb4cb6853f868abbd2c67137cb395a3c4af0fa5e73aff70666f3cb9cb2b5868cb5bf6d406fb8acfc0691afbb94ad4b85cdd63cae59a85ffc93197e80a2dfc909f8c1534c6b1eb635c3676186b3035cdc79237dee80d1b234368a2794139713ee72bf3f04177be8b87d748622381b0c5b4e77af19eaa78ce2eae3bc7d204c67e9138096c0b474d5e6c617aac2595e8ff64d0c12ddcb7e4b261e1d2fbc45e3f294f42e9f6220673c8365b860cbb96bcd34a7e163e4a35fc9d577adfc79ed5ac1508d261ba4ca9870e7fd01dbc6b72941c2db5fb4d04e699dc7170f940240074c1e0620f76e16534bf04214421a9d3054e5505487a3fc586f2fac79933e5db15d43ee10b3b4a9829ddeeef336ad3ca78d1ff87a6329108c7bce15829c405ab0b2309d9e997a6639834543b92fd3dd8c0d948554f7a11409a8f6310517be55bfb1651524a4af67b60e770488e258ff8b45e22b33e5ac1d8a5a4d8b5a861490c8c8486103cb58da829f09cf26061006a0f53980410144a30591a11ee4d2e9bbc0348a6e4b686bba0b03c6e1d1a9e1dd70daa33bb3fef88d3640e89ce68cedf7c05c4203b7db0157c9a7452efcba1b0c36e297847df90352a440ad83e6a4d57d5a5f1b23f55d7611d03dc9ea43c31a74874d53e421f633037c0b25383cb4e2e9986b86109a45ea913b53bf5be57babfc3fd8c3c7f5d86c51980606849dd638389812244ccc70694f1ca525ac27de96c25a4b9cfc7c734ef98fa073cb9788b1c03b426daaced7158835d3e81b737b6ac55fae3372225d9fc03c777ca106dc1afaf58eec17ce19aa5b15ad96eda8cbb8f44c21dfddd1f599b403a4c06cd217d8d3bdc7da8844d701dcde78625333ea492fb78ffb79ef95b7c244feffa8f527581017fbe614ecd9fca4c21287d192472fa931e4451e4c9a4ec368ee9c675b3501a81d11c9f02412f915006029c027dd3304058bc2a3e26270b5cd22123c5b7a55c8b78fb4e8fd76361f65b7b16af734dc98433428570a7508f173ad2be9e38e589ce9442735e0171ea9a9010618ba649ccbf5852cde18b08a1ae4ba7dfb76442fb22bae1675a5e4aee46eee85e5690148a7a3ff5ba56b7a5a089812c137325a2e572f54d03a001c23be134e6943aa7b653528b868a1ce4b29f58e828e509483167e7e1665e06c6bcfac69f7bdde87db4cf291426d2bfbc6d0e515fe6909e8d7522f3da84cbba5068626a883a48b5f9a651b8fe27df1e91730e85f4b7f8f4c7264433644a268d711581d7624cfa9cef1043ecffb0b917a688703e94a97d6437fc7bdfd764abfcde58a5956bcbd1085006b91f3942f02caafac386e4994314f13b1004dca4f25b83b037d72b5c3525aae6e82a4d510e6413d592924ee486f238f815743336936e84a5a0ba24e9461e7a995e0975ee8e870ec5c9bf63578b2a69d64da6205d2371ae097701be4160eabbf9095a5fadd9086959212c79a87ec2a47c7c1d743b302dfc1c1967584a7e2a0dc52be4c426b3d099c64869cec42225cce2c54a586184911429d10963864eba6f128690d90e3e515208a8e77fe477ffa92c3ecd71ef0cabac40434da13136112548f9093cc2f48088e83d5f0c67c053ea419f226e9e0003537142c4393dcb1fc6f4f4fe32382b1376d93e0315e00aebf4157d1b81e43cafbe2918353767e816bd628e8878fc963fe859a3530b130d1d49b8b8205943dd030d634114438d84392dda7ffd63d25c894e28bcd0882913bcc73e44f0da1c4eb2540fd70e9fe0896221ab96fa621400ad85a0490645cfd25806e401331adc3095269b5f8a5bfc6139daeb9062fb11567d2b2fefede55aa510dbab47a7c433d545bf8bcc1856c8f288eb54757c32ad7d459a9e33c98d31ad54d979bf73048dbdb284f032e9816b7d1d2447409fb1fc1651d5868ac75af69781b5428d06629d0c69fb907ab223f40373a034d5d2fe86664a2b793e33395add063510d5c8e073a6238d03d5a2c01307b7af50b5b55d0058715cd0b6d0cc33e0e7bbabd71b91c9b5a473c9fd5f080ba85730542aab177311dc797528fed3c435b33bc19279ca981c778e8dd3127d780689f4c6e9ee666d374bf841bd5f6d31454d8f083930f01a5df2abbd43be3b12f97fd793d7614a0f01af3a7f19e5994593cc3a08b87ea35946393f45b9b50b201c0ebf24e853e017a6037b2761297aafad5bf0db94955cda2e005b36cf05a1a83d9db07bb645d18a5b9c01212723b22f8685cbdc426aa6cd1862118ff43a8f80a858ae7a91949420adc30c5557065043c62d0f27367cd3a788741d347f5720519fe72a1fa3da73f5ae1555181a8ffe318c80758737b40c35a99481b96d859e0a962bea26dcaee53481c4b9bd8ddd8f4e87983b31353140adc9b21fbcd3ffec9bad80936fa3e4f78a73b7b77cbca6d481b093a9d933f5b43eb2fd8b5fd8af2c96121a6444ee846dc1ece77a5ed47e6130386d4c6d17251d26cdab25ee706cdc00ec44722d8cf352c7b54d68f8a40ab704bfb60a1452a441ecd93d3e6c15b1fe9ff1dea6b1bd84e49af525a3f56ea417c56bcc697bb1f67fda2e2cc3a49fb9e38167f758515d09b2ed048113f64b6b1a7639e33a135214f9e8c62b9aed3e1d4479a3af14a0c7f4226f80bcbe0a62caa021372ec1e9cf4055339cca79563f6bd5de438d57db613924899fa870aeee9623f7c96c68cc6d89226f04e3df79f79e12e4118bb4e3562bc139dd941bd342ac90a00bed06c712f3947ef0cbb0c310a72fe262f4f272fa93e2717cc87a22e1fe7eee6fde6cbd8e2dc95cfffe71995e35fe2df0a487fd59af63533b35c8e41c3d8688fe5d30579a290ddb65e0d925b55bdef36af5760faa78723902891ec9fcb5cd98f32db247aea49cc4b10c8c56d29c79903aa0075bc401a231cfd350ee659a7933b533c85a905971cc35fb89646430a97265b492aa35e081105727afb02f0d8c9923d54b5588d8a7ad57d12b6ff62e0421f168f69f009d69675dcf78815d5f2a0a297adccb46f336ec3e21de0daecd5b73db0da1b3c308139eca01de9fa3264e8edbe7d076caa768d65ab103d791933200b0e826f3a4d497f42f5cd745b52ae478aeee1e64a81cbb0008a114675e999245175b268a88497a0d870b6ef5d4256990c80417c2347d63816db9e3a394cc8ae1f61226f3133a04a5bee36f2fe278edc2a39bfd6f00b0dadaea6a79b7eba7f74e0f1c839ce1b9570a861d23dcabfb63dbe9ba18d69afa8d53f74ee95febb9ae506a906ccd65695ea75377f74c6327e636fbf85b3f2acda4ad8435d798b49743f1f48b86243a65fbd3e2c00d9b3cd1360b62351113532200f7f8093b22bd1b7c3b97a8be1b5239b4b4fb439a8f28d144d3d7f1be7e91236eb24663111bbb85ce431efc78bb0a410bed7306c4196beb2393c059dcbf4251a411ccc8b70fff23c58383193aba22affd238eaf88086d9b31c173ce327a0bdaa63aef14fe7900d15c4b6fefe9c67e6eb6975d6791ea4df2e5761ddf765fe527af2c10b99b91f93eb18eda819f3fef798fb7538305ae4caaa19c4bb205367401fcefdb812509abfb7d2cb35d3ac9547dbdd6240b9a5aed614ad0087ef75e67e79424e9066d2d37c157a6c610e7f84f5fd92b2717f8a06b82acd6e4e7dc3f809e1f8812a7a7fa318201e9a6fb7d3bdd49c6b284cf68ee926dd8587e09d1fd0cec1a6c7bc30381109a1f5fcd3851ec3f5d359ae4132935dcbdee120570b05fd5bc42d36f6ed3fdf36cae8eb6bd630470ac4eacc0e192c56f1ba9e04d545234d6ac06e0bf465bc73991c6a7c80a162a5a30d0a59e63a193c4103369be0405057a05742b120d95a6ff933b5a69eb41ea908ab87a70a43c40021c5ee94e48caaec11212beb84801deb753921eb4dfcc40ce4b56890b23452228d836f8c5ad1b8ad2b177f3084f59b8e69fdc864f3174b4b9c6cc34519aa02864f29f6b2a7b84659347cf8aca9b34584058e805fa875500c12d39443f464039ba9414b9bfe6a427b03ef90e2f9416475648f5ae33fafb4733811e64e2c202d907633316c02f60bdfe10512a6caf93781d8ba1cfb90afd8e4e7c5f0bba66714b2f88acf3dd89094ffcad0149cc40baeb6347219913a28a3c9464ade8929741eccc1c527cd5942e29f34e401938baf8fed678c2328ec42f73207eeacf427c039f018f9b1cd4181f978dd0091d1b395c3ef2e3f5d097ecbf3abae70f4357ea49daf275ab88f156c2d0a9100758e94114742ef6f845db50db21e6c2263edfd0489829a519ba7d257f27dcdc8843d48c1ef0084ff26c2d7fcab87106fed4c5f94b98df9c3de6048158161901e9ec17f15ae3d8d0a4ce916b9c46ada34256747f262112c459d5ef2737076484bfbf699f3b29d84819b0ab0158a59e2ea116bd670710026ea0435d1ba3b8fb837b267a6123854a233263d273a9d5afe82821d27295c694907dc6f4d9ad054f58607f8b4b7217dd33dfad0b7ebdf8f161f94dd9636c5c3164e13ccd080dd4b0aa39b53b41a1fcc145cab3294e88a18c5d2d298fc400aaece85f4af1a3c1fc223dda2cb4872f7c87aa78b08bb3a0ac6717d9454f6e1362a0a6d12b0b860b5f11f4b585a13cc5346440ee99da9d2c915f187f21384481c394e261109aaab28d1628592eaeea34e918773b5c8db2d2de0f93062b4180f374ed7f970b2baa26dfc00e19a2ec7d1c43dc3377e800afdc2203e9c51f79694a7bcde3a4af7b5c05df7b876a391c8d6d487f85effb82a17b7a8cabe6c59abd52e9a7f860956a7d15b567c80cfcbf35baf4169e7346748be4818a3c687efd87674d493674bf74c23f96b887b9d4b31a5bf84d3abcb771ac55dc5288a5e7fabc27ac7da4bf792551d57f885738f54dbee83e4ded3059d67aeb2318addf19c30182265d13887ee42f08ed5aaecf321deb13498d9bc3ab5d39d3181069300a0b38bad983608fe1dbe1245e9adb79f37db27e8cb44dbb6d783543b329c9e7d59ad07c832cad9e412f6958a4861962c8b1c682aa742632abee4bda4c693418c5df2758883ca1a2d70ac49163bf6c1b5e07c283be3b796edb1b4ce09e5bb7c9298f729596058306e20b213eac612ffa8d57cd3bf8133aef143b1d86b1e56aaa935504b6755f00efe3638708159e07e28c9e5dde755d4cb616f4e0e9a76b9178b7f043130fe7e71ec63957286b53772cffe1074660fe163cb45dcba94a4697658661670caae8cac193f5d3e6fba523c5b1ed00e166c49290c4476bc9c3b0630044154d51ba4d3794edf7213b643feb385bfed1992889d6a1b7a198d3ac16541ca372f5c8e2aab46671bdab862e966eb69cadb7c361cbf9405309fd94a6a0491a59784690e872197667aaddc83f18d96a4e39b72a62553850ff1fc0df5d16314c51b7e728f66343b34b441ca2f83bb2b6f1986e8b7cec871d2331af93707c64b99efeaca663af36cbfdad762036622659e6411c26da7f11331d21721c5eb2e5e496ae302973d110569261ee19d79c0862bfcd37355f5cf511ce1c297f422b0ff69eee94e4327e016de1221f75c1ecbb3bec3cc236411d2563ec0bd6c6f48e9f3ebf676b4eb6178684bcf00eeeaa0aa145e6c6618d1208d5fe01d0f92a2401e1e434184129190267ba2ca42d799cb57f5ad8aa607231f6c5b9039cf7a5eee84cc9d1f0d7a069a50fcfa5e0b4495c56b82b97dce8a64f0847279360bd60f35f5fe394e1d30db8deaded6b5a77f49b5c4bedda144eccc4c7a9f8308065bd5515c212dc02c45ce84cfd912b9bbecac8f0fc42ded9dc80c57f86114b94f1906fe6b655511fb352434ea5c340365f18cc582b7c96eb366bfae9176c3f2a9af202840eddc4f87cbc9ef0e713d6722edc0958bc35be063c8ae68bccb035046d8b451133eefcfdfb05f913f1caddbb8a143b6e683bed5de2478cfada7576efd850b076da957f6cbde835881624002059177e9026d378b8a6e12189a9592e090d14641bb34e584013958e034f6c4234b044c3a19fde2e15e43908da130e1ac0fd401ea87e50ed631a22e2b2909fef1f076d47fa36433f6d8289f59a1025e0baedb137bc5c7010ba4449aa951bc28d9b0a615a8dd47e958532168cb199f3f81eb06a6f7521f20eaf964bf88440a855bc5b75af90f86ec57b9c99ad04fcb096de836c5a38ec4f30c9ff1044a92b434d9646370f6f65b3a7b95c1b78d40a92f462a66c6153ce0ea95fde4468605374fcfd69c96dacab0ee4f6eb8a630e0cd06bea883a596731c6a1ff924b2c11897bc24978d23d75c747c5bdc5088b850c5fb4ee13b434cc06a833a7fec6872ed43a66087f1dc65ceb70a1e4835ffe868292d40e4ff571ca2ae97c4d80f20e6b78ddc75ac6ff9911bbefff2977ab4703e70d010ee90f7a77be60d46696e086006e4ac4952c1707af265e1f74544477fe2a3135bb219913ed8d053dd4b5df5e48c8c5b93264dd07975e4cf70de9e37c28115ac32840f621f30591c5b1957bfd126285136a50d6f31735ee96a1b447831b2371621f8e65ec3a51759c561fffbf738146b422b4e149786ea3982c4cb0d9e59ee0431098bb9b3c88d9cb5937a9050d77499b4a1546fcfe8eff70129b369e11fab84b31b086b19b108d94bad9922163113940b5d804cab7169b6939f1616aa1c636ca04cc20068a76bb9e182651d8fd9ea3bba32eec2d4c59264fc3788eefebd6c791c39bb7e9b8e0f8e252cbc6a22493cb346ceb8c2dd5d388a9de33ea24bc58d53e0d97105a839561e532a9e72d5fc25e244f6a7a42a3079ea792117279fd21f9d537f5e7551a1dabae433ff940a6f31cee5931d8fac24001975fe96dcdebf991e3aeaa051e45429d184a86b212521de1d9cbdda7f18aa5867442cb14ec00485a852d5899d3e4fa5b5b8c61318d032ef50d6daa34b1b54f79af3858879484c4263ad8b37ff54f006b1aa839fcdca21295d30b35bed43a593c9b03f572d076b95a6844e2e4bbf7650c6d560de595c8a7caaa772408060c1a20931db13db07184949cb6b295b1868b9eab68b8edb4d834ad14d15a2e992b773ccfb79f43becc2c33f30fd73691f3dd010fb68dea4696827c8e3e44d02766e95569de5fd93e0df530c7e4a9ecd15dabaf38ccf99d96e9367ea13e2ce29d5457cc452abef2bf3dad57c02423939033056d60f15011a77b6b14860387cb0685103ede28c847c8ea21b120adcb74f85dc2bd859e7c9419189b939a80f81215088a05126c78cc86ce28e22e57f55dd8a1a85228bc3f69cfeac1f775521fa18bae966dc6a6c1d1520e4d9f5b26aa596a18a613560c055f24c3dbb61e23c5fe3c58655c943a1684e71b30be0d10d480e122467496ea5bc25c05d705791af3db8d1843a1fafc03ffffa2fc4d345559f9402f13dac8188bfab420fbb44f10a4f6be1609ed7f702d4bf4c2b3a302086e3fdd85eebbe5c1e167d2e11eaf6dce64651ad0b14cc40913899039264f94f71047678479ffd6eff8d483d0fcfbf4740275c167b228452c9c9eae94547d399df17922a1deaf77b890a47aca9c83059f84377d10e85727347d7dadafaf79513fc59c4fcad397a913911ef1032b5603d9b9d73731b046c4c861d721f0c9666ac28e26c6b51788a3cb5146d4409d80ae22c84df2a682a7666c494bd6db60343dc340081464e9aa796bc5ebe2d3e4cb77f11d2e0156a1a0b931479c32ab7954be7e09e8b54b13f0889dcf268e144804a4db4f7028ba8959c3dac593bcd4fb12aca84a47835d8640d8fb27589159d27c9d7521796ec41b6f5c4c451566bd9f7a71eed7f324a7a0a08c11aaede0e79215c3f8c422700556c0381407c9a663bdc460a72c029feaf3b499d2fa5d9e5b1ebc9fc6b5be08c2113be2d00a28dc2a96712467841ef3707fec2278bfe8618690b5da2054225a6ea45a1405494502bb95c8df6f8294c8010c5befd4109cd606a13c4dfaaa7b95826321655706cdb25db92a484365af0101887fbebae278ce2ff8ec0b061c0fc054fe5c7b58f7a4c0ec9ee99f2921e5d1500313f68e402fb30d101cf3ecb10ed7013038e490bc8343b1363b1269ee1c21998ea9ef6e5aaa47046637d437a06a9b2e7ef101b02845b61bf2ff778fdafffd76e0129d83a5c514b31b5808297576fcc122cd1bd09e6dc6eb0464d8b714c9eaa853393f7591f466881af55e03b62df879423808ce4816ffc4f41ee11c3fca97df3090820c404b0c71f9b05ae1325ab3f8014669d40ddd662b64b764c4b7601100f1d5babd0c96427a9b8a46bc0457d29a0d11ab523259bf33209d99286daf65004e670193f6c80fd707b74cabc1b99d953e8e4f511f77b20a6951b3b2ee90eb6b04d38b0b889759d10ea016f29a49669e144c25a7006639356dccd9ebaecdc76ad0c808583acc28e4fc855fd2f9f87dbdeb4921b2f957057dda99cbd32395ae2fb9232dd50ebfaf0d793d6a40592f37d76b2f6b85cc1f6d6b4e9b67bdaafc222f4ccb29d7800c1b24ff0099783c93c5ea5e4ce65384aa28f6545c51872eb3ee0bd360152f2719f0ca3d9cf48c39b63bfd2c46394f2b9473442bef7f9e3cd2fa517348b5ed1adc15f3d0644cc9d705733d89e68aed0e1c19bedd378ac7057e396b48617b882f9ee813db87a9498e61c66fc18aa8a3a01b9958cdc6ff3b4111e1ee2fc55def0b15b2917d7d1068dac582ee10d89480e39f1d240e947123620ab8ad85c0d4e4347d28a2002675c30c1684db9547b5493ddd709a0e1bad2ef991f35e217af99faa56f094a88ef7bce34d229a39ca1a22e68a7d4e6309d6b011c2b3d60d40d181e9cb88a07d178511281a36d9a3f8f5a5540b415684ae715db0e2d33aec0ba1b8afee8d235651d54c70ba0faa97585c4ddb6e7c14529cfdbc2f60658d18510cebf682480f3c9e0ea23ba4cf208902a099c889a911816c770889b00126c49619af759036a4368d2922e0728b35c568d185a78ebbcc48075c50f17cf03312e89455dd53a3acd7fc61207a4d7e0b3018127dcddd54a282e8b5a04b6463b98b50e9b1a07635599c788701813a4e2d9fa2dbedc254295ecfb1e3cfdc2a7a32baef523f7129a610351cee96233c8b8efef0026b22bb930c0157893da37c3bd05f1d3b16b6cbf49db37689c1b8d716a3a2cc27a37876b200d7603d63dfa6a9510cce76d4cc9caffd98b2d20efe22724f8e57845727408f9916e57388b7ff40d98cc7cea2068e2ddcbb567fe815bb65524192b42b837921191cc840387191ec2b2c5ea32f6cb791224f833cc5f81e71e0c6dee6634c41f0031480b8bde7187aa4a59eb4fbef79b4058c0769ca3e256ae079a034fd20624ab844d453a66085217ca71d1bd2747b9fbabd4d284872eb115e4aa4c42e4a13117efeae60c643bc2294fc9500ad09c6a10b24f003781f9dc53e7a2fb032caeca1a22d78a26ba5a2dd03494f0aed80b677c2e7752f3ce8939cab982bcf2b05c2a27d1e7a0774bb8fac5549099c0e74d304652c8c3f07842b32fd4e64e4b21013114ccafd39573dcde2c4567698be208642141b43c7be777d42c83cf63588c9ec48dbb39dfffddb87572ec8f8e1c427ed8deb819af3909ee5ece87bcb3290a8fcd6716b051bb42fe2043c9777d48b0447396e0e1ddf4f50187d4adcc5e9a4108e94b78451299232c3207a6dd2d811040449077aed15ca82fd36a26f5de7cc5d9cda05dcc0840d0bda0098849cd6db9196397954475c75ae38ba6b751cd4e96a4a133bcde6a5c9688bdc28fb3effc21c3c1387c74eb280421b518faa0c56c7b6f562e03931ca7021dc56eaef45caef1bcc491222049627e73a86e8a5333c72ca5ae2e0597c382e6b7412c93329a619233791d40e5610aa92ed5c581a39c97859622813486171b7c036018f517e104efe9edca6961f6d358b95fcbd79f805eb35f5d1fd5d8f5eba6619505cd86144d7f2fbeeba45dab838c13550826baafdab260bd8cf8cb64d4578fd877e3dfdac824bba096e032a065a60bf92198c7b004af0dcf2c36922323847ce14d3388d3a632ce066c0a34b01cfe5f7e31cf02b721be3632592a18d400a6fc79c881ed9acff88ee7c3c717e599737e83e1eed3701c6a98c0b3bc04d7438213dd3d705179f1a7368f2f65a5aaea46470f9b62c53684b4c05f59a1b90b5be99574cb2dbec70018c602e49f231d8c9ca0c5c1cf6e48a4695b58698d34a6cbd81c592e5f813c2d5be4382173f5d2eba32376db32160d22d07eba9711d90ec514a2627c3753bb3bbb36eaa3105bcd1c1fa16ae05c1eb8a03194063c89005e0db3ab9d59555e2afbaacbddd1f0e24fbb86f2ae5e43a254b4f7a97aaacee97cfbe9ec910085f13458a3887b480d27496a15971e841ead270bfd2d6a1a806b90f726c61804552670a24651700806195ce4cc6575f5b8d5ab6424ecb9650299fcb01f99cc34ea60b1a6160c5cf41c380d781489823de27a19726680ab651b96a149fda25ae8b5c6190502966298cc3e4987b488c05780c3c79aae353b4a9682e7efb2811e681f55aa3e58a950fac15f52642f3f17a7cf62c67d9f83f0fa76ae99b07d3fb7225d768840246909b981b88c5c122659de0f3e1b91a637f0f393866e80cd9a642a015390600bdb4a2f7dfe03f181fbb136ee80deb2e3d193a7041bee570143974436e9e21bc0c2d765f1638d8c3123be9ec4ce58909611f4ac93b44c990fe14d9b9c3bac0aa538032464b96e2fdf95380d50d9c7a82479d452901c39db9fdd25cb89aed064373a42512806c5550bfb900f808d87a257a38c2347801a1d520a80a8bc60b586575c79284ff0f09a7e3b379d5855b10a9762bd2f61752a336ba5866b33e2397c4019af4ea2fc768d5f81b53d3decb98d1c50e06f275ea0a7c0323b8ab5d72a737b8cba26b011c0b3e22167dc56f2948128ef3cfb72730d34655251b041f81152931ee74582c80b4bd7918bbc23af0dba0eaed69f4cd769fcdc11a0c962d01cec8a38b64a40a148e09e22c7a9fcb47ecc1535e69bd555e1d039074a5e8b73b66a779c274fd78d12037ac6b4f69eb5d30fe7ac1edb8dad55ec180188a7837ba403a700d60d576c1cc356d9cef7f9ea254bfd8df55e9bc28d0c0c21be519277e6869eef0e592cc2a35664a7d055f99df84136a1f2c02a22bafc35501854a5d4ce8d3618f36aceee3d72deaa14d3f65afdea640d7e88b118935993aa8f4ebfc64825d825628135c0ffdfcabc691d1bd7b7749bde392e42f76667d2e72e3d1659274d60e9bc6ee0370cb0a759d1647b99871cec88e71ddf50ea6b64e9d7a6222a9602eec262544751b7c1086e88d2d537c419a144b098055dc09a06456b6427a29250759e616b8c5d24edc48721298e6a7765e55a6ce38be106bb62331eb45118e19e98059a2da41fafc6baacd1a639f96aac03270ab6f4a4a6c5ca17dd629c0ee029fbf619215271ca94096dbb5dbe2bde0b3bc9abe33577461b909dbeca0c8db495a0e4e02d74959356d98f019b345046e866f1c03ee835dff50b2858c04c9471c1452492baccd4ac220bf957e425faf5d42dc879b7adcf391958d518d3b484cfa6a1079d0ffd92feeab55f8de83629845015136a5defb4e7f3482f01983d2f0fae6b8f8b91a901e1a84a2aec14c8e6cbdc714119a16196d23bc97f5df386dcbb9bcd1425d56d98f3b07ae243f503113930f1c9175804f9821998fdae372dd2aeea9573cda139a6b6dad7b41bdc8a39dc85a2cd7068875b7583fa4bc671dc929678eec9f1be7639d8fbcd577a75898119c65585a22b152ef0b4114079cb8874999e0c8eeca5097eeb9d315b4a66fd48ccd3e772a212c944dd0a8620f6dba7e5929639a3c96c6a7c31784aa2fdeef57a684b22d843cef1a2d3ca5dcd14a777b63cfda8cfe7b51c7f90e7127fcce03302b80f9ba6eff61dec25900eae80a9e2121a0ac21a081ea5ea081e90bb37c436874d0322a716509ed082bbd59e538dd45e6b71363bf9dc117d61f622206c77c18bf307d3cfe09e65c92b7a9a240f774d4adc2fc7e0aa94cd5744686e07df5d2a594cfb3e52a7dd50da0112c1416f3f843dd5514050820808ac221146a8a3f5b2263acc023d87d475a4a33b40a7803245810d27089e66ffc11c6e0b8a579e3af42238ef3bb52d702ae202372f95ce1a92356e9911deaa84bad225bed60af6d0354079b80bfc50bf8e562b2c777d5d1bd8569ceb286ad6afbc62f26b0ff79eca7a86b209cb662986a6d99fc58789dfd36f4ea68e630dc8ac4a271a52a625ba885cad01ef4e693a98ac48d02829d47eee6bb65f91df06ec3f930825504a05fc09f0db2d8a6e3439fcd173b957b777707761101b4f58b46987d47fedd83e7854c1d6027d3762882f59ce56cc1aa8cdef59e2e9a510ead1bf3b41c8036f28628e53fd69f1cb967cd9d7e51671fdb94e0f34bfed71844905e562daa4a48c9be7f052863b63326d312580a58ff83da2083a5746107a4dd57a62bec21eef74faa4c2261a46e99d94f04c850dcd2824619a8a31040cca45256375cd4289be5c129b8892b243b6b8f18bbf51ea20a771cf941f473612aff14790d1c27ebaaba68cd4f82d083b98ff62a9a98e4e9436f54772afd6f2cbb35bf0fac95178fc95ff06e8d974e9fbc221078407af869a5872fd67ff5569fac058a5d9f2f44c58139fde82917b0a3abded7d2c8587bc7f010326213a425541331bdcbae1fc61631a059fed6c2804a716d614df2ef7d8673d88c7069a84c979a3702eae7f75609458ac61638c8cbadc637f51912774626f9d913468e4646ce5753aa31d30b30ff488b50a58b62373b7525fd06d58b56b90cd456b60b2fe2533042b786ebb89bede7d6db91b2e7b0201f99952040831dd1d3bd233f5dca46b4d0834c83d8a31174d181a4fa4ce1513a0628bbc3e0962713835013e7c9c23e5eb07f913b6cea4bb8cd44ec3d0f920eda7bec050d041d2e2a74d2476199e3d5e1c80767906410270008ee684c4618ed0e2c791","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
