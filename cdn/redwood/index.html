<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a37e0d9de9faf41d1d067292a711c5b157020d354c7e0a4e76c27619327fd551e4f3eb5804dc1dfb3dd3101a263415a4dafb9cdefa6a2f33ca78c1725a8094e2da7dc076989102aac989c8607a98938c771f5bbbcc0c8d8ebeeffa63fb28dc47750b84b9feade4c2aeb50699f8c32b0605428715ee1fe07069306781c2e1b8d3d00fda1dafa1bd95c02272992ba076e6ee90c178ddf7352cec324a00417fc6f678a93f5ee47c09f72d86d4b0a298c268aebd030e495434ca5ddf966b39c9f006acfd4f683216d2bf73c99aaab04835a42a0bb6bbdb0dca964c46fe054d15d2e53eb7bb7208f90d8a01a235272636d4eb9d67d349a3900e61f79d8b16a49ffd11bbaa61a209933ffa27843b3e45e9cb888be197a835d046a85665c05af39b599ee977859e44bcbcb139cc422513ba0ee83bccb76ad22d9c8fed06edf0c774e58e4621e9de9723ce73c228bd748aebd975964fc1bbab2c4d1b4ff72c8a37c5ee85fe12bb1e94962dd166f9fc944bcb79a826fbd9eec9dc35b75bbff1a6e1878b061e8ac68d6f258eb20a35d2af5cd70eee37aa1fefe65f52fb65a00f0968507ed2eeac7305d9612da9b9da6abb25bf1ded86450464ca03b0223b3ab3b7dd738e6b4ab85cf8270978a7dd7c7e3b066cb05d4831eaee20866a927490f651cc1e4611f03b1c0a3ec57ae6fc587229a4bf13023e8dad4d17f38cc23cfce7e9a0e2fa0a39bb75495d7ded1a3707b263e1a606544961d00134bc45d2dfc6ccd350a7dceb8277517892ab5da2a8c9b6661b1596eeec6fc8e503d51c0a065007436887564bb8dacdcd9d563100ecba8279363013e625761ea2a2f780a3e16cc95398865bab3e89c11aaaf3ec3063d9a0146fff7fa720be0b533a05aee5a06ec51e302f5ad1a670adc48cf2784e854f9454d79e030bac7900cff6b32ae83c91990a7499c62c3c45099c07bf4d1e7b53fb02bae4bcf5c8d79d19fa5af399418bd6445ee01d9fcf8fd8e30c02c16ae5888207b4269b913c1afeb8a9c1745f80ede1ba97427a390354b6961015e2e0c1205555046e403c1714fe1429ac9155ae0c7a15e0fdff0d56878aa3f58fe162bb9b9e6202b0a0d2c15f894465b3257a89597865a6e8a8b3e15260c624f986d8804b6071a2181e35e9f9413aeadb18cd114884a1a7692d2e4207de0b04e9e14e2808c8dd1c5edf8c4f52c2ffa54ec9cbed068a9835a1c9624dc03f9fcb4389e31d712985d02209eb1827da5f7773e6b86f287a7b50e06ebf5135194526fc0e273b30ec6abe7cb5e4c5e3918309353c78172b351d98952868867fcab1daf1fd02b8933921bbd878ef44212c4586b5f205737c408255ba7866d049c7c0a1b053481623a591baa5646d2636783e4931833c059d37bb4f74ff326d717c347a8b0ece0e90296990fa12d380749e27870902e50f6be089d82ef25ebd7a7c5d0b3f1a61636593f74dd8c7ed478ef78459a8506cdaad16d97621142dce000425e456b532756a061f6a579586b1a3ab58f7e5d13be8a5ec5159732bf6f98f3fb6586f76584b1770fe3155e4aeb3c337c874630abbe32dc5952d3aa91681d863e8a0997efd68d6e47d4f7b70dd21dc0c2d30a25b7b8484fe515eed1a2ff591614d4cefe2f5f6b930a3fa4deab10a84b8eb68e5a3a3e4843674d74859292791c8a41fefa4c91e9fd4acfd154fcb7ef28d456a60d51041d8b6ecfadfac96d8db9ce987d4203d9d9539902496db8867715d2fc1faefb0b10d07a0df44abd6efb09be030bfc79d15bf5bd9784e6145105c9bb967cab4ea21394d8ac42d2dcf3a72a25cdf6a36a24fed86fd2d3db3deed168ceaaa8e789c844b01af673063571373b89a100a1d208ac9644ac74c54210c257c6f77a0d25af9e0a81b5392ab2bc898d5bdc9fc5bc51cc2087e6a695ca65beb517265e48caf56e6ca1b80d48a1e8b792e0fa509c201b05545e8f471bff14871edbc8620b4d2d4ba571de4ddc2c2fecaa76c09c239f1b160741d43ef0a85b4688bf7e16f6dc89e66c774a5e263ec60024e5d4326b374d872aaff7043e51bdcb96073bc6bc14f42cb8c1d5224875082d7cb5610538f11719655f156f398fb09ec4bbec946f5d4a289d81bd2a74cfbc4f0e68aeb8d6184b1bf927468b4669dc0b79fc878848f5286c038f66055373dbdb120404f278942e1575b44f4d4e91bb35a0375c7d6267d7e76249b8dfdb4fab93aa34db2cf9c5a9264d115f7d79525d58cb3ab096bd09ceebdf8f2fe1ba67cf240fa277bd8b64bb80bcdb2a9951fbbd67a7e59b4b3b84ddf0f26e2891b2092c30149042ae918f0175304582775151eb8ba6e6c19ff156b0ff4fa28f7c40e629569700f8bf0e9f707cb6c1951669446c7d13f83eca6bf9326ccf8fc22dff9716b384e47ef7565d7a93520abb6b252814f23bf883fab296ed0acea555faa6747070a08f741dc0fd0b4f71aec2b988e11b147aedbb57c38279ebda3709e3adb10b71268741b32c5a02fabadbd9cf0defb34fbfbe39365ec1e9c5c5dbb88802042d2f5f68cec141ff4d4ab737451781bcc733f7f93b54ba0fd457a262759f4a2114b7e00344233928d3e20b46deeb09346b97e867bb35e594f62d2d7cf198043091826ea69167e085cf34d6123b65d30d0c4abe965d2b40de1f912b4312d36f966ccac8491bf67f8b1f09ffd26094f0602cacdd96b7fa4a281952d2e3756d26abc08f9e64fce9d1421d9b8fc5093040d0caec191ff85c3070579a32ea5970371a24b73bcd86dad3824c0592058570729c85b7db38d9173e300fb8a26ea73e2b7533eddaf36925cc920cbb273186d748c0878ece7e3e86786c570402d0aa95e1d7311b6629d6ebd793a7cc25ee227e389997be8b0271990c1c8670f04afef26997c5ba4a465c5bb4596c4e3fce29c8c887cc8fbc1c717d9bef1b14b4383f9658e25720044fd7d3392c47a2bb197f673c1f368170013d3be625e9a870f0b8f15c186e3797b405654f953f8f67bc01403e6e6d4a26371f8091e7a6aae6920600a54f11cb95b4f6480852cdd13c5529131efd77a00465f0db56bb943c9d18e2fb863a4dda09da4b77cc178eeccd3c0bfcce801058bd347ef3c1c58052d4875548845b322c371e36e9bc8d80e99288eccab460d7423e0c0a37dd795105d51a52d9be07ed42dd8fe818ade1470550512f12a22a6bbd72c9c0f86e7ebcd9b99a7d2867185d029f23c954099c2423c2ec25624b40289963a73f55d4d15ecc689c4a9b33e00af74224a9e9d9a602bd5ab81eccc93dc6a359e9a4a3f7ca392d521ea89454c3797d02240786f9b8789b48e6bfd5d6e0f175d7134e8002bcff631328dd4cd893718040e0708cf84fd24311b21824c0491c05744df8384789fadbce1ea40b4bd1a5644af80a4056783c7e25f7f49dfc9a3adbefa67f70a22951c609a90bbdd643d531120e3425effe977c6c90541e33a5c907004f50106e7d15a9ea72db8255a963926f2060a24fb3e0dc46728858ea34800aa7c2f8faa03bf47dc35f8c9190ddd1b6474c555393a1d04534a9aabde5102c40a5d0ac08eea5df508203b5f9d34784957a94ec46cb18b65e09669e4eae0637db6daadc5b163a5f0759bb189862d20612439f0ee2c793f5f3af9eab10261f3abed61be8f77a6f40b329bfa8c662a80cc4293b560cfb54534acef21065c85d5dd6df0f5336f4a6e8451724768ef2eefa7eed7fbc784cabbf86d8ab8c9313e9cd1afca9e864d3e86c951499606efb7e1b201326cbfe0a9437c07a4e99ba15c32af0df54819c5e75640afdee1d99cc6249b57d58cf667add9cb68d5671909ef359d7eed52987e9d91c7e9a177b53f43b93e54b3be799d15bf31fea99e1fecbff4babe15350e6e69b1c125cf3c4e5ad7790cc041374269ca8d903d0b85b0ffab9ffdd9c787a368e9482038cd5dbb09f67b2752c7fdd4e67cb33d60bcface6ee28799991a03a69e0cfa86872d410ba8d7feab0ac7f59384c45a47a9f6a8393ab288b636d2062bb531e20110933d44987bd16b6b94918a50b02a1cd3994a64aacfbe4e5745972cf688c567d54a2d736f1b48abfec9440c8e57992202a4550a7da6ba7ff34ca6d897f0f5afc164f94cb11d64dec0c1ab38b263fe1c0f5aae54d319510b88ef942a783695f4171ff43f24dae0b3638060939a7154fdb887a15b3111aaf2b3df3a9ca6aa363aec63631dbcf3f3e32b15da827e720c3902663275021e8a52838aabc5958c2d37bc3873677da9d1930bc53175ae84d79896dc6819d511b3fab8f52b0b0a6325f87400714df2481c1f2287a9b2ccff700ff490b3fa8ee2d5ec9471c2e10638f20f902023c518651eae6774c7be944809e038667d0fcfe014c2bc63b22c217c6e17c11e4f7470699a036ca1b120c86531eb120bdeef97abc84cd562288dc35fc90fd796cd1cc3ffdc676f2320a74fa0a79dab8ac5bb9f8416a6be44a0a964b67e0d61b3d73f865b75c01dc82a9ed9d196f8683c05b1e950aab0153f5ba87f91e98a3d462dc5f786bae759ac5ee84d2e04040873a73c44fd8e26b4eca2f9e85ff1799f382d9d76f9ef6faa4f73e347e7a59d39b9533811adfdb3a7d91a2527f18afb7b940d133e051df0a4772d4b2cdc9aaafaf8af6a43994f70bd153ccf630f96a0b80ed42254ee59308b134acd49e0c8ebcb11a97f4ae84e9616dfa909178c40ac2e9bff60e1c3d76e2b1b485d22ee90939ce76cee8ba97077b1b5c3b831d8c591c72cefa05a3aef6d519561e038e403bf67ecf2f5217c2e503805df913eca93ce3eb38fc419b80c669b6dec80bf6b8542a348cf407d70b46d3a3943d089a85e857359c81f8f25515d35e486cfa4dfc2796a102e4b47be2af9424674ea7817b363deed5fd35a17c2661f16da592565b9c0bd246cf6fdee679d67d2b513f1ea5b27aa0a41e7bbc104971c48101b84a9df680ee877eb8b386c9c2b62367a2a3a2939f632413826728dd4543b98036abdebf49c00e0c378b2d9814f4334e034b98eb61093f647cff83d369a5d8d6aceecdf92a72412366b8824a040719209c3456d079682f6cf86cecfc1b2b3d7e9e0d7b750771cc418151644f178d30295e04431535e96a0997eea03858a2fd6dc628aa323d25a0534f70dcb8c818b718b179e7504df18484605c3bb7a8464bf9faaff6d19437ccfbb813ab2829fdafd49db32333bf76a95ff579920b3005d2b3fe4990536be863e3478f18c1398fd51c95b50b99cfed100634f26c6e440d4429585238b7826d5028d19bb7f1a9964536b1d9b926da86f394720b92e16413c21c76181767a73c4da3d826553a11e3e9a14e79bedd900aa36a5dde53a06c72c1722adb8e7739f3ceb2c8f1e7423ece629b3ad755cddf3efc25cd2f07eec9ddae6177ab708389a27040024acbd17a4c8f67f6ed017de95c8fefa1eaa846fe55d9f5dd72fa8c3acf74c05d53d8e1d05351da3a9e123e4c5b32920893b5b0e893243a0563d6ec33d762e0f0215145c14c34fbf115f1a34ea64738c8a353d3c4466c2f05254b12d120440d8b5a0b50e430c902622152f093ace5657543ee6cdcd71d9b1707f533136ee865777de9817380857ff55cff97c787c220a718ff417975fdf28bb61c4cb9daa9c02378bd5164364a1b8747cb917d29d337a3485205b865ca8417c5dcec296120c8a99d9ff0cc7aab6ce572765099c14f9dbda8a41d188846084abcc0cd134bdb40c0d2a63246aec1d6e4455f752f7536c300a299a6b662da09926bbe307fde41111e17484ac58f6addc6f2f5dc95a165a696513b2935c5df8c0e5af512c8bb5f855f16359ed87d10dfedbcd911ef8d2e65af4ff709009bec1b8ed9f4f29e7a6c61b01ae16a32644dd43800f583d461abad9c16bac82c8485ba128993da1d1fd112ce59727ba9cce2730c2a1cadaf6a97eb9b6c2ab1b81d31765ecf94e72afcbb32268e10f51ad3c797a5777229f05c8fb976052141f0119321c190e8878623ee084ffe34e522ca0791422a475721334a01b95acf6d93de4eb41c69cd12e5353d9a0129f396d2c6647893cc52311e5c1a111b9e55e62b11379f7030953581bd61537c429b20e328915e929fef39326f8d1380c69675b838895f8e4c19d2405f1eb934497f62a41c46e9f6489749e241364c6ec03a18dd4e0a28154f46edfae664c31a2c35c47b7ffec6948b8268bba3343ce5aa7b312ae281f13ae1bb48a10ced55f2b68b1e738dddcc53272377385b39738e5e3692b0f11c76e93dacdd99fa8e7bdedbef92e18ebdc5f2f215f9da9716b8e63574711cad0f2c7ef0b462403c1dfd813e7570309c8f33e365c023fd0ef9d0224718b64fc326edd8c7f53ed3ae9a8134b690253e9b80de3b667bc1ea90dd2bef21f94ef2e25e0ea7ac28c4c3ea7d4d36af032e3e09745d1e4b0a593ab8a0f78484858a518a0ea880f2889c79806711ab2223a9697a1f487ae296386b507dbc55454208e4f87c203840dde4318ab57b07b06144a11610040c7775b2dd333df8713eb6f4832ff3d9ef9c25e1e2db3ac9a2da8ebaf6a25d608328b30eea07e55be9b031d803484719a78b74df2085a384ead0de268d4ec6f9bb71d4e9f6c6d0ebea373939c365e204b3650c896bc02c6c3cff87a2c0f310394843ac811b91ce0a01fb2a825a3faa00a6bedd2fb8b731388f6de6ee292119f8fff8d6f48a647d5735bdcd1546013ac38bfd7369f7b559d336f64e2974275bd35c231c546f914caae536c7d0e50bd5d156344faff011e59c93d5e8a0cc4cbafa5df94eb9aba0b1ae6318b0955afb2497503411b83e854ce82f4a6ac86b332203ba45b5d4d517945ee6ce0344b93e4d362e2c3d3d56e6cfa40d1e4b597ac30e0d35afc43bae2c38d3e92a919ec9561e610234c41638043541cd337dc8d2a205c80e588a2a8c033909f899b9ec60982c3a5575e25fba06249ae4761b3c83a30da159883a03ec57405e9a783d354953dcc510cf9a371296059c1fd0da86a5618ee58b058ad170b7804a7a8e35c179786638a81bf3d24731dc75fbb3c0485f6a0026ee5d31b82a4c93ccc73e33739523356471fc9555598d83437bdca038190eb657c7e9e720ef613a493d76a5567089721cead67d78ffe393ad6926ae4e0e1facec7763371e3670f02fa169345182bd633c167758c5c05dbd08dcd11a69e54648678932f01c3ff895934a4029590516e1411c923c602c5b987be256e9371658708f54dce44893a0ebff57fd6cc8f94cdf062ef490711be576ef0190cb6aa4c49317f1052447fcf26551c67cbee322746d1a217b853b3b9d5fa1b3b4d3958a500f0ced76298b8d47da345838b1a52f54124fbf6c74ccc4b33fea7baf6fa51260783b1d82627680c6b6b6c30d9a7f80f257a24c7b71d5d0d74352590e9886c5c571dfab94c00515539b75a0991e8d4be470d17ee65dc1e2bb0aa433462cdc5b861447c56c9c0580bc34386577f1ca5b47b2c96ad5296ab846688fcd20f6a4f8873a1e6ccd6e7a4ff5047f10de6255e5d43ee55de0f7513479d2c8500ea81b304821c9b68e57b525872d0be84cf65064207eef7da23affdd31136173c0aacc2051082a03519e4371c62331d9e6a6204142a8cd883b453109e9b6b48ae4ca80a6362b88aa17023068b755231ebeba0c7525d1b8a9f7b9d2509aa15230087db2793397ce3421f2dded253f1d9d4848b1ad9c0204a2dbcac99168b15c44a51eaa91f473f383cd633653be46a57c031e07273fd113cbf473634653a01ca32ccb26ed81f34ea927c6d2e0b55f59962715e207b81a97bfe4cf42bcbc5d8e28bef35037ce361d95d6bd2768809c25325eaf8c9673050dd4c74199ca4e4b45a3c8fff9ce57ce7fff858fa32ed51aa99410ea6799983925f4e3d86ae27abc628a25f1a810e58761c8d1dcb6c0f017d608561b98bb5b32e2cd2b2df8ec9dabc002d8ed00eabcf50d84ad747408156a6eaf12f39ca19765c5b73f23a284e19ef77ae4f225a78e823cb1952e8101e23ad6d67ea1ec6cafd2894ebb8a81cc3de4e3239243ecdd2279d330dc4aa06a385e64202aa72fddb93b7965e9e52a7a8eb3a323928929ed8a07ef792f849d1fbb649fc23770b2d90ee02a40ded29c770cae4b98012f6b5f77fb9d4e49e9b5db0206ccc396b86adb16f99e8168eda1b79a4a8e90d9d240cd1732e879b987fc80e2e8de2d8dd74eee91ed09bc61af4fc70346bced93e8931c17f5460e267f1ccd5a92b64c13f42b89982cb0507c56a9dfd941c1e860e3cf3115258fcbcf5bd2809359d4f135a6391898f7499ba2d8c2a232ad7e8cda5f20ad163d6b5b429f9fdd56d787a3a3fd24d3015b53b97c048b4bba29ffc41a8478b7483af456da7ee0ba40a72dd1a6b6b32f4c840377bbfb53550297c06dbb66f221f916d8e8db6625c0880acb0a0c07c1c775cfe5ce5af2aa49d063b83b271642a6f60c2f41ca435b4ec8a735c62560da4e62c9fbe5c3abfb1da3328806b992b2926e459b84d04fe47ebd40fb7bc4d8b170e5387bb565c65539e180beb6f9d23d1cffad607102526174c58e977646ccfcd5222b905aa7fc07a32d8fd0f810413d50c591bf79dae9a11549aaa69606c8b3bd899b05bdf42ca6f147413e50d625a6fc16287c6367c4c07142e8e242b8547f17ee7fa1badfb5759a3aaeb3ff768c91d217f8859d4cd3e28014ede42eaeee58ea4187b6638b77c02f8735a644f758ba4ec3826fe89595c90353848be9ab04c91e26c9f7776cd4902c81c546b9b5bc264521ed04c2b0edc02e86cefcc0c0224ca3fec338fd092039b24279f735cd6c151e7ea297715f9e644cb3559fe1a447bb4c3f05cee2709b8434cc29da736ab9f1fad3fa5a841eb221867d13aabd22c3a528e2e3f510ac06ae25f8a0b7dc2808fdd5762fc5fbde67cd2f5c2611be46f2c601bac6f347ada902cbc11fb145cafa830262aa46997a7778bb1b0ca71c183d5c10daaf789709e707c84b500717d65de3bf8b8c6e82025200b75be80c0e22f16ef6f90eb5f0cb9dbb77fd026fb1eeb02235c7f3de0fcfdee08d04aa980d1bf379d8ad97b3948eec2e942ce143d541f5df9077aa0e881196987542dea77804902b7fbff8d2a21083561249aa7f475c82b0845d356a4f06afc01f1a65216ffb45a9bcf42df2e830847ff64df230eceeb18dcc540ae11071e2c377397038dd587a1668f7792e980273f624076c50842690b56ec43e649189a99fa8e672d25502be18e93130d14834148c95353e2aba84ed1d90a63484f1bae856a10866db415bb3b6072139450f4e5fc0665ed19eec63bc0a22399d879db42f32a46dc366fd063e28fb73d3f33d7429b4ef4f3b9a38389fd82a127175781f27da0dcf208010a57f205587c303e508ef8cac272eb86ed7130bcb21b372df8c55a1df96e284ef594e65d18788b41ff8c59398fcf8a0919366b15cd1260fe76241c8d759c130b87ec1230aefc437e314a4eb560534780630515406f76837d74cb8af572ef310c380d27819b05f12d4d5b11ec562cecf1972d7aa77e5f1b5aec9b754121b6061f8dba28aba8056a7a2e8f495fba1e44579fccdcd5ab3cdf94eaff4a9051cfa51c8f70fc72754ba092261b02376a1ddd676e53e0241a9de86ec24233ff0cd2e35ad91caf1ae80a42ca6aeca699b52ae0428c3243c169455f1407719bbac4322a1430eb3e81d5c9700dc45e3be1ca42f69e7fde07e9b51af72f9150794f368d0dc8df3e9db01b2a970dce85bf654f98a262be994f03cb645dd08ca53165b4d3284995907bfdc64b2f6995e116787fe076f40067237f0070878833f8aff8aee7f0361d5eed54d0d872a1bbede6fcb11da4a3be071454bc40d482812acf218409e1cbe27bfea24ee8f9f1dad91f5edc6f2fb812ece62bbab0402b8d8926b0c1c56d0aed4592d9e9028e6809c99cdcb3d27f978648cbaf4ac89c1b5f3bcb79196a38707bb5f3fac2a95aa3dea1b410182aea9e3307109e5f8d19d783e0485b2d85ef22883cb44ef7718c6a63e1bd3f93bf05342a644225da5e91ed9ca8730bc4ccb4d81a9d0aa6d6329c65c1f94f7778f1501e7ddbfc48aef8b0dbd6e6c0059fdcd13d12550ac3490661d276785950f43422d51baab01dae52e56f0582b7b14f0f293bcc8b5cff2e88e56f96a57de854fd0b4c0cf2aa77466ac3b4ee907f71dd4963aa006476350b97a1d4febca1f12c393b23bdc698028fbb4dd41198638f677eb696b8d6f6efb7106726a965d4f2b50d06465b68a0d91abe99d7c65eab75f0c92a9c973d8a6b84f53c32a807df3fe706796f3ee258dfbe66e67f6e464ec825ecd2f1e895ab1fc99f9cb53bc8ea9a457f0aaea68a88d8be2c628bf902959fe1e5c5d2846d03191aa9ca70a822e126adf0ef44cde91aa742f76801b0ebc25a562747d277eb5e66c7afc8c65132dfcc487c99e04e180a61ebb39e2579ca51287c310d2042207124e4487f3b95501dff7b637ae483853cd07e6e7cd340d0114d80006c818bd6d0ca9bca7e1b3e63265c5f7edf0258cc8e3f6d19dfebb1e3de05b0698691a79ac039d436eb9e6fb7f43e501fd1ce2419fd10e53bb4805cb7c9628f665213e9ed9ab6e151fd0d8e07473680f3f82f5c47d8755aa1b1d073ecf6be34e56cc4c530d3e1193e61869f49ad19b239bb261475ac393c439bb7add3b51dc0268a41a9882f2abcfbf6fee20fa6fa134f74f4ad428a6bd49b32debff53c928120574dd6a9083eeecff4e51b501fbcd4a5f38d12fd47af63f82c39abeff1116c00d26229412200bea5cdd7532b74dcfad7b952b0ff47b802b498bf50f322d23ea727e5c626a86c46dc5f2dc8d596776509eb9aa791010bb13cdecdd99ee662b9396c6282f7e8b4576ca4e2e360a80aa192d45dd0c182c7120aed3210a69c4d1e473c5af52b194e07d390925d1681ed31106a4242f02641004fef768947df0a7cdc756fa6a20e6780b49d9e2ee89b4458f9792bb68fcd9912345192478a8d44d59c8997e3cad501cc2909edcaf4cddd6fe74345e1d6897271b95ec7745aa7fff2a42e121dccabb992cffb6237e5285493168b954b3e7aa39f373fc5058afc84b4401aa195cc958a1f2f43cd68fec501a72e05c3ded0584148235806212ee281b192f370521c82a53682982668868c67e1ac425e6156f06e336e9d033e2b550a981c1942a7473f655d3967252993dd7e0697d1aafed92e59997b352ae6702b5d6c646530639747cef1ff696e8014083b2c0503c8d465b078eee6a4ffda328cee22f78de5bf1cb1c0303bff408e3ab98945cf55226fa6c8e520dea05920520227b7e29db1721ceeb8b40305a50c9a03a11ceac319a513cb6f3b61f2196682379ad490456675337be332b1ea81bdd50601960c74de99fcf9814f1a764bbaa47e33d03a755e876a7faaa756f11fdf0e85b927731e47ce57b485998d55ac78b949ac5f1d7dff5052da91cd71f52e3e58322ce2feeb74e527cb2a4c5037f51d6de345bc4f557062eaba56bc41d65bf14217c481e4507fd467c7eeab8eb9e66d34afa7c539562007a1e267447b054bfbadcfa0b31cd5c62cbf3be3260f2e80c0ca4366707424e512edc3e68e3a9d6dc16c435e7156414022368aeee689810ba4465302b5ba4278dd4414554f7df6cec72c492821263961b843f16681df834ce72ca29143e20def48b2d59bee12e46aea8a5582c97ebbb19bd94b98d0961392cd5b94d2655a2a573fa52acebc86f28cf4055fb64c637d60be2ebfcc0a6b7d4f2ae7b75538ffecb546cafed3cf91960b8b1331b755a06bf48474634ee8c6558c189ffc95b69c0c78beeeefffe235b3b7a2b7372e146ee120bf650f883137f1d08d80ce474315cef574c95afc8901f94a2e46460684e75dfcb81d6ef26110da24ce091e5036e0fa9e551245e3f0c30313006653d6eb62fe49759a9a32f9f7c871ea49cdf94e6de049584c47af0e9f1673beea5a5111efe6d96644b56562a9efd4f52447b3ee93b42d0f99d863437af63585b39e7f23440ee3825b810d1889f021ab6673bdefc5b574993771de9a192107e1a0c6f78c799a7720b2b395ecb22d838649bf9074c3af6a70ba6d5984817a663faee99a086dac8170ffaaa5dba1fec87ec0ec19c15791f96192b4f374bfa07af4c798d3502cc00bcbbf9d2b71b898d722182880f3940afe096ebe878bc57d99be453a56f9b26c48be8bcf9045711c006b1a6874e2224b9b6da1369950c24141a0a7ba042cea34e393ab0e0449d2aafde161c12e707b2b331e7621220a7680fc7362d9b4bda41a07e07b239be5d244c06b9fb3d1b3975fdc7f7cf81659f05ef05922c96a28417d31ecf516ac9a4d9aab0763d36fca818f0e6f0ed17fae8d3eca55c5ba0d79e950f52b995f8f340a0b6ae4c81c746e422354423f02a892679f627039d089073887db9c69e16671ab53faca5c8a0d0b5aca21f7b2f600e976005b676b5e5d7c822b76e1278bfc03e62f1d2f6cada45945e7ca2de9108e2bded72388334bef79473ca4fe8cf31c716ade11f2e47af15719e132e38d223ac3b45359f4dbea5f0846e37274c0294c70b4d60352c3ddeffbcac2220da3c703de506c39e8420fe8ec403fa2cc7abce1c7e0b9b393ae57efb367e634f37fa1de71da47103f855e6d6d973b706ba4e21e6bd6941e474ad5e1a2844a0b1838ad75a1cc261e41ba9e888310621cff80c3afbed7eb73c0a3737bebf90b39ecfab61d6b39497d8aae2081a332b302886e96664eb2db8e6db4e901cb98f7be9045c49647a3778c76f87eca3b66b919880c1270df4a66ae4a93b3c46b2663d185ca3792fdaca0b85be4554d219fec650a984b3d0846cf30e9aff0b441d9109bfe1ee6a4002c475f32aaa1c6df2e46251a9b644e0cfb0228e6960a26f4db538b9d4e49df77216c7c982df65f1193e6697e4b0e8308f77ef04d48b5e85a85ab1cef2d00edccb8e345044086857a311499944e9195da128ba4795b32a79c674d1d8a85f99b90042b1586d08b8b9b39242bd4f423da50d3d4848f3b99f08fd78c2969f5bd8fa55b6a3c6d25b3caba536c58e87bf7e88a073965b3b72c09669cb093696a714433b307391db0a2db01f52e2fabe75b08a2fd727e98010d4769c502a1a9abd44a11dcbd959252c3e598cf33a0900eedfb5de183bb8b127c66cd4bade73210609b043df389bbccffe54bc4614de9649070b280afa3343962cd21e54301749594ff76d861abd3f3e692c7eb718f4676a61aa7ac96c7b32e82b68b7a29b2ec2a4e58c3b3c12587c89af8c5167a364b802590af8cbc34726eacc22b89044350f1195cc59babcb384ebfc32c51cc0266af6780ae56abec03c8cf14ab4a16337e3e101b39e05b4c37563f07c0a0b7984e3c5a6388edb3ba07a8b111691571b8fdeedd4d651ba34a03af5487ef439a55884985337e8bda5a04fba50018af49298a711b21c9c4f8cfba62585d702ad9fd81ee11d99f55660c6a8337d21ccb1db2d201a97cc88fb33979b4188de9df2987658400fc920107582d1722cd3b5af840ecbd2aed1af2497abf489b11f353bc312175c68b3193f2c6b1df7172fc6f725bba93448d50dd2163174d58614542482d59b18fde989c7f8aa2aaeacde4d63f41cc8ad3aa09b090683b584b08e6f925fd157050187c0d44b8f4fc8977f9cf2f82c1f5a3c1734dcc222ee8c43ee7f9574eae67b64286af8f3169736a3e3bae2839ab14409e6097aa563e298c293c2c93c349c3a0d352b7d57702c2912986d226f72ed5c3ab99d1a63c12f0022e97548c382ec815d22d41bdb32659fb0295ac8fb7fa0de0c86a1553e058b7ed74edd457a0b3f6e506abd69fd402712a932b45037cc8970d1a240a341174301babce5bb5acd1eafaa50b42cff1a22961a5fcfca8ab5b33a245d6c48308f488525488e55f00fd3fd4a98b2a1401ddfc819d21149454c7a682006fb0f6f6204159d8f3f642fff9e28a59be4d1f51d2bdb85950f4ebb708ecae91e35773a769482896f8d1392c7e7e3c293ed4f3c199f00cc5b103fab5909ca7c0a7e8ad9cc91dee20924536ee701f797ead577121cd8fc7a8ee6b43a30de655c56aeed09d1874f7f4c63e6bfe52fed824adafc0dbeac627a0bbc08ef91aa3a39de35baf2b781fdf471d45828ba006ec7546c27098dd497d78a0e748935fed99d6efd676cd814c247d9c3f0923d0478368acb29092f8aeca7d97c47939b484f3bd86d6de591fd2320d03365f0ae43226d602e6e64976f7f57eb07c10bb78f012fa3d1f2534049395d3d8fb16e413fc1ed88c02f414ff3ccd2374489e9b000decf8f231eb809b485a64ae0cbc806844dd0cdd8549578b91c1787266b06fa772af07028b601bcd864cd87e8d0fcf93ea7a733c8814a974ad3852f0fb971196950800b38bd2bcd29e09b89f57840f8e8c166ebd58e5913fae8750f18817c307d64a86ea602ae2234d27c08bcfad3d50a4d2619d05974ee00727d46baaa61a47cc9373bd286b5995082e8e06edc0f073abe17c3bbabb016f7c9db4898f4746eb2c978b7de677a4baf87db2aef25da29e4e57ee4c2898235be6a7fd35c49c7f5bd0c987d014b0d49a0b387c07df544a987ea3241dcd587619879d8b4f5c782693b52448b99950dceb3888990724d3449a727c02a476f99144595903b4c6b3cf2b8a29dedd43bed9e9156077ef3c84e2f27dd2ebb23a7870a06829b6dd3327ee088956bf538eeeb2a95222d81e767ed0be49576ca0515468ca54bf26c3e2300c180e1b66dd6469ceda66fe5aa64792f8362044b8d4399afc1b8b38eb5bd31a2950edabfb1f096ac90d766fd339cbc8a90d0829bbee13dbbc61b20b0b102e18617c8f45555f5b0a88b5abcb233f43343c3f62c8bd3d8595a5f91fb14fceda9b0daf28a979ebeb0ddc42f8f76eb36ef84e4df7090665920dcbb14fbb22d29f448196e6f4bc3806ded228c321d44e2206dbc1c2c71898fe57ddd77010404bffdde57eb942c26552de8ea044452b820aedd9a27ac31313c75b14cf034216895ce4c752d6f71a5432b7b0256d8c98ce0a1498c1013120e64ad426e22342142780525ace32e501766398b3f49876ddde62b32638d8b3ba2bd54ffaba0400b331683d62d7d36333dafdbe1f7e41149b19d6e48fb68c4190842744aef1b7f4fbe26b108c17dc806cbba339125df60439ebeb059ff7e485c4e043bbcc6fc5ad60c8dca6678a4e584d257edb3101959f281aac11059debb6cb99969fbdab473125e002d07a751afef9b19ec76e9564f330061693559915710da04ec1375c35a27df24fff49c41d836a5b224e0aabc690f804577febdf0fbf013d5484902751b8aa06bea095134057cf96ea4f5e86319c7173ba4d6dc621555cb72c3860ac2282d19ff77566d9ff51ad1d4371256f5d59c23f51431513bef80df6c6d8dd6676a61db4cadb82477b05c19fcb5ff9346f5cd8509875fa4516768fda77f2607c0e4aacb4528891230ed5ed5c52b93787088ada6dd068165950ec906d18f99cd1e60eef2c4ee311d4dfee6f66d1892aaedcafe282a73f03c24017650170b4453ae6c8d1a32d7d0ac0bc9aea15301caeeb6728fe9040f1220a071cf2520650b9846faac1a5472c9cf94fe31f1602b4e6eba0ed2048df185e29fa388c6bd56a617dc01f3cfcde46e1d0f4158cdc078e9dcabd6fc7b1833e4578387e71a4a24689acddc14c856c6ad25b21942b65ad4d82e6f0affc458cd59161ed1eb382f4e5c38e6d6d11c36d571255c6cce19a278885af48cecf426ad411ec62cd52385f53c506b6f9a84e8ac1a8d35114fdac1e7530d397c86a140eb98249cf7fae1b8de76bc56b6b3656cb887201da12d080bbdc516d32e37feda3703504f0ec4c8f3a90d1f3930520eac090b596a8f3d8c91fe30a3162f8b4ce58e1a69d9cbbc8c9075de7b564cff9824c5077bfac1513b1851d0f4dc00276cdfe525b747f7e46c9516a647e40878cb4cc66ca4b0d95c7a86afd31c06ac50885692c3dafeb4d36d537637d79d8e366657d4e84dcbbfa20ed09680a17fb8f9567f710c59915132e8fce83c912fdc49d2865d3fd57843100f3a0936884fa2c2f7387ef878ea68bd3fbae9dbea7fa1f1cfade000191860b5b51b4c56600f7f9c0f50752cc628360bb890c280e2eb87cbe69ac1c789a24f606c59f60d4bd1f396c30b3e245481927ba8f60d16dee369148d28021d1ef395e08e1880b7cac56af71fb2a6ddefe092d5282a71f8716f055b88729c6772a3fc0b71c51dd223868da798d813ed3cd86822a571a6dca49faccfdecee38f6c77a66b42356e72c4893c4547964234aecbd975b26fa8a1951bb042602a3e5290ac1d47fce69a0a4297793d64404fa336429c85bbbb57a50cc6f4be319c9936d7a669f4b905a71012a48c0853851185f4136f28469a590f0e3bade778113ba8ba4dee792227e4922812e2cd650bb1974b2fe250fac59abd350a5862d0efbc885ed8e833741d8e45d26b87307ff1b892d513f41c324769a14a5e26eab903b9d48763d68f1795b2c83cdc70d35cdc8651f0a7bca5f74e335c1d6203a83b326dd26f17993d043ac42ac7376894c2847b9a8c9abb4c554a3b3c2cb8e60bd9ad67a52d093e57ab4850231e6a7fb04ffbae17ace49bc6b5aaea2053cd2560c4a2988279464f0d121919a5396dcc2d2ab0100c5dab92570b8ba96eaac4d53c864731dad8c70df5496a959f77f24d3256dad4a078b2ef85cb031e8a7be8324a08b9e44b9443a6bf70c52b09bbc43ba79bb8121c039a2e5bee9029cdb82461fc62b129b14553a9645259762d4359c8fb1b5327300af579e7d19ef5e7aea7c7d1552e749fd38ee076590c134c2b6ed3a0b7e163d4bccb4c5ff7e67a80172aef544ff3c37e69b1dd2376ce241c2e1134a893e71d6bc789fc046c12e5490767b6b1e2c3342275a80103367f80baf185ef4090f5c378e92b9f6e6b898c26bcb6ebe7d7ac3ecbc8900644b36c16c82a8ffb234ca88120a5d9cc118b2c0342853e93989325c6b208ff08b8db6d1bc0bb9dc257ce60646dcba01aad5b4296b797f7b380adf5e61231c78a03c11ccb4a96c06565af426b696f94ecd1c88c1ac4ff59185208dfdb68738599716825d3b2af30dd22e3492e904966df3afdc2eef11455ed9d476391674890e96e2e5b7dfcb9d5eff18038d6b0e88e1d4ed64c5d136336928e43c3012752010090d9cd816fca9d4408b99b233d0f79ade7c751b0d7c232bf23c5dd47f62226e4c6d33646af55608f5ad2e671c12c6e448fe85a4b475f4d59e9fbb696194b18a0a8374403e5ff43c806c75a3777f226231add9d8273229e201fadea4926c5e708153490e165b7c9bdacd38d00bbb8bb2c5926703a05edf7c6d8379ecdd7da8264b21a7e0ec83771cd085c0f2d6c72008e480718215d697ee46b40d7c94413fa47f025d707f41957659a44cac94d3dc3a42166817d00cb84875a2ac23cd8cb16714f58d684153715370557ac89b85ef15c19d38cc85f0e13228ecc34cecd0c9f87f64de62aedfe5c450c71a64c0eefc0f2785c6c9a028b87cf1a8f71dd2dff898bb350cdacab3e785bd696126bb926490670f078dc32003126857d4f43102c00db99d3bf4d81ca1f332577d7e4c0a26134e8f57ba9a470480401b151483de8d580330075939e04b950e439b6baf9aeb1efc9c4481a582d0caad302e610496e65c3686b11fd523c48db5675a053ec7cdf8d875a424b6e8856fce39a16c49dc495726b04bab78ea4e2a673ea260df7347e8c420269a97398ccc63409a38d64aa18e6590b3e663e4fc7fc651043ce5b571dc04e8804d2b094e8241f02fcdbda36e3866598968690616ecffeb20c58299f99a18f5f8ae1a4e1a3dc536d80bbd41661658a5b5a2ef4bf6e172f7535385344107bcaae6422904033c2cef8c9493b2047248db0829d309b053878ed5e5b976f4518ae76c865f8a7fbc24ad8bc81ea9d39d0d8318bf930de61921ced01cc4cf6cd14d6d7b458e31b6d6f483b3af3fc4784703","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
