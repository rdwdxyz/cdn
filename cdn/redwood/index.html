<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6eac0456839fe5aafe24397aa3a21e5cac86db7da1eba7b9ed4d71f4809ac45342e1bee4f12cadc4b73c86a8989a1fcf54d8200a8beb4ccf068ed55fc8b1422d3a2ca881a9fc681ecc7e3c113cdf94fa111cd00eb2f6d4db2d7e16b02658e1effbe1e9d8f8580e4253eb6fe280fc25d751bebaaf83de3a6392ed3bd53f2f77a6cb733b4a146717e63b94cacfe08eb0c1a6436851d3cbd974ded899ad6fd7d417f6f9ba31cb63dbe29036d36cafc159a9946c5882c066647fcc121419aa9a856a6c191d39d82be3134531c1864eae11cda1b40c3e6ab2e007ad88399e80baa0bd2e407609f36fbf87a53c1de37e103941da79b936823ed1c28cd46958d24350739dd0abd0cd784e3e751a327566034df56bc6a448ecab8143c4c62918f480857dc8338a77a053a968504b8f387d9be721ca93bd254a5c24df6bfaef5f123d96668a9e72b5083256d2729c0321337e06197c0c67f0b28c336c68d0fb61fd9e0a6963292d84ab82cecedc5c4c49a3418b94fc9c2218f4eed9d3e2b1b67d9f52919f3c06192b7e2ff8186e2574e5a8348111c6546dd4599b3c90fb2c68201128ad292448c7e8115b4f8373782e6430e730d1e1f405e6c37ab28e4e0e140125f1bd79227a61af0884af9ce0e174c251c22d3f54a1c1b6735e0eb4c929b11b5edbcbbfa0bf1cd5fd95580a7896d1e7ac0fcbe1ab11ff4f8a1565c9da5e098fa4a77c184d6e10bf041ea4f94d110343482ff944a2479b1e1dbae95ccfb920e5d616db1c17e5009463e826b02aa915878f6d8d7ebaf1dbd75f11fc7bc7fcca7e735608f4c8ebdb885503bb38d76ed4202a0974903fea560acf806049b2eda278f040ee464fa47cb69eb6a0e7b1063e1d182d7fa395cfda0ef4510f8ced2256e98d9abaeb5b9e17b8b7ffc4b8445e1fe230f673a75b5aa4203e6e745e382bd20541721871fba92f89a547dccf09b252aaaaf8c31c7739425261c6601be214ae777ed0c78296a20089d393e70d0db63677a6724ff945098026640e87ade610e6a8f7b10ca825a63ee4d0c773a692b73306ad15f3391a2a64528e1e1b9464d5c214ef407e87bbbf05361783a70b46edd45965800f925b93b2dcbf8346e01dcf1a3c1b6564c5a55106125327147639dde29aff860c9a6caf40a2973ddef5a9f78928828ea54077583ed9f7e3d1be6ea8ed0fe2aa4a30adc02b05a157b1e71c25149dd6b99bf093294e0476792a67d2eb0e03ca893cb4cdbde8b32727b01748ca288181e107241d97d2c68e1149e872ff0d92752fda485b6f49a8f0034f12a57584cd291d5a4c899494cf30db94daa990aa774dffd707930254b77dcf249229a26cadcf884741093b8ef5b837ab8e03e5ff7f8974749becfa82a8c5114309860339dfea75274815fe1d44d9b3ebfa1c25320826c1130b497b3e5efc1a46bdb12a9f34a6549cec4e2c170b782313cbf9335e653b3381fe0ccd9914bf4b9143e5f0b0eb82d2ddef637d6df565447444a82aee0e776bb89106ec4fb6eb6ccf3383bc81e69c410eea39db8dedf199421c7092163b44d670d139562571109ff3d31a3aa8dfbd81d2a557f100a043760c3ff68c484404680fe035e83273e44130b1e28ac28569e3bdd23625d8234197f312d462a6a98b35a995d08364ff53649564e1df65f8c382484dd392b286c76d20d946f13ea41081146991c0473e58ed24c7530fac5332909c211a431d51bbc6a11cf57f2c0c9eca8081d9ee0a3f328aa53196eea77e66d868203a7be017bd1a6a8391c0992fdc09396f4623712c2ed5b137da03206da04b4b7374239217ee4eedd4c21abc7c8dfe127a7025d487c2423792e4623c448abcec46e679985ae3dd2f45efa669da6841266a34250705396429596b0d752edb580b1e57a511277614103e18988fbf1010db755752bb64a680925e5d065a12f822b683dffa6bb640e413d3f2d07aa53925eb9079accf78937556c521ad6c8969bbb681016f2da330acfbe058f8fba85f7074167ca7069028768f3e5755e79794a83775ffe0d85c1dda21db36e98ab8d1e7ed5cb27bc1bf69d58dc26e4974210bc1374382038ec3199271445a15ae06e291c73eebe094b1de379a8b47de03d5d47f8561296447a6a6115bf8b818b5b1ca7953bb17af1994e521af708a05c6409ad5908c290d5491cbbfe564dce4891c07bdddd0c5161ed6e3a1f06b759c8aec1a7098a5c0f4b152dbaf5eb8a2e68c15e2bdbc75228130a009920bc3e24195deca3cee34c02d192a7a3a6cfa7652c52b40f4d7767edd566293fe93fd5a06cb53a79f1cf182d34d46143033079177a1525139edf3861a5166db1a56bebe6151de3573dedc11b5514d7de04b7113229c38d2728ce04a24d0daa20a487a920d53a3367c899e0f9ec7366faf5090066173981c18b1f630a556a0e1410ee845f61033a5def2661bb3c408dce4ba63fdfc05496bc42f8a21871eb79308772f7e681d490f24c2c4742a2f322a7be87895ca40945b6fd848880c9d605dc3375b0b949f18d25ca97e9391ac9fb47247be4e57c7e4d7b155c00c75395a116978d8206cca128f7c91bf0b239dbf395d8c63af66524579ee15554066156b434c6fa838fc479d983d6a0a56069dbfa0be9fe2a387b18cbd7c4ce7afa12035841bd6a9b3164953a9a809ae21820bc41a2b968a28a6b6e2f443bab77645efcd9045ae7bcddb6e427fcdf32f3360f34fd242bbbaa4daf84ced410f048a368e9548785d67e2bc6409a127c716c530f0cb17ea67ccf5f2a8710bf65b79549040cfda17ac814235acf62e844f76da22e2cec990b140b39df0ac6d97fe48dc7b0e07fa1c03e8298eabd5470375c8ce983bf6c066594ea37fcd021cb14f0d7f4efeda1c1ab9d48b78746381ec4e8b1c0c25e9172d531550bf9b6eb1b367e2086864299337105afe3bd0218cebfd62367989053f9e6818f68fe34742d7785d81031818aa7ac55c858d1e55c29ca88f463e0b66fb4369a53d6df48b9dac63f1a7ea2640bd1760cd1b84115c6714947c11d224d56d64b317eb16f50f21fb410062f511fef9ba34f82bb96a778692cba76b992bee06149c5b2e7a72b61555c219cc05bd0b0a34773f0462ecdeaa4b1ab9dd457605e14602f49fe5f1d64c7c63811a3494f1519c8046d8fe6a43ef11cf3cea7a4a5eb35584ff59872e707c36202970a9505b792b2ac8f193f8e71f829eb667ab722908f8a073d18e875be89b11697b3be1ff37a4b9db554cb982b70fa46e1e48c65acea240701c6ba8047142c4c7f2db4db87d05a564b96e2d55d043651bb22e20b53b2ab6d82791d59d00b5d68d1159d36f0260684e8e779ffda7198eb14a924be65f93f78978c5b80924166ddf002c41aff3545caf69328a4a2cac8c2259afb62887e1b33fabff72ee69f76011852c6218ac8e438d752485b05697af5efebe7942f1d1ddda961ac3b067708dc19a3b0d251a3377d5a19ab7aa3cd27cc04fb99783bae81e1004ad73ac61172474de7d52def06fe5fb67351ca49e7112feb5b45b8879052237b4f5106709e298a798b9464812704df42d729f72b01b3cb26f208ec10ce14aa9689be71b72c7d4c767a61cfbc4115938647af6ce3359cd83010b56555c59b61784a95d84c13745d8cd2bf5b941224f0942818d8a5b43382ab508c717288b42f289146f0e24f73951f822bd42677c758ad097ddda385ec575d8fb069b654836f0f2db2b9121830f5b6bdff79c197008f316c6c5b7330e37ccb871b41a57e188d19e83f521350fdc6523b470b4cc4f36a874fba52cca0f21f3f312c0e8b4157a37d422c2fa72347b498c0246b0ebfd6c6f92c570023c3f818b875d607cfc5142dca2018a0ccd3fbbc83a1c2593fcbc22b8e4b9222ffaa9ce0ac81d91825f9e052e10774dcf367ae9ced32a66bfcce9921d6d82127ecefae2c5645c6bd65b9ddefe8c9b7e5d663e94fcf517f6e7cb366a601ddc51a1070eb90db04efbe35d300dd91209fcb4fbfc284244ec56f9474fb105a63a8481392204f8b273451d220018b9543e5dc3288fff208b7ccea15db21dd364a86e23d61f449eaf51daa740a1028516816013565faeb3b8ce6078bb7c8c3dfc3c3a0165be4f44ee980b863450cd044d2a06403497a302a1f2504af9e726cfe20e2459563d51d6de02f2e4d04f9817e4c7f28d26eeed6c9f10b4b86893a5ac76461365a3510cfc44aceaaa0bf3ee6e8935492bf7089188bbb6037af63abca7713b11f8eab04eec3ddc2c926c72f797f80471363fee8750b7d93e2a52d62aca51cee3196972ca2c4411a82fb09663f6045b0dfb5ef767bdd77edf3fa437696df9e8cec74eab11a26be289f4230c8b3350b0bf0be77e950e237403a3b11a4bbb9740a605476508cf788ef01f0a22109505c817bd955c75500c59921e0dc4d9910d86819663c8b12d929bbde14537bf8f6e7b177bc16053c2ad661f16633ab9063ed1714665763f595d00ac324c0fa748aa6db70a9a61ffec6bfb701ef9ef77f91e88c545049767272d406d385dff4af0f9f8740d5fe65a68bffafa7f10ee6aeb4b1340b8de09b5f5ad53f00f4e4a0fa46c4d16cc1e26b7b796c0bcdcde825f912fd599de4a6f5ba9165fab438973ebc9e5ef09ec46c63acf5a7937c186cf78da94582b018fa8ed69ab99cbdd17f646e00e6a14d05b5e931c26e7913f3e51e718f3fae8004422461294c8fa3602bdaaa52da6d21c2ac774f701c21bcc4bb63cee495e8f90c936232b87ee7f06097b12a4a0e051385dd9e9f30796b74d1bec65d42929d5831bb248ccc774350d3edc381af4e7840774ef7cfb102eff2b0155f10654365a18e02500df273adaa573713cf9708628a2bfc667c734d51b9c2ede4fd8571be4944a64fc95fd65e8ac9d519cfce0221b3a9d521bee5ff211f38fdbe165618c01ca17b7861da1d060db778bef2a9da3682eb35af3287d3da83124dc18b01fa1246553cfb5ec830d068cd39befd9e7d6a566add0650b01f8b4f0334a5ee09a46537ae5a1746412e952440703f86f2fe6987f2acaca145655d31ec6eac51eb76bcaaafca064bbe8d9e6f3edd67e46fcaeb056cbbab340af0aa9a83e482db07c88da1759dfb7de0ab6fe03e3121bb63ce8bd5a76b0a98f8023e4fc3354b28224c607d874c9519f65ed0f30d0e2281b1d3a4225c62f27e712df570b6ca2ac861f950c2cc882cfa48dcf28c72b97b9eb65b6717e71095f2673e5b2b8cbbbea9c2648a0df30c2e319ade422fa475182d01da3e9abbf1e9767cff3f26667ce492ba413cd5aa6a3dfb9907e4f3c8b3089bcbfb10e6d3ed84d9706d5a79302ac078c728aff7140c855b5eeec96c3a09e0ed9c0aaaa413c5fd16922da195ca5ed008c8b2ca505a0712f2d17a6949c3ad4f754f3b2f66aa2174ae020e66567404cd6cc226ea2d9b756e496cdf978ba3c862b7ca6b029885635cbb39341805356120be3ba3ce37a19c2a6ba56c50ca5ce145dcf48e4e3913703fbf1cc23549b781b6ca9ae6e01e4a237e9e7e1c5ea7386cf4e55beacc2fa7ee449785f028085274367f40fcc557c94c618a6eb268025ccfdf7bea38ff3eade51036ededcc7bb9e3beb5a96c943fe47582877a44a59b5de543470d5e130a4dc199c64710c7040dc672e55944f2fcf66c98e75599c1ece2d79d88466cf8575ab8356e65058a525594285498051c7635a29885a7981099b6a5a63c428f2019389d75e266bbd07f16cf43637f1cdd4fd471e1fd965623cd83f156b43c0c5152059a5c1d0f8cf302ee763d4774426ba005da26eb3b343106afa2f3f1e34259762beff6593ed86e750d42cb9b7a48e7304d1dbad3d9eec628729b2763667271b17a56460c2ec1aded94b4c0f7e8fb43bc19756ff8cdbdcb884fece4550cb127a576addb480c4ebf857ab45f5eaf5bbc90dcbaf19ca3986c00e12cd3e62cd420966875cfd97e31502dfa6328fffe7ea4ee4567820735c190cb287b6a411d0af8f2d23b8570fb5858574d67ec1c2556200465844f13ab4c235c6ef18fcafb23e1ade76e781f40fb48c401180bc6ef25d8def915b1171c4d2d9bf317b050e56a8a779a431bd62847a8fe0fa02519ef1cbb58dfd9bd2bcbdf6f465e594848c3200b2da28aa3ae4f800445cf2ad117ac97d5e0fd2e3691c5b1fcecca6dbb224788e08c81433347e60bdcf7bbbdae9fb03a7a5f33f1b323850845902ee12394c91e07181db96917d499b8febfdca7f0b8e3ad40338d3536f551268294913b6bc20eece531787948296577450509c06095c06379e358138c98e6eb5936f4295023d55a502048088ed595aa3fe72014eb83ab2e8b1b741b66ce5acc4b292d990ec3cc0b71fa230e7e0c1aaaa6da40707a63c93c46c383c83b4c61cffe0347e69791159044ca1d5d73990365a6ca4b81d5013b66361649b6c2c41c1b9b708e6e2ae3c07543c781ff0b6eca2a64f60aec5aa3f0dcead2d90b603ca709aeccc89cea80b98824ae9cb12011c52fe6863f183f6dcadaa27f5b6f2b0f7111d8a43530db13ee5304fee6633ed203429374f18f156e3099f6750ddab2925b6ecd1679e446d82d48800d90ac5926b559bc94ec7b9a7f175cc612204045e8fb2c823fe6b6796c1d75ff0f545032353877fd9bf966ccdee0a621a9d746efa2b562e13f6861281d70fbdf94d2345f41b9e1ac072dd15facccedcdb44ef2b0e4bf363b307d9d5988d2cdd655de5eb8aa92efa2d1e3d30eba972967d699b55e3627044b978d218259082a89f6f91af959f5ede0894f60e8cc8e20a4b4ca56ed7b77c9a1b9cd8b7f389205a904f6908fb9c89462652fdaf49ab8a6870af8e02087ad517cc49bf1036f9778ed71eac1ab37c23f3a99b653bd44adb8f30e58f62bb54bb1d14709d500bc7725a113d859b5b56205039cb29b01886b16d1f5a0848624ec52fe806c391ed62f7242cefaa1d6c64ff5692eca78ebabc4902f21922bb016b9b566b1759041b3416a81c9f6e62a1af71f3e4b48410195092c7f2c380c00cb2b9e69537093e30a043793ffa46a4c65645b0a62657109cbee79d8fbe735d0bc4b14f776dd5f29da59ed03d6e7efd1232956ceead96bf9ec00c29f9647f189192e20afc77195964827c9446359060ccef9a6a5b9d02b963bb399c5d006eb17328e4c2b5460d3fa176749ce1ab0823e5c0734f20f50db08354be775a10d924d277f3db7fcc4910697a1dc5d5c7b452fc51f538d03e2050e0a2c54f2b80251c3cf748cf3eb0184a4b57a243d64f2e354cc20a32106134203b386e39abd70e90ca62eeeb5a6b7017676afbaef044976b3b0ce2bc4b8e1bc912901a5ca537405627bc1e9d3285c45a370cfed65dff2a7cf0eee16572a28318335c1239ab80c8181d584a3754452c996c4a5520ee2a17fd036d8c696257b348593ee4829211d210662e2342c8ebec19a29f624f9f8c5b78144fcd5b318b21b184d41e6486ff4d16e69c4e4e3b4bbd1d20276b0ddcf66d3ea647ee01597e3c34485c3662649108267897b6c56d8d0fde91200f94ccc6fa8b1ca8184b2aaf20b77479a40956599eda0bd409059e162e987cebfc6a5a8c349fc516f13231b2d810ec9493b6a6eaa47717e1a420fda56c85c7a3b867a0376fdb86fdf85a9f539fa12c1fd46d3cfaa0359fd97440d9a609de1f042e24e21ba41b93eeb85c90476a8519bc3bc78a56c2fd2049e2f3266694e6e8a38b03fb5038b3a3aaf54d328cbf8949d151605864be520c6ea757b4fd837e1e51699b0b24bd7e0d410c7cc2ab49105de869dc59baa730c2d14388d197c4ced0c5e8f65dd4e639b27f80e41afd479ebf2461bcc64ecd1bce7c2e5f40bffda53e946558acd6e1b0cf333b3aabae5fcd38c259a9b481135a91db3f5007999af35a09ed06481af25b12c2c392438a289476ec4656b108b10d9e246c009635b3ecb9242029c94eae615b7732792287076ca9714a941a520c96af5e781a92cbb7fd3bce5e92c8a7abe915e1f97dfd05d3d0f0cb1fcd4151e358bf914b5dc79e856cf9491065b1e6150dff1d9a2347fb6d6fce354ea01d292c98a8f1bee243fe7e123c57862e3f1a64f3017f684f15bc783dd8bfd4b5c364e8e7bf10b6821a09af97e9d4bd33d6bab2fe42ef1da5b2cf96b8188eaffd4bfc358f19a7e0ef7261727104fd01494de175aaafa20a49023a50785bef6344e677b059e312cc63a6e10b9ffca0b5f2213d6edc3bc66f6a11697e1ee7bdc59f1b0968fef8840063198e58c862fcab901ebf120652e21ba29a1d30cc1e5100fad6aee2cf51cae5eca3be76b86dfc93dc9f4059811b5f85c55c6b91471de81561ea5a6e6c316c667c97ee5a3fb5294b808d5051a77b4394ea373dec39dd95924241373e3397172c7f2bf74ed81dbc603a6b83ebbb1884fc8274fa4fcab230f70b2eb52876110d7adbff171a13aa59c8c9f33ca4ac87b1a62e0c97371054a6f98538f7ae02800c809d8f9d159bf1d88b364645025cafbafd8c69fd5bf02c350dbe3e8988d4088a8bb59b9dcfb1c95162c92967587cfd4d4c6439c7fc52dd4dbafbfd74414e1984875960c5f624ee4aa71d89ab8ea2baacd793b3ef0971f0200da1aba8823853e43eeada4dddacbe84cc397a66e1a52c05a5247ad9902b7c2cfb8554aaef9a33d1331216dcfcdd03f5b6198616031966a8b5a7d237eea2e4961562f4eb6aa6e25e43b2245b15d78869949fe03695b4155a60a55fb5ddd6b5e851dfdcbe4aa9eb97e41732420ab45caa9684044a7f2121de0000991b9eb7dbcedbdaeefa06f408a39592bdfe22e27d0629f44fead7df8af0921eabe24db157689d28a51c7f69143927a84fbc100e8268926ffbaf8e0f270be5996091ef88f8da734b5f30715a114ecdf11fb5dfa95b5fb17756f0ff397aa0f88eb4f1226e20b87ffadd0077ee5e9c0d063e926b29f0381002783842d40897818a2f62191b4b6c4655c3aa07b42f0a16f56c9e165abb12261a86aa0c9bed2526a89bbdf672af1fcf05d63ca16ad55d09a671daeda4d05c9347ef4c77c7c6d20d8ecd1ce27cac8b45ecbf61d89bec9d6e9b6b7586380100c1bc1c33b2feaa8b3dde56e9bbc6d1f369639c29b8a1fa4beb62d713d2b742563605b8900240a8f026b12a46e1f700eeff2c5e3b6c4ea8264c27f43a52b5fd3bd81e2b9d7e1f7f8ba33e3dc95e6e61b0513a880a3661ffd1593e6f81da5732e7a28d2f7625811e00b2e6fa5e726c3b19d0c9151d5733343c722e682abd06b1de4ffc9a44eec64863b7cfca2a1e26af30e36238f829b1ccdf8a942922750b4f4e0a25bf903b456d10db5010c9d7e9cb68001dd920ffa15ab7cafec4b62057c4c5d47f35e071dcc3728e25a530459f411c63ca8f48f2a322009f933e5743abb2a38ebc01372a9ff23472117885217032a15564e08c8e3e76bf0f8684b0a607555196f6437fb4fa5507252f6f1de52624915c531c8b662d628958a90e652ef8f529cc3fb1f55e8f1168e0709550e0f881f357afa0b33786cd78d79e23803c2c061641c3134ebbcbbc93abbea99e652b5e5221f518b5a089de8b4d0009df90327e3bb39a2e44bc496995a5d921e659b66d157eee5cafca4eaad3278e50c31aeaaa091a3f3bcb5283cf346080111868ad671ae1d89e8e4c62de858cdbc29323a723c44779e81bd53fdf70cc1d5e466e6d28ba05ce0daafc23a560e571e7120c33f9d2eac57210b2373df7011a06addf094b8c0277d322b2de8a0dd6e8524144c0060f1d1724f84eca564d818bf3970f383dccf7a9aea125710e1be661125e95ca3d43d016054062bd2054b4379c83387163c242204d14674cea67c738b63787d47ff600207cb88bfb29ef9cdbb916ca53e107d7b120442eaced14c6c08b3c533e38275067d2c3936a572e57ed5ffcb4b1c7203cb223f2fd24da7a73e9f497dafbf1df4987c721dd3a9c9ed5cf9a19b28af1b4c34455e363ad47c1889cc87537c1441fae3e0963a0f7bfc71c9ea8b79c37fff12b0f91e036f1bc33f68eacb89b061acc607ee6147a0dab71eaba2b6919db91148d2871310b93ce57bddcbabaeeac1fb33981add5e9fa2d342e09fdb3265bf24bdbd96a500235fe4920f5516c8dda1398ab5621032604d62e07b958d7758b143a207c630e0fe271a990fbe469d1ef2e1514460ae05d426b153399955fff80d3c20757e93134d414bb47dcc1acb55a3c63ad0853fb52e853b078da459c91c6518b6df9e6a4f731e1004ed00974bc025a646725b1093712c598c90f0cf909670170b41a9eaa1c2d06d138eea291f9880589bfa8f0afe5e0b03d723ac514a30a5dbca53f8ee463257bd3edb5e0ebef135d6190af4b424a49e62aeb75f803bb7ce9400e99ae99a92d5ddb4bd63463c238a5e198b042f2127b572a3213e5ae9889495877485ce6b34e91ed4e0f132f8020b6932dbea8a87533b5cda0a327b2124897fdb6c6d6a3806abe8696ee3ebbcad7fcf9db5b3941ced837acb76da88ce13483d65ceb414c1681e1b66e3863a083cbb3855d92ab4a99326f1930bb8042320528ba8f299140ba9a839558e2a210a75356f403d284b632211905ff9bdd727d9374a55a277c91ef2ebcab86da0768acde68046b1bc790731df52f3368d9f5937731057bde88beb95682b7a352738a8cc805d57a91254290c95ef5fedcf5755078137891bd73939aeb1ee7444d247d096769502f199200a9fd706a02ec8b491596355b78a200b73995bbf4b90e4d584cce32b67cd8e547e4169249147665d068ffd168830ecddc85e3aa970770043fdafbb05f9a772f1e7c742afc4a4c93a5d77d5d6ec21b03b8c9dc4c6be82c2e4a23b850801b7c66c9dbd061c1a5a80091ee6561b9933bc8d2cd34b3c79176cf2bb74f1a166797fc0f7391b7e5682339a72e8368be2f617e7e89a548f328ce5277148c7d3e90be6de918c2b96697b6b8d26842022e0e7954843f0c52b2472fb3f2c6540da82b53b9fab9421f90b9ea752d3c69557e2eed6cbe7a9eccf11bcde8f4d2567b8592598f2c61597b7cc48b6e58a6e906e5ef8a7e72ee9794eb6869f274129935479e34eb7580b0509cd36478b421e62657e46496ee2ab39215570e4a3c4228e70a30a4c758a3251d2eb85638c2f805f3d611165d3beb79139982b598d7ea3c916823fe4b05c20614b685765cfc4c752838d1c133b4982961a41919eb9a0a34a021f3e946fdb7bbc914c46c8b55c4853d870edf8f98e4f1642d0eafcad3bde99675fa71e83136720ad1d9fbb1c1fc800a92415a4f9e6cd9c0d6691e75c7945be01abe4770957d7ce4bea9e713e9a376ce60b9f622f73b743bb5f7f9ae83e2f996b6f5ed472ac2b6ef37fd08a42201362ce79c8f5ccecfc27767497a796d38b41a1be8bbc872a178ebfd038d9e08d623b0fbb86f4aef40a2abe5b80b3df0bbb8dfaacf1d11e089c5379c2160fae73b35a673889639e209884be079c15d104570b99909b84b62237ad37740163ba858cd80162751c3a51fe6a975f00a68699c1d98d6ca9e6f553eda53655961979c5554ad381b720e3493f5ee9d3a8d2f426185ebe5cd244bdd986c4935daeb4d96a63eec041e1c0376674791ab2430ad246dc0d26b35287954d40d0f9a85a44eb0b55301fcb5428a6dedd55b3f091291914ed75fbf631363c553e42d7196274c5cbf0ecc0ebf9048f567262de2db6c2fa6249af266e2bd49a8de62607a5a214f8d1a54b6a7d1756b7a95f51f3ea2615293c35dc4b6a3fc258c58c18e180d48d69cd85edbd0ec87f6ce2a97bb0462d23045b21a4435541f86a00290e3b5eddd0a9b2c0b002805a963ea3fef2fc275d924530a8c714bf4c3d38434f33cbba9c82e6db67f9b4d23356e733929962ace233f73273815b6c9460841f37462d04cb2d8900151a4b967345c06ab832c322e3f8abcbc2d90b55b949899c3fa4e3b0537edbc6d3fa3800f142ea115426af2293c0c28135352bb7c001fcc06c88b58cd01baf5f97f73b5de4d8077f53209ab92d15a3e886012b9f964b91eadb3ce4903f24def4a3f50a496fc54d98b49c34370b409f5a68c49e1e70aa87cd43498f74ddbacfe1f2137c744e245a76dd48edcfe2b5acbdbfc2c6131a702d9f25adf3a99961370e34035b74f476bb01cee7edba8f18028473ce3b332c6e6bf669a21e156e69cf1113b477da70e18da1fb8398583747eceba19118ce9c68def0711ecd2ade83dfaa054ee52a76341ddf970937bfca9a2d3e9307fc903b28bdb2dfe5cad36dea44ece79e0f831e2695e0923d45ad6d693d8bdcc5d0373ee2e67667f12e2e302fad7a193f15dc8bd75d28cb225c28b35bbfa6ba890eb15ef4d18cd81292e6f839d7adac5ff0a02df1399184aa4327389f8b86740d466d4d553d0bf5ebfe6d7c341183df2ef1b02b0ae2b87c3dd7171f6f7042c547b4314180e5e46070ff911a76915773e48d6bf18f931248dad69f0c36e55794e6d94cad9914abe9dfbce7b3afed529ecf8a9f3cb1c7ead5b507612be01e8e78a9240a8fc6a5efd0c0e60fcdaf68cf0bbc9c490735379557652dfa851e58a1cfa86a0c27c4d53d24fd8554f22c0b71e665410c44138366d8ee60f65da559bf8715004f6f8048df88788f0f2363df986b04221fa7efb3d5ccfef50924d11c69f712433d5116dd13bead0e4f295c634ae53299e2f3adc9965972ac88cc59101066ea8bac2c6702cb50ec3e78158715b163d826675ea7f00f78cc8344ad4ee95cde9b7bcfa9541eb031630aef9046dbcafe336717fc120aa6b5573403e3e65bf0d718cc32937a86225f7d50adf4ce21c42a0c2311f879a9a4d4e8a32298bc88cbdfefd4a011c8f827160927259acd0d110705d0f2d9b23e1c09bcc4666cb0198d060f47da6b20251026a75921f4cf67d2058e879ef1163e2b84f981d38be82fd8611d81625d46f12391fb66de16256c57efe6ce77163621a58e5ec808ee9781e6eb5a8d037d5e6edb57e6fec6f7a1becdfe75762c22120e2e30072d89d3fc08054056e18f16eace9caac524fe95f4cd8990701f575b381ddfeea170b00128a5f00766d9ff8351380cc226971007c7706957e054e20b9e549eb5613966f095c587d7bbaaf6263b5683eb145197da6354776a05a8411088acccab1c5016e4b2f63a01663bcb588ab502e3e5c4da435ce34ba22cfbc1e79cc9744532b8ef6367edd702115d82a7cf028ab42c0895914dfcfa3243397d7413c7e04821d4bb14c1513bdddbce2ebb375de0885b4caf4ad8219d2d7856155c7190297a50dedec34784b718fd445609075937154aa28617ea5d7549af2a1e57fe4b4a14c6d68e3b95a5c5fbc2b88f08285f9edd7121ffbfacc8c9b3f9bf696c426a4aded48742615c8e8b3dfed9f629be680516bd8b699491789b081d861ed251a227280bea9debfca3be822de0bb6205b78708e851491f1e1c69c8f20b00f0ea26018a5b401951137ea8ca9de14b9fc3c4abe113f1bee00065853e160e909ce375d8006cdb70f5feef13478fab7c8fc777fb98e2dd95a38cce3de3fa09560336bc91af53628deb44c7e5c4fd56cd0834c2c413bdadbeb6f5932eee55441cd099f4f9910e474c191c2405e891ad5f13fcc52717131b7de24ce71a93ad90d65089ac8be6764606030ab617b1b989d94d8082d32f118b29c185577008c8418b5f33a5f0268a7784195bc32b27018769d341d6bb107ff11076a4369a4875f6f68723cf04f3f23091993ec34bf36c56914ba513839b869a34d3efb3c60b1e904ee4f8a05eaf6cf8a5ff311fb7ab3756bf698cd0d28a7c6fd424e7f43b39fafc747601cc1835ab9c65ea407c790018b00df314a8aad5f8231faa509942eb67100bfb14eff512f086e1c28876679c3a96a5298abdedd674d25f419354203fac98d5bb7d742f6e7089133eaee90455efa9772d7dc028f1053907bf6a2868c09689d4dae1714007ae4bb419f99d906e98299e6bd7f3c5e297726b6821d8235adfdf93d9ab0d3c466200967e178614ca03daf00ec8530204a8f6764823c0bd3c916de02627d218d9a21f79d4af8447e4883f78dad46d82b5162d81548d50de50f624b41674b7a50b0e200fe0f9be884ee17865ed51f69f23c8d44675934082db4b3dc12c66b7cd5b37d27e516b4587990e08639af7ded68a8786c7e107952c43e699bcf9391a1a7fad4166bbd74fb5a4ef2200761543837b608661f304292beda897afd0ca4f102f43ca84bd2651f8a021f06443c8bf25df4ef3fff5a2752e9d888622d71fce81a108a806e0a380dd9136c1d89cce30f9ffaf8acf77dc10e09e270a84b8f0b0dbb3ed851df0bb2992ff5b350db315f6338fb696fa8fea553c546b534ae0dc1795f6afd1254786e94e700899df5f2537a01e79c71f2023a18c0ace3a1adbd4248e0cd89a1c0a52f2cc3015bfaf461f8ce07e45664195c460acf7d6137a2a8877c72220ee3187523973c96a245ce4b0d5d3ca275e69a6b8546a4126f26269e7052a211953ad3d63d473511a59c56c4b7684cb21a52aa76cdd3d96abe262753747b0e5c991e114dd8be3380424a2f08aade16462bfdd9b76b7eda166719df429b62b02e907013c0e90887ac38820ae1e623a65087a153aacf5010de927fe3846a4ff6d6cd61c6601b3de42c808182e39c375e99b7f23884b7851726e38ebfe1831a2067daae61061fb3e52234b4415b543f63945ab5e61276fbde9b9a3dfa6953aa6685fc9be6724cc12a84af8c26c6a1128727f76862420e46b1654d8ca93b1f3ba170cbe4622cc626a26b22308eec21c4e46a8b40b051da01149541c5be0ea2635ff27d6a1d9b8cb7b564b6a829408258deda0df488caf3c251f37e2b0ef7064f5b59c292a2d6bc47d4e887f3764e62dbe435dc14045c8af6509924bcedcf627183e624e977295f967771d32d0aca196711b8ba5011885bddf48304a577aef0746b2f2f8e1af4194d506356b272cd88076f728dd7bc6b304cf4ff497e0ececcc8ff3fe2d2f59ec49f0c1ee228cd550c3da3e5dd26a026a94656e8d6ad40bffe97d8c2e701cf330fca5334c245b40b67fe4d36eff674eefe8145e0decd7a9354ea77acf5b61a358c83e2ee9c76a2dd285044919af4e24155361807284f5bcbf8cddabf8e88bb3701900acc509ca7a930b3a0b66e69fbc015b19f6eb890fdbaec5e630a7d23d9639b486c38e4683b064541749316ef270c4c7c2a0c42ab128e2ae3867a9b5eb83f15c005522bc46fc9379676333a5be608e13a7ee6f6f737515cda417c9b840eb48b5491159af84622917793128315e67774e559074d3a85c4e61157193d47c51592748a8aa24145c2eed0f3f452165207cd7c9fcf543fe7ad17fdf29416213554cbabcd28a2cd2a80f688579c53ffdf0f9df91ade0c7a637852d9c8fad143877450f3b00947899cd8782fce8f6e1923cb54c356fff2a79f60bd9df90e4ed68dc1ba3218ef73b8a1d2fefbb9294978b677b1702c279782c3e0675bf550ecc5649f332ae915db17420cb385cc0cedb02503a2ee48395c05135fda451abbd3b76e1df699b020c3fda4bede4874879704208a016ee102fec0f11f705d5339d68d066dcc3d75d4add088cce1838e60c2046431a3c19b4dacabb1ff9403f7872fee240edfe8f5e4ba7fc84c3f7b6503f6fa5cc60bd90bacef12a52a670858c3f0f5bbe84201f19bc709692137c65675347979342d60d7c12d775db68a0defd0fce0e0788cdeb500b2ad7af9f8e1cf3cf4f22dc6024e2bd0a5d9873a0a30926b8b2d91caf0040ebf5eb728a862f0d6d5c4c6dcdd392fc21e5fd63732505913de2bc62d249b2237b38ecb831b10ca093df957a9c7208ad30f459bb69d1110659feb0df402fd02bbf1d3a6e63b68f0c7c73de2400ab85b7fd5f3909d7aab30dc6588fa2cea13c1ac0ac0bc9eede722b122d4dc6a4a6afcb8c1c7666bd2ae42ee60ae5b8e8112434550cc5d55d816441e13d37c3f47afa055814a3951bbf4ec7e92e8b426a33f54e1524380e4c7a3ff170cfb7079975ac2cf0b2f2e249c932ea4f21702102941177a43cd690eac2dc331516949ea8c6ce8ef11308cc997d8ef3aac074ede688aad327c05cb02ed38a7fdbaf48ad811d3d12263601ffcf642bddbaae4de99e37fb4642f347898986643351758d7404bd8ce25d8c91c7304ed73498d3bbbd6fc20af62e02176a1a82d988314808a6c8e6b826623e0a96bac3886d6713ce67ac502c7772c96dad400284cf0f93729f0a6b1b2e74d4e6ed250add16b0d2a8309fef1ca8976d73d9e8c08b32e57c3c048396695e934f1e1169eb57829f4c2a7aa2a38e6cbfa46c3ac23c12d89ddc88d84edbddbed67007071c2e4a694304d5a80f296322bd76fc56bfc1ed53cf4a722b6b8df2b69c56725e20dc98b36d21ea5a1a442710862820d74755f952731c82cf5784dd3f12f608cc4ffc8e961340db2c1194309157864558010b992ca358aaafaa02bc14227e06803c40e2828e5211fb0d908835ebc9ed4eaca9c72c466cb876a9c21539f803b6585486a70c9bf5fbc73b7420d9129736865f517aeccb25412042133a93a95858fcf83d654bad37d46a871a64b596a423452f18b4eded8fb2a243164ec2f3b62a2f59c9fb5dcd5f9d60f7e9d8a9845b1d70045e1de4bfcc83d79e5a99520b76da7e4df7f588cde56ae0c916e012346471edaad62604e452185fc405d7a9cb05655727a9fddb99cd0bce9cecc05b41ca803add6bcc5c8419efc7d739c37423709dba0e6779ca910478a026cc89e7fe1f8e8594015de179bf8bedb2c721f81e29280a9e7baf01f437d05c7fb78c9205cd45ab62808668efd77b0166b697eedeb9822ab4e3189e556d38802ab41b644376936640d11e64a788611bf6bb18e49f0a333daacf90f0299b10939e27adfdb508e80b516817c75e391f761dd06a8b1720bfe2d1b41b672c79d32f1239190bf16a036542d9adc702e75b7c7241831599cf44cb45085dad184ec6b9e0357e0e4801c57f4d0dbc42beae5462fdf9bb1b7ff523763193a7ede3c4f2f0d6475746057f161025d7536ad504b17b7916c8704d6f0add578f048695a30cbfa00d74fb36fe6a32120f1ba23caec7e028ef4d615d6a646cb0eb0c37dccbf05c8a5588bbcd2cda9aa5ef1fb61cf13fa31b40e02530877c826a6799ec4f3dcdd8b16e7c8eabfa4dd627f8f2c725e53e6291ae8a08494130ebe2a90ef43bafcdeb6d0f28e2b65654eb15c2c9e7b1c0e32b019ea30da825440f25122d075868cacd07942a87bfb188cf6215c688788fc073799d361cf0f7deb01fe5146b2a7d2635f91b00b117014a9d62299acdb6ab5bd70dfbf5aebeb2b5c7cdd6cac68da69945fc0ddc74eb988683b3190abab38bc6c56190e3f7c23dbe19f5adc99b289aa870133df15ce570b5ed31120974e6f3ba3106403b16439ab1f098d17527cf41499b5cc3a4a213270a0e64ff5975d0ea7f74d19abdbbba54d07963e2034a7b15a5c9057943ae6b2fb66cb149b54e9e067029fc94e8333c2354e006d4c4e40c707691faee6c0e20497dfafce03e11ea3e503c371e881c5c059306f702b774ad5558606f81cb55c47a7128428cbe905c0abd6a2a724f40fff4596ab4e0dfd4c711948e306d7597e983c4794818329994cd1f62b77aa343c32bebe4a7140902421d5f01d422c4611bb11d6b404715cdd24fd1b9bc68113492336d9b010a137b394f462d53d0fb9a2b977dc94d3cbd5474839e8308e3833a960a89df2ac84637636978e0c50fddab1a6c01428ef8a9687b76c9bec63932b85b5aa0e332252060c7deb5ad8a796594358422e43e5b34d69b8e20cbb03e4b62735df2e0daccf51f0a89a7fac71eaf2d4704e0cdc82bf43b07f76de7ad02e2dd28267a1d33ace2785252a649d9529df0ec2e7c079a57f0e315fc96e505af32a3c60de03db9ec12c7e787c4117289b1e4be8ca12bf03c64bcac95cc893577e247bb9db8d4e6df1ff7ef358f2b20e7576aaad3f28ab62f610b48ee92c45b296b464f9a6f9a4eabf506b93c6","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
