<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ca146bdf9536d9d69d45692e3f2551d44fb317c785e3bc567df36b883f14e9721eeda01a80edf9eeea473e8f88b5fa3b45012261d2940d2a0ad813a82b8df1a7672d2989e9b34d24a8e2000986109f3e2acce3d6746f2925249bd16393e1c47d5ec74ab2fb9283c400b8b6f8bbbc3f367310b1e9bb77df34b70d26b98f620e6f4d04196c8d97bd4206d2715af79128f647b61fb9236f1148d14cebc1428a379ba4f63a2e2f37ab560e41713f0b86d57837d32008b972216f85a28e925f92c29e214936bd31ddfcb1ad31f3bdfbeb969bdb297d0764a48c2c9cf83ab915218c482d8056a95706c9d667c58a50b2d45df17fdcf2b5e356da12f04024dea1b9a4084e8b674ec40f7091302b62045dfff4b99b5c11b6f5cf58ffe875061d998a7689d16009bbf2c4f9146c48ccfacb7c2e8b29f8fcc8f2ed36dcfcd3c7ae5dfea698f2da8445ac3f00b67ff2d5e4d32dbb79ab961a8102fa7a09928f70b91d8d6b2bcdbed92cf25f5b3cf5601610e32d0835f3c7d632cdd96e19ab4feca80fa78f9486b926b538512d16abd5c90e2ae270a1c3b7313715468df40c706d32a10bc83ea47f7b78f924333faa35bd41d43d8af7bcdbf2db61dd6455b568758e29e394a471d5e45bdbd09e32bda2cc0e0f8a72df02be44d54c8839354c455daa550d9cc661117eff39c3de46c95466c1792e30d54142042a487d50d36723a1c7ddcfe56377774658282bd3a531a01569fac9424c2730ffc8f8ff11e67388abfe3e1f0a0de5f34054831754c0a86d780a7d4280032fd9dbc93daebb1b8a0cea1ea088639bd9b90c3f80960f88ccae2b904bed34927707ba1879af0d8a28bb1d8c4ed1287630b986e62bda7b6a0d4d51a6cdfb25b13e7256a1ada1d36560b00ffd1d8d50922c484067290dfd4b694040c6ce560ada83eb80560497538de75c2426ac0b25a03d1868e149368a5d8739f8b8fd7dbcbd93b7d6a60e84b222d6e51cd48baafdec5664f1abf2b3d7e1d6ab54d10505c6e2750606142a35741771953c5ccc440610943a7b5dacfe511d6cdb8af30421508b354d8004c8868ef29424a8761a9e922e2a98d95dddb4e7455b6075c9e79b6d8fd59cb481553b7e1abee27a0a6b09f5b676dad2129c3c8b2ad578062d5c3f03951c5540206b3543d2206fd2d6fbe365c3d198115a4a47c2d6d1240b96d344a6b2fa2dfd81c4c578a644b4ffadec2dea02cfb9901e30ae41255bbd5b065f8118d0413b0349d97ec718e7998d7a44d0e0ef33af2a6d9ed9f4b5bfc8e1b8b32326e013a3eeb54fb6c8228d0e92c602989fed9e8db43be831dd14d167a2080a4a0503c1dcd0b043ce76d5d05db57df8f4e2488d6ff0d982377100b5109bb2d96bb3a60a1a14088d7b3590fa82297407dcba17e447c394ca67e433e6d63ca85bcf74ae20efde22043a804a9078340db02d75e968906f7c9ec1b5eadc4c3cb05b9a757a72afb9cc9c133d142f6390ad94a3d361850ea05e1b5e250b7d08b362f4d05c39c671da56057a827186af90da517c75fec26e6f2b93b03a82a1e426db6e4563f7a94254b7d9d917366ccc9d252251b0326e62974922ba6469a5f74c2b5a2edc1dd1f2ff9f82a446490f3797a491b17e7c8c7c036a65327ce9d03d3625e2cad3a69bf8d80468ecfd83f95884b107989be2c7724964073921eb14eb5a94f930accd11bee30fb3b7df1123c95627a09cfea9e6017bb7d3dc1e0a180bff5298c7e31284dbe07a69468bdf913fae2a1bd27cbefade8713cee0938ec52dd2d772427e94ebed6903ed5f7c5e89ffb5cd55250b038f6a050244f30bdfbbba8f6c02e8899c563dcd3f298c3ce98d524dd1beb5bbe2c27123ff08e220958df9103faf188b68e3bbbbceeee16c2d9d30a6ece3432797c0c638885918715402d32cc1b762479680190e3bfdb2c4d553c25582d0a22f55bf357cb963357e19679682fac9ee7856a5008648a756879437d1c0cf2305b872fc49b4db1091d9f22647426d72661538111b155c30dcaf9e01c09658788cb99f70a628743a45d91e0f33c7acf56d82715e885c4d2da47adaea328ad6ad6759a65adb5cf080c289f07c5c0e56c5b1330a83c11c83b8355ab304920340f7f22cc9355735d9aa971b2a1e1e2c8669f2a16958fe8f6966de959e11327b1dcc3539eceed6a75c5ec0e842ac35b7744c85f01db5b7ec75c052d15cdb27fd0419881aab286c85f3da2c1efa9f31490ced1564b0207e3f6e7d8d18da50ca2e1570dce3248b1fd03e5d99846eea6b819fe5401076429355ff154e2f3786ce21330c84841c2416ebaaac31d36c239ed8cc64660944a96b3b7856358c1ef0d02e155d847aa999c4621b23acbfd5a88fa5c2c6d21b6d2d3467b06d781b3aa5e77b673f323ddf05e3654c9a3c23025f67744b0e2d833a55a983ebca112fc22eb0ded295cf1d7c4cb603b30d8edecd7a7c0e11dc96c4e02ba39f5721760b5c5b9e0a5258bc9e85aa7a6b790ddc7e76892adc6a00f87d2d9a6c67bce72a02de83f7a5124694c8db4cca82a61ccc88b1dfc57f6512b80c2fe1339b233fb47256f68d64f59edd7e3bcea463564eb13e8224837215cf3a2cd803a8400a67aab71f1ac7e8eac8b16667cc9681483e4a7c43e08fda263558a426b3d6aec2fab2b83e23db4bac228fc30afeb2da8be8558eadca7434303d16514adc553980d88383f8afe0517df24c5b0856a832cdf6e9ec1e2300bd79df42e7c3cbd97f29b7ea615e7952cb76ea9bb956a6d7ec945cc7590ad1f095f50086e24c7d0a53e5d9745a64be1365071393f399fa7bcf508b970d455d8b6acc15d8c650dd74288acd812a119160b17ff7fe4b67daa88ea83c52d442bfcb9b04ea5cc1ee73870765dbd7c43a522a875ba37fb9852b8b1ecc802e3c1db495475b58ce2a447a45fb68af733303de004055500e0e573bfaa6f92122265fb13ca95ea17cdeba86cb93dbd142aed1f2db3d9e9ac347df8e4d5eee8ec782f5e8b6088682a32774e127fe2e5e22ff8a38df2c898248df37ec1f1f092e30941c848239731b68536530fe5140e50b4c37b7c327c46e4206091fc2bc63fc27b3979cdb33fd5715b0f3286548a4911bf4fc1ac93f55232ab4fed25a1c0a52ae5e80d024901ea5b271b8cae1d60d63be902f8d69ad435e159ab14d503846698cb3cbd826d0a63a3eea399039aa725d2b85e92b1b8e06380201d523412ee3a663709f0cf94ebb5c6737d334b3f6bacbc5d245d4d8034304f71ff2a48c68c030ac846b7493e24f8f558ececcece4da023d96700cd88d0c9515d883054afca2aff7518466b42af7388535182d16b0cf707b5e0496c2101b99f5467feb76bc2dad74704322f30cebabbe14407e9e3f41772b1a0e4050393360d2d615877f1300468aec3629357eb4cb153ee5b56e2eecbad540d4b0579d6cb0c7d98eec2717828cbad40bff5d38a19f5c3de4a183f83ce9d9385946acf9c8f6d5971be05cc496ce38106e438017c1c2a533262660f83017581fcb06ad69fb2f165e32d9625d5e4008506dd15294e1e7773d64440c049e4ba57c2ac5f9d3b023fd8189f4c0da62052efe3b7dd78978f356d3432faa8d3c76ecdaa35fb2a78b6db08a4f1188cc034a7540c8f25f6849e712faeb5ba2f2a9d776385c89629eeed36efa5ab888e01fc266c36c3f20528d2bd88a64f7e3e6c8d15ceb0f5c86795afd535dbf8370236280fbadfc7bd32f5910c6c1940bc0e74cdb45544657963f24460fa2a503d69236d731d2013b66cfb583cba461f881beeb41eda150a042728ab642dfda04bc3848329c5a098bd0266999284efb1003dcd4dc30e24a3aa8f7b604bdba9f27f83c0cb7b8e241b5d94c574f7925c90821fd301efedfac4a0a0548e736492fd66cf97b2c27b9c2075ba1084f4007c81287b28a89380177b1e3d8956f00bcd0450ae2f5cd31802d582139cad9339aea03fd29f9d52353b96c7b6f76418fa52deb2457876802d20999ede3c6a92bdb77a1c1a3452b7a21a75ea314e74b94a54c015f121dedba7a0c65a5b3182e318a074592ac70a9b402f2e9b6e237b37443f6e4670a20bae94a6d79d03069905299f3ffc62932e5e0a4eb924a0683a56950c2fe841a0c804632a7313358987b37df66f841e67fd4c14795ce7a802114487e6b81e9953d8d4db93aed91bcbbb6e2dd07085e22f8bde86cbe8cfd91d708def6c771af760125e7641ff1a30b5aa57ad08fdb420c9c0367a203c0825c01f95c85c500e8be24408bc09b01f92ab724f818807741ea0cccd082c3f473e4b5acc479172c77948181f5452142c19cbbe364480d194089e6ceed02194a2c87208b725185eeb8db2f1f4073d904ce8c65cc748866ca0568d73b37792f9ef71cd3a1578cfd4f4b76f1e4b4026f4ae2db85d37172c6c7c3e9cfb71b8b1ffca8ad73d04ceaf8fb522921c230884a9b16050b3ddd6b5edc7ec805ee33f00e492b77dc9ad1722267fa2412d919ee6c95794f31743ae83c54e06201dc64598c841f106b7d6aeede3eb345065ff1b6e64a3a0c1a114c88518959f0798ca611fba1c7c7ee62adb5a1ef32200b923c8b16915a0b5105c1ee2d6a098f54738069d4870eb6beac7b64263a2e2ed2c9c650d56158b6cf62ced7f7580740e77ceba1b48ea461cbd1eb6257c8ef472690f96c3ee24ec8bc0936e09ff8877f0f206db7e7219b34b122f695790f030aa272044f0a9cc29815fecef5a363999e41c676a93b5b3a70e3a10af6a78b9472e56efb671300c744426abb04ea09646ff3f414f9bc4bbfa1227597fc7e13ef99c3dbd8c8b35bc5da8ab4b4e8b5108984be07d608b0fdaae571153df15bf1a14ffd4d03ef945eb436f98bb5cc076906e10cc4830e3361d90bf93c950a9bc380bd0a70426d91cdd500901d612dc6696eeb8b872f33e6881db1342410f557569a6480b590a7af081901e573fdb9489061ca6441f681e33733dea32d740bbf6b7dff3c84cb8e75388c4a9ddfd6861d27fffcae0d27ca8e3888fa41e36644bd238acc185c8c618b3895aeeeb12ab551c55b749ee9392a751f48b9ad3a5df95eb65e15cdf6eb4bd2d0d39a6d53166dd2a5276472020381c0d9a720f0954bec9dc68ee87a3aa4554fb0aced9e88ef1919af1364dcf3a60445b05e240779ae8425309c58ebbd355f508e15fdbd4cf7e3623259c8822ffa379b07e086123bc4888ce3a72c69926be99030fdd56a45bbf408e853d5164a7f64f191d190d7dc3d87e3d45924b8d03307a57cc75c59bb7e1b4cd4b8966e281a7c8a3b6466e90db7806ed363e5af46d6c0dda109615999d8464639fb85775b99d49e7bd99e499c1074401a2bcbcdc801bb8a65affb1a7b9639be2c29079b5047e6b996cd603bef0a76f53bd78dff1e3d14ff93febbeb05f9c642d7136fd435768a24b7004c6be4dd0848ccbbf5a230f77f410b31a815613a7b0cb36aa069db86abaca0667eb6cfe3b0152302245b478aede612307dfabceb019d836c913272695acf7a566ccc6a7e7549f3705406164699a11c24b277929b5c9dc0c6e385a424711d4c3a3eefcf1fb7cfabfade3e713f04f7be34a00b0c75a2b112f960c2c673f1fdcf28b43d747b93ee4105edd6993ce9fd23737059c40437ef1bdca6781b56df841a95b881e353a9ed490554fffb138989913c242ff6d33c32d8e43e5bb3b5d5a423eafa92117000831580ebcb826a2c2ff5455a5405321d94b9e54e267dfc4c06441795d9c5132ae2d0a318ddeb2e1dcb8f66cca4c2872cfedad8cd9449fb0b25b299c3d72b7a2a3adb7c2372e9433fb304eb94dfe8ef7f5bf0f9bea125d118918e28c87f94c6ee2909aa3fba0279da2bc59135e5bb6ec5500fc85646920b8d99bde9625ce07921643f310e75ae1cb842484ffe8e1d31e919f59acca433fa92c9e638bea61fb0bdbd95edaebbea65f58858895554a3697590af89060b41f5d8d534336c43a531c225070d87bd44c492b2b5db51ea13b0a5f4d7bc2c5a2f32ae3eb194dabf896123d2dbd96e937aa302aa09ff9eed96d82041a50742843785f39210214ba826c1aaadd40f9c3ac654e16f9d8184ecf89f32581cffa8b0fe3337a0bddb0affcb184a3831af41c2b2ad180e77871c398e01dbb232c586eba7b679eab912c4604d6e1bce5d88758b0227eecd040ece22234a2a7d39fc66d272b3195000be1f5e069cce154994090face709148b547df5cdc8da578b0ea79e1d81206b38dbd343e5cbf90f2af1714fa849e403d52732e6de98b04ea3999c723605e0490f26f7a63e0168d5aaeac338b59c5b8d0ae83f8d9386d6f49f6eef8fb5135819d07a93fde4d7367e015f8d486bdf98ddcaacfac43bb6d4dbcd864e6a1dad71a68c781387a9c4a8d57e6e10a04c3b4bf3efb996bd04a51f4f8a013d9173f2da6c879d3a48a9eb33d15112c34099c34ec8252498212d3472eba0aa8380e2b0a9255ba4b44918ad76c5d7704861da72efed3d6cf33133dbe7855044f40d2c6f69a44ceb14a33969385f5fab24b90fa4c08925c6747f3923cc1f31e469c109493400856f34631ff5c88c57d317f5af5dabcfdbff8d3f440625fe897a603b477135b98e59e243bc9d74502ea5050e1e1381966a774bf976b20ff7709f6d3a22ecb75e937fdaece8c5af0f30d4914a1ca0410c227f1a28a5db52e57997bd6d21d1a18d3b5449e48b56579cf4e23408b0a420d21cb193694583092902325381490367448e281e6c52ecc71a165fb70cc92d903fdd78e046ddd1088ecf3e73eeab94f647fd9f91683a038c9af28fc86bfc04e931d8b7f63b41e77b2e3187c4d6458d01e5a4accdc7c0247c664ab8be20fad8fcfe2478c135525c53452b9e7a9c92d4092549e237e7b1179b6bb6ef124d44345ea0e1455e20a9075ce09b62af14fccfb03c248e13f172e9aac7fede5901cf05af5ec8f1eddb8b6928a25feb32c1ef6d8acbf4d616165986dbc7212d875c13b58e077c534e6df2c55d05b1b86ac12ff1190d68de9b19da926aa8fcbc71e5909a3f3eb6e15323c8ac145945f4e8a7841e1847b63c4b083dfc565b5965be19452cec6fddf82ea300d0d7640f263f5dc66472b7171c3335abc626d4531553bfbd0275b4f4d73dcd8f315a94704ff66a3258edcaea5c03d8c5b9af6503d07e795dfa1fde386c01dfe3081f45c4ec652fcd67ca5b24c8d01b4b1697acf863a52030791606356500020547fc6c06167c8df0ba3cc2406cb7bd64965249490e8552b4d4df204735d9ffa3f3291390905fbd640d0fd771184bd1808a476043ad418b9f57985fc10061348c2d9da6705090e7e7733468bb77e0fa2b6121b1993c0ca70c4302442865db21859191c04c57e70bba702163a287a55e99bf457ae64bd435c2b599de92eb6af0e0fb7bd382dfa5753a5f823acaf838b8ca7939fda35c9b2f22c80cc1c5462a08d487efde557a5bd603453dc413dc87c8493b639b81af02e4453a657427fa62393e4e53d0045063d4a677cbeaa9c181f25ad1c0112c00e0d7443d9669bb60d1b9b82aa760b65bb704680cbfdf111919cb62ba71bf5b9038d3935d2cac0bde8757c151d12efc367a9a946e03873b714cfc5111adec6afabef35353b65fa7527de0fa96d03dc7b813d3c143da0e34560c400b15c61ac1b08669a35955cbd23a78a937fd65406f5f78be11b800ee32ee629686ae83ff0de082604fdd6529a8c233d8a15c76dbc62b0831ac82543f3a7ff68dbd392bdfa2b31b81870ca857172cdae70d42a57f0a5f148bdd3c4cca93d592649c43d05fed153768aa5e8022947d83ea397e93a323d1776704f0733c94580b5dc3434249627186c5b3d912eff903f390a7f83d5d336f0b5a3e86ebead35a55599a39c09c695b4a92e41086ee7fee29d4fd18d7042db16dcf6e9fba90fc6033fc1aef1177268cf61c2125773a1c5cd1d8a2c9613231aca9acb698f9a1a842495807072a5967718c2b689876c327347dc30b5173aa0ad5c11f603c1dde00a5cde59ac138fda6c08583a0bd4328ea35e43099001e67765eb4ab8ed816b0f769aedbc810da989fd6ecf3217765efbb957b16553b8c53a2a67e2b49a128f8d9d3d5ab2ddd760f9affe0e05c05ba6e68b88b94706a3b4b82e80b7e6b50a1cb7bf927e14d4baff95cab555d99b38ea8b485be4ed641a5e2e1ade22b4b303e4f4a474661fb2327d9be7ebb05e072b6922b49e7e4d9f9cf3117d8b9ad6971dc9f11cfdae978c1f78217576ff916269ad5b0c877280b65d66418c210f2243f00384bc197fe8e1fb21b425d4c995fe367895a421edc2c651cb3bb1a4fe8988f87ac907172b189d57f69ce6c17379549e3b288bda4b03669aadad1a6f33b343668d766773992c2824c84d223e8631d5d9b27f164b322f0afdbb07f8457a69c550c1910f7137a6918aa71386899d0b5e18a06b991925c77c9cb50a2d228cc67d1b2585fcc641f57736fd808e9c8315e6e2c84208cb4b291b20e53e9481bedf33dea0372aef872109301fd9073d8d61dd278fd4cc2ecac6bc20b825ac72f7fe76390fddc506baf161f021192a33d9d496c7b555d328fa1332a4cbee3dc2ad0b8f06da791330ae4314050c9f2c7268c702709d71bc7df4bb55cea0da95659bf7f72398d964a24756900091f01cc831e8d47703234934ed9b20b96d3faad72b1eb0e3e885154937f0fd96940b674519b202d4d7054709b60300774a30f184c47cc3f6ef1fd4f85aafc22ca2c9de1f0b697bed0173f1646abaaa9571e14c9bef3e9cbeb55128757e344f41effb0ef6201c0d4beaecd9ed82a3b5a2bd8550cd75ad449627de597fe3d5e581817362761566be08a2116758f30df4e18b87c697329790b6a165f88f3ec24bfc32adb8ff876435f5178b0347cbe616097733ac9c4be12b119f242e6c573c404748127d52369e45610a90f3dceedf4e9c58a479972f66422fe863927a7e2b3c03b6a98c4fa0b1fe8c0a0abf0fdd4155bd4813ed9ac72b9227e2b580e7535845a0585963c48f2c04615577169058ae9f774edb5263c01e83e9b880741892a743cbdbd94a555c0eb9b0434f2dbd5675da5106f29025a6ec94a877101f94b6c0b90f9dbebfacfa657a509c4843b1a47dd156c1100acc814908dcb313a1f2c5a5c6bdf12d9d67e3835cc8d0ecd3daae3ed6adb4a9479095c51bdb49148bdfc85189a9bc6830e4775e3a9406cd79295cbadc86b4f9e52f957661e4f15e1e58754f288a13e744128cab9bdbc386a0d246c27b52fce78f02235991eab77d6c1904a68a1d63ffb0b5625bdd7a43e75533d641274076f4c811d39782f8fc50629d8ab9b05c3bea3db4c5b746c13dec08dffe83231e9390e3044f77f3384df97f8319ed99c5748750ece8126cac5c60804c487c3f2c73c61406e55641be34e7f99624256e00c64ed3444cb4a07c55d92ae6588f2086d585e6035594effac56716b017ac0e7aae1f3e7053b0974aca3c10551135adccb45a0d5e563843e8a208456719c0df17ecf55ec8c2a82d19e76c80861384d5e6cdd6987d8b6c00bccfe989db4f0441b5f81848e3405ace6ec92d2a28c306cf1898a5bb05d84991f10f85dafda919a472d43e906486dde2173f4217db5781ca315835c372f466db5adf3a0941cf7a9ffafa2e8f4dc4dbb6b988ac87ba59520bc18f9f6820038c5d8fc9c466a47b2b6d975c732673f559693f05d1cfabed1aa8551c4d55de049889d2f25187d606601ab86ee07c101baa9e066ee92635916934a20656bd7b44272592c70c2b204b698fca6005d0d00e0610b6ae1839fe03d0648c6b57763cc7da5c2309633210a8f87034d5fcc719056cde3d364d3e21c5539a6f99565f6dac15aa462cc12f7353ae4b53b4d47ba8d24177a9299c61142487904403974be85888139d5261ebe85f5fa83db6005cb3fa3ca71c3cdb64cc3e12d2a48eefae0826adeb7edc84de4621a6d4bb42b734bfdcab594bb9bd3180683d482b65b7396629043f7158bc8ccfa93f7a368e60908ffbb97c1f408f31eae23e525e9899fa79b69136f373f931786b2a6681d1121f1da2bffff991a0eaeb45f447bcf323bcab551a4a988960a5807eaa4b48b1004bcc1ad94c3060a02c26f9d1cff98a912e9f4e925bba68dfbef44332eaf78be70ccb1d756a27f974ce59f90c20c0c346aa7ba25007b4c57532f5fd5acefdbd3882504554ebdcd66525cba0948005672a4cdd1ba85a0b1e692c9ca86141288b8282b0476a8068da1837d91316684e4db131df29a3ab7368592247535af0d8374b91cf9b75de35c82088220bb0e01d1a46a78397f5744e372b6b4feaffd4d56896ad1ba13d90666e64b27c870268bad956456bb7baf1f48c16d868bbca7c5020291ea88c1784552a5e8bb65424e254eeaf559ce2b882e76becaf155334f29b38acaa5e038cf69da8e72bb54a8e48699b67abd1293c1c88d324d47d473cdd97d947b0e16d1a3b43ba90d02e71dde362b06d4e6be51d1b5836f6a38356d188ebde759e5235ca2e0e72997787f292b6fbbc35bb73e4b5bfc17e6ba80ce0e790d81ce348cf6b59af39db9451b894260f613f73f055d9deea16e1e3ffc631435d808ec1da2f098293ef5569832187c8c40562b73ba70ff94b636740e818cb42f8909094f676f4719919b556036afa4273087e15c60a63df57e7e7736644276917978708fba81beea65fc8efd83cfed568c15fb20b8372eb9926071a64afb9c6b5993d3dccda7579a985dbb95277dd478cbcd3e8b30f300e5829770caefa83143d0ebf1fe78761fb454e28cdb98ff05b7b0985b3a5809f91e51915da4be8e400de0d42d455d25e7d2b51bb9ec90fe4b9acc3be7dbdf3cc020e839227d0ee9943464844d6be1a7e5a6585214be8c55c42c5d89b91a968da8f2727678b3dd0cc95fa2237fca324c835b5213fc172147ae3f2489ff3609ba1c2fc3fb5a79b1edae83bb5d096a3903335c94a2878d44ceac5314e5ba49041c30c6643241b2447ae3a568f5edf0e8bba9b6b0d88b774709177fa2c4ea5a2c9bf4a0a8b4bf86ff2f6dfb47adf62cd5ab1751649308e79c4a37a8f804aa8e1b67d5db9ac7ec9495ffeb7f3a989d22f6cfe782f065530292d63db9b26a54b1593a3ec1a2e2103efbfcd39a79db31133b3975e07d974b4924d976af898a60e6a2198fa73d84e8f0ebdc34ff3c7b8b7278fe205982abfdaaa4ced0598677634ed8c66c50edf71c4f7fc4dd606110dfbf5539659cdb077eab92afe6600f403638a097cad4b9067964313791b6b793e3c1f131bc31708a00d439b4cf8f339fb556befcc3bab2ecedac7aa5c938460576bbe82a6326f7df7ca244b5a87cdbdb4c626d4eb3db67392e358f5cb7bd8922886712e1d9d558a6786ddef2cf9db16772dbd4e2df8d2e1ad9c37e735787b2bce4533dd4cabb04a99e25bd0d91284fa48d060ba4cc8f8be024e3b0ca6c7910bb9ee70e9bcbc2f2d41f6e44be4fdedd04cb63b5ca967547c3ed387a2203b09b64c52c9ceb79021eb27354827ceaa80498acb362588c1c2718b0acf964090574a8fc819012040dfb51e7098bc3151d29a24f5664fa00a9a492df41de09e8e669dc070875523e3e62ea616106c150e99ed028f11973d85d3c810bc38d952526dcb8126d0be567dd9642a48bda61d60a65452ee148d0ef0af3c7770ec4acfc8074c26c55a54bf9fe6ae8c7c5dc3f6394d08cf37e8f1421428b0e3f3974676a168c4f45c382989da953d4352fd59268b52a1eaef36a53e1fdea300520afaadc7b6185c801e9214b7bd6136e0fda98e4c351d90806dd83a2310fbad04440fdf9613c51cb00424d33903e589596de61319df45e6d0439746210fefd25950ea5539d96291f366b7757c41f4b711d9ace980dab8f0d0e56efbb00ae09456edece238bb932290a1f7c72826fe7a3e0502077696b0564d8563e07565587fd04ef91bc26d76cfb3fe8564e55610737be5d49a83fff0f41c664d25b43b81be1dcf5021b48b5ed0150b7a68cb07b7fb5676b8a3d1e90d4a3f2e215b59304ad6a1aaf943c6f251e090e867d39903ae800b6bf30067c6e4d88e76641aa6cad0009b08967ef150d2652bbb1db14bcedb7be6e6d74456059356602903a85aaa07aad4877a789aff0ebf823dbeb5cadbdff89dc38c5bbb1b181c7d9ce69220db4b6dc5ff7bc6df2d5d071b1fa030ab33baa757706664979ae1eba540d315ef0cf9cf9f993a8cd47d3ea3e04d31d4070261bf5c7bfdf35bb9dacfc25b3a36ad6d447e269be67eccec65dbaac51af943e7542be93c2f470acf180c6db0c661e9215617faa206d07a554a1d3452371dc35c8f56728d7b05c741a4223f7aaba79224cb0e4a7603f2ebbcc4816b9176217133376d1e9451120df6a62b5f4898b40c9456819240c03a974dbeddd77b22ee3f926efd203d41e2d47453e7fdf19dd1f50c5ff2f7742bcd9b47011ab21b129fab49442eef34e7238cbcf365505ff8bbc0925df9460a92d4a444c95f54ce4921ce9723025a5df677ed949935bc92d9eb34db86545edd05a8b2ea428ee873d96ae5ab6eb79b12ac68193b1ec7f82c6afb3471fa64e638200c591461f035e6ad15b0522f470df2d4f96272aa2670604b25ef07019bc10c1b6fda0c795c89b646a697fb906543868256aa5d03b8645b023b2faa8814f31b9982f9d7b036a06cd8de2ba246471e00826d4fe4ed30bcfff55e1af99a74f513ddccf23f73a1ff9169662be70cc1b8633d222bcacf8c0680522770ce1a658cab7cf6d992e699d86619660428d59c7cee56d2341dd9989e2867ebd627a0b36464f6cee5a560ec17541384d24c70830767d4d287d3509d8537a2994d0ce2165e66b068e1fbf4e3afb21433b8c6032343a5ed8c2e8e91dfe0c2e3a8d22a9c4fafb4d70e89c7a2fa0955fdb91df648a7879456f10dd8723bd9f8c40a8c2e410fc5fbe1ce5cc44c4a3d36a44848a20937739db7d3832e3f90f0878a0510f1505c3b2b95b00be44a59ac31de0d71dbba6a57da0bc650b8decc2637807ef8fc4a7c2daf90f0b69603dae55e7383f9374321dfcb3cdf5d967d25a57d6916c4d31f3734c0a0ea24661a650adad8d792dd8f883085c6549d4a74e05eb5a0ba88b854e2c7312154aa3d3b7d925bb6ded3479ff05ce319a09e5d9924c1e8b33ca293dfaf8bbb5dfb3fd4abdf2124b70b284953a7f30e877bf956e6162fedd94cbf34fa81cbb57266d4593bedd1184e835bd256c1a40c97002450ac2479b0aa542b2a7fa88a20e66819ecfd433d8190ddbf448780bcf4d6e308e6697e3cdc9f8f6852649495fe3d1d3cdbe7e2af9fe7d3e565e5aed62dc04280280eefc700c42be4a8e5768abbbf7122fa6e890b51b8da45be3f86fb3ed2f9c39dd0921bbb6950ec6d7d017f2a3da2ceb4edf673e09ee9a0928078f9f9d38e141a7e73655c93c4f7d83e36eb72bd8cd22f6536835ef032b946f59ccfcf2d9896862f6886cf024437800a81a5c042d07564f4d5c8538ec604f476ae298194e98b495e1e58422ca794553f4e40018656a4872bf4fb7928bfafe9b1dd99f10d1f1c00985d956c0c39e8f71a7128d2759966f89554617eeda0b1830385dc8cbb19fa8b4815162788d1a08c3c78b69a94d83111937568dd948c65fd0e7157fc0ca2d64f244c08e9edc1d6ad96853a99c529aab180102a86ffd1f28ece54227527e018c13183795fabac25de995d990d80b16933b7249e432312f53f244abae3a9c5bbc4fe31fd0b2c6d7e35335628a6eea8ee19a7a2cbeada27ed7e7317a6944093bb690bdec90f3c15ebd2f9312848a0587ba42b90382c1cd63fc46cf7fde1298fffafafc3b2faa0488033f7730b4ec8ef97b1ae7317f5015c5e0888779ba813ffeaa7612d0fc88c0ec67860f42d48f4cb0832b0d85dfa58f52c05978b954681005c0215392c6b1c18b51bc338ea48d49c7a0e9c1c1468410b82b5e00cd0f9db41ab90a0aac08a997cf77818c21654e882f465c2194742799a88da9174fbe2e93af4b57eef4f817e600b8b8eff295bcee3c725d2cb4fdf24c0048caa923df71b3b1f5f62006cf08f0afce979c579aa39615cc1ead70c2ebc314d402f5dba21a1c3406d8c46744a9b43b6ea0a35a56608edc906409eb10b4b5424d4eb25ebd84b11dd6cf49c3752cada61b5c8ee9744fb0e4f6ff66bdefb4293749d312b97187b6cd183c46efa937befe5c0ff8f2641905b95f2bf346785e61b3a6423eed4ad85fa5cfbf32c86eedeb6b1fb8ce6b8999591484ed991ba24586d14fa4c5446cccc790bd8a3561ee37e71b4c8e35a0f7944b910a8be0b67dca317b3d294ef1c61683187acbbe48a1c58914b82115638ebcf19aca979a1c7ec46216c354fa0dbf09f6f286eb79794c11a9ef90320208305cdc94b73fcefb00f91c6f739798d94d8366e9744b92e53ef6221f4eaa8243de6e449b6d3fe11ee532b02cb7b8166c33e3013e441a16b3e7ae3ef4dd994e2be21c502217aab34b30f38c9cbe9b215a2b563c1d3d9f48f4959a851fa19f1d67a2d110e6bdeb1241b3c4eb4d91ff43f2b73c34efd8eba1f9165d337f717fad4530dc97d07e3134ead4dc83a073ed92da0441e5c239877a911bf433acc22a46f0cd418397633f5856a6f4fbc37518a9d89f45ae3ec87d948947a4e18b96eb3cdc67fee8a3d6a5a5369db9b3f9a7fa12c7bbd98112751a07eed0004d5688dbd7889a32ca3bdc5fb9594a9a052846cdb78061a18504bce07b91434e7df6f4649aa57d9548b3888c5cab666f3c6da228979c7f4e1342bc474eabd4f1aea0a4e247c28d8600f74f2311d2210f2bd170090938c05dddb20c57a53c4e0f4daf6ed9de1c47f9b0549c54d28808c52c3cc8ef53d2ca0b60f4fc0c8e89191e09e2d80a6ca9cc08b2b516b1c30761cb6d24f46212456a312733ab7c3b648060026989c8332b1690b570d26d5e8fb12995bf1a357aed93d160d5e91cb3c8eafda15117fe9154c24393b8ba8b129b2f31ffe80a35d3ec90ecf69fd2edbd398df4c25716af495fef9edcd2fb4ec0c60ce996f92b37c6739dee9cf9aae2cb509d8e45894dbb2767869dbe42322f6ae63df3851659ff67ef2bf737780c6b37f5","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
