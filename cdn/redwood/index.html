<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b3af3ec9c877d28c62a2fb623778896671ce2bf090d88f7c5f5f92c1704037829eb74979c523aa48ce834f008f9b5bc49cc9a87d73621a2dac0b468e11c2496143c0476c0be32defee8025092f5440a3efe4c6a03c006385eade8eb28871dc6bf452d0bed0eda5d192c08bd0a734676ec8f591536d738c25b688e36152418d0413e8b464a7ff5a80d037c2cdc46dc59fd9cd653f3164798ef47382ec261786657bbc0170d514e0a43095f99d1428948cc58ab39f42c6bd9d451053fe2b003b44ccca2996e895d925b8fa3cc9e8c7701aae7280d142a2debd0d1ed2716b63906229010f91ac8507d2883a14285b2af76a565bdd2dc3cba615c37c104a49d3a76316a98ecc852cd891515e80a0b28c7cfbb29bdcb32c6b4d893cd7d997b9feaa32e32d22ce91e797002da05c160451820fe7a97c67218b0273f57c68112704d7efb6b48cbbc4fbf791484cb805b657dc1ec84234c7958b6aa3ca01da7bfa25f55a8ddf6ece0289cc7eb1f2cbdc7f81a4d85229e6c85f0227ce6b649b348754d2566b4de50a730c39326b6bddae74c95622d653b8b8a2080b83055e36256998453fe3f83b69e34238c16cf002feb58c8502c0785366b8761fd99e0f26e36395c3a48e22c6a61cd42292d07ca8d2120205ab13faef79e90d22a7890025c6a9cb6714ff8bd3cffdcaaa112855705236abb05fe201fb42ea39371ba970eb2d8242f7cf22f90aef7ca672295a5688f0e12a56140cb8db77035635fb723b1aae756ecb2caf29c64af56d0adcf36d7dae20d400c174f75fbf9a822e31b62baf84ee333c538ee6112e364305457038e1c1c92f83e0e74d86e2cb53aafe6ba1c11242e9d6d80f97386175579b6c43865ff8bd1fababdebffd11d2015211000a58e5fbde77dc08cd6df3c70dc4ca6fd36a53dd52223a506cfae63fd291d8a6d13ed897a7164c47d76d3fed185f3641fdf774c598c98f1f98694b4723787d21bb0327eeab7af29e18a0ee47194bdd3bd47fd491d17393d956288072e4618fbc3e421f6c3a0ad4a8a51191a5c32b8cc30c866632d11e142c388c3c7ee5816fb8ed39367f469cce38d054de893750dab034f6ca3cb476dff9120f08c06a2272fc8298b2e1e8d6cffba8a90050cede8f2e3d671b36b32c5ca405b85e943926694dbbc0d5f55102ab99ef11963fc86600323b73d6c0788b9e42ac08085b79fca8446c999022033bacfa37f7b483129929379cbf05a65cddfade81a38a8c9597aec36e9de67fc462ba7475c5a337999328c37baa836c2dfad30450fba5fe3f34e40521afaf779cb56d1a028ac839272a77f2d243360385be276542314bb412796cca74d2acbff8c27da12d5c353d32779f6fa7f89df4ae3b656df11bbf03976eab00d302cf26d0b104b587eef79d152b64b16bb454fbae47b1e1e609db8b05788394c3f424d1b0d1b6bb257f8b3db8f460b47e6602da524740b03f4ca2cef697c97b58fe7a786ee158a94749b21a701d2cb474a41cbd3909eb213bb552cb06724bf120a65d095acc27cc0101f343ae3dafa80ef0b8dcc86b82da2c8e6eb6234f1420ae32d39603604e28b653d05a63f51be03b05091f22bc4d93180af03a0afb1ba0bb094be6be4ebf791da209c125e97abdfefc55c0a38d94b5e6863f8aed0d8b85b31c2383363d24e061d60095c697f806955d8e66079403ff42621ebcf035089e5c813842b76aaf20644ae0317d7d6b956015455e0f709c70482058533988dd11a40af2d437b0de47c8e03799dba9ca55874cfb54d85491871c5cec0d95b7ac9ae25af8eef31609ea1b82a89dec89e53c62d61b6c15c72fa3bc44f17e21a75cf1a3f1c687708b076807d9c830dbc02e3351914f031406767d6ae0c0265bdcf094951d6b35cf9430a717ead0ad4370178a9af92d6b3caf11f99fe0cfd6198d30673c52c81bfe5cc1d1528380afe24b4d8c3fdcafc34a4e0f47b559d917027e6bce2b87b0409f5773035652a06db12eb089ccafaf9c2512fede2f10bd8e4966e614c56f00522be2d03c041404bdf314a832cdf681d4b63db2b7d540ed74e4d73723216bfbfeecbb0df1b8bee80ab0d2e88fc4a3086b04f7165ce043c9c0b35d029e0ff3ba0375523f19b88f7d0c4b03b0a6b1f5ac54583fb6e4f4b640d805e499f9bae0b6dc7990e3e19188898f8a542ff142a74407581a1fad3598f03c26a1aa337d08cdf4d32c8ba5b840a5dae070443ff0b326b83acf16105dcbe2a19f27066b87e283813259b5a8d653ad8571692bef4c73db59e4a291ede7eea1533746fa4add790befc482ce7beb0916c50d0ae9f8bc96a991c8e015cf32380a68bf3ca31f097ae5b57e56e54875a3c72f103b4fc1a1bc0f3c98a1d2481aff383b6a94a6466492e5bf55ea23c5d2abb811d3bbbeccdb5981310b9ee3ec0cba422b4cb909bf6146929d79f483fe34452fc95907d8889d6147703464bc0067925e381f0493c7b777b6fa5b16cf6e8b2f37157e7251bc64b81beba5208dc6ccf0bb413d59ad13b9181b4d0ed51c78e9364654b34660a1d248f460d0432c6c98ff5dde9e775500d7bc383c993ad83a100cb4d7e7596c412a72c0342ce05b8f44432e0cdf4ca2c96951c78b9e650312e8744a418936844f8ece2522d4f3fbf79bb54cafd9e7330e840aeb414a3c5981465ae723c2ebc5fafb59ca1bab96f38682bdd57cb2ddba1075882bd85390c41f0fdf2e2dd47a206da3710bdf573d0eda1bc59cdea83505706a8c4e7a95fd044f039d1b904aa49e236d5267c1f8d4abba100cef75baca4f736b5d5458532d6b2ad18ab42ed7c08924aed3a7b0999fa6bc298307031ca5e47e9e1143d905db2bbd7372361eddf8674fa508d250cc710d62747a07a03dd1b18e4f0eb1464394e911bc9e27a835f51f300df5c07a5c1c8e0112569870fb665c214a2838d99a99e0df8ed54de20aa5fe1eef4489e2372bb03b66e4379424cbebd0623768992d00bb22fb3db1866d200927e039b098570fdd8cbc10860b2ddf038c8e1383de6af336f431941002fa4bf0504b7c278fcc9f340014116972f681d13c83332dc3fca80bdefd2c169d66db878e04cb1edc43baed659fe42d665f2ed30c9d0d3e4026a1e5398ddfcde047123a85ef76cdbfd25f1683a2ac8a05c8d7e1528c82f13a8c1670cb991f95f520923b160aa3a33153218331d9674e662f5e6ffaea27afad3705db07e5287f8119c3cc45bc53f15b0bebc7337ded08de568e3c36108e0ce639ab433798974ad6536440b871a0dd818daa4cb410b07f818c6b4d56ef3a4824096ea6a8d01a9992df19dae83698c50219db3a6563a05e4c4a3841e2a4c0d46c5df7580c5f9bf91f8bb929bf52ccdcc59dc7f411f1c30cc8f42f2be111e825ae0dcfb36628434dcd54ef63b06f239129bc8650254609a511d1ebdec0422802c31efe1187063fc23a455b920a673ac13a56b4ab00b77b945ff3bc7d7a837071f8e24df6632171210ace52b2f9585621945133b7d7d9fa67a8b2bedb48257ec72fc29f510ccf5f37c2a98a9993be94b63bc9a7f83f33aff19463200aa967b46b1bb4fb6d30473d8b4d9bdbf30dca1ade3ac3b8fbd5104a8ec6769a4b06d294acc3181d7659c1a4465dcfa8af506a2c4c6cd829e1e91df7cf0233b17d500086d99984031d57f41aae66f0182b04388b9ca718dc4c6abd0497e47e1291dbdf0c8827ed0227e5f190785bc2609280c4e8d139b025462f63fd11adcf92195803c19063c5e025135acf20a5d50335adf2401fd94ab98f7bfb6c34d381311ad6d21f32e7cd319de588f2b5f8331d204cf1d8991656ccfe416f299a6276e411c5bf5e6e72173aebbaa2c72a0f73a75ec2b44002362f6ad06fcb227e4139c366164e3511f933a61d51a820cf4b00e6086015b1b37c1f55f75711ee01002bedeb5a18a07fe4e99200e22788f058a3c713a38e5ca63957e7227428aa711325e40734a51f14b4e7e9bbfea25eabbe478a7180a3a183d329d2908bd99302ec13a5bac64dc03442eafa3f0b245536386ffca269546a523b1910a6f09c54080543b7b007560f83e7ac24141ed2ab19bada88ed11c52c3b39da5293ed8feb451bc226f8f2c7a4fb0ff10c31c2802f239cf7714efd6646406bf6aeb73aa307713593ea863d71d4d272cdeba84e41f8b13a5905b7637528bf08abb185616afb91eab2c8a4771df8f3bcee6443b2b6744706384c1bc4d252ce18a317145c09ed6c74e2f686c0dba2ef590e07e8b2b4dc2eb44c48b26a602bfeff961508061488dcaf418f0089882f6a3f494075ebb31d05c433a4b1621b24b05984317e67f28c24b267527bff84d19f443d81343ca2cc56a3553010116113164064c387f24527c14a0b4395d177f6c9b3563a3232f0db9df3bf4eb6822bd11540642ef4eddcda637ac640a859c7bde7df674706e6496a647e66f35672c125088e03a697ff0123bf957b54a06548ca00283aaa983e88e7b9e07f11647e18232543ef6ba0ccb8efa334231310868669f289b1d344dcc379206741a7dbb4127d0d46181ba293f42a8667a44fd1433af9f8e14e6c2885c111e40b2313bcfdfaa5e0022fe2b5d7a990e803b810325c588b63437a5544a7544b331618be931a85a2d4410204d8bb17c703c3ddebacf229fdb56ea45727ce16544e2b7f75a16d539b4c78506c59092ada1cea6a6f88c77520b3d95b100c79e565a6fbf7b835e363b38ed199da03879ce7e7265275762a502ddc39e06888d78bf974f97d4a3687499b8f875a2d37e8c47470c7e71a90e3e2e666ec5623a902d9b18b7a98996f7af760dbb619040c818fe7dda16c8ba0c4908f9d36063586fcb2d7460c16bf3375ac554237d745e24929534275ebe35c6a8fd1a141932535a415ad04732977f41614f03052122e6509925a60fdbad83b545e7ebc2cf7269c56e5f1d408eb15af06561155a48e7f30bb333cf329c7531a39230ab820c083df6fa8c9bb3e75a0e473df1ffcf0682e58e57c694fbe107e509c0aa391f1499f09cf6bcb1d06a11115637ab987c35641da2e32d3014c199902aba7a85ab297a51176c651655c472a6922948e601d597c0aeef167e9a6afa5813f54190c79a2bc945dce6fc0d2f96f25e148551d9fb823d4c36ec2cf1c2a839dd01f872344dc0cb9c9b0a8f2f954c34f1956ff9274f4d6d3bf39f0d0391e5e1859add41b3a011e4dd94f237a2234f539c9b08cf0518736a206f93aba65d93929476b799c2f86a46a7219d1807dade27779c6a59ccc0fcd0ac481f10ccd83981f9e2b032774609400bea65a9b07c68d16b9390128a1bf65411514c6910e1e77d4c92f305151597a767e2fa484e16acd4d249909f7e3ae26d5a8dc4f007c3ed8bd5c0e08e5c7664987ea425a9aeeb1909e8e012cea1f9c99aa1dde3b138acd5d716f69dc9be773eb4b8b6c1192819ece2c22fc9862c0399f17fd749e17b2f632a09795d430e29be8aab8944e9abe3a1cecb1e699bec7767518604e579f72acaf5611ad5be40a267b485e661df029b6ca6d87cad79adea5834f0847279c845b3acb060137b2933347017a4ee3859797f44f5959d50030613f5d08414e6fb263f49a976fe284bd669b9c7067495ad8c939cd653ee9d8983004efa13fc645cfd145804196c611165cf0d6def9018446faa21ff5d5de88c14f2aa937984feb8a2f37dff2e08cc261ecf77ecde545df5f3028018c3788cccf0891abe161d154d836ad723684cdda649848997f6a3bbeaae95dcc6c6c06ace9bbd40cada21f2ad3a1d94af65858bbd5799d5591c9fa5df967c202a78a266b4c1b05c0bd6e925577d2c8a67ab9a01bad925f1cb027640ee342af119ae16839571b8508f0f68f16c522a0c5056f7767700be04f6f55bf7cb28ced014acc132c63d89311bb2602cdd587dad2135f24e52b8fd9c11250e7ba5f4f6479dbad9df93a83bfec0c5bd0c11a5f094d469654d075c9a3c25f0f47fbe32b9bb180fb57dad3cc15f3e2683a50fbabfda753eec6273f647e77eb5f93e3a34a7606c37585160bf5a9102f52bddf951d91da4c22fbd7afee7a420c3e0b10068725ad41cce9f65107f7b0a74c78744d6995b6e4b2690863bd21f458fc3250be957942709f3d26d1592d4d293e8d6b3659c5b4fd54f18ac82512ad33f70fac52a99948d00a80cab4477dea7de29e49ab486829a170edbd306041daa60a94c55bb47c01f90e3c3d5a2d869aee8b951652108cbb590b82be6e632f20fd0be4af61f312d8d93a0792f63b88d2ba31991945d227b47377990e70d5d09c9fff251fae8fb36984ae91961c13aa244141be7ac8c70523c133712709aa57ac7d1fd2d7824053e82a029d54376c6b6026f482aa942787f8deaec7532c8f7552adfd95301293466ecadc83d6b0017709d538b43c17f775ff488cf91b9ee59bd3e72e4e0a58e53f4520e6c83bb622725a45a64008bf16c21dee8f0d9d9fcc561355ddafff168a69c21b1dd5c681fe72d5259c22f8c585c498fa5f8194aa84680a9b2ed785a05bea4222b3251345a32135d71538a2654fe35928ee09ad89c1f46fdd1f1bf13928c965a445df9069cc2973762f37aeb1181fabfc4f8728c62c7d8811e2c8b28b40b3258c08188c39f4d0c4e019c0945cba9a0f78c841e70dc00d679a255ff794a97fa1468ab9edaa6494a8928829bafb2f3cde982f25758f1a012ab1b0c1b4b9a3055c9bd61e8bb0c135e0ea07c9158bbe6d09f2058b4b4f364e718459dd73cec3d79ebd909feac2f2734c4c3ba4192ec1239e9a99109049369e9cf04862d6891a0486e5a3efa298bf3e214e780044b1b73d805d49a05d1405005aa2e471a5acd3ddfce0c070fe99e020bebe24f7abcb5787fa3143617cea25a7707743588e5210b982d208129297018381c75020aa2ca6bb2c6ac09ff0a990191574a819b2bc4aec7b0b6f86b1062643c9dec2a16f59767f4b2f7cd9a1845dc16d26428ae8455d4044c7fdfcafb75ac6e52a62a239b847f7bdaa441439b26b13a49179a9dafab47cfaadd2ed96f367865bcd66ce77f1717f5a1a892cac91e0dfc1f08832d8f43c944f2a06147faf67cc091eeda19ed160d0f5397cdf66c01aa67b7def884ac410cd6e36645470a0e2fccce2c9e3858f25aeaa8ada693ab7957cc2d08bbf85c786bd4c7256a23cb46f0e89f7c2a8dc393f9fb344e7ad14afbda41f8b8603f08a0636f37773976d2c5074ff0870ad8e4e3e9e4780cfba77cbd8314e6a216b389790c3a704675eff82dd8ec12a6a6590b47e79780107ed251cff3c7c6a2fcb1aabc7a776747ba805a2b06f7fdf9032fa62503e22d338d843eda0d620004515b321fe0268e2edd70f52021ea64e579990d3033a166702c8d99a97ead0ae4b6964757dd471dce737cee0465f77094a68d892e6c40000623cc030bfcaceeb61fc963d1f78732f734440aedd3404b2614c461a38f94d1004900451971f9277d7bea5862514a8db34d47675468e73b1a8ed74f3ab0a4c1d9f5639c6d7d7234d03e38aca3b6c832d55c8c8f307456dfe4eebcdbade0ca1b8a5226d8e5c3624e993c0a5a74e0d65ed30f2d068b613687d9dfac5c4d77760cbf1d37c1b1935fa6cce13649105e06e2170dd2d0eda99d02044802199f0107e89932c6f1c1eaa8237e3bc29c9e031806ec56ea0006f190fb7937c918570baa982a5fce894816bc8a9cf30c27a9e8417738145d12c1c440eae272aa8ed4d0ee206c3c98e455c6cae07351c1b8c20f4422558fb9888c1c948c299a4ddde9f42d30624e064781ef978b201fb3af223f8da37721fbd743a2e9b871f5f59faec04d648df87678636056ed9c6837b0b22a60dd5ad662c1d520ecbbdcbc728adb478f725ca3509269375cc791163ff9bf75d5a40ca6868e332c262ec356a07b76eaac2baca1b33222011e7be8730baf0a5cd511138c65c6bc75ea7d81deb3f60cba1a6cfe38b36e33c3707c76d6709b3c7d5db27d262929010814f4e680acb43e676beb61d0a61c06d29983cf443352b7a30ed43752cd0dd0acd4f5b7c2c883d12ba6d25758a7a561ab6802ec7be015bbb1f496dec7a7bd548a9d79aa5040b0097f56c7d0c32702c0295548b66c6ab4af7ee0818a3df33245d93222fe54e30e6d286c8c9c6281044642d9aa717ba97b15b1f04d60a50f12d06ae52b2b58b265d9b8e798595db506349eff8f856dc00c1884e1e8912c9f329b813c523c971e28142cfdd89a095ba1d713572b957b29ab1512bd0ddf5938f4c9063109dbe6d9c3cd95c43652d34ce66a062f38ab0ad81241d8ce052685e6b65c43410fe49bb160d1a5578618b66c176a87dfbb345ff1352107460c8204a24f6bc41f3b254a6ff9c87985fe9f2799fe76147a1fd8ec30ce686186b23ad7844bd2bef97dbf4ad076563015fd88d7c0a9afebb0559a01965ada34e91f08c8a1133e210ec6e571c8f7748ec041c2dc62c7882a0215189fd6bd84cccd675e686583b7b5c84e824945ac233fb12541926c45a48404284df4bb47cece04ec86ee91a2e510810012b1c07893119225aa7186413cb7e06f1abe5785cd692fc137c8afc3a47fbf146f382be7410abe2a216677252445738352fa74b686be729d896998b481841659cd7cfb0bd2fe10b12f33b3328507550e318c7d7fe7bc3612937931dae2b8ffddadb1d07575c9e0851dbbb103ff266cd9d8ab86f9acec4aa53754dfc9fe22d8b8954adcb10e76722aaad2f1fadf0badcbbc44c4d09d971d812ee7033de168fc072e33424106d9a6492fbc02d3ed5f5004fd67315c150322e54d311245a1744c1042b74270a5eed7a994e610d08b2c0f493de587c50e46c4b6e0c0a590519c838f7a5a5ad2e15d4ce369fb96c26635d50ac51fcae4173f4b1c6729ec9eb205b2043273c90ac9de9f3d205c87e7da64206d651ef230db5ece9c4a3d80d567183bf97e2b988a66bfe783447ad681240c805457a3d9bb3a69f156522d1edfb9bb07976788838b486d690a25abf66ad63708aec875927938058ede788293315d4b668fb60ace77552b721162f3a06ea2f1e284f173b339d517b2cf7a722161baeae92d544a847f720f7b1dae0772a185cb05b6cbed0984133eb1eee1042cd75a635c20c4530a70259c746fc7492e9b47dd6d04f460c49c0c0703c67ad74a36a16617523f80309223f0ae6b850e9e556ddaae9bf95988441d3e7545af26264b4f79d33fddd3ce88e57dd6a0fa6d77f068ebb9a3ab68af7c4069fae229d3716a5fdfe69dffc302ee837d6f1debb13a8dc49ce40aa9e2c8335d84d120bd064a6dbd3c505a3dad4ebf34f3c79467332f5afdbfcd35fb60ccf4b905468566af9402803f9fbfc40c4613a72c5073c010d1e4d95806016af8730cb21fb10631412b15736be899e0da58e7b9ead01ba5a863582ea1dab068f8224b50f2c3e4dfa2cb1d69e33db075b3dadfeaaa70179719095567a5eecbc6aa93bdc8d7f6c6dc6148c4dc1640ab78b5341c7af78c202eb20bd4755efca2c8f260c6ed4917c376fe0fb533438665c7531a3542727cdde26eb16357c51d9386a4b8ba4a4ac2c531bafb1ab6cadb9c3dfbb8093b99b9e3d35aedb03774f3ddd69ab03c04c46f678c4925b3beaa23a190434d84602a0335a9f737ef0e8b2adbe4e88cbfbc7392c877a19293cc42ed259d768b3209fbe5b9a55877ecd8f2f100d9fd790581caefc4943d5253c96e7bb1f486d545f1ba2f45747c12e85496a51208491d176cbdab7028074af8b3c458cac6849797cf2c504b3a6abe8e9a2291a73a2237a3c873338aa8b8c640f3fd3ba0d7c670c49a4b120bd1f8f98e1cb171009a2c375af0fd6d8559a026e880f220787ccc2f7fa4c80f83bc81c82f92341f8ff32b5f51229d052b5ae264250a3e1455430c003e4ad2e1fc63a61d02b69761a9a47b3d7a4c8189f72ab230338e846cbbd64bdba8746c5bd400d0be5cca14ca28d9f47b72d3178e070a0551dee35f5d07f114dd449b3cad708f30303e81475d34881200a280d830418e840ef988f63435f6250fcdfcce37a0a82cc3cf14fea67890f89a5ce57559214db30c51c0499bd8e26ab7e17feb36ff0ee2b4936e740df545f44727d8a8e1cf0566d1bcccb571fbb6d0652d4020995e6ef1f00426ec7878d57354ee93caa64ddf9850600c3858b4bbe80f15825386018035be82ece4f7feda4b5c550a635e18c0c61f2485cccc887fafd7675cb8fa10da23bb4306ffb9ee46ec5bf5e6595f83b75cbcb29d611e2e293ed665b5be2a546ac26e0e126378e12fef3bad720af02fa749dc10cb886d0930f381b16f5d0aa858bf516f875796f024603454656f2a75ed6f3b53092e77098bd6ba76381f05817ed0f77b2f7e3c3779abd686185aba70d7145e4fe9ace7717c731e028d023a594cfa4e2b10f63f1d4e88424b89d3bb14ec44bb3ddefd84a57740372ccdca047d2afab639126d9d365674ad64105975e1de12d09f1f092567d637c54b252f9d0b5636c4372c024972190d1182c34b5f61adee5a33b936d92602332b1faf6f75776f02ffdfa67cfebffef6c7c7b281ba6da34a9ba707f65701858b568a84deffcfd342ec1bd00f9953292157c43c05c73d08f48276d2b24f926cc6e8a0fa6cc89b0796b20b0c5bbbb4f5b5fed3b3ae5936d93b87b0d4ba8ded42787c28e5bf5d889dd63ed7524fa5b8a1264cb7fbeddf4c0b9555d314ce0322ed13c9dad62c2ef7798998ad0f174e74b86d04d72b611c693dfa92472295cda9403f0f710ba732308872ecb10542729c9dc62a8363ba1462e0517974ee7e9dbadc18721773e61021aa85d688308227c466b3ba13580705721d6d36415195ec38557c437887ce841a00aa725dcad84bd69863237105586de74e068e53804f767f4ed88b15600e64c5437dcbab380a29ff2c7fd6b2e7852033202acbee3647527059f8a44cf5d46c488ef941d14d85f806426ed47ecfa185f0a3428804554ce8218d5d0546931ae38a262e2f188cc4367cbc358a9a55ecc25cc899df40c2a02bf66925c1babb089c1d46033b65570a144a88ea36aca14ed03c4542ff1ce85aff2d886f76664ccd7d814f55ab25d75f24681dfcc2066ac7435090a97dbc05ef292d150640a96b2e7f89e608cb1ba108cf479f7410a751ec742791dd2b96721a498df16fa376c7ff764250cd17cc7c990f1ac162993d805c6d9ae2a164e85b85ea5ea68e52b16e422356d0d1f5157673641a737962318c62acb7408858009437b29ce49f275f866fb8d778d859586490ac48bcd6de337ea15506bac5f85edc928c558f10fe372e566ecbe4eedcf230d26a2fdec5a14140babe8ee0054f11a1db5211b642a5add91c03ee6b99f2baacd47921708a6accf57cdb940123c25b92f71b93484a5c767fb8f98e57eae5acff6695a722350c786999af38ecd1f1b4b912efec4a7059600449619998da16eba8a6d21986816d758d727235205d2f56f51fb4f3958089df99f86e199ee8ca7eddd44e3fd78844db2195b6eccb210f7c53159ec0cc184ea43a16fce371e053f834d4149f36a45e3f99e5cc4d3bcf979e6d7367bcc0d03ca5ad5154eef13331e5b34fce391e6f4b8d755fd28340878799c3676028c83d7c2ff64c3d3e6f84fd40d1da23a23098e8fb306f32b49fc1248867058a2df55541fdedf63dc74746cde8339d298ba8cdd54b3e982cda5006c14141bbf98c5c2d3bcc9accbb3acb09a8b9dca965f8c49e8237028c2815417009583b115b0275a1a9087d0101b8f14901bde038d947db05c0a9d409dd3bacab76e545b254f235f35b7ac16428bb4671697d620e172ca230c317db59c4f4c36295c6b506bef7ab6d7c8b555dc8eef4132900f3243668874cad6f3f317a12b6c1c1acf9414ae95d36aff04c8effd87ac66bcd43dcc1318e9ef1a03d26709e3df375f449a9deecabae6f23fcbf21846e714becb0b5c08dff94b82a93698d36bb5a3085374e2cfde68e5350d60b60e575ecf6195c06d74042269bb35df330a1473d8963d93e4126e46c96440d6a699bd5a39a9e5005827cfc0b8146b5de74dca2c61fd4347225671ec014c1f04fc1668d1e2b21c4b5356ef05a8acc4cc51d44b51a54d5fd5d02e037954cb14b922940135947d68fe830a302f173b7639c79ead4a840549316f1a695f47bf88ce1fe1fcbca73025a29a463fd0b9777bc7e2055a32ed52decfbf7aa5f38eb5c76fc74f37910a9832ba39c09abd3f2d77e67158cacb3a9e3d29004b1230b6b2dae3c0e4e938a927a733d0c46db4101dce59ce26d7c94a53090f6b9e9904460b0e7675e2d45c60722ef895c8164ce836972a01e3371f4c434b80ea973e2a820ba361ebf9c28a3f8815e3f43f2301ebce434962e01dfb4a607bd05403dae1d2aa7217a4f72fba67d593b3aaf4bee42c355946aaf66daeceb1e9767b630d6dd2d380f1d18cbc213d6637e6d442fa227dc60e31824afcdd2ab94778e32ac77a4e9d98322c793a1ef348a6d0335f1c8494478152d195986a9b9ad1f533323c9a3241848b093bb1b4316a9cff06affd1a9b612ece95565157bdeebb719cb28ca3449e8c7e494a532b36cce9741f9efc42e89c1fa1a8a28199989bfa3377c4b4503acb013cbf7770f84214408921b878e8d6d8a0ac796aba337db4b744907f931836e3ce08eab806fe9da9b5a647fb77e8bced7fe583b24922fae113325d9d2dbe7a1b03ed3cb2bd60a83c7bd691e31564e53c87800a90004121defc304058517d05f01daaaded0e5700fb21aade12cc7f8cb8160d08c970b530981d5644abd9d8d2e515df09b7de81a8aa61e37abbea4163e4049945fcfd4045e76635f28803f4d85a694f163132c5c79fc948ef56b10f80c989c13232e3db0180f7f2193a80d349bf9576008f4365b8275ef05d3c5a667360e4797dad63138aa8a922994a9c753fd3bd4ac2a15affd2f9e12c2f733f0149829dc09d5acee86b39788ae2dd4d6a59b539aedab68f9e3cdfcfcb4103b13eccbc12cc380a651f131b92065bc71f926dfa8134e812a1f8f7a52feb5d6009d81b81d2209574d36122d45f7e8ea2e91e7c74608ed93f0937918f362f8cd556b4c13068b63f701f6d3f5943093f8bdbb6f0d6a201f5c7e240daa3b39d5f65e927558fc6d183f611960d338a49268195c97b90a7d7d594f796b52380509f4f42ff9c581f2c8451e669f6aba378b2c21e05a7d711f3cfeae9e76da116793a20c45917b59b85e6881a75409be8bdf770fe26a58aa970075135f81bcb451e2543626e61c5159dc2658f937c1b2cb2aaf3f9ff717b7a5960c850291f3effa95c1807ae9f58cfaf78e8703efd24247d6deab8d37a50e231380abf2fbc320d588f2f29a43b1c7b13e2fcda853ef0e7be7ab70e8cc280d7ab5bb3d85384ea96ad185bf8124003e52b8fa50b60a721af55d3d3b6f33177b1690d88eb2f506b02ec38b6a3f8f791ccb5b4059a2476368eba29310ac6cc2c00fb391b1b1b8f45cdbe5012977ad20b20a310ae0bd6e0e888441bf591b20ba4a32a4f0ffff3d2a5443a75e7e2404b3b67f96bc3a97a048bca333dd7c5bda55c3f2b57d4813eda2e3f38eefafe482479f05d9a527fad3cc82f7e34482a4f6ac449699fa9b8b3cf335e3fb1cb6777f4ae2fea5e2cd78ff28979ddde541ecc2a53b0f595bb6bd95d7df08672641e0d91d63094d77e84a70318e80e491fc4aae4a937a8ca421775f8165debdd65da81e9c6ae77f93dd138e3197962a6f5385258033570b293b21ea834f8c0bee75c877102f16f280a2bfaa11a2f34482e85964bbe5225b7b4fddec0109011a48682d11359e4993526d0d3184e851e2d440e13269887e16ce26961b01aa35cea4e5026456de582665bcd50743788049788f9dec5d6c6b1cf29fb367726bfadf5e9a6e27d58f5bac6178b36fbdc07b1a1b2967f9a4cbeb63b82888c768bfa819bad52781a71422d42fccc242fd3b2fd8ea2fbcf87909afd820ad4cdea2621a3cc073eefaf116a0e9dba6d3acf449b1d15689606b06a8fe3bf02c78842cd24c2b06e39d389650bfa267aa487d987202ac2d939209e4e63c60b02a5978712fe526b193cec1bb64fffaa2875d7ff43ec134db56a86954ba5c51a2cdad0fb05f54c542ca5c9c358f01f412307f43e0692735ad59df719866d6523fcc0bc227dee79f9efd2dae6589cf4ec7fd3f1828afae4b8e2bce6d5b369b5ef6f6f56753a0d1d22926909cd93a67e8794d80bd1b049df8fbc6fdcd63bc4466d0533f2cc43c5e4f60a3afa171afa070744e2baf3ff406d3e1c26ff2816cf29389cc2c856a7a76e70cc5ba866134afe318ab38d313443aa655b0d23952ef1b3dc92609aac4f3254074b45ad5f640c75b1a93b7cb64f2f35e0ccf2ec72d708e501bf842f286f5a4770c4c80517d396a3f90b9542c5d6f148cfdb1699decc101bf8bf019a9506a95c580db7683e1d09162b3a4e6725f759782896417d29001a1bd23c71ad88a417566bf0daddaa760a4bafaa74ea1a16bbc6dd9162db09471e8ea2be8efce56c678e04768f25af5415508f41ff5d87a69cf773fdbab8fb86f2df7c2ad8e3d762bf29f3d8ca5f0783c0429344bdd6f379388e97d9432afa877519b1f0905c8812d0d27462b9a64261b00625c7a254a1a29217d5b9dbf8d3bf4b6c9a56bbd76312bf38f04268c393eefffbaa218bd5bc44c84e6397a0423fc572547f0c4e1a3a4423c64edf9ccac8f6f20e7191c11a65f2f22e1258b614f5be5cbe1645405f1b88bab39604a423aa4a5eec76bfb1281526b33b9ca3d336f8f57ec9f41045070303d65f3004c4e4e4bb798d1d6d653fdbf6c15e16d71672a04c11491dfc16bb70e96c620defa011e5f734e4a1e7cf6ab4c42428b45b2328040f913750a08ebee66a2fb5cf576e8f3bb39b82f56ba99fb7f1f4daae1850e31a7302a09fbb433cd7c3aae4660ab67155583357f0ea3a1c858812f043e5c66e62a7b6fda340e2fc17bb9a3d0eafc1c3445523fa49c9aba464fe295a92b861e27e1a71533ab314242a52c2235538c58e9996d722b429c66ff7e6380d0c4ed6f83edb63f9f24c7ba73ee773ec4e73ab64731790c65ab845d997833f2ce269c682e4e8d9a9dc3bb2a013155e606ae269c220da8e1faceee054bf038ecb7e5a8548dc6cb92efe4f40a6f8e7e26e396fa9015bce38a460d58cdbc389692978a292eb133f79d1a6e5fdd9b8b9ffc93c8e89a6d763101836aaf2bdeeacf5acede8b563cb89222b7889e4f6c51e9d807386fad4777c6b4ec2e1649b41c04bfee38aa3c4b4a3e88f2fac1ff3192ccec9edc943618522cea67703cbee8b064d6b7031ec7ecc3357839d7f1c4eb10b433253febd6ab9598b8cf48e6fcf2ed3113cb830a753a75793362f38b93194121953083851db982c7b86a2e96f9c7f77421d7d61578eb81c4b26c4cec1006878f956ebe19bf8c1cbc508ed447cb8696862fde498832f5d4c3267ef01f663f99d6d14605ced3e2836b0a15a01cb5877b68047a9d98fee4366487ec1647f7c6593a1907f9781e60803a9363b167c781cc0e023d8d0f0eac6182e2ab1f2e31e9456f8f80a93cc188e3241d9b4a0897ede36d875ed2c84e289ad94a60113b6d932c354ff01b270f7a74d2099cdd44f1f79ad2d584cc086d696e98f00d5c6c68b5d5e92d6c8a2f6b5b1562e155ad05dc7a43cffb39a13a485f15dc4a1e54ae714ebe8a0844443a78657bcde5182b149af2436e4c4dc7e1317029899ffb49636f3ba161cc1d9425d641d592671896475e6b76390e8da0fcfd0fbb1860820009639842df1e6bf4ea946362c696cd6f4c35506effd478d2e2c516af0ec930f441db7a4cf37be7dd7b094c6dfbd418332ce842a59cc25f8c59b107342d69db4f351f6144653242f8cee41b901f30a88956b93aae557c4c10a3679b168db9369fbff0f6eac2f5dd89a04bbce4423cbbbff2155cba0e85ea3b4cf5953d6bce4a58aaa374c94e891dd5e72582d057cdad28ad6de0808cab3ad159a176593abbfa52a6ea3757ee9d4f362d2c06d8bbb97dd5d04b67bd693f9d6e6817ad96b07d1aecdc321b287e12269ebbcfe08194943051b961d619edf7b9c49096b8862e0378f825b030245b9ca388655ef7092eea27b525ef320082067a1c68d5c52c2c3a8534d2b2516738c85f07f2abc6657ba693616f7b438c990827ce2f014cb9efdaaec1b9d60f456b305292cc5b04079ff0a1018f5ac84332bd4eb08eadf91c7ea5863cae9af1bb12fc1b4f2c56cfb52406492d073f49ba8f7949acf64bba4430105d03550867ef6c89707136f84086f8452b5de92d36df10a890d905a49e11f43766de05367f28668b9dcdf189751c3e10f3220048ca02c3edc39cbe3c2365f37f9d24a072a5d48a99e66e7eda21750db1ee6bd1950b10a07d7c4c71cf20565a6d8a6679773f48f1a32ff043171af6bc9d6b35f052af2c483ae25da8115290c88aa2df34a3030cba2645ecef63db9d5ddb0f4f372452cf221fdf83001848059c7363e11babeca25d5f40741ba2a93b370df261c7a53543d7419f857c5a80b82993dfbee00449ae9e4fa916b663075447edcaeff844161a577eae8e976d29967faa2fb72f8d36dca2e202c08c304ead4696536b8814fb8cde135c32426146f65a1dc774d59383da775f16c057a012d2d22699706adb914f284f34871fde2c5c171cb356a98563557b23c530f8c03acd71416a4237d2598f889a150a868359703a018a4be1efb792a3610614210c9b1774d744b866905cf86777e2aba5f4bf963c08a3dde6465db8cb6f41e7280986e8a9b8da1f8c70f4cb81e5242584950579a2eda6bb40f5f071f26569e91507e30d434f63aaf6a0cd700ddbab0ecec480bc2ff5a4070403ca811f98120812f1d38f5c23ac50c6a39870e285bbb6924e41856a36126dbc3b53374c1cc7f7b04876b8b2487b75672f0fbfe4c5f745d5a2ec0fe2eda4e0925380d1681e33f71d43cd3724671e094810967b8ab733088c181f56f51033e3cf5499c5729ad6a6d374285895be595e0b78445953ea1af8146d26c4d6bd2cc1128df381d8a8ee899c33d16d4ff77280471f0ae86c797f3fb25e02275fd6c67cc632216165e12f759cb3955a7277b00733b1385ea41cee5e2a2012312993366717ce47fc6b3d1ac3dbd27389aea38afac06af60c7ae412a14a9670acc1ee937730890f7f8c33a47a0269bbd6a9a77764edc79fee7822a939850a03dc06e572263a7df7871083820430986f7d20446f00809d5bc48a5dc8d6dffafd5f823d00ec4c78ac5f9d9f17f12cbf53627a17688fe7439ab4d1dd84b56ea1b6d1799e40008f99f3d01b94bcea2311cb35ca757bef656dc19f954d7bd1da41ff0e3871ae0598930294195056052b9b73a938647066e3e7d02d0ebad5d8612c96aa6423776596e3a1a7ff8ae1f53240a05d88997ef38a6a345479d48771fee7e2aea40d7bdfcbc211d03004149071f18e78dfe975f66d0009117a038e99fbb4af48578ee3ce6d3185fc260a8e873044a763ecfb5ebd9abdb6054635b38ada9e2e936ac5274096a38654a4d032634a382ad8b4d6a1f795f7f0af06c863e58080dbdaef03acaa7dda4c38fb987b7d082935bb6b0deb9067e015d4189639d8d8b4684e8e260486dedca53645d172c37d292b54fb4f49daa460f0accb4d6ad3dd0790b3cefc7dcc26ef01ced32b224b8a19922ba5e6d5b0321b940e58f16f3adfe50b0da825e41d3196a286f43acc5148bfc93693bbf466149343eb28d757fd6e0cc30f9f2b2d5e1d3b86fe859a8b564ba249065671fdb19e7db2fbf6aabe72e9d00f16657b94953a395d2382f9a024d155edbf38e5da12128bc361a8c16d2da6a316c97e2ccdde69d2ede2d066ac2f1d6a2238f011348d5a42647e022580d79c7cde5de210582611d567da112dcdb96530173873f191599c020679c04807516dc690d5deed50e02435da8c60fca7b6abff2c23863c61f4ce5c7097990ecc9be8d2ef78f2fbd4b823f2b640c18aa2ee8","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
