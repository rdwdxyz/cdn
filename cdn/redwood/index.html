<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6a38ab65f3a1e5d76c1717af5160c81ccc54d7dccab7ca6c17660c11212d56aeeb239ff8080f0e8458efba9cb48d25f6f98be579487ebbe6d1bf53d8abc9e9ff02863dbc73b4b52d4cee81bfd66da5702af430ce613cb24075fb6b692b9f481b156438b4177d7820a7f4580889412a9741e3e7449477c867e9b6b78da6222aaaed798802351891f25ce431b83f490c34edf456c68d11c3b3a80ded5b5e442aaaee046fa0088af6078c4c290b0adb2f0ef2bb6ec0cd5c54490c15bc8d7fa8c2a4fadb74c12bc1d0f669646fc50b39b7e95cdc6653bc1d05073d7129ac92570bae4ac3d7c4dd14e52a820289158f19010b48f24b7bb05e4ffcf1501752978bb053f364e3b628ee9a44649255945fdaafbaebb2d7806461a25b7febf40a6f84b3f5fa1f7256e620924acbf35b7194f32cbe9c1171fad196d67de8658ba6b1e6a9ebab2b39293f690ed3b9f4e3a0ef613b283ed9b477172d1cb1d966d881e1b8fa174b9e12d418914fae9f1811be56a025d6139f96a86e9ef17dcf86f1839b884121a538172e643ed4ccff3b9643c7cc517a144beab4773bef81efcf7dc7302a3af8db208cdcc7084c2185ddcfc6eab417d4b3eec9b7af1ca4f9570afa94175ff3e5f602aea361417137ed6a6e55938c0e5aa92f260eb34613929b2b2b1c3b27fa3b449c516b20bb0d1a628ce7abfaaa22dbcb2046c9ddcbc210b8154ffbb0bba2117d9cf4bb09f7e4704c95fb118f32d959e2db348f85c564554627cd963d12109d5bd659cd25d2c3f6fab6586f5959f724b3299d94bd4b4b0c110da3cc45da4ac288ff7ca0eb87ac0ccfee423cbfc7c04b00f9b533446083dc56bce7b41ffa430e2b0ef6161980f459ff0ea582533e5a5cb673dc4c8cf12133dc0a0c2130358ab1266d2b1acf9c2d1728b7bf09037c76c9678f4ee0609bf7e7990d470db4264a02111a0336a5e22243582d4565dc36e0369dc451d2161ff3aed888a16c57f8fe8cf5d5f40edb813ae71972130e7f32169af79d97572e3a40186d04449e113756a698f0a8ee3170cd95f2c9af6e8aa09e75520dd10029d1128211205940ec96cdc5e8e3b3f1cb9d0589401c174bc05e5fb8ec037fb509d7a61119d00dfe5465a9f6a8765f289b62e1d4a96f2bb02f365ae038bb9ffa931960072e88ff28e806c7bd9fa04e197229acdbb3adf901b755d4afee001d9653672170145f542b7d5126fce2fcb877c58f814034e36c51bd0148e82a7062fe9f15e55301578730a910130b6d33b5f2c43be1251a17bc69d6913cf46a58c000f547f893a875ff6eecdb6935551978ad6c7c307f8d37501590030e8b3d8e9601d84a0414711c182fdaed6601d7446f011f6eb5403915aed261b1d6ad46a47b7805090e954913a356dc33707506eb41d19bdc4b1c5f9e0159ce94b6f926278eb594b86dc6b6f54b80d2c37dba84a454c4943e51e4b2e8afe5afe390ba8de9f6c98acc2e54481b3efbb98fba58cdceffcbce4df3d34348e4bae32b0db928836ba7e5e172d931592c336cc7f2a8906906f1b9643093faed151d233603f7984c256611ced91becf367a85365aa5df111a75b64c59307bfcd175ba3690269bd68338ad5e03d593a659ae625bfb46b4b149bcc1871d85f4a2bd80cc509429f40b56c69e3a4dd937c939f7a047fee5d7a8ed2673d1043459531aacdb53e55ac2633cd47c25e6a88e525415cc0e40f6bd4447ee0e7efae6993eef04221af8c530659b7f9925875c87c45ba43d8f7a2a5757febc4598ec27bc630678aa97b9eb1b5cffca1b0bb90bc13b0d9837468d0c3f851a4b60964c5bfff98c265369ebd9b3a82383c47a4065be4d25c972281be159006b2440bcbf8dbd24b2015a04d2c5e2c1b0eebe34eefbdeed320c181ecde9dcf8aaa1e0318d00a45e340ec64918f23d340115e89b0be4bd551eb50f47d620683c0c037eb3ce198304b3287c5d2c44a416205de633f6a3741b045811f4df0c64a82bf0abfd390d5a00a7bd83c6cb1d696619ef78dfac620e9b2aacac3da248517f5884129f6db466ad2b569bb63574a3fa142d6be38a88ad904311969c81fe56a888d3dece5f59ad5cb5690546b5297c08a207157b3d83ed221c3c6df908d804d6450bdbc48160b438f238184dcbdbe7d833c855b8c808e6eb7ce46a39b160f55d6f978fc5211e18ecc89ad8968b49e39c40dd3e1305a37cd2e3bb1998af511d28ef58da5fd29a177b16e0df64a262d2d9e1d15515f4d756b8b53c50e02b029163f31d6b3a9c1e13133b839d6bdf981f31fd241b8d4ef8c665102f14a6d58489d5199d785cbc0ef9a8721733c1427021ed5a388c39536371dc30a6fcef4bbd1040d1625ece4ceb1845979b33181c35e485fc3d9cfc9967eac53353502895a1a393dc4a70bbeb0186b55e36a453e164be50165a57d4ae70ac327157735bec80a86c63e846a304a1faa51997407fec087cf343510ace15ff9fbc216ceb3c2a09890c618bcc0bca97b54300df41b7071df19a3653c938544845817cab8f360abf0bba3b512b6fb2cefd311feac2483e4b2d918c4602110ffbe14443263e263b8a7cd7d8327a693938d043c5e173390e75620316cf1bd288eddccbc0f0adf94f2e44545a46a205d2711b727339cb1c4bb25ae5e0f05a36724ff59c73cb7be23af58b5872cb9b9fec0dd55d508144879cc8628868cafae6cdf190721c171072048205d4e126541b7557f9581d849e8715574139a0ef6cc5a578505c3f4f5001e77c476f384b469e4df180d6e89ce0858fe0ea591589a4fb95d68f29a66a0320e0834952f5e8eb3279a1a6244b2fce94e1e246a2146bf8cc622332e30c431a3c7013b28bf4eb179add2b582ed25255d5ebaa1920207a2fcfd4262002d93a8e011e506375b035ef22c680630c35e26e0076d550120fc8d365155824afedfe92d22afcb47ad10ca03acf440065082b0ee41209ce56796cc13e2b1f2bffcf93b39ca13e40482ff4ce6add2908e62c4c66933cd2e98202b28c0ee3d670a1003e18467af581d1ea5360f257b68d59e47e12c5485097ca90b578f561e22cd83444e91e0e5763d1b81aa64385cdc660179dba77bf88017176ab15c183d5d399b22febfd89daedc7fa307b3c7e5e6406c5f330d0adf1a04bcfd8ea96b348acc8973c591e5bf1bddc6a7fc291c1a97b9680884644e4c1654e48c2924b223cf3979ade218ae9c9f0367f5b4262bc5bfbe407fd8a83f7e422a2cb2412db371843f67f316e39bd1d15921f5d7e707d3bfb70df767449542ffefed4a7ba232ef7a98a9e288c35e8b5d7d971d1ac3f9d53a28405a8d12d1cc4b051dcfc0370a112576ab19dbd915ce72833524c406cd5c03aa07d6b72b065e34b9af8dd7e4cea2d6b3467ef30595e31ab74444e117f730f010a86a15a71570b052a665e2e9077549e94cc6d14b8e70e01e8af0c473f9b8235b7b1dba6405e1c65c238336ab51c701980db1547aba7601981ec3336f892dc02ad722738745509069f93cf2248c2c18094e8785ec6b668e77b6671a15fc3739b55f7ca731621847ba1fd31d70df7fbaa2969be5c9b2b367b94e1bbbd5345066c934237da9fd4062df83941eb90896ece0e27fd053e3feb66f33ed59d4136ee9c7af61cce3d80d5011ad6ce1deeedced46f923050fe7c06eb8b6bcc25ef212f6c8395cb2da99f9d314805ade90331e5a916c533a0a39925b0cfb6770d7d4708c8ec2346d4ea201f3f669cfb9b6c83c76e90ebd23b55228a76a51bc941df2e7aafcba5df97749aad4d6251168a3587972142f9454d5b30299f610660a4d08dbd57753ce2071231cbf25e719ae13609c1d16c59c256e888ce938c327f3a4bd52dc2f914f2bced61234c6b25182982bab4cedb494ecf5e0140f6045db98d8050eba0b7508eec849925714bd4cb2704da4ac1c876b0b59b16554412f06f010b4a3e2ecf52385c059194672aa61e228adc4057cc75f550ed7288155531c630410c6b00264d31fce3cc8d327cfe91c930d989aef9ba385eff48f651fc16009ca2ed21bb32244509e95571d6124b601823ca2992a62265542474b101c9ecc09ac691344deb8971e03b4f664585218068c216ae3dc02dcb4efae950a4a7f66c11eafd488ea80cbcbdaae9aed30daa50e016abb17cdea739be4131aa05eeb1545d52340186bb62cbe6e979551eefaf0d38c87eee0032b8acdd8c792a3d80773f722ecfe3920d4a6c3aeefa1044dc37a88521ebeef9811b254c0144e8f47ff1725ec6b001c8c89f85cca6a3067b150e2b4644162a924124cdafd3c644f15fdd9ea3a464088c9adf8f42e215fdbee1ce3c71d2d94fcc14221305854eab4d7b62c37b1f2c9930ddaaf1614639fe9789335cc68562cf1d6b8237efb277c9df9976e7bb8388a591d9d1e5c64ebd25270a66d65b4dc018914d57552e584238f32af2ba9c1b640db3e75407dc72ea0524529164b520ade041cc74f8cf62e563850250b0914a4f805cddb4dd5df488b372a471e053bbb4e9dc37f225db98e0db4c16e52834fd632bc9dd5a316f725cba8f917050d714f3d805d71c331e9c0670499727afc3b7f7e30357ee61a7304fdec51374dd118695f3c39e137d75a08e146aeb4ff8f7c80b45a82b4bfe4ac6eae71d280f811fe426bdd0243146dfce8a6a8ffbc4d16b7a4aba52123c8998f2e3941c802a04f00e6651e04fa36790484729c7bcf1cc0841aa52669f6444e983ea9fcd416aefd87177599ea865a0f8f137b02a70bbc3e80223008d4803c6200004689dc37ef448ab6b83c60f23bd3d9985ca22efd6c6065e6b128670f8640ec0f7e49002b2c55dabcfec730d1561155f9ff4b5ad9fbcf42131b82ac72209ae32e6e860a54bfe8425a9ca6ff19d330b0e7aa5454d2bb2d5b8098abd57a56c68eee7571a12aa37f4d54079da307ee69bbd0a9c72938a42634e3396a8a38e7956323d3b51a39498408de7612cb8deb317a47a7496b4e74862b85cdcbb7ca2e54e8876c41fed39df529a13f3fd8e9bab1ae268450316818531c6fde3550858dcc5b3a357003e3f8134cbf19c6a9d5023d4840d42c5ca8e10d115e36ae42be92cb2be08d05f075861acad39d62678358541a06d891eec8b3f3845b9256e2d31fcc16dc8d91d4ccc899ab0b49e2d78dec132daacc16d472cbfc3f4ed36e0e65469cac07b3e18a9801ac7040f74a078ff46ebe9132c2fabc60054fae9efff58c6fa2a39aa6aa71b125704c5ccee80e863fa8a4335683249a9a3fdc739cfe502b7d195f29864e6857474f88a9f01a8090191692343a060a99162a06105f78b841d3655167d53958d589d841293303a89b7f5c6a390ea7f3d9b6cc97bfde6b64131d7223fbe77b145f90bfc9eed50905c79101b45eb832e458d7f1cf591debc9ffd3c85388174b9c7e70520ad261517577e23af518167ed4bf473876bfe04b6c3639fb8458e861ad0ce54a6a5fce2fce9f72732fd24a5875bb9249e9eb8ab364deca76b7813a815dc1808a3420508572ff723d788375591400cb0f9a2cbb57d7f376141abae3206fa62201ea97e169f206e24dd31a9164b82683f09a20b2263203959eddf2dc2a9fb7852d380e64bbb6c19e1238822e129a8d004c33c2071af88094028855949b3efcd203e8b98d9a4d8311f4514510239b17328025ffb3bb372aeed1fa4370e7d415351d10d4447db11a1cd2f606c9b413b54532acae80894e85b816ecdb64f6dd6129b483ba09a2084379fd628aa993c27b575dc4d58d5617a8083fa3a39735d7ef03a5c2dcf32206707e293d3f111304340fac283b4a6b0ff76411b2f418b6b80041f43119396b4dc745bbc2142c29438b662f33c143b27c3aa5a677352f007e60612e98cd34ca934b828e11d55702bc57b30956bd64c00568b59d189e32e4aa21cad38baa87aed331365d141099fde3bd496545809f2761c382fe03f46303c4d789ded9976df0fed888385be31303ea7b096281a4713572d1ecfd9541f3f25bcb4ab823d5607dd7964b57e534941efd8df32898791e81a5ea1a692bc6ed410ef8e64c7bc016b86fe1eda4b0dd96c39d746be4dbaa7e1309625374232ca2100060b32bb7206b9f2a1f0722e71354bb21502640bf0e249db97acab72a5e2003054781189b4c20f30aafbaa1763677537370351c1aa105c78c1701a661c0edad71cef58af8266dab5c6893377ce878394a5f4075174f39bc567964655c3aeb0bc00cf8128b4fadc84cf4880a1fe9f9addb83b09ea1efe38cad33dfaa3fc51ac32e52b1c520daea49450ce07bd057e75d94814ab4663110a95b78d4bb37949f8d3e71ea58f4ab7019cf58f5a211af2ee35081cc125d3eb3661625f5b0a60de2760cd47ae2a53a348ba12599a8a507846bef83ad8eb1cfa3fb6fdb00944205d0fc300a7b5108a37783c98887116ee40cb3b50133f885c19ecf48d2905bdbe353a291803403b7bb205a629637e6ef667f13f9361a1fc1fc5ed18676c196fabb47415216ad9c680337c4259a0e67649cdeaea540a0133294f9cb000ff6e2d33018779da17b4e2bed3b6c593b409849aa69979e535b426c5ce5eff3957d24649f59ccdab8a9de9ed7fe8574d9f6c4b8325ecfd80a7b3849936ecacd231a1233a71064391f21d098d875db0157f1033989e2e42ceb11fc24418a980f9b048a52bd1774df537858618886319218451d340953397ee022d2944215012a76e84e4a3148c399ef483fb820b396320b1c85492201ede9893f43fd2dd4b8085674d9f814c5f9a6bcd89275461638634b7f47d762d00b78b4e43e40bb0c0c1ecad85d4f973f6d03e1b6fde9122ab0af699b2c446a47d9d3a4ab64f4a53b5289bd71218d312a89be70c2adbc292ad76ff748edac519b093fb7e11de8490b21cfd5f5329252965da0ceff43ca1c818832331c31c8ce38e8c058fca0c2c77ce1112f3ec62cd334543aae29e2729153383e3da9644c88f41e3e9a7c733aaedca0154b1252943df124af718648ebc200c6930f3f041d9c7ffee3399c48617b26a5ec2de28d59453086b26cfaa1fe48cf53bb9c4b321cf9df15fb0c7c990400cf4c2e1f68bb6818f5b7869be3ed1e25d0bb3b74297457db9f41e6d8b318d3b779c6253477fea5f2647b2604d94780f928d732989707bffb3eb39522b95b6da82aa49a0f22546462babfa6b37c0343f48448872a8d9250f96733b9d863b7c68e91b9c0fb9e5d9c35a0fa3b7f66e7ffecf4589d3cd36d2220fe78730250e8ab6413521f3b5474e41e3f23f07565904841d4345967ad1891eccb37855a433215443bc6d7c2b39fdf93a7298f00f100ea5725a94feebb48dad492e45d1bb17d8b7f9b8a10b32902cdbeabdc51787c43232f132d70c24560e0ca585ed768072d7d0147c6c6c301992b37ed00b3d8ee505ef9d7668d3d412587ff08bac74a05e741765cb9f1427b19ccd721380593f55954373152b241ed4c0fe2863d6a3844262c6c9b3ff1f2848a683619e7e8a21fd0ccfcebc79d5fd3b5c1f9d0dc9e5ade7e7058d76bf6d392b0e092156fdc803f55e3931a95d7af4bc29738fd95cbe7a2242ab0b5327ad87b60a861d8fe41c0dff667bc5b0b769fc6a8dac42522013cab48f6c62026a86d43672fb49d13268b9730160da7e409cc14e6871d3f618c356f4007bdea74dae338233a2122ecaf1c9d6dcc464d02c742684fdb76e253cd0623dc1cd94ce80bfa2adaddbbf94660f190288c5141361265ad8f3ec4cabdadffdc30b0ff45a19a48d5f8c679adad3e4168682f4ef1fddd30d972337fa8875f19463b3f3cd30cd4cd3e1324c2a73d55ffd7e654e3677e739db779b2387d18d52eebae705ecb52df529b1527b5bad587145081490e88a52cb58d8c58a6f4ee840cf280316e699e3fa028521b6307bbfd442687a3b243a27d6eac45c9b460501e15d1b4415bf9864a70785c99a2d97f76c1451fb9f3ff522fe3c3676efac5d87f2e8c89aaca715331ef5e7d62a94a9af81d01fd9462bbcf52ed581a3134e77fd10ec2d11bf7f8fb7335a2c72cc2eb993151d21c564ee9909944a5727119c5a62d86ae9f11e0559fce8f1cace1d756311edd84689208a23ea8badde6bd35577b5dbdda668f4a4f1b7eb42d332cc81d69b2644ce0f69c59c7bbdba534119f2aa1595cae16a69cdf2e3447b3404b67991c69242034be8098c6a81c4d8c738033df8f87a686255410dd0bae6516b98a3afa2c32fbc31ff896635f59f6059f71c1b0cc41c54173168bce7415273cd90994d1f1bd97bd0b1d0d36caad2754bf57f553de08018eb5b79e8d21fade0745037198acc0993ef0b9adbad7597ba43645d06b2b34e61f805c9bdf67ffc72a9c1dc736a0978b3b0c7dff0f0d3b146607bee38e573bb5e830a930b9badd3b10098b11ab9e76dbfc2533646e792f10f4b608fe362df561c76b5048ec4fd8adf5c51973bb55e7793792e073dc706ae137e62e6baf7bedb42fda9d59dc044a367be951d7d0868f65691f00d9e789d8342d9d32360de3c10573a197e446538dfd173617dfc4d718f979defd3390c15c9305cbac0f54d2e1c59221f5df7cec77fbe46b1dfaa0d952089daf8fe1d22e852e43a5fb022317f52e744d2ea311777f832f324c60b1167b6050cdb9b63fee19805398896992dfb17cdf06bc2a39cd535c867d2325e6e970481de38bd672f048746abed6aab815af856457d00390bfd03899ff4de4c98e85b59ddfaae33c7fb17d0d18bcb27b16b27404fb77fcb82550ec81610cd7f708caade75c8516690fa041c743c3d20ccc7c378498f8387ef2810d680eb0f90d3083cda675e024f5fb033cef9abbbcf4a9c5cc968ec99208c432dadb3c0a4fb8de87a3961139b490fffdcf43311a0c155d5e7a17f4b7a431ed3aa6f8b3ce3b0d75591a10fc9a36894046a98c61cf0749f3e6ae95109a1d19a8b9cd2848dd2ab099aa4dcd30b74592f651131d3599f51cb6e7e7260d86997290d71cb8bd58296d02e6fcdcb6bd3efc3fb2b0840a94577cd353c40ac6479de3371ad564b546fc365f355b95f99ac34c4f5d916da506c22b1b0aa52cacd54495ed9d26c1170e795b18d4ab7db6ee1b5d4f03ff69647f18854059e9ee73cde49731b518ef3a18780fa6ece0199d607c6c739cf1eb6bd6a1c65ac23c73aa57c0e6f51862f0081d31048bbb39b5fb59ce643616c4313cf5676e0ba12cd505c15b23736a84fbe7ed978736d122823ee92988239db5c94e088826f48c3ca54c2e67adb3c00731906e19a8f60cf9eaad41adf67f7558745fa89e1eddd2ff524d30e24da0687960ed984aef290d9c02f07404a02e77f65a1556554a302d0bfeb62e5dc51b79aa2176e70a4f8be616bf031d44c8639e27157d8f61f104e8f5cf3625f7002aba3e78f05b99c0d59ac00bc8ebc03cb60cb3bf538031102e3a6da8e602ca0558edb4b70c5920f6d091ae569fca2e25648a589add128be403be317f227f17bc8eb400ee538e0c470ae8c3cddd68fc2b6e140350de46d443065012524d19280f46af112bdd15562a823739717fc517e2297f38e07f8a09c81afc111c285f4282e1d0cfc91ad1ce3a2f970bf288fe7d39d66e0c4b76f4a42f9dd67e4d9a7ce34413c32694f54f037d108a6090d068388f32ea0e5a834df73b6da6841ac6fd3f8964bc745a0842744a7f40a6a878b4437df659c98af33b3730309dca0a8c8731b1e873a32728f0b3725dd63f5a070e8aee83725438981f86a4587a56229254e261972c40455e807cb437da46ae9fc794c9514b7bf4d9c507d6c73998e8af9032e9995bf477e231e2b1dfb367d04f88cb2cc6a2521cd3cc27eeccf8e19a4588adc19d5d1197511e7be45cb1d8c9a1f3a80678962b0d6a2ad188ae5f89e8dcd96b8527377e92854f29b135a7ec3dbe1341331f60c409e006930b1dc097b4f162271b9d8659578aa1bad5347ce428bc7dff2a982415b4429b6a90e6c8916e76472a7170cf0a7143bd7855425d335bd4fbfdab1af40901926442648f608d3e284186ab7ca465b23a4753dfe7ac9e209730099ee9b662a97e2642ab14254fd7f249e11db4e81c684e573b840a36fe2ea00c40a7d9b37da15bb2d8a3546362b63d96ccfe3754f89dab8bd14ca03395c526851e1c296654d3ed25317c74363afaf611968d6793386f2f754938b851e1bed14738657ccc85440af1c2bd0e6a23e16a6d21bcc9eac436b3e8dcb7119c9efa8a6cbaec1a5243f1299ee6fab51c01b77b07c0f40dfb96c1243ece8080b23d82c6af330d2f77283ca8140f9dd24e63cbbd9ed0b6a9866cb2ef1a49d4077a3febdf589a2fa3e9e6857398c32b7e6a6ffe8da6026747f22601c5ea45499c6357bf1e9ed70c930d7de839fb35fb690a7726bb2dbc4c9114f5e43390852f6fe872455291cb82bde49bfa9eb58ff5214bdae2dc2867bb63e88562f35677f68e30005fc77513afe18dd4069ce4c7bd7d29c9c59b13fd813bedb315e06e00d58882707404c8ed6c19b921f04518b24301b0d40397fa10c1c09df1b32432d011b69161b27d5704251d70c4aa79c422d38704cb9d9d855d153273889a59ab87da6a20cf0b368f794dc2622801949efce050d5388eb575e266d866d1164dd9ef660c56735621e3b8c3f6278b308a20d367cd03115a89d69972786ef7ae9b3366b34c863327d47574fbec6301175617056911a8de22b334fdc275fcaee172b666124ab31d4355e6744e223ee306a42b1012bea2138df9e02b6b2d519b50fedb13682132497ff09244376a58f066af08a3199fb1815bdd9e6095abc120edf37ba506ecf4fd2b050070d39aedb7135d6aeda3e59fa595ede01d4f32a88c3fac45f5df634e83384c96aaf96de207f646a350f55bab3a890b423d5a54a9b44cf320a885fd1b8fc659bd9d8016512d67d21fd29e3570b09c461049d6a6294af8388c4c35a124eed2766a94d5fb9aaafb7d28b1a0c01993e31979f9d271ead0b1909bc0f6194cc15c460b2bff9573eda35db8b7222a4a478943e0f8db9ae7545dc66bd080e01da8ba62dfa906f7f4d8f71b947a218ba222b878791219ee8eff82e55639a83a2dc0c4df8fc220827e39dfae797247507cee54ed8b4e3473c56d7e09216a016b74a1ed68f40c4fa2d6952efbc6bff56c6caf0bee43adf99561a256cb8fa9c67de196413c3a5cf6231aa427acf8ed38d9ff794afaa36fde830c9310ff43bd21b7c309dfec2ae345e9f825d5a193111e21629a3e5bed73a9b6d50ff3198450de78a26ca7cc9b12eb579a266963b78904b90538be714409943ae47a077b1991a40ba92d988e5ca384cbc0c33f67d8fbea988a9e3b9d296b08df890be61df30c520610ad1e41226f2822fa85ad2c50e83ec5265f2e8ff5c466a86910659cb15885c099f3afb5e5e334285a4f124e5d06a1a07f31d82dccbfb66468204bb2af275b93d13a4d93f594a46450eecc7b57ca07dabf47d0579be4a36b59b8424e981ff3801f479a817fe00be0087777a45adc680fb13087be9473eaf01a8f30049a9bb315b3fb06b34db0135e69b13579fc411db65e51c31f971d1c5f536ffaf137a15c539728f9c632c60b74ba124730de7fec36671066d8c43ace6b68cd0969ef6a76f7cdde534db1c022b1612fad3359e8bf285f33cf4f7da5c30d6de2587959e98c2e97ae3a53f02af68f55135e2c95114440895f0933fdf586b6510e26d7144692b19d9961e6dcb18148afc81ae64fdeb6f7acbfd88feb607913776925fcc16e7ac59f030400e6cae5000ab8e2f97d648b72f68868719119c623b7c1b0188fd3ce217b9bfe34d2425403164da4d5952250d58e36540ad19353e097b00c035df92f6ca16912d1821ae7a220cc42a713e617f326ec369546ba5075cf505c3659b9f8432e6073d24a5e2c1317ca489a1133956c1a643726c09590a0071644334a908382b88e1335e6c3b0ca12cbaa56200b238f71d8bd787344fd04269be21da70074a7eeff111058ead6b852acac86bb3e3f8d295a1e53b3b8bc526c4083df7f0ee97e1bf155496625df10e7155d41037d3d11df51c43f7e6dc6c572a6989293a818810861459476d15fdcbd6674ff653fce888e2fe4e4f8ed1cac9e6d140aede5e8a844b08283649e04d726954ade0313812f12d512fc0d575075380d1e5d599d72ade38e50e2fe22d3af312bb747fa58b5fff6c0fcc620c4c9fbb11fd1bcc84383845f3a5542cb6fde14dbd69849d586acbd5f0394e2e389dd8983931d3b561da0343c6840f7574af855a4590db802f6f96eb1f435aed02c14ae631b11c806f1fbbc676db45efd9444dcf0e39b5c40a2af5c2820695edb48dee3849561559f4b0e6f48b1b7b7c55178892d8b37ca3d59bc11c05bd15fa506b7520bb11a2a5e909376a8515fd47ce430314d7810049da83114eeca916f40981918a721c28990dd77353c67023995dd613198cab54db9714e0d32f1daf78d52fdcff20f5bab661824f3b6ece3f03973e35be131e474e17d348dff23ab835ed3a88be5c08d45bb1d060a7fa3d9bc1be426677d200878bae458cb912be7253edacb087bce1e2e16b05eb095c1a10f38121c72344eb3da7cd1d579a46c067166e9460856d77bd1d2b48c3ee97f33c4a8f441b6d1cf6f972808978f6c5a5d6898ef17c6d47e9c09c2260267c77ca2d960f28902b5ad6d70afbd44b1bd4a0f31aeb0da565b3ea1900bac1514f26e4aabb72d30fe874e71c21de625e1b4efa3b1a85bd968d3b3ae19842b3cf9f95cdb2076daf00f0c5b4ede65603653b327bd0cb72c0ec437b83b76049eb02199a524ba34eb0805bd60abe2444f6b6cf5e3906a7f4d744fb7d8a186a2fe9fe355bcf41e35b3a7e9273ff15136a51035f35e2aee65018062daa21efcdeb0fda547fe2a2cce50241ca3f32d24b39168514f266c38c43dc4c6a2775f5284c76be7b1c62c03bc3a7448308c378751f1b38f4c14781d2531a35af974ab7864c85b64687d63b18ece65d69ed8e4acf85811a533cb64c12af001ed471ec96d38bea2ca87edc70396af2f14a65532faae6760dd3c9aad4968019f444a8b03d3ced5c5ee9f389d3e7d37d0dae89b5bfc1ad7204a1c0533d1dd6064b41feb78b4da17f69e84eb3b141e10f22d592afc47bcc63f3401193abdc78d1fe1e46eb8fe69ef347245a5f279ad4e3db5a2f0786402d759cfe25255f8dae438a8fbdb485922d00b3f7dd19e44f3a578a5759602bd6e461d64a15a4cd46552980b4021e88dfed3109cc99b73294b430f10180504c8fa086dff66d8f1637fe3b87eb96fc827fb6d19cba23dd8d199bb1585367ff4dbcd03fd618d53c9b414dbd1c4c6e795edfb06894b18f27863a2dd7362a5266e65bd0ef397a5b5bc5d6b8a13d0e02764458d4b83b6f3db8fa8ee18d60c5897a5e62b6ca1af42005fd0acfab1954d90ae95b475c8a7fabc0c2ee6a4513241778001d57bda83f85604b56f181376ac252bd2441805748730eaf01550708339a72ec7aa2cedd3fb647619ceb96fa9ca65962c6a97d94dc8d2ce936b608d76161262790208a0d5b58449d22ac5fa0705fe56129eff8ea324efcec4d995c73b07896e644cdeee006941c5f06381546a06a187759265ba7322057b0142067e4087e1bea9888bf85b749123d3efac0786126150d94615123a59f9c4b8c560d966d23dbef7fd585a353d32ccb19cef5e736e2252542493764da47dc9d342f1266f6e80c0fa1430f6fe2400b030a8e35906d14048de246cacf0ef52352f3fab72d27726dcceb7981be7133c0f712d73ff185dadebb5c0cf434e8a62d9def22ca007b1446d3c7c56687bf59e05dbdcac3d95556a5d8697d987c78d30d06a9f31f11ea52caa78f5ad37d80d23ebc1f46dab57cc13bb6bc85095e345f79df2d2d20934b717e02e8fb4194a415ff9b351de8cef7b758d71c7a5838451a942b3767e7134a50a5ad5458db1849ce4e7d8d0733671b4310f784829bb5d30cd91c1e0c39050c9f0d2c8c2c78e00f9926e42f5b63c98ec8f8505178b9b7bef6117ec58e4b4e3da3a09f4b386cfd5cde1703eb4a9903b8154d6926ed410fbc6e30211fc7fae8a9a4137ea18e514c1437f37c42094c39fa3cd46f378df219bc383a510556bbd91a49890c6e9553f5ed1b2125f4db2fa83ac141151cb05663a7778c5b359f8a75e66e421669293400ab605bf36e7640ee97c03ad7af69576bc227235f1708d1dc51c97b42172df6d9d4050f859a39054d1dc59f237f69d2d2b7d2733f143f9d532a245be1a9c0b6380109c543350b88894bfac4be4fa3c2ad673278727a4c627675f51547930488e33d651bfd39418bfea60fe6c2f4d26757042429f8e842e70e6c6de2b642ca9b4593fac254ac50019315dd27d7858f2e280d00fa387f7030677609e5f5dbc25ca75a21f67f045e95b02bbf900df1f36196d8c9443f08179421fd8c654d359529e2d2bde0b0b89b41ac95f3a9840fc8d033a99b182a6db10a6904d8b4cc82ecfde3bcb8644998ffbff88a008d6f80a1ecb369f65b0fec2323ca606558044a95e363523d30f940ad135848aff24161738198028fb0599b4179262aede4593c30429e2035a8a17fcba643a1443d477ee3efb8ed14c6f863e910d0b1c3bb0e59112c44ead1f885ebfcc625b67802947df33e9efe5235008b0eeab5a4a47f576e2fa7576356fb748f7b65c3b62b1cb72dad0d260ea054c98597680fcb4cdadb44538dcb5b9b81ff69838f744ff66e4a3afa5ce12008256cdcbef4802868a4551d0ec409c72017856b433293c2651706ef8b2249af909458b1aaa59b5818fc782b8f282d1413e96af728072925074f597d48cea085fd5d9354df1703cf0841db2dd62676c19782d8dc22770592342cfbb2ad7fbab69e4519d625738650c03cb747f06e532ad4518693f5a19c3f6a6b9e10c7ed5167dabd221459a5687408af7b7852d59bd94c7f2e760a241c580553da9ef1d0987f29760041e84d0ae09e76324877eaaee928aa919c5fe9fd51e9495a387189f5b75147f5b40b28cb1d44fac645bf923d3755c2997b49ad787fc74872003cf48b945732ccf73eb1f9fbc38b7b804f0e16642d7c0030c1ff322523cf8b563f1759b727cbeb2d5239097230d45ebf670858a243e9bf8f33ad99681d0d8188e2cc1bf1012190dc4692cd1724edd79d476c4b7ea5bf33711172120e8b32a8794b33b47bc62c3f0af3b4f02611e29a6c445b14abf7e86f464994dddc7657b29285a79e9d2c531941adf10ac9bf1abe7fd1011eacf886fd90e7b4b4e2b76256c0fa5b706aed01ed873061d1e12618daf76b2ce8fcec33cec79280b8fb90e10c6e30192ca0fae8fd9aab87f4b65e949796aa799cc0ea3852e175c88f084963a51eac69a643fba828b91b80e4433f43f945fe71eb28bf813d47cf76e50f80e1d28776627f2e4c55a57b8e38f0556a0e1755166115b827d3d91d114148b5b65d76b040b41c68eb485e9ef6ac514c45e1c9cf46f2eb7ba8c94d1640c499a6fb01637ef61377182199a5faa83b3074e14fca8f233c265f72e78cd4ff195d93de0b2c0c5a34788e8cc6d055e4d72c1759da6a10be5173aef4ffc1ddc060b3047a375c01e013f7191907fdee432302d8507b05ecf844afbb1c946f179ea0dc57ddb20bf016feddacdcb1b63a4a5d86aa95be65af755a9ff7a42e36aee33567df37e55c214d1c23b94c33a345eb6b512b66287f1ca662ef6e3dfb07dbaf1c989a9ce65e17ca9d8ff876529d2f0d8f7a0e8dc052fd7cc448b2d9494b0b080b7ddafcb90ec4a31cc10fe0ebddec38d6dc59aa0e194c7ad6978cd5a6ea8a97a040bac5ec9829f01ae34e5417600a81203601b10bb139b75266b29f69da4de49aee85d525c5aee14c7907a0c22a5a3324af75aaceddf571004c4ba9b3977af644f6cfe103ce73ad23af40d569f58ef5a47a5c44ad342514e86c19cb54e5707ef273b780197a7858e0e738121f20a00d71be7120ba81a4e7368b52e6234f07edca4cdb4b9359c7c800b6ed7cf4c911f1b952dab1f55fab02e4d2094b852e4481aa729e188a97e47fe2928ed9c61ff1bdfaddd22e22f4110d92dab35bf830047098e1ce1f4ac5c7f0432a95680d8b2e4ae3b8ca361720f08e75e255f08bf878f5478429eb6dc4813e22f63e734cb4f462e4830d8f55aa80a3c4de89bfc1d76a5240efeb924eb8310885e9d5f522932e9a420c4d4866d041efa76971094d877b465963d661bd43705baebcc87a8f327e8a706726a6bd0df05b946bcc3da9c5bdffc64726a1e739ab7c8d62ce26e062d230db170046923ab5c50a816f2a6f85a7885fabd4933d5d7a4d1e19644f988a4cf3cfcb75011750c04a8a28a499f29384f07163abc749bef8b9ecbe1e85fb1da9138b2fcf694607fdf46ada35b11c0e19b37ab74b29caaf27bb247ba7fa5f68d705aadf9bd2639067fc06ad35b732c080f90cfc93ba120870c11314725fc7ba82d61bbb6ea873e74b6ee7073273b45ee1d4aed12b936126d6bb2060f2e2c93ed02064189e278768d6e6bf74b68fe35135a6bdaba06a9441fcfd8887b9556646cb4677f06760bd7585f1b247acb6e6c8b08b8b4daa2c71aa5f115aa3ee1e3e634ffe2963e5eb764a76163406945b3c640b33664b3024be046135a6c4a26476778f8e5e03c7a8e49e9379d7bef2b272495fa68b487d8aa37924db80f1f010b4a2c7a2de97b209e268c914b2bc5f3724e06510a1faeb8dd14a1d454ae65e9cbcc75aee69da5fa6f84d274961e093c1fea3e6c19329d1db70b2c63174c32de498719eca185b87079b477a612a936b4811ee86ca55db74020cc47104b691dce87feeac1ee15758e874b8326d9b8ccaa977735b9bbcdb2a1e43dd9189d8c01501071cd93b4fc899a6f5a8659f8ebf2b6d996c643726eee4a66dab3d31b0ad72f0ad4591516699cba23818cd3f3a60b7fb043d1f85b80d8805160fae740f8655414a82552d4c0e4bad31b77e336443c8adf9468e987aae2f990bee939f516712e767f2558e6aec8f17403ce43fac45f02255561c3923b219fe37d2d5cd0478627f847e77779ec55851b302f85cab2ff415404df006f633b8bd6877e2a84fca80cbc9aa24bae25ad560cd6ae426e4bd21a63c7a4074b5fae5b2ec1c30eb07eb8be03d2d29f10fcb9d30076c7b2d29787a70912eed64e9ba54c04633e3e3434f53ff76a7c19adeb3ab7cbc0680ebae07e21c629f1d98507cea980f63f4dcd169ba330e6f7ededb18719f093505aa6286848e7590941b6e02bc17a2ce6e4f0509bf355a82234fea1bd31761bb4a3b6c50a1359d4b69f4f885a39ff68994b8c9ae3986b9e97cb77c9864e03365fb4235c47f3952cea931e8faabe02c29c7c76015ffff7362ad387da5b286931e2cd5b0a2cf3a5b952f6d81844029544c8a9cb1b9c888adbdfc09117abe33ca0dda9b5f5e7b940e2d086a6022b19286d5174f5012bc7747561581e7c65799d257bf0be2ff54e31df012ba2e96879894cb8c83bdafd933a9006ed7eedab2974ab64a2e0e50b5b745d0bb92c0d47ecf4d14e07276e7a785469b762686b940c263f709f6dfe65c6fadd99fa17ef2569ed33daca3ab12dbaf7a865a7074f8368a801066c81486d93c6bfdfcbc5f4b54679eab384501c3751d406942bc358851dbe15819df9b7a9598e9acba0636e0b2cadde41060962f71fcb4e671961bfd2a46563cb6d861762549d1701be33503115e9ffd1cb9200a07e98534613ffa63a92298650d332c5581566564ebff5e6d8e62e8b36aa4f725430e0bc8b72ed84bd3efaf496aae885a6b968d637c6931ecbd88f8f0e55d5816fed65e84e54887c824db6b4ec894c1ad45d0c908cd3e5fda8da279658bfd88a1a0df2b502c0548287e5e0e68cdaa20363c2e13991cf4c41df0e46dbb9687cc9a3eb626370d8bcd9c68079e60f0866da85cac1b284cbe92773e31c1aa5642ddce358bcb586bf85a153cd10638df179700caac4e798dec9168d6931ce429da3980fdfbcb6a8e3f4bc44ab7f140f4f0b1e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
