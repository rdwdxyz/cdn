<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"80c434ad85994322535df473384d7ae1e81a0c8837ae230d87b9a43de37b0f56f8775562364deb3e17d03d13d8fafacbbf72e5e629cc8d0a79bae7eab55f6f577694c94193718a5275bbcc4403bc0e1dbeb2838c392374057554e50002f65b34e02b1de3eaf8cd97101d4a28365f1413d0f4bfe9167b5c02baca5f61d4226016cecc1e727af0ad92595ed3601310ce83ff0eee175c12b52659fae3793e7b0cddc6266f980e56b37087b5ecd405c00bd155c7b4dc8621c62c0517dc2869b987e391069c8d92395e9d0b7ab1470d5a9c6cf5b1033e4960c5bae8f35d89348abf85fae4a3d7097d39904b308045000ef55601f2414fcc4bcec92669a213929c5bb0577b3fbad32b9255b17e11e4c059554ce1b74a8aa1923bacd7440ce5da0cf4d59c226b4e6e150da3a9debdc667cddadabff3faae2cd7bcde86fe42a43513b49c0be080213abd9eb7df353219affccbe5d9020c99bfaea10f1a4fcc101f5a69eecd3ae618f871bd9e9318a9f25ae30b8f05708bb1ff24f20ccf74fa6b050b86a1f2c291ef90538b7019f479d1d860ed5202587d3c13669ffeb017e741453f8cb636abb55936f5ede3ed862dfee0e8b784fbc919620554d9f53eecc31553b08975d8d83d07babf07b6d8cc6891d2a3cca6358254527ad2bad64b9a6a2039d2ba1af5ce71f3764af49a662c05055adaf3be6a604b026803263becb34a20992c4d7fbf6883e048c548d095901fa6116ad02a3d3cab6fd06cff235203109edf5f647b7010a3bfa95e1f0ad9955c39a9853a47cf37410e0fa7d0ff6c4cfb4efa62acbfcf64f480c0ba73e2018e54d748c7fc82d878e35375a333e0cea0131fd63ccd2999f570cc04eb2e926a12207b1ccbb9eeeb7868f0865ea11af16019b91d398dc981747af64b1a96670c15b672378341a6bde86ac6846e35ba9e2ccd705e83e0dc64e74b1e19bc0702280e48ae1309224621af34caa073aeaf9bcc2583a1769351bb355be7c1d1ace013acbf1804cf86e149df836e68085dd986dd1be17bd2140910b22655839f0637f05f9bfbd369aa75b6c905bf3accf7badac38bd50717fe29083cd08a5d9d4c7ca674a15594606b1cd13a04fbe4010df4a5d2ba4f0f8f65f1807323331c1a52a80d1a9ac722845a1f4d914ecac45a86607555f871b589d3f436a53e3cca898122ff3356864f189e14c2ec8e318d414c2a12213b15a47e282eb670e204f1383df70c93c9f29e4885d89eb1f736f7a2a49286b74ff101d8620cfd916c992959e71b91cf9825a4c7329a5300ee6c175906ee2321ae9d9af5145030add904a7d31d5b3671047e4eccb168b27929af2e23e9eac8e5316aaa822ec37c5b9852ec5a04cedb574cec3fe81469ab7b0a9221f17c97f677ce677963d3f2136f0f268f180fd1c991631ec006ac32c1c6517f66c16c2122b17b38c23beaea4491b1ecfd422a0f86be937b4bdadf59be56526eb9b946ff8e3330ddff6ce965fd3b9eecccb23340e20cc17067212c463d6607b8518e5218c6381accfe2b6bd6eee55826f952300f9ed8ffcfa5ce63feca0f773d8f8c5f83a49f07b680d913f823c143f2d3c3e3f632488d6267b455ffbc481f2ebce70980753d604e4ed1fe85c30dd3012fe3e7c6256605e19882540047b67fd7b6dced4e0da36951ff68cc30fd7ecf9f20ac3eafc0a6a983085057f7e264b4778b27f27e0848002cd83dc40a9c2aafc15f33c11debbe4eaa03a189b815e1278d29d85426710917ee8b3c66764af42abd8ed816766430bf5612bb1807235486289da0760fdd3bb71114fe3cc6484269352a9ae5cd4a295a5c3f7db8533737b30a791fb079417bea2d57d5be1ca47b025bdb0cbee66a09709561a3fee03bedd2e67f8a0189401367cdc3d36d09013c5b4325324d39a66753ba8649ee6b78c913640a1f4c4be8252445e186793cb3ff90c3351ce68c9e41ab14e21838ff598b7f956356d2a570f8e1dc80d025e29759c8b82eb86be2dba3db05fa32c345b7a90eaf0db49fd2ed04b6cd13a4f509c28fdce4109cfad8c6e93f6e691cd857889a5dae4a93cd541bde7a5ba303093c47a84bf1f7060b63a753b0f507b00aa59402909edb4b9f4490c43bc3ffe07dca1945eedb3eea0a6eb7390efe8a29449f31b73f22f45424af8754589de0abf74667ac21a5c803ba9f85e322bfd4848eae62ea8b516527840967b4dd5e862899b6ee9163db628adeb60d22a90ec85529ec5b1e731f09fff44cdb59c791f3bb67ea1ca38a4a7028007f2197cceb8f20087efcef1cb55098a7b5d588a7517d03ada8ed6fbf0ac177296a84634f8621cc3767cb124fdf3ae738691f2aef69a4d5150bdaddcb12d38edfc73f17086f84e50be0a7d9c26098d955b987783bf781241eaa3c99af8f9ae00c1f8d08480c514a4ba15ba8cc187313c1fdd541f0c0ad5c8c74ca45d71b28e25a4065bb068b4c00f086b075f9bf1ec46640054bd42b7ea8d50361dad032f38941517808dce61b719342c466f1254432b20b41899978e8ba670be6d3e80380c69f0a31a438b05cef672b981d32d3d6aa352538fbb7daadd6997853f4595962f41d70a7ba3a2fb3a89117a946f934a50b70d509b94c8cfae2902d620a6ec5e56b3b330aee567aeb3abee3095e81cb59ac097948221223d13e42f95052084fd4da9c699b606495038350133dcb010798a995f31b7ffbf60314a5343ce2b2066d6819dbaeae22801b6ba26f14661d934f4a6335c01227f9f4eddf362dc0553e8632f26661673668058da4907ffd03ff504a4bf5b4dddc9cfcff0bc20b9a1926704f210a9011bac2a0acb87549834384d434cd2f7e0881616f2be28764fbb264b3344fed1c5345623157ae47d6344e8971613ebdc5df8733bce2fc304dfca026776bccde4d7321edb29628b187daa788dbcf6809b5b61b14b95404f19ab5baf05dc482ae9f19607c369936d493b5580d553aecb29026db0182ba8b77fabb8610e90542f129a11bfd8748aaff92679d0e6ede6940ad78f7608a653b412106022af388ff5cf4812ea7df13e2d43d08033df67422892b319cbb37739bde0756bd8d7ce08d3429f48dc0dc9de33db45ec9b75af47ac6202b11d530ef5e986d9d04998c7dae7a4ea106964c16ead84049b3fc1eaaac0b64092d8bce791666c7ba6aeabbd630cc4d83fe77e9656c9fdebbbf04219e72cc870c810a16ac2aa11420368e4b1127abf4beb306118c97a00d44b3b26f23c48d8dc801bd694901a76b415c03373c0150d24fefce76a599965ef9a2356d975a6d6f98bb355568536f8becba1bb2eb2348eb74ca9703cfd57f699831d9ca30dd222e93a2d2687fc0466c6fe34c68509df42cc2f032d9fb1d6f2cf4e10b23c94db43719a116cf13736dbc088d38bc3b5221ab7976370d649fba87334bc87502633a976e99fa76c64b0d8964c8888917bdf85b5c2a2024b1f7effba09453c4c2dadee4dfc12f06971519f7c5e6c0dcb0f335f7f8634ca0667edb6bd380dceba5f7ad3be4a0cb48d853884d891716fc85d1c7c4b99e1eeb156a93647c00f2f5530a285b598ad452ef5caad76543c42bdf32ac0b80d14e0ddca51b810a9e94ba32a9206fc7a371fc3335b62ac1b50c28333a37ce1c54553d254097a9f612a7fbd44172a4762679ee03283cce6fd7853dd17dd6e6a3321834ef6a41203c7318717cf3e3ce7651be08742424be9f7cc636988efd4230b5ed73cfb2ed2d53edefade7fe9caf458d56d39978326722dec7c397ca42b6c304a41e7c40d0958e270070c1bfd13d1b69067cfaf1f81eb0561e9998e8710a0190f573ea0ae4ab927d652d89a4ddd03a2a497d2f64d900be98ce47ab4d22cfcd0d3b92402ade61fb9e208ab25e782bd86b1f59e0f94c8df89793c75fcbc11c0c30b7b72d49c2cf777e050d3c55223444d66627e019114a19d3f17047ba53d595036f551bfafc43161388ffb77e7138aea7b31f54af9ab82743ab7291cdddbe3c0f52afd5f3783fb41f21229693f197ccb456feaddbaa0db03ed4b500c18cb89a9681d3c377a00a3e4c8dda61ab714e6565a825ff889ff3e103a220e878a2060c945532af2c364a6d791bf7ca97ddf2a1787a07995d03d0dda7a50df2aa4541bc097fda22ede809cf6a4ba9d16c1713cb291780028056212cf2a3132c860115b3cfe3c063ada4f532146c152be5f4e19c80a1df510fa0dea97d338c2233b0b949b9da9c2943dbd838e7fad6c4ba5e2d80ea7879ea31fd132aea4f512aba5f65822bb0adb1e97e5cf4b817f7d38ab94ebeace8a57f55e23ac5fa34eb1396fc590e7aeaeadbb1bd2f845f54daeb1f7e342c14c57637db4e4707febfb07a62735e3203335a9628aec58232e57536cd924f7222590f71971e17efa80d60763fba240be571ecbde4e567240378e0944d99b30781a8a7a7a082e023b7af96b3ac51a71fc57e301138773355abb096537851a7196b4cf493c4aad82fd1c776e0b15a6d1332438eaeb1f123f935e1240e24d678c98fd5681451bce147a020b9d2b6f20a8613e55b14c07a474a24fcf58fc5d658a9dc056be45dd1d72ec00956aca9587ac8cdf1e6c59342de86d93a16446fca9159b6c6126377cdac8aa833c40e603ed717b32ec9906c9261e02b846958b92e9c0bb017982e93349c26ca4c3def12dcbdc65281be2348699b9175a5da0f4d6094a6974dc8825febba24f5511659e36b149c6ffc854daa059e800c4278b1fc0526926be1cf932e8ab93904093efaadd3249c243b3d1566e0cf1e165db2be0186bc0dfd354894417140a26e23bccf3643281eb7a7602d6bf05a57422b209e0299db9bfa9e992590e8ce895277666443b61c7361938fa5ab0b1bb93cf2e0ebc17eb15c6f1f5d1a69c4b802dc6a1bd2e9694e92d1b09bc89f496633ca8f30cb90e52342310b73252d591b36c918be340e0ac960bc594fbc4d6820c781a23d25ecdcc815df9c0054d0478eac90eb578e281465cc2ced7e952f54ac459adad584f01a69cc92e3e1395846af61321d971a348ec45a7e5da44507dfebe4e7aa42b0e9495ddec903897b98c6b19f9f19042b7f49a262379ea5a77ca68073ca0821639fcd51e21d93475688c6a0fb4d37636ca31a562a5de42d92800c25e3d68af46a3ec878667c6f92d0a52b50f3e4fdfa6678b533fc902b37c3cdcab11597f9f57f7e3fb90e5f1b06d53ca7d017efd3e5870f373d998ccbb60a6efaf71b3ab8834851427f1d6da50ed0bfcc5bca9ee10320066bc2c9c8b0cec091390f9a97f758a08dcfb833dcee92d0ba24aaab50fdb22dd8589d5f0f6cf425fe894c7aedc246489b5618dfbbbd8bc3b9aa14adb8f046123fa2c0ec99a08e4ae12f434e420cc5bcfedbfe3d6204b6ed9aab9a8fa3aa080e4ca2cff6be8b806e9e03ea09c6adc70dd934a0f2a55750acaa5f53120ed264dcf477657a56b2f3780f4d4e4be646c07ea1973a263fa7dab07914bb6486e395f24cf5c75d28dc2ea2962bc4d3bf4799a8ebccb3b7c57753575f2dde912855b29146f68f0eb365aad2c9a1f166a47a0a5204b88e3452741a45559890bfeb62c64007d6c8697ebcd3c5d44b3c09a8d403fae661553257402a97551f9caee16962a4268c4903bfe2364ed6291d89e9662ed8d74163c609945911ca951489159c1a9aaa2992cfa4c601602aa254060d62740e9abee5c85ec758e2c96f0f2460af95fd4cf638d828f905aa86bf45a021e11e71f2f950da2b344234fa3c40b5481b80a1d9b87e7c53d23714049e6fb166aa3e8bd0b0bdc0079fd033ef3c5a0ec1f5a50bf8db0fc0d6e15852a39bc915473902b701c7f1ca48635d8b3eb78ed2641d752c4b7ffd5cd9ee9e56ff970500dc0bd311ae09235c2f123b0dbf892a1004d47603295076a8c8149ce4d348f1fb9239290d7215ee4aa706b2a01dfa367af24787df7126603614d97f51ac7f0189ac86f6e2a5f6fae95778c6307f9def5c3c204697226da99914e6656c7b1ba64a102179ac8d4751380f4f1eaf202566eac7dc1b06f19c78b0f0ce23ccfbcd0dc376e95e271f7485f22025a35f80b908080309d845a87a1283704fbad3e08cccd6c550c4d22d5d2ef154f0a303c30d7d6a3d12249fb1d0f7a6b02ff41c53c58c0dde69622fdc47116bcc6a16e578cec2e48e5d883b07520a95d15bc83585dda64798db8c0eb1f887533b8195768942e5967f929c8e3829fa990c82447deb525140673f8323d596da7598042419da01bb5c36ee679e57e8b76abd72db73b7ab061ecfc8068713f68e66d08d31455d9dd7017caaee54ea52e49119e8c5f594cd086bdd7263e095c065d710cef31bf41d6c41a2d0d2be6f74964654987ed7466468fcc8844d6e8f249b1d1848e405f2c7c56ce3e706a43af2cc5ca04633ecd8edce2bbbe63974779d1d3d8851a499c03f51b0e485342c7b4678f4a274795dc849d6f3b7d2664a6dc278d5a17b5e397c28c61d1fa58210391aeb64274085252f57d44869abd100e0c19958dbb1bb9acd02851642a93fcac61c7b9320b84136f6f4b11e83fe073e03f446ad0a8d806dec84c3d5b5e08e3c5425fc02dd0b8858093fd8ba035231b5a00e31c57a0375623250f10517083de4539aeaac560abb36397b23fdfc0578c4ded7a72b9bd281d8567a5f7dbc8f06a9526ab5032502104147576630482b0f34ec0b9ec3e74f707ee78591f61f36a4a02dc8b3237f35703cb442639240bed222e198a940406b1c36312a550034bf8e416e7787257b4d5b340ae178c15728a7268dda5da781c5162d12d411c9e5c5611538bc8658af9eb370d72dd338f7fe0f9c472f85d3a8d96e7c4f3ba4406b50409152453c9849ce71819f95f36f9a2bac91ac88437a174e8d9883c6e3681e34528a52fb8d406efbbb400b25beab555150b0a2ac0c6e2b5c3d41e38c016812a05ec0efd6afac8f9bba4d8a93a352978f6e29daf0bf1fd632e22208b0d658b2887387c72e6f464cf5e342fcd40c5ba2c6136b815548970efcb437647c2fa80c462a78717c2da12d245cc6a1b363e39351158cd5ade28a8af4d8931d748f0ffe63d6fe879fb4362aa219ac182b00d9fe1ecff6f295063d76acfb03f37cdd3f815ad002f557099169c2bb890a057bb29827ed57e73d405c33a917350cdc424813a5b5ae6881ff096556f5845595bc8035fb76905f065c81c00d1287063afb4b2e4545d6e91c35f5c98427ee8f5fd2276b2f8fdc6f9b39fa4d263b74e68cb381c396080db910f87eb14cb6b71da98dba284558ade708a621b37492027841f10f61893efcabea6bbf594f87a868b3cd554cea808d3c1ae86788223a935a1b741b07b9e3ab44df0d26ad781e923d6a224a69c650167f40f26cb8ab1b21f70174448a9a92e8ae8870122e936eb6056f35511b9c2f7a6168b63f8c08825f659eb0b25b82a28b779da75ee285e8f19109c20f45b80f5783d738d9cf1af38060845e16fe9941e7778ffb2297566d33e75c7bd7e83ca0c21c7b0d057ffe2bb32d7bd15e068f7b16e87e053fad84116448b5665705492efbe8f94dd0a3ca46411262b8d7355553ef8b7bea434aa7f81c22d7bce0aab9499c0081f8fe94403a368d6590c85c945f482b6c803f3be174d2594f3ce8aaf6de4f47bf5d2bcbf3b8338efe61bd46aa50e33684962a3222bc1945a8d88d16db61c82d94d193eb4f1985f8aa51e0d7037db3614550f7671656469fed8dd94a82142378b91126e0702935401bf79c47ed88361d3cb34a4c495e2de6a44c41674abe0a1ac4d7a85bae78a98a3efa7d7a74ec4be25998132d196ebffa5b06ad4751adb8ffefbb09acce113a6b6d372a2c8758832009c7214934ff25c8d0b6c8fb008584f7295dea97f2d2d16d6c9f624fa981fcd407a80974f65876b6e45d0116abac24d3502d8698b13bf2f98736b141f82631a2d18359770cbfd0cb690e8301b7b746055d82acc30d1a4aaeb745d53dd9b29f5dbbaf06d8d06b9dd3c78a6dbfb18dd88a61bd3538aab743f4eebf4f01dbf36d542a8f81b04532d664670db13b4aeb7ff273a721614164bda2247f0227b3c843117b0f48237bfb6810bb73e83209e79afa2223d79d5708c7015a2097279b45d9a91b471e1a49776c8c42927a09a81168324688f762c2565af0a0ec66cb7199827ed94aebefb7abaef10422925b7bdbff7dc3f33df7de4c924bba95ac6f4b4d2ba99bac25b035f6a506bb788eae0d5af9bf13153871063184b4dad895770839790af4861f66801a64f6f62464d7ec9b01aa608311a3eec32ed384985ea5d4ee1b878d9650146e00e9f4e29630e08c97159c5b32f5e19240f7db540266fac8b6b659a98b3ce1de758ea537f9e3f8c86821d87378bd451002f25016e59dd9495315d4a393b8900439fd98e57533b96fbb698d4e2f96dc4f3c170da480efeca5c0360511e4d1f65d2c4a32ecbd3b9fb44a59482821ee3564cc4bb59a6a97bdae158b869f48a2e67acb8f39376d9eea482df9eeb38bc0315f66c2f4c2a254b600284e21dc736bfe5e12015da1cb6b71d3b54fb7e87d71008ea2e2c912d00fb99ee12796af0c28061159ef504226fc034bcb4dbfe5625574fce326482e844bdc3b71d721eb250cae9061d0e4e2b7d1c27d25e2f4c204d33c551e3e0c425eec99cef7991c568287e030608a2a8820678cc9abfd8ed434a81ef7f748927e13b354a4eb9504a782f095db94ccb97ca331da1aba2e2adb706c3a6bbb54ae1d8c0315a1abbbc60d95c60d8ab9fc516bded8209277a0823477c26c17bed25e748c1f993f8008df12b178e0366d94dc034217d3fc0990992d7678ef05c01390880ecfb0695195f3e946269b776556fceed7389b55b83faf2b43960fc6af769545ac8ebf0c06a67eaa42deb9817b3b18770ac56c315fb973b385c77e35b941efb206f7ee8eaaec56e684a6231e7c14b71576ada4b00df8ff21b29aeaf05fafc1de8a8f07c7c77b9410e489aee079fcbe6b679e61649e08ba6797ee604e09ce9f7f4db38e882a47b9120a83d655098bff77314b388d55eafb4e67b90d62725699ee4c605459b346488f64670b43d63357de438e626402bb2720bd4cda59360af21ff72ae641558fb572db1b5889fc9b342c6a5b8ad34b4c9b8f36fbf7280b3f7c785e1b3b10d2a261487f621f2445dc203ca0f771485e7605708c558162ad1bd4ea27f13110efb95d9c0a5721b73a7572e58c2bd1595aca56de1d40089b856572bfdbfdbf03a41c73fe1e09c7f1fdd72b804aef700c6c44500243207aad466ad8332480a1fa94105c0a498326f24abaf5c847bb734a6381a28c75d88211a070f52236a1371ddb26d7e32753764ec89ac22a22afbd02686eb40c6f16a9c7a8f727f5cfa7dded85f38865ba48b57f773c17e4a4c2f7c52d6942be22c7dc9a09228740f08aa3cd8e43f80aabf904cb36dbc48b61556e7c5962d36d0a300dd4da4871bf63fd5ff36a64cda7b2a0cb6b5d668c3e1bdb55ba5882ae80cb9441a22c580bf4406778a331e5c035913e2d7870d612a029c60514d04a1b7d22aa05d5cdda32c7ca18bace337ba98b67bea1263c921ff5d7aa911263fff89a2a3de6c58ae2fce0e17a72f2bf724108b78cb70c38059e0bbcbe9b6b4cfd09904166352e7fd0991823e32cfa05b4925cf18395158efab213f093de8307b630803619b0ef096419bd6ca0582468cd9d01e4903eee86af31e8144483dd85ad4510e5fba79750dc34f8c19d5b081653411a0eb76360066b0005428175d78450b7dfacd11ffe649e88e28cdcf127a1f762a257608ded3b5fbc5145625886fb7a62a86d441914a7fbd9c303c6019d310c6e2e637ed4aabbddb810ee69daec48de666bcae6d28b897ccd5f95595c5a2c38c3b8e002a5969f07b8f50ff245144dff390b42716e7b38932c74d878067e1f9624bac4b12b80326b6fd1226694af9fcc209e8c5b5ac8ff20779d33b9901568de3a876838b23caae3af68b52c2b584e06957c709cbbcfe7390cbfcd26ef8911948f577b0c2b45564949572964ca969004b397ae9e82e437e2ed09e8583e2634130f030d6dfe7d54fed439c3bdafbd3c513a681cf7d2567d5d152ea6ce3d83fdbfd0a28e265c86484f69c1de2fad6e82985b7faa91b68cb936bef8e6b5cf35a68ba272a06894c06feab66afcfab3bc86dd050843eb3b68abb8fe1c52aef0f971464f00822868dd9efd767076ca4851507a9148e2264deed84d937ed9483cb826e84fb2cc0e6ed93d948e595e4e82a50afb8f65a664f5ec481c2a882cb518cdbb639451d89c359da65d3640aebfb513ed1b55f4467015a06045b48be9c7ecafa750154e66d08610a4605ee65b38c3a17867ac70ecc73a2a3796e1c7d9d4aa5ea47913730f2e2c3c5e85ca7431d0571cd6efe6525834085410efc1a277791de475668f0deb8dd72cb012a27f77bfb22b01a32805792babf0230bbafedf9a3b17bb5a383df667fdfb5d943e199ee6e80f40fcbc6554796a87c7b852038210aa6c423e76c03c5d5d6e68092000efd0e495d8d253b1869d6b657cf1f0d0152c9714880927e6e03f6dccfb47d354639eb17042de39aa8f8bd60c68c184467680a15eb91dc686db852bf28b73200d824b9446abd65d53a394177ff2096ea7d005332a2e3d5e7c3dfdcded4e34ef133d25a202155f5227ba87606f1cbd6e91a669b3354ed5654affd1524e48a5f49211a6b167ba98aa81417c0d5f1c52853ddd68eee6e42e688d7b2a172b4aa98d1162f2b35e2331fa2acb18c71f63e2359b60aafdcca320bfb0109c353ee4a94a12582bdf9eda618d5be4b5f7ddb27266947e4b91e9d124faecaf669ecb8d2b2312d08825dbfcdd98fd277b26fd7e6899f5d55c430c056540e8204130efc63e65908484a200c505ae010b8f17d3d1dd6b2538a4f57c00595943b8a0d5b68be7dcfb4f1d01f02db40d2a9fdcb17fdf39865e77c8b236e725d71b3189fb5a6c92e44fd0b145b1cc274b92fbb45c764cc9adfc44d1d2e1943395ee42faae70551408f768cd30a37c7b74306ed4a3d671761b21b9b5e0d75d280c733d58d200e0bcde8fb2fbcc1f0430bfa1abdc7a31530ce03d658737760204ad971118c9d65ab61f24a19d359c6623189ccf0a480819eeba31c9bf5d53b7c16870839628c0b9f0531ffa51f44503de4a5165fa7c6fde49b0c871ea33f878cb6cf3ec349ec183894f352e5217443d96097c2941efe0210cca342e5044552d1f1ef3a88cbcfe27a145fbacca33a0558ec37d721c66e7e44cfb415b5336c3a7cd57bb55ac268204b56e0b152c1d4427b743e44d7d813ea89750ac729e92f1a1e1241be01cbdb154bf8479bf74a5e44a47d2787887ad71a9ab7290734b0d6c8acd743091a0868defd1b4b32c711e5f4dd55208e1bfcd1de204298590d5752d61d7fa06f00d0c2fc183dfa266658caabe77a423e0e118e790b2c94ea70b467fe21c840e672c4efffa4ca3b8bb6ba0c0665ed3b4834345d72bfc208c2c16459af8f8b1668cfcff7cc54ff30b91094b95ef43687d06789a332b7cf6aece3996658ae7e150e506f4d2985ba65aad10a1a0daa14546abba79037ee7a5f01e5c001103fa22495941d94774547296f0663a1671a8fd675989f595b3c4aed4a134837b934ce97bb0d39214d46bc3b39ccc8de80fa171c444ef3fabe46fdfc6f1301b81a8b0ca1d6046ef56f9e8568ca8e9f7d4b85954ef2132679428c98868e9af146747b2b0058e7e725b2a5e42875cf1c8e8c2d793e251d5534708f6e7e36069b1166a41c1b502d6a63bf5d19bcc9f04abcee1382e7906ad6e708aa94c72e4ed975d811283eec6386ba0de0ea287075cb8446587ef2a8d72c4f69097a151bff3e23f7bf74d92e569a39663c6e914cbd5099089172e59258268a592df4a48573b6afc422acf454fd1c3d5137cb2b9335b7307d2f153b4b08ad64b95853e9a7c7638367ab3bd5fa3a903c0a02c50d4030d46f11457c3fc0c0f07d34d3a37ce19cacee50fe3955b5e3c08490389dd2abbead3f2bf9dae6b9237a9ca86f923041f619417a97765c4d4ce623cd006d0d3b0379dd6c4221059c8ebd111c259aa6bfbb1e0f77cb7dac9adf689713383fcaff46687eaad554ea3cf2d86f7745310ebddf91435efdd2f334a1f3da1b4c40e7888473b0ffdea3a82705e982806990271d749c6c38e4268188326a6fb473f54c282ba311d6e4cb1b323138497100d9c207d39906bbb3d756fc29aaf9bf960ce418a38011d5f95dd9948555257d5b37a99a47768a758744d0f2f943dae9d9a55d71c7eb2487087b2cfe68191156e3d527c9237eb7eecd7b421d8517506515c34a8d4f44b03e39b7a6fb41500b30fa43db751a5f89574ecd5c63c356e069467b80c6459dcbd07970ed105fce6ddd8674cb2e5e1c4f0257e502b9aefa2a974ddcf7f52e4fffab8857f41008815753c0b11180628bd690263be9afb7d9609a153e53c6d24c7370a735ee6df997f88895dcb09b5258257a77b94dc83535b5b36d5b4d60086ad06c8f2dfb846ee5526467339b5919752036bfa9dc78b6dbd3b47742a7a7dbcd758088ece3e9abc82b8163935af22101f6be3098d58f95264ba43019a07f1757b949811eb41ce2b413258826086a1cffa2996439182d25e0721325645094f766cca59dcb5095a9424fea6628b3471f5a6fabc38738ba35f17b813727086817da6ec2868ec315ff1d81e36014d936dbcccc9f5c9f0eaa9d1b15220ba6107862f1d8992c66004ab2dd65ae978f360dfe3a1c3228d746d6d42dc5e70399eab98dffe8cfdadfff8fb6720994d9fb7283bcb95a1067e67031020270475edf9504b443454a42e97bbb2f14d81bf7e9f2db66d0716d333baa23af0a4c31b5ee928241ab28350b46ed13a08ea4aeb31899c9e7cd957e63168975fd26315a9a5ae5b53eb0ebd4d108a31b4fbf1676572d9ed6c01c4c4c16f5d09d887a53f1f60fa45ad8a42b9b6758d453dbac492d948b793b4380a07d21aaac0f690d3e0eeac718eb08e881edb17a061c1e0c51f104b56916d5932a6034fdaca37e0a24b19b3b9dee588842f72fd2587dec16f36f05d19ad0fda379909feb71c40b0fed20700bc289a7842324fa67480942716fe1dead9a73548f28c94355559f6d14c61eee41df7a343bd96b4b0aa7e2f1affeeca79007899ca260921b2bcfbafdc1866eee2b61d3dbade9e0256ebf946733cd44901d6c01c45392db895fc376fa4ab5a40474c9102cfcab54283f6cdd9457980e686264bd811db49a203b9fc2148af63adcfd7d9cd548aaf33f6cb1845505e706119aaf3418c0ed735e386c6e4fda6de4f6b78c38d0e3c442d1b10db6a67c0f5544eb99670ae4bf8a67642083bcd650ef870693945c9b48fa520e3fba414a075bad53bb10cd660bae7743a8474750850c04b529465560f180e42a1f1558be03123fc8f301c207a69908ff245989dc00139318a7fe7638f86207822fe6ac958e6a222f79d15c7c31b090f4d8602729cd07138b1a92d0802df3803130e586bb297e878a8ffed7c8a65603f374d69bc39d59bd47a498395b32ed3e11f2d8a019e666f643b87f5fdf441ab041d0d42f55bdf55cca071163f9af527c92ffff81e3ce4fdbd10eb30f1cbb5661180901df27043a097bddcee28c12b3824956f036e5dfa9973d280c542d6725beb2919a2de12b35dddba7ed0199e1a9f1e49b115773bb7587802c9d05795b64e48daa94a01ca78bf6b6bf112b1e7f918fd3ca0d2f1ddf055f96f6158ef4946dd9d895bbe4b6c39a4de9e3c122b61d263d54756c1ab0341c105eed5ae966e2e45ddc375aecb76cb526c72d470dea97bd54b35e71b00fe97b5871066b84f3d844a4ea06cf9683b23a8a112ac06e6654ec80d608ae777c2ec8e570d71452939e1c03cdbb6b0af812cbae69a8cdc793583bbb3473a813a7d1e41ce56d1ddde07adbc80337bcb46d2f72e86912ea8f9829c9fbff38970ad41658e9486bdd4c8c662d56867b3adb2c6c7f51cd045a123b400c0c6a71dc5dc347ea91238874e0d72dddbe8c2115c8009f0f57d9eca8fef2c2aa54db15dd619b054e8fa2b139e7c26f0a8152b49fd133cd5a71feb9c1700e462717887484cb199849dc48e80f24f2262412ea92729c25c1bf80e5e7a13a5de3b862b4dc5cf32e36e9f796c7e4a3244944ed215b65b1d30259780941ce64dc4d62abb095691f87f2ba9f84dd01e4733516e48a0e8ed68254905d59936dc12006e92c5bf77367a34048da9e74157f53f5a4256336211a996a84d165286079289c5e01b49ec5f83196f84eea3966dd4ab0996a2f13bb0b5eba6c40773f21cad4e498657794b21ee16080624e2210aff3f640799be483505f2f0c3d9af73ed4534025a7f1b14edb8daf0c26d1fa734eec9be215dca0e55484f9ac04b2a72afc6839aee64b3f4de65723e526186a459015657be947ca1c1505b7cd3ebaaca83612a6364ca364f72e6d84ea300f635344decd952e2d13ba6accfd14ab98d1f05e51acf3ce660017b167f7fc313a17871b51cbf4140438ccdbfc3a6641a14f8634b24bc878f04f5bc84cc87bf2d05abcaf092e599b581acd5d6ef3cec1510e14bbea8afa11754a93fed94ee99c5b9164af90c53eedfcd9e9c51099344ad06266da168364217e3296ec2125ad2b630f818540c392ee65743276821c1c3fea452079bfe5555aa966e4035785f53d31789e523ed1d49fbb747380dae86adfbeec42d0b964058118b5bc721f7c7dd4fe7daef3ac8c4807f40451d46662e071a0f1a8239b30371dfabd6643da9582e87401a9a60890d30a4d3273fed2a733e11ff3e3066b87a2ac2dbe9b54b17bf8ee06baa534a64d465a0a48dc3cb5edf5af82875017efe05bf2a60dd9e5f84aff4cdf9e64ef380c853f457d8fb2253e9251535567ff75ed64f067633d80529c845f66cf3521eba8cd9032b416cf1eaa4ec839d8787d8f824db5fc26d40e9e50d7172309516e43f59eccef338b13b9d05e3527bfa74e7eeb27a5af63e79d9154096c07f51715320ad7b3425ff20048f157c24a7f70b55b431c727f8a5fd8f7b3da89f55b948bc458113586a8831f2832fecbc47b2b65d08bebc1270a414197e5062cf6fc3da3d7b3767768ac3b140bdb7d945f269492b1e9d0010e17c74a778e94f315ac9fe1f8959702320772ec68e373648b8f9c84266930fd61e5fe3ca2029511696f252dadb443cab09fe9923b832516917a4285ded40ec328816f2fcc50b98c86f5c8ac31ecd1d0868cdb34f8d0dfbd0469e4cf4e47b11580a4eb706bf06a99911fb788e488516f4e2b2e06430db5c344f922da87474dc10a18954218458f090b00fbf0fb144117b2bd636113bd175c29b12f4af8f543203c0fc5bcb749e71573ba7ccdcd49af621e2396398c5922d8ab1592c7be2ccfc5604fd88321e3da627413d62f1eac7812b0c5ae40e2b8b64cf31c49b34bafa57d98506104b19011cc22ebeebb67f2af5b1367889d0760d19fa9450f00ba69c2fae6b86c69909f06447788738d61aa30ea53a542a1ff161645d5fcc35ffac6b9bdbf4ed6d19c34ed2c91af1339bc22393bb3c65da07c909c9bc38c58aacc2d267fc7252b510d2dd67a90508694745c9215d0a6dd7e3c252b1b9183430706ee75b1eca54799085914ce498bcc813b24b0382200b72a7fc7e3937fa8d618d80629f4c791df2fc0a9d2f153b332c873dbd326ee84c1e0846af8e5c4b9f5300e82116a06b66e40322eb8b0d18385877eb55f63e4731a0de174a537bb7a0a4c4d199b3f83ec47deddf7558484a04a749b8e48ffe1711a50487f4a1f435d43d279d7fa904d6066a9561cd920e3f4a323578e37bcf8b13e20ea54f304040a999f68625714fa5a0a66c2d89e5f5f0ec22b658dd1eea1ff4aefe6ed59e5cfbf21e175b2a4502c2419402cbc7b78704283537c1ddf85d3a009e8664e8bba90df3b14896ce26a8006a4cd4ccb87f9f31779a3e82e93988a132c792cbdfbbe9b66f422f716e6cdb00fc0094893449a69a7937ed577883e424dd6b2f039724d27a31189f15388007e02f65ce82595e7a34e83e1eefa1923455e96146344581d27277f891f2f57f6e32a6c1c3cf4943951262c870fb3ac6790bd7d0df74e74d6d7dd0454ca7c75843d5b3f768fdd12f846368c9e57eabaa13644da7b98357fc9201fc05b6d853f832e194642e14f64fcb21caa133977a37cbaf7555ecbd1e6d1a9b19e9bb0d720e4e672d09d25eb13443c4907e3c41fd59263c968f4f5dcbcea6b44ce5ca9c3523a216c92ab37b6f75cf8edb66ae95065e81829809ce0c6944e9e69872766edbae7d1852391c3244f719b50001111c17c6f6c2c3d41ecc8c3f538caecf9f105af67ae52a8f9be49ded0f9352d1616df454aa6dfd315ceeda582166034f3fdd98dc62238846a1e8de68d2368b8286de4753b0380c05d5d582bb635055e848c39a300ff456be4348a124a06c8cef33a86ef2ad519e9b1b7e49a8134df617fa2f24ff496c1db141c32d4b2056c32b413f7f47f14411cd612d4876016c03ab149e757a876d790323e88592babaf56f7a6a668f8f061280f98611c6885a8108a853db44713d773ac877b8bf475129c66e2bc3cc847257316e7334651f1e7e6835f271fb451daeec5340d240f26470eb5224b266ba71db0750892da7fcf30fc8b94ad057dc8f53cfe7e019c05f63ff66532e0f65cee11063b457126c07f7384effee00762491ec3b36fff204391d37dc8078877d0c6b0a6464447ad8821669a1ec302b99b74067748cb1d17207141af64538f62aaf5e399c7cc4da1dd2f7117a46f68aee1f979b04a0c068fd4fae0f49844f41ce019f2cab7c550904ff44b89604d8a62227c0972661d3efc5cd8870af19a31323e6a3e1023148fd0ebb193a020ee5b4d71e9971cc28c05c0f44d05a415e32d158cfca6f2b7773cbe02735c74ac04121d7785e2c860901c0e545ecd52c64230c7b171554a26a800b096441b94b1589f7c6a5b3f97f0043f81e58904d83e7ffe8b93f640660280b1910fb7be2a45e91a91645b17439eeaa8310ccc0b9bfd384a49148bbbffbc2f489bfddb2a541f839a365a12e4552597f93c86ca3dc9aab3041e17778ab1329d2faab61b46c72179d6706dc4add8fe4642522cfe0c6644f6ad3f0a597d8226797cce323cd830cdc1bc1c1426603dcf867b14758f57ff612f1a2db2b6084bb12bbdfafcdcdbe35ce13e24e503019ea134290ce3ae39c38624c6b79063ae93dad983d37d98a44ee4612203caca828fa820c3900ca50ea76528ffa6b8f5faeb74b4f0f7bab669a64ebbc00aeaee4a61d3fdbfd5b5282d389f782a60916d1f48944b40a1de7dbb9f45cffc62a2b57aa5d64561e40248084071ce2170fb125c5b9489110317355875466efd0a802ef79832b40707b298f7800e3f87f937aa2294661c819c1de613c689273b9597b3ca22b82fdc5accf5ad202672363ae248d2411e16938dc1659495aba71a74ecaaf75acf84af57db4eb1e24ce54945473b8e75139728508b78f54c23f073c4e052843225a9559f512acceb78236815eea2f6faa4e098d08258fccbe1895af440ce9c464516752677eb914c80c49098f97f667be9766907a3ad6a3a53e52ad46548f7f8aff7da25b790759038a736c5a3aeea207d8164582fb21d1681527b066465bccb28269afd561f91daebcd468e98944665c3e4485643d5bfdec85c61c32ba013ecfa750587bcd95055ed18810068839b52c2128bcf95bb139951500095fdfd30f29c1a5571fe0bb1465693e5a266defe1b45efcf2d378dcc48e0fd4d00f7e5d3ee7bc70f32cacd1b8f975c4aef2c659553ebf7ce748a638b7e9d17241ed7d913d6945143b77d02763b43f2ecf9bee4dd3b24fad9a042e5f7ee229c0cd8aeb00b31ceaebc8fe5371a94392d9368b4d28326b3ac2479075af0d451f6bd3cfd109c8ed27f2e97d05e3d567e9ce7533694d575f1558ab34a9f69eb59580957585ee63f34b109a405966bd","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
