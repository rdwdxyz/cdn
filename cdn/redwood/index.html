<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e15d03304777094f1516239fa203208cf0076be0f1a852850dedcfc4ef1a1720918eebd312ab6033fb707f80ebeed9b3534ab86eb6df002a857de140ea1018cbc7686f3a2290f5752bcbc2df5884e6b8fb7394574abec349eee493851e8469fc81b37dace6d3248428d7582ec034f2b659bdeaa11da0024e7e0eafef24e3db5fb56f793b9a72fa2fe2d2040e78e557353ff048066396e57eba2f23db357ee9527e727a81bc1503e6b19370fac0ca0738091876b67f339946d4011ade68a2055f8d9c8d8843c5fa9e20a601a4dcb1b51b98fb56136906bb0d6976e165cedba409036e0cfb87c27792d8bee6e17220e3bc9e380f1cb3149b39e2446ac9e65f6e032a9e958b8f350c469462c0a846f0b4ea32bedc153e61df856874d9399b81658d4389434e098a0f638d6142f93c987009c665329b6baf5fc05854c17160660140e55d99d595b6b2da4d157bdbe28ffc480d2025932f6213b1da45d76810d1bb1db9e0edc25264042a8baf88090666040359b39d02f57aa766934b50c24f00118fd40d2fdf4d2d62d129d54e5b9899d194583af303659bc4f74ad2039814f0e86e084c7b858db8eddf642e0d5af4d905a761e5c799f9203349fa84c027a5683ee4c0fd8e19b8fb8257d24fa666daa796454a7ebfe8069cc8e51abac58f0d2a91cef9c01f6f2e58d0f3aeb895399e57978d311e0cc75e7da18967bc932f1628fd6ceccb1c35c1d4d138aaecaf03d77ee0e474bd0eaa821efb08421b646fa2dfdd69539f738aa195710106669818e7d4b6680853b6076a69712b1ba6764c8dfbc1d32b2cc3f246204b3dbbd8357a10ace3dcc5e97d2af2d1018b1c2ba89563986953c192dbc398b12083e57d3a6c6fcf8953e85d1c8c1a45a819be4f745594a406a9c6e687b3311db7007580af4ec9f6c41cfb4bde8f63b04e688822082c35fef6f00277579654f6b727aa198d776188f9e579ffe1ed7e0e6e3d7be1eed1393628a7f577610c4da908027e2aeea934a072183d4eb6b08c783127c46fa45b9f4f7f9cfa3ba22fe1cfe5a3b46cc150663830b8b26d0a15cf71cfb0bace1958d56dfd027be60579537d70ce6caec390a0edc98a5dead45ed6c75309066d12871c640c5f3b1e75ba78d50bb2c6717c72745aa0b7d32eb80b4564e40f72b825dbf640aea6ae73c654997abb49f7f8fd16c15540ed197e69707a7abc2c4661eb9505da7836ffff2234b6b6e1d39d9d6fc99c4ffc42e9be0d2991d5491088c86a61010e3e68cdf8da29adb80901c1e9eee3cb393fae2046c253f9a1af9b8388e846e54f3b9acb9cff09c6e9b91484d75344a6178eb6136cad11de8500c5cab8637fcbc32424e90b39dafc6cf48edae29ef1765f5006cee8177edfe12e6d988b7c2dcffe863a3fec759a81363436096f04d492ef79d5b6fd8220f0bad55383c53a77118c83838050d721fcf5a786a783178102fc70576f8458c6d1754ab1769c30afb9e746175a9c0ee9a93c5818cb7af3b5430004bc1ff7fa811023657dde11698937044021f250ebaa7f424bb68b1e1cd76dde6cb162c01305e6b629098b74bb3f187836976d181a5e2f2e8d96d3497436aeae889122c1c81011014d0a9ae0bc651e81473857534fc5c1c15da538850dd6e72953305f657c1115a54f85b278e2643dccabdae097d0a89a9ca3fcf1bdcad6ec1eeaecb0c033efc932927784e9a2861e464aa49c1c6af7aa98a02a9f747c86268cb2d2f9edc103863072a4ed57bb05ebf8b3fb52ea3536f2af6edc2707cf8fe23ad5816665c1ed4f5b41589e3491b6f6b1e424b62e0ef9a2f042c976f41c4bc1ed118e50ab0997e70dd036f4ce100fddf4eb1ab1d9230eb678f895809ad78d3073feff9eb40421fb6bdbff8c43c4a02222acc5c4aaf307d9c8878726eb709d3261f77e4607783129f0f4f653119ab5a181d5837096c9fc5eae9ac4b07c0a1835c89b1c77f59d5350957123ed66027bccf1b5755c28cce46ef713caf777d9b0b53a32b2d230a7658254ce1bb37a0999661697a8c57c67ed1117c75096ad8390cd2416cc6f2551aaeeecbad7301abf129ffc9ec33b12a0cad413fea5d34979768a2c9ee9d7429bcdffc6641b5bce2f4b77aee6e5bf82f6bbfc1612345b3587cad33832329329f2f5d319befa1fb0eb738605919a0d6a021c37c2c7b992d555a3c198f8d76b7fc94c485e1abd202867b86594829c8591ef0a5ad4a66b18634d137ea8c9a32eef09b509d1f3e2fb1fb87ba44def2823ea73c6dbf1bf4b7b16493fdf05031bdb3cbdb70284732b095a8e7c19a38cb175ef9c7503019aefc1e86692d329fc51f8cab6bc068026bde247003241248e7bbe9c0873ccb2e6252f2b3822059243432d8a1293ade8ebe190feff1a0e9f576a6c74db4b3bdb54ff81c5442c82be750a0e1a3478b3b7b87d7729062c1aa8ecc18a5c81ba240bde080bf927adfb57362673495070114a404e6ea6d85d72239128643bd91a4a8d293786fec0a4a0a715ae653787f86797388cf7c1d657e536fb25581a7201336ffb7b85c6883cc3840c7e09f3b7ad093e9cd93b74eeac8e6bd354999619ab5e17b6b6d3a90bae0aff5bc57dcf3cee6e51258e39d5d828d4376610828f49912cd85e9dc892942050289d1044fc03c4a1853764c0d066bb077ec8f2d6bb98442da9714fbbd308ae74999614bfc1a8abe2ecb8f55d17cbf09ca15bb2dba02907f1b7dd831bf85eaed1d673232e2a927b3442b89161b19f0ef4ad4759d837f01581cd5d7a28ca050736c1c84a90bb4ea441795e849bee64d238f54292384b5b728f36e8be9c0e61d6ff93acdd21dfbee841cd7fa42acb1f6130dc819d730d3ae931812e5128780dfaa8c624204a88059a63da1717432a6578695fdd9490b183608fc78e0b90c3004b3dfc6e00b761df8c8046c0419a73ec165a6ab0c5a732f22ddc14ff9922c8593d52c7c704faa7cf8a6c3024a5bd52d6151593d4731d4800b6c4a3721ee400dd2848cd87669037371d4b7393ae9630bf197a3ad708bc2a0df1d100de47a3f4840bc9f79b4086bfc85838c3aee34225705960a54ef9d2577ed85bfba6a582898a2738f78fc9910a6a8f24fcc1615d043679d890283886de10b06e0bd8752d41f80061d1900c62599be9525ea18e52c9d7184cd242a4b5c9960de7879d3eadc149d6e9dd3a62d4769dac81696101c8f68c5123ae8b2821b0ebcee2ffbe4e6273ac45bc1e5116fbd50537c2572f89725d68bb0e174c1111205e8913c58b4cdef027c2e1e31cfb305f1a55bb673d5bd7a2d4b26ca0dcc14cdcd50897fe2c9669a7642c0c5c64e7ac6f4e3693c20885275c824d699b9552a1d925c0d6f4c7bd4cdd7df0d9ac1006523a0471558d093006483500f5d6394998696152fb799a1e03b54a1fc98e189aa473539393263ce32f1947fddc9fa9002f9ed0e98036d1538d5889e56e7592c6e928f2e22fa2334cdc0deaf328884ff8be92ae01bb4c5db408808759afc1e1b31db4b85c0bedde32543328e15bfc888f9563a6a000186380aa7ea9a2608edaf626052e66092db067d64af3e59b5483609e40f9dc5f4109c036fa9d4ffd6327c8ea4b46d3c7af1d4e4316a378aec3e67521528b77bf70f0013d186c0ad7c15778024c64627038541658919d8b33827917f28314b334439edc00c4cd449119dc8c7f8e4c03e7d219f8fefc5ac926901870dddeedf57306c46558b52b0b3f014381a59f060ef0be0da6897a3643aadf6676497fcefedeec65f189dca49ae62c469244bc095183552fd9e9744bf81d45f4fb29612864b1c784bd8439782461b5e5b0edbaa260feaa1221b9ede02f4c2507881ab460e592cd3d04c999b18c7ca7cdda0faf6dee680c8f34e7cc3617db7fd7c9915c5c79a98494271f42665809fc1f8c2583206af319642f25a0fe590f26ca184aa48738cecb40a1954d49ddf18122e8acd2cc12223405e9e37b7ef6d0038cc7815d1c630e7d10c8646877a56ff86606c5d41121047aea3f4552401175758dab592cc33612f26a26cfd406ffb24e5fbba0a73293c6b7fc0566a00b7e22b8b940c0d7ac2cc2eb1641072253df914cab5d795f5b1719caf2c152dfc8d1ba5c9ee1448a720f168df951668b0d0dc144a467a7f3c59c3bc823bee5741bc88a3a0d9eda5f1baf50a48e9fce6223641d5b0709b40aceb47fa1b2e47080712b6a4f934ba3a66439859ee891dcbe6a7c4205d27cae7ca789bdf133871ba91c82e0f0debe98625d2501558cebbd9f1306b333c8b4cc348755c09b38b96ea986def16de019b486d5456c8ff7613e057872b769add235f4d80527cbafc60ababcd70418c9ac3fa084832913823239ac4202e4338f2e0f7dca737093cc9e48069fcfd2f8c9f072e48bcb543d5f6054b0c6ed8120901dc92cf339ee0b39fdddd48e6fb2ec24c891c0642514c1c5fbea6df0ac0380b11d6871f8d3cb8820dee4e86a888985d8438fa371864292eacddfab0e103cafc93baef0c4391dcae3bdb2b8db6a6fd24f83004cbc3b6dc773fcdb565612c48a764f3a45a7221c6d117e666afd219d8c43d77ef5bc1e274835477a0b0488b51ccd4f567bb3948eaa0bc0e3fe5dad18ff5bb6b10281f1e9c9f8307cab0c90e76c784a6ef4de3af4c5eb4eb0265cc57a45008d75b779558cefdd5a1b7327e6fbaee51a11fbd15ea690a0432f498ea875ba2b5c320d8a5119b648c2e21b635d04319793ac87a64ac6ad1c2fbd59c1258cbe88d9e9c7315e09c7ba7e5ed83c3a366587f2543e9292094c7f6436f39b18deb744a4f8b3bb12f875bcccfa84096e8c75da6dcd410bfb248c6965a13b21e842da5c10891a231c4ec891cce9cac1ae8040b2deeed9c9f13bcbb0747e2721e1a4b02efc099386ef4faa5fd2761b58b338592c195d24146318cb2ce1502097eca18d62863db8358a29afe640b510ffefd4cbd375c26e98ee80e70b1ccee4539ffb8b73675c7741e56dfc38c76f9e4fe19c986f87721d93bf4e82a7792345dbe162799a3a2563909b0fe15e2fefc57da4a75e08861f17af7d072d6eb277ee3724bf86f93feb58624eaf4bdf16115989b103f73e677754abcb6ae3831ac3ad33db73db7cea0d6c642d906d2de0bc6c77c607947cce65f10241f2108cf4d92caf177de45f1e0ed45b0a84793d183248ab95200fe196908b2e18876ff5a4fc695d7ed473ed4c1e624065a534d324889b6cdbdce4086cd54bff36a9110e42b8893a467658ad1bf591d4a92cba811162791fadeb7c0e2002398a917eb254d6d24f94cd146ceab820970e834de44e759b57d643cb2c9b33bb7d2c6d984027acb220c7e5b14c260c7ae762be7e9296ceb693caa7899cfa3c76666cd112c0fcc5bcf8adfa88c9ce011289d8643186d6537e0068bacd9b9a7d333be02e34099817b768863671080911ab10ce405c19494498d0df4fe7c4d30452136537ed3f2eb8891dc0822a6b3721a1c92c3465f5364a3288df192106ae576eececc4985f965e95a9810dbbd11224a1e7349ed34c995b047569e09992a3ade8eca85d84a9d7eee4c5678d8a413d2403c7fd6a41cf2c66eb7a81fb33c720618ed84397b9bb115879886a67ee6a18db264afda298aa71bbbb3781b7e4625df708b867ebbabdfdcd6dccbddb3ee8bafa914583c1aa5e7e6d6e43612d29bbd73b87906d42893188770ac9a54e61be2812bae89dfc6befc1a69be1b16d1d0434acc4387e8a64239f551d4ea93971a1bd04fa9bd53f82d849e3fbf92d5a5f3ac341a5b20c907af79e46da20b74e5d4c6f5cc4829b66645ce16d3ceff60b00d5a3d56be46d79547adb09b3faba5e590d4a57fc595c98fddd9c751fa1c26a8a5efe5fc6d4fbfea2ddb43430ff1782da04e67647bb3d56ec8fdb2dbe19d4e920840e06dfc9c4c78ad5b72e14010509d9e01d3615a415ebb97d7e364ef72ec95f7cdfc4f949a71fd4e45350bbec1d94733866fc4ce3949b3c7292711d2ae89047155b0f8dc273b2df03fb413fde56dd0aebdd62488f85536a7a58cfc8ef0fb2c680a0656c80ceff30abee1d8a24a5cc5f167067458b5327d064dbc0ebd42a2ef774cc70569bf522975f63782b88588d129c6c03e17437d28e2814125401bbd4a7f65ec79fb13508447f4591f029624c8a381044b1e329a59a15639ecde2bc1c4960b84cf07220501a2940e8b801805ff499e97a8f876bf0689864635447cb6fc88ea10c456fef101aacb0088215e7e519257b456f2794c827a955b25dd90acc8f6c5e6b5e4f9d816fae6ba31eec31287eefcb3769589a70e9d81d18413259920e8c1ffd057e344a5bce4e5d61842e3e212ff6845156b6b1df29cad59b385f8088eec5dda0a230190269a92c879ae4b63caa04a16f3e2713ccd8912092d71c6b5cac992bbe3dc6a23ab42adff17326056d043bb5e807bad5d9ebfc32af1025bfd304eb50b9fff2902197b8e9b9fd603cfbbb93239285dcf23c7f53aaa9885925c482a91ef6990e63fd81c04723c9488df456b3afb867b58e3eafbcc3ceb4dc384aae2ab5187ca776663e9fd3f9376fae606ca9656e3f798e645979b133c4a0f616e0d3e7535b0e01b65fca459a6c36eeb9ad8cf4db58a2fb3446093f66b08ed38e5763c988541313f0e1f4a7cdf6c799721cd226f8f40db998a5da686982c22f4bcffd300f583d038143ab46f39783afdea8d82b40fee4baa51f471ffef141f8673daf00d434a9cbd861734b660258052c97ac07eca83e540dbfc90ddd62a3597c64072f0263688ac1a23f01be0052096b4b9f40fa6a4df6df16909adece364d2ce38a184da41ddb28ffe78f594495e3a25401fa44162b3d5525564cf43b9192bb784af86f3fa3cc64a234bfc613c8e62496055db6c8f1fe55995c4445ab224442f046c5b0503aa6b48df4b93a6441761359c28325eb4d611aa047b057d3bc1af7f133870e598cf7003db18b560f9fb1a9caafe23d31687d7f55d5c2948eac93f1cdd478118101014c9b94ffb9935269f57e6d77bd6f5ebf9b9c68b189f774244bfe24350ca338934c1066b0d75146c7e56ecaae6f8096573dafe0f0fa7da03fbc9094150ee7c392864e4105cf2f8c1344bacc91fbf7c24bc723e80fa674fcbda3291419396cb0268f4a0200711c7dbc021cba6595304a392a41b2dd2000f334bff1e5f328020b469f9c105495139c2c4637aede63448764ef2a64cd51c115cf31eb19c2e520c8736cf38265280a87f7b0c2e3a42416dd2b740e96210ccce5e0c19b594305d892a7d5c02dee7dc2464bcbec5f76875bf259b5a74e8c897c12f26c1393388833939fa3ce3ad74f650f93102bf5229d490b9bdf577c9678e74f63ae958f321f529eed509be51da8eabf4593a5080179cd854b52a19e198d3dfcc1cc628062bd2bad4e243e65753047cc71337461a385101642f96293ce4c863d6d7f895be39d6e50502afe2063d8ea0ef0dfcbc3b3632993a4d499e522c666dd2f49bb430560bd65044f6a00634cb1881f5bd30796c624b73ef1b465a6984e7e7885bb9379e7ec26780adcbd4bec2ae0ca6073648b8e6fdef7eb1388896728923a3f684400e781e2dba434b1622c2b44b0726afb619c912826d0255e8d6e3379f8fc6b98bb83df5e43f79b2e0f8a72d71cdf02fa1f442e0a726d9bcdb570e0a85f23c7648236e1c4b89edadc0cc91ae9fea665ecb5442842053fd9b6e182c37a58235b219cf12a8d7007a44c416b2aac16d7591d05885a9f2300df72246c9d179252496ad9ad6f1ccb1463f9099bf060164436b1de361182f9b7800e88a895a47d7a07ab8cc681134cd104086d9573c0f76cab57a091b008cf9c2a3bb53cfb2e19104c45f522d2a2b01f2a68eba55fc6d42e5555b467a83c691614b52ade3edd621f61e27830cfd66230dee970dec71f067e111ae60fccf9eda0eca0a69fd6b9a6bc7b0347d2483632755bb8f11547c365f1d13bf9344a8e6beae42a76289e01843b6b8d9d93455c6208bbbcfe0bf134a161113a3ee31c4d3424625f5ec81525c1b7c7ae99cf4576be579e5f6904cdf4ccdb5f505899e82e7c10ea2ed15825e457b80f72bf73c13796cbb8521e4276b0ce15e4d8dfe7072d77a8ec1584a97fed0d6523388b48cfbf7ca1b9f4adddfcae9e47dc8646c7ad3ee65ef84cb44e453aa491c13bd828c3d79a4586443f61afa3a1601fb554d668e6cb2a9b8b895afb85bf57fbcf785be9ba76e43f3e2d1d6eaa1c0d2a14b1ad1f93ea72d7981a4548979bb2090503548b1e6bba4bf010576ede1edc325c642182865e63a5fc1f49ba173f121e37628ab316de0f64bf7b82bc1e16f71657078097208820200a96275b5e3611c291a02576925e71e0ed051f6bdc7596880f08e7c887f9a381f152fd2c6087bc57fd1c445dec0aafc746d47610f73f58f719920bfa77c030a88376af88f7f6c6c21e5f5728ee6e48c460155384df395a24c44bbf45512097c613c58ce88da9bb92d1c32e2301dbeeeea1902f02c81c39cd0a97eb69ed9d12bf9735eb8bcaaa4f0fad548a0a7e3d8cbff90fdb271e0f708df1e6e28200ad97f7c9391bce2ea239894c9dfba5056dab340ec4f83213cd0f6e54acccd6fdf4c9742b49f8c4ad717e7a25fb8a9337e8dff2e97aee48581be92066032d7eb3d0a21f40194b9658352375c77e0472bcc837eac2783ec0335c0510337366613662865a9aa0bbbc7d72e5cee88475705c09d5eb74812ec33b3ea4e3be9a626625a67b14fe2d434b4e5cd147a27c3e9c04c0c4bf704b27d7d52b9d1a5f998c05f297fd39e98491f54ad5674544f95c706ca6f28e0415ae223e43b065dadf4995500ac19e6b2867d98578113e07fc45d1799cb826d46c1b9369f74ddacc367a8795def88110d31813465d63149ace674cc22742b883b54d88e9bac987459ce02cb12a2f3f10e0e986b8c68fba2b22b1f9c6487908269d06fa69edcd39cee06d0a0a36685f2a7db5abd84b188610f91bd3cc6733c3663ceee53bd4d4ad0e74efbcd51e041534cdb9956073d35c23bfbfcde97653766e83deebf6eb9294741e403b977d016b947f69ef44fe808ade9492dd23101f8c2db9166b0e1d5cef12e6fcc44f4e772cf8fd7c02e22af18872aca8ded8e2cb852e36a972f63ff0968e26512519064378b58665048632e2acc364b477e90ceb97f9d1fddf980ba63380168164177e724048c5aa4ca17547ae7c0806fe1f15ecde8facc70454eb95a49e7067463dc1dfea96192a1b0362398938e74ebfebe94c00cb5ec7c6c7aa492e29656428d44648b86e4bec309e2cff9115c933946699c15161c6cd07c8665385f5e9e064417b86bd48f00540a5e30e42d4b049d1ce48a91e24658a776f61fa31e09ab0294a8b0787269c27e9ebf95136b4c85f7adf38eb33826fab0157862083feada42736711b643482264e447234154929fd9e28ccc004469ea36afd0959507821585d83e2de84bf3176ba3c894f0d88bb07325e5a9a62d6c503093b916ada90bc25ddbb8197b860904e7f87c04c7e033e2b3fd2982e25aa908f1b57f6975990799e9c79d28fe2feaab53b0eef267a4b3fbdabf398fd84b721c2c75ccbbd48c967ba0f201b36e614ae21f2bf3af7958cfb0875a8fc377fbe6ffa0d372770c3ab88df8c07cdb147c85bd7457413e47ecad473b3a00b2fcc9d620cce22f88fad47cc0f6ad71d81073f952f56692c0b82317168ba43b2f191c8f50143c94816d0e807ea847283bd594cfd0a37b378bd5bc2c05bf16710959e48970adf056cf63d9f4fbc24e4b9a4ad5b47c41b0a7d4ae9f836026a048d69d92dc18d1acef7fed64b3409a07492ebd76f063816a88b74ff644686ec4536f817605247e7ec26a9fa7e272dc5307fa0b75fa5b048303201180ee16370546ec571ee157a948ec99ba4a6b119272e726fdaea958c613e0c80a4759d5e48c2deffcac702d6b10231219e53cd9a91b16fe8815ed7d41b434536e9043b39f5518acfcad62b8b795baa55a6bb46bd345f784d6019a258e14d073ef7f6375a0bc72007b0a85e2b09d55d4b3915abda0d3abf56280315573092c9007af7dcf0c9885f21b6c420e44a049eb9df0799266e087b48a9b0ad775879848d558a788ff23d9495ac0162edf61add86d409b62e7eb072583556a1ef4bf6088da631bdc6e6c4f924f2692e88b18c11380ef87465fa0e465523fc758d25691a629bf61c8d8e98a70c91084c980a8d7e4929941f405075f41dfc2606b06462a6a8de36554bfd03a2d9c1101aea5c6b7f573abf5cfd15c6826fdd009d4de8194f7822a5962b6f55a20f2d80d8ff8f17eb6b18dc908ddcd134ae5baca0bb7469dc4108990ff503ed8bbccc6f63a684d6537e977cc7b7aae48d47dea7ae0023bfae63a0cf874ca1f6dc33f852b037dc7821a3cfc3dedf1efe0785584ba3957fe41c19c15e4d8ee3b518a10001ccfb2fcd6f85abc4182d837cb0d78279633de1f615659032c6dc64b6cbce66780c61703f552782c68949df47a30f38ed50c332e9714e9a4c1427d0f2240e6a4db949275a80fe01d378efeadc251d031f4547a131bfb4abfc7783f98b610aea8d219c57a66904b9cd82ae80a548d67f87e4bde7e5c76362cdb4e9e362cb9e5c87da496fd544b1950eefb9231def5ceb32eaa6b085ad3f14727dc93dfa895e67d2de851b3eadabae68e0509ee307ef4ccfcca13486a8d7f75d0c2340f282aeba6d3126bd52578a979e9b37e9d927eb793c10d766e71577be4fbfcaf54b1361b32dc6021615d8c5d00fd08c6e01cf258e41c1fced8e58fc1e76c6c86267c6301042ee02840e9d3b3cf225f2b6bce9a7bd9cdb87c4f247c5b47273245b177f09f2f4634f6d5df29502130ae7dc6d616f0f38e3ad9b7c38a698c7026f8e115e5c38e66f2db48e762bd6cb87c08dab469dd21491b6878be784fbd7f50357daebd4f369603b50217c20dd0951cbee55618c2a09a5e0f4abc2b818c6d0b5a55fabc81af012aa665193fb4d7cffe85d6607ebd9a19b3991467b100e9de2d9f4d171ec95a938a17167bcde5a72dc7761f179e0d75cc5f85400262439631708e6098ce71e9729877741194b0ee454876ed6e63daa21cf046cdc830b607b39ff852365c97cd87feed814d70cdd0bede57e7f2cfbda533254759f9b8b622f8bc3e93d5ed515254b2518b2ee1bf1c5dfa94795804a80ed2306efd440b03ed3552d978c2dd8542d2f5237f9fd4215bd9172083fd88bf44ae899af56a0a8d83c1ecc49baffdc02a16b677b9a81b96997c8e2f67b3b1d83b4c81d342fa14b5a03b989282abf7bc1b53eeebe640364878f71c6bd7064aaef7e30382383774cbc7e770ec94dc422c302b3726eaa07346094b83468bae4eb3aae66cf69ea7ebe0233e049cc3a364f78a7385ffb5f4aa3670fa2c3dc309255b9bc7a7ef9f4fb2d2a4baef23315f8b6c6064092c6821a0a3cd6b9f8a62b5402604baae74c34c08582223aea16d14313fbf897e921a8a1c39a5ff1406894f9ab318a56f7149d7f364254d19dde81a67cb49b0556f58bb8cabeb339b32c77f8bb625fe5cd5ec628ad964fd4aa883d3dd94127984860aae33c87dd58264cebb0d4faf35a91af0feea986c7e1705460bc61d8eeaea08c0cab4f52a86729276371d8361227303f0f0f7a2d85c7565b17b7a1aaf17c3b682537b1153ed0e4fb48f29efb608ef715d9fddfc783978537a6ce3b347977878ddfa8febe12603b2ebe6990dc738554907dcf6ec3c9eaf3e90b38638d93bdb31ec00aa608cd782b80101dc18808ed68febfd529f5bafb22cd9c8c0c6b7e2651ece8dd1db171f3c3d52063da28b5d7e21026cb85001d3085f53f060d634f0cd6e88820b629a4c8114fc88a288d83a1a72b1b8419044aca246e2bc9a0c87ca2994e3c006f0f86d35378f701cd4093edc38b77987537f694f52a7b18ea4f84030cf263382c29aa49d4a800dd70b71a6fbd5fe992c33b3a949f045b61c35d8984c8d8aef63a29b9bd0fbc04943d289fe2525a9fa8360fdaa1c62b8bd82722a2f8af909d00fabe7949c63405ee1aa9a5aedbd0e4987fd447384ca2383ee91fc1b886dfa1bcdbc920979c067164c673d52764b404e195249966580144871530830e1ac8064176ca992223c6d02d3bd7fb6c0e81da588aa18f24536b76a3ec57df6f612bc3db4a3a63531557b020fe64db33fd35b92ad86db356d044f8e11c7f0606a5ddf21a37d3c729b3b300d9b4e4dfbaf50b0914e5bef46c8f037ee949f45b71af171ed93d11db97d6a9ac55d8c88891f366a346af053daae8b110fcaf39ae31a211eb05e1ab3fc899d34cdba82596429b6ad7d5d99515e42c48553ff227084c62ec37a36c1b6e55c40512785ae85183bc06bfdcdab98387ffea037d2a83b6bd9b7e22ada6e0c478ca10d4845309eea3420769ad513a97e279496833f05fee6451b03db54cee80268ed31eb5d5a8e0ab337112ef8cde6cc37611b185bf600cd1e06f3ceeaecff00a618047bb2affc7af30f42cccb62f1ee2a90afa2489c479b0afd564dc70090ec86041bd5509725ba85a92e36b7dc9691e95741e5e161f4308feb3e2fdf8f2f954029fe39be1a37e6825fa083d191fcf8acf3467e7a3a8074e37766afcf03ac1f42add303c6ae170f6e390b9ef731381cd59208f1d95c8a94d62c694603e6607ee94b6e2b19195bbc9836e54dcdccbad76399c6bca70a2f56148b3f1e79c40d3d2fd36595f0874ca3e67b97bd6f8fa0e8a5321dbcab2b4307900fbde096710814faa8644e4f85ae844b3174eb114e3a3dd41d8ecc00a2d78996479a40d7bef1f1eb0b5cffa602f4bcece2b91bfc2ab6465ca5f69310ec84d3a4574d83cfdd2283cb78fc4ff657c3864ece8c9cd39d5f8f840b973183a5da8abac88019b904f381f308f3904695e299bb7f6c17647e2db1a8361b2f408dd7e408094277e0825f101e0d0a4d500777db9488f8e4efb7af3dc9dc800e1ddee519f1dfc76e5a26d0bae26d73b817c004c512865a87e76b336e292093675ce80ed6ce1e148360a59da5bcbbe5d76d311d4ffd9174d9c3fb82f2f12cdb276c2440b96c1692fee8cb2cee0207b0f881137b718243c73e26960d8f19cd374febc57e2af8ad48669d9f9102009dcb7dd81a0fb22531233b53897aa05621a2696b6ad46941bdde59d99d50044adc2400734e45420254606b863d3b187dc1639f26e95c34dcdd966c4b4afd17db6dc3cabbfc0ec9cc3dd85d9a8aa76bbc19644089396d53adafbc4444436df5038ac39be9633b6b5b117eadddab4a6c1a2a28bcadbc0585360bffbc87669aa20cf6e8578d9925485651164d3e851705606ce3ffa1221414fc57651c16d78ef278141f42c005f553aaa1316e645e80c949253d66eb501237ec3b175d1041ad77ad38a302319fd2d8905292c50392dc5df4d5f4ce2ce053d93e009f4d2ab2d64a7d260f5d2e4a72656f975a3dc7bf60ebdfcbf725dd9a8a673adb8bf629720908b4c29fcd607720980569da7eba85fe747bcfe983364573b451067201fd82ffcb3c519c713a5d42a9a5a78892fa471535bad697002d7fb6f657629514e927217af7d9fe87261124cd1dcc39187b1b8a523e0c1b694c096380ce66ff016521255e97d345e967bf7f574620d3652b63c6d53bba374cf93bcd327d7f7959291ef77fc184b6c536eb357d21a7b42571e6bd943c202358ad8308f4213a4a042662d47dec46c7acd229626876a4c04f2eeb0191c86028241f63493f8913aee303e6443d844c09e1cb9bb23e51dffaeb0efca1a8b70ff98fff30af31b84b98ed039e38c63c14b59ecd7370d3de75a10acb46c529f8aa2e134c5238e2b05916d214a79c1e55956466a652d8b5d657ca577c0945ee13a681c6ec7b07ef860a78d9ea0f06645ab59943cd583a433b801c68a654c3d8cd4a3060d836e921ec3573a585f9bcd30b38ebd812ea92b276c244dc54311933cd08f00ab1c7030c9e43cb92a1622da5a31dc5968495059aa856a6b31e985b0126626b597328a2bf496aef1f672d203018a6c66ce1561fdf7d1f34660021b0a92297643a2274da0b8337b6a50e72f59a6a064edfc1ca222f443ca4c9b3cb6000e6a13c26fd1064a7dd5a38169749e87b001ae9c88e3773ae98827f4e367c7e665184945efdb8650067544fce3855e911bbc808643a8f6d12a828ed65e4b58c84043d471024af9a73098a7dfe6b9a39cef00558c47dcb08b63d30c3da14448ad3ed7921b79ab6914afe98a8d09668dc992f9ba11add966ff8f48c276e3f400cdad20fcbc8d32b08fed92397e1d4d72079232985e56e10cffd5e419a43fbc11302a361ce24e4f1120a65c170ec2044f33f014613653290373c06731c8e703ec51f0c776889eb5c55a6a8f66e0c754b8b3251344602c578f065b54a4eed6b004f3d666cc99d25b51203476dbc505773e1e56939a7108723cb080bfd8fd8723c20ae306ba7efe1a2919b650094e61380bacd1e02124d8f532ed9c7df024597b764e4394ae956c02c359901b2a57469edfd8ce83814ab9871fa5114af464fe6e50782ae8485d52d7184a978a5cc29232fb38a1b12cc441db4911a4bc078550e1c348248fc13d3586929b0c89b7d8854f8ee2ec6725cce1c060399ba20a15cfc3d3ea2fed9312f91e2f93ea344d4ac8f7bdf183f74fa5f82da10a3f7b7b4a6933808d73724e957a11a0ff5826e432ff22348072fd1b6444b02eb491979e2bcaa46e024ec39a93ffa6f58a210ed2d1ca843f1c67b6da74c8de40cd5b8b6fee0f83116c822c7ad8c1c207b080e6254e660192329f14571b8395d527ba90b968bf91a8a49dff0f481e914bf606fc77e0e90ce6698328a2268642e91e94e515a5f0a0cfd6b003a054a8937d95d8b048b071b37e9bcfa370d9d0815f26b8bd47686d42baf9cde38a857ef44154d27cb87c0bc15ec9743d40d155b51c9ea824d0caa14db6dea9168b5b6409b5b2fcdcb4f3e22ed0aea7f344ef2c173531c3b3bb7a38d1593720d1e3a6a7986f52111fd71e13dc397c286ca787c0e1c4cb6124090d24cde73cc6f7493c837226ef3afa22e0364519624a40c5cf7fab86518f323b2b20121c16e31ac1c4c642733238668342abe0407ea5","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
