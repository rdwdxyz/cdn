<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a422c334a03993db385c3fac034be829d18e905751a5e84f943cf718854f7e1dcc261b2900d463340debc4b6453555f56e1160b37117a0b1eb6da1c1acd0d35064144735b66a614577525c1b8954c99eaab8491c316a8f8472962b5780a0b9c1ddf0349b552cc95cfe8c12a5ca4a510e63318b039923c21b84fbdd4d05d37570734f842b1c2879d0f66a7c5eeeddb5badb244b0edd02b0294d832ee9426c52ad0486a5786a3f49dda4ce44c268f8f00f5a7e0a2c43e29a8ad72bc89a7920a390d547532409081552c0acb122f19f75d6fadccab125142879195e280dd2884b1cb300cdb7e45d79ffc2b63f87dad57b424181bb88d962c4eb9b1f79d2fbacbc314491e2d10a0a61ff96e9370270524813eb107f78011e12f9b0702ac52a32d65cf0dbdd61409598a0918bfa1bdcaa0555ae1862857639437438e7e1c7c4cf18bec28f3ed7f207b73b85d8fc1025d8ce8a3413f260cf1c2ca348595d7356766ffe8dd9b94453bd111519a320ea730aa53894db1e1f1c43b721793f4ee7d46e2ba03fd6d96fb266be948397631d751cbaadffe522ed585e85e28feb7bee611d734cab07157bae7f5ee5007177093235fead1ce0f4d4c65b6fb1fbda7406a290d64acfce0ca5b6c039b7bdea7c219fdfb453fc973cab80341673ce4376350347df1700cf1cd8ab885050193f1a62b8d5040ad5a2ac594364747c275f563887cb55ecb207aa831b4db685324d9037cc5208c9866884c232ed903db14ce2302cab4bf163dcd93752c1b5ceeb408f9d4f036d86c13bd5a036bb12afb1133eb1ccb8dd3017aa50f96be9ca6579f4d93ce6192305957c719656ac402d8350d8017912ac2305d0db966eafbbe7db639a5af02b59f6108bc8e776aad6a9c5f762289fc9dce63d81de854d8b3a3d45dffaa267c71a8e07922ec9fc464c2f5daeacd6baebffe0f299765df98b165617071c6bccec99a695db3b50647b638320e2b21b2af1349ca6c776967e773161fe52b4c0713d73a9b9ee128cf4bde41010a37a0316b0171898735a401e7f2bebb3479ce1496b2eab2ea7c5256e902754cfdf5eb81019180e1a65ddcdd6907b5b2fba83018cdddd07f9710fbfe6d1baa89e9b8f97ebe4dc27ed0be9fd76db078b9d813354578c309b33a16d1d810845e4faef487698f6459b1093f27fbf4fe944b8212ed485eb9e6b4652f99a0e3595a49e761accfc0b21c0e7f622b4390a1b9b10edcf747123d8adda49c4bc900f65ebbfd93ef6e1588c4aad6e4a32fe71737ffb21776bbc02a172435a2a733055247ca43116000d9edfd3232403c4fd0ff0ab673c3ec374bcf3715b7b4b844548b8b367352413d77cc6bf3bca0a2b14fa707d640bcde4415acf6b1cc1d389aaba9675800afc40cfb137a390ee728c44b714783089644cd095972cdd7c63d425d1aeeb9e0dd8d82a59c3a8d480852ded790c1d070fdc2e41b3ab57075bec46cd5e76507f6a48207adcfc7e262988e210ee30d8ace615cbd03424b9796202b51c0ca2a20fcdb2c1997c466dff1538d2ed857f95183d510bc04b82930bb9a948a07b50a99ea32b243b726ec09c17d7d5b03a9282039a193c108c10237005219462604cc096d0aa88b4235e10a4480f0c50f505a4c2a26f4ab124c51f1b9d9b4c5ac746111e910b45622fa36af6247330ac5f566932a473c3ba58c9118e5872a4b18451b179b6279e3f0af3ae1f0b7deca1883e0bdd944cf8bbb3ea691d3cfdd89912c69c5887409b3def1e52d693f6c340a65c42ed07c4394a06cfb9ed767fd8cc635f32cbcb0c39cd240318ce307fbbf1a7a9a763902fc629525671a3bb3bc23967927fa1ca6d7e8a76377a4162d5df9fd6e2aece37f3537b5dca7c2788504f0277f3ddeac691e155fbea61309d58ff9c3888099d3691a6ab98187e069072eb6fec3ae367a2decee7fa394f59be4eb83ce646e72d3354c2e74dca4b32702e7fee284a97ac31ac85b72318070b66e3ba8b8ef1677f115ae12494eda0ecce9d53b8aec2985708dff75357f0aa1b4bd3fa33ec66001085423a6252c01bd4c8715a9e3f624c1d934d850da3396bf7f83a01f453745e0a749506f571d9ff0e491f2ef07427048401792f29ee8f8f9ae3a9fdbd2a3ce933e73ce2cb37c50fd9e3f843ca216e06a79f8ddf0cc98830e97cb1522a42faa5755641535cc9d17d01ee3f07ad7d124dc701378e25644df0cf70d943254a7f4ab04eab096d67e53f3c39bba3817c5e876ce05a2944d39dcef7201e980d99b2a12fce7de17f8f5ddc70cf649aef3abfb188f47566884fb8e0acc4662a3607af1dd2a3d06a1a7e463374dd91bdfdf44aa800e68a539ae8a3ebbf34d55e40adba4405f0f16dffcb1f7b4b0668d2cede96ed3fc9facf29c47b18cf9a8d8a9fcd3e2add593458de7357e4580426bbafe14208b80411bed689b5541b333e03635438e38d73f216a4e2357ae1ad884e6866a81c53cb65ab5bcedacc1058f41870d85e7cfdd178e3232d97c9b6a1d8bdb7708722d2341669706d3400b891ed8f084bcc09cec5f523cc3087a61911cef8e651314b0bfa54c8d04e6446ce59baf985a75990e92b73be4f83d2925196698fab51ddfa61874dd031a800923345abef7b4cc36698b001d1286651a05e77b41b03e975c4659dae0ef01e8e392903963dabb13f427e48f1c3620cf7e1cbf8e702b2534924359c061265fcdc8393899b0a24150a2dd612f6fd1d3e81eaed6856638e7dcbb661fde4ee97737edaecd752e78c1b82553753f6df04fe87dd97aa7ee48554fe44f8d5b13d45a58dc749bf1d6fbb1fae84155aca3d676ff9deaa8ceec2d22b791112308a6c970b13ff594531a9421f168ac476621acfc4ae5c026598baf543d6faec4ef683d3f4e6ccea8542517a8e2296cbf8e6be20d5a89130496c6585db221954947efbd5738a4e359717712a586936622fb1ec5a8427127e2df1971b6bb7148a86ca88e1da02a736a40484f25bcafb90bfe90a774d0095225186248839fbebc6437ecb4ac3b2c083a8e67007b486f2a8a9c6e7eef0023991f4812c52d756fd7c34bdbd557899907ec2d9c7dd40b5a5a4df97f8474ae96cf7c58b71b43b66a675599777879b411cbdceecb0e04670367d5b8a35c23bbad648e2ddbc62f4198d34c02ce5720857c7fed8fc02645ad05b305cec2d547fa27be5e44d873ac61cd15a5ceb2fd56cd19d09414ca204afec09e0004fa057eaea82d5ab3e9d5d33eaafdc36fc150a358a25003226167107bd2651ed822b945f1adbed40f9c075259c11474db3bb60b19f49cf3f35dc18eca4457f13d60c9983796834670e741a808fca48c3e50e65403fd59d93b4028dcf2f9dc6e9cae9d857e9a00f6a720659b1b10605fa9be6217b36256723dc4831bd944fdc95a5512e804a77c98420f13d319764374b57934f778eec0ece2e5dd254e2913564e6cb9f30bd6778350e8251f377a0dce88c0bf63ada1fdc71454cd913fd9f4ca489c1a11aeb9b4c17032bed5baec42101795aedc9c37cb471c93c6f26dc83f0aa9a7bf4aedc90b41d7f06de261655783a60248345d702e6c7457962bcd9863f385bc46e5d13157399996319249f68a014d871806213f1cecbcabd82850d673dbd5885c9b68e9272d6c2fff9aeb3fdef47cbbb997c818cec23dfa59e4c9a2ecb1eebe42d6a8d0222de92ee77342457a31cd102fb92806cfaac02116d3f8c25ce82742bc20b8f0845a7d30f7c9a07921aec903d261d2ef23c7ac909551c69f3c0e1615f93c6631e5091867fd3cd36ead5596b1f63886698ec4e687b894ab9d8285e3192da11653d069ba3000c50ad219bf1bea671c5759130cb7a886739877dfb7ec0ea445be423303043690c20faa4bcd6be80e1390c598ef413813ef1383a2fecf0caf5223d7982ae347e110db8d5d329b54bebc310cee5ef00510378472737224d3e773944252db603ff35eedfc0e81e72d82b43d3dd0bc7b9ced63914d92577559a9d622048bf81b265c88508fbba89611c29cf761a7257645872ff233383786474e33d3b6df7d3f9b0649586aca13aa5011224a953931325c393571006bbca3d41e979b40c11da40228f7f1021cbac80d6347573a5d37f31148ee13a2293776773f873ca1c55df71196d062badbb2b93ea2e703a8f056f96b31f7ffa1fedc17aafc4eb884e0a4618265713d762c0201fc4a6edf6ca72437c0ed0626526aeff1d93e85daec8536604bf056e45688b39b7f0b7a151f8753ce9bfe303a76ded39672b2af98ef4710f69e5068123b2c5c2d23b5055f242473449800d44304b4eb8a21a45509a730b23a39ab50122e07b68e1316af6a5cefb8d625329f640491788e3afe2d5201c86e5aeb4df1a44aaba33945165a4d03666d0aae0d61b3e6e8c1b1203735cc1cc713f466604a620a92e22584554ee8dfbb6d39bbe27298663297b60457bca14b52ad8a3a745d9b0da7ca237d50087270f78bc21e259c1622fb11457814f9342050609818e08fb93992c6ba5be655bcb030f902168499bb015997a9ffcd22d4c4a30c6781abecb51c1bdb716aa11baf4b7b96bfa421f01c62f91ef863f648480d6ba06ddbb33af9f8334e64ae370e32c132e235d16acb48192bc1a6a9144c0999b07f6998d6abfc89d48982fe3d1a229677d6741392bbf0db739cbae1f25f76184767b32d3f88b09c25167054a67fc7c81c8a451000ea861b1e55525d8d0041702460086d0832903b152783584ef4124a60571bbc96cbadfa8d6803144791dde2d5e8f6b37a800fa1dc94b9d0be265f21e9c429fec1fd740a7a4b705f6908e57765eb24692d71c9e6d631cc0873786be75fe583390abdc87e2e76ee54592290317a46b7a62f021773362c767271ed111c23a7a1dd2e9041a249c260b7e1a451b0b17b8e91d44138444a05fa47fa53d7de8571aeb9595029ab4ddc7ee8f4b4af5a6dce0ab846b737a4a5d11e6f226e2d2d541bb1eb37fd9075f520e8f1c02caca3713ff342c064b2dc73c5982064e6d91313b867b81c113d17bc3d86fc0ccc2909f92a136a5890fe139d3d22fd71aef9683dd9321feecf7bcd0638a661d0371834a84071c0bc6ab198b3abdf246ccd09abba1c081158412013e69e9d7d508e55cffdbb82b40f963bfbeb3ac741d1d08d82fee4a33a668c0e3d938be571ea241000031b7fef59c88f40c0a991227e736a0bbbec96b9c771f13028567ab9c2bafb748f00ab749e2c563dcdd832cd9c086bd709f002e546016e4c06c1015c1ea43bf653981be61799ec039b5ab5117cdffe5d557282bf8e5fdb523d1e4789467729b494a953528f3d771dcc067d5f208a4b4ecf1c0010b2ab0f7711b4abdb8b40955ebc582f9978214c9c1f37b8e03fe810a1746c9717132243c5c0a9d6b7712b66debb928cb419110c7d3b7114dc2bfeedeab9a69ddda6ae180e73c7d8333036c687917c56365f88a4ddc03d1d795f9ad56fe6d678c7052b9e4da60bf1d2ac784095cbe9b5767d48c30063172b3c9ed0baf7d8c2eb081525cbaed18b81f5a602bedfcf8b18b42f2d499fa8de81fb2a2a6f537f6d95d38722de42c9ac1d6ddd257473e8b5330007a7582704d372d690210c6e894c7abea78b4eb426375cc61b58433897ea267df022e23d386f967caf9d51b2941f875e0937c1d44e38d54d11a9e695a46b945bb209f75fdf3dc99ca0f588a0689f1856b922ad864d4fa61747c3de550d08a47ec23355045224cbb93a03a6135337a51331491ff09f587dd729f39f44a5c519a75fc1c31153ed2d9a9a89796104291bddf518ebed24dafd7ce49b73b523ef42d060e29fc12e06ea32fd3b1e8b4fbd0897e7d7bc4e86850484ed448a567c90667088338b42c7daa1b45229264d2be758adcf50a2af009c83a7c83d221b24b5df6345c1499c47f0b4c6a3f1a784583b810fc0d6df498a89a4d4adc72c1faab8d8889745fdbde508c6309678c36605b5a36f7703ad4ee8f7e0fec6f6f5ce06a04ac3f8128bd21418c18fbb771ea2b6705c4960c36b02ba3d0d66f0ce43a387525492d622f27ea07360719080b11afa1fc3e8e6b60662b36c2871025401163ab2d989d599a35c59016c0cc24b7415c33e654eba51b753e0233f5fda14a483066a3c70d89cb9f9626e4d1384810f1cd7298bb37b781eb805741377f13eae9e825be31052da44e5291b60576c5cc61afb8697c52dfe466d3350f027741ac4b76c6eb3366fa8493679dc3e3025d14898e6675c77b48d6ee28544b9e5f73856543845ca458065dff4798b326974d909943c47877b70ec5933af48ac36cb0e4454b1ee33e95ab9b78215e799f85c3de5eb20871f6a98508483d4f0fcc34051ebb4af1c515349bca46ed38d21b70f88c8f12e392668d0727739cb2e79cc854b694f0a5d4eab14684be470c99c06b903faffc923bf920610a703139179d1a81d3a1aee195eb6de87b65bd1002a8c9993659ffe266bfa7296eae5714a14cbb5561b8bd7a8adf1cecdb34e9ce301518b851499499c3e769df6f68f39c71da8cc7696221b068eecf1545f1efece2284c1842af4f4a74d7e995ae877bb78c1780bb848a9fc093c15725417ce166b0801f7b6ac0ad0ae36976163b814967c2067eea20fb069e5aa9a626cfce5443cba8ac2de2d600f14c85dcf020c3562e30dd97d77e4fc69bc1916561d46f2ae1a454e1cbe03332470898bb6748df8167f6dcb5d55e24666e6620a83036c89457cde40b8a040d6a3220f45b550270a38211d0096f540f68280b29fa2b061de24427e6b08e0bec21d26cf6b399dba0a1eb8328ab60cb6bb7758a893ec9f39113859942aa65b7f2bb0945f0b29c1cafce416e7c07cb3d5801073f9752e5ac356cc5f944275dd57dffc471d318e3f6c7628e160d2a9f311c6e074482c40d805a1a6f39a01a3d2846f914030ac2eeab965c4b8d4ca84c3f131b1be3c8f4cc921705226ec35380724fac00b0aef7360446fe3443c61bbb87f149a33792a7bca4b4853dda570fbb33435be008a8c2a53d417570cb525b3bbc0598c6eccf22d32f9f326a0c45f7a6617a046dfcd5ade667fda203bf5f68d957dfbec7e5ed84a318add3a034d09a3d2567a6cf005c7af13e2b789545ff2323e2963162cda653789b25d0be57657eef8a4568897879c390911d77b8f0ef8f782e9909f3e51fa72771d4bf0f58ea19218d6fc6baf2bf463845775609a7601212d6a8db2d814cde3195b8690160afc68bef47186c28ae22bd6088f72a214cb0f5c2d2569b9f28564d4b1732252903334e8881a075ea93249869efaebf20d40427e5d88dcd89d19a21e1e85c184e7a9923d5ba7870ce41d4d68fc4dfcc2baf47fd82586fe63bd8bac749fb043418cd14c083e1ef2e769405a21be1950d8887d8151e1decdfb66e5f405cc320a12f361c526716602ecd01a73e8e103ddc46934f4d7252929a54dc7f30c7f22fa49d8790eab302807a99e632699a4f42a1eb2f0f8990eac0adbb9a5ac4d31b65c3376806fcc932c68d9747364983409788c634d6cef67a5ef6b1dbdf8ebfdd68795092bc8e2a3fc0869bbe691ce3e7c0b1d02f99459cd7f956fa7801768ee15d703193821b2d130461e5ba9200deb4cbed3f71fddb95d627fca04d8b8daa2da0725c8444a7fc02a1cd79add943fa666c861db7200b1a82030f2b7d322150f0dabf2b98ed934bd42792f2d9df5962027cd15d4d537184fe4e3d7fee189c678387cafaa6f149784ca93a8cb1995fd5d45d16efede634e712a2e3f6063cb37b54501c8ff65950f565e8c9d14912d296d75dd345b9e0beaa3d2019cebe40c074a17359ba7e4e73b2d83f27372f9d93d84c074d1439339bf6b48582395a0fce7c818223411ad778a936541502c6ae1593714efe261c61b19a3d29db8cd082ceac184380ca87721d854ff8d243cb84ae1f1ce77ce4b08a4b7ef70d1dcf36026045997f855bc519e881e88a78ec5ff9b32c4c2f10b59fcea5e315dc6530aed928295b6a3f9e11b074c5843092b6349356353fabbe6a901d359df9d258b9e8372505ad945cd39d0a57a0b90e94470045e2589c82a0e77f9acd8d9dc38ab1b67f8ab4eab53d1254d401e79417386e2dfff1059f7ecda18f9aa361a179851738668e90181878bc79b7354a1b67898b5fba53e032a4718c8739bf0a357af76a719b92c4dd5fb82362925411d20d4f70dcf158d0d54e703a4cc2d59eba39e89ae171a6ab829921b1f479d3f801df8ebf4c200e5cf4f21025a0a450548c50e1472fdfe1518fa9243050a46cce77894e0784ee6679230a66cac4dee8d96c8473992508d3780790b29d9ec7fcbe4182695f48f5422a9facb151cfdb82db18602a78027cbf7f99cfc0565649b65f30bc86d157a4df078101004e277d929295ec6731c3eaf405d9ba42456adfe3567aa6e441f087673e13928b7d2dc14bba0266b353645cca11637b9ae29aeea10ed35cc77f3d1aee72c210865591491e54839971e0a4bd86c25b9d001af61fd02c2012b09001dbc124688bfbd759af35b68f0a773c2f9b1da9cf6099485f01b77821a41b20f9d457ed6276c3e4f81d0e23848babfa51c216b09be7bc5edd2d86e5f1687d6ea962c7b5f98fc1cbc75b102f2c9988d2e696471bb191f54970717d06f62c7daf94b480bc7a76930f46d558788ec6c51e193010c8b8a68ec0d072a8600cc38c14faeb9f15f360ad913db0fae490aa82831ec17d992914878d93de57dae8c67f639a901e54f61656c6e27871c380949e8a85a439e6d01653b884c5298d943ec35cb950bb1497ca0561896f8b1870ddb117b7db1d186622a484ce392b0884e4f5f9654062917436495b9a08735463ddb1e81188f932ae43e28fb9a16e24e17d8572fb2833999a998a9878555d86ff76e780293fbdde25121d210f8b30acb6cb9a0be75b9ed97d41fdc5e31ef27775bd2d85d2fd1ed335777fe396da5955504e038d2675c60d647cc276f647683b7c545528c6f81e09058ad2f3d26af6d875eb5d3c1575d65e6da8d2de966fc20bc254f9da30f2a2d55a0811203c38855731864c645dc4ba9999c780f3300ba7460a133ab37cbe16e5e6bb63865d9f963c9d74a0d469b20e1294b79334b0db2de6b11276e924f9049c3c1b10a58d1cd8843309fd2a4f8fab851132505258758f2a38e7f3efdba44cef44fad227a998dc90c7aa2ab609a49d513a891dafe90d04da13bf2b9a8377f909ef329eec9eca9b7b28fc7b7400b28d925c901c7a3f8abc44ec46246ba3a59a90373e683e3a980c47fb7f1a401e24a47679efa9d445e305576afc281c1b3ed39f532e56f2cae54efa555fd7ebc9776898e473dc6cce7e3bc0fe6d64a044007a34d76851f89443601e2967b2365e8679105df73a16d8d05b66a01d8d495dd05454fb693eebee7d3ec97b9df81d49cb3004f4c21530828e0a41bc4a235071f81a8c87413a70603a921efab8cd7263a7f1d1c31f26700802763a2d60b57885911773ed6695ba44e98255e5a85c346f7b6742854971608a6ac1312d22a0398da20761ffbb00077bd61b8eb4837017a61e2072fffc22d4449a611a42f7a709b270da0ff2e84767a9622c2180de7e74ded77ccd80232144bf79df1e8fe41e9ba43fcdc8762bf00315c0553d5cce98fb13047e82e304051af43ddf410a405ec0e06af4e5527131934fc43087567c170d354dde4d562a7ffc555d6932f737493963a4129057a0d817626ef746bbf96ed07328fbe8eee83a0e626e51cfcb4bb6ed36b009f9d6c4ae8d0dc59ca12848496cb15cc75758f92dcf497fe1fe4e51d97bd2db94459a3af11ebcfa6388006cd1ebdefadcbb01cd54bfab112e261832356d2eecff65e22d924dcd3a9fdf0f12f5d3f60d12fabc21d2798b50fe1deb15c25467eb63926788b47f997ebb8bca165f85d0c072f5cf97d2555a2edcadb09c0cb46c32726a0ed77dc7b74d01e3ae2f69519cf0d43c895a93ba449dbe9416ba557e7cbc45b8cb96defc90f8b50431decc94251ba27fd90a038c3c94d2159f030c11d5f51266b9091ad084e5c58a09f665129383f0a9aa9e94f05136d53c07c545f8306252141e0118bfc84792a7a0b1ed9a1bc0c56757526f6de6b475c2e9b211087f05cc33b6464e0d96c0ee49cf7fcd384f414396d4f990b1c0033b560d155e88afaa745fcaf297eba74babf261bd8d91e28b90330f67976e3ed27ed23ed1b452a1823671906d0fbdbfbf844d7191e4f7a5b122197f24b1b912dc618978617ddcea3acef33b7bad323601e4acccb9b3bb077c1f38b746b4519520440eac076b925d9855ab61dee103a934bd8e190d44095a11c93cb4717a38094affe6c46ea6f52804ceef15e62a8c333a65670d7a35bad7e6d5d65640d7b113b401320fc61286feb354e3567abb0c192a1219a4dbacc9e5d523ebdfe37f8d11c050b4d8cf04010e4ff30ee03e57648deebff7b41ca3e79dffa659ef6a441b70d25bb843c1a45beffe59a6be0ffde59c6b99af6b5877fa454620a8fb368ee5809c21639cdd28040cd53b96eecfdb3af407d6f7c36795f94a11fff4a20da295ec57f4533f2308441191bf1ab895e0a478a737be14113736f7e8aeb435cdc05c3e229dbc6e437273eee3d7cacd61f14bbbb91ec39b7073a46eddee509f1122066219095ad8028fa3c5c15aa9d78f9d2bf60eaad759817880fa6e85e31be557119b3bae62cb03ed820ac81159561ea03964a6c37758269b541949c552d4fe60a2bfa14e5e9d5ae5680f8dfa6ee30a2022beda342973d325ddcfff31f12fb7aefd1c4b67383454d3ca36832c3a8b23d91bec9184e3127d4816a5c3e130c08712d58b7554d7aebc4ceb17816ea86a174f2604610776bec8030457b4469ca6632be2a493ccc0f02a10952dcf8534531807efda46d1f83d75f54a259fedfe759a3d3f879cff97c85bfbd6607856531d7f35dbcca719db07f6b2f9d77a495e672f7e2425dfcc782af27d55b52dbee79e3e485383d9e2c43a46b942375051adc8a971ca2c75a141734e3b6b66666909f4af6cb32e5dbe95dd3120042bf4533c5d7ddbec162023f3dea5025dfa94214e0ccc76e336b5c0ffa10879e86867c19cb78a4f0ab8e5dfadc7728b11a35a49b597bcd8f0371b0e1ba8405d78747418d6448b8be9dbb2ce2f368a384ce2a3181915dac0d70d97167dfad448b50e41ec8bb376d69e6afb35bec502d37ae639facd6f855760f53a08621405b7c9dda93dd37642b96fdef9892c005bbe31474aba5e81eb1af69e6ec3b166517ec0f77200eac201193c485e7dda91a1d89deecf6b21d84840cc20ad57baf2472189e6027118d600fd88ed8fdc3a09ee84fd299095648e6b59546fc91d00c6852f628f8bb7a3167c7ec5495beb5a3d50a797bcebae930d01b11ba69192191e85b0cfda5a9867dec1427aaec9d6f9aa685744dac024f7a7f0a1d3a2dcc7bc2fae976703b69a555d91f3a4a63e029b6f7f6793a5ae681df7a1015a05b83fbeb28924c81e5288cc77b67defd2708d782c7632e1efd76330eb054107c73482e64d17e74eb9056ad6ed8ef92efa8aacd932d3208618359aa21895053302087923f4b14d9e01f32dec5163bdbdb823cc21c4aeacca23cf36c6954a53273d9395217570f307fbe78ada73380267fddccc560976929410b6b4acf2b316cf143fd53e1703b05c8e7ffc8c9143a60eea6274de25447daa258e245f58f3e100813a78d04b1443c589f6ee92da82a93de7003e5d692cf4fedcae3376aec979f1d13191e607f7c8306b5140cf3dc24294fb220175f5974f463608c8ca9e95db98b83b2d183a8507a2d224847fc15530fd70ea238b374acfd358713349036acf56ffaf7b3a02e64f88d6d8a87612debf498acd6e3a81d16efa7efcf4a52c62d45b9352d0c7187f8c45e0c5c62f6e62a04bce0d4a3e8c230569a144f35cd8a9def5dfcabc4d47f84d25fb2449f302f1b6cd1c251bfc92e5928ff23f4ffe198ca371fe81a1718e0754bc090e7f4f407063b85802255b80c7b09704def89a818e21ad4f30d51b18afa11190c7c9f30e0ba8f41ce2a5ae3d8b025b3cfce685c9654c0842bc708555002315d648ab9639dace69d03f40916f936e76ecf13a5f7401e52fdf54522bfdc7c5010594dbc20106e0461218a5add45a9843e882f9f4cd45917ea1799653a6e68c4f577c5a25c4f8fa0ac37f50ead9a9db94f3dc7c12b99be67d6b2965f71c6ab89cb077dc9344330af9a8134a4247103276bc9d521822f048e5f56f265765e1f51af3ceb7c00de298fc9b2e3ea9a4554bcd02e46a147ed4c933fab8ac41aab9c0830fdaf1ad394eeec3d66162370fb7492171e89e1488b1614f07ac6dfd24f255cd3101a8c9c2a532a972ae7710300e30f9df63c3c33c73ffe6098650546ff4a45dad5cc1499750a0996b7c52bd8a1b36785b7bb279cee9c26b4714dd792d7e176c587808d6b75c598db5c00c812adbe22baa8580e76b2859f2ddd4d31b4bccb656b1b5e58a1e1eddb7325fe5fcc7d8995aa4f588cbc96f9d059f62cb1e66a1633de24a66dd1044a6c5cd9ac4c842082d041a108f770589700282f5a2ddfe190f0c8533057224d46c10059d9e9109a8f1ab18c23a8280dd287b020ec637496e4108e9e1539d3700d24a342ef52bf9acd9a4e062f2298a0f182b17cb2b8c8fa1dfbe5f679904b2ffa89af71653e3a04b05876199457853a4b610c38a7353c5ac68680d492c78d53f1e3ce7b1f7794df3a9ebace9e7867cd101496dd7022c98fa19b9d6ab72dab07559e4f98f4cf528709bda865e9d9150ed02cb13e6ac579a8be5c615bd7a6832f5181f6cc1f7fbc8b8212d289ae64148f61078446b161034929af41f50d787aed5a590ff1b2ed99591b71db50d1a409cb04a22dc45068074ccd01f545b619368983693a89ed881d1c3a9a1dcf4b28a5a1de1e371eeb24f2f45d56d34c659ce07c9a92574de1a01e66c422ce7bb26bc3a878e28d51ec8f62daac18579976780125155c9b1ca9ab0a8c1386efd4c53428526395f961bf386d3f7e810dd30d392c89d4368d5eb77f2cbaea160f95b37657f7018e07ea681badb760863c3f3ea780abaa68d8aec1b1e2fc15359450374a9f08d4cf873b4599d5176bb483e2c0cbbef921228e680aa3b4625f86ece4168f7b02c0a56eb8fce1f8ac1a916f48772cceaeb7f75b939fa2a491f796246cb9d7a06da1f4e978edf5fa6cc6ba59ff93e78937fc23f346362a5b9f42c9a8efe42840613bddffbe4a241d6eda838e4e4f0d2f9a2ba55d8a01b1f453cdda23c463b079b91767d20f1ab1644c10e7b8e1e6b53fd68a686ff16bbe90e226a30087379a09020fefc20993805ea0889429f73447690758d492060501f12409833676e73ef47231be02e3e444734651b9ef1e9c7c088106df5fd229424e065b31782d6c15329cf141d23994056f6d205b0409d5d5c6b1613d6d2f0511d32d43e600ec11b4e3359a8ae43995ed131dac3d2724399ed6f7d1bb9637dae365299226e702b80db3da9c849de79141b70945cb05164f0089f9ce4c63ff7fb4d9a225f46cc802e46fdb5f6f4acc5ede963d8d1b4590162988e0f81508c3e6ad9118f910a444a741d97ddef48916cf554fb10b905720179fee44c3c7d15a2947715bc96ade4a101dfd166c858aafd85728faa8e504c16aceeafc5f1a106f13439d8e189559789bf942113db633280be6ff9019d933b61c7820ea1729bbb805b495f301f78f50ad4675deb3dce16cd25484c08ac6b98b69c9f12eb3a78053f07e0b5b1666122b30b39995408820cf6a1f90955fce4c5845dfc5fcf9f1d6a607db2b9e1457836188eed81b9ac80403be34ac7e6407370a4d23ffc5bfb430d8ca364f7773291cc1d581ecff8dae9b5d3b72df06baeb85c8fd8cff52cafb4f2f8ea1084e609e12d68767822c2d8f11ec75ddcf3e7ae04deeb07a39f590f119cf784dd6e5738bb95e0a46772b6cf315bdbeaeaf807e8d9b175a4bac09c35a132289ccfb7997ea790dd3fff837e2039a98a7b46bdb93f77a64a635deb9f301520b9e5745fa01059998bfb3d4d1b93928e95b3f0cd678bdcf47a566e2889203daaad3dbfa1e18a45a10acfff7ecb8e8f9653c08f58b29b6ed5658a90c305369ecd14ce56c0ef2f0e154685cc23153412cf85a32a37066ba94ceea0e83dc1ee1575751a01b64de738196c9b300921a5711acce84c969d37d8f43f2834870e215a652d7f79b558c2dfe83b59c73077b7f8a19e3308f3561b2b5b006a96c6f09d68ff8f10293d77f8afbda929a623edaab43d82397010c2d34cce569d49f200136c00fc6f09f896211c3ab00327d631f6709438e9e17ab8a8adbdb0adcbcda5dfbf2b38a29a10bd94e5d6dac27112f5132410131aaade98c16d7dedb743d3f010218a87c486cf41eb357421e597bca3d6ab9e01e331dbdcf85fd30c71f1377f3f34a9763c994d7d348a2a77a4c1f0c2c5e2f0ccb1973d69695c5956f515559fe501c9652958c9f0cb096ac6117c67a3d4968e077c7063e2ca78e1e3abbe21e636f04ffb768c1809c22c3797ae9fe0ebd4671540f0e54042bdf05630a0019def67fa089d82c029fa7c2236f1374bd84153cff83b0af9a29b8cd53aefd3fbb96ada2bec3b73106bc6df36089c006d2d1dfa7037855c6dcad7448d678b1139dadb37ec6b0c1e47577aec392dd4f419868b83985f53a0733519d6fc196bb4379bd38df5b8df50c50e3273444d546e2d979c67de92a651e964cc50e1f78d84ff1251708285e990d90f50f92b97d806145482edad6f7f7115af397483a47d4afddc85b00aac2ea7c6cc15413e3e386d2bac09e90ec15f6099168c2b44693d5c089268d83568813f57dcdb53ca9b3b05e2cf579159cbfb079255c9b3908927eeca2354356ba0b761888bc036567be8e92b0f60a2f99d88703568e74903681c6d1c8ed2e193d06ef6477800a8e6c46170d527134eabc7e6b7bf41f441478ada108a630f1486c7eacd5f8684c20b1e999c2c5975acf7378b39a33e6980c8eaed91a8bd288fc20fab5870f32d2bcd6291b524ab4a0188ca288b667c93be594e10d53a426c9752c062ee06c45c59d0a92ec8c4049f1c8a96e5bb3e39bee8fc5577a08aa14bb08a96e9f7355b68a4639723965cf38e410d99d280c61a8f15b87720edd1a9fbfa8abe0cf43946f730bdf8ba13ee76eeedbcbfc654f84bd637996c02dcde830a055e0a5ef7be549f8c9848a9efbeeb6c0687a1d628bc1a3315f036ed8d9045a7ae3c8a2945c405c4e10be59fd5b35052ebc0732d90d3d0a0cdb5dc795bf6d8bcfc6123ff1150a1645ac6147439969015e828f84fdaaaa59f4274a809793bed8e7db0d54e6f95ebb816fdfd2b51f9aab714e38d0a58790eb5f2be4ba89b9aa34401be40730eaf8c2bbabf69a63812627803d2f3f1886e9b371dcccfe160ff9674a084c32a770027cc9b6a26611ca7f413b049d756177bb812420513fa71e8351ed6c24f1987a8b22b13ed872a2c2814a2a65d9d2e94f20fb7db9ac6fda1e21bde48d96cb25d321336eb1abb95790bec408be90bacd7be1bdcec2b8ad76709cd9796effe5083ac5991c3ffa9295dff5abbb989eb2632546f5f1b3ac12b51d2461644ee2559c8a03f3e5b1e9894ef71cdc47630046848a3b922851eda392798af989eae8cdf7cb9d41e5fd81331bc25ee594da01985033f20ffdaad8a8ec63c9b69fd832ae5f97807d62eb78e0f9a725679141733a45c0f0d3b2ed4e510d3390e7ae3784cb4b33aa123ab9a0fd7aaf2e64756fb06a7ca8aeb88c47b48e0cdabba04a830a6b1dbc38ba3f28c4ca08c6b4d8f7aa1e71a34cdad9068c5e3a0e42121b0f554a1386afdc7799198e1f9a2fcba4ec9d834bd8070570779d2438c3826070a8d7e496fdaeea20e15b9bd82414f8dfa63fbd1836ae344ce7d4acd5b70fae7635dd8cfd1c2e666de390da6fb72912513638583ee85b59b1fe9c393756d22ed631fed589139b37943b85561b9daeee7ed0a7ee1a067e346d79c7c6b8f84cf155a3567713b3833384ea924151cf74d3ecb8e48789b074054dd25a2b48c99ff2881db2f262ec352df277fdb82923e9c60ff52287a4491e01c39c721fb50b6da2f6e743ecf0802a1434ae0186edb0ad07dfdca608404b6609f20bbd78276ab068aef23cbabe688769cd9ba56fb996f1f744d3afeea418435e9c6f2c3d5598e07a11f3e4c4aecb726fdde3476b98e55c4347b935695f3a7d6bf05b5b0d61af4a92c61aceadc4c914693c4a7fe6fb89ce3529ee37ef44e5ef791eb1869bbfc2afeb11cd25d0e2bd022662750a4262e937047eeb820563a787dbde5fd3b1b3fd26b2149a611cf904cd1e93047df41690458957103ca2a970aca32719d53677fb2467ea33313568d37487b997be3b08e332cd6948471270645a4f928fa21edc87ae42b2d7a64c7575b5445bc35a1af0bdd5429771a952a225434095aaf4b231673a72baa9c5fd035cfe40e406d01f57c7828987f7417e8de3f7246afeae9659148ce11d92d071e50b7ba68d6173f89d8c1f517189700d3b4892ffa5fa7e9671766ab290b62782e117ef257d4a20a526da6f7811f5c9b661c7bd48194144674835bf22c0e20836e5228fe8b63d5e856c1458fff32f90ba6b90210606862e50fbbf243015a42d27f2525cc6e3ef75939735ee008ed6d9688c225c41d61afc0a0a2be59bf16908d1154fb3b23bc89ed73441246dbe241869b83007a329a7744317ae358b0f4d73c0a3e7c933e7fad139d265aa13a34ea67759b9c66d04f3ffa0ce14abac127171e00d0634762585314f31d7902bd8e6911f9796061cc729433e1f1a4a943ba4e8cd589b9b44a4b98e69d009f8bf83dce52426696d4ba873d4390d11d8957b4f03b8e42f96d090d889b3f1d92530fa07cefb98ec24e47a46ec04533bc689b5c54266b1f4d9a662f4f05ef8f572152a7b9260ea30388cc3e95ae109355ece4fb90b81ffbb9ed440de7e3ac43381dd1a007bb4f7e8f7bdff9142e8e921764a1abc758446a8c04c9a51509470c7a4d2f9115d477c0f79c627ca5351c0166aed2fbd30715de51e1e3f2878e8a8ffb57068544fd76a343affac31ee7ce4008d2e432dd3eb2a2521f5245955e430c8369a90a9fe0198118b81534455b557a5cb3722360a7a62a60d8082b96b5b73b742509a403258e7246b61062cece7c7963aa69e59b23c0d06d77c8b807d0c6b169b6005abda4be7dd40daff23cfdfd83e60f0e896bd43e2a566af19eb4e70ae351c4fd01fb248ec90caa2b097604245efb34190706bbdb3142efb5321d33be7104194563c80d46250d38780ef0a8eed42f9ea6357fb5cefe73c3a3d960e6590b5d0ac45b262a4d5cad0212a785df5a273d0c6d92157fe8d6d1844781f226478debbc2ff1eb660fb9ede05249127b0a5270b4d14711a7253c6a2c4311779f5eac92f002844dcf694c9bfb7b6d52ee06a49fa745a6cc60aabd8e8a60906afd6fc527bed7bcd92e6c62d54b016cf573dc7c12ad43c6c55922d2cf593aeeb58d3122a67640b0919a3bf2c3dd49f24c92dfa9fbd0d626affbddcc5473e89b763962592ff346245bac3ab90ea0a7cb94aedd5d08df86c690d99435e12d9554fed1cde1d6bf05ecf6e4ab5051ab3024a5f29699a429dcbfaf1847eb38cf1969534234535d16e3497e2e35ef87d74bc4166ea38f9f1e8a9a20b42e4c1aca6536215cc2155fb23c430583faa3d5f0677f4c9e2bd5e4f6ed3caf24c70688400a42e03ec3c473322daed295aa89adc4b539b437a2f76311daf0bc37422e7ae9c9ee1a5612558c3e5150b5a5615bed4db234d1ed434ea57c7822846b305881c90496d93fc3759fc47c5dcd9d0e8cee2ca8cf45dc05207a573138a2f1ded74e456b038431b09605fda6d453db7b49dcf77a785361488bdad4f5d1927e5d7a239b1ed3673947baaeda170af976ede054fa81804d6ae5078868c3598145076bc89824771fd7992d1a305b50287b6614e0e42778","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
