<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1183fee04d4c59dcf9e29b9fc143189e179c1b7fbdcd117f83379973517b198dc021e55316154c7ce50dc81f3fd1d1858af9d1de9806bb93a26636225f66fa59b926ee04e7b0342b99b047eec4139fc8fabe6dd1f92bbaea1eab6e4af3bfc5579d3bc6def3d03f0e641f279488a83ad155dc1ed069edadfa989e7e17aca22e0a4f802de6c50b47736afeac1462b12c11fbbe5059c17114aa52e50a1e4c4e0b51f8133fc8c147d420a87e18222b9cbf76996605b1c4459a127422ee558dc2591e46101f247a0a24b067f79edea3e8cf8d50bf73287d1d5feaf00ae51bbba95a02c47e62c51c1b2f49d031241fb2f8bad88db959be0d0fd5c3d18b480eb82788db1e595237d90ec0dd155f0adde7dd3f54a6002b1ef78944f118638aeae72305f6bdecaa37a11e7a51da0e1333d08ee30e4ff023bad08e190392afdec1ffe01ef846471f8701610fe683b0d2dad56932f661a4db7653089299e63f09ab2cce8a2acf848cc4ae239c861b10f8d1a9ecbe70745ccc49f586696acddba9cbc9d230d661881d5ff00d503b790ae111d90eb46325ff80021e5e70d9dd49151b82613809d5e7e5e4d55f7929524b2973db0feb5b149f1d0e1bd4a4cfbfb2aba04d3a563d2e987382bf4ff4010b3e2ac2dbf571d01acce812661cc7cd0288b9a3b4292dc1aa3b04c8e8c8d51eaf59954af1d9759612f130603824a86a4ff697a0b0a8f07e3806be124aa18bc03c6335ce2398b24bea3a34e3e42f69fee6d051bd200bdf34f6c1e63ab8f21e9dd57bfe5b49b8ddcd2adc67d7bcfd5a45a68e49d0c729ac8c582a572768ab26e43e27810dd651f3b9217d105c8e2ee6206e31cab6bff3016caf7cfd3043fcbb580efe37a3446aa90f7d7d60aa578b9ba8a885a385cb9875b94138dbef14b25371f1b7c7847a660e884becb8fe63779f1757d752d589e7ac7b0445a030cbcc68cf60082ed00232dbb8ec4fe307bfa6b60c1b79dbdcaa24299c391e598da3b236271a50a86a1f8f833d70c895cdcdb43a7bbe25bdd4232d6eef496f8421d94bf713d62b45ed72c73e9a364dc43e51631d25f2319baba1f7bde6ade78e851f84c217a3aad431952c1ddbe820f45778939b8f8996b5b64c52d429e0cc4b6af1c4d693e9ee28c3e853a2bca0ed9a9d7b001806573489cc346ecf39b37c9ca3b73f30a59dc750fa690e76f5a9bcb6b95f2e3ad4fc97317bc4d1e23b656d158af96c5c3ecd3d9a32667f362b4f4a77d3817e0bfcff16bf2731a90858f61d848f0b456e0980c45fd00c66586a0e3e2c39b9c0d09fff01de308a8deaaf5ebe12e71deedc1910adc10852da2a185650a8946bfd42ff713726dbfff25f51139297a168e9304bff44e1ffc6018482d480b1d7a4dd0174f2ad427fa58a11220b44a1ca74c921589ec82d78968c9c6d62ee5d8c4563fbcae5f32713a23462e824d0f175d97642c85eaf77b36c595a6591532729b8eb8725aacb369bbf9208f7470894f23720bfd4924ae6afbdea839d990128a71c81529e35c8c2ad989e55cd4b85ad27a51727cd962893e5c104cea42d3c5d6d965d7d406b33ce237defe0c8743abc63651979ee121c06b0f3224bbcb002d8777b4aa1d0209f1e762be28ae7ae524d9753c0172db147450d5f205c41bedd339b0d878388ddfbe7788df19ac571bd85bb2ead0d26322e99223b3ef4184582a428310ad2f42921d213c6ce86df6ecdae242d1bf2d88fcb7eb35d746c72eb5005302009e9bed987cd5c742db8dccbdeec71d9a0bf7882363826f5b4cb5d9bd092700ec184f5e8656ba71a84584a478601c5b756eefdd097df38ab1ae07453be32d400ebe148f1be64d6c63d1a0f6ca79513d294f62f5d34b3c1b3459c7e466404d2f6c994be6d7fc08115f9c8902080bebb4d81408fd4b27b204421cf52f6def7422e006b019f4afed744333f216bd0a8de110af949e628a782d8ae815a66ef6a683a831dfca3b6d939c0d739819f18970497a3ff68ad7dab18702d556f8d22ee25fc8c30c22e639554121f4688738cea6b665996cbcce456813da23560ac3d05cc859f1392187e5a786ddaeee110ed89aa70e1943dae2f974c3a68f16ddb595eb1bb8c02ae82d132a2aa7f36788e95b3180e764059cae3130f8f06bc50be043434247bb09b8db2c832e283ce018979fe48d59f73c1fcbf7522d47eb1c7f5a22d1838f01ac5c40809a429b3c53f2ceb8286327a7a070296211d3c8ec18e9719524f62acc40e7d25643069dd37fdb80e4275e2cb5fe0050ac9fe024c89b2c5f47b56da6b55dfc340ef7da79c249d1c1a09be1546ee5bb41e685f87ff437288b532d913111036c5acf09fb23a378a18aadd65fd35da9b6ed808f3f2cd8420a8c69cbcba9d37b5df20e4f190a8d0a39c3d7175d0676af1793deaca899d3aba679901060eb822a4f908791a7435f684b48ad7eb024f058cbf64eb1158cbc137fcb3d08ab04c03970a7b7890a538bc5827317d2712718ed93dc11f563d01d09588e40d0fb89ad22d85f5ed5d94517cc6cdb053055546d339d3681413abeeb3d82f6b5368d45fccb9785a78f3403b92bc12a7e497b408164e326cb647134584515aa4018b0633bdcc8e79dd07203d3fa7098b4b64417a9d921d97ef16a6f528873198ac53761b08bd4715230b6f23d5fabe23432c8113cf8aecfd12e0403dae39a7880d25bcb961a9bf8485633cdc83edb7e14b5dafab650a9ceec22fd2851d3a63b8899d07c685eab296e5f98fd3d3e30c30062853c784d7192dfae3e5b85f23f959707ccfdb2d86c1f8f0db85521784339e0c90b121df23cc11aa13c22a82edfa6b85f48b3f9866703eac28c8f36eedd0dbf16df5c8076843d2d9bc93220d96c4d67e0713aa1001f65263891fe6afcf90d76feeaf85416b69c3a565c125b9761d49fde158aeb41e0286c529b21462f28b46984a8d59442ea3aad5667b191dc9d751018ec925f8f57a54143cd54346d298ade3d69862abb03c1053eeeaa8e77489df9f9f499aa4a330bbc47218bf3807f5e458a9d62d5c11b034bb25c6306c2899878ebd275421905333e1088a742f5b63e343eb347bb6b6d536a3a799e269593264e84b770d0c6286eb7f0a90a68f845807ab1d94359495dd3be97cb39d67af2dbf25cb61f3059976f1eb9128ab2f7fb925dbc2fb16738da3cec786b25d3695d372239e775a1002f0988c38736246ef42e9932cea3078aeeea446baf86d6e1538c5b6a1f26b5f6878a94cf50a14e1e484eea5375952181753ff5fd78f761938919f1a5be8d0daca2badcc98a6a9179ae72cf56adcc2a239c4dd4f47033035de7de41d04480e26e86d7e34738179492e5277670d65d5cfe67217460032fa56b6fac4d18ff175365facefd709cafafdd458a4dc78e8d3472cc8104baa49977226061008a226df02970ebbbbc9ad768ca6f849636577acc4cae1f28910be6b4b1706b13662d9c3f618abaabb445c2724498bf3190c4eb02c771cfa458e40c2972327c6d79b522bee21414ee943cbb374f902c0c3633c07c41c15816cab9edc21185e5170741e76fef92489aa51824e08a322ef7998d02a79b53c240ca4e41253952f0cb7adda4c76c773b074a0135b4001baa921dacb0a800eddf1986afcab670493e3e6c84f24f6bea8d52feccd3ace1cfcdba83925a4cf6e81209a31e2652667d7fc07c4041966320acba069c3e8305ca6f4768771bb06a5214fd7d7f132e3e10be2df5f3c7454bb9b1897dd8e825036b524df8f49a15f90dd3833046c3d68e11b48e4f4cc73ef902a48b3c338bba974a57bd2e3c39777952c3fa10543b86e4ca10855c4a2a5078176e5ec84dfd7c276453ac4508f75648677045b88a973978dc1013a8913f494550ab396e0d81f979ba54d5f746fde445df5cad8f4be4c77bdfe87d17701062f4efc1981edaa2a1de58a0cc28c6d9456174a71b04e58e1990b9dc22c5a10f367d99b214fb9d22a33dd8930a2ec35d08f58521d110f0845f99930d8ea2b681ce98ee54edba6c1f262301a293849ccb0aa8439186109a68afa8d7a8af3066bc3cd296f81d8acddeccc82b681b27a2b093f287cee97f031ace37bb6285ddc84bd112e534d9f056e09f1abd301e2b15a1adcb1df4c0ba6f636aa98aa2bb1ed749310e63a68fe2270f4887edfab38f602343573f575cd8805400db7c81ecc10b23011739adcdfbefd9bc43bdc44bacb29b4b966b193fb5dcc1f84a455ed8f35e7ea1aef6b4e92b2cb4e63f3b7607257beb9d92b227ba1c0fcc42443187bfb0284eff1eed2b73b1740645357e3bd8f8735fca1a2ef8f7864e325d0bb8dca98c52725f43abf902e50c34c9360a33ad8acf1df8d9c5d7608070fa7e0e654c80d0ea06c9829e8ff4803e45f0a7a7aea7deae82756a994271472ab1daf1e826ca4c9fab41536c902d42141d49f18e5e4631c50f97b6776518e3f9e633227999fb26e3ee46a99a6cd5aa748ed885612ad9f6c076fa3f314d53d2a8db720077b683ce108f7ebbd3a56018aa9106b81e18037178bc48d6ab4eee5ae30c8fcb455b9f37d5c7d7fdf972e3ff4a6691256d001b052342b5a57611b85507d32a0bf9c9dea9bad64b4ec5422affb82fe1955733b6eba27679df5c2f105b30430c5af225618d7416d3c3badaf69070ce3f05d2a1a6abc5408f123029b68544df466f3674298700e62907abd4707e212f1f16f230dbac374528483c91ef269a0bf2c050689c58b5b49dcd452a79fdb26d7035a5fb24c3850f9c74edda8d2031d6e475e027019bc2c4b320817abd0b074abc7147ae0e4f7c4cc8f6242385280ac24d2b7b929138a88fef64a528aa13a3fe6a837d1880094f93a19456e5fb02240cc7b138f910b4b12661793f0b5619d34af8846b4c8f961bdd0cbb5d9f67e9f11b82980d8700736cbf63e790b63e9b96339398783fa351ec569256acc8369f56c96c91754e39c70a960fbe9c9e3c7361695e2e3643d82f29b873c4e5e4b86566951b0d576c620f9250a3f5bbf6be0310e4188909fb268a9254f81c71314daf8375941efeda61be5f55f28facfbf0bb8cc1b73fe0b276d01cf44faf906c60e33b7b2fbd2a0f6ef34b74e8532afa26e7cf296a15e8d98ae0240e500a245b8c33919c5466833afc3bfbb7b815958993f2dda8d410fa561a9642c074c957f18aa0bc412c9c6d827917c8474b654c172f8b7af74c90217c197f7aba21f76a05b658f544c8aefd4ca47ebbc460f0dae217db0e59113c034e1be7b4d88d6d823b685cbb7a12670196ad39e04a8e600dd8aee3f3b4087254fdbff7d267e67ab47bc34251e605a480af0ab6a2f71f7d51f97cf72263283c4168229b3e844d9a09b745f7df65def553b2338f3ff9618189f5e9ae9548d2c0b50292fdfa08a9fb09f72fd9b4fe0e82b578afb35b76af17dfc56fb6003ddba41449e1bf607696b39146c57ddf683f074aca6476f6895ab664d752f8e9f9160002ea19ca6674fbe64bb6619a36be7c37fc3a876864ef9dda28bd6d4a61d7ce102678c92d927836df10ab0ee2ba4bf1a7e1272b071db326aee0c1d690c8357be9cccc51b42acfcf6a244ac6836879568c329a35719ce13094f23143787c30faa24aac5fbec4174f99a8a3371d61a9a3ae0d0ad0a26c2f92e55754829498322a0ca590e292b76228bedd61bbfb22efbf4eade00deff12a3b956a32c1c45408d17bb2b4787d097b00fb263eb51e0e4e464cfe0e915db25d8acd4fbb090d3ffeee73ac30e5e03c3a2d5b00d6dc7e517875c3caea8fd001d21d159cadeb87c277d5d1bb688314a799e89bf9fef202b74cb47bc5bd8eac4028d295657a93a00e14adc0021e4222f326f2f27a3d91a6f83b127a04b455702108983971215377d4a6a7554c28595da585c1e25f38ee6bfa0d50f11f5b4272ba23950324a1fd5081a221c6b79d485ca3c43e9fc20f2345786d93477f53ff43a0a54a1cb9e27a3149aeee7043bbcbefcd9bf3811fe7b4f1b34693660b9c7bb19bc338cfedbfce865e0dd3160a9adb59795c2bf8a894c515a67d28f4c294128c19278c1f66f6a2b73309863f5a5f8267e589f1f0f742ceb15ce0cb308747a0c1373a8bd62305108097e9ea15ec57db7406b07f3a9f48f58a99ca8ccfc6121eb361a45880688f3e41fd9692cde6c2ec19a937ea64c5a46bd5ac30f68cf3a3a6ea7901562aed4600f7ebcf2d1a5fe0d22ab5918c5b1e867539116ad04f8c539a500f7ddebd8900b8d459ea263fc0dc5056cd98aa2ae965405dfe9f8b7a7cfbe37b4912fedd3a891acf05dcfd7f8ddb5b3ac827a02bf675cc6d147cab1cdd6304d33b7fad0d3b457a60a581eadef6ce019e99145467f2fa52fb97348b4cf19cbf0b1cd18225e601024863739553a57d85baef63075e8e7ad5211b42d5f12150fe00aaf44b1ce01263d68ce7891a4b688aea757f50d796352649e006b5fecce9a87d4d4c0a6b4f5b9c1b23224ab04d2e1e0c94476aa04ad231286888186efd54f8338faa5c45b287b5610e3ca335d40def2fe72f6457f4e7db964fb5a3914b4bf2302b2b74f4cf25731649b36871c9090a76a9fef2a9255fe778a98a0cb0da1eeac52487c2ec3398f51c9225580e50f74a98407d64bd9ae9159dc903a6b567e5fede71bee0adc814049819816c5e1701bc436a15eaae94738736be8b13155ea20d0c6de5c4f9ac2cd09c6ee57257d67d821952a1432eed1b0c752eaede2874730516aaba91fcb4dd354920f7579b376f196747f425df7d6c6504773d5c157f17bdfda1dabfee51127fdfaba5812984f1ff00e9ca6b814b5dce13369f03d04736b50ee741965045f1a47ba0ecfea122ff2107f4a76b0fcdad7758cf3cd5ded0aed135ee45b0cabe06e98b27d32f0d9c3d3a8b627d7b6d7d5009c494aec05e47625638d1b5b3d27c389452d24752f2edd0821545e3eb0d17974ce757950839c05477224bf8640f83cc929889fccccb277a291ea3957fbe03894bcbdee2a16477818df149b04ab4ab9a6b9b9d69b32f35f9a66dceeb011b039957b46e3935e05701c5b0e1d43ed2737c8400f2135f4dac8c1702ebfd5e429307e355e1ff42bc7b21cfb68c05950cf34af983dc093775797e412270f7ad5512dcb7f93a65f88ddc7041e83eaeedee8de79c0b937e3e1eb62425e235d46cc6fec3b005e23b4a517d23aeaac56d050d0bc6f727e3e3e1daad92d1aa5818e4e8a4ba750878eb025fc9071246e21f969bf4e9ea82fd9657064557c80373f8457756c9caec7a44e8c0209c45edd19fb5cd9ef04afe532f1821208639edd0594b0c2d8586580469b58ca8b871f1ba73b9b6fe9e8544f964ef90a47880eaa37802575875fc6a2e282158886641e934c57541f4903cf667438d2f220119dd1de4620e307ff7487d1038b1b277acd602aca63d9d83ff8e9fc0de4094a8894dd1e8fdc503762d2806b8ee9e087232e11c121d1991e6953068355b14d1e369526149a45fcfe635ffbec2e07cb06361be594b1d0c05d91f666962c2261dbec4ca481ffd928404e7f44f0cba029a838a3a1d879d6889d1aee0a866f39405f54068fe1e9adb2a9481db9cb4a840f63b4725779236614f6e7bd5161dbb5505a542faf0f850cef1d61f819b0a1e7ebb79889229706f63e1d07f4b5964a16ea25b258ba0b2d75f570b01a30dc6d3f7b2fbbc655c5e77b35e1d89b622138b79086a40693e4c135748782caad9ec3d6bb6b7949952a173ab4ac6216f1969af60692fdf27f4e0e78990277417f6ef89e954dff3478ed35828d46b2da336f7bd0f3b190bfd286d684b4eab66bc7bbd845add584e2e20df8ac11329c36749a5d1d935d68e33fcdd1b190211d6302b50a8932652f320391bfca3ef3ab52433a172bab0f9fc22bd0c659f249bf257a0468facb1922525cab5557f5b3d9791e71c10136dfd032b533dae3eecfd306521a886967cf1c8e182aa64cee62640e70c7436b3cebfade5f4e85958f795e9580192730f07b26935df8dee1f1147e22b4d3057a91b7e3977f712361599e5048c437266aac28d62c9422aebc8d221407b6b66192eb9884936b37aeaf2879c19f263e36c944efd6461fca1c7e53c460dc7f25e3127725b309ed6b519c7f845dbef652a9d62c172e5866ee01b675e969c4f4947f756c103a1bd3102ac27f2fe49f0f2ea6691dea940d7a74b43c03b44dea0b884946db8e66753aecb71f56a12833d65c9224053b2daf448727052d77954dd93a0af627954d289cd5b4c0713e8658b4f51f666cd703743fe0490210b6199739c272f2e40733a185ca7f55ea290404e044cf92aea6d58f4210f15f894972e0017717a025415e4a6ef90bfadca312db866382154435eb8bb6fe651cfded0d84b7a85dff3af3509a93d571d5d550dfaa4d8e05c368abe37c3c35109636522f1818364e5822be857fd609a9b006f47f3678fcdf8edfe89b0f38b6582b5ef720695c64f63ce2631e40dd62f7d16d91c3bb091555a84f27294b52addc74d822dcb594dfeab46707ed21c7b0333f6e2cc58f2ff10590c244f800e08f1ecaaaa6544feedb6a59c00c8547c8c01340dd47375e7eadc56f835da75c21527745ea0e7d0e4b49c82b5f02ecda299407ada33f44fc8f5c5b37a91794c45de03ef49de89e22fcc8be29f9254f661635d7057006fe36e14affb2575c6767ee59bd4a99b33012db395748ad1414e4d77f0e910f669a458f11f54329432de28b33a28294ca540c0586455d3ddccec8c1f663bbe03605bbdfdf54b78f283222f551420587e31fe522d875293e789ad97899d825a731880e15ce2c942068e6c201982d3e4659aa7b340eb225abffb4b0358986aea4efa2a2de8c378422bdab875bb7c511e7315cdb60d415aeb7be7d7ff8271956179b9330db49ef4d5f227aec65c9f29aadfe2f496256c6a3a0a02ab919042db7c43ed36b0ceff96e88cfeae7b40c5ba5cf1016672a44445b742a947d6f1378ee07d0c6fa7426f386171f3f9111ded09348342387ea2685d03806d146195fd0eb2bbd6c0481871918d738a25120a81daf7cb63d5e28b38d1bac44f173c6680e1d184f4c206f9796a59257f8f72d24968763b8ce7f2f8e82317eb6fa39a3dcac9e153506cfbb959619a21a302ae7f0dcc3a453212435db45ecb1a4c5ae60620f962edaf23c4b3847f049e785eedd20f965e8d9508eb5a98c85ad309e9cf40c3165e5d279b38328f448961d147854446ec03b33e3f8705f113da1d50281ce4c6f917669ecf9b11930df9bb5c8db3a6b463bfffe2a5364adbd0c577abe695cce914c865c29d4c90fa834e55a4ca5f9d1f0c8289218e8379e12ca7bb2450237089cf4fae818cbe76a7461233094eb449ef7d38899cb6c1b1445bfb1835dee6c0840adf552372cd0dc16b0813dc7251965a5a554ae40a8aad9d7ceaac07230d952402075e45a31aad759c41721aa2e239eafb985a91595aedbdea691b06743e16077a5a4f520ab7a59ef4269129db2b0046f74f627588f792138738d05bd6786272cc41017f35802a4ca334b9dc1156f2cdf44b83f6a1e8e1d019b1faf84193951a2ebe2faa6b66f7c238b2d0c2e87388bf8fecb3531d392beb5684077d28ac051285e599ae40ae74f5b87f80bf4ed38535ffe16ee7a441102c1e1c48b9e626dde98dd7975bd3f39e84dadca2519465943038002a88e428e12a03f53c93348ae7fd2614653f74b33044281f43b80166f46ccde48fc95342878adafecd96b397a74c0fa6bf63645f5c0e6942d31bbfbfb4c8a4999ac0226d6b0a0ebf38e526cf38f6b757dfb68e117393adfec52c112f763e7c8724b973e3939fe59e8b9e5dcac7feb9396efa624ff1583067f04b23e2ae88220ba19ff2fe9caeb66326e3abf96eb39ce3e53f87986be09b9c8b29839b7c3881ebdb5838a701b545938fc986d7c93b4dc6e7f836fce6a7eaf412d73e466a8e0cbdaf89f4f47b64f5ea47568527d12e3e012e1c0d3df44caa5d89337248bfb74089917b92bf1b6d7192c7578a50833ef5e8f286a5c70fa553ac8ea34c7668e41612a5d774d8013d7e0fdd5a24e089082370e221daca691986fb2e22a26d8aec961826e8720396510c93ef89d0dcf6fb05de4300f1fe827dc8d1391257d1759b3666827f0db022dfb97a6565f7b6a6ff3ef8a9446ab181d1d3ce17669d5f5960f20019d7ee3bf6efcd465020b2889ef8db38039e66a4bab303834f58aae3d69472aa2c08798f7dacd602488a89e33b32f346f94db4deb0aaeb8227c4c2fb68aa0dd0e7b2490adbab724b2ddde0eaeb543c9d1e18dcd0f7ef91e4a4b7c34bd63edba74fa2a8cde4e2482d4e7ec0d4c6cc447f39b906e511556ac8daf9a8b3734bff26d504247169fe861482b369000b221dfb7186cd4c5d2c906b22a70fd00aa0f67c6f0fc2258d7727c4eb5a273275b94e12e23d7db7a1fa783816e2a209290e12c940d1d0326e53acd7fb3dd460fd3b2b0fe57e2cc60d4d4bb415c8e3466f4a3f91d3cf2396729b2d359ae3279b7372e07cf07dd975e46ba200f762b4251ea4e3c988cc71897e8c78d2a6f0b8919eec091a979713ea48b3395b307b6af661a8a9a0d0eea7509159416f28bdace1aa4ad3906c82c56e3de42a6d838aaf4b2abbbd9beeec7cc2e268fa3ce3de8fa330a1d30103e352f382da20b47d1c8a30d57fa7e1e5dfe588df4f203ca887e065c1ecda806e5baade4075b796fa8235fb093cabb7ed18168fbddcc8251cea4b2aac223df406570cea8134147ac608e805b80ed0392eee67108666f5a8cfebee96b7be16097eb2b6b3ff863d5cdab64ae56fc7385e12b5ed5aa42c9635ab21d361c13e802066cb7c98c15fa7a6145d19ec8683cd2ad638a33751186897037f18683bfa587605f274cf5d6a13f736d550d18d419c000f39286382dd2c976f6f2c131e6ca88e8871069c94f2e31f1476a4c1a913dc0466a7e3bd9b6c83b53a29e7a7cf383f0f45807bd74fe41082daff4ed069e890282b59323b60eed46777797eef15e15eab2150199be5f8a7fffe70da8beb8804a12303c9a26a0d657841d927222c83dc66d383df82a23f1bc1b72a6282ffb1bdb133ec2ba2feb36241d601981464f6e14e4d13e4ced773a9bf611a3d422727ed5ec68681bf5ce2626f52ecd460b0fea38516937f916ef9b62bfd1e8e680342ddf8f5d205cb60e8f5dca31f63e34786dc488622cd53901b8c23ed76bed6905de83b13b210b250ab927a158ad31a19dd0ffe5d46862d985873a5a3ac768d25567506b746675a9b7816629cfcdbd4444f4a20b1a7a36dba273f6de754ec964ebb2004e823f75c4e8589e33c253011ddc399b10b4af54ae0a063f5207e78b4c65fda50d87833da753b3b9259b6970d102ff22e6d3581ff991635a74363a56de3fc5adb0c5320d13969fbbbb211285f9dd89267a52bf0f4d73bb8f5ec4cfd030cadbb09eb0ede4e9955c1d672368c8046074964a0e4e1cb04dac1842c8e64fdb20794eb61e0a30212ca9aec610ea267ba1c1e3c06ee39a907ef8cc0e7c7e22d485175e8c1516b631c45811e531bd6ec32c5610fc06cca861d4e77943e5070ce28a275dd872682876f737abd492244365bbfc3e6643f473edc856ef05f32825ab4c150c2928bd6baa1aaf50b8790b361e600f51e0289f286c8d44e630ee592c863728d552a5c510d6cec019445436f2463253a000d712f664d11456076841658661f99a4dce51a683f8b02151d9d13fe73bc1d2758d902d65bc1b1f50906f52e41e323b95226b08fba81311fc07815a81130886369e50895a213240b32c111b37afb1bd74fe79c651a4eeb74c55149a8b31c196647e8c6c87216be860f3a0e3521d4c6000351998f282e74d0bef15e6a439fd1c323b2b106c40ebdba7cf58e49baafc62e0636580a221f38f74a2afa9a05b9cf06ae027f7322d8e4d49af33f6e7603b2500f29f6fcaf4cf2ed2b9342b4f4473cab89cf641136ede6fe204b194454080af5c8898d5f101b75dae2b3982c580c4dcd16e39bf1662bc5747e07bc820c2633f7bb5dcabe0dad78c95d25565a9bdaef280506fadb37d18bb899c416d756890eb3c94941c84c9fcdaec20993b3ced98085060e6d3b4abded3259e6e08ddae3ef7caa6d26364dbd3ea68683a39ea3cb1e97bff42ddcf4276cf6440592ac0fed238541ba263456932d9f23f2dd94499de37db473338447664c3595724fd414e85fc4442d1aa4426ea3a1ddf7f9984b783afec8c618736b6cc74937e42e0bf5ba78fa31607e5e0369cc54d5e7c3b45e82c0c3d7194ff282cd76fd87c68220f33698ab31cc193b80b32f76c8b5e081c08db92f273f927458b3ce4bb9df068ac8f9e962509fcc95abf3d2623b807549f27810a85233dd08863fead6288a987bfc5059486e50610cb0289fe81437dae157f896d4d31a1182cf517e05648a31b3fe162e67f0a78c270ed078989ac8f0daabc31a3d78d0479ecb30353cb85018a6ad86d58a86cd28f8ec763a272e3c24c4c2370e63872bce64504a64c6da68baa3a3edfe5b0161b0205309a87e5881a58ba89ebda50578c494915dbe8b79114fbce877997949fbcc26b2724f6a96a442d1723031d279623842753a2c1c05073a67e4f3a55a77074c2ae14f3dc4eeeac14109f63edae7dc5fc6c9f1a38953c5886513e1bd5edcb297b2bdde228c5b82791a5822556e544555a2427a7891bf91d39d036587a2528045cc4f7c35da68a4160c11cee1fca3408c76669bdceb6cdda3edf3c282dc5b0662433663295fa60e58e9533e63f911817d9ab1a46e27c3f15bc3d9fba0456760ab2a7a573c0cadf6247594152a2bad5db7fbaee34caf50324ed98813f90d58b7da8d558d7eefde595b7f4b99c760fbb37957df2d05c4abb43d454997ba587b3385f992862459bd10c80555e48010f50695f50359fe2ed091a709ee29f2052b009fdac48c888cf31cb34e5352fb99eb2861e4343c046548b679f67f6c87d1e43bef47ee6f457b7a7fef347efd6bab6cb675b8d5846210cf8f5f6f47c53bc8340553f785211d05ee4b04f645264186477e2f5ba96a85f983122ba9d3678e97a05ec39aebc25d8445d660d4b5c4c22b83ba5f903ebdee892437e80bc38dd34861c48d24b2f27b28e07f5833e4b1d7b610f7b00eea22e36173b17730201e714f92a24752ac7332f66bd5ef541f5989fb7d22328381a92931d11ef467eaefcd7049bf8d8198afdb2fec0e732e4ec458360d3ecb0623270ac222a9c94cd62133537851636a5854f732377e24d7f3c89b54a27f95ae79c63dc11e23d1f4564877ce5153beb08fcf318990132b60c2ec111bbcc7b5244059e550bade57f8ece0830a14c308e235d35c8090c34c5e96f679399ccd53f8ffe08e2b60efde51c21a56a76a86f55124999e3a6b8a1ad25574740d6d778b59d8fcb9c29c686a111bc1b25bad5ae2a689e34ddbf96008554250ac0a91a5fc7603a2333d8cec5411233519f249065c2e07c29768f2798bd4510453d6363ead39b791641c01dc189228048cebc1945883dacdba0fe3231f881948daa9d6eba68956187bfa3355fc03e452df56b03f79f17bf928018256be88df88e24488f26308a40c9fd8beefdeb0ff79e24b78dd7ad6518a76508229953994ac742900cb4e6ba05e375b024702ce5c00b83f1b0e2708b2784f20a3c59c91b44d93a7d08bfe27b066f37e6e3631cfe0b87330aaef335c4736c9558a38408204131adb38beb0a2b8c171a169c61a81ea390d3e7df6aae0d867c832f14ca585542849e6181b4ea246d5c2fdece165d0508fed2c9493baf36527d3dbb222e63568e5b648c06a8e651b76f6e2710d00238467f1a401989ed9560f13ee47c48c9e65e345a5f8ee21be42896a521a30902ed3721cc72fc82d72fcd077f913699887185e445fc6c57d59d56814cca5907b802f92fac179afc8b2698be430b542004f4d331c31634bb7db608efc03656d9b864b5a9937368773c014c3226caa13dba4005a1939c01d0b790d42ee46290d4c96e4e317da3e20f84ff61b486642c09840b265737f571cce9c5c2eacffe2c040a787d148664fa1b324baaa107aa475d3a324b4927d722ebe33d56c0772966abbeb09a420b3aabdc38774ed2fc43946c48a03cce838f71c18d84496d10f7e6a8fe58498f8064ba02a2fc7f2b089494d419b06c000f75c7851760cc22dd594431538d8bafd8e66a4a97a445148a6fda698428346448c8a9ad1549df5c92ee84da2e7c47cf2cd30130238a03c6829a8cef547241d77c17db4dd19109d42cb53a1b25d88c019e966b1dacb2a4ec3aaec0b69d2376b4e078ccb9467d9f588c47a3b6b4e5bb39f7441c065f8f981ecfa0526fd016fffdc799ed078c8e646a31f5a7873b1cd2d2fa477afa49b3009a8501e6cde016b198be0c665d64a6d63c598b7ec3e8c9e889d3a2504184f1bb247b01a983a500075f2e57cc5204e7c22725367771f01cf07df9e89db3dc87f807f02e8108056585794735673c5071fc7d21a45b739aa51a2949bd0aaf03600a09eb357b33940111d5d331780e2cb4d80c3d0fc55d0e49094e0061a812c3f8b2ef2532df5e83e75527c3e39a8d34d3a275ba3e6c07ae4580e935e0aa25bd2b33fe3e5e8a6d6b3c9581ce006bc84a0003ca864bd8a13f83d59e8eccf59198e5fea954f5f36e03e680f94df2565d5265c62364577a09a2bb7333ea8b875191cf00e9d66637212e64572b03793bb8e25b2dd62904f91fc3095519ccfcdce254eff743828728918c9e0120db4840370a1006b4aab8b6bb7a612e26013f2cb8bea21267dba08031bdd79efd3de55228a90e41156c968e79ced767d0650604166ef7719935868ce02ff95cf1587fa9b89a94b233c07f31f89477299f3e78ed653c94cc905ced87600c3f857e5d23efe3600bb8b417e434b2ed4a5dbb51e07941aede887fc4777b12f984d9168074ffc886d57814f8020737f09dcb970f60068cb694fe45430abec0930fe50adee7a52524dc1d3468ceeb9a23a148954f5afaab33214e7207771c0f599c62ce266f3489aa667012e97b02ff68e983fcc36744cf8dff26a619345588fff99010faf21f7f0f22f7f4ae965ca3aab17001ae9fa37e1bc899bae3088379d132b684795aec1f9fb9a5ee1206244326bee557abfb61bdad3acfdad8b0f35282a722a6003eddc6c002b59743ae1dd4c9767791c87151e4391359e2375e2aca883cf23d7e69732eb0092b9b03277d875b0acab79c69f03a87ed3f0d5b739572d3588c638f683da3e804b7006ca809fd0d7a0e9fb66ec463429705d8228f19240580ddecac4e1540a8c0dd9e7875cf3c02c890c5ad10e74e28395a6ecd4e0c51716830dd4e819959cb33b3fd117670de8a056bf051225d9d493d575990a8517545fb5d27da5362a035377329e7f3dcc316357ab467b9d91b828e6bae1b38c4e29c2d69838affbf82eecdb75ebf92a42608183aebef55e42436b02e28893c36300d5104db49708967763b5b11a6d5b25a95bf29ccf383f510ccd726d328d346368a1cd8f4da542d67afb080dc9283a30e56ddd0b4fdf0d4c638fd19c7bf688469abfb4fdd42d7c236ad814f95ed765b3044a700e87bdbc467dfc1cc8d210fca812a96565efdcf37f64720565909f5e190f8bb24a0aa49d0df1fe5f3cf94a1a05ef83e634f0ca85c24f5ade94fd3cbae4f9558c5fbaeb9dbd4fda79f35d7f3d1bc2df5091e6be4f09f9536a437f2c13fabaa88a09bce6a58488c8ab92fad03d4d4ebcdfa5fe20e3d8a6c58e1ebebfc1a811444fca90b919b5fb404d368b7720580a3336aab009f7f9be848208f422b84736f21b89a442bdd269e5fc4163837092d5056fa0857cc62b9b2a9706a986849e0b1f9bb71f5d108ce771aacd4e6914bd0be0ca60e0172a1d7eef0737bae9cccf501d5924a676b204f323d10d516f3c3188428b8adb2bde87fdb930d3e50f20fb2e890833a73ad8c4eb77e1dfc80acc0833389544f3875234c5a17af6c81fe08e3c06abffd04a1d5f55ce885588e2f6486077e7b29837c9f16c8993146a6a3fa11e54c7d90dbe7ca8c778ed0537b8a1ded5f3cbf4d9ae0f283ab08dccebfaa58190f31ddbd6ad092e7b7a289f1d6ab37893d42567b25ec49e1bdad82030aa0bf4295f33971c3b23c2fca8437bf63cd47294d912c510bccadd53768699df1b9a07ceca0e58d006413ebd0dd82c1896b9e8b892861bb81d169aee9a87b0be81b4dfbf3bc258b81f5a482b62a12e2fb20dcf823738e865d190c419696623f64b4881849b2f3050d7b29114a39afa0bc9fc1ab286a691529f83fdc8fd4eb9663d40e7c311cb7971e66863c2c1fd91874fa30461c1055ddb9b2a2d390b6e48251c0816223c6db5e88d3c33d2e3faf1ef6f6fc611450cfe280862b8de4556544f5ef32b084e6f452000922207f17350b99d773f0da05cdcbce2907400b193e0f3bff03328e107d2ce74b963a0cc22e8cde357f34e23e6cb88a21542ec04c9a18a5c1e7309f31af2f0c820dc0045fb71138ef368d1a59c7219124032083667bbd00b2977d2ba8ee76da0c25ace96943dd34efb181e76d380285cf997378984ac356ee69ba9753b0a3651296db4d9de811e0077f8fece710b2a1606b64d4ea151ca5ab5bef214ab3f29f7a34a587dcacd0d6754591ecd731e69ff97fe09bfa9559dc4e716a1716a3576e40e4b5b13d36e2567425e3caa9aab9425f5cb998a4a8708dc9eea2f23117687f6293c95cdf84602595c77f0d4cdb6ba6fef4a1c5e4f6726fbea2f590cef0a5f0036a7ab34aea61d64320b1b1a838b864f5b0e4bc43dea55ee167590e13b9696d26c61af56c3357ccc05c985cc90522a8fc97bbec1004ea8547e1cb165094ab20e7482296a4e5397bb68346333c3f8c791f334937d1b2a74c01d8ce67a752638df75f64e78d1610f32853dc4843b0179a4dc101de06b0b5c815d889506be0c61957f45490ae6fbf4b583883ac7fd616b31eadc3da38694a807cc5696405a860cb382d7e68a47ec15b38b8a77877945d82b09bd8b7cdc41b8919c9701e06d6e8652e2596a9276b94099d9dfc2a42e19569c507e97bc19526e81882a2cfadba8e5cf7f0f126dd3d71d34a425d3631dc2edb383c7fee3ea5bfa0ecb309fae5c123f94757e65b6d4b3e450770888fd0c52ebb4e0385487877cebc7dbf3497f8aab4a810a8c425fa02e539df0343461ca1fb21505a3d90c599f0b7455f4be42d856179d5f3aba5e691c921c81b5a9e2430f8ea742334083f25214f6ffcdf5ad1bb2e415a8d5e04fa9c6ebfb80ff957372ae30400b0d781885dd3f25d3d34451cea2627084bae035924d9fe7a83530792416a09bc8cefbb377f9ad6967679e73efe1624adc9d028a0737f1257794313a5bf08168ae8a7fde1aafc09cbde7f88fcf3bd1f8411e75725acb29bf6a0f657ea91d9b042e237314fb919cee3c16de4300696bd5c36d7b9c95af44eca9a3960b2f03c596139143a5b60cdc7293cbfe6379669ff8175b51696d56b9193aca194690810a56be563ccddf3fa0ad39cba827c0356904709da5ae1cd32ffa13aa963fae6ad672d1a8661f86557b13cc88c42166ca661457a773615f9387c1d1fc14440be491e72d45eb965691b7f9e2c3a91625cc565fe92b26a9a3aabb3a4d83b06744ba1ea7a1102826baea991d1715d204cc15cda7a8649bcd8a53946b005a97f74d86dbbff19d7539fb5980b3863c42dda9b8204d7c8e291dc09f12acd2fb127222b5dc0278924020413b2035aabce1a7da4798d54b91aacea02ed193be96cc6986e1764c0551f6dd633f54686bc23e1d7233681f6019246998b7870877a98b3ceea4289bebb1344fffa8e82069ea8627545f34bb15bdd20db7f8cc3ea3b072d685c1735dc0c6baa7944c4b325c0cab08c50a76d406ec85362263a8f9f71fbb10d48413e0c4867b7a7e0557ec91b6f3e7b09751b5964506c7fa3d8941ed735886f4f630e44102b186341f1d996785b12e5ab8745576cdaa79093736ccc","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
