<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"da48ff2a305aa03f9e55b434caedf71a004f7f42a6282948c62929dac37ca790835da5a2e56ea44f89cf499da5421bd6fbc717f7b08c67be9c57e654f88df2f4867427b01cad812c5eddb5f91103ff8baf1392e8840f74b9bfff41bd9994065701dbd4f723f6a662a5746eb30cebcec4dad751848fa0008c96debad68b6aa9ff95b88e1381d38138b9ec011c708f301b269f7eb025e88bf8959c98811a19ce03bd48eca7007853c59d671ea7e2996208f3590c27059da45e5b1c0ed872d36e60379d71efdf83877615a897134470c2a1a7fb8aabaf88745ef4f6e3982d5e0bfb80b0a8d4136e390e6e2f3830ac776059ab4d933dfcbb5125dcfc5c166dcf8b91da36d835bc6072d34407d09054e660d8ab47fd69bcdc9363fedad61c5043aa1a58470a75bb9f850fc17ab5c8f112adedabdb9c003e66aa6fd9dc03b207d4b5af9318cf54bb12e0bddd5a2776a28488fd2823544aa57d2cb22e7a6e88c9b54cab08cad1f9271dd825a06907989f117f7c94682644e460fb308d80e58849ce92a0258393c7cfbbfa1b70a2edf8262f92f909f6818f08a607f8b1182e71a282b90a730a996b58be999d02b648b20dd6a55f16dc98db41de015af7548ce380268f53f3a43f902aaa38cf8e6aae4c78d67e0b096c8ded485818e1a56f8f8742229d418c663c10a356aecb78d553c45e30a49de143b3ac038ea5d3b60f2d743f6a103c8de136063d7c46ce555ff6ee09def50465d2897c05d8b522eac17bfab599971d8596c055054e32f2d8695007ff2f88cc62c97e13c520c739e7b4c49dc1719672c292c827a9e94aaa43c63cc8a553ef427d3e8375b8026d9462e3d3e0ca93f8f1b33e5619c1d6b4a02bb66d594866906cd13fa9a842c4b131367aeb6c35a3d36e33758085f624a88efbbf0ca582770775d6e758eb416eb003d1dc4a166491eaa01f8896c159685fe3fef1bf4d58719c7f44ef8a85ed44f7cb6bfe818934e7238960013dc59d63237802d9cba778c751f64294f1e5d9d9e91a36790a087a55d00acf5d6ff4005e911cba5b215e049436fbfe907a654c6106958b33d4eae0c9e3091ed418fad54c30a2f90e6b39432b265c856cbf53e9841a8eece9156e9f289b342945f54eba5175e75b3a8f0493a8e7a9c0065a57307db1293dbaad02f53c9b48e93bdfeab5d63be33256de4720b3ddb1e1e0dcafe8291079972002ecc3ceddb06e1fc7989ca2bd7bf59987e3bb079f21f6bee14dfb6fb596eaaac4463ae19c1495d5a66b46b0449500836aaa5c86d687329425371efcff830e74d2c53c81f74c9b2ff65215bc3c26016864562d4a0b35234cab10c45c0b7438c2435fa74638032ae01b88dd4c1d4190911fe2e38b2e5bce9b4fc12465fbec81330fdb91073f7e22bab6f25ea626678685c105897a90e76ac95468126bf90c209184bc6dfb1d8910364df20e8ed5d6055ca795fbdef90ca9add87791d2396f7c9fc3e7838e260a8dc8d5900fee024d25888157bfd3769cdb5b45995b5038cf9c7aeddf7a1d44e0af1675e01e832758ca16529ff6e39ad17c30e2ab4b2f64cc43ec3b202f6d5e2daaed8a3412a0b0922f9cbbe62ef141ec0129c0fb11c84cb277ac439af4f5f1e28f1f30a379a35d49d40825207c689e2334b2229d52219ce6b0d7f8aa9da26c11b1c9e5d0b731f5cbeb8c370f089e216a1ebc0f8974ecad6883ff3eeb95231a1fabf1cf74a1aedd0e8229c367479b533664c26ef9b734365a3e5bb82d77c10144c05075f67c75546bf28b10823aa5b413e5e5347177652d7da0e6cd482cf6dcc45e9efaf39d04188898f9f91668dbcee38b0a3e24c09ac44fe86cf203f8929ca0c2be0120dd2eb28ee834cf4722efde1badfdb1dd0b23c7596fb3ee066ae694b66cd3b1f7aca870cf580ce42050c26f21ff0812f2bc39fe684c2792434d2063ebf161cbb9f1f4d72212a45b8e0602d1e49aea5c1fb4af9e630533a091d21ea936d5098979a68ad5f4983e0cdaa07f1004d54136875f706515aa46a7561ef20b7ef2575d9c89891cd5f63a020135049058409f664f7c1633aa1eb5f83b28017b17ec7b63c2725c0532eb6f50457efceea819ea8e9771799aae97b8cdc13fbe06f8049cac29fc85713e07d8913e92f3b630939c377360a6f1e85216bdaffd968f1dd3189ffbba992db8b0df9b6ed7915370586da0a322cb6b88d86f7554b27457d50d2399ebdb076bc3da9d57e4e98952e51f170f740a4ceb1e75420789663caf571a03184e16465df134122aeb1f2b07ffb4f2b768d9210f07ea3b1647a707a1368560794b9aa89b72b4b7ac84200899816eb6e00e8a800cfc3a5e67a35a57098c7f74705fbb16aaa40bc5753d79c773235da241a058bfc551ba3817a4d64ebde16ef89c18e6b2c768bcbbda24ff8cf7389e75a3b69045c269c476d958c4f5e2148bc9d86df6a0c202627db07bc9d64bc922c4e24589f39be168f9c51b120d9f7775a1a125433560f15b71b2e6d6f867146fcffbd4dc09f81ead2091265b05a0387bbed33a39c3394d80240b786d78be526893e1872591a1d8a5fbf704ea3d783a482f59a4b81c19c09bcab0a5342c462d894081ce308d1e1e38d8854f303d2304179ea9581d758d4e0eb33689d40f269c49228162efb03a871df48b704edda2329fd0eb9da073d12b36269d156a2eeb0a4aa7301a28102e36123000038d7b2ed1b6af1e1863ceb140fa00dc1ceb73eae4feaf34b7a8e160e3754b33dad4e708022adf7baceb9cbf5b74723c45f478b66500bf4c3c1ddb047ab5b6b8b3149846f535bca0cbd6cf5e4158f532a2ba52488f8e322abb4dd3694992624a8d86fd897d798b371b0864a6b4e29584746c98fbfdfe424ef10b77665ceb46eb1fa79f97a57bfebf18ca15bb080ca27612b7c692592e2a4b255704c5bca240c2716bfea3a6efada52da12973826fcb780f5a407351514626d93ee3446d89ae6b187a729155c898a4db76e6e9b759da03df3d0ce8407b6251b49050fd49f1fc9ca12b86ea598f3f67a0a0b5914865cb29e34b164130d08c1f689eeba5f0ee9e751551524a77761556a7a064cf56353cd5fd342d8f32454462269e0dd69965fbd78b049b6bc2084d1135916f8859cae3048894d30507a0569c8c27983430e9c21ddebfece99519fdc542e4253ec1d1d707fcc8701943df2e74d74f0abd2b344686942a32f61e54763c961fd57b4d23f8a75c094997ee7190f9217dcfc5a995fd958a895c18b5515baa1575df1941bdf45b987e18b929956f45a02d75367eb1fb17eddbf66f27b78414b2b637f8eb45c89d42985e054a41f81fdbdd211b0b89030eca3a65527f63e57e04edd6ee4bb1f7e6f4bfc23e38bee465a4d14522a3ac65e71b134961697c042eac0b5c068a9d5ef60c9d5a7d886caa9d0b218c0287d5aaa9bd67f5aaa51b2033e9730991a961724ffc3fc7e69273786c3e16f9eec4dce0e84f00ef8097d8d249ec27fc37614deff5176fe980aacaaf890a5c0c8b783a1ed874f98bb377709d8c20a114f5dcad018cb23e2db653b826833d1062474eb68f1c8a3194d7f46c1ec3d21fd1a76d5be19f62956ca5250269e7af737b7bbb961aa10ee654c90a003a57c8fa27c5158d139a5ba88a1a830725276af1786f48bb264dd84b534953c363473852b469676b68a4b109ca8b7482dac56c645da1de46f0b9cbbe3817b1a70574d1837a11aa28372a755accb87d9b632fcf4d790b7090b4fab07d14a9d8129cd8ef2aeeda046b397cf84cd56540d1449fa5ab1d52444fc835c07444824e3d673f4434680d17dbbd13ae9c5a01039b62fb888b1f479eef7edb40e9b91ec0ebe2c27db538188fe98aa790bab7ec4a857a3642ab8e9c5980e4a68520b97938ec26e409ec4e8acae6ded8708b2ce6233b56578af66c5f225efbb6e42f7468629d2a230c9f461a515a9e4bb04d8ad96400fea79d5732827d0634ffc8c4263475721669537800f9e64925c2b5a8fa04a6dfbbbf8c066b13a3d065312b33f122c832817b8c2dd609b461b92d1e4074048de411248ec2c2742a211d9b6612315f39e531a81e62f77359314f66cee73f3a3d8f879a84177a7018d664919b56e139b34f80d1a85ac6852cad08fc192722e9625680451ecce33b54f4257cc0b16245257b36a8456f4cd2230ead74f2e226d4094a839dd25651c8e600f4c193c43571fdd62c1109b51ff438ced8d7923abd0268cd8efcb90c6ffa9d2212a7948ae906e28eaec1226b15f4f149b43cb49e2685e69b74824db637277a4cb1ec35fb14e25929d80b7e1708ad7fbe6bbef07207a01328038d1ea2ce21d4a7a27f068fa097889f6a9b2b57e45080a9b1acb28f0ef49d012a774b435df6a53c5fa0e74993562d0be1214caefcd47b57a23a3907a5aa944517331f6770473662ef476c1803e5765e65c72ed8515a010b2e226769069394d19a3ef85c3fa6c95ae67d427d56cc5e9be25a260c0257aaddd988b4dbd8307daec8e33093526a2ec70e5988f049e4e25ba169c58621ce9e2287d77de0920db09f07df9868db5e6e969c9b1afdaf64bb4e6c16f1da7bd4e07eb8a80c0e3d5e06434a14b6d94c5948c51842bfca7b59a0b9557a373370dfeaa31fb8735caa3e7a29a49511cec7e1666e75e920bc2bbdb01b3742050693fe4095b9b750f3e28b6b61f72afa93f4893a41c3555f208f38c3063d6330f2bedf349cee01eaa3af94480119115f943bc04c3bfb6292e0fae61864576d3b5884ea67cb5580ee1f02bcc2bbbcaf4ce8e88e43e72be52e711fcf2b209de61561f9c2ba3c1cd84f618f2a78199e591daffda04fa45a74db8263e10e0be3c272e7da702fab7d281826fc4f4954a4d8fd0de50bbbf66c3c87b08d34ac5666eaad215b013589def3b886879cefcaadff916972b81465be29409cc07320e5dee0807560cc627e8989ca984bc5aa58fee0f3d4fd923ad84c9eb127ba5406bcb1bc71d99c8c68fbe0d3fe8d26a97e711c46bd14eb8ae752b1f25f5553249b256f473157c43dc1b049cc9cbbfc591268f9da2fba9057f4a99f1fc4f3da5c33860709874c20e1f130d92a2516da115f8a1542e6549b06573e044593a2b9a8febc6dd5e26a7b83061a783ba86f4d008c4f6aa4c00dab7c075d336e07a65c8329427e328f9cad9d0d4055c4c08d6a1f5c62c691677df6f9e7f20f2308c05b6c4085ba2a38cd43db944be3e1cc929a741dffb8eef751765ed7b99cbb101bd67c6c0bd5a59fea61a79ff2469738b68581af5803ab7d21f6da67573fad1d450f57c0da16ef494f2dd6c8c93c99dad9db92d64a33e7c4d780cf6ea522ff2b253eb49d53341d4222f182c57d6502235b1a578c6bf4fed41ef06776a428c763d3f521c5af10ac5a462e24b5b3f6f8b3e6c9e44fd40cfe2ad3b707e4df10c7ffd74a1547f7ab3be6c752a20b05fb9201950c81756648bcee8d102570a4bb9283819793ea1d80487e1df9ed948da0d05aff3d3aaa22201247ce0262f762f05147515350fb9523e62be288cef0f5dc16098b7689c9fcdba1ac751cb2a3992382365756bfbf8b06e8988629528bf2a0748be33d52e480ba3a5903aa20ac4491be4b9868a7601239210a2f53a0138b039da63f4fc5d7c24bbd52ba84c7b315f36942f76d7e3c325ec974af14e03688bf94b1d460ff078c88f81f5427afcd579bc527708d597ce7672d18c96ef4e4e84c3787c027de7c419cb4c98dbef1220fba94775f7585c8235f9907bcafa25a490a0ad308a7ed9ccbdb86dd15ea902f773c8776210134e311468bfe48eac1f49723b343d7665712b039e8470ab46777d9329f1a39a863603f2015485658a15ffc027ead5a1b7bcb10b134affc2a564bd68032733e7b379de3d2570f12176ef641cf184ce17866462be7e81999f0860185850093a50276a124b757778dda3e9d5e7e4926363d9fa85791a45abb44d0dd10d3aedfb60071e726f4b1109611717c4526bf2c4e8d46aa90b456d1686775942b31d2a2750dc342f3919fe03f698d6cb66bbfe7fbdac45dd21ca5cc5ba6ec7cf5ab2c7f58eb5072c0652dcc1d5c53145c2b1a81e2a34a84d82b950306be9d4dc3beff036c839a4da13d4aa16d4110befc7d96da6b4ead66245ae2c66640714cc1aa6853e7146285a95fa2e1e60a96ee61e672ff9de853e17283610d24320bb804d7f59224ec83e79b25f3a4ad76550e6e4d798093a190a2dbf0d9f5b7736ca18132acf081c48ed0fbfbcb082406584b977f09e61b22cc200706fa478af7526814870366040c929e9ec4f2ed822ec4f4783b2c3601653692b9c9d05a4ad59ecc82abd62eeb8c0ec58d470a061b8af2d72013d5d5d1c9faaf7e5f3a340f6c77462d0f8565f0b0fefd23ad7ecdce902f5d5bd5abf02343159545ee8c673798ee079244bb203e24d456e57394aa8558974270a59aef7d1cc95a44b17de31e2233fde178ef7fb86bf301e088a5815fe93f0815245b58aca1a1b0393878f01f95ae20bd37b7f0711637fa7038c102ca26a83b35967c87d132b5666ffb60112cbcea0ce82759f377503973b86e7677c73d61fec80ba214ed595b72f746ed3615bdda5001907be9ee1a90cad576ea80ccdcc3057b29f209d882600aafec63cc5487904bdc856319cf7d759d96e88a937ff3f9216b2d89fe5645319bcf064834f5320153e9c8e7d09c620e0faa8a7c63c6608910c17c28ec5a2514ae86238dd94614bfb62dccd159f368168d203ea45221fec21e0390d4b4ef54a070ff718ab425d1f4166b29bcfd94a317386f7361f627b5abe6cf60378219603b2695138e48c5dd584247ef1e1bc92d15dcbfc207ae5be27e5a652149dad41cbd02bce25e1c7a35cbb44b093d35d010f4633f0f3a16b58683d2ce96a6f18bd37244b5c528f0ccd65ca339e090b780d473dec6faee632fa4d40127c894e36e8c0df7468845be63567d944cb7c713337b5bee090ec4865752854e2ee309fe2cbe63792929537602ce960fa2fdcb05addf1ab5fa52cb742378f02a477cb2b7e90bded79e8645b47b202ef92895ff842bcba4d83e9321d95d9a85da5af2299c7cc2e7717a66bd07ff1681115ca3951b4e58d9d9b06df5289628c43a4fe5491d558136c2d2ff6f07fe0a7c56313b7526d75d750f08b3a79a4fc0159b35f16cecafea18086c42c7af1fb9c228eab2093e8333b988746ddf23aca044895a9aca6adbced4888f4e1ecdee800bd40dc367066a6569d0f6ad9f2d4768d30d89cfae0d02c11389aa6dbe71371673426aa9169968fbfa40afacf9fefd2195ff9191650324702d852fc02c9c4f38365b5afcad682892d06d0b03f394a72ff74ed1e9d62e986f4161a2ae00b062fd2d7b394f73840080c748d4641ed5959bb22a6c755d2cff3d285911c3d6e71363fd77cad7332a55182023339a652529ae99357f0988ddd4112e7dae5f188a97a4958b906bc7434498d6cba82d561725fbbc730c3d0ed6f830f293c6348a82726b7cc268a50f8d1c99969a7484a861239d57636f02722cdae14b10b87280024c6ffb898061952d236709f7e553dac2dfd63b0003b99e3491f776fe244bbedcd895b3ebada7fad6b944fe1c7c094155726a742e8cec413f38fc6f3734831166b47e78e7fe969cf8d6aa9b9ac1e659211fcedb0da704114d7d6747f785bdd382bc6397c1d7b0f30c55292c4f179588d33a9aff8ab7ea42f6117d1cdbb46825a46c571525f2f395ed7aa4fa37d7903c49cefb49311959983adc4249d9a9d360844c9ce9b66f30ca7004220e313c108931881f178f2172dea754f40862180be0f9a9fdd2df6cde533efa690b2b63ee9f446b3767e1444c5ea9e21f687e72e901bcc9d84aab9264b01db83b97274a3fdb09a69a6c5e576d4ea9562aea54a8259a977c4d5b8785c034cdf667343c7a71b96e9c778b50b21ca170f645f60909a648d1a8b7f47f01779da662f9f0da5f1db7e044786ef50b94daba5204597ed1fb1c74dbdf9a6a2fc920f1746c55739c35f12851423468b8c50083d7b6165d072b026367b85e22b1fadeb7f0c8804e7e19c1a71b539761b750fce7dd1303e6378ced7ec7484ed41ef4a1296f313e419c1ef1c2206fb770c148e4a6b3cfaa6349ce7d891cf1e41bbab8bebc7184d70d30fbab9363f475b9fd281743be75b23dbf18513fcd370f8a377f9413d95a16362f6ece2a79733290a7ff788819d30ba84104f4c03d6394c8b12f19198fc1a8db7d8397bff62f930e6463ceef755d8997d7c8a3b63852a18aa4379b2c5fa3271bf8e6ff261f9c7c53be05f5d4b40332dca00586309ff4983548763e947d7622f04354d1b000eb7d592935f654cc5532d73772354f8e4f8ae60cc6169f20fdbf3427f85af3adfba52f9e9a65b5e20ec057e41012495cc702f57198ff8a95026b036bbc70132f923a7b64437291f23c157ecb4359f84ed86ab059ee0de070af680256389ae68cbb82f8f4785716b75afe9b85d94de405d35d0b1e8002bb6142e2d6fcd835e949c3f9bb395671e78af70b88031c5fd98d46b304bc6b5c5efa691fa67cf11195b5585b29d907534d9e0a852f9213df5b4ec3cce5b3fb7d67169e28a99e214c58ca8811f5768587d9fed253a3668495b7f9bf7b1a29f14f2171215333ea93e7c47d5ad2c01e1ee0eedc08218f7eabe24da42b921dcfe66e7a4afb9f51a9a3493bf5a157a03877ca4b91a8b2616011b109b4d27f8f435c4dcab62f141a180aa3aa850be71b4a8136ab3771d2dff3814a92be0f30bbff5a15bac73ba74fc4dd5286990ecc359b685e5e991e4b3d351c2fda2683937625caf8e525dc9ce619efaca51fd18aa1ec98c900d84a37bdb5b40522039cdd496dfcd3cb17d584314085f26ac8525281d075ab8d2bfc1e7b0a54cb30984b0bf902467648051f80fce2b45a150a83db19fcfdfcc0c8fee75e02097c8416613d338bfd70566e097f4b294013721927a50eb92ea4668fcf80479bfff43a3e6f9a8a6319bc7f6be41081c7b14baba9d1ad1ff5c32ec4ff62571d05a889a2a0bb6c5cff00313c4b870f8aa4d81903286c5a50e49a3e9c8fad4af0c6bff66ccde9a5ed480a04408cadcc7503b457afcf732751bbd527974a29a8dc3c28c1d5dca2af57acb74115bc635b3cb68e6c8bfbbb1465b08bbfacc056e3cef44782f3fcf6187f015ce52d218c7603145324e5b939be50671ac51bf2a3a05b52efead3b5c46914b183ef59ecd26afe611c85fc8ebe33ac67f548fff3429531f730d05511341ad03df182d2a59412176caacf4c212df2490bd25e0493e83a7fa77c42b583d889b34ab0de52ebfe45d4a4d616e20c335e4bed4a6828d14fe5d8fc902a2d9b51c951061b5ebddbc35be08ed4756c91c1ff717da1c2c22d70393623ebdafbf2e4a3a7e1387ffd444655babe94d899df8eeb4a381514bf0380ce7e908db189890d41361fcb86ea5e7ce24ef3006cf2a38b56272bbc1a98efa5b8731f4727a49a8061cc52344f79593198477974a51fa882f9f04c2ff1208710ce1c1469c99a43d09faf8aecaf6218558ccf384da5028155cacb646ea62186db17d8e4bcf40d7444ddd60d786d1890f366099a54183d11f2bbd48cf79adf12404eb90e037b41dc81b61a6563b29dea2fe4599a812a797458ed51bcd649dc72e4f3dd427eea000937780d5153956434aaa3b5c7cd91d42a21948b7fc19f193b454d187517ebcb89c8776ef41fe7a1234465f4469282749efcdc46683ea860bffc8b23cb43d162100c2b821fee85db6a4caf29f7ae3c974dabf6a1ba2a3189ac63d736bb134252bc5fea19521a1344bdcba8e15301197c90a03f8fe3ca0b263f374fbfb058fa91f406437272b5afc3f5ed155aa3493a08e51f85ce095b85694eda3274396eaf94e7162b1705b851a7dfb5b336df98a2437388b9d217799679ea5b43b408bda97b9beb18a3d082570feed907dc586a2568d538b18206badefe8950f82fab0a24028dff8fb05bf097f2e66e25c70749ec6f9ca6ef5ac2e9cac2e889a3cd409ac993bc272909e495a910b53a365ff6462b4c28f053e348c4923cc619db60527b1b6d9a252b6d359fa694777faa28802143866575cb03912aa0de996cc096b50b47853d3d19e74ff0c9bad2bf5807575e68dfde1f625c681dda948cf40bf521f985146a246171a354ec368cd448238b202eae832444d9b621d696fee9ae287fef989b7f206cb086cf3427687cf3ee4205ceeb16bcbd762afd2b73e1d2c48cfda405415a9863c4b16db98a82b0ebff453fcb7b2c0478c0b5787baecd214a69fa8b5c040e1cdcfaa0971c7aca6c0e6d13c7fc8ad7c1095e8bd4890b94ef429379e9d058c287f211b5f12dfffe9830f6857a0eeb57e7d576aee498adff37211fa068e1aaf8d99111f2c3f35616f6a3ea26bbde92d73fc7b511e69b5481323162eeec03167c0309a00dcb7481b2954bf9a59fd9171e26d828fa6c779341be48edb418ef69632be3b570f7a562838b42cde2b136793bb28a81e7abc53b7e9cfdf97d6e33ebd1b115b5e87bbd6cf9eb08fdd46e0aa1fd9aac5afcd34ac52e496e8da899ebc2d63720ab572f86485308d76f76225581f3f12b4d83b55d6945cd87eecf21ea7fd97e04e68104a8613921f8ad4f13dac45f414a2e014bd49a2da0a0e79aac2d28eee9297d57183b3af4075ca852f4e544ba6c5305a43ef6fcd8b1349c7f10382bc8ceb6daf52d69a68f18ddfb65555266413c7da176b2b7c1ce1ed8650501fe799e552ee9be9cb3833592462b4d063e559da36134f4b6f90eef80e7f81e5de810bb0a75ed0fba3a11cd81b952fdeb5c40a86afbceac972bb863784e8402f416999aad869fcce3346724487a1d57490cdc5f6746938bfd3d8ac50a6dfb80cc57f126b3512c9cd2800f3978702c55551a68eb9e072e2dd99f61e0b158f7fcd7eae30aa2dbfdbf85da5810a9b5ff817e266395641de9d7ba6f12b44bbeb769b2cf0599a33b0c012317ab074ab667c7df82f94860f98778e4a39cda67d03c4440234f3c3aa1c1277f00626634d4e75bb6875360ace5553b374a1230669c8343ed4ba2e93d050787371dd220432a8755682c5c8bcf456d73773d10e51a631265342f02cebbb9f074c64484c9681f3e335ab80cb19f879a0b0d368ab924d447c666b7933a5f8474fb6ad719e1f58426b31102169f2139507b9cb4a99c003d08f85963f97e34fc4a5dbafe9d1b43d8457acd0e5a8fda6bf81d740dc15b1109b89191ab3b32f716e4ed716155187bc55bbf2325482e31c78403d1374310338b88d7b44ad591bad1faa8ff9090857a67fceca1455e99ef8169a40968a413c583accf4765165489a578f4ac8f4a8526d03cbaf3625d6bbc444daaa2492412098dc0caf5acf2d58f22500d9ead879729aac3a132b441e6c4a315bd912e8dee3962fdeafcb9be677f11a4f8eaabc83284b87bf298e192336a26c0e1fbfb345a07d33f1a36ba9c9d4e540311abda1fee7814689ae4628df0b0b1ce83c1234109c178b5196c9b132c123b2bf6f013cb2bcbd3ae7bb212b35fba1c983acb29e8f3db92bbab054612de4e9b1013c3ac899998ce506d2f4bcf1adf55c96ac23f1f35bd81b9e8d8782bad51ca083ecacfe31d1360fc2d2d55c90bb3dc9e1ed59eb3da5ab0caadeb564a0e4fe0b6cad9ac6d58c50c78e86e30db83be547af01421c952a06472e02e14910e421b52fad303d6d54dbf213c469cffd45a4f7c7df1e7653084eb2ff8ec89617b76dcf6b2a2d24086329717c0c085d4dd32295d25fffb0721f641036e0db3d1e5944aedbff225619626f290e149de649a2f80b9b57ad6e908d5bdf03b8b2ba73fcb1a00eaf4663fc2f95b0a1e6a0599ac0cb3c6eb3aa4b7d573192a43b0be1ef62c829af5c7d40ec89edc5441e482b3f2b82294288c41a3a4c1dfeebdc36122d8f1a2fe62d858d52720eb0763e9bead4ef1c1f7fadaa3d5161197446c9b0f250f58dde31d11560887a9bc82071a321643fe0d61da0401d6172f0b8c6118db537361585059587d94512cbf7a22434d4a1c1ab04b4e8f7f08303cd3b13638766e9e1805ad211c8da920613e70ac0d9382951bf50eb03bdc0fa20d6807b207971a68a2c5722c56a44a0414574071c2e0cf14f7d28393eeeededef5cd232b9f5c9394e6a23392f8ef8afb2df1624334f5d5e00f7d1b404fed466c267332577b4286341e6140d612b85499a554f302e1648b1132084de69f04fd2f0283cc0d000c87d3f77458381c1924ab640c19e9eafddff89e2c3f07cc72bb2eceb43c62d2aa0853b7b3be416ad0117321ef27306dc30626888866466ff47df21db69d629fa5970521b3a17172b30bf65fab585e5d1bcc493581948bdab892444b160bfe16a20ca3d98dc64356f64ede4c964056a413123e23efee9a1544f60f4cf397f70004ec94fc802b64bfbcd07d47e1d55565a92a5d1c9899e20ce04d03a2284fa6e92ae929c6558103353ff43be9d72a1b8454da73ca7dc2a20757c769ead444fe4428f4798b3eb6ceb94a4fc368610855a0c8d514d4bd39d4f20df00eb91abff54a5e50ed1b35bd436974b541cd2b958f9b5b12038377a46ef946a4468055a2eb2753f60bdbf95c39d5ffebf201d2542195401ca2563aae8b52c66c1e6e1dc2acec37c7bed9e3f6dbeb2ec567049a8ab2779fd5feb41a8fe05d4b934dbf8ac18d055e834ca5906c582141fdfb6135e65f74988402c35a9f4d8e7520e0644226021091497262edd15a6369e41f2b96f7d4d435f15ca133d339ad872eebb82bd781290cfb531727749a788291c79d27365bcc96f2b0dfc54ab80739b1f30129b1eba41332a04a2ced586277188d8b04919feb5233d55c54e8322cc485b20da5816c8cd217a536448a4749fb23a1238215b85e95d417c6ed486aa4eeb3b357ad841d7aafc3b59abdadce1b2c3cc71e68e3c5b07f09788d8904a8956ea8daa87b306df24e54ff5044590694da6dc77586ae3ae6f5a188c23e43dc44a059a16563cafacf957dd13f1bc8a9766882af6e2feeac6530439de633b3ae94ac7b76032c12f116c90e0a20eb6b7f6a0ee71e8821fcaad9c187b7912a8f29cc3b20c288524c61d63ca4e2985e842ee4587980630f279f0524ff17754ce1672b1b54d553baa692741d84bed1694ee06b05ccb23d32b655cbc12a64a441f14638eb8bf7b6130065139983b87de9ec9ed69356e3a9ba096e48122a64ef71d8e8576542880cb1bc577b170f03f8c1b344acadfc79af77886657dcede7ec681cf245885b3fe56c207b9beed2898c1262b28f327d4ec2433e53a8942c0aca4c987d9a42bb89e1d3e2e77dedb5f453ae9ede5798c1a0eda22182b906eeebf81063f364fa523e5e5eca564f5760c5c067045652c4a537f463f6be58fad72c5a45e59fd8d4d9e69f54244a9656789b1bfe0554dd4684791569b02b752d57590b1592370ad9ba1cb0cff36e294a280a227725efa37e77b80f135ab8ab6dd4f5f0046120369b54a99443624bc9c29a1062aeb21dce4b039cc9099733d2f5bba9fe9cdffba1e74e4c546af7205d4081addd0f8a60f9bbd627c1d91da374b47e92ee13e8ba543090ed2d021ca71cbb064f5dbab578e38da026aa7bd52502aa29dafe2fed4ce62f02fd0972767f2bb12e9f55b5f1c9b982fda32783a8664569031a6737d7a640b5149991435e79a726d76ece68f0d2fbe27a993b2b4088ecc250aef54f9c5b51598416c4311c83b61157c7ddd98ac251450f85b078cbde18f2e13b074a5dfc16db8506814e1b460e454b6ae8b33636e513d155ea82aa91d8ac4154dddf9ba85b80cbaa8a8c2774b0782af9ed9c48fda7d2d71e05edd9f2b72391a8741bd5c5f9e6f5bb8c6a7bebbd8f33b7732d96eaa8101669ba50d1a5335c8b7f53e4600adb5ba984e7b6da2464e88ee076e37bc116423932e17eb5f121957f8cd7ab44275c453986b24c302a9ff3b04ca8ebaea9951e0394a997a0ec60b8a75811b84287346e7f82d82f30ecbd1931b81c4b3c3ff9ccdbe3ce91f772c23c37c111f59bb1ffcce4e3cc77a6d25a264521770760bdffb1a6ddac99bfd18f1af67e9ddb1734f49dd4def0067ada4b5c1f009c3b5c7a65359379a0f17162ff6fb4f2bf48f6019dd3b44037d9417d25f28e9c27de2f434ba8b81d2a627bd057451b6bdbe183843fd4549a0cdaea692954bcc4b77ea2f6e5e6f645e99b94f755d266a7cf2481dd4ebd7f9760f165ff1d0458abcae0878f9394507f5dd548fd5ac4692763e73833b89f53ccbf3ae241a142eaa6e63e2fcb724713d1eb4584aecd3b0f5ebda6af4594aa11db497f9fbf9069d739cd2c09d3037bb2b373c52279f440dbf1972be90314cc77edfe9fcd996a70cf486b804b1da8ef7a21289a69319ba8f19b82b16dc6c61d195430e1ff89eba5194a4f32edbf4e219b22733a6a98248d5e56fee68d861dd62ad38252663c5396a17acf02628aadceac44fba1fc21c33a9e9d12b7302ec70633252fbe3e1c4a72a9af208b314a0bde2f222f227cbddbc236b8c5b4bdebee8500cf2880959245d34d394d5406e38296f8d502e4fd09ae2d40f8304606f4249f2d81dde565cf55ad10a7918c5be93ea16abbcd88bb245954c2c68db4131d268b537e059c0ff4a0e6153695b9461bad96bc7bad3ac46192e5cf532596aa90a1ee75f06a29fa5572a40b69466b2aa39ecd85637c68d3d41e4fe033f3b88eafdfc02cef234fa3c10fa07c901e36931c6211af32788b058fd3499833686ade0e59597b083c291cbd5bf7a66f0d56098b9b5ead6626445f6cc869873d1c90239d25377eb7f2f623d4bd551019dc97a86620724e395fc94c3bf63ee366b1fe3a72bb44edf3ee0fa9fc825130ffa3eefa986bd9406294c2d3b19be94f80627a1f43f1254f91c5e118b79e9e3fbb33eeccf93814781da34762f6be9b5ebb845706c0939a737d7c1e9effa1e51d37765385a4c7714d567cc3283c2861076cc77deecb47022ed97a564908108519ff6173b36c40977f283d1631e5f111fad2536947186bcb161878f8281418b65a63f11e5f666dc161473af51e8bc5ab58da450383b4b6bc195f89561478af313edc215320b7dfb1464c27bba7962fce0353310cd6bb9c30bba19cbaf3d6369efda0010b1b77c13f48609587527ff8560ce790438c4777def73797ca793a9624dbbce3d2f016d0e187ee89b17d2c58285babb5ffb2a14436d6a89894db4f8aa500c1316faf7fe8fe3572915fc5da6ff5ece91663dd943cc4c50e867e2ac8f0582c6c88e047552fdbd69832c888a12c61ac8f8113471f76a2100b7ae949b26b2058c31d2c066e44e7582a2e0db9a062380b713778c3662229e38b4f682087c75e4ce0cce192ffd2cb3c3510e1c9030a59e1730794bceb2f1816d306b3ff49880fcc04b0ebdb0c3ad50e8bce1efd610857dea3d30c9375d12d7c2f2ccc7062a1a9fa47831e706482afe240684ba9c3f15da411b82c544ab9bb5bb40529d345bb31fafa3c69f3c04eb59b6982f53ad891b2c62fecbafa2a11a1c64803862a4e6a17f3968834de09e66fe5aa7a37482888dd536be0b5c57c07308757fb294da9dbf9d001b1aacc1af42131a157cf3df0ff5ed01b47953d69997968c9001ff0cff2b3ebd8d4726d57b36ef6cf9c4ead4108102d030f4676e35ffc39d4eaaf937806493bf9727792f9a7a0e467675a23628f235501fc0f5a5a79109235861e1300455a7eb364af54f9e9b2bc67daa69215b304aff0c6394cba288632ab4b1a7ffe700735a5eff41a95634e541804febe497821c19a752199122a1a690906ed80d6eeb8e938d0369d16eeec1d3c3bcfb04867e644d600a05ce4097b01f4166c241f5d870c5189ea45dc698cf049674314a2bdf620fd9cce922ee64ae25cfdf8d16d92ce1cff9f2fc8c36b94aa95151122735ed6256e4db85151811f4ad7b051a0db9a5700a87167dbc6a85aa3178b3a8c37e5c67e51c3eadf318e93e7b2e2ce7628ef3b4a13a12704c6407bfeea512e67aad989d11fb7cf2b8e22fafad48fd7235d97c8a2541ef7da826e6e0dc2f99f9c8708d06eff685a43bbf17818906f1565751e1230c96c01b569a2589802a3a9f251117fff9e8f622da2550e07b91ef1242d3270b477c6a0f8a4e2694c29f195955ea0fd2d6ec3c29154246aeadfe35e43c56f326883ca84416ebed9d1581e2f7c508042f514f46206ef2843473a109e9d6620bb95e36bef0526e471095f547a9fb64b7a41becc260ee447d447b131583011270afa05fc577569c505982d88ed6278d42cbae7e7cfdb317299030fe8234920145011bc57bcb87b4f33664701e15965eb46eb70e80311219104f2b76a6764fa187e7d79f3217b56bd99c9e6f6fc592cc4528922a2837310d702afcd87e23ea5fd16ab8c30afebf4610ed1acb97ad48b9f9c05fdb7f57bde9cd4ab70f03af8df2d48c4faeb231fd84b8c43a8ab80c3b85bcc6cd703b87842379e32707f8b3e4dbc3400203d284647c166ef58e0fb6b5527c7ce4906f5a884cada2fc27a56744a451a08c4c3b91ee2aa33a87f7286ab5e54ccf11de624cc51645475f6bb9cbbbef8b37c7f88ba3fbaa355e74638dc207210f548a321f6f9350fa09964ec1736f36c3d956656e400458cd8222563ed53d2e33cdf9038a4393de887f7584ee4cb0f134a8a8598f6d25ba0f815c74883c94db83e75b0a7d4a1658769527653787e9236b89f267ace1b06a113110e49fdf90b633ab7d0b13d34e58bb3bde1de5bdffa0f8927b4a2a9f722cf0336bda938f9268c5c89ed46556c66c7b297cf5796b80ce4c992ad6a12ebb4d8a800c6ba2941a6cdb018f58dd4df5976ed55647be10cffea18d6c26fc0d9b373885729b0d4cfd8fd1254467dee1092aba17e27045598c025dc90c1a644e6c4fe44c40e8171edd75b08713209456e609230926338d56e8b1338f1c91c89883f8aa4130559fe39fa325a6725bd32b6bd89608439f9e6afba165c92282b5f10acdc0d5c31d0df13d7acc7c86314e9741089b252522b9b81e7d3fd51ac03c066574a62beed45d14dad297ff79129cd42611f1882f1926025d2568060f627d7be9219335193a70a02210c29254db7c2ad489c27f2faf9a43f648dee89c90947a13907d553a612c40ca7872821e2a30d2ba8257a3a6952eb6069d7de086c9ee4d634ccb7dafe62ed97733b1215bc2aa7d5fc116c44141672e5dcdb2747b15217abd72a4094826415fece0eb7ed0c12e65f73812d961a52cedca2f2e1a82f363e03756eedbb5e5ea2d5f82e72a8cad37f780e37728efaadd65a215caae1210a13efac3b3c94d2521b0ab9c23008ca05ced134b8b061e899842d9e3ca183c3dd5c133500753110fde3a76baf0ba0ca9f7c4ea57e55dea9d377ce16bbd46dc143a4cb22d03d4b64b0472eb7e587d732cc2d9936f1662267eec33a8715759836f5225f5966bdc9721442a1d2d47e6ae7fda1e0c49dca3b9772c2c4f68a4699b7b4326d0c17a0248dfb856f29c6cc97127f796dda342bc79779d4884e90b3a13c1de9ea453b1885ab9b936ec07c1247ebeae5fc87e808daf44880bacff6404be7b0c86aa5fa0b012033b600f97b1e27ca9540ffbaf4b531496553e184b10616874eab64dacd0b73bf95c2d0673cb4156df2bfab5a2e8728241040a5111372bd9d9b831399f985551375d0ae9b84175d5e712e945053644447cdf44a4c2ff77ff7f418b8b227a4752cb1efea9b284837349fcda6d903ef95bfff4ae04c776ab3e600772183719bb1aa313e81a0d16ce2cd805c6a8c0e3f676305d4e301f59b2fa943da1ed74522a2e39f24fe443e4a1bf0753d23e7d61e5aea9c2c8f682366ae9cd9e7d74c78eb46837ad429ec208882ab16046fce5a5632242a8aa7d37dbe98481059e3280084aeba0d5204cc42aaeb78b427b28762feabc633540812cc4c75298256e52a22e323e4ce5af051a5451cdd3694990fb15016dcfd3dcb6a2e05608d59fc98f73f340fa4666a72","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
