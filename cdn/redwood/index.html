<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e25100417bbb8993eb4b2df3d2e879d23fb114da787a6205826808a96afe5b9fca3f6747a02ff39087a4f5c882250a15863bfaea95a6f7b51697d8ba8b7b350510f367871f3765565689890a3e179e478b45a4083e858417335da3c1ae778a35b515fb36d74674c14bb6d15c03ee580e21413810e412491c5c31817d9f9d72695e075e0222c199abedf3a94b97c175a50344f7145cdf6f2a025e93765650c5714cf0a5ea983ab3f7bcd2ce8f70bfc4d254ab5df230d90f2e30cce2a81040adf3427a4d6659d90183ac836fb6af117762b416a02256860a2b532efa8fd34fe32fb604b31d6525776fd001b430a58d3b76b44c90eec31a15c005173f143cd83435b31c7bf641871a4b606bb7c3c7c9dfc9617271c16c04e9a08354aac06740870c15006e719f00195d0820b1de8ee1e1047f2a03db9a8b61dcfa89892215d92c74248a8a14e45ea22b68e6380884e6790e1b62f0b7d8cd0250a751f150a72c10c2d5d59cc82bf6514ef621a1c3844112885679d707e793795e5311bba36169965c68d5d776f51daa1da49682d21538846b9756e7196d26597ca2dfc9a30a956143b45ead91ecf44607c0620dd8c15718fca81f98c1bea6ae16c39f6b4ca631c89e9016635da5b501eef84e5499e2c5eaf99b020b2365beb3499ae2c33dfac408bbd0345634f14491d512f18e6a29e5297ea90fa43ae11a7f8e9fe800744d43ba53575b9ec0d3a01d53b1039c1cbcbb00573047da97ba8f1742244338f68d79e40d999f11b3289d3890e619b864bb26383c0e0291e319c8e140bf53c45194ef04a06c7589bde53b5e0d8fd5a50e1ed02b312c12de8cf4e04089f18b0c73d38346e83d9aa2e8c002bce4410976cb7b4e942be048fa88aa23521487c689578a1b30a969c7c749a53673930dfa13e5be636e37b6e1c6d04d8640c9f8aa3a4108da0dc021efc57cdd8f6831c92bd754b82f79f84a0a37f58a29e3cefcaf9c041d298c7201b4dabd0280407ff59e061cd64db07793904a1fdc24231262fe956ea8b2c5ea5649f956205a047943e6f818b579a4d93d6f6ea7048d64d878c3638395a0533474ba1de28a53bb564e981e996d01d8c32ddab38406871df0274a27caf429ea98660b1886562773a812e613d35161baac3af7143b179c3f470d4023c69677900d53e3d08a0486c9a7b67ba66f32c2bb1f486691bf6f1bf93d977fcffa1d61c3b0d31812a8d277b2f8fd51e5075cbe338e19c9cd19155b0146b3144802a50f724e2f3892c96b540972237aae8e3e87aea693dfb67a56ef6d3770facfca68d1bcd24459ec3d8469c73976d4b1b8e97c5a51cd38891d8d8cc1e8bfdd00536ab96db842e945f1c9144c54ae74be32be689b30d620a7eebc8f3a733e97248bbb80c290a034c3710d3e3c75adc49d50b4441a7dcf58015b94510c5b904246fd6e6e8d49e20635769e2ac4f76296745698d6f6b5781c4f2ccc5cd1c8934bd19f68c1a50f232ae31f95dcbd375ec1a854fa85be990e156cdb15b4b9b9cff9a37e427a25f30f311ddb2c28124da3acb83efae352905a2bf23a64960fa9b4ac7aa5c8db8524640ffbf205ab885337b99c5fae75c3bccce3795ae5aa46922996dd62d293ad200c3a1af5f2687aaa835fa78a9c87ecdb01d98cc6ff3e38e8139694ee708d3ee33530d422799d857e5c1e37d7e5803c58f184d06875d2f073ae997ad9fcd10fb59bd3884f954976f23a03f760cf779b5a33a864247ca540043426e7622ae33cf77391da5f63fcbaa39ae38ee7d2ff2973ed612e5c500130aa3066f2995d9fc47096320c84c9673780d34f5a67180c672a886e4c86edfaa438cc05f569efd008498b4b19c09ce38e73f4aec1116d7df4de5656ffb0e929a03d6298d748e49c532e62eb03e5645e9c3346db06343b0b1f757a713f3e45ccb5e8cdc59cc73bb16588387f239ac1c7042fb8c53b6cce8dde8a6a458ee005b05ab3c07d9c620c5a00e482069f90303af3a396a19da859e46db5c187429a9cffc0b13e956d387ae23f792681ffbebeeee5e31473f8d80aaefa2ce830dd36b392097c55733438a2da228d4d8026ad0b75ca959d1ac0786f806ffdf7ba93da3586ea6ad832721e0a4125cb5749b82d38d08e9f28ecc7241ef988ed8db5cb2aece8945ba301e0774542ab4f40508eed52bc361f95fe98e009dd186a1672faa603dc1c29c2f34075db33fe3497df806b5f414dbc4fde223aedffd486d997ffd286d09e50f573f3b6a78f06fdfc82574ac7e2cdad292ced2a18433656d8db21e7f0f4f6346e38aae8b5e3881645a7258b714a5ae8df19b445b7dd9546c4c08458f5eb56eb3156bae916ae87f7abec949520087700a39dd75e456357137d5b88ae82b588219de16ff3d088e4a1c49cbc614553ea328c6e3b184e312d047c6428885f5824ffaca3c99f565efe110352601ec348ca967b8b6c277d2703689b74ca8c2561cf4d6e111933e68e5fca7abed211c3500031488a8a677eae46dd9e7f113a93aaff7fe3afb2afbe71bf0d34fa454a88709fc7b4f39c3fe089f8b106c39f5dc936da9cc88d0383ae4b6c151f6fc0afe264cf47bf74d7b6ae768e48846617114f530bcf9bff79fd85ad88b8791040944d9addfcaa9822c2a499d17ce5d781aa06368f62b2d2db54c11f1593a4cdaa0b893f81f8ba9b30d574677cdfa1e4da6691b5dcb155af12a139273fe2be921c38cfc47c9ad297f09427d761268b77910665684491e95b0fe5878a10d423a40b6579f2e80e5c8402e90538aa8a952d48e9c435a1dbc0a04b5675f4b8c09f7b847a732941ded909dfb7de4195d2880e52cfb8da6207d0c2d2d0c05d497a190e94fe3a32056e259f01387f0da0d686ba683aeaaf60c43d421b467b33f81c89ff23be86697843701459fc421075ed286bdcad806111fe6fab3e2ab52d988af061fd4e7f78d2df386cfd0ed2015d71eaa45958b0cca7140540b09bf3f76256a97fa8316cf3cf74b26c4d025f988f9e1f04080d37c4b9b66a5837ca315fa2cdc98d41fc2bcae2ea3241c2e0ce26abe3ac3f6b721af66a16006a334c03fba16cacaba5fe9435cda51cbf3c7500cd007097aab0db992175f478d4e3841df0b4decb69ebaba2ceb4b94381a25d62cc8d73dfcdbdb2570fee45f3265fb3af3304c4a33f45532acd3ac5604aa9df00e11cd1e068752fdd810eef2381092d71470b613a1c804bd94656de5b93afd5746f755cb773ed64ed2afc346d24058fe786d12a9d34bc7a2a896244bcbe6174a5db61524d266631cb3295dcaf66cca3d14646efe94f23e92dd0ff915576f1af71973c3e1a65e8b5d9288275c8ca8f08a8f3dc6063eda780603be0225a5a0ecf34f6f783825f32e4f20afb8d688796ce4f8ef43b5a4290a716e018dd88b6d87738c0676de6e20bf229824f81b00046f599a4a89040182ee3d5cf6822a0ec3508ca8db00f9ed66b1f1789c6859159013e2cdf15a14ea7e782f4351cbd18625f005ec63c4a4ca4dccfb8be254e3aa23f0378690bbff9b4b697ab152051976bfac3a0ba3f3c00786e5624fd86fcf96aadc490a9a377e51e859b96a050c84e0cd0ed4017f1884f779e26ce09ecc9453488a09de49d4e0c09fccf7a7f9570642cb60cee0a8bd7521a73b97ef05153852d128d5a06bcf3b75541b936ce4a3dcc72f9116f238df5eaa16c92379613a6a19edb77dee2d7872c559fc772035ed3edb6ddc5ad058abf451c58e89b5cd2588d903df2f41b50ecfdf08ed9d00e76db95b0af2e024ffabb924a5b9dcdadb61d845ef86e5d4b1409889a4f50d1c461932024cae249085ca9c6a734618cb9852d9c2c3fb75600ddba8e2d4a8ba5096ae591049b1dd68cb8a61b7bd9ee73353cf3abe2d75db8f317cbb2fc61c2fbf0f2b73dc0b0a8b0a0d5f8d7ca3948727888e3d00556474001f3498d8bf858ce5855b2839510b33c8f4810781719b513d68ba78c4f5b913a20fefbae8b513b2f223224e40bdf2ec2a7ce9457781a79b2822de6738ee72532bf61d7c33bd78fc74b7337d3abcdf8434ddf940adf9f15851acfef53b1768e374827c0c925f0ef87b959fe3bc96d7de4aea8de80295d9fd0fba4cbc13588e0f210ff9b11cdf0e6469515a00671cdcb0e45312fdd4d6c028c29590bec503881051298c5c2d728fb3ffeb0cab0e69582b3d5c96e77a64923c04a15a306c98a98f020b4d665af502e2c0b79d20bf710c70d7ec85e0c12ad43784d502b1a470dbd0649184285bffe5cb50978546e930f565a49f696cf532c98ef90e73666c5e548599d553367db2bf7ce4186d82a8dc5ed2a9be033baa9ede851d3dc0c3171df794c46437d728c92c1e67affd4bd7eba0a75215a534c87096f59857e025f3e586b1e40c95f49f458165f59d56c3b4ac8b0aa6e3d7cefa14fe06b1932b4b29531eeeac4f05e64c554099d26572afa4c142e2ba78cf3d56813a6d92de677c1279f703174d60bdebeba96fc84e89018df8fa4fa4cee7d093fa045e4a2057cdae1499a868ff5b52adc0f408faf1d6b55b904c02d57fcf54a8cee098ba3c9564e6ad781e16bef7477d8f64d81451dbf6ad4036893852145fb31fde9546d58dc2d6cd5c2833005ab9ed8fce1ee04f29301926c4cb12d55db77b50bf5a64aefeca24af57a43b85504fe07c99cfe2b8af079a408b1a00f16ddcf32a338b3640ae59763a3466176526dd8b8743e3775de708c64630a9562c1f2173ffb0a22d6a37144e3ef72b2b2898c5d5d3a051b4056cb27a4cb87eae1e8a6849a69030f36948a8d7036e4f9aa15e61b3e26f87a0b758ccfb9d148e9658ca768d7193aa12bca233a48f098ebfc955bacb13b8130569012033da586c608f9bd89df64fca947e50c786ae85ce0a3baecf95028fa97988a4064943d32f13921606c6d528c0617610558f972eedc94837c0c062333962a92aa2891abdc38c7e1d7705b1686c66870ffea1a32be4a02037f91a9e9f5554d52184863d876502d8c4d28e0a054402dbd16b9d326397272573a3d028d854511c584d29a40b06faae6fad52b240175cbcbac27dd15ef1f59505686be0339362c6d95a44478c610a6de94164cd44869ef1dd42a35d5fd57e99582058bc5081ca6d1bf5ad370f6cf205e8bddf6754f3a36e520c13bd8f81749060216d2addc401d88ad6d812b2e200db193941f19d10efaa73ccc3404ab53b3cf0b9ca99ffc71c023abae394a30ecd5ab6a5f95b30eab647621c5506734dbf65be25aafb315c3deff1cb26be00e2b24f1d5d2c20520f0fff8ad05271d4f024f8bd36a50c47bc37e3eabd7344e77057f1d47ff33f5d946490cc0c3d06c1954af9a7f52e117aad4effc934cc09acc8b8c9a9b56c47de0be14a4e10cc266502ea89021b8fdf13e625eab65e63d21b4db3d5cf91b2c7944a95b13c018abd971c733fd002298829cabddb8db608fcf62b022575078b500eff0075f9cd325013343ea819c1451e1fe1b88342bd9030f471627c12d0abc9d1cb92587c315b8a47356e07cadc800172c7878d8bbabd8e78b96937e30e4e8d6fb8417b07fd6bf086bb330f5e845086b582bd239b1c1ce3e004cd05e96d792f3e5616b36b107b7ecd1cc2775b9a5756f7472e3f456bb94fc8bdb6e358b75e4e0ffd156f2150296ec268a5e419b57ac161922e73bb0b1c2207b5faf13fcd20bf08652d582e0b85a2c1b6565a35463643da9d67fd05705d389901ead4a68bd7c5bd0e16bf2c088f49fea2dcaa975c93d2e59cc6e1e82e76544de57ca15cd27df225c2d35208653cde14c55cbc92646b3fb9de3e4f52ef1af3bbb7c589a5fae9ea9fae91438998c749dbe25e55408e3ea31166efb8afb1dc46fe9cdb5c8d86c2be7300bf581f371334db39e36649c751648eaa951a363a24506c0577adff652b6bb232920035062a20640cd0f163bdadc5d17f1bc663ece7c36acc3759261859d27d5647a0773cb165e8e811d465c81afe0e3508aa47656aeb1f2f0aea35210b149163e226d05c89d94011cf3ba4a814dfb11a06bbf7bb6a1128ae47fc0e5ae27e8ac1024d7e98bcadfa83aafca3c70ff07c4d11d8e84be764470f01a20b99325f55ba8065df30c8e7dc9872fa2490618fa0596fdeb2313f419ae22885c68bb787d9acabefb2b3e1f473feed295e9ffc618c88813e135ac68a9bba06664a4717678583290e16bb43b6e59fc78fcc715309836a9e241ec9be896cfe52fdd60bd1482893a92f72538b78ecc792bc935bad60215dc919c3c9d1cbcef26716ecf880dabda89c23274f4e50b1a4251631268e2c30fe3c23becef58b1608207888e32b583ec5920cc00208a4e924e4bb839b9dabde6188a9696b579be4e473eaaf453d4803c43ea93ceb403380064db03f53c24cf433a129bb519149fc141e17ed31343bb0fc5fffbae4b54cf5a0e03b2a42c5a1b0dcd12a6a9d0ff979e63eda154147b35b3b858c7ce8ec7a529b133dd11a553299c12e153cd821877e8917532acd50912c2b0767ad9b6ab9098522171815d28b1358eeb965b95b02755b4342ea66896ca3139a73c2578644e374bd0cf7a929c57c7399473b91b3cd357fb470d0c503768ca5fc01e95107ddd095a4036bd30658b233a9aece4b6eaa6795f44ffe6bc69d80f3b1bfae3f28a82a3ea795335ef9d132869520e8da9f812a5153c2e6adbe92e9beefdfd0a1e8c71e4b9ad10eba27c1c381909f3461a966115d15dd29e1eebe6cf4ccf200a47242baf56e42546a18612eb9a173d43579718116656581fb296fda5d01c40bb8ab62bff0d823fe6c6b53ce382b54384bb32b7113751d4c3d69cbafef5cfed4eee0932a49279359303a935e050770166e8e08f7b7178e3e9091f1d101abbb67d24c5872a38b730346abd3f444ec4b9a44695a525b07790d6d6b680b62f8f44da089b42c344b842a3070c9ebf34dc73caf6e9a12eeb7b0b8f5ea87451fbf5507afdc9941c09cb70613b9ae431c76a2d756c4bfaecdc2d81164fe2e2d9b82c978172bb86250069a401c27e5fb714297448a24856539488639bd7520d4ce4a7a4876af1b6656d6dff47c2d43ed8c07dda64ebd17a856e37c9e9257d2e31b21a6fbbbb510cd34872ae452078f4c77065a8cd026652409c7189a5ba618b4ec2dadca7672b0be35f7f206f2cf3e159a75cd32ab6cf74fd620a9b036019a7601f8eec06727b22f5436f94af9e13fa6f586df1ddb922d5aa2c3030dd74410a6d1738092fb89da08e63d032526e6ef293e76ee7fd1078f37535462fd1ea895363ed85f1aff30cf817109430f8ed788bd33736a467f50d8db950ec99543e55e6082a7d49512747f1158dd3de15a589f7f1cb018378b8352a9152e7dd9fd77665d305b8aa27553754fc7fff2aca1270c09459f8555286de00756e2710bfcf550325b9fd65f785722c33875fbaa28860cc7afdc74629b10d51f7453c4d8b5f083198b8c41817a0be782c8c14430ceaf49065a72db3785b524709e321c624a998349de382e8ecb9d2b9c68a4004995735dfe95b41c05f449fc646869844f8858df7b5457eae9a5c6614c77a9a6fab3c05c37d39b1f1ee076dfdd44860106899b57b651def71cc254a731b8bcb5aa73cf008c30666eacd5d7881613b97106ab08aeb92c796d31d740a0fb8c64f88c85ddb1f2b74f86edf861ca47e09f6378776addcca1979e61db5b2b7f3bd529b78d2bcfca4837d99a19b21b96f5a8ed6b879c092c7b33519bcf36fa525d4d4ee30448bbaa55139e3b9d4d7e7bb2d5008f2b9a7deaeb32936cbf588fa030309856d2b82af301f5cd1fb53a8b196e52acf9c6c36682086eec7b613d66aa81078eb8b63e3019bd72e4289ccd6c3133eb22e366f5cd119840b911c9f56c9d200bf06c0437c050410f92bedfaa10158e55a254523cc6144b4ca7d3fd3f7d9327ff4254c2885002239673bcf3215f58f2b7a991e5f77821c8fe747122932bbb6121af2153646b48998b7a8c49d10b5d1cd8d08b76f49814b562b3c341f28f45ba278076115194c0ed5664994d0ea7b1cd111e1f1fc4569312602332099b1646c78324592f713ab3786a07d7ccf007db33a1a311b0777d79d9caa4bfbf98fb02a6c4bb7697dba8d5a8f8698d9697012aae17528f94297fd455c63331cb66f1a617d6a08e6b6d8bd92e36b4f5ce0e6bd311970f25842d6d490b9c73292341cdf5e9b7965c99aa591b5c4db042d2b818aa5803597dfaf4792069f0d388f249ab5d535d23f78f07ec30868f23a00b5f17632b58536709f94f9664d2c31893c47128af7f16a49f39c06bdfab3ce4120e3b992f85fc5a429a5e6605bfc6ec7e01cb9fa0cf44279515436811f032b66428929f61a2f22bb183ef05dce4f89a7d970d6fdd9d3d10274b3756183581b030929bc93ac03acced17a35496f0e9021e8430d6d8ea55dc400e0bd3215293c3d4b9e9a209ff2f2119492ce9f6c2e7f92ff3895e1fd264626bfb3edbb805b43e65a2eccf867bce2a4df648c41e3df45ecf6e39071008e38d3fffc23a2bc3f270dc3353b5ba2067f18a97fe2233732a892a5db6fe9595b2d51b13db64b998855444ef92d91377de48f2ab111c0c78ef1148fb39c96cb007eb2c5a6cdf94bea57fb1890572a9b238b5c18f2f45ab5b1bc077a303f3f7517832f081b4b1ae23fbbb94adccaa7b8cfe0e0dcf56a84d6204d9735015df916fd214ef40d2315b2b76e5c8c92f0c9e6e4e79cf1774363fbf68a1c6202f26557e563a9219dc39fc99d2ed2a1610b0f5264776653245bbd25a1689b04cc4602174b25302b04a6f14a29acb64ac062e4df2143245a8a26cf95a2c00d67a0ef149572214cd7d3b7c011772a9ced0f7197a2e417877682b7435ec01e2096aa90620d16e1342c7f31105196bf144ef7d019a1dfd9f7beb9bcf39273ec1df85c4a26dae317e536458c70578d24eb5e36b3b788854019c22a5aa26286b841b44d31c093a209fdde2381e371e79872c86dcf78d5d8aa26a6e2e8ee958500604b848ef5536c9b65099e216427934bebdbeed3a99492043169ae9a0c58e2d650347e3f2a44f8a17aa8e25638fdccf4366a04139f8b45c24024a748a5bd6c3e7ca0b1d18e1373e03a701f8529ebc0f1abaea3ce4d6dc5b7cdc4123f81bfcb6187b7df7b23b1c356ddee94293f8388925bfba1296e6e4e9a673132116422aba488151e82ee7339f1e2a43d5ebe18cdc4341b2fb215e72a59a65f325a1f33bb303fe609f1a0e2568a801e61bb430e921794a2ac2116522de1a29191af07775cb0acde975c488630cb72f27452f9969547041134d319d213929fcc58bb899a0756d5664fa6051b11d52881643d7b9b79e0404f6821c9b5de42d0377fb34b45a6fc7705c68a18c4f79133773a481d019e339cc38bd6462010899c1559169a4558a1991a75ca6079d988c2362c849c35535b41797ac7991517ef86d3f61a602eee4452466a91a1046487ab14520f1b091d3c840b314c41a796f7800b56f359eb45a80338cf89b12ff71a5abe38fa67ad172e34f58f0aa654070e3fd713b3e478fdb5fa76c31ffddf5a4134f720f7e736c049349f04e506249a3798107f6ed1fc09a476b660c2393c5ed296378f8651afb90cad2eeafc3f78793facb351728303ccf0f94810bb8c36aa8e2899d3a97394a6366a691bfe47c84db28ac2ef3a3988db6102f620e4aa07696bdefcb64882be3a08beb290ad1a3d95e2bcf1dc63353066521f0d19867198d68d85b320e6dbcd57d1865c4fd3ce8bb868b19508c676b84785a254f5a0055e2527837935db208d11a3297904cfcefdfd527ce0b4a2728c7d37c802bdec5b598da80abc8f249209f286aeeb744114fd0b6382a53493775b19595d83cb650ec9f04875845d84226853636ebecf29037fa9efa7e0de8a3b192d97d73695e4808ce7768255d9e7195bc7dd94e7d48b917782ce861a779306250e7f130db9ee2e782eef7554f7a431c932bd455f139ad17eefd3b161f281eaf44d90fbe58c5377e4569c8b308d6d7efe49cdbcdcacee85ac567348a451ad6ed804a09cd09536392664de02df56cd82826d93096334ad40458e74eac090aec078ffc9633328a4e1854176ec68c09bc1c109856c94b8e494ff77c21ba1735519958229066bb49fe88e94dafa2c1b7ea32a836e4d9af42a234fde7fa736a209d954a1e3d50d38edb8cc69ba77e0230189c1de02803d0a7fce79496b1dad4c5b35e99b7bb0832bfd826713e856927fb32e7fb462f3e3c766775d810bd86efa8bbe9cb2ab0f85489fc3044db13c36068a9168b2ec394ecc2e43e1f775d27a37a21425a19283afdb42cbac98a5191d3561159fd5af88eab42c6348d35f57a5933ded8333035bbd20c3efd44faeb2c3661e011950b9398cd843ef2e855a57c93bbc7d33493ccf3cdaa68344e6ceb2eca1e4815b5a135b6aea73d6855dc4bba1e6fe13e290bd75108172554ccda77bc5ae655d95d5410e72dd32cb76d2036027dec967c6d8efb7e2ba3374a184ac44dea2f5ac4d2a04da77dd72c75c8a64095f5f55a84b6c248fb810b0e271383d4245367958258d71d4b67c8b9bde94bebc11fbadaf113c6b39d3a7c70744539c6729647e3d0919f09861369b165d03a7799cfd6ee7d5c9320175f947ccbe1c1543f53d1fdd31b248db49f844c9441d0b5a38bb63d917083339a7a6903c626658ec247055f85bfd5cfeac59c76a9a84eab20a65b9e3fce717d7eefe8515a8e14501f7b3bd5d587f8799ee780dd61935a4bde3eb800b108ab60f4279273e8337209013355eef326cb9fd0f7a276fec79bfa0ad68d28328ad292ab52b78609da97be0ec0b2be0b67a79503e5068263323fe6ba4d4045c49d7a0f1ecf364a379c4853c596202a8dc8f73f19a86614fe3d43b9156ab678dd6a87fd275fd9253c376038a869144c9fc0ad7204ece5605cf64b4fec9a51cbe4582ea94f0b579c59c95f74dd6f6feeeb4b4a6f61935b0a5042185e802ec8c0a360ab7023e6a43a74eca50aea612dd09ab88517f0cd9818e4d0a57175ab8b6bd969aee40f88bfd2d9521c4a098f5005f9451656f6da19d49ba029e5317897967becd8238062bd180abac689c4e8a1320f57077c0fc0b8fcfce8abaed8a88610aec671fe3924f817466b69a1663020e01e9d96c20ec13f0e75035ad8e50ff9f5d7aa930dcb5c63a16a482a1ed7d918ebf42699eae6bd526a9605a233d646b49847bd2e23e6ee8a20053feba4cbeeed296d8a77c95227caabe71d5954ebe823b0537b079406da4e17b4f71d979bb195ecac9e1b2ae2938224af4747c0a2cec07f296e8d69851cf00a88a504e9c8d30efde52c1e0e8f19bb4dcd61b256bb0d234cf7fcca8cb83333300e513b8cbe21357503d521b9d77e578e57b70ed2e55045dbc6be23ecb9ed2d77b1213d42a3e4b7f7ae66c306b119178502e7f9761efd209da36948ea40c09fb53e9aa0d301dc0681282e4ef3d3727adc208bcd37f505f4c0c6d27757fc23e70d31fa5d098c60b05c3faacd6a56f56bd8f31de4395a8ce8d8b6d0ae1a1fe34329eae349494d0735d969fe3662694dc3bccfaccad7a9589f182fd35f3eacb525f4f142ddf1d1633ed4de50ab6661b0569eb80b2242b5dc9a9ac234d66fef41b6d8b44b738ac0203b6b22569fa1233549ea9fed45789284281764da42404e2aad5b9eb76245cca3031c8e8d2944cdc5f896f184089d276f7bf3cd027b396f48d29c65ee32758eb0998d3468b51060f010c1fa250f1fdf2a72aa9a8f46d77dc7dc1827ef8562f4f0852238b370d07f05a9915dfc0b913697625ad0eaff992172ab0dc2b060bdaf332032015e0cc7b9a5d741e491d77ad395ef7494832ea64fc8d8d998b16d5190c292a9efb47e3cd551ff79a5cabcf113a0c651f6153f5c7b876201c1c372ef232173b72120b2170dd640c2913df41b4cfbef1271032be71a04e2a7397f08b63216375715f09cae6e8f87a5585978cbad69e7a3d38bca8f3ee07d2e2b40ad539172fc5c52b3eb3adec20483628d560c210c4bab9323756e4618a77028984d238b8ca687d5c3c04af099a71cc8215f50ab46563f311fd6b493a79fb5fa62907040299c0c1bd31f9032dc80dd3032da09e540573becbf153d989036a0118e28274c676bf8732542a4ac048db5077ba2a583845fe91618b140c9cd7e092ce40e70b66ce64b991a42f6dce724a94c50dec3b2e51e950633cc49ae295ca77bbc7a1f353d5381544f9b8ebe6500c21f37e1d105091b38e60f3be0b394dc1a0ff47c8f5b76387d1335827c7ac4deee57caaaab5703b42f319c19847eee9ddb398b51cc6df2f1b89c5a3e506b463fadae0e89d7bd34178999007cb54f3314c096cc8050c11c697891a100d5fbc70c83394fe2b4d50edb1bf4db870ff99aa7302e292f11c05ef4bffab883d653ad762ec7049ce78de95a585f214c76a9dc5f9baa2d823f4c8f0a14ce272ad08b79d134da1d10f9da9fa7e91cb4ae4f955e7efd2c91b9def3b62985475b229a0fff29a13bbfad49ea02265f4a9e6248df97d16f5112acfcfb1600e06b5be85797ba01a47626fdeda671efdf72023d698674849fe57e5027805bc7cacbed674c37947d73b7484b06d9e2b4dfbcd2949358c0bb6a6df63d85f5ac5019f0fd5694f620f6cc39608b8f496b6e5e81eae8cedc5f21d830f628417d92d9c374a4b7516a84558e92665bdca5ddab91b4995be3fcc164a9e78bbba816cadf0ef59530c93d42c045cca151057e052860746a4d50fa30389ff319422fde8a56c0b418829c83e6f1a7c90a86719f897a456d3c1a7827b7ae8119a929e9ee8037ac346b20c9f9b48754af560d20df8c411ed0d66d13218d26ad1724853b18d526228c24b6f4fa951d09810f5db13008976ccad43279449b8a6bb4203037e12fa422dcef7cbc2f03b41b3806673d7499c902b833f2aece4713adbc78217b596ea77aaa13bfad6f08177732e1b85669d3991a54d89f278bc9635507308d809b31d2881a8265f9ff71ae88d55de4bf2900d9c603c321355cc60af8d9e59b00e3a066cc2b3d2f035e2196c266d6dd2d0386523c593b3dd62cf3ecf3416b91d863f8b3239bc4f870cc1699a067a8bdfc2b7f7fe232921dcd02e4833af9214b58039d2cb92548764a38a27c1d447a400edaa06d55260184bd38877bb152dec38fb3678479127b0691478b45511fbb8d0771c3e649a8c0bc34d7a737fbaebc9dbe23bb757cc3248ec8b89a0954aef5d57f275c3d8942c20e82ec12e41b2b98d6dc5e5bf8fe93c26c7acde9a17213ca8bc23bf2d2c10727ad3fb88c501816190abcb06c0815d0463a5a013a2d1a21f744c1853054d17ee3c91db91de3ceff7becf5809c23410d637b7c688f4477117bafabb37c7ef621bed01c9c0f71e6b9b4c50916b1179cef9e6a3002d9e59b9917465d7847e983a0cfcbd9f804912aa96b4ba813432f4a1729140b2874612f3a989695f651c7af02b5abceb60611662978be9b2f011f3c0bd21399502b3d59c401870cd8e304c5011716cf1aee9a0cceb862ee0aa3645c146b3ef2915355992b7257e51abf1f45ef5fae1dd9f8449e5161908be29df67b51b0ecdc52966f939681f24dc6ad1ba24fcd44281d550338f8c514ab8707b7f29914d8f95b820eae351447915bcf38598e977855c67de6aa2376fce5abea1a5f5b0bba66d88f716fbf2765da3de5469fac815ab577aaecd40a5e29830cac5280d7f2ea4e327ac6710af6b11b4842e6987922444fa5656540cb850929c93e350d39e794571b5506086d3cc33416a2f1fc5be1d4fec21bca2c12b88b9b2b6fc6b4a4416391da1c82cf1cc2e2b6dad01857c20260bc3d9c6c6aac66710fdf08adee996ae1a6c3aea6d9ff51b6ab664fee4c197f9237083acd6bdad97689e8737072bf87ba3951942d0eec5cdf0acf5c62179f3477c00c1d97262dc34a8b400329c8407e6208add5fa643f6caec72d8799ac6176d26255ac4403fba31c2e368a1571be01f0e126dfb78b5cf44ef19d576f76d4a97772497c6de3d8492f6ed4f9c5e28e22510bed5b9eacf85d060686844c7e5015a5bac1e9e9113a73dc9bd1aaa10e31c3809c31f15ef949c52c13e85163ab4d54a12081d9b111aa0a6687825019d3bb3778532dbc3a059d726fe9cfcd2f8674b18b5432b701a92273130e21b1846f5406a9804a0aeb04f8ab097bf65512d7170bffde88d841f4b10f4bd018557209c7cd589f93b358d7181ec17f01f04214b47b5db16d2273a0f97a4c59c969e92da9aea4fef62045ba9142b616602384d04d651973757adfe23306af775b61b721c39aab44ff8742aaded82f4d5bad06bee05f7fa18c1df7e335e70c20546384b00536a2264eca8109ed794bc29b6d9875153d82af35a0c9150ecea7ae487f98cef116dddf913292246a8055306bcd5c6bfe15223f4a1b6ff070ac6056790d75bcd78aa895030e888d5283b281d62f6cdffb6bd6cb04d6e3f925cc1821ee85b1923f0c6a00f2c2d6085daf98232c62752360ca6be5ac4332481b91d911728ff507ba7f19ac046aab7c4b0e9d6f3eeddb86e8579cad1ee8759395a33e09b1e8d8650bfd27229e02c87719bfbfea6553a109debe06f35896905f19a694ab937e1f1342422dac056437da2ed44d56456eae682de9aff5f6648b819978477f7588877b67b5a7eca542a2c4e56742723513b2f54052d2dd089fbb0d7dadb2ec71ca7c65091742d276b7a29e7b4164d6a5ab5a6b11f9b22c7fb1916e3c53f0bbc013a472a2652f7a40740106c172894560954d0c65c4b1a8638bffa2cbcff63391193ea9a312c9ed9896408ac3c56c2f3955360bfc92ba2412c91a39aa9d91ed918615e559004f9cd1d0f20f6ac2ecccd1a8e46af014f8442f7db9357823210f07edfc1d42593c55c986e8e5313aca17eae939eef43ab790023841a23816ce654e9b9b2e8fbda4971a0de00d00a9a89633d99fb59c95707654c6e4707019b3a6c0a48e700625546a5e69162ee6579359eabb1f1eb4a7b5166cd5931e53cf6df1ae9bbf9bc33e6389030876d4f75c9f4c3278d3c014b934460d091c2777f5bf167ddb08b92133c1f3f772060fd5e069f4de52252006d1c811e516a5b9748e0700321a78eac34da8b11f4a1ef3d392f271e055adf03b6145322e09f4e9598c155793ddb0446c849b93e90ab37c9abae57e1fa117f118296701adaf5b7fd3fd32746e3bfbc04f0543972fde75ba2955ab740bf5d23710d53d6be060cca1bad8e7480a09305f383ef86b04a17c0b8ff15c0b988c981e6db1dfe41f94cb8b4055d73a66383f550f94d9f04b3628bdcea7b5ceaf7aa9ff956546366e5d5193f8c52c95bca211fdccb6fed87b30463e2387c6d71b0ba11ee82582d1eacddd5da4bcd7532246dfd5fe2bdffc60d3596e62b62e2dc55e32681f8cabc87e55cd8d3e7aa0134829c4fe255783d0228397d0c56b6cd34eb506c51b63dabc1ade00f87af3cfbccfa60b5392bdecf8d4e6553e2219d12fc9a338c93c8d60684a937940614cbd539e54d603b40c603d271688e220df88e7cc65057ae4eac12d9e791c5cfa030af698f8136cfe12722b0fac47ac7858a8b0ffc1ca6784fb47e7c5fc15bfd55f14665ccbba8b1e1cf0aeaad9446d0329328f8efbd992762df4f72ce836c1ef5611191a3d90584106909a65f660f55f9fcf502f66b0310f76144fc29d6f6b502b0719fa033efb1d49a77b03a792d0984c43acd2b1893b0a3c2ffc9b22302b9e92e24d5126c62b0bf21ae0dc3d0cf64c1405b2407ea74df22ab32a1dcf4a19b4e1b81c13318350649796d1f34f96af73b8a57e96a203afa31a611e5cc9e4a5932e8d78e80964e0b4b071e9e96289446a45f05e53fc6b7f2a77b1b50c43a0ef0197b81fca2da81075407074de4a15c9d04e473283e54bd74d6b1276256e901decf042017abde6a31c8711d4d8b6b35207e67fbf1fd17119f678c8b5325051f70b95af174f5cc103b5973d16082daa35a990ecb83147635195c1ae354ee6f80438fbefdc38ca97e8159f08ec3628a6c569411b5e026c191ee1221ec632eb1d2a4930dfd3b60d6d5c8aaf22b9bdf40431ab5e8ab007a5df16756e81e06aac02e3d9bad177017b8edd1fb0581288301aeb206b1952aea367ccb3fe6c68627b9923efb9a10bae1990062879710db3df322ca881d706293ddaed29c620460cf41adc54039c54ad3e6eaef1a38bb4e6fdfc6aedd994121a664e3bc37eaf90ab2762bc17bc628adacb03b74cfad221a4359627c1ef6fa5490133cc62358a27e1225ef3c7dbefac630435fc5cde0a43ec42a0a2f8c848d8bdcc1832ebc3296a4f0c061ce0647ba114f4fee910465c9825adcba95794e82f9151c230a8a99dc2750fc9a705dc8f7096b606f69fe6ce39d95eeb4d3b84dd43f8bb2df7c1084b63e29da6fa1446bc4ccedd31555e6d2c7bec723eee8b40182009886d08a570c86844d2c103d02e5ccdf466a24a5415599931faaf88c7bf485840685ab76561430b4bcb6de46796f49cbdcc29bd54451fd6621efb94cb9f14568fb021f972604a1da0f02c6f628a7178bd3a1afab56442e8cb9e5dc615c8f3270919670555385e4647578ed459e4cb566fdefa60c8c852fe8cc45167c0d9d535af2817133766ae9328351171d5637d47389694a56f63fbf18c603ca2d619c5703f1b97553e169f5468384042aadf53c23ea7582603f611c3bd8b4f0ca9d53d6e77f879cc134e8891f74906608d4c09ccdc806190f8940af5b62f25961db15ad08180ce48f15ea303469e1d9c317f6030826121ccd71b17b5e86a6300ff9583ada13a2518ab9cc9d0a4b0ac1dd89202d90eb3d30231a4955f038197b21ae67f550f8cf7080f0c60d2217cd96b1ee6facf9f448260d8ddaad8867fd55ba4e967177616a140f7d596bee1192756364ccdb941a432cfa7bdd455590236c237eb13bc4274b652e8e01a74dc751440e6b5f57b495efcc758406f60530243ac10b131b6c5b4ed32ff1e081aac090ddccdadf26fd8740a047139d0f9690ca6e29d76ee7fd7446b9e255c1721ba317c5c6343ab1fd7c089adb9324233061e300c7f4863e0c6360c1a99fd8756d32d7d30dc3b1fe884dfba1b45d71be3dad83bc961c4ca7925e7ace0cb85d7c280f5bda5c8cec2e3e498f6a4ba27a1c4ac3165762b861ef964c2c43c385368f33cd668960d4a77527d212b435c8542b264f93f648b1608e7f886895cc25f56aa5ce59095a59ddbb773af2674f869467c05cd506a002e76f783074bd07d78d8360b6df3f350a5b738b16bec726aa12e3d1624d0687a1c68da423d3abaeb45fe20312640d3b231c61f8847c07a711873e37626d7cae33ecb4556c2a38a0984987c4c9be6ced2d08e7f605d9a70c29d3bfe6b16e8a24c169d12a00d122de787c27610d13d3038aea61edb9813e4568c9f3e38ef9be26ed19959de17784c7f1acb769a3002f742416dc2f0cd002064876221db0b93c296b6fbca897ccddd70eca63884186e0bcda2d4f027f49116b024a37ef42e460e19b60f5f36b9995840fc0f071ee2de390991dba2a98e0b78bf074bbf933fcf03c32d95c072d336f1304a25a07d36e983dcda09d9a0c118b813f5e94c01450ab941979e037afe099c73f03fec6fd87935f672af8261deb1944a2ea5ef902fa12279d0a83126d955c0b3820e9afe05b5407bc1129e8985d497802a6c752b20751d63ccc935f073a092cbaf9fa379d5180b04ab443179c636b8bf79c70546a8087f212e5cb96d715d4315a72e286ace0143567e485dae9640c6f15ecb0ccf8bf2cce445bd8c9f9899e70324fec022ef1c20b020e6ffe8ebd55b90c43aec5264cb9683bdceab8a2e87ee0097d61781c66aef4a51060c4bf53c8a318733525dc723fed6b672453d853754e3036b73aed6fec718fc74dbc0cde1d249a13e096dfa65c14e70eb83797f23902f89a3ecfd0d8fc54aa791b144e0eee261f1cc43557f1af3a76a714827585d8f86c890b67748262a4fed6b048","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
