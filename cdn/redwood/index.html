<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5bb068b72b887c55b2c96547c7b430922cc1af0a091f6a56801b7b0f9349d8cff0982613085e63176bd719a0f6ac7143cea88c91ca25170587d292c0185f1a91b370b61a0caeeffced794f220908dbb47dc1f2fb75cfe96765bd6cf456eed65a9ded1c89864b3ff419d48380e4bcf33887ef3825023cef954a78864668fd931d512614a945141d184d86a49f817be019182e618f193c0758b11a56f28f463425507569d0f82d2b0c575956a075c9e2e378e8f4a687851c49697d14340618877ade2cbd9e0d57bdf34d39cecc536a78433631f8061d7c70bb7e1bc4265a62e036638ce1de4ca4b0abe1d6855abbcb16930840ea6eaef583287bae17bd60f4548439413e369a5a332054483cbe3ea351f4543c66f7abefe2ff244dfdcc74cf26d0b5a322803674da651987899c8896b5ba8185ca637d341c136b9ef33fa3d7c30a274c0068272eaceb3964de28ad532bdfe8c17d41fc94fd92094da8ac21afbdcc88111ed7687d7c934e19c5cdabae9316bd1546a8decfe40b3e715afa48fcf9ef9026a946f8ebf056b69955fe0ca7c98416037ef832246bb58a6408d55dea99d46c3eac2fae8629704ae6cca5bcc458b10566607c14999edc2e9b39c163d564481520f85d6ca790b659ee084384330d1aa43fb14918c96a67d13c561545416f5648ece6ac452e8749a515782d878de7c7c710bcf069495588f46994e92690ea92587b9329a3c794b7b6864ac7f0cf511bb6b7c51dcc8b7185d808f87bb47e46230aab4c82ac2018497aa8aebeb31bd8db65c5622e32ac378218011b9bb014773d1b63718406e00088028bc6b02ec787c4bdd96f5f4dbcc0aabf7b6c91d3dfab4f0286c4856faa1b7682918deab898988ef338519d0f08d969da7405c3c5ebdfe25790f34146516f2f5d19e40c1e4ef988d72fdb26477549113a599e518bb50edbd7dd37d550435a595d219501d94a3a15e02eadc0a45b7985ca9b9a2a538d3cd61c5bdbf0aeb2ff1e5508e90cc00f2bbfa92fe1d8c268efccc7bbb8b1c2141d11654c4979721f097e633e601e8e507f167cfd2aa764fd0373905efcc57b03e070bd90880700bfbe615f53d83559955ad6d4c357446ea09704211d9272c34592ac1316c08d9442ed49c9a7ceb60c81da94773cefc1d4cae15f1e119d7dae659909d7fc55759a5dd4421f58705e5914f8fe5aaac932ec8e5e56a7dc0b31085249449e591ac70295e120094db9d9d476a2e954025ac17802abfbf0b664df720ce15f5a75afa7c21e51d7234b00b85030b67aa7adaf661f9cd5e764e3402c73312cb4fb97718311953673d40d3fb973a570c048e7c1b4775ec0a6cf8dfa88e9ace9475c35d23ad5e79e3c66cb3ee45f7977ff266dc8e9035bd0161369756084933954640a4936f706921feecb0fe6aab4cd6033e4193d8f1b3c2dffc3e2ca519d240905f8cd3dac78a0941dab1a5ee0449e285efd990498bf794fc4c18aafb2a4f17e4fed7ae92cb3e10e523d36795533d5baf29389481888ec7ede305b1598538e1fbcf3dde264a6abc701815da3dbbc18ad30a7d185c4341649b714ef57a302c6c8b946681c5402d9d2ed0cfddb790df8c0aa0b52317f9c99cc0c4f484032ed0cee7e494e539e8fd57c014e2d652a217fa1a80c9afa9ebf27b78031d14c8aea5d4a9dea3eef2642d894679054acec6cc2d858da43d3307e3fff14da01117c20f20d918ecc685e6eb1a85e93373d25f613817f7714d11e10a5b9a9b42357db6be1163a5f2b8a3d1ba25439f7221fc164b1cb7c4d27c8d2791e30c095721944fa66b4a31b91476ebda503f53ed9e8d90799b32d20b8e38ff40be3eefc73ef7785c17114f2024ce9ec04be69e8e09d96e951f3131f36ee5ef7d40cc73b9b6da9586665bab2abb8919934396b44ffc8278f8959edd1f9d63ec5c6f92461d443ce67d7b26bc0b007aae114276f27cadd37809bfd23a723b762e31b03295d12ed66f877cb761de192aeb49a6228e75c23a07f40052d76f8c0329cda86acbfb62ba6a6f655bf2967c3ebe1524e53b479774dea24c0f289abff3f55b916880b56a160582659b658986f6344463dc0af322c4222f96fa259712c4f24cbd23db88b83a0b9c619602257b9cbf7b4b1b753ee8013d69c2e3439deb3419e6b76ff3fd9ae00864ea52aaa7cd8bc034ed3ba1741ca63e3c906dcdb61127d0f06d2f94229b30e2c804b8e414e66307a9c7325acfa1d1aa76993418e6d16bd09b408d64818ddec27bff0b7c6464e94f1ba9fc22f6384c6ab7f4b0851052e745b7c7dd988a5848e15a21099afeb72d88fedd905d149d9217b18a57ecd7a068505f977ba7201b952524268d126ad96056f5a2d953a897351e58f3276b30ffff73e79123df2e6099848823dd8d687d8b494aff7499fe1c418180eb5e838959a8a633f5a6f71688b081904aa18a474c6f9bf0b604e6c370c6452756172be038bfd1d025b1623e642e56265bb6e2347ae0a7e89009ded8d49af92cfe54afa84dca96ace9a3c67159240add29f73f006317bc2279d42eadd90c57eb6d38c54c6ff87fadefe7eee7562a53547976037aeb9864d4f8b4ad8f70c5eefc7f6806130f6bff8683f2c51901ac57d2b2523bbc64e32917c618927488f1a946b438d689fed75449181c7ec05f1ad8fd4e1f928ef6f0e94b92bf902fb7a504c17d658dffbf9a73c6fd998bb099af42e27b14a6409d4d96b684097321104bda803753669e7f92d5242637ec672a1e285e1d84d80ea56bb8af5a8f43d11ff55dca0dd689f35cefa9ecb2c5f444c133b5a48f7ea9fea1def099b7777dad3618fd5800d1836b856f1692969c764143ef7dc1c8bb4a28d8f507ea8df80d0b1b4a957784e3bb92d9df2f1481e5de5f76f3c828f0b59414ea7876a009b56657aaaf47895bc6f7a0f6f678f630e4f46358e80ef5974b8c6392fedb4ee1b15edb8feaa4a47a4194dec7b53feecd8b6ec3bded995e6dff180e20262d14e1d5e72ba5b908c1eb899b1af6d3b244b481ef4fdcd9f47ac7df42a5e2eb7f6b529741311f38930bab2b457c63ecc59ed158f0a54274ed9ea1369b0e0ef5c1ae8756b4617981aa1b7e07e4eaeda29b5c2fbce3bf9532bacce05354bdad9a99e6f1af0fb70c1bfc6ac84b889713bab069f41be81e6d18da339eeaceb0c9c5638aab87e89cd2367b9c140f6e9a0d589c4ade98789845d447518ab9e6cd38d2fadf4ce954bb696c99528c1fc76f15e5dbd422285a759e89f32d7c3a5b1597c6465427e7cdf219fd2f4d4c5826e903aa608ca2a6e5f9b076c03791a6b053db95495e35adb3d4716ad44c9491925e9accf9212d1f20ca1de3db6511ed310d6aac88cbc71c4308f73bc31862dff0881e07784e03795785fd1bd1fd18e744b2eaddc7b553e05de7e31e4b069d51b6aa56a65932f2da24a550ee4cf2d65ffa608907c06e8160014008bbb48f56d2df2f98f684be48fa002c34456cad56a63f912d5a9e9c2e526e16793e769d37f618adac3d911a18ade418fc15acd70689551ec0c0265a1f428f37c8880de87009a42ab6c1fa98bb8835829b33ca9983232e403251dffb2c4d11ac9ef5cc8f8ef05138381ed595dd19673d063bfb4829619a3c720988fff95a964961e5fc57ae11164f0211064c99534dfe5d0569d75c809575d523498d87a682c69d5de798ca71770e26beabf7ac7a3982c1a197ce88faa5cc7c7175b56331611ffcd995942cdc3ccd1f091dd3c8b6868b7762cd0876d21011d681a3c7411b34bf809267d16932ab90ea76b018abc8f1a2dedd05f0c00a7f3e39cd8979ab812335eeae52f1768a1ed509cce7f2f09791940c1149e390bcfecb7d5e0fa55078e0a977f9f747cfd90be2047ead056590ae1e8d57eed3ebececca4067616b7327a3c028d659cfbc2d047318af420ab3cb5efbeb9578a7038b6543eef4bfabc270a9c3e5e888fa911cd3cf62d15f24c51d41c5f29ce45bab7165af7e90565bdf762c00daa11461834b5a75a3337ae8a64e8619b116a3afa65f5a1514656b9321f532a64e055682b342754c752b43e94b41b874f0cb51d2cc46fb6da7a3a4666c329219d8c4f296f775e1a8d63bbfa54b101ca013ab5ff7b0e28e229bd84900e0f9f8bdc832c941dc72b1eb646800560297a068f9ef4875a3aeabbb09a89a386eb8e81bb3623ca453d4e2eeb04fae5a7eacaef1af676c5ebcfe701e2eda992f1ac013dd773eab35bd3ec13f8e196d8b78fabfff7f9b51c5fe1c23390b631368cc74b9b2b6c4d06109efab42190254ad7dabca0a4370a6d94de2c55cbc1eaba3d556f0924b68f418be9c554acdd059471087e4e7f2a89e2ce5fb411ee8b5f9ab43f4ba6e7e27f86af2af4b93b6ddb73010cad8edc7d56681288551e08db0fdcd90953986e3fb3b06f9237bb4918ce0c6b421a3586c26beff74e23f6dd3ccfdd4af6ee668a4dd91359facc838549ad264d48e4b4a7462ef18b897cb3a6258b1227fdc1b366c5ae4bdf10afeb2ebb0e7929c6fd9b7150423f6e0febd63aae710fdf113db9c5e511d11a71d5bfa10bd2bbeb8267f33b3612f67bffcb34017f5fffefc372b5b7452590deb306243b426c2d412350f191e2bd32912495680eb56635c1fa60d76164d4dc5816a0f1d3f733dcca05873d432eade4172b761cfacd81814b0d2a8a27abf93e4d481e9adf6d15365dd30e076dd269e20719b91a94df3a401a3d2d3d638e19ee776d1a4b5c29accf4c392edb38f632cfbb571bd2fdc958a7fa106e79131f7bb56e5356c91912ae170a521aae5ffe95b300851f71f46b41a9affa205cc9219937c4e25e30cc819f086ed04066056f07d947962da2ec44402fffd126402010a4ad84b717eda3033abe529966dd11e0d354ff11cd6671d78c4a9b2e2417aaff63b1c304e36a4c6b74c97f7a9e917399375c86b6c7918a56468ad0d224f67daa9a8f1234741f218eb31d057ad06d4383da866dae7f0a8b8298511b5b771c0fe7aa0e122d1fec8230aad85747fe6b4452bb15bde82191b5fd1fabf69c579151de4f0a0629c4cebe3d648d5ae42c9b2f52abbcc7808d6f5b5005720c5deb5ece7a13ea0c4499c0c8d74fddc4b34c0cc33f6dd82ea1f9f76b3758abc8f50ac66a4db13f473cc535e00079d43a57d2ad56d139245eec58cf7049de07d0bd0f54dfccbdd7dab4e0296fd10b2cd0a95596532aa8fe2f860bd153446d0c9d69750b968c5b5ef00e1446257a4a7f27d6a0694a58a3622c8ac95e2a76a6eb31792bce8cf8f13c9d1f4a2252ba54576f666849f1c72f5e0a869ed89a0c1e76b03fdfd9a4ab332e8e0acb003c221849cad29ee675217c4b092469cfd69666a7ed421983b820871b7bcec5cae0add9dfcfe33d8f79f04f59431ce7367c895636d8dd93c96e4ffbed3611c8a4b932e565ad53794d2e16d9078b5571f9c485f3c2d3a6c2470d32028d2b863960403d8ef7407d89dfa594345fd63c3028f6ccd392196e207dd18ce47b31a1ed76a8347de630b080001e4cd5c638c9523639fdd56747f9959d4bf7e922ea00be86b7609aa5684f2027f09be2b2229f8148c91c876cd3824a9ea41d2aa9ca4ad84f2601053148449d54b0224d4684c5259ff9bc916e060d103df2f0aa0024a8337197e59db6aececfbea4b0241fef7e7a9ccae9ba49bd4a78812625fbb3c8b9c35b7f6fa67e637359dc6c99dbda74f8d57b0c29b0f7975b41caa85bc70043e05cf93612ae673fd69696b5615cffab90f9d7d17d4fc8c51a859f09a64f0b003a086a4bf41945bd85a8d757cc60286e8ec71f0a83511498eeaddd078065757f739599ebf44966fc464a50480ead956e5a43875632654521c73bd0d85cf89910111eec5b2d17cb66a09abd4c5eb91901615fb4f91bfdf46f4d2112a02b2c9360a9d830d5040ea88562f3af2e2ba9bb2705835507dcc79eeaa56a46b13dc614726cb7a8598435a48d614370243a1c4da80e88ccac660408d2c01ff8b264bc19c25bb83f0c2ca5ffd529661c732db4f4632a3531c6417e3a322f60efd2bcfe9391cc3adf1f6513456258446c901ad59119b80845da66479580de9d4944c39a8ecf27d682cb697991f4bbdffb1cde1f95330812e2a870b58a2184d6e50bd3bfdae061245c34acf31ccaad99f96ccac8363f5bae7980074b431ddfd82e95cf80b641460b21842753e7a9cbb4fe8724959c1cd8ec123e8ba0173c75c7d2576290db6fb4f53abad6a4fd11c7ea50ff1ee658d163688d99a5c758b0679a028c4cd8ad51f76718d1e4561bd6527c4916d66d8588dc6317a01460ff080126e71bf7d6e9d27c3fbf15768e49763a0ec1153c0dca529dfce62638274346453ecc9e12f38715330537e5d94f06736ee61fb439a68591adcfae139dfbec65d5523a673a06e154ecaff2816884357d72d1e56f2084d3c6a34cecb0ae075cc8b971eabfb277ef2805c03bb399a308ed839b56c83630a73fe1fb7631e47a21476954e453885ae8fc4c8d9fe07ecd118f986d6e7cc8ac8295a185c050bdf5901f4be64c154e2fe4757a14a57d1252b6871176042190b0465c5a01bb1312a4aa3e35bc3d508a8c097a7ee6ed421b562043e667deedccdf7450a41718fae326f9667f60d6563ff89fac86e4dd64526c1c9798a70ed0911139955af7a38827528e1018ef8388d2ae9c94a16778f57f94666315f406caa50c6cab8a1e1f4e5fdf6d857594f11d6644774128cc772899c37c6239b586a3873cc87ca9c2ac358ee3db157e4f4d10c4b9278e84b4dada91efc168a1de39c6ac337bdadcfbcfec64901b5b51f3dce66f7835dab790481ad416e3b347897489dba23e0ad11d1d3123b0b77f359f06114636ceaee35e72ac3d77611d31e9e645043be7968f44803bfa14f8f51cd403f2cdfe50ed853290162f2b29260e365299d18c7264db75c0478db8d45997910292f4ea39409459695c5edb9efa3f4e7a2ad866ccfe608c8c2b9580f1bbd577e38513c073a25103d5d2d6962c0e62781719e8a6d2f2493a1edfd547b8a27d3bee8a5218469eb7b14c92c1eb50f491a7e7e28305b2881e60803d6d1d30c07c5f77d5671a89f71420320d19c441735b40f376776f00fb696c94628dfa0aa2007bc96060d9b5fc3d3ed10a0db43ac5f295e746543504faed1b1701ff646f7133db1084c5169c46f5618921a8905f929a726143190d4aafcec389bb6ade27eb235e823c5eaf35f4f31981226e6335261a9bcd38c60f869b0620e3d33a813ad59dac564de4c89938e0c57a4c807ef5e72616b2d35c016e12c21090714b416673a204eacca7635f5b0dee6e100ef6f6cdada1aa6c4f5b8b07417d42e016e56c65e2729ddfb6638095ac63b79bee3c40c8198713e9bda8eb2b698de599086af555a88e065539b43cc05cd14a91962a1fb14d3b9d6c77c88830a51ad99f69e016f475b07947ce9f745cd91cd725416447540bdd6c3444ea6dbd89cdd6ab88316069fa0c8164b7275500f0250fa9ea1a900e96ae5a7273ad4bbe43d764e47e99d67c64759618946c0d3c390487014490a12977d1aaf95c2124ba2a0fd3f9c6b5fb11354787f04aa7583b37bb5a134198d6d3f0acf1b8a7387312f6fe599262e90d16e3917098c84cdd6d9415ef4bc2845342586c2ebb80abcac8687c049ffb60fd49eb3a44de261650b0781b141750e24d74548dcd05d729d1a59fc18ca4a4b2a751440bafbed7ef4089e6525008f8f0d71e6c9e5a6c7ab0c83814cfdc8a13898e9550b29246fc217fc1b2982757fb1ce0fa0293418a0709cd1afea33dfbd1f6f6d4136ccd725cc3018a114cfcd55ce1e94d565b34ce14b3f181d0479f9d926fe5ad591a0e5eb510f3257aa778a7086a3ae8f662e32b8a4c102646d4daba12cd8203d516935a7a735c5e52af40416b5eb7f3691c2c572bbca5272df91674b306ebe7622b984cb713561e7946c2014d0b2b9165f1b5663e845c0b85e6862fcbca60f1b4da3cba8194ea65fdb4d90ca7542c7f117ee4a60cb7d12065c825ac7b05452ae5746d69f321c55f4d5b458ef53d6d79070bff7686fd699fcb806fb9eb021ad3b44e03814512b5da55020c756c2a35a56a16b2cd8a2acf7d84e38bfb0aa18bfbb40155bfc0e67abc8670a677549246c4b2653234899918179f430fe45939e25061c8f527dd61680110c29a1c4931b068b70bf81754037b6ad90708ec5b74fbb696b9682601073d5d345fabb9a2b04c8a758ca0e026be36ca5a7a144aa57d02c7d0e349d72b23fd0650d4c243428257f4ee4f084dc4a1a750c62597dc820f654a98646732916ee54ff14cc6d4a94b36f810cf53f795740a3ced8087cc8e61fa12baf41cf4e192d3acfd8d97a849cba81b2b627b037537c28f74a9a7c8e1052a94860ba68a16b7af795bb1a2ee988cb22a2f985d86e8d0929d6234270eeff4d8b27963990b7a62d3b26d30a4600ccfcc00adcc52b6ff7e34d8ec05bb5b518721e3e0966e3f3f7bc281ce91457faa6218fa426973d26fa5eab11a30354526b81ad43b3dcbe1645ec778121979f2d474a76dbc43018ce0a0af4e9c70f9d89feb35c2512294a83e76362e3e87a3fa57ef975431d110f66cfe01ef627f81be3105009e38bbbedb0518135a82a4a27692d7fc5e0f7213c43b2a69c403e1ff3d4705d1816527ac50473e4aac9c7a3e91d09492f613b63b81a3f10a3fac779746f8083773bfd4b1a6527fe21f51a0c417e0d44216cb074da9b1342652e2e9c513adae6c3ef36679a3b3262e65d39321867d4b1024d527288c11e6eb6282228e38a6c78d45da7de7b52ebe01789cec3c263d23a6b4ed21c80191db8b3d87e44c82adbcbe2e4dbc877b548a67a1b87a76d0ae4cf12f1b06242190d0aa9baeddb8173af446ac669ec6b7802733114bc865a0ed2bb68e7b77aba37754c20c74d989208108d2f77f4670b14d98865d4f13b609c9ec028518b75e4be76aa86ef4aea94c564963a71403dca94930177337de6263474444a917beb9264b3665a93db334911348828b2ea2622a01709805f036f153c59155a1998429bf5e0a4a498ef4909703e436f9be40251549d1da59271e100ae404381b36b1449b43d781136cac52a1c6c4d1910631289ad81c2718f20fc4fc03f33aebcc665d960a9203b66b1a20c0e215950cbd8f6dd5af3f834c1e08d54cf9fb031eb531bdccd39e1c1b17a1cec6e70df5af2b61310888cf4ab7160f463b896cab8b81f53d914bc04964b44fa5a5e0c66e80b643ead789739ee48a4d935930908104829de978cc32d632102f5c2f9f9c6ae0ab721e18959f8d7f01fd69ec0390bf4eabd1617640bfbd1c5079b3feb6199fb0871038f06480d8e8628f0e8c7763eca12f764c4d06a0c0c295a7380067921875eb240dec5ffc97b57a0cc7b5d39ec863ad97f4830dfebf3dec7020911dd603204ccb08ca45850465247c533e04d9f136adff30ac6ef3c117fb4ab1e6dc6fc2235cea59559ee3b0a51cb693aed7bceb808521bfead57c343df535a7f916cfceb9aa8a925bb3905ccae849f763203dfbe23c83fc2deba145f1226db01d1d38d9645221729b8dae51750dcc19bdd22969a926f9ba81ab9966d449d530c5ea44e5d067ca4958e9b51000456bace7766c625a9406e94426ac55d2afb1be92df33e54af3de7be381b47e874acbf29b8ffd83314d35183cbd1dd2d37c6c0effa1052ad5982fc48021be4a7e52b1376730054ed4d8ef891b7183c1c34c80b86090a8f848ed9900f137653ce0915447ad4b0832d96fe709741a741fd3664c4f31193605b42277f5ce46b86efb2ead8acb85689c6ed7707d72fae6725bed7650a9af78d5d5f2f931f4e30cffd73447645d34dbd4150578520baea942d1d50a6a9684050b33bf8003915bc58a8b00cfde2792366a26fbeae8b65d637fce6ebbc065571c52f3d45f6397b25041bcf34319b642d9a6ceea2c96c1b4a29ad3017c17162989172d1b70882f7103629cd0bf19e1e20a89ff03ef22fd44aae8c0f5a56fceebfebaedc90c27e57add0e4ee097016460808a63b20a58b91874b9af0369c9f2bdd02a0067447811037a925b1b26376c7efd05bc9417aad87cc87e2fc0d980fa40e50ae985ed6f22002c5df487823fdae3ea2e427c09ba73aede3c2eeffaa71d2be2fbf48904a673540a99ed8e009bc0496eb904efacedd3a7bdc96f3f59dd46b693e8012ce8266d58c483f618b382c8bf7ae2fe39973c22ef06f573844c75f6e7c9d9f4c2c4aeae05bc303d87e8ac59b06207b8abb3556b843a1ec447f3addf46587093ada870023bea1243d961fe2733422941df2de0c5d1cadea077018bfc1a2d392c466ef789fb44887f6ad40c44d54d99093aeb8d4a3f50b40b6edb2f84f12dbf937047bfbe503d0c38eb9e3813b6a0e142eee8cb95ba2fe5122cb148e801379f266f68ccc32e6424ae090f8c8d06a10e28be9648e415c3db6fba1ee6deb01e3c641f2eae31a5a8d498495c44138360818e7255f6c65eb33bd83a540bd899d00d18083c2a5deec6c4fd1a166c824f21d3ac29639f0160a9acd8cda0a1a5ce62b1e56f8152901ed4c4fbe6de56f29490b6c935b71071365191465508b6b09c34a0923159f523da86befc79543d839f492614eb04d4d72baeb1e72e71206bbe6b8d3c25af358ee44256902162137e7ccca7009f4878909906f3eea4064767bc5b10394b20e718744a576f56dab79a8f09b97f91422585dba4a8aac67d4134ff3018d68bb9d4a7a8dceeade46e047bb5157440cfbe6540ca427573f8ea029498ec935b479de51c8facc0cc0f57171a4b11d67db5b93e311ac5f48b424cc92c71ec61706f8be4ed1d9906883a508f823a5299792b882c907be6f0e939abd4e52e2a1e27ac073422289f18c6a09883db0d4f616349c8f14ec979b978e504cd9ba30921f53bc8fcb04623f326d48504d9839e52e83c3098a9df97da53da2c016dfcbe02c8313a74651c87e9cf223f9882deec8aab2eb136ab709c44b87dc6446b2df90c096ca821306f3fe50ace2881cf8aaad0820b1ea481dc7085c88a9fc6755fbe8d5c3ec39bd201c286732b5273df83963cfd29b3b92315f6bf5adf6dac021c92ab56500474598b042c551f51342865be803e724acdde90868f1047fa74ea56b9e6e8cfe859dc7589d30964daa4241655f5e5e355097cbb848a756ee36bddcf25157f81b66a76e36c7cb9cc67009a306032ce06fc3cb1a9750389bc5b0d55929c99723bdec2537054e9e1380b150d9acb2c5318a612e64058c15369d0b98c00fab24bd4b5a9b81447633f1b9168bce824474a99cf05b5be928c852ee5e02fdd70054309e5565932995874468b557691b9f403b7a3d3b3df1fa02d048f8fbc738741f23576d5ab8305d0e07c9e7e931bc370903e000126352489d122d9b7218d530be08623f0dff6f2b184a2bf63bbbb21ac630ac557dba74e545f39aec5c59b167cdf758a7f8a97b251222e6e954a72e6df4e67f104c355f515fea0fc5a7dd378a63c7a3b2e54b94ee2a38e11ebf851dec6d4fe9c1c85fd9d0a7e96f90bf490109b575b00a7151a9872028f52140991eb89f493afda7e48fc99980044dbe02dbca7ea378418e3bc4b84d3820abcdcff3085369640999200e0f427d3df6b7eb36b9eec718ff7aea63c6c6eaa7af2f4a287c5da639a03a7409e51f26dfd62a68c8b30a1baa1102b0ed8112362d6fa1b6028db6d95ff0ee5869ecf3d62a536453a2304f06fef9db5f5c3feb8716e4ad92de024aac306999066f719dfdaa922ffa18e696b4f30146124e8e04e44531c759b13b1f06faf9aa161f4f9e9aa8f641d8ff9183e4253ff68c6b3d746acb0feefcd9c708a5f3b823070355eb0de6f3108c341b273d3ca0b49f78c54a8af44ef45f7d4cad556a705e3a9a8541b6b8e67e7d888a8d367419bc4e74150b378bfe04a41e7b35de22a0932705b08ecc01bf3fe5932c2e681b0237c515984bc4da184c13cf8fb340545aadff706ee323f55488aeb1a4c5c2091f73a5495e69884733435031466983b57ff58f78651a7936d6cc25bd5f1a0789f9acb01696500f0578d4e37283ef1a4009beed5445149b76d3db5aac7862ca54e189b38064ef2081c855afaa5aaa67e684ab89288048a9ffaa8656e78773623e05ba3458a6c7fd93f00d249ad3f2d2f286fad0f90c157db864abeb015faa2c0bc209a361916806336eeff80e57cadc1fd663464e39f08558c4ca967a0cb7a42c57e8a9c55732cb1fd1969b6e57474b64293495ebb5da51b2e285b7071dea3195824bddc730033a9bf6db51dd5436f4c02e55980c4df6a394f5f28cfed3fc6a6ff3270befd9985667981a41d058d815f9f6c75bb9dabd0aebfaf859ce6cca5d52de206f4da5441fc2639ea00845fba590f46f66b79fbd5771aa29e26ec1b5309e667296ef0725d7a6f7c7944a36e8d7f401003d9e6e508fb2c1fc84db49840e54319c93e452b26077e50a5eb1765e014c3924463f98fbd95b46a00deed7b8185b595974c26f3efb6504770c5e77e62b6762123a2e9d94c6927f942eba96c7500bd7a4e0cdc595c63b777d1848a2aaec0cbc6c6c5ab297df7ffc1a4dc45ed9dd245a547e2242fc543da13a8a607941095c0a1d517aed904532e371728392dadf8779247fac8b422649627feb4d35ba5b728dbbe617262cbbebf832cdeb65a0cfbab31418f38ad121a1d7d274418f2c55bf4e676dfdb1debd725cbb464aaf1f066a998b13b3b7ed1db280a02ee582c0751df48b7385f894d40897608001b8162d7cfe10bb920165c435962a575b38643120ca218b12faeb3ad7e8a1291d9d0744d42b7aeeb78c1296b3197e35026d8d944eb2427806bf8954cdaebd37a5b06546092b6809cd84fcaf5770958941b305737ccb1f094cfd45368386135fa4423d2eee20910868b389e1b8819c325816e02f2dab0a784091b1c76eee22330f615b24ad8d735b881e655ec0cd9d18f2a8328da92949d6d8b85a33d9b031f0e30c5ecbf7c708b3a8aea67a4277f48f409533cb0f5c6ae668a05b10d766504c87065791edd4b5a1fecd2e7a0e2b93b1df0a09f4eda70762a86bdcc1c75888275213734e599a8c263b19d5182ff1d2072545f43e5e35726d7213d395248b1b227a82b8bb84d52682f44d9d133a8a34ad2a0146a0c9f780f122f92c59901be6237981ece1eccb65cf16f65af85863a4dcbb82fc83657e95bd2105a58632475e8f12d4f37052b280daca0bf2ca2f6e836e0c8abf27a07d2b2bdf007dfca26ba1eda48c32dda894f8ea5a1ab814ab25dad7ae2c3b7125123a252eeed98210c402c9d3854b67b0c38c43b80bda2192226aa92478decb85bc958867d642f31e4765cd062d5e8e23eaab5e7a8a5f289bac2a453ed8350daa953efd58703f51cbb6d4bdafc3b8bfbfae9db0afb1574bdca834f873953bd88dfd2da3620162c708e7650552b5ba42fdd32d3f2041f1fa4d17f4180448732eff3a3f1c8edf9ab94ddae918b7c4e4f47ab7f7131c7ef0e54d4fb0c9156a41891367399cc13e963abd109ce4ccf8759747486edea3f26b66b5afc788f1f7a01ed216a4bbf1bdf4e6b396c345bf62fa6c17aa33ba5a6d539cb7c03551edaca530911ed40fa2cc672ec99d14df73a6b65392d03c5eadcb38528410f76dedd0abfecb8499264b2c51f17023f7e9e79ae0c676bd1e2c4f2a57dc0ce438fdaef10c637315501f6c1fca504cba4370112578a03a6b4823af3be830c7b5a39c1abc65a72ba1586d01f9220dd0ac96cba71bb2cd90cbcd51dffca12c9bf38351d4b9da4cd30ab497c6e0c6906bd43be6473472dc263c93329eb47472ca895acbabaee253e98631779166ae49e22229506f59c51eeb10f08543c79a8a0858cf2e4bfb2e8737424ee8fbfc119727efb41fca08bc9f570a67a7eaaadddd62319e6f6bdb31cc44e070d1e687a2316380d4cb4a4d59f4717a4ae4c1cb09f36e952e03ad0ffb6b33e557a34923f2f0af371a2ec556d5a711c348ffe9172894a8b13e43ddeaf453133e12c7defb3c9cb8516e59086ae45f29f0543166feaa8bd5948028d98dde68c621e4251c6641365329b8a6a565ec4b62d05f6934b54e816a7fc81684e293c8ec3aba4266a73ab1fbe1fc1a39aced48647a11c67305e752d9a7898f2916174c52c9fcac5cef3e0323494971f3ca780dc1d38a271d3230046020f73f0cd5bafa80488f90c73cc3c95cb7a678d16af1c37b88776ee633f270c52ca019ba00ec2b104e6aea670494ab6b248b25f8e1dc5e9133ebbaf8506515f3ddac4c4b819a9141b8ad841642ab97c847a194af4e874bd2ef9a13af996d9ed76209f9275914781b30dbd8393366623c7290afa7672030ffbfe1639f29751bad7757f15eb84a0347fffb5fc7669f349fb4be2730c288eb560bb00f23a42c8b6625348d08755a481c678d37e8cef7d4581714f049726391a1e67a3ea64f311dce86170e5a3ba823b02e69c96fab995fd40b459bd7e3cfda6dbfe2979020ff5c4c5ccbd0dbe63f56248413920776c9a85cbda54801db8e5ea229547212415a2a5e5a59a1ba24385dc14664909bf83cf0c88673ea7f97e380a60c982857b0586901d01d5cb8af0ad12ff866670153f45832f5b6a85eebf257b38d48d744567205e0efe989092560431c785fdba9a1964c17f862adf3b9d5757ddb448297cdcc8d5835b0ec3ac7cf951531db09a13a2586d040d6098d4b095c200f201620ce8ad61fd5e5d3fbecc9f4f14d8c0b66d66cba6f692e6751ff04945f1ae557b5ce7e775e758bf79289b054fdb547e5715b956ef16d07f0f42ba16063fa703baf3925d7970d267373b8fc507a4b1f3c0824a3bdae01a4c46b12548eb0f2a31ae3b82189a27380f5391354753e0d1e2cee30316795cad4966f67d2f1142b21520ee5ced484ab53effade9018b92d6f1c9350793e1b89e4740a31529acc99a98491a0a7a7118ca4594fe7e68a9c991e1da34db25bc884f6ce47f3421ec8f78ab137af30ec420c4c14415bba70ca74e524491b88a81f16ba1107a15c5d76004dfdee23db909c0cb2ee9406636404e63cebb1fad7e0aaf3d3e3e93f943093529113172175f2e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
