<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2e7a80b07f1632d837e9ab42e063f7b53a0a3a531aa83fedb15e0c53345da55e331eef4efe51cce7df64a683af9366a54d072ec7a5ffae2be0bf2707229da91fb323d38da277e2b1933978723528dfbc6e6b3979f7437cdd8163442bce61ac5a08c2218f0edcadedbb12e36f78ab650300b10ce674ebdb73ecf43d17d238120c657386b58894cf8cf1bb8bf302eb30dee2cfdf52c72d91d926b6d18f08d58c1083109db7d3a73891bfed3c531b430f3e44c745ceb822459037166db6d297e6af7df31b6f00a8dae7ea37468d321bcf21878c28cc3f690be53b834c4302997009befaea2d9bd0728b0a4e5a3ab401a463b35499e47035524ea7f561296c6bb5fbb6460f3d9e01e9be7f69fc1008ca40dc5ad7a6cb36c4507898cb07b7c64ef3081b319656c8bc4c6ceecdb8798cd315f4473fee2f51a08fe0806f78871facf5edab86a6251e3c1e64bd70c88d6a3850304a08a7d2d582d1d2739f4003d333a038fa3b0c8559e74a5df1585d5c8460a10211b9744e62fe94425b7d8b2d291d9c43dc6f1f1ac0219d00c3b61db79508e100e9279f846ad1d0cad1a8523bcb234b7af8b2668c04a90f25224ac99d25908e85f6f9cda80c5eb9093caa0768d230d531acf9c136e146f6ff5b1d54cf124d60c7751b4ee1bb0376307932f60d72c886e7e8259891d9779397026bacd5721efe29a115b93a4ed645676dcbe13fd7d5223e3ee8685174d15427a6dd3b4e51c82323f9e056ac7837d30710486fbef12a86cefdc4485d4c7258d330b369878d6ed4b456e7fe9c2591264a17bab4a5d92bc0207c39e67d3b1526e39a639204994b4e0955e430ae03236fac4331b32ba46071d1a31acf72cfef6c9ee9c5f1a5c80b7f6ece647fb425326f78d2fc5b0a70b9f62b8f5326c48e384fdc80d1f449627d36bdc18197b087ea80d706bdd5eec8a5622b1353ab1ecf1fe27817b1964f4944599eda84a6ba05f1c74eff63b7407a99a03adb9f067dbe2b13103727e842e220415940843e7e341aaa0e80fca9c34431ce1c1ce4ff42c9395530a078b0d7d498f51f9ec3c1fe2ae919695adee627eca96758e6b926620229207e723767dddd16a9e2b42cc812157f5be8b3bf8eb09fb946fc20f3b3884eed7efb5a5d1f8effb5be90ff9e66cb9d12c3d9ef7099c6a1509915226de83b5b03335bbc20dd68042d07d32595cb51544cfe145a356b98dba8925864aea2759dea5fef7aac560e9615ccaa3e5e92b7210e18eec60d39718f8d0ff5ba0507d887b629f09dad788bd937062a35d1a70dfb9a6cd51088eb19eea2df2063ccabcab2f63880526fcfebc9daafe6de046f7176c9d40a09450ca6257d246de1793c5b108cfc4b65a72dd8a26596c6dcb79c17429424c6c6ccb4dff18788744c1c23831d218b8a1a7997e024f76b5d3ea1e6360471aba52ecd0fb163e49fc9d1e0c8872eba3a8f859d9190670a3897ef8037b25f2823a303281d2fa09da314c80604b0107bbb87fc77fa080a37aa5f23bffc572ad0be630b0f48e7b9177946e5ccbb17da1692c9aaa4069767381723c27e54ef43231a5a4f17defe029dfb7339f504b232f4c098751e771a1b8e959fe037d11c57ab45daba60c8adcbb1ef88d49e119a32d483c71da032bb91b390f589f42d2197700a5ff96425a76d3bdcf53b86997d554e00ffc57b6bc5355b024416c3e49034a26493497e0a7d1f93939a8bddb297ecf9184f6da4732446854d3d39c0bbcbe0ee58d45ab02fc8eba149795d91f014b23792f007d28f109f128997c43f7b695a080951c744f81e45f2cfcf7b41d0c27eb738d16a433f8da766277895d31d3f4e8cb015e493594e3cd7e4829a943846c6376ce676ab650d63a8ee7862956e24acbdf4a6707561a28727d1b32aa085cd707a5e4e7531ab256d99f4aabdd8fefbb8f8fcfe089e492dddc1ddbc7d3367b9d1a3f9bef5b2eec9aca604deee8abab7c46201fe641c71b8846e56942c1827d88a0b06e3dcf8563ab1a705534731738b577f0e6b22afb8f38bfb686bd46615f7f186c95f96f2f00963e1e85c086565dd4ca2b3e5b245ea188bd5c2ddfa46a4f311e9e8503c67a172a50b6f0a5e7b2146ce4c15295d5f53eaabc90f8d7249ee39679c51e7fb964990fc0684a81d226f3c1f65a5e6f51f61b7870af59644b90c861068613cd6e9ae7c820261cc26591c1bae7497e9fde351ec5cc21577cc9d1a521ea33c314515678c17779a83a4e30803860442d4f1e329703ade96cb0997250c69cad9f4f842f5b7d387b6437a6ee32835042ccced2802b373587a4a31799cda497aeec735bb38f8d3d8b2b7154af70f270c5c4bec33db832c9730883dad662010931022957a76198c474c361971118495cd3f918f4856004549f0027bed83323737430f85a4586e8f50b23ab112719f082750938aa8d181f1779205277b5f61a5cd65229b2c4a7c0e6bdde1b874e38b2c4b47c73777a46654052b5377ceb27d69071a43868660caf1790639cabf700c55b9f99a310dc4951cb15f687f480a83ba10504e6f4a98c02339b94a9197f354419da6b1bd955ba4a7bc82a495eb8fdd50b717922fe5308f74c48d3e7af05d734fb534d6fab309dd39e0b5364b867c7e1c99994615ecfc69b89e533508c0f8a985c45f752d3e97b7add23127ea6669eb2a4befe16851cffcb1869e3acb7bf28dd43583d82fb953e17efcce5854ceab599c7bc10748e3327c6caa252bb6c2558d3a087f28dd6fe164196c3514f71629db0ef1f84d5d9eb5a96aa2d80dc207fac57406958ddfa06d4ca96d0f0962c1952157747bbba1341a39c951bdec8b6397cac130b806935cf7a42a46cab00d3bd808b0a31db44e95edbcb8977ca3dbebec82119cdae3d89a179746f43e4fc9df6775761b89fd909979a3bfe83c94a7ccfc77ece0ec898a117d01a833c96d4f2318e81805f908d1d0e5317386128b655508c09d03591fbcaf984f6c27d2bd80a558321b1a0e52c3c3296b05cda20d3d2b78e186a14cf091ea666f8daa232cfa5710f8a136703911c1e750cc1ab4acbfbba22cc835a1c97d166a81284c95bfcbdedf69a5bd9832b075674d62aa63a11bcefeace06010130835be72d24bfe360f8dc241c8cc88579e52de995992c5cdf12cb76c9a49e90cbfd098b40ad146e126e2af1e53661a35cd7c75f2417f0b71137f69efdbf678be57f6a8786681a71af58efc7e6dc13a2bfbf39b9f96c017c8f329eb181cc1421413cc435dcd4c7540f726e714e93005161a00a5102b967859cf3f02178e057dcad4ebcaa2af884cb10716933bf913f799dd2730c860ecde1f41ea850104ddc978b00af16dc58f5639d50dfe59ac899f9c328d0a2b394c796735d0b6358d0cad0271cf13809993b1800260baf91f03aee9a73289d53cc17d12699665d0e31055931ef9082a568534bcf08e255d99f1b22f25e17b536d882f297f12e3b0478ac5a48c4efc0c9492367e1f965c419d41465da8ac6d2923bb323d669953ce6285703a07b7d1754aa7bfe958b5b70866a03b1d5ed359299c98e41f3d961683aaf922d99da6abfcdd687675c46d9f90c0374bc5cda53462f70be4aab9bcdd1309c7e90a1240ea74198c6d33218f2a52596b98bc5a7ee6eeb3fbc4b6c2660588ddf112cff6bc58a34aaa52745f5c97872e55d6f6be73d32a3da632f0b05072a9c15d90a8c0b8bc696b17a7a6f27547f87077cd665df9733ba4cf3a5e7095128940274a63005b91513264a469194d43e8dd82311a2777f9a4bf29f52d88428726596cca895fc4b40e7f680285a6f1ca97e2f5b0037ed826afbcf6301a83d3aa74883bfd12e72c3052ae285e7d109f633f2e26327efd0ee9733bd427df5b4e47fe551cf6baa81224acd6b24f0344ecf94be267c1ddf557c555792f092fcec096f44f7ded88ea34661d049fd8f94682f7b2bcf562d869fb706bf4b7bce78591eadc5158594a11028e5bcd9278502e17ec5946df8faae62cdbb0e013bdebcc5854c89bcda6cab1d3d9c06951b9cf8d2aaba849e508fa2b326955b2726113ee3aaf4e525f552a6abb5822e7f16e6cc9f6d4908ff5dd75763a3b83f5d1fcc26279a9f78d37d69bc516cb7437357ae6afb99889c6f73d1394e3486ca06a4b69366003c28b4dbf4e3fb871af91c05273e5dd7cced946cdfe0ccc5d1d73160911170ade0a3a9f4e5b4236d22905b5dd8a835128d9d5ceeb0cada6869ae6d21919a2d4d8814fdb919feaf8e09a04bdd0e7024bab41d0ff9d8e63ead9777ec51b986cd15f4b68b00fab913384d656fd6f1f8ac18137a4b8a769e5e3d44b9ff90bb52ae2a40ac981245e14f117eebdf6fd958fce9de50f683e33c711f8bc2ba773ffa62d474444ff07eaef2099be209490bf92b5bf6606b1135d7e3a56251334c52ff2678ddbd3c79751581362ec036e80a5fbb1a94575ed133fc4563aceffe1037dc61b85f5792c8e1c08344da4146ceb72a9141c5cdc9f036b6bff34bf91fbd2e4995f0ae2f738f5f42d11f01de1e085adf4cb4a4ba8e457880bfca43fd71857452671b9912ac41f4dd46cd25075756430956bc7afdfce1fc6affe5c9689041a4cb03938a9fcd1c8b3b63519e9794a308272bccbafe5304b14d52ce51254f8f300efbe4bc717c9e440bc3f6dd5f21915b3cff4e2516f425b0c34c670ac42b9e760ff50eba63ca05a4e1e14c0aa50d707a80263eecd26808e7b944b8ff0695c9ce1d19a32bd9952cd77c5ec93c93c06987a3b0e8f2948361f82e8f2cf04a93e3a8f37941cc0f4cc1385aea71d749b7e588e8e5eee427e630cbb63a1a25afff3836d4b6dc61bbed1dceb1a83571b5955172f3dfecd88f277c09f387e0b7d063847ee0b5186f2e04a4151e422f4f535c4fbf6bd47ab9bfbb624a8019bb941e83ecd2b74fdba5c8b43b5a2697b423f739a152cde5817e1c9b5a0ee26d752d60c63176a7b27d8c7a943fe2a62abfae59f04804dcbe3a718fd59a90e9fa972826810f833d2a013efb3188fdf92daaf1eff3882f0fc737043ff48687b93edacf08fb056bd984722a9b5485064b5e316b691e6d8632be2cb1c4678558bf706579caaf5f33b22615bc970baa796e0d2b05c763cfe3a1bad588b05e897bdd11d6354520d8b7707878e162207f23e7cce2f9461b2322e1228c362fb458e3c15b04220ee469efeef9225eb0a3d5748fb09755621c9d31c627494a5b06d0b4392c9f2f7c54b0855c24d2b6cc84fa571c9b507d003545fddb17ea6185e774302b3e1f391e96fe1b3585ae2f0b92af642d4245ae9bb5c0b23e513df8193a08d1f59bde2ed7285d175fd59f724fc8dfda0cbfda24d7416684ca991a74af0c3d831ffd579efe7d02d36a03d5b7cd1e1704a4906083edb6f5d6e7a9f578ba79b2dccb98830795a56678179cfa73132293a814cf928fcd50e72e81357286bdb08e439c9f882235b54ee7c4497e7ab7d5ea88321601c4173e51fe9767324c76493a086d87a5f35403f01611f03b3d8b4b1e67460da130e5febe00cf05e5ccbc1ada587e615ad38323a9db396b30764f84b8d7bf076d467ebd5c35a81957dbbb51b5963b9e3af35ea18391589a2f8760f461573337dff47e5180768fa9dd2eec14d5e0c001121d767799c41678a513aa19cde1263e9b32dfc63d366709fc17b7234e4704b2f6b0aeb407858ce4fcc243ed8b251841f9696c1eaba351d06309554ffedf1396d85a625faa83326c0e1052d3aa72f8b11895e0bb1009ae0f32695654204299e96b668c599886c9fa132ccaa154d17a5affba249bce695c86df09fa1da78ebacf8b55308b6efd0ce94f1d10ab8c29e2fc732a287a1d8fe04ccf7793db0c013ce9d1a43ccdb500cf1d8ef550d239cdcc0dfb98f1efd155763f45a45054f6af08bf8afb1a914c98dd469e6c9ffea88e1f466a54eb3c3d1b2709963c571f3d6027278bcf66178b93aaf21f8a541650f4577a4eac7ed77728ea78a8f40544d0cb07fae7f7acc6b2df68c7d2679b27982c6466be502728953ff5a1f3a5d951bc230d4119b0ffd52d7f111a883211f171452044956a3b3eb674dfee63c1307a590d3dea330d2e5013f69838fb5279d13d283573dbabf570457b5b76f8a1a19fa96233cb17017457ec94e8e63d9617c0e9e1b68cf71aedb4ce37c5e28c5f8830f8de779b02b9895c6102cfbf2a773910ab39d6de07eecf890ea83fbff10b5a06576848a787c61c12f57bc3214e83f8f5d7c73197365cb8fa47d4ed68eaf19eca1e6146d0626b7abd3ca74f4e69f5360ebf04e35a2c7138784b9fc74704a5bb232a804cb56df71e8f1c10c5c014ddc321e6045a8da7ab5f64b1b4af58d9e03c1a04437193c2c82a51cda8a2aadc0adf8a8dd1beb81df6068c468b118b2931257b42dccbeb494f3971c5bf57bf8d00de734118417f0a4a59d34ea329922763ca0cdb8f9fd407a9ddacc82afcd7626b6d6eadaf31890c370d6fe84f85e88dbcb1376300518da78c6aeec3ada8d59df5eaf140595978242a3b6c0b6eb63de0a3373220871a95e72fa16647295d89122ab85ddd36cc7f2a51adb6bda7e101fb769bde43057503494f2f8c222103266d700ba4e5284e5421923bbd4b8e5dabf3a49a2e757240cc777ac3930f6b0e6fcb0057f2d8942ba4182ee58eaf5e9fad6838b0eddd8bcbcb51a69fbb0fced60c2e29ec284ee5f261f4eeaa209b2a5af0bdc984921698412e10fae94433055c36de5b4b051955cab2a858e7ac9156a6b3104f9a5c19f35b5db46ca59eb5ec2f696ce10b65e92e96a001e0cb7852b87f7b416caf2fa3f0e0a9b500c6d904b53379e79c7d83b4c889edd1bbf7fc0228a106c7dc3a28f490623b04717437699b99573a2d7c054cd74368eacaa677569292e1b42ab1facf9d5e018393fdec0025167244e31d2a134e54777705690cbfccba5b95f6fd7586305a2d81d33ce4837c4cafd30b450bee4d13caa630f4c427c99b77e4fa977251d39b7c488e491fc3157ea74b97c3e7b4528ddac4673cd61186f34cf2a6031f8cfa22c3d2bf93723ec3c18d4a37989cd16f169d5fd5b4e66ca0711583e6079c5bfd1da3928f61432336f38745925c331a8ab3639a96fbd74f73f52ce9f8e5c58f09374c4a095108cd9a139c47ffb2e86de4741113715e55c5201e1ddb341c0380d0e6065fdb8a6efa713d049d1758e54508ea95c981304c46f3604487abb6bb744f53347115975b54beebb27ee1b95fec2ba9ff51cd56084fa6445718321741fd1fea6a578f0e36e16a66acf475afb9d59fe5197e7e16aff994067bcd69df27407c40e84fb96b51b3d9b1a0e3bab459a3a02e6a6f4536274899be73ad2adcd871cda9a9585db68efc6dab207e6a1e18d73b1d3b9db6d97a96d61548b9fb955d15377d419634ebe8d178f383aa148e30186264fd2dd99a881815ea88a39d48bc02cdd21f81be1f48a4fb655b552462c9f872d01741655ebd2e024d9bfe53f55c33fec0410472e97f0d6373235ad4d04fa1b7c64a963ed3390c0b898027288902ecedaaddd8fa611d7e9a4b30fe04329360f7fd0922fdc6b7b51d2040577cd13285010661e96464d53a81a8b0658870a815859c434a084278b56e8f53a42460981f65e61195bee3162abf1ec91b812c2eb470c9cc157c59f6c36dc5d6e7344963424737d9d8e232934d2c4938844d5e8b775d84e0241de08b821e10bd68e058b82c61d05a3346a0e926df250aade4dcd5fe01b4d9257fa90af33eeb8345a439ab42e48556fb73d984323d18502e459dae4a9318ae2d378c5ef218eb6dbe0d14ea96d8bf7f86e5e79be5cd7bd3e69716fbdd17250fb5a549a12cb5c16ecbcc780c39d103c9d4386e0b980499940a64329981f7fc5c8ef51c558c197dd1a83666afeccb81caba9fff90cb25fd1fdc0e76a6cee3df99711568af0c33d586e6a4fb46b93cf96def9d3386c0003926b6c8cbd6ab52bf6b05baefee9bcc394014521ad1cd62e34586293ee75554dd67af4e5b6974d978ff183aa444de888059dd67edfd9e2c2f10152208a1c2e32c1eec530f8ce90a9581f0317c5ac58710f8584ad28b99673f73c0d0df5faabd86415c6f70e7b3418fd3f21ab65ac8a86bff92ba0976c866a2fe13f74d27b4a7df07ccdd1edb465d59b0be4afe3ce6a554a53cf2ac4fb8a51d04da3102432fdf124bf74c778f0a620daa47baedf9f3e87bd850a13335f2c06dd0efc37f31a091db6a699915d9cb0c760418a80036c1db1694ebac2561e7429df7dc796d1f4f0bc4a0d5040de81903a39dc6f58e027a79fab2abadc42d422c7f253639420373c13102b4b714cb23f26976236c2c017be7cfeff472a2ba91bb4dc9a632ffedf9ec2a1a4d39d77aa3a8eaa140b4931489cbf0ed4778fe3336f464c044d9fbc285ac5b04071785414839fae70faa2d2fc38833c432af243750610f56639bc392cc167018f8629de80f2e01997aa70cc0ce72bf059654f371574ac3d3c9c7e2f7abfbd30f61cc0c51d0e2c093f55d9cb45dbe57a8b5873279adacfca7e121f432c1dc3bc1adb19460beb41fa407e770d162856f5df72ddbec323da599ed238320577ca0c5f24f31c91b30a32ec906b7e5c6dbf9bc5f3c11e12dd1449c9093fb22064dfb4a6fa8ed649ec12c2d3b3402ce1a7f53111dc80f8eafb29f935c019a755486c22af453dfd8305a8b7a153e96bfb8839712edf2c62975cf6257663a667e9985febd6b9a1f8adee424055a01b7cc159953ad5d2cd05d337bc1da19be9c561d195e50b10f08ed6c2aff31aada863130e0c860faef1afbc0b14118af04327cb291ee9cf1e349e6c9b56e1bb0a34af5d0a6d0ebc27bf024ec57764952a57eb5d687d557bff69841d5c07e955f6cdbb80dfd0cedcb98acb912a3166cbbdb0d784da68741cc51a28db9974f64f4995bb4aa1407a9c161f4e624d1a96d940e3bffce208f3c4f7f99ab56d08319d0562dfa441a03c5201e8097784ecf31b14d34e91957fef81f86e76b98bc6d7ffc9b312cd59332603915aa29eda8e1a5cee5b4894b3f46b1b65aed187387b7be1277a4674c63fa9795552648f7e8095cf133340119c23d58895ddeb9c0cd0ab60a47af1f14964e090181b5dd68ec7a5595beab1d67d290a550391d5f4b1a8f83cc3af4abd2b93370a94fa5c1b0c6976610b9deabcb6504d2b333f5606fd2c848cb1587909815bde746434a1273d2ac760af6ed35333b51e27a42ccbf5fbd6baa369f376fc3eda9391072261e75e0ad69bc8a9b85b1381c1d66f208110f38c331800b3e642c64ae82c3ba335023162f722048dd0ed991d82edbfac8c7e3d487bd408165dc427223ab916ca6340af6451cfae25cc4c6fd2c2cb18cd03904ba09043b6c436abaa20edaacd0b2b4aa02b883bf6267b732c855125399c92831308c6008aff82246d6e7947ec7c957a7a36f585cac0a1075480ad66ec35017476a3f0cf06a0ca328dd16aea923bed4a11472bed80ae5e6536f96289538314673bd48e2bb923509221fa140fbd81083829b6761645f0431cd42c3390d2257b0f1acb19ff99e439e77a0c9cb60bdde8146a4f7578cedc2a54dfd19699c9c5046f3a6068e0e9588a9b82d00a481ae0c08f93483623c18684f458dcbf399a7d97573749ac13e7ca9af3f67f096373695a09faeeabb5e370988b86164090175e54707c54e271dfd1870e0e53238a9b5b2fcd59eeeddb2e87845431057276387fbec9528531344a316954a8ecab63764494535c461c63f07662ad6dfd35e884d3e27f83425c3ab597f59e86c440f661dbe76bb067bd3e36be5ed02b703e2089df7ddbc137f5d6564e2d9ec863f4b1f8ad42173299ff4740718d8cfa8db922d2e8cfdd35a3b43d98e6d33c1baf7ed229ef0ead93617b25bbc18002466231fa7da44064c84ced75bca54aecde8a34f71e1d24d9a891b35abc0eba5cd09a33cfc89f31d002594b0deb8fd2fc459fd3df02fa4eab6850bd701ae17e2ef2442fcd617a75c70552170536e6fb6e359f2a0e8f84128fbbd6bfc94eae79792350933257ed31fb8e67f49eb63b8ecd8cd4423b180505b3c90f507f9861266c0f756a8fa88378b170e3fb3053586c056730342364f79280348857de1675f6ddb17da5a2b567f1fa82322ba23a6e1f7c026897160b6792989e944ce3a186f932dbfaeef8756f343041bb483baad715b29a0d82fb64acdc55be761ef01f42be62b10e441481fe37f8aad1e3ff5af2e1869317b7547d4c4e3087b9144851f4803aba331e890fcd854c1bffaabf6bc47143b750eac806e0278bf86a371b1a14a5425e215eb857145067ee416a77144e7d1fb25c8e8aea9bf39e2cefd60b2375edbc0b9849a93ed1d388108be64e1f6c14bece06f9adf04000e35fe96c43b04f1d879168bb9c250f05e43689e13eba7a7d2d98bae4818f20258c8bd5599ecfd33a6282478c2a980178e4b8cb93f0a6d9bb5d5175d2bc3783cf13c52f93b80298b914b11a560a8faa63c33334ae055e02444c6450da0c3a3c92547eddd1b7ebe1b842fb93a625934603d4a44ed04aabd51c6dd95cab6e5e6951dd8e972608abaf5fbbb887844c17c857ebf4459ce3b0c81ca3af140716a9a0e96478cc98854f4c301c6b42ae911d4e274b1ae43b1103b020261866de8b03bcc551aaabe253189593a4c10e564975658d4d68db6e991bb203692826e707cb4605289d33982c82b332b67782f44db5b0e71de09c7d252abee4c7d9b86d7f2e99ffc2a2f78635f02a1025accce0c1153234b8ef4415b2d193316d13dd050ede3d4bd1712126b5e41c455c3b9f4acb8d4ddb00ce50c4c5f1edb690cd02abf2582570c17709e1947b8fa0aa99652feddcb2478cabe6f542f43d4b96154200a39eb08800423cd421ae2a08fa206567f4837eb72be4ea954eeb1e25158bd3d4f2e08052ab66145d7cf1cd83616fce22e08dce91ccec9d0fb3f3b36b0b1b6beb18e61dff1993b2f65e96bd45f850d42bf01c0e062a0de5958af2622d55f7a75bd47c58f34294a2e380dd5a37ee42ada5b1e515acfc5af567e96749ded8da1de7e8529dfc5a475a4ea168d4e9e12b5241bf32b99b2aa58c4d89a5eb502a219ec2739fc4ed05682b4ead744ed520dddd3d689c8f05b1c2dd072a4460f7d75d1b8030f2d331f2e28be013fbece7e891efd38d11b6825fb162b08c4c18c0a3f3afc788078046f4b165930d7aef1652c86582fd3099030571fd2a7cfa0175ed991c597880895cac1d6309719d160b73134cc90a4cdec533b2a320df4b8a08ce56b4e063a9e19a96922e4bca6bf87f0aeda882f709458fce4b3b2ee6872e5c0a2083d5766bcb20f877c4a78fe8967216ba8a346be9993feff1d190cd98eeceaf38325ab899e67cece19d1f5ea4d8ac02604dc06dd5041e227365a6294e46f819b51a1bc5b9ccb64ec4585901c42166c64926a989c4b79e26ccb893bbd20691f018e569c0bf3e27142fe3c314299cf44cb7d0441cbda0e26ea4bc1a021a21fe2b7ab01193feacf4415efcb8c4f7d6e3c60bd83d2dcf191200c7618596c302e9100c919f0b708a3b45db1abaca0d9f9f8a9086e2e96147ee427c87985b7630e0e4d7e45167a1db70c2cb4df56d921f6dc90392a7d82a759588c8fbd5360efc62981a3235e00fddafea2de8d00e2b707dfdaf3072835eb18d1ac9e2218213b92d8de4ee5ed1437f02d876f729b02d1671c4985a1e62e193744294731fe1e035cbbb647248f65a82a374dc355d3d739ed3cbb83513a024e1b9c6b545863d0dfa12ff603b829b7f766736ea0f6421f57b5445fa988294dfea9a6abebf951b9a7bf781931b838b69dbd5f8edf94dc4fc34a678209aa196792e84f784459b25c75ca17583415250e089c25b24d0b50e7127579c68bd58b4eba5e71b999841efb60beaba78803071fccc87fe91c605abe15235505306f6205578d45cf71b318df7ddf028e339f235966367d48efb28c145de843b0bef362fce828a0d71bcf20c2f4e458caeafcd60de07099834a2bb5083712cd80097ecbc1631f758d5607e99fc7754373115a7433b4d895482a10c39df1166033c86370d0c990584dbd7c06413cca30e3d5aff264ac4ebe7dfd9ebe35beef8d56b2c08b1cd66de89ce5a6531490d1dd6375b8240dad00bfa59a21785ce6a878ff349891cae6d6a7c54276a91bc121c5cc9d1291ecae10a68d08effdcf77270ef72e7343d7016819ba0f52ce0db5c811b9baa8431a40496f48c11e6f9f9abeb33aa2d8fc9c728c510c63eed0e6009fa2a9e842aeb136f2a490b22af883fe08be57999f085867afccc5b214a6c3902ccb02ca3aaf4590d628a8b8b34c9c590e2a91daa0aa1c14872259c09172ee380b3760ca5a2748bdd686e213208bfce401ad34f7efd252a32e73bd41a7effcb24fae4dc3e9711e288453242723fc985c1965f83ef45b3cb4b8aeccabcb6f88891b2d6fc6866dd216a61a2dfdbc3f95edd35a2c06dc914bece5d1bd167efd114ca7ab64533e62e7946f06ecc4c29713eb233267fc04611896741b0e0034182f36d072a584c6bc8ac04cbc974134e010cd0988ac2ec74404e98df6cb105dced9f6361fbcb0847a93bf38b1d58e3750627de71031358fadb896e074714de9e207cf418de12439b6925973a4f7e54f37f247cbf374b19addec16e70058ecb427fbe2ce78d21600dcf685b38bab7435b3bef16fd830603edf41da7b9fee816ca6aeb46621055a2c42e92ff75caf1b06284a464fd6c055e2c656f5d49508e096075b104bd81837ecffe8adc81d59a03fcd8ae5e72c1faf3a83d65cdc81f436a64595c22c88430540fb19f0609bc355c358ef411e2d4f274c4fbe7bc042bc2dded65450865b53573f93d68b6811544c1461b87a3ae221ac9e610823b72242a04b2ecb6588b1cf71d76ed58f6e33b663ea03c5c56469b0b20ec106d50b3c537858b39e16686e79c1bfb816e72e4c134dc8334672d976fdbc5a2e7d57602e492988db71dc277934d341814dd83d0fd0f2e41e71f2de8f2ffc8904bbc7aa812752bab2c3da6924f82377d4fa33514ef868ce49b8cfc70c1c2351a58bd953d7abe2bf57235cfe5d988eb0dd55bf4cc86cba549298fb7184d7f4ddd6ba2fe796d497ac56416d5c076497e3681d4ffe6c73cc8dba6cbc383a8fb0f6a649e58cfe4c602257ed78ec4f75bcaf36b5a8c3f871217ddb6b599ac1d642a79cfee3b89246bc104e2e4321d99cd4722e18544b50141c041d950d15d557ce2b82d6547ebc9a674e235d43cde1118066de642b527e1cb9a695c9cc2c7446718892cb3bc27c6800c0a32924f5c67116f0c80c849416850fb58c46d10791db0c34780a9be82c6097f8acdcdad4791140319d84b8804a949a76c986f2346301a565e884fdd0839704acdca653209068bf955300295726dfe49bd3d86022f572000d52674adff8bba0eb604eed6640e107c1756c9020d87d42a68598e01b1989ce71eb340250534f90cf39c34dea1c0b0784a42577fedfd861dc30d4f3fcdb1f06ae02f901a0fbe19950cfac259930eaa8ab1b6d8eb5bd077ec898b5d4cb2a2b63f1b3db125187186fe1a2923a16d164b8865f33d7e1004c5c29d6be5990a40f1536ff6040d2480e916a724ebbeaa5eb3e8ed4e9d2dd1a9f6d1a96c9c8ed49e17e7d8e7e91016fecda581e4a534d113327414b0e8f8292a5258c54aefe4fa5ba4620b21c54c54b0d408a4e33f051826f351604240bde7f5a672f0e260094ba53f3188de32bd3b16c8557794d927dcc9bb96fef0da39e49c8343f88fab69f8c5f8fc19ebe898f80d8d426b5a93f066e108eb510f70645754737dc5f4c9e04185993a24263ef47c656038c44a6a52dce0ad932340b1752a1839e68f0e0ee4847d41b8ebc5947da2219c239d732db16bbd533d414584d257dc6b9947a8903fa42bdf441dc04608b553925f92725afe424946ddd20f9ef3bf3308ad03d25458ac5454800b423bec4318ac9485dae4c89e49b722d6d29847de7e8dc793c30b71d66f57f4c04f94c006fff29da276e196d55b6ffd4b07f41211bdc2de531ed799754bfa4abc3a7626b8bc1c3910d3238dbe5d11decff41c7b45dc4dffd190c6df011831d0ab8a0a1604193d6d64a0c227f302f11c56eed6d80f6c3019267826286c634bf731633a87acafdfcdf9347c9fd36a82f0a60e70c676bc8c975185db2c2cbb778c974c19e4366e2010bc1607b35b4bb6e960afabf0671875d9e7dbc2bdae59a981df2dd7b54925eaf926265d6d2d86057bb9fb1507cd766ae902a119a48dcdbb79488976ed2149e74fba16869672f9efb3a0859a2504bf1b7c579485e0259e5ee3a8f212cd8256669715552b10f9abaf3cc8a885a60b3046385bbf27e42fb924af4f41351030807cd8f84896cba51d8a3f6269d65c622da4c1d9f00228c668cbb5f9a243ebe241528f9ab92f311d3a9aca2c464a3f747514de2adc666e18328c38aa59fe00bd8a51afe182be282989211844b1f9706e038b2279ba841a6496cad600cad1f33f2b2f873f503935c9b978b591a868ea6c91661c16d7b22712fee9ca07c5374742a48ed81f30b84f5e34cf9e5dfbf8135c9cbccce7cf2acc4e48a6709abcb488a7398a8a4f3db33095073be2fe39f2de6fa548c6868a8202ca898aa9d2aee1a39bca29b35e845773b51be121ed12cd296f85af702e94849bd32568f71735210450102a20f78e4d8360077c21e8dd807f5190b6a0a46c57fe55daa562bf02ff1e4277f29ea7fe6a9452739563e26dd092c65d78474dda231ecfc2534308b9d4d68832b6b0e481d4ff3308df60c9789382e69dbdf4fbaf1dadcbcd96a46a28b5ea1976eed1c072a9e630ccc0d7161a18b61f432584a90061cf20abe89d0d083124ea4d1450db3e08241a04667989dd7460645ab3b6c1dfa33a0df264b871816b76d9636226453c8601ccee3c12c319227c078c09c6acf4e5231e68e2f6655e02db12a413e9ca505317ddf1fb7678df57a9b9752aa38b20298a68e4ae0b5a26904efe01049d7fdae4b20bde46265ef01a74760e207e38867adf7e41adfd3477b0bb2f25e7fbb39c7547216124a2b8bd523dc6acd8829e7f51cac2afd0554109b8e7ef5ad1c8e5974af2f926744c28ecd4bcf0532ed9c709c45ecd7561fc07eb00e246f2b17630f5de092187223df34063f9334c53e10e860137bbccbb7a22d452d301ef6bd42dc26b2252a6d51e776b9a7d5cf3c7cc3eb94b756d7d01a56c9298229110f13e23914c85effa97ada1d80dfd9ca72f2ad50eb4726e14a5f108fcf8453da5b511f97c8545bf0cd31f3da74408b3e491b1ead0632d6dc710ad2a55ab16cf5f3c25e21bcddb01c7e42f78deb521e380c6cc69953181410334a54e67ca6b8b69ac4edf8f9f8624e2db8088a69c0efd5465a2f9299616d11bf5fc37746e9be15f95e67a81b7aeaa2e9127b171d19d2032e0eca3e618d3ffe7c372242cbbc34f5f74d31f8234e36107898201236059a41d49a91d7795f25c9317d0aa9ac1f00a8778e04ceef13ddec5e746b913212e299c249040cf7e5a79f0dbeb22d6e13e8c9ef5635bfb18159e428a2b4809d202cabe09c94f717b6ededdfaff9c0b3541819f7a2d16b70f1abd12e13401638f2b578ba754da0b1c9efb99778bc688e861676986e4c90e1557c011bf3beac0dab721ce09e62013f5b6d4d2f3989c4a166330a71c3cb1b7104609c8384563454a225ba83e9af9130bda412730a163901320ac8515f0b45cbccd9a1f93d74ed9e4928a7f1f37bd5fa2b32161514cb9bb0f1619f2acdd35a7e66a8a50b79272db2fd20b578899014b32938861071be6dbbb76a4580a76cf549f60287bc95dad8b33b64afdc9fa53d5ef66ae56e14bcd7a395b25e17898d57e2996919c481ab3f8a5aa05014cba114d0ba4de2666879489bd34b7656cb54e7f6e975ddf17e47a271655ad765df7d5dc629e32316c2cafec67b19ad6cd43a46d8efab82b086748fa91c0c565fa236821f8f19a0ccfd4836c64b3894187c7da97593c1241554fc102a48bcf142fec86dd4fc12555175e0cf6c95bcf5aae634d5a90c5f1ecaab95e71c617a14c32ace9a9f00cc8be206fa2d751c1b0079803e59d31b187512ffc9173d2e6e57b98de047ed0e74701e3effca40c29e7c164fbb6c61e405094decff10601fb020db356354d5029e302eb8a461e3fb507aabfc9238cd7bed1e442630ef79b13abbf86d4f9ef8b9005c54694b57e97d4ef4caa3ec97237fd5c040b249954f2fe70931ed628d6f380e670559602c8bd3dae8569cf0a2803d0244575b9a19ea0fd1d9cd4e147d8e589199559811f0cf220bb490249637d270a24e11ee9fb17184df09a401ea81939fa2e1f006533113c38b7cb0e31ed9de96bbdf54e6e8d9dca536863c3ec67db8bb4d1c94b5d198b8f372c2fafaaad97fd8b437fe9303b335d55e2b9cb784185f96170935bab28ee0ca520fc77f69b2ea82f1f1af055f9c574a189c9dbbe18b5c7b9518407686fbf2f538bb12e3e8c0333730065429ef0417b5fd49547d7360f4252593b65a708224e3ca1dab5135527d6e8451e34a81686a33e4a535fee340fcae3c907492e316f8524206a750bcf6a1d58f96af9ee193e59188b16094211b840ec30ebf7d0fb7d9ead62a248f70bc861a12a00d0f32c465e43810206151a5c1f5742f2a3d310babda665bf534dca7fedb52c0417bff7752071c466bfee0f1fe6d569b61ce7f651eabdcf630ccbfa6f38a8ed491c119a95f15de5a13a54683461c32509bf2f3d2d82cc82616fce215babd5cb4b5e4d1f574a1503977d7d10243825bc6c837792b09727eaa9ece42198bdf8b09c123829caf298a0b589c78076d76f79dae3180873ac0a36b7a1a34d115b654c8bfd922a9b85bdced7eb0f0ef23569a261e45c8000a55c6321f955180fd652759ac78bc44bc2492add2b19bbe23b2db4fc8096543edce18fd272b4e436f6f4c57c74d2861b7efa33d3e0ee529ea404d8d8e6fefd6b03c0c1b6f1bf4a86253f7e88679c73d0ee32ec2f123da152d65e6641d654080682b30774058135d08995b8314dfe9e1f656297368a7b29ad7a6652b4b552da7e66ad51485e506cda5de633f2e1e4759d92280e9ec0c6964116ca07f5454281da9202e3df4b8cc9dc18a2e8726961b23cd89bc4f46e06744c1c6dd25b0085b309a36935d1587f91f57e5bcc0707b7ccccd5d439568ca806f810c819927878a57276ec7b9eb65fddd8abc4f34e0a0930672178fbc5325051e5497a8426cf88b1ddf6187d00c35813d25ac179d1815a7e2e4ce4236da56bc3df9b92fd6f942d450d36e6aa5af7a902ff64d29a4624156696119fc1c2b0d38d39dbf5da5c41e3e12e907f64047010e3e51100779c613064578e1de63e0b54ab35ff079950b3714e592acd7d8f49f517867cf13aeadc9228d31a8bb5599031eec5476a144551b2a87e1f343a43dbbcea4be37e070ac3f3d4917a493c07499ce2957ed06a764edf5f6cae50e673ab8a09d1e4c6a87d93916d8635361ae45c2c8f2bc5a104e1bfb9db295562b5a49b13f1bf61b6433f8cb82f0f04610c73567c141a54653c56f8fe5d373e1ccce838cf2583a92c1913daf29ebf1c4fed1f343f06547a560a0e6059b2c0230362ddac93bd99621da80ae1a300306c38e6fe8c9923c9c0aa8dddcdbc008d4095be6b6d05151786efd2ba6b18830baa18497564bafd86491633535ea0aa0e29e0625fde2e883497b0b35eee95a2e61212ae8fd72074ee7c398921706009be0b0ca52092881908bbf896195835a8121d9055effe08b9f06dd3c70d7796c3bed6c3a0ead0a070c45031cf02be8d90c0a4e0b43ec69d8d09dce6591bd286bfa1d58b99acad3c39b09eabf473c0aab0cf141f0e61f68790c705404ea2e54340df632b9487aa625d0706607411e1413c31ac4d2fc63772de68ca2637981f967c192084ef564389022e118d74284685c676767271071e8981457ed3c34c8d34d48bb430118e608ec4b2e9e2b322a22d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
