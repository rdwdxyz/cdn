<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"4169168ebfb4fecc62c8c50c2447da7dda6cd89d9dd366f1cddb5a1807badef45929a2efc478897c3ad3d7127be1bf06c4dea131c33f3251eb45a4d389e09e944051381a3c85f105ad058cab016e7a27c4916e88fc90a520526c306104dbded543cc2ed3cfa33c8e17d5ddcd9b1420d9b899ebe458253e754353c4babd5f67c1d704ce8b035754e39ae52a18e1a5f673606e3eebccfe6e50ac186a9c053ac2103571fb783c513c50a4d136bf62877bee3d6afe50071b48ebaceab34f45df145f9382f34f8a292d190a7bab07cf2235e3bd67d30d51b55f167bf1fd6143c1a3e0cab5afd206cf78b481e298de88a66516e7869cff264535058ccab62f4ebb62bee9c6ed9e91d134372274fc6666bf6a1a5e71e9ae3224099242e38238f4a520871b63ef4160452c7643a64ce57372d60781d6f7edc69a011d74e1024c042cc890a8b0b5d5f350ba5bfe2f7b7d01c4be9c62c2a1afb05a81914c458533d734e06754aeea136cdd607b994b5a45307fafa3b5625ad3aa466a98421460f1840e030d52a57702a7c2227f5cb97736650fd7845cf75fe5bea4b8571da68427788631cd902b8f1720d7fc9736306785e972e930cac5480824a76067699f41708febf4bd9bc5c32211b7f61782003e7e7219ccfd93daf9be5211646626419b624682a850b4737b913b02914fb4c8058ba14802758e823a7c6830c813bafa684701addf83ac8440b091a0228833ebe1ae460cb0d087048fdbb6deceda10a9a1d616266143d4b2ff990f49a2687c96746f81d30b07e88f6b3fd4ae5afc36011fa162409b3555d8daf2af39ddeba1d97ec17968522d3a8094dfac226ff0893fe1e04aebb105a02b2ddbc22b3dee268eb242877461a59bab3122bb676bb77167cce50dbc3e9ef874685a249bc76e27f28462675d2c4a2bf893cb54dc21fdaae832a200121aced075a653ced824b95f5d0aaa649aa0aeefc79395ca2b3806b1c7d3f77995d9795c15492f8f56aee0db4b1f581170efbe5385200ef989b1a7ddea81ab8c314acd7f77b91849dbd967062de9c9f76a33f49ea057090c4f5b8c15e2d00c02b742d5893f33a8f53bab2efb018e44802bdd270fe47216c6a543f700bec27299171e1f145e3f35195a5d91427d3e09fcd32c9ab334799b999cd9230e158f1d86bf41df6032e5f3353a0f079175ff672850bc3f11926104831721bf9286e201df9612a25ff17b3efcd4b9a3932f1638bc66836910a903acf9ff67176dfc02d18db7f6c2b5ea283faa2f1b0e50581b6bee8477de234abd486050694a6c48a63063b6ac4034d7b90c2ff93e2eca683c3bde0a01dfacdcba59089fc1935b4014faf79d006d162fc8a475b7e3014cd5ab2035bd9c08a067e2592e24d8473483684143bdfec61eea6a82fa9e1269b6fea223d45cd8f0a2443335485685f7ef0b9996d01d5e9f331a0a763a0b64b40a64eb358929a23264ea03213b8df003db508cc175b26d055a8e23bb3437512a21a3116454ca321f94e02d2c0eb43366f5bee60a0fe1159fac2eb2787b0ef65a787d53b4a782891ca53b25cc5d3f6d60ae3999524ac51d5874e988fcced57f12ad476ba657fdda86326eec8228f097a4b24d632ae6ff2e3cd5c97945e6420dcbd3ac33c31c7b36706f1218e779158007066dbe8bf4b0243323955ffe89d5019ae4de5412b83dba0bcf399e80e36078207a55a1e1a73278be60b3c3bea8c62348178385cb80c2d7a8658a28331a86291bf4acdda7d6cc477f37020c66a6f9bc5f2cd7fb5e75237a49482b24e29a77c8305f53f22fd391cf3503419c95a2ad8b98edbc6f334c919924ee395b167246a395946cdef0d8fa1c51c127c9a89a795aaa09a2b713f61182d6badefe697612eae783f20f324c65750c5cd23f32457aac8ca29ab09f290f999d0b8fc5a757b0d24c2c43a53d07be27fa7f84b39c2b080f69862072f1c2457e637be0c54da1590ea96a6eb4ca8d1b6b24ace037df3147b0471274a147b07e883c1f097e450aa654d188e41ad47ad27a0e217ae3df2417b193eb861ffe161d79912f2e174bc2efae2fc0097da34a5ec0f7133fe549cbeb2d50d04a844b3f93ad2cae4d71200325f1e345c9cde4c882d660acc6f115bae63ad11fe8cee81115a32ca2deee1f576794e36386d5f17cc3748c1f761dc284de2971fb6e1ac6b5bc90ce9545d0462665fb52536e1bd4da3f1731391def93a757368b5c6c20035cd751c284554bd7e097fd66c33ff5d5d5f6c5229df478f34e5efba03492201a7bb04ec1d6e7d51146ead53bd27eafd5e1b7100a05d8c396dd4cb33cadb96d654f1756803b2f495744337aaa4595047259094cbe080e0d3674c0ebfb2b2edf5502a4de666e520f0b51cc085285c46540f1055c5733ff58504b0d66d3209150e1e5bd0daefa1212059290ede04f97e917ae545cbce9db530a00eea7f0ce87fd1c59d072de519e24aa476ed41101af6ca83bb37a5be710763227b7b641e72bab9c0c4558ccf187052a16b3c69d51f7f3019fadf024c8762548b4febce6a3509a1711bffafdef8e4924a5133a47f8d17e13f817c8c4d789314018537bc1dac80adef8b2a3cedd89310ae67701a408e6298b077c9caf0972dceef756eef24ead434d5ce0f6dbac133b9d2c60e9ebabb029bd8781a296874190be5e3864cec247ee7596ee1e2fe9952c980d6734d9c422380797599088a85c26115bda44cf4cf0846394013ea9a94498561e32f6c0e8677b202a7225add7f0f19fb5014cc6fafc260b17450b37062004f57cfba2fbd537b6cca02f5811ef246e5e3d391645afd21f436c23b5d817f06091e7ea9660294cd739d2ed7f8104c0ccc723412a44f45b6a926f4075cb36fa0c9bde620ce76bd653d7088ed5cf8381092ffb0a87aef4b95985638ab95228a17f5fb9dec1bf786b4a485508f7baaf5ac52de2128130f7dc53f841ad1ec51965cebfa9d1265cd1333520e77c18412df230e3aa3e3251c9aee7591c0a36a24882b1e4d5e3322778a9abefaf0ca15cd1ff3f5d5cc8d306d40df80c8cde9754c7669efb87df08df76de5027d7afee990ff3804017cb0d31614982d4f4ebcda7a0a4ada100b0516d544415483818009b72e3ec332c8f7ee8256b3dc076f06d89ff3096a107ce39468a54b37f817bd5a8e521a95a4feae38f39ccbfddbd3e242cc349092a19f0464ce30adbae1a1afae3f04400a626b6553cf4da4427ebf4d58f1f0efec471621b4ff8d3e9fdc11ace15b799032cea08166e0b104890983b88ebc434f2a56180464c25b37ea887896e142393c8122d1ce89d48d8383b6dc00d0c02163f2148ac22f9af6be5a236ca3a9ca000b6a18c0cb722acb3e22153d6f2c965281ea2f0b1333501d2e4912c4fdf2c11ec807c6d311c17c92c7c3c5e8258d020d1e64d57039538edeeed63a68daeda99bae8c22025cad9d297bdd46d4ce0953b36b62a4e0a157a2749cd2127f943c6cb5dafdbc3dc7154ac1a87dc246edc3809d27b04a5e69c1efe1f1531d8c6fc4c45ecb0681d58d18744bcf4eaa267f8450fcb7f611a4c788c7abb8b871ae0133373d4f58b79392e82d0441d330845899eaede0a537ef90f30496ee8764c0a91af770e733981d95003cfd4c8424bf185dec78156521d926dfca937af8d306aec137e6223864e6e9d6fd3a33999d27ceb8942cc4afe1d402bff3150742841b8f1398580a9780cafe800d9d878edf08c70349a0a3eb125e37364b30a72fbe226ac7c8cefb07b23a9216018d3d1f91687906494889c952d1dbeeee85f6269f5f6c2dbc48f1f8297382fd80020cd376319eec688a2cfdce7671deb27eb81b91bb582266e24387d57e87f48695f28640ad2909705b2983448d60276c416a3c32c7b064ed7d938c5727ec5967283562a770b1b4d55a994e77d334afbc63fe5981574d44501c9a015303f726565d59175d8bb590a753d1cbd8820280434ac5616a3b7d0b160b46d3bb1029d6469c5ca8b95d5833854c8cb0f3feafe787dcc04754e884ac8096c981d4e702479757df5fbd9ba1147ba0d5d96f4f5b32c6a5a109562d4a9f46e0c2da9ae0c813b12358b44f2570317fc205d7538d799bfa2eada3da3f08db1f2f162a81df2c08319f290bbdb8266b06e0d25067bbf2a7b983f3443a411460c72c23a751074f7d735ba914989ef25c4cb58f18ae62203a9944afe3899823eb44cfcdde020ff6de2d1219e90739909a57bb07d2c7be73dc16e5e5ec6b5507b22b178bfa7808b977138a35901e495a1bf9b4903b344c5f5635004f8898b6f16e5eb8b8db4b47f76466a9e43632fa28ac05698ce1c7328ca791469ba0262e3501764fbf07ff318293fe14bf9c46bbbaa0c3cc66926336a54f6acb129fcbbc977ab00af54b238dce00f833b8b5c5edc1d4e36cb75a6520d4f0cc8deb99d34f0e478d31febe7fe50c7359aebe5b697b9f391dfee4f4f09834755097bf4229ee5e7a3a5ae34d9b65800968edac03458821a2251e0d57cf6f7871616e7b12f1720b7769846243943f53818bd9a55c8cabfe8dd09721b2dd81361cf4983c0d262e3ae745d24d3df3da4f6024b09d2e427d66daad836e8d07d7036d90e9ac6460abfd65fd0de11f908cc0d3804fe6f990565f6a038c75cbb7e2ddcd4f84c68c756d3fc41e80e75492ddfa4a221ad797744a4835892935ae1ff1c1d893eff762419a7851dd10962fd45ac2ef68cf75b40ed3bc4cf4765496c41281644f6bcf3e0e85c22ec9e6eefd00de1d080b88c60ac0694b8ad87f78ca00bc5aaf01c4ea8e4eef0dc5a98563629f322166e710b619de1d43031824444a09b6aaeed7066becc5ad9f424c07253999e3149bf9c6686539baf00187480c5e0e2408885f816619c1c08ea2e8bf5b05044b5726a3123449efd5de022b0fe668f3d452d057bca30cf2aa432754b0d3f79ff3c6b93e8d6673a12a2e1d76a4dcf5477ce8f3ff795e68ca1c9c7254702bc4737e8286bcb7d919e47b4a8aa1d0871f4daa4c8e5eb50569e5f3ae954148f1db69ab0e45fd4b2896f36074f1c91a39df6c6ba234e9f48a8e66956a228e7d87cae8f02565aa4e4da7898883ad33e52f5cf009eef5f4d87ec84c1da77dad1f506a3a6665b2ab29a48e80f96852a201f4cec95d2f03f5e937a9814a08b2eab444baaa0c6537747a079796227fec2ed5e0804bc3419cc6dadf1e27df425795e494efb8125e8c77beabdd58eb35c82901a1e5e81cfa3560aa1171065057a87b75ea073d80f34894d190b36a93a2e745ecac48b5647f36243277d160665afa3ab7ab7fd08fb42b017e14b7cfd9489aafe9ef7346f6a0364e74f7b98cc725c68c1b94413e8b612baf6e3859890bdb9622584b81de84082160bb1591b1813a535678e268b26ea68b71ca2a19812765ec4c7c033b531edb25c74538c7ab6f1c1f54984c8be598ac933c6d4f1acf1dacf9b84683f349d6e2a7174282cd417c5c19677924df5842098ebfc84f3c13d2326b6c0d7058dba6548cc82cd2bde0ce12c20b9fd446b8561c2d98f36b6fbe3597e96d2dcfaa9c5c4f831c029368e28220fc449ef007d470cd11eb5244e75975ed90d60431d982c52e15926c357e5c6638be4c490c553f6c4ad78c86f602fd4b3201a9b1b709da00d6ec246a0540f2d037ce4c9f8287d4c3bc91b8773cc2b5735065d3b4af14d7c4a1a1bec0ba42fde7fbd085cb1dc52699453d46e884b42914ed7f793b6c1e06987d81a0466a45edbbc0fd90ceb2fa069cb1bfa364b030c9f377289389fb173decf1b243409f03129cb5705696f58bda1f027ffe18d1ad382e9bbb3aebb4feb933dbc7d394181226a3ee00e2bc0568d79409b9768a2f730aca6ad8bb630135e2e12a390f89732455ea508ddc4fb764b8a316e3cc9e84ab77d57a6e72e53219bf6023187f71402ef74e68584f72a9cd96539434a79d040d572544b916a4893b5922d7aa85e7997aef93521cda2bdeefa75ed6c47b99e0130994f1352c06c40752b3d2cc3852d675f13c2e1808e3a4367ddbca2ac17cc2fa1d67f4d5248d9ccefb99edf3ace9dd5b178770033f92815afa5b5bf36207c8d1aeae8a2d9eb2eefd63a7887d074c5668a0895e9910d74e192861eea60fdf25214245c48535e31dab65af0aea4bcc306a4bfc57cfaec5e9c67932ef75e8e5ad3cf8d5f5cf42eb4b69c292797c224e066fd8ae11e3425a9ede1c275e34fef2aaf2c867c1ff386fe272e155cd717bf4161f9aac6808d4587c63b0b37127f4d17a004023565d121108fbf9d4463e3a9182c6e05d025cb25b2b770612f3ce65f0ef18787bd25328cf057a0e766fed0a4cdda80ddfaf85287393285abed405a2438800ae4b5a7cb0c0f48ddb6bbec49bfc5d7f0c2672243943aca3b665eb9bef791ea463480bc9fc98c8f1f707a26a0df1e53cac2ea849024f46cded3d677999b91607639b2baa8c9ae865848092bbd5fbaf8fffe49fdf2f3b5dd584b1aba45439dcd1727ad91d89aa9a5ca59148fb85efced544a9e3effcf8fd934c6f9ea828f8d118aac0af80edba98f1eddcf55546419c76871ab90fc36578189c24100d53c1f37ac022855fcea8fde8f0714d57bd3d6c2181fa0dbaa712ff8ef4f449349055c87b9420d14d5be9ba6d6a262d494653aac470500ee8407cedf07ca31192054d45a77ed788a33cb623631be8a9c510c92b9e561fc09b3041b8744382f248f6d26b76e0411eda2fb18c78132ee05fb0b649ee202685fda134b13a4c08ef987b99757f85a3afa6d5723b7eb84f7dc7c3f3a56c963763ace3dce99f7d4a3ef3a2f1d8952398b6ab63e6b414664eb510d979a80f6129295ed4335a0540f3175fdd6d3018d55045db93b0e1f85b89bc91b82b2bf3a12e5f725e13488b8d521f49be6de5e27af10deb00b0638717f66b80ef42ffd89cb7b67e1b2322661a7cf47cd5e1df2f919ce764479e752fdcdd48c1d9cf04904ab2f131a16d039268348f0a1eab2e7a02bbdc538f4c0b64b6f4385c6c1261e0d3ab23fc4c7c68f58487f81495b4d97def153c059b58b5d52525a4d809e96f664918ac6f1585f13caceeb0608c94594fa36ec918c79fc447a755c95cd296883d173f0e834638f2ba1bb71c15aadc14beb2b36a4ae7f57cda2209ab9ed4a9d79f3f9bd2d67061ce348606d7e288bdf22b2acc69ffeaea8d93b862b786cc7a308281c2d282bdbe208e3a6c791a08627648d8aea8c4a7f1e2bb84445ea46cbc68158eaf7fa78c1e18cb5a0d0ce3c7c1985d2889eabd42fd9d29211a18fe85f630e1a319fbe13a9c8358e10518c80a0286a7d50d3ecba8508fb29e8f07266339844f48ffdadce845519187aab3f417fbee51b48b20cdf134a62078a5b72f3dab9cea0e5aa3f13b5e31f6159574a631f8308f071b972b345c678f1db7716adec8c4038a7bd381c9c492faf03ec56257147ae53ce2fee23b0c8ff72a45a0ddfe93e4a1c0678e94ba0618b166473d19fdf856b72b9eb80b18c635300934c53f330ebb3d776b29a94cd1dfd82b6cb23938a16de835954db3ab2d249d0682c63d7665b79f4810cd051486a536e23d56842804eaa5568d551a3404838e43932cdc89173288909a6a6a01a6937a49432c9314b3a1ce4bf4413d8242016525188ef4c5cc3e4435af49788a1591f9f919512298bd453779ce8e355cb1589852af31ae567e5e99d4a5a7a91a6fd0389175cfeb7044582ff5568af1dbbc498b03f71a2ba65d96f1623fcfa0f750d4579e3409dc36276f597cb5183a9e33ae9f8e486381144cb1042171983f3e3715f17669ca00eabfd318a3055065482c246c5ce9b5b11fd7ef7cc0d5e24697fbc15096d43d5302c596a81063a07675e8db195901fd942feefb15b7df06d51f4d8f95c5cfc25b80590391aaad434d7a603581dba05389ed8e467cc7171edeb79445057ac087617ae175de0053b83030d6c3f464edd79184e54a8a87f07063a62dc5d944f24bcc0c2289766c378a4f48be9fc5be0089a4cd2f5523dc0f3c624df027e755342860f6e71b9b10b4fb16fc418327258b547214589ad98514780b7efee2046744dd1a71d8c1a42112f2dcadd8807dcef5716b8685b25dbcacd4bf94d3595925a2446c91e12dfe008f33fdb31e7103c27dd96f517a0628e7e7dd1d198cd419ebc9485cd197da8db3129fc460aa056e7cba0acbafd754702235e2bb459d44f70458a600107cc9c4f169bcae45bf60aadc03b99a1808c1a032466f1a5b660965a3cf309a3870b11b90a7ce14fa1ce5fba42cad201a53eb7c99c43b54aee74aa14f70ab98c4d6897b60fbdb5c5ff44bb79ec690e604a27cd6b63c444e50cfc43e17fb330934cc94d7a4394de9d97450c97d96622bf4e3bf76a75c6a80d61245da1670e5419f21a790bd909cf45212ffad420652422652843005205ec51de0c59e73c311b5ccaf556e858b618c61c1c4bf24bdc5de9dfc296d20b223dcd6e26a5968237b8d49879208e1fc0ee688da106dfbcea2abc9988f476d6282c5d75f670e0285f611bd26a42605d397eb6fb276324be8f6e317fc9116293ff956e597045e916d12d0d018566f8638e29fa855c6ceb45fa25178601ba6b2666e72d1b45271b11ffd5bb4cfa67092556490d3a86039cc96765d563b1b035debe77f57541a87efd2a6ad38124f66de533ff26388873528c90fb771f0d796868310a021e6110f4b19be9cd6d9b9cde1bf775ce86995b3e26f5e02b487bbd53d1f599d3594637dc02cfde247db967b815ad09b90518ee7e0964bb7480490b0a8b11a60bf14c4340407b0a215b9c485b8c398499ac432beab82e4c76e69234bc9701be11d5bdda89ef4048042f7aa12211a412961420a9f4b0a98bf85f17bddad71458b2d2ccec5f6e42cb182096182fc79c84edb4813ecfec927d6cb54db2feb6a9ebb9d23424bfb196ae5659dee791c9af422b7d42bfa96f0c6be60e13311892365f3c9a0432034752524d1efae4a1fc2cfa874af3c0c13b63beb5a89f129395d612bf479461425c6becdfce1ad5141d022c99e3e0a64435d3cc99abe9ccf296982049e66acd6086cc256d4995f59bfc00232591613c2de95aea96d1f209d9535f24082136a533c73a0e4bf3722efcb770c9a1fc6e31dd849430231f7d2092913b8fa1de2032060e1e49d4a9b31df1e9953c53f6c448b8375d2b85bdda92b38f1200b5b03bbb212d96aa5adfb473ed37600f78ad303128975994e2635954c9093d9139105d4740adb0a4ad2bc48237181cb8c1b298227b76f19a225d3fd32b646045a30c03b30ce2231d04d0fbdc5fea9ce95efb54971ed2564372194f2d232de236b8c56a9080b838faca53940fdf618b8cac2596c3814409216c2af87f02f8b60ce8af8b9c206cb3b99ca175d9fd9ee4ef22139e19a609c0ca0582c36395eb188c32d7dd7737f68e3ee683a8410adbf4a506b9b95dce7036373ff912bf95eb9afb79fe980f58df62d7cc2cf8e9af14dab8e20fa356cd65eb351f96d4b0c494f4de76c9896a89fe523660d51c2f71ff34c59281525c01136198e4403d5c6814009bd0013be85dd8302baaa7cea073b807c3d9fa67530d2b8a3a3431b4e47093904742b930c95823edcf54586b94ede3fd915905e371e1608673ec6eb667eca36c5d9c2cec1580796923796e41ccd94fa61e60f24f602ce3c4904cc3f45a8522b996e4628c900869f49cb592eee66fcaeb0483f6ed440398872a050d45234d1bbf382eda925aaee537b2f10dd8949671ca99f08380f8a209b4eb8f5eb3942c32233f7815de400389f137e653761e03591b28ee1f85653ff8c1e315b1c367301097d6d6eb2e58d9aa1e5c7aad7f6bf03ca580b4814232090eaee167ca2077235c5befc0bdf2e5d550b43335035322f5b4ef3b0ef8c42a2b3b1e00ba3c413e5f30474b843e47874ab9c75b0ed42aa7ff45559ce97eeaec85743c5ba07c5aa7a2aa30726f638b2c3d320e89137149bee2b8dc2a2fa9f6d84a2a89507a756295f02c769c0f00efad355a3e87facd59ccbed3f09a307e0d7a7f1d636bb18d956684ae79a39af38b94dcb3a4db5091933656c7dddb7f9ffe0753b63d8dbbf5dc9331db616e03c232fbf35dbc7be0355a60b1b27de0f4405f793b83398de5b31ff2e1cd0f3a17453c7ad6bc7485a0c84e92688656eaa9ffc12bd7f916a80a940f24187670f15c009e3e1aa597e19e6e9db5d30ed1786914778c458b2385854b11d47772b13bfa7e9128a51088025bf85ca31390d1f73f13e516a90ed7268492a5c8e7cd31a6347432fb6d9dfb2ff763689509c95ca098d5a8e485be5c0d5ccaeabfd5d47d337ef9cf35157930140f4774916552b01447e2a81d38b32a6b4ce791b8d0647dc3b8f68ad69ead02712e62427ba73b4d1fd36555acaa47698ee634d6451ac787b8030f1f5bd638c2df3bfbadfa72b7b75fc29c6f24c4dadc2155fd02775352f1cb09ae29442e978716f8e81f2d96b88de0011809a8106f624e67c3c3608d20cdf200320be724cf4693b5e95fffca3a84c74465f3bc21544a9665e2946c211e1eca0faaab7c49eddfc4adf5d236696ceebd905c832845b0bc5c78518af6553e0a33bb503cd2b170d304d8a864a847dab91f68edec70c9c071db1219a9ac5757f96f10d014a7d8424e9c282b86d6e29f6453c39811bc874ee10af25bc0c106399b0dca402e7a9e2b6705ab4dafa77718d6564b4f0c63f4292d7509edb627900ede7191eb1c33b80e10ff9aeed69770815e92d298e38fd1597ecaa27e1b87365bc1487b9a56f433a896093a89f91e580222fbaea55f2d51dab57632db185cf8d3ed33291cfc3f36858a2f15cb7dcedbb96eb6b3574419ae2ac83807fc8e6276c6225e872660c9177cb764a4cc36719d2a1ed99680741ec2c612b78e1fa66a543e964e15a3dc143459157c292ac1cacfd50a054a4bc5fcb5413d23d7d60b03f89a4ed8f3f9874a68d8b487bff43713ab5fe03569c3d842e58b189b78e92e99e038d42f6578bfd5313030c94ba9173aabbd2baf5b436a3285f601cc61d244873defa3461f5be6bbbe0d70563d85d60518d43b42496c0151b5d634d334c9b4aa6ed58061b9611b0f404230056248d75dc9d65e91eee99d0ecb94157d8102bdcc83bcd9c66f9b37eb3728ec013b6f249964846582dc39f4d2e88b11b1a273a58d2f8b899f4b74b28b2d01eef3fd42d97f7213a38e4dc06108a4edcfdf7b906a48bf064f80b45e4d273c225584e86959765d6a71fb150fa3cf8675a224eedd99eb62dff8b19142af778101d4b4f0ed8e929db8510d42ae15284d351a505cd168469d8f7f3905208e0a0de9abed2dcb2f4d08beb60514ad315bb7d6fbc817ac9dbe4dbab7226eab7fad1a1ec864c537a8a1145da7d3ea8786d206b6bdbb645420c38cec0ed5f4c69605e11aeb7af2f7442b92344710ef12aeb3964b330ce1090908aa132af4fe6ee304f1ff4d4d6607f5f120050ca64d088ae057ea9b04446cd5005fc601139fa570f0d330c3f0f68d2e22c538873311b13ba19c91504205fb228b0a486752e0d140c61b05368779ff637b6b7306edb80fe942c9cde4274d71ef541aeddf195cc4691d7ac69869ced309e75e42272d04d879b07597966c19417852f9c55505ce72bd130089d71cc00bc010de99b402dc7c6f3040aea5f5da7efcfa36838e2a0138180ae68ceadc08970a8c5b896da9fb7bc64228a3a63813c79d9aeae774e5b61ad8425d94d2c12798de05a827f9720ebbccece0dc4140bdf31acea5271baf06c543b9cf8cc3a36ff6b95c43b6e654dc767dfc844a92c7128edd2aa2a0c09c2f7b9a0cda8af8573782591fd434eb74ac51de5ea398854a20014e020efeb8676f514a6c22e72598965a9a0d9753fa886158f615d8a71da6d35e972ea31a514fc3939eb8ca2f502278799b217bf7d221f310f38b0dcb83789049eea7ce60b86cc846fbb96ce99cbdf4bfa178a721ba03a31bb1fc87ad0163623c24607942b0746897028351d78913011e63fabeb0ee8d46b0f2e0af968acdfae49219b0ea757c49ef8290fdd1809120ad5c25ebeb16413817a36207cc700c337f745c462d7ceda1e40b038d0e6d0e69aaf78cacdc3fe87bd6ab0d14ce1bbcb2a10964edd00e52174cb633cd8f1b6a97c87da0c8bb9ab906ba5774fa2d887c2367769c5f0e8e210c1f63a14e9eaa5951e2d1a6c7de495472a12a186979f5c02a11b767154e6369b3925ed8d700029692af30970ddfa21d135794c92c1f57ae0bef251027a909ad536912d4e551f6b402325c743690ef2c37d97d2cf8eba23ce93134264fa8d0b0fe945af9bbcaaf87ded86a993a609765fbd7f38b1cdfc175d24ee92dabc9c916e1b1b8a7999cf82636751d88fa7f699ed6abc78f108ba720b8510ef5822c6b15d57fc63f51ec9cb3cce7bad889d49a076dbe64f42fc5d70a3ecb7e64ca971406d857d6722c37a450e4f69be58d842b80e1b9118198cd0e93b9f2a8f1404e356b3752c07a3c57b2cd4c2c3fd8c13522e52f1900597b84d6f592a6c2b942fbbcd063af566eba696328345dbce4b8bbda7a9f23460b6cf2a6bf562215659e0defcabf72b0ce7d5b4aa1e678d5ddb5ebf88e1f8458e655f37d9a53c12a0b485fd74e6bdc305649f5e1f2552e0bed5ea0389fd223da01539ac1902582227cc6e1bab38b8c056783aae15923d6f9b0aecba67eb3c5ae910306560a6b08ee70c2a8d7cf67a6dc23be62aa063fd2c0e2537408bce575de64a7dc1d4ff07dfb355d0186dfcb8f86ae08af9b4039ba2f6048199b752bbd974faefd682faf48414887ed1941bc249e06ff441f08f248c36128947e6afe6e431c60f8d74066c358a194b38739d835e333b74ff41d379f17b6abf9e57c6995982b08d30106aebe3ac5268500977ca01be87fb36bc34d10262afd3efbab121c36882719d139a91efad07bb05795beedf5695b7e1c3c8d8144d1645ea4fab506506a7b3092c2990d1f541d410b1a21a532ab6641fab0cbd7fcc1d0354ff18f66268c391782f3c9079239e321d967d4e4f9925910b22ddd36e85fa6c541e762d691307d9911057c2c70da321dcca75b28f8f86df36d1454801a789f23fa59ff675841456acf3883882ba6ef1b3251d69774f879b6250593aa208d109c8efcb9b8a90601d1cb35924498348f6cf88c8bc1eb11f093414caa80895998b14505d108de6b9922d0d7ffe3832fb229df20264cea3220b40bfd62c175d5b00ed29a94dd34c58b11cd3e9a3426557b29e268eb76bc7409dc8cf0f0de98089f8a5517435cd2d68edae7ac2ef18ff967623b6cc7dbc9c99fc8af8c898e6379d9d6a48ddc5cd27145ef7d41c906cc7003bd905333b7715d7d3f7a540b5b047e77d096c9002abed407d5761c780027ffa689ca099c4a326d035ac2b4abc1b422549e77d2a6bf05ab4a78ba334f6d8da68ed8a6816f12a1ac677bc454bc62ccbe31a9661490bc8ec9460177f135036d1cb63acac0308f19a6802d276a7ef7bf7e785fee3685079a08e720f2486602249b8196073d49d6bc134475baeea268119b0e20670d9a0807859b6282cfcb5584d7eef0144215e47afd7269964309805b84545aaa4c0576e13c6c668cd453130beff0408b26ade26213e7b4aa96bd622fed6cc809c160b3cff678262a7fa25556621e28202168a4a8452a792db4fc067e966f4fafd974ba598aa602bfdd3e536e509854d3a01770bec2fe29ea920685be718df78faa639d81ed21bc20a40257f9c7d4943e66c85ea577e9bf2ce4d3116b81d66be27adcc925e70a51a5cefaf666608563c22eb2e2180ad062be4474c831bf039af3b2bf97e54a7e4b6982a00fa20da83b78d2d77d2d8dadc600a259c1fba2ff2df561ef0a18fb115f818d7c571f5636e29c0055e7fea15bede8b1ccc283ad59b91fc0da5bca9beea2971bd2cbd9451c7fa07a8cbc8c64674948b778a8f076c7fee4240d9b196aea10b5a36620e549bfc04b92faf965d94a78d93d29594f3e27789d413b57979069103f72f92d4bc8eb4eee756a666db5bbada43f461ba5a22c537d830c5fe5a9eb06bedd3a2bdd3d26a8ff18540f3828069a195b4e13cebe969c7517e28b3051e6d934ee41d4801a841e0bce5f50df45c647f9e0a1165c8cff465301432bb24d9751e7bb6257e0b0938ca00c97aa2d3dad08751091b6a43d02c064a06afc81d77155bd0e9c40aa19ae41fb171d1c478ef38ee8761313ac0d2b74bc14d4725c81ce1631d420946d17facb9df8dd85c9c7016a0c1d7c149c22c30c23ef0eeb398022b276624a07f6a236728a942302ebd9285d894dbac02467dba1a48a793da01a53fccb105eb46b991500509a85aa75853bf3270790adcf944a5a05951b48b9b5fa6b7b68dc611bad79dca50b16836f887a3239fb78f1ed378730dae28fab17b874b68449b089967edcd0ee1f79e0c42f29f5b7ead50b6afd866fe1221a3a5ecd45d4eaec9a054a45507e11ab91d7102876bfd7c4df0fa95ebfabfb1ee1b11c7c245fa7bf05e203055292a2e3a9588d3f6fa20a4dc716b3d925c647c7a99894f90ff855cdcd4d9d4fd2a442b8734c21e30f36c5ebb66427bf1cb47465855ffba274991fbc6180832ad0fd056a1f1faf920ff06719a259e68379730227e938de8242dd7a70049c1761a24ced30b71fd91283113ecc2cf8f612e4b79747273e571e15b661d552f7a14fa4d2a8bbef646b68b056fd61e7ee0b280490cfbe12ff35d2a34896bf6e8be930f74de38a0103c7a5380cb2f9aa5c8672a60725b44af234d2c88495fe343348918702f19b8607876644c25cddc704607287b0d5eef9491d39e6fcd1373116691a8fdb3f2fc3933c69434e79c1b4009f3224c3c10dddf7a3943a2f7ad4524d9623e0df89a14b894b7451767342034519f71063d318c84f60d0228ed39d00d8bac675609a75984fdac47e59d9d04734c167173690e0b3af281a76026f05807e83524195baa6bde5e41f259a5355af5e65a768e3416e509f12210e3cd8565c2870e2e8584b725ac2d1bbf19ec735b8decff211f406176cb96422d73607cde54f558cbc4be510311ac7f7df6bddccb6df4aed7a9d539e96f35712690ccbb7932074a078043706130eea00c9c11cc15a83b6e31d6c0faae293e319f249fdf837848e4e74bd8be86258493342c4bc43f277c598c29d0f00f52e2418411a0a682d8f502db7a6fb318f4bdf6834b45817c5c624dcbceb42876f8e5804e6096e887c265af022ee91fa38f249f2ea7df5449da7c72af2ec8832d3802d58bdce6aa6bb032560c2259300061bf9486241d693bba7fbff75083896b372fca127788be4573bc5120b767c62a6a595f28ebc9e97fc055ae04a32047bac5609ed0caf7b6d87f8c28a2ac25771f433a19358a93d7098df7b6f68d0f8bff7d8956d811088afadf39f341be5d763d1133e49233c5f00c8bfb263f7a9c35f579e24e0709a045b818c08405a50196e3e15f2fab469b9eab60403c391f7f30696625dd513265129825b735b2f745304bc01eb13a893ec2f5e5e69008a6490a1233b1fd89849711595180287ae346a77296cf7f1a8e2812f4b2104ba3478cfcdd27ad46dfc093c0d8869d98ed1c59a7636863479de93073aea9a7648150baa0f0f03407b77717b8a9ddf735844f19d788e745ad800bc3599a7c0a61ab90df4408e8a72b387fbbac11d9669e330c0cc6b45b00f7b2da46f42bf3e6d26488f6ab80c1b4384c3415af625af7d4a8c0e85e89512413ab7bdb2b6430659b855e73c0cb8148163b9b53972fc9f757e969dd31dd0c3317e90f1432bffbca29c86008d6cac2ee584b9b76ed2e227d40968316ac5f1115ebafd348d0e27f1acc0facf11d770be6b9c1ffec4bd0acca47b20f333d1ea7d60166e225d1db194f11b94d5b09a12e44911f112f97e760d37820395cffa6ee1a78f3d656a102f7561367fa5e896a6e9c3932a38110a767c94708213cc1223a77d969dd5ed419acfef17a21dc9ae614f394ed717da8adc86a9b5b78ea33d8048f0388a4105e3baaa09e9b23d0074d6dc0a5ea3af0026f0c4f6935cda3fb68ae3edbe7243ba11a8d2fb9e921bc639477a3c12931aed797fddc9e13e112d26cd32232e7010c91256b12a8d52c10b20eb286f2990ba21471c33e749a9a4c55c7809318aa8d49bfcf92eb781973848f5214bc52b4ba06bfbe78040e143e622a7a407110910b2658caa0a657c33dd2dedc56a3cfc2764fd962a3bbb20ce0097bada1d3ac758164855802dd1ca285b58ca8100e9cdf105362679dc2fb20faedd5c021e0cd6b8c460abf5d750ef1960ba0d9870908b15a908115e6bc8bc761d19d65a492910ddcbfcb08dc1e99b151016d3ea193091e830a0cec35aa1aaea8788d5d5e06a8f2bc272f30b2f01c48b4775f2553ceb913e6b4145a94286c315f3662b15b1c9578666d401196c10bd312f38b846db3cc218359a74592987989fa54e08d0cfbbda7051ec4e60ec682ffc4516f1f7e062905aa3b8a630987d7780cfd7b1c24c82b384428b8cb35c6ea27e0b697f88903da11f465e8239d027064eabc09fb7968395209772acb014eea3f3bc361a90aa51c08dbc0a9f8c5b614bb5f7f6229b7ff3d0b3ccc9605d835b3fd47946842a52ef1330ce7f67ae659e2adb42e882ba3fbbece0b52f7528bf403090cbdd7ae797a2a33344524a53fe1e98199c94445d96b2dec81c9d57767792c925933883859525ba85938e5d4a54a105e9cae4a4e079ce618cb4c6acb64fda0b95edccf1fc4b4e7cd4faa8455843097131aa57b58d803be40c6017cf6eb6b1b2df7caa6c71584047a2c27649f9fbfd3bdf2c055a6c5511d4f6e74985858d9667ea684f715c5bdf4090501fc4ddc861fa178a26ecb5cb5275868c90c8db27a099f55041842cce28233fe275ecd339911389b6cc310d1143e109a1f94e68243b44dbde684cab87ffe265f7368cb7e617ea42626de6d8b1fb1dada6578945df577351ee6e7e542d9844f6448ef4699baf67036bad7ad86745fe1f296db426f6a5d4d07ecbb18a9b19378c202e1de86fe07f2327786331b4eabb205b0bb25598905e97d16363dd9a9da1f8606af3c48531db572952703317fb8c86ccd325e66b28681bf0f5ea210150d152791655793c999824442862f271064077f846d97deb4fc606dfe95b9348886909878866e397ec89c6b2e206a88e446eb9e8c904e557b49f65a8748083510416d9059507c59031184dda415925729592094a88193a0c12b41e769face642f40dd6f904f8465376f670189531e53d27e79f1e2d3ba62d89cacd1c9dacfe26638b2e49e9ce4759c6a77d5fd01957c6d2538dae43fcc1fe6dca5605f85611396281a796d1d7d4d9c4dc1004eb516481ce1f337a378244ba9977afbdb24f318b0fcaa61ccf90fa533b49bac0465fef448ace35146c722791e0a4687f6a6b204ab0a620ada904d4d39433cf3d4128cc5d5a19383356777f328ac0a65f8b5f404f50f4c2ad910351fb648a6ae98c84a8a79a2e4e6e7315dee8b74228862721e80584ccbc98cb8e579d74cf6fd660f0577a3e8ec712c44697304391ab3417af7a6930a6798f7424886575f5645f0f660543cd575936e08a5a47cf840e19ab8291f767071b4368aef3d1e9680777cf13136795d86f2f924327328d1dc8a2f47fe9081bdfdc0096153d181bf1bddce45260e2867ceba70ccfd1bd3c1b8ab1ecf90e7b943ed1e93aa7ed30bfbc08ee55a35216a900775b19683cf2556b0af0c93a8bb145bb03343e65f5aaa47444cbf2ff4621ae8855472f498805997135ce8dd0c0d07050ea138b31c498146206b47366ec89d5558b93a53ebfe79adb74ecf7a808fd434b73b10dab4691f1bc7ae46af822c2648dee551947e0daac90834d2efc82d9f606c9206f24289df6f2fca870347878e2f25e6398e2d23467ecbef49b489ebc27b2a09b0d572602a78561743d33e91ccb37c96e61076812cc095888aa05c87f9ce86ed650dcb1f9687325b045d5db","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
