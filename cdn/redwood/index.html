<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6c61fde5753c5c91092df79c6bc03a90c1afb4187d8fd9ce661a7c3f32c5ebe9a98be078eec98c2bc82ed0e2676b67305b759e4fc1b7bd16b19a7b8b799437007373a183051c357277f610dc166b5d4dc5eaed4780a99871a1801a50ee73daf517998ffa4f57d1fd2cd5a7bac36dca4a8af74cdb0a078d7c15e273067d01720a8220650f94f6cf7400d394161f8efcfc3d4ffde29f06b110e1c15e000318de13b7e7a697bfa76273ccb872cf85327e4757fb60dedc2cd3568b3602de690760ae4313f6158f5030cdb3243c34a064e04fdbe065a5e105201ca7bb6ea0ad6a206329307b23a41d0338300e2b49789e4a00dc5f39e92ceb311f7dec96c0a4c59ddd0310bd0c7c7066eb142d0abccc9724a05b4e179256229668f5f48d2ad8ed68d29ba8806776ab4a468cf082e4c9b14b258e783bc479d28bb71ee50011515f02fb5946648b921b99f228f4c2dab3b27d16ad6e3d2348f9d40ed1e11f4f2bd2fb2fff80ce3df76a3aee4b585b2ffefeb46002a434dc95ef1151a63993f00b7d8f1f5a59252a9b8a49ab02b9eefe70375c7a15333c627d05730b0669bd7a4c3ee6f7a9fad02d5643286ab951b854d4571cf5be3c821202ff2414ae7ec7196d062a0555065a9f4a7cf5b8b0e1c1a06443f213b66b5f6c48f902cd007e478182c979d2e801307a45220f813cad92d09b227c9eb9e3c628c83e7307145bd05d35cfddf9d2d425d6811aa72fc80185374e79e008f848e1865abd58bacb4d354a258d8ffeb07a1fc343d30e1eff49e94fc4da08bbb2f9f377c9701cce7208225e959fe51dd36690bd23d33b0a67aa112ef7986e19803f0d8e26a545b2c31a630fbacfad0326940f9b054ab9668041407db0640ce9c4b363ab9a73cef05e7c4bb43ea672895a8cab4daa15058a0e6fb38cbc1ccbc9c21cde0ec5083fd9d9f5d97c33d6d44b5f2e42e8318f44cce05b03d70aaad33c24b79ee51b347038f69a252b577aa18d4d8a5cd00f05fd6c8f485330d0654b53200a85eef36f689fbb472484a47bb3ce3a618967772f7c08f254ec4dbbfaf0cf8f5bdd49dff229d700544d70f09653e11aa9653667a3de9e2fd440aeccbebcf65bab1c8c1b4a7635726f3c1c4751fee3ee778abaf5f4b556882d48438eb7f05a1efa202dec3e7c0b576d90a6c436284a8a18101bc06ad845f8cb682ef623e60e2540b6262fe36a93202b6e875fc47c6d4f7fa98a3b86a12d76b4da37a9ff6f2fc3ac70e250d3f00d244481749cf0dec0487f35a09c49e189ca5c16b24986b9fbf0f08b9238004f41b9c8d8d44c2289c7d1679a1bf508274cb31e4c777eb9f7f24d450bf1d38592250d769ea9acfe8fd5d25c744fa1ec8fc1dc6992899d6725e8adda9e52b4e3229e0849fc3c732fbc625a23bc7c87ad12084e53b12c70d68fd29e28c189654cea53d55fa809fe2455d985677b796cc8577d328b8c9040e5228cf87313485e751242124ecafe030e44fce7e9ca402e9146ac42ec728abf2a5526b862abe858b6c476bada3ac3e9f870a534acac6290e325d27cbe70db47e2a4ee1accd31d06109f298747fcd341c48f45c279cae25cee0700a24bae1792530c5daefad20d51f670df09e3a0f087dd18e37c09069fd49ec5036093ec5266753686d961cfb4cfc18016b3e4cfabcab4a4a46262dcc0196d22a5167d628b9a9de13e62820356748de4e19e003245a07a59052e2ecc6d367a90c563ced88191887b9e3b3281b7dc287fd330f133421cc55fff4e814ab62c43ef5e63a1fb598e77a838bf79bde0b98ce584526f8b0bb8d2aef6775e785f4bc0a3e886b356ba6c1644f6c0064dbcedc77f45672ba94637c2c6020ef8ca8fe9a9793ab276a30bc0dcad4dbcf791ba6b54c6846690b6a938d72ee9cab83781bdc10094ec7a56719ae6de4f10bf49ae2bcbb47f0d50bfece580302ea92935a16dcb226a07ee5b2aaeb199e364360c19f53ccc0e13ea6d3be4de7e1137a5f32852a0432f076d4d7bbcea83b4896cca6940cd6b6e5ca2c454722d527a6ae9d3896d56582146f08ce873387b1d33db233f26d1637bab36d3d958f23fa79af884a5912a83290c941262a4c9838067d8e0f0d006f6cea7a81ce7109d878fab9bb3c655b06b26bbe68cfe9ea2f57f59d83fe501763ee33403a577da438df34bfd2992bcb20b3508eef53cd817a623fbe4fa1b30bbc5c3e698f09d786c944f06d6e184874241ff5273c5098e10d2a02f04e15cc3e42968861a8f2e1389a1e39ed71c6449fdd9dbf431d718f620ba684a3487dc1161caf8caf6f64fd5f193d1e898e19c8387df530d8e5af5570e5a9b73e899761ac8e62965586a196463761090acc85cd04bc3f91ae62809ff778974a91719db78c1a943af1912b656c794aa66674251b47b372400d3b7ecfaea5126e302b9d6de2e378ea727cc77b1900e2c3ddc4930e9ff6adeda7767f15631f438c025fc86adbee9810eb8aed2f8a64263a9b141724ddafcb543a4665a5f89be4f07787550645872c064359e105c985a56b70ec040db33415f0a720764f3fe7b3109169dd288d3ac59a434d24200f5c11e9b3b2446f4abeebdfe1d06b532a8bbd0903b8fc916eae558326f01fb56ea81af6a90e8bc2a58c6c99df80e52e4980e4b93e805165ea69442c53794e483c23684115244e1276a7d4869caa79c0ac6811392d1b72f492cac105e547585a8196ebc3947bf2dbc48aff1c8171ef2eecf9d6e84b341fc5bc3967854d78985c5cd5de28616fd9dc58ac84716970140e7f328a7da208ac829676b01b877ab818dff95e9c43a133ce7229431b232e76736e27ff543edf156244d3b88d44cee73588840accffae444faa5bcb94aa490295ed9cb74dccce5dd6c785624e85f37d31ea315dc85e21393d19164de2b17317133f82a258993a64c7a863b0e5f63be55611328096aabee18a4f136d466d16708886dffa81f170ad05580cff21f54962a595da41389c97434c2bba824e0050da3ccac65c25e56d36f5da681f943079c96e89ce7340c59ccae80cb857459ab7022e67d36b4cf9ce5cf25429f8f96d6f376b9c8ee8881ce2a39067c2044f1fe07eb5a9e629a7a95a01715a2258859d80796c7b36cf85ec16e371287be683795e915fc71f866cf1da7b9b4f96aca400d09d301d75343d8bb8453b0333a1575aa273c0271c21da3801ecb1b74d9b2432f7c57ab977282cb08ad2c04a50f4db0ceac6b3928ca1a2dbac1fadd15ed68be9c38cc675aed1c5a9098abc4264ae26bb568cc43fe7ddf856e951b866e274603a679e98f3f3ad77c7bcf92959a38ee6860d3d0ed5ec5fb50517d0d074ccae835ef0c1705b339e4b5b38fdc25d7964f46bdaafd519b1008e80ffe7fec48641e1c68f6d3b1b66e3e23d5f90f04fd5740207bddfe7242dc4daf26966535b0ff8fd0f8dbe5257bb5d9a745c07682fce44b17cf05442b2ad11eae787be12d9ff3af72912e7f765db55127eec0bac41b589410eace9ba5bf354ee986fd5bf0c5cbc1ef737d80a96246fd6761c820411b7529f67db543c4731ecf8ca191350b097749aaf2fe09f22e67a16b8a6afd2665184737d1e4c70161f4444d19311e46588ada225bf58e50217108b4a0826e060d0942c3fad1d5c0aca68e1f89844afa89dbbd5a1614bc91b5d2daad6c224a71a645e5c60d7b30b32d94777d59de91cf83bd629a29c4fb4ba1f44aeda87fb3918cbbeb4bd2502217641132fd90ac9e2dc0fce989533aba246d9b76e314a1f52df8e40a76ea52c0375b7f03ff6962fa6bbccdbfcb93e1bfd702fd96ecf4a7a1c50c222c1f4965f2aceb3c1df13c31aac31f7ba172e82d40d7425fb09add8cd15aa04cf780f0099c4295dc0120e9afada7af5187d8324578486cf06c0d89b6f38f91bcb05392dc6408cab872567f417bab4d04e449436d6d617cfaa953d04ca23860867d6bc2cb73e383b5073f99590b7a2ae3ac29916026e3339be14ae44711917d4598c4d5e126ee690f31cbde1bdd4ad0f3235a86949514a1cabe20c0e4cdda1ad8625de6425556affa41c8872df8fd6b78c582beb465c0c748cc7c67517806ee20b3bd7e33b82fb871486131da4850ee67c12fd97b9e9c7d88f1f58b998d2db0308deebcbbba639d23e7e110f27c838bbf4c294899a2d9d95086777fb960c23552fdf423ac62b6118b7e83dcbdfd3e346fa2e6c5861b6850119bdcec10a174f8162bebcb5298a02da7317041bb7ffab0b7a3f502a5404b2532d131704de742b1f09d8e2bb92d2c7857188748735eae97ae36bac57ca888628bb737314b66b2320543f2c1824ea485e6b41b139f614ae77d5e2ad223d8b5d71910cfd282384a9dc33557a3d47b23a2db89aea2718c24ea0e58693c249febe2ec8f908c3ba772dc72fcda8b8b12e91d31f8fc166ff57209da91e22f97dac82c4de79788b6c99da4171a3c257a332cfa6fdffbb4899b958f49c8cf126b080d051acf227b03ec077b2cdda6cddbb91e05743bc250bed5241bd20add56817747269a4ad15d797c6b2f682491cb1c5c4d172fd55fbefff9d2d434c34c7013684cf342122f548f96e18c5ccbfbd62f10df5d504ab675fca2c5d7c03ca5eca7fb70ea2d0f7d014e1133c6f917266c3e20ec147b69a8c821699722fc84dc64a07c64f99e5fce1965d1bcd3ea135d8902096080d6a3f4ee171c6b129d1f0cff077377d1c6cd671d290c70b5f38d466ba4f93f8a23bb74087d357ccb3bfaa4616cea5ae7233f65373d648ac8b28a8aae3546b75edc15e6657e3165eb83f48dd7c35afad041ad4c639bba171a6a484cf314610295bd75f4fd8c53cb1e902b1f7cc2797e4963f854fca3e4e9c9d94d7e026001243f4a847c1ddb8e8bcd8005e5d7751e3e8f69a348ad3a23d2d4502f1f8266b706e5b84a049a2165974fab586953210aa7144cdb511da2492f4b7dc1b708455c7fccf4c3210066124cd86f9beb610d7ff6b1a04a69cf7006cbee24c84f59f52ff13a147bcb720b3f225eef5d868bd03f8264ae43494a2d428ebf7d52c0af2053bc924c43e78e70da7cea5055ab6e3e082ce0b0bd701b39ac4a692a6c23b860f9b415a8e8dcdfbb102e598ab91682a1843540810523cd5bf5432de2d0bb28b512066789d19552eb1493395c4b0efe3138674cd1bf588f1f333c8bca368f56bf69fc2ddcf0c771605be6120dd7624c91c0b21e0657ea60c217e479c129daac317768a61d8fe567da714db32d2ad008371083bf6d903fe94cb4fdb465b3f56f2e0bf58032b6531739a039e97667b194d90ec8682543ed43bd752ebce923a8b6dc93b9d1ea4fdf9b989c2985ab4dfb7276596dd930e92cc2abf8c8d0f5fd6bf0b68dbce22c9fac913bacd532121efb341b7213fc27234ad3e5d02c6986c00f1fa70d862da89ce7d88445f8f335a75a313b59a274c1fd34fdb5ba7dd8cfdf917d9ad094d8852db26aca765b24f42427be941e61d0b46b4ede24007e4d9ce1f9ab06726f9f0ef2bf0960f0253a994fae8f6ebf38bd43a77943692a1a2831daad2a817109bc4805b4853268de4c046c6cde6438f7a4a29ad54095f6b78671add29dc543f1d85d9ace5267703ed3be47257c123252bf3196fd235724246acab640c94a485b0538d6ed5bd6b8f406a1d3e639032a80e85250ecd948b8ba9bb39ea1983536e8794210e4c001bd75f41c6c08510694b527520afa27ae0914668bd1d7b812c50a30b04896ab5fd801aa025793232f209fb7acc46faaa7be0fba3089cdccfddfed480be474ec2b30fb3c35446a1b96be25fccd95f02de793d6949ffa41d3487d5a313de44c1cf43f5c24b62ce87458ffe56dde3168cdd2d3c655a69afe7d6770db009abc7d4ddabcd65adfb45f1480144f43596086d43a743a4adc0ecaef1902d50a8623e28f2dd25cbdfd3579c320ae1422dacca0a8396c5f3b7417a1077cefa205909fa568f5315f6a814590801cfd9ff9d489a9eb72b880239ef3221617c3b246d958a89deac65d653fa93e4a965239fcce056dec2a79c7e58d4a090adddaac0773fa0e282f6ffa523f1483e39ae501b8f40c212f013e8f6f7613aa2e1004253740a168e975b44eec57a22797ee46ca3a358687d78a488bef48034611c310c22851f554b83c638be85715f7694eaad12cb2531e13aa6d9dc4ffdf83260ff38f0b353da2671aacfec281ad915683536d67b588a153d5064997149b862bf9f3dce79e915087e2d203fc265b9e264f34a0dac063703630fcbf2d82c2f1d34a889e0aa50f6fdfbe2077d2918e41c862b109435a78553a77ba1c0017a50cb9e4980eee657d3698a0640f68f206c1920e7c7545f83b95e6864b3905529acb4afbb5148692a20ebdf5995ef9bd50a7009d655fd3641dcf1609a3d8b098b73d255f3dd796c0b5e02a266137c4040497e727418d2655921bd9822466fae118a469e62244cfc47b0fb23b7ccb9ac81f9a8eb7ed639eea7eac56aa926f37efe7dab041a206f407cd29dd0af968e1b782e5962b5a4f526206d0d07fbd6dbf7c51d0fe1854c1a910a64782ad6f5d89b17ab0a8a412fb3f6066e2efcddab3c5b93d7e2d6294ff52993b036b0feb75628be5bd6e15d711d840ecb70149f7b9d84b7eb847df4c42a6abb926e70b22fce71c914b51a4f1a84f3de68c6e6675dd104f0026a8e236667e975913d0be0ef55e16e9f29122bd5d49ef1a39ebff4cada10cd70cd0799973f0f09fe2b19e8c427f3935291c3947d48d03c7efc0050cf60a53a4fc10f5a9d5bbfb1352f8e6168c5a9ad5dbad011ac452c556382dffd492b9ad148eeb12edd338fc16710662002da36aaddf50a7e68a5cf0ccd5b8a54383b648d006fe39b1be9fd38b4367ccbfcdb5741442f3ac0cd4177dc90cf175d16f743cad86c925d65f9a6f22239c7ed09c08b035388d894e50cb2df476a98f2af5c69e684e66d288a2e5803bd92ecaa85fe532b36622a6a4843ce25162320f71925e7fe7df968f7e311abf1f4a2e5cad00a95bacb1d6b9f91f53f852de2fda4574a9b024e2d063d85d40b61c800760c97fee48844ae0e99bcfd1c9eade90f5a6796c8d040678acb814c80a7ab4332b465a5b578031ffbf32439815d01fe9c7db8d0e083c4fb8a91acda9bbd9af1fb1494b5ad3041cd79f2e8ee9e702cab30cc7864e3318ef8569b7bd23fb445a3fee413efbf707dd22e132a5ac4888d112d1a194b31fe373aee973c36702634c8c93d1a07b0d3270a10ff02a1585765d6d1443c57956fdece03c940f68898f39df68b1a89a95728ab039e9afaefee4fc3e8ded9ac7bf72a809eb5cda01238462a4f3cc3d0fcabf6b339150cea0464390af275326b330a64bf05d2e7d49a55c00509ac458f654fbd045c0526dea8ef55acf6991c7c13c08368256e4a0ee676cdd5c7575fef53362bc59586185ee0edccbcbddf0b4fb065763a7dce4270a8ff79eabdd9f66fccad3d229d00c45594d468e0fc386428cfe1c064d55f8c03a5f7de929a47beb4722b84cd5f6be8a3a677a96ceab2b07ba074b886819c5a54740919d93bfcac8d5cb8972b31d91d09c782e1449badf120738aee76e38b221f48cd8857c983a9f22985672cce3067f7f3dbdcd5c21d291576df4ecf15c8573a51e3eb1d7e3409c9950400669be97e96bf6f8cd6523c1a9fa8b7c29296ee18227829d540cf9dc61ea8981da898087cac4512d905fcf248324cf7186574a8705322fc2d4a6c8ec606fed6ba32579746b784684c5acfe0409f615ddaa33fdae35397ed2fe939791896523463869639f10e6b84534d784872df01305800ea9373db7508611de93cd9d32d4de5f2359d526a85633b998c62d0c6168614d579f06a5ba563527ee7bdfcef929dcf32835febd2e9495a49fb8ae72a7a01a3b5ed805d1c8566fd8c9b49d8a10a024c8427de347c0ceb97d03de48a06c81e7b36bfda4cde328bb96523e95f83158fb5a08ab545f0040916d2fff1f150577b3bb921d177e6ddd37f3e3484d3ddcd601a2907780fded49eb04e0368c6d3330c072a2e9769fdd521278ac28463c306377556c5c77819a49090ceedcc141d3433e639c3bae54c081497b9b01967828a5ff9873e8453e846fa4cbbd67beee061a4e3809126157a19acb31bb87de102e3a34dc73f8b59800d6a11f4a67f31f7d3561d4c9c90ce4548d9ed5c36e0bbb783b51a10aa2b06f1a207655bd234449c14636984a0956379205d408237c5e3d72956d4bd064f5c1c364509bd8eb4c31a7c4ee63296a9cd7ac35816756aeba8e980731fec03c8c3945b1e9423a6f8381ac8ca0574d87535981a5915108d3820aeb640ae136d071ec5a0411f8dd967e6a9ccb740e34539ef43e7c0d4545fe2755721b00dab623dadcbbcd2967d1529e974979057c89bef1f0dc022a375260493b3f11a1787ec08062a3caf9973bba796fe939abcf19ec09f1f168c48ab9d7a11b0431f8f27249d6a52c82c18787f888b38b965fea40d8f6a03874563d2aa05a251b7e79622bfd0f95999bdfd6ab35798a8c57eb84e78274f3910c24ae389884d3f509421b564763e0c5e2c938a35f8d23ee7cbc3016c08e2210bf9582c9a885ff383786cacd2e104825c1c03201561b98b956834c17451cc50a510e042edbb24274ae20ea342abd32489c1588db7f3c3e7faf72e5b115313701f92e110bc80f34807dc76f915e70be62ed1a1a43a4c58f9d5d6e9af7629ecaf440579e02651f65aae7d4f7c0b62c278767b701ab37a689d91f129bc8dd0214fd7c6a9e46799e441c0b22f90f941f1910c8ac55bcdc23353d6241171214548a04810cf2cb846666972d66262b79f19fe08457b57ce6066d14b9b38e9d3d9000ebc88da7bf3047178539ae3e945e7786102ddcafb875b224a708592a44aa83fbd7a12e1176ab493743614ee9b5f1f8ce3d9157432cdcf285040fa667cc75588e1bff7f74e91ab483d68095e9bd4e2054e6aba7416b049f13fc70a670e7ebef420bcdec885eb682948fce3abd7f97adad75eb7799779070775a20455576e4533312c1463b4c782bc7a58823ae30188cf168862ddbb744c1cd7e6abaec99ded1a673d70bfdcdec3d633b5ac1560d8e1200b72105d2736c739f4fe354f73d6526eec90af32bcb73fdc31627c619b5c30ef91f6f4e846b271edaed0f0f01b501486421bbc45fe7a83e00a8f73c13692b48f9b69611579692200b9393401ba546db519f6c813a7225b8be55f27181f6da63f04b02bcbe65d97a5d5051794d4b2636bc1c8bab77e0c86455119c399417133086dbb86ee0723eda1109fa503362b700f21e751f3afcd950f75ced682a55bfec95dc077428fbfce54452445e8dcfafa3eae809bcc70a2510658eaecfa3003af7bd5f65010a5bc36fdbe90f7f2c84989e7961fae86f265a38b73ea71e9284b55ffff71b2cc6a2c72b6b8e6b4ac36a4904c35409a6dcb73d1d8e198877715d0afd9e0a5a57a2658805ff78651b2c5a0e99fe0fd54c6ac39e05271016b6232a76f4b5b52974dbbf76c5c22e55e032fd01aea627396704d452eacfda1311d3fc9e927e82e7bad0958af7d6446875e3cdea3f6e81d342da56cc01161cd1f88419626b82c1377f2dba4f76d350e5e3b8e899dff624a6550d0a33c5ffc3c506e7d5b6c45bcc36ebc1feec50ed21161bf5e1a710ed364617acdc15ad4686fc15eb92d79816abb84bd5be3708604ea5ad10fb4e33b0f7eef25571fee47716f9782a259dc3cd2aa2d04c9396bc307721813404e838af7abdc8407923088e5eb68c43b276b1d54dc78c766da80fe8dbacd1e2ed5595282296acd7775a399c1a4e29f6871e647b6cd1b31f2a1b6984e02ebe601edd22d3c856c10c4de625b2224f5dbeeeff3663a87ba2fd96a45e1d8c859a2e4aa8dfa717b599a6cf1a5d358b4a22a06d3564e5f2effe665a1ab75a5984bcff1210e80fa21af3ed816a380645ad81b02e49d55065a39708172ba59a86d16b9129e3e5fb33f1951d9dbfaf462514ac5389b54f5457cb08778539eb8e609beb91cfe665c28401925094aca404854bcbe4588fe712850d56a75a73fd1a18981e4ad096571d3fe56ed8c5bece2de590f0c77236dfeb793e9c641579a922842b91da47f8c522c0f45c48eb76d6f755bedb938f354737e52d950326c22c44791ec0d850dab2d8d7a152b0f9ec35a06a02024a1560e9d107a28aa6cdb527c102153978589b62f3e339649fb837be94d544e9fd2f6fd6b6f4f20785a3cb38d0a0c48f0b4699c7a43b884511d943af2cec0a885fdcce02ea92f01c49578d19f8b916d7b51dc43a85951cbfdb60162aa954dd1144c297a31fa983d8c1e52031fa2b3cc62bc633c4ca563e3a9f574c638e69975da988835a753bbac1d8e7e6a7e9349f685bb5a8ee1dd6d0182734ed27e1581da3521cb522a8f635d5b931fa525162b271f8f4c61e1fc01d75fd8dcfb22ce1b52b3a7799c84564cbfdc575b5691e4717779091a1453c00cb570a856acaf2d1dacadd5cab445f59cb773acf5fcd77e71f574eaa8bf98d0ef25445c0fd921e7ff0e3f5754a5279bb8ecb64816df8576076c1bfc29889b96cc9681cb9298033d248a0785776a77beb18747a733571fb9f09f5c1a26298e1d6cf9819e4abb07d4030eeb8b262e972ef955965f0e5dd0bc26d232f257fb6af3da48a4632eba8949c1a6c915c0ce2698329786ad85ba9f2a70de578924728226775b194bd9659f2a43003aca6d7db2439c03c9734724a2eeb858596094d1abe8cf1f91f99014f1cb2de705b6c55f2ad7915f4b51af2a33b07e54e0b1654873f9184bc400f9da9eecb322308f2721b04acb77735262473b577a263f55e86708ec9b9704ea8b9391bfe78502d1ab186fb69258405a1be408d3465f3034f7a7e02ac4c61c90e5f96f04e5561367d93b99191b3f763f0e058e7e36137e4639e2cdae1cdfa6cfe18c380936ec55a8b4a48efd1fb5fda621e344e88b1ab161ef96476eed2268b3d7712351b5d8364465d5ecb2c7f6d5e7170c7e59f228ec92caaf5976c52470f33081dd57c1dbadb960dd9dcc5645e51cd0945cc1f41be2da87a3e3d5e60426d32aae453afd3aced5ddb19c31aec065f5ec5314d5eb3f0b3593400f419d218419b906070e4c39950e6c41a75ad98ee9de3693fdc64b607475f7d3a50ca913ae9e0c895d67950548d433dbdbb90da7ca79ec4a6144480dbcd21b5269567e5b58500991f92efb6c72cd5dc7926a07609a7bc5c551d20244088efa486b6a31ae7f2ea204f34ba8c7b0c03c9ca1ea7db310a3a24690739a165e0ae909afaefcb3b62d37d11909ed7619593f868b0c28398ab8cd3d3a339e27c9fd8bd650bea72e179728ca5fbdb9443209347c4395f90aeb5941365acb03665e180ae509e992b222eb415ec5f895e866699dbcb380b33282cdbe888cc166f829e75af4906b8e4be7629c23c2cf39106619d7b5bbafb6bc140df25aead545b909ce43a69e590fdf3c2dcdc4059ca2cfeefaf0d6ae64f2bcfc78a3e6abb2379217e562327da27fd37de9805b91156ce736dd1f0e0660fa73566cde1c6b367fc1d20aedecb5788ee3d8fbd5e45cd1af8a24c98c7a3aad29cd5474530ac49177abb82606601e6f2142e8def402311b42c2638865d8d1b155c26464bf2f9d0c80e3c215aa593c2e0f991b9a6e404dc6992f179a4c60ce55fa518983189841b82b2f3b50622513199c87c38991ecf7337aa28f3380eb93c4c5249eef2f31322408203476e249100d82461fc9e4c86c1608d90e8b763792d14d2b88d03df5b424054bb6b68e112182d930d6f71529daee9b5a113c9df3e7867423485f2ec8a755a275804f92d1a25e2627ea83c69fb762fe2726d000d61a9b8b4a7522cbcbc05e2577f38c1cb7082198c34ec2172afd1c319804e032722550d58c5856a04914d9dbbcd47e1f46974908a01dba9ff39d798c6a274919d567a3bdc01f26154cfff72a5a968ecf5b0a20670e5277aec78aa038fb2c7d57e52d659f88d77ecbe32e2783fda4d74d2a94d0519ada6ab8130b59d30e4e453a1a2b8d087d897c16ab6e5a6a15344b91700ebceb9a28785e325e26e79d2fbb70275a1116f39988294d8941b257e8a972f8085cb5ae457b3c487ab378e45c85ac7aad0fef892b765d1842f049325c71daad9675e5c58cec9fd3aa5d65ac9e4b10cb343f822076156e8da984928f56e04d3fff63aae40fce6e800630d97cc6ef59091c83d0e5457a0fc568d48fc87cbc2e4392e79da433336eae1368cbdb01071927a9ed0a348894ee883c7c19692edb245554ec682e8a7217e934c998f5953165b8aa4fa7a93b525877b8c95c6a764e988a19ef9c11c597cb709853cdcf088ac6e37a2cdb7605e7a06a98e1ff02f3f42068ec1aba94417904d8abae7f74423ff13248a5cfd5690375f98a1789e0fb7050b32ba0a453ec6d7dcd45faffa7f352e1b6e27b2a278e62e253a1ab6b488b88fded80cd3ae130ce7f9f3acbcd5ad53b5eea1893eae45fb7380ecad410c634347abdc0bf4cb6d8da1ab00b2c17c16257eb361d845c76e40a7975c6c1a4f0551ff6cde37e01026583a78074936aa3b539c3fb3bdde7b117527b919670b863a54e4f9087da0d0c1b41a2fb56021872b77523334cc1996082ee6ed27d1add7d3636716a7a2b63e23779ec0e629431d7b9986c295b2d781338b299e11bdccba5274f3b66c6c90427c137f26e3fb395d21571f9113dfeb64c24d55a462a3061e1bef7bfd46eb11e5c198c93cc0a6d149d1ccfa98226f31393125eda8bf15a25982eb36919c538e21f874d91b82795037d868d44af56b25bbd8c476c0410eed82b2c95a9602db9e54888863e300238861a96643ef91e6c4e612a5b8e5daab37d1eced94748f6d95c6db2467d42c44d9891d024e29fe98d1ece2a5a91cd1c9fa779440ca299fcbf54cf5e5c1b931e7b1e8a16ce090b8877803268f3ed2567fac4166d990e9bad91f537b576d41d88215b165c982eff58566633ac030334ae461611725d90e9050c0260e317b76ecbe48fa807a4eecaf9912c41934fb64cbb845c172c24a574878ee37308da191ddb686047117d671da9f8673cc9a712a92d208af3fd9419ab98dfed9aa564127e714a6327d485f95c2aa698a6d74e13473e8ca003634f0b32baa5e432395ac62d2e5da7bf136d8029b6ee28d4074253585d9ca0c59b8891f2c773434ab209d0ccb8bd48ddef335291b64742d183ac15830c4fb0815c89e68e32ad7a0db0f52cd04e7f5c08bc652c612deb1819f54387ec076420576611b111e86c1a24157cd712795b5475294bfcc4f6f69a7abdd08944b83b67817472fdb01c5a6d4b58ead6d6b68259ea6d016229f831ba64b5a0317e2e520319a093a558dfbe14bd12054d0a545ce1079b8eab13866c816281b83f99761666c216c4d24272bbc71a3b853a1ea42ed6c4a60b7f658ef759c9857f3881a9f514e3c05fc245b1b8f4e6fb377c962d1c19b79f229d7e834c48b5076c863c0ef48f11c0fe00ce4fcfb60cdcb13dcb9dc2c3e45002b1cb4cdd887ab835fd73e618868171beeebe6437171ecab4e5d46d5f223626dc21d0fdd8701c36c1379a764c17f587cead0dcd7eb9c05b6eeeb5c100784f5febc02aab8c1d0656b22e76805b15942379d07cd92cc3e236e22c6dfd09b7086dfcd3734d62f71d996a429b7f15435461852132003e80d53c9dd0b5ecff12a3f237443dcf8e27b3f76cf73f47a9142e68f756e747dc8ed2fec05148b2d09722feedcb15e2f1f93fcde17a52be554f58dfb16bba630eb084a5bdb3db7b8b297c8d1280229b56f7d3ae85b496593edf48df738fe018fc8b6c4efb58335412c9f4f85c76ecbd23d708f78e80f9fd98fe886576d7455de048243e90844fce2cba31a002de71ec1e4efd01300ba652d628f577a4303691c7e84796fe80291a4be1df61b79c852518d9715a8fe924fca52ac6c64429865e1116e1038e932fbfd7917855e8080c9e68b0a5fbbe37b8f9c610ab3afe7c0488e46307a6f7eb948bafdcd210fc2a651ab9ed448c9b00d1d23656d8ed9d995b0d7b6e83b53d0785abe9461189d1c42e6d6fdf1aac87bcad6e980636529f90a7e576f9f689fe20fc12358eeee14852b330f6ca61fd188c698681d366d3a58045a74592e6b65cfd7ff56da4ff00855df2bbe3bcdc0d0487b836d2910a7a7e0cd344be3bd2ac1aa4f9da4a1bf6ccc2b87f2e161b4cd3ead5992b1eee64db67046cc41bbb79ee99cf3aeb7ef890d8fae11102f1b5bfabe72fd51b81118a2b948e3080db3fabb827c0a39815fd5e54e2b08be36e09860424560e3a7e6edfd13ffafc608d8973f17d5f6087900d6330629a012a03c4886cda93a10a2f684c30763d5dad820d8addff0beb39675ca49f04b07425180a1f6d2724041fc3224e725f3401e9e9ef600a671cea2b3645f006a34a737dd511044eaaf6813784808c77578a0fbf69582006b781816c5b916f842343a24a42a5610f0b43561003102fef6cb05d2d3a8a0b4ac854da111e9d5d224372c0b0b2be990a11af56c74bd746d3cb18b3879c3e6839bf43d76f0eddce9965f75117d715766cce35db18152343a6ba3196691acc92775843e9e25b7e4961081a286396712d16556b303c1cb3597aa8051aced0241a1fe12d447f4ecb400aef846ffefdb0e46c0a07832efa7c9e412266176cd3183a0f14a2e537af11b5c3907c5ceabc7a63b986ba89fbd620ccaaf31410d92977a38f9a9a1681920f4fa2ce291c0acba6d6b569f9e0ed13705741117c960322b5c171a379b1c84cab8741962e378f612e75f0365642898a4609b088a8123e78cee459860ed042e59bd51c67d9968eb83fc2ddf58088528b127c9dcf39de7db08640e9abf57ad08dc5acd552d01a51b214a2cd6b1c09f6410b8cc43467f458e9bec9b780b11fd39b4c7243593b0f63bdc4177afde412f02ee639a028084dad1347b1a1ded7f50daa32218e7dbb56c591c6a4516e47eac3bffb5964281812bad492fb71eae0f3c9f38b429073b11d015ca421e37c8e1a5f80d737b0a09a204a7b68fc8e52c52cc2bac0c231bb442f33a6bac44fdddfa7febe07904884fb536cde6ac4594e66a10713fa1564830ac538b5d046fa2dbe6adc8df55b4a83a479249b5a2f8ab3100784abf3d1e16a1b20c83d90a4e37675cb9a4338020796170cac516b1a28055ab492352d504b67a47d5758d9f9214519acd8130dd3a6fdfd276689c53d554d7ac36f5d7f3a665e3d8b3e17165e06409dfffcc9bf8fe748c480afb4ec0cf1c3e0bfab4416e022d54767c61aad3e182f9b06dc2c83e03c962e0751388462eae706d5e16f422d7bff4a5d60961f7e01d7f131763cc6872464a2087e789b5469c55e7e531df95ba1fa5873b806c48c2456f7113a3bbc47ddf9d6651014749f3a7fe3bcdc6688261e3de22baa7ce77d62f22e0126301fba78d56c12dd99aeaf50c4011bfa4699aa649fa6dbb27fa18933628e39560d497bf19f4f2d97d2cf4dc259d23405fa5b95d0fba45693c369a44a76df88fce42d09863c2cf6fcfa5c55bb54b06f485f18d571e76d84f7f071645e71137d3fc37eb25680fe3d96bd4810e109de766ac5ffdc343165ad66c5e340c6aad7fab23ce9ca27f73dcb5945eda0c2098550421cee13c9de96c928b745e26e33fd8219be9035785d50baeef95b81db3ba77a0fcf214e55c8d8888ca72cebec227b3771a37d5eb37caf98aa5291771aa3ec75ee9b4af15f234cef941c99c08358a1780f4b2ea4e98d53572e7e5eca8f64891558e0eac2b5e4b3a059fb2b31c047fb57c049320863d21ff3ab41af6ddad43de5dc4c873ed58ba2bbf5e749acf668aa4bfe489b7c6888c79c0e6cca89482ba97123837e039b5d7a2bdd2bc3508b905664d13c26560aff1825e9e11e63cd5cc9287c04b67c57e13510827ddd25de50daac830c85d6a0b1f24d63d3b7c9de86fb3d35e69a3eea020dab473f63f6526d0cab3cac0e61c25e481475fefa4509ed06727e37a0a7cc9eca79e43bd293e24892ad0bc182d0f62082de1036b28172f1f1b9dd52a4b050b7740ef039560019b23fd3b72248509edff30af249440f122a77138f2176104a0279520799e215f35fb0323477ce7e0d3776c197664ada8493b8995c84a14a819029b2f1eeaa3ec435a84e692facc349976f198f52f3a2d32ac7dc47490d32185c5c29462fffb7f6b28099ec5cc286077872331b2dc037a29b4eb67cb5792ff745a19318f8e495297f6ae5d160363085b848d25255f333645724880a6f4f26a047dbf150850fb24933d52f200427c9a3b3de3f1546f38a647f348ce82e801ddddf129fbfd2b33c074e3a873dd27006380c957ee03eec3b6ce008bc9ac161b045863d44558257bb558eeb330f9bc704dddf48f80dafd42e762472e08a50c110cc196474361f02073205b22163a6a27a54fcf077e8ab5951533c2549fc04742dc169bc16d28e915cf6a2f7bd190ccfeeca6b45167c78661bc2ddeaa3d4d0575acc7a6844e908b59597cb4ae7ae42e94242fabc7e7c49f0a045ee725f4712d0bf5c0e2166737a579b52c9b0a7b277d43592ece861efb5b5513564533a2058bc1faf50234a2cff731808f354a1e400e66d00a6192dd080617014517fee8fe1d6d38bb1cc3e3bcb25c809cfea461860c15bec7c029d27920a1830b617a619c9558769f00e479d9583c086959265341e628cdee9663c2d289f6a2e19f6ae7f74bc2b15c02bda2e338bffd1df974e6bf6244e109e1a287c3ba4e5122332981526252d836123f327ad29f1d25409b3f82aa511183687953514b2398e8ff53ec8b37fe6cc370bd155093a93a1704d7fab4445056aff78071606f061952cdd94928d4de8e6968b011de3be7a0d9498bedee00cacf514586caf70141eef2405887c7efb97acc1b022c2b5d6812e839fe2bbb654ea2b4fd2b391bdd803fe8bfe59e5b14dcc9adf3708b6aba27281e53948608cbb2aafe54c7a00396d288568a79177e7869e4c76d4a0921e4d64571f6f90eac5b3ec000563f22b8d79150176e0b2c6b421fae14b20a430593fd530ac3a9242f30e2c591fe1082ead409d8e8962cbb7f2d2ae76736835ed0295f298977d6d0898c5a61ea7c867bee81a4b154c2613c89cae3c75f5ed925c8e33cb5a2953cd753f28e143c2ef60cb94a07e265bc13c0b0f4a8a63120db066b6b63c18ce41f687e1b0d4b62c74c2d5b760b2b688cc23d8a770eaa9b24e35dc9254b3a78f08e43198fac9f9ecffda0a123e78b1c2b1611a46fcc2cf0199156f6787844ac8e61aeba25accae83a95601ce7f608b532662e8cdaeb61f29f0181b7313740c9b937e4068fae719e85aec75f20e28b8b3b114eb02a317939a32318af56060bf1eb3b8b4fcc449af3f46f6173b69ebf6fab8e72199432f13627d9d7af9eb37b80424ca325e605ef372e9b32700507ce887937f782e60256ee199b2d759843ea8918a84f77437b3599df2f04784ccd983b1f757587acb0b6cd23d8a3c95717198ead3d46fc76305e1fe5d5b61f7a98d455fde78fbb4c779ceb5f6b71ebbac55180ac7ff75430c314c27e557dbb81b98279eaa26b7de4ec8e9e512b0bca4dc6c917569f4927b40de7c81cb4cf002ba56ce8746cf08fcfebf3a145a1c1bdebb947df98407593c383ab109f864a1ca99e78fd872074018ae441a3382a761f71a176ca3840d978851de935404a82a6a64167bc452bfcf7751cf2a2a29c08b41eecf5cdf69d1b48eeb38cb9da6509bf34c38b6fb758592931af91dc7e1c762c8e9b1654811a230bd636b2cf428438ae5ffe96e3a21968eaefe2af62f001ca25a0e25ba0ac78d5c1a5e7b6d4c6158e13bed38f7e25c96a6b1bb4f0bf70d338449c4b3798ba300c1087a6495cc9d393377a07c3daebc4ea77c509583420d6952319af3ff827cf0d7ef847653bab221e2aeeb9f1d5cc064edc9640ca0af26a12a18a5848fde9ec40933220ab41789fcb9f0cd1dc6c4f3454a7476e6dba409dfa78f9c83a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
