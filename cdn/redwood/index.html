<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d41d20f595dd3b52079669692074528de8ac034a20d4a82dd7bb7ad933423ca6b503c8a4fdbd3687efe1a4c79980edc4a51bf731b167bc11a11c1fca7053fac4746f316a025f0599d20cfcb73573ec4ad2db59ed805171bdca02ecd369950208567b8302b6231bd44312bf1f30974d956c9f78fff8ce52b8fbd50cd87f1c652aeb28d2f61e2f68f6fb97a8b025bfd5c50b5ee0293d76bc453afe923bcc5ea6c7cb7fc468ed5edc8ccd9710cd585b91a4b69d4328276dd7c5ff64c46149a719acfe8a35b27e71093633a263671c3dcea435f63ff758fdb79fc42e225e4db5545c87db98475c897cd79a6d3ab6fe1a75b50de0a3dd7587fca6d9750428d24f7ffd8ae0aff22cf6b844e0e65d37a537e99af8baabb22ea5446234d4cd16e5202513e35d4820a78c3b17e0726c58d6bc428e7c497a28086c190b909c2b855558da4a1d9a5b17dc862d5b5ba88b197b5e2282ad11ce7166a3ca5948b7cdc54e213c5a5e852934e4c32c8ab64f51bc4cef27eab95f51eeba675ba8d3da830c61360dd226aae190bade19421f38d05055c2ab84b35db43de2e889130769a164693c19b632232f240270b0aa73958c35d94e81708642b5c964678c301183eb3f24bb0f14dd64fe2ec207cdf1ab7eafbc49458330da5c4c56d296810de3b9d592cd1c2c4f64a1282054d31f92fe291814393e9178cdc2b2df452c43b7610dbb457e789f61627415cdd634c08552f923936dcc93c36f3f9d567932f6b930543bd094e941e6e4cab66751596f8ff35144f40a8c6aa4b4ad51fea6e64a26ac0a0a4ef91ccc7c0bfd18ecc490fe28c8cf0429a5b789c671fcdbda04c4966d8f37948364a00177f426fff1b21a92e84d2278849d142394269101d700df4fbd570af89de97ef5316a4a897b082f9508e644dd5111fe2348db09fe70a197519dd3fcc1aed74270a38ef8cdb4884e522ac3238850e4377888087188e40a8e6c1d58951ef068058d9b7d40ea9f26b133eaa17e668db4c71b5e69e21a4fd5f6d3901fbcd8475c34d91fcead13729a089eb352b2c428313c735375a4479acc8cb173ce5d406330d48beca35f66d8fe3962561ebb56ff9ad4ec1cd290afdd5bec7b7e93358108d210df732a60a38d51265bb605ca794b0131eb756116fd61c60c626f9ddc2eadce765dc1640dc485e8efc0b919f740b52d4a6e1e0ac7af639a9498774cde38a7cc73e8d7811c9c4904c90347f80e6275f2f6bf7f4815998734e773b859f3ad71a5041f82d354a9fc35c2276ba8bc847ef8343066bacd34cf550d4792ae5a41fae3cd3bcf0f8fb8c2b88b458d180d482ccd62cf9bf3a69f1a4ed3fcd9af0064b0a0674a3dc64fd9b4ae925b3e941f0be085dd770d71fafc21dafc41ec4f507bfed5426813d9a24e1aa00c92fbbafbfad677eeeb0385574cb7f0f8add10226643fbcac5bb633a430e3fc180601b31fec736d9b683d87e9484d0196e0b037207d8ef21a57d52d60df41a7f853d0651def4472c69e263588cdd38410de3f770c5958a9b153fd3258340c87ce05c356cbf438356c0c1b52057305554bcb0110ef70819d9855270276ac04646f2dd1e330f9484526c51b12d06177506efab8db05d3497344989c3bf1dceb538e5c8b37366887fb4bbcdd67aef532d9b5117e13bc8793d334fe06c4a9eb1298c8dbaa4d503d21b593d7959cfa55a9b6abe24424a6fc4889f257871dd57be5fce3971c6548ad320179b89a72e99555908ca0674eff0a7c95cde411ef388d70817c984f96de022b198971c93ca2d0e1ec475a7ed2c75f0ee5fffd3a382b21f931a9744b54c4f7954e467e4af48806f5a26e83e8ad7420d5a91799c067d935eca10bbcf9351f400ff92895ad2479a678d49f2bfb8c50206b15ac68727d3a8222cac6fb3f73b77c9cfdd0cd436ea9d35f847eaca7eeb2f254727b704ca0da72ca360b517ee60f5cb2fba53dae2eedccaa302c0e41c2b31ed115320484393cc2a14205bdedb3b40b8fad43af25e862362ace2bcb12b00e3c583aac0e3afa74ae6857f8d3858a0bb50fdd93c85d33d88c63ab68fb061e19503069f41bd9384c4d6bd405b865ea698a013c0d5860ada386cd7d4e1c129732eb17abff9a2ae85510b92c6f462786f15403d9d2d84c1308ccd18e80e35e61a5a3cc008a857ae2be3d3617a19d4a101e1d2e652bf002d7bc1e57f1147316c61d195c954b79cc9a9d92954fd8e243e62c0415bbc0ef792a1f305dcd16e169eb1d6d2b91d443d2a2b540783a09aaf51d0387ace75bb71670abf3607b67d24ff2e919dec95bbf04a1d51b1659048362c3d9165001ea220e372253ab48db38967ddaa8ca638b4d0ab46f2758ef8b5ed8850b588f39dc6dcd8a952abe163f08f25f8f9d286024caafa453329f2cd0f9c80dc6d3b59c6dbfa4ee46f51981675870043c5e7622c7102ccf2f93b0400bbea7a0c1d337190c09486ec0dea18fab08045432f8a8c2ec8e3c3ed851497746ab2445168eb7f5b880baff2377e03531d50f466b8dcd98920084fb9b72e50f9bf8206c89bebaee503aa41061d1c2d5836968e6b2647e180ce8f24a7d2cf088e8e5f52fef54f9cad0480082b022761562fe591323e46d4a5a5aaf2aa94c1b6272153cde1061dd094504451ae801e6bca06792bdf8ec52a6b5f3cd536240f823c06c3f1f90a608e6fb41622a26391f866fed8aea3bc61a3f438900ed25c1e6fcab0360fdca2e155a21178616cb934bee2aa1f2a5416d74293726d6c534b0947f050e9dcdba8c4afc15ec3bcb4f5b28e0dc7a97424a7b4bd93edde2da5732a3341c8c08fbb3037c2e9ae810dda63e999890f00e3d7d9fd97f332d9ae8a9d9f8bae48eb79875a004558aeeb8cf6e8f7cd2873230340b380e6faf99e8aeef295c085ede41e8ca430e3313e43a444634f4906a9f9fd9c9c120b299f9257edbec8d9ef89ee0b561d8466a42e552af51f32454e13858fcc8ce5a755da561be96eb5ab01121858e445a199346358b0b54931191163d16457db4429767ef5eede045d05c192c544bbbdface8ef03bf215fce74711da5d046e7acb6b5ad9f45d24c819d16d414d338d3729f6cf02511de8f4259f2b8dc998bb9cf7289eb3cf8240aaaeb7d6e13650269ba5aa4f6af453e4cddcc55548fb9fe2d09cc3bbf61102d9370b000e989ade6920222258b1c6c1c74148d1039f376482a4278d85f24fe514522eb7382f9db5627a89f8b3511979ca5219a3d790fe4f7bf6471a0888f3caf94cdc5ff3631ef9cec95dc283af60c49c1da95667aafd89300be35cf3c3cb96a1c1c2b4a07019ca209224f93ffb0b7cc380265d6f98022b99d2f69ccf0de320be427f49b9089182ffa0abfee109ce91dadd60c4f6de535086e4e348c2728649e64e282d60793677d3bf546a314c29e8ecb1a5c494cf052bc0f697af374f9dab3954432962f262749a7e10317f0fb12bb305044d58efa9a144db3b3e05e7736cdbb88823384693e11ab675793aeb3269ebdb80945d06925d143ff0f59d0a671d98c0306076293347e5238903152f928731823826036aee8ac5dccafa42640abf639122cecaaf9d66a0abcf9b1baa4dc985843eec03914fe7caf029f37560bfc603ed368ab653aed91540819bbb2e758d9ef1c973a71819b9ffd16daf161118945e1cc156868dd03cbc5846bab9e6748e4710e683754e7a8acd09a3ec719cee850176fb168222c33518981742d3adb1b67748413d441f4c68e9c1428331d2905eb9249a54f3c57209992f3ae012f6fd9be6af30bfa64046289ad26472cf1820ae7e9a75703d62fb06866475b7dff0cb82da1544e1bb55135ac27d45dc5581b63cbd5916ebb404ff11cf9c190da08090335163cfd46edab805c99b752b98866d45e4c5e941bbc406360a4be5c1df3d635bfdf38bee133f66e1fa89795fe481b41d6f5f5601eb92c933f3a3775a1188ee3f46bc3cd0ba0e73cc4368fa71944473caa07c2ebe98fed150c6d6f0835594dfb3b12811058967302835cf92753022469bde6ead78f1b1098e7a131eb8b5c07e9d08a2ea19c69d4aa81e7583b49a94931855be29372dd58a92ecf3bcc714376d109920ae00f8326d738e57b1439cf7e95b239a74ff8a479f55021f5825a82f2f5e28ce597b858ea1fe935f017e2359f3ed2a5309100403815f46bb0a8621671a17ca4fa2fa1a6cd41987d126a92d3c9054715f06f7c0d1e4d88209a776aed95f6b5bb5d9d6005fd8fa97b1a345d92d6e897c019d9a2a035cbb5528b1f5261c7f8babf6b67f01e43508c0bf7ca41ad2236ebb4cc5128ed215f45d1cb2785fc3d782526e2104c0f3fe18c0a65ef76147747a1f018a5e4ec82a5848705c9c3444dfc4478121cff8c04359ed0ea6e7fb42c08700fc1c86b570b2fd4ed22cbec32d4479c29dabd7d36c14beaea0c2939030d73aa1b7a7a8326b1d787a55d25bba34d17dcd83268da982e60a53ce0d3f4fa84736b777b13b1ee0d2928bb2bd632ac6c2cf9920ef81dec47dbb62642e6d24a4821e0c15baf07134e0481ff71a4ba85d22d792da958c829a96e735e05659b10c1f3c955cb2adcbc60f6c68727cecac057682f3483f6f05eb25c8ff7bff5eac8bb4c858d7762294b31c8a808ba2a84f832984ee2d8e10f8331e81165b83b40a9115c2ac40845d48d531501230af28bb9a343129d80497c28485c3cb59cc7fe74d8a2d4969c030aa1a3ebf6bb22cee1846b7c1c8af7ea86506e370517afcfa7d7b7f1ab147a06d3d39196eba7c84552b9db2b4046d4b5e0504cece241018df691161bbe28df2a382276fe7ac7c899c696e0f973d463e6750cecb0824308e0889d49a92eadd43ff3f2ca72cf51bfc96c08e3c6673642200b537b460b173286c687642076f22f846bbb8a0d6b51381ee3385a77fe7b543f3477a172318e7b80dc5cabfd7b2856aecd1704bc16e4fbd830b1ca9226e5298c50bc2777a3faad9590fb6d3bf0577ecfd86d14d75b1d5e01addae7596e9196bae85cc3066e0a0f3285fe31400d2ddc734e0920fccb197954468592cf07ec2e318c02d45dcfd9d99253c24851256e780cf14fd56f80cba88462fb8a818ff758a451c44b64a4c36b19eff8699135e5856ea28211369bbd0c54c8465af2d5608c4f460757e735bd7bd24ccdf8d8162fce84c2f2ca1d23ce478720363a981fc98755c3cf2d4a9b2c01a7a1432220013137c7d796c2b97b294718900cc73708e94a2c87658d4c3a640767aab9f41cb4991b551c0a3cb132d8a75ed1987176e0d3dacc639e258ae55c030d51188dd90e793457dd69f6d5eb5037f928e281ed6d46b6a5e30dd89ee4045f3b19217479fd315822d13c8d32e7da951208367568c5559a7caa7084fdd94855a1eab4204222162fff1e36c6d64330620bb9e7327ed249335d51dca86ae4b6362aab3a07dccdcfd141f7186fee5b2de7925725b2aea72705a0dc7d850254a9d5e5b46e82d1c969c5efc303b6920390424486b64340bd06994b745a7010edf356ddac64114752ed91bb72611a526e5a038900a0a936c3a0f622a73d526ffda825310ae5e06d42153297a05ff3fb9c9e3994bcab4ce92b9b0d6b8ee6d2211f7e35986f8ecfda6820629d3d48c8c8878101bdae476407b7129e33291ef7e091d8ce44a74702feea89ea40540fb701297b1c4578c1ae7da7fbde0b94ec6096f1f9b19ba9cb398167d82be121ffba43e2a2a01cf166f3b2057bd2d161191f131d1d660c951dbc40a49061cd52491dc33d1e77de2a5e4720b0e7821667fa5a2fce43ccc8f42b1b29e82119af718bfd7e8cadfc61db601e8e00f436e1433d5a22995ead53ecd4a718be9c7bb95d6e439d071828555cbd694149f500014d91269a1d8e3220595a93102302c5d945425c559e2173497ee4a09d7fdd7444e99def354d4720105390867bb7a3b44b5b51a88976623615957ee5cf0fe7891a1af844fceb47da28f7a2607b912a2b67f5328a3c1a6245fa83bcad6df8e6167298470899ecea5d08e3c09411c9ca4d03dbb2b507f159e4095cc2db4bdec504663d9f49e5c0e0c7262fb55217d2b31ff8e840d11f55f1d46e65927be4c30237f09c60c0e0e0c9812446920a2d56a00ff40503f61e445048a43cbd8cf96a9a88b3cb44857afa3b90279aeef0fbc1979170f0341191a76ab0c3be91c6f126e1b1b9a5f0cdf28e2417770727a24e660a1a9b703d35ac5f71b44449a090833783c462aa589d0c87fa0c250995c4948eb34748088ce26f1a7af7febca91d9389b54555fd8054fc08396326db80f46c41d07dbde160cc9a0e75d9fa9212d3cb5e75f096a0deabdc3c9d99239f77f83e3453b03b840f40de701999ee0cef948bb4de98133be2b993690c04cb1c8d006d8ebe29989cd105bde32becf10cca6885b380d627f7fcbf6139078c1ffaab8264e1c4714d2674fdd70ff4797a1c61ba6d46eaa43d7c29d1775f63df769b6074c9e654a9634e4d388081be824c0b60d4bf3939b27c65b848c68cc395d9a830835e90fcd252b9644669e6b14ac910f6286dcd98183f7b5ebd335f91b740f3ae9ba53f69be129bd41cee8013d2cefb7d9c049be9343c5997712bb538f6f698bff586669ece77b77972281a823c7038d96d871eb138d69e1dd8ca4ab85b2d4756765e5181921a0d08c9791618829da613cdb3022beb71f150f7a61c2fc60ec12af291be5b7eb9fdebe9c16b711c0ef9ef04755aba5c70672c021367be2d3b7bda7442e614b8a2694be6792af77c2feb559ea5f18c2e550074c3ad4005bd7a6c9fd27f88e284e430118bfdcf033d4be6d036296a0a6cdfdecbbc594feb904d3410e62ca4c432a1499d6203718f452cf50d9211450727bf4be612cc2d33b6932a89731ba6a2af1b5e95fcf42e1d40be023a19d13648afc59445efffe901845248dd8ea680c6b61559dbeb699b95f8beb694b3d4fc8b7a1e73cd162d6993d528dcfcf678e0bf9cb7cc1c1a2aa19f19ebffaa1ca4762782e5c9f447627135daab9d3a77242160b5ef1ac51efc845a4070a7e8bef19db450866a28079ffd73c73dd6478063d27de7409d6720efe7ba92b7972b0bcbeb42ac9d88784999896eba41c087b2ef8783bb5c2635f3cb6c57b133f75905e04d82e082cb2963b114fd564a3edd38d53f9f4d53c81c21dff8b072e0cff00395d99077260f78559cf2abdd7718cf0a2cdfd07d9d4ec8c0bd1fdbb5ab2ce3ca710683f30f452d8c73d7b65a0d7e25b0d8fe73fc9836dd9d6217e912f2dcefd284fe23343ef95bce9ebf39943d92622d12c603bd613387f50e997b42ed3d50f7da904c1cb6184a567c33ce79846bdf8934930db235512ac408e4a3674881ab1a219a54385738f1ac64a87da1a73039dbfb8ba98b87feaedddefc47b5a9cc639d2848aa92a27aee4a00294b5dab58c66278a4ae6aa40d0b079eae4f0ab016816cd602048b1d5fa1a1dfd84e54b2b9dadce032c2ea0cfaa7ec64de71f89245f13ec02ba71bb5a3e10cfb35a24fd6c62a9548d54efb645afc74e26e7b3d01ec7e7be762584e6901199b0273f3822d327ce3b92c21778a97af62836c248f8faddb6ed512b6101b3e1fdb51a6f5e5b10e41fe39440aff4a84ecf5ba4d1ea4ead6862ab2c5d2ba34c9d120bd268896dbd4ba7a56a58cedcc11989c70b5796470b37078c7894f79a3cdc9f94b178d6801585eb2d1c058ca51eb2460a6350de1de0dad4ae93af4a5ddbac023141527e6e2118bfe5bf6a28adb8764f1017eb5f99a0cac50a3418edde682a096e6591b6dfb6a02c677b400d68c4a1ba416853062473f5150fd1abb0000048caf220ce41e9e4f45033299641781ad9b34ac1d25fe70163c0cc48585c6a71c8f9f3b102bad7f5b995fd6930d3ca52fa2dd948408fce48b35ed29b87f743e1ac429ec3a8841639855f1f3cf19983d9cecd9bcc37bf833ca6118c340f8d6e601d70de2c2d1b35718e9ab86d91f912e99a1aec378c9f15f306e01e6c8a9fc111a913a6a21ecd50d190681277d7043c6288b473102a71fb6a65ef9e68787988b63653aa42535d69a86771dcf4e74bbb3ecbaec8cdb3e169dda2212433f5b839fd9a1410784be889023112f04f57a14431fe048b4dd8c93d7247b16a419168a79ba610b5bc9780bd9933a1976b0ac57db4f19fdc55aca0020c189233148d272a69b67db4ed71b1b2f854219e9918e338e0c147d72d29d603fe4743d976fb07b3980ea1f4b56ae3e8735cd1d3d39a890675cbe9a395ae56bd77b116fdbe02b413ccc9f0d3872595e2654883740b2f5c4a14e1324693bdc5e64648da26871020b1e0fbc14b4dc73a5add62e4f5a710cd60b7533916fb3fedcf7e5ffa59d3da97b4e9d4aa75c4ae51851df71667b45414dfc60687d4721429d7e522a6d2b5cbfac51afd99f1333c6e951e7b9b015ff28b11f4cc77d04855642f9b40477accbb5e22129fc1e8f05c11c5b9bd7b05386b49ec8938672018918e147450f2bc1143436acc9273e453cf0d5ca8630f4458126a3fea7f6bf3eec8e59db1bb6b5363d38b29475ef69a35c597f5ab33cd79aff24cf7e0f45205fb553bc0e5bb653e79003ac83571b39005f5a80420548ae52a0037cd17d35c9e91b56565dd2738d6ac6882766cee9c947d6baa486fd2a63c51c345cf1fd8afc04d8c016f6c8a513c183a8cd629d0f341236924049abfdcf277779f2eac0ff4482c21170a4be3fa691a403d03c72bac62967a5fb81df16a23ab3898452a67eaf27fa9ea2425d2d75ea3bdfe800ee50b4b12659d91c1c649a4cd94862027b84b459c4b0b42fd614d6beee551c673bd00e258daf366377f2e9ec890b3286d4b331f40e7e949cc7bd3efa6b11f322f2ca51e80ea49dbc40fe764493e1e3b3f443790d21f089a5fd387ee37ef72fc76c21b5526466085adbaef73c793434be150d0d3eec8dc6ca462baafcf62e151bdbf9a13b85502ca78215232d82608c61578ae25238117aa9e9e8272796e0de8fe549ec14ce0af9d4e843b98c556cae0efd170162d816ede9e41d6254a7045af29e1da41e1c644559fd86a59deea5b580255d2242f46174aaeae34619b78a872134e36c8a0531c18159bef4a9270d3a5b32439cb806bfe862b47fc948e70b8fbfd9b2450e93b8bc359d90465cf4775190c0d105b67ae0d9999679f09f7a3e4f92c19aeb2489bf1bd09ab2b51e4614d6895757a51094a1350013885ba7ca129f89b12b0562e0dbed3328663b74d48ad34b14cf3159494736c91740ea0d43ffba4c132f827f0e69606001c655f684b180bbc1237f4b6ba28864035e1fdeb3adf6706c53e90772f860b97f0f807e249c77f5e2c8fed5e059d8c227f3319b443e3a8cb0be3610f3c80597251b5dc1b43e9b6df08d2cf6eab4b5a92185eed4d84ad31b7de3590a5ba41bf51c04f163b5850e78bcecc73844248cfcda18bd7af5dc9f24564b4677f02d5bd27a7bbd773ab1d25a88c8b933066cb674f38644bd279f36d2f4750febbd3190f3e7db19b13e852815f90c392f56ba2b4ced03fde01b1f31c6aea5c61cf0b1836d3be09bc25481f0ad4bbae482fa6fb4019445c60f359c98a16c1e190f5d31359de67dee4c09c762824b514d4dc5a9fd37f002fe6d47bc6222e38f7abd2225024d28788ade5e167d2dd7f209240f7e84074b8dd014daf8c1c02b0e5b8ec1219bad9476a914a112524d53b53182a04e9af9501f9070814b860e0b2cffb42e60d2ec8234511652dfd7f25b12edc2b1296f16aef3415ef48d039010e0a6f1976e51481e75ab549aa93256472a6ee33fc5cb1917f138d9cd9e029306af202f21fe1727db36a29581ef329f5f55382549133a1619383f8494e75a5e2117ee9999775038b889b240377e861e088cf540c37c14750ab0b6047eae19deb1853c0ab927fe32c6c84fff3ff1e6b1ce0fac86d3ffa5d767879584779cc955e4fb50ab3994e08250835ee5f648a631acb119fd280c5a7293c07759f6412d0ae30f361872456d9d3db93675e05d2daee56d7a98451674f261bd237d197a91373018584cc981051b1874c241d4fc4df53446d96014b5ec24f806fa2481747626cf6847d4f3318356882e01265ab6e01a5f7abbc0fd5b1b65497e67f36a176f982827681a77e3a286847e1984f09ecc7288f45d8097076a69cc96e154b33865ddbf20882ff0e962faa9dc9892ea042909c0b4da19beca0fa667faf9f09394e94c02981dafd5bc04ae1860090ec9fdac3752642d0a4d1115174478aebcf6063ec3f74da35e5649d185c0ded5e23c2849d146ce645a1e617f4e0ad772702b8759b4ed726256a50cd39b603c4e5485bf422e98df155f066c1615c0dfce092ce9a2f2d659fa5a054d5256c9a1dd2ca2a084edc6fe37085c18e2e6dcde6a707882e8973561b57abb4ea357d706b21f6721b80dca04f3e9f037750c440d6a8faaf80afb6356a0571b60406fdc9529db126a213d5bf9a56fc9ba8e7c5b1392a4a0cd3abd8995a55e550f08293d1297a38ee51ac2ed64478f27c7f2cb190185eb81a30bfa5a4c49a8425a29b01e1e154684c431b152863daab7b2c7fb14e3052084236a57040c5468522d931386dd0bd3fde9dc46860b200151e2758fcf5bc8ed9a822449496690da135f81a524c07e5ea2c3457c326df6e8c4eddf42d58dec9625780b8d1407de02df5255601d3e5fd2195cf61d857264f8b1afdebd5c4045cfcb55d7872c1865b1886fb863f653179d500d28bb835b72fa5be05f4ac1bea73a278bf149d14d48302cbfbb10f93080bd86f44ae176c1964a4a17688912c544e3933dba2b3b9e6e75d13ee61fa177367fca6174144efa6f6f0473c998e060182d2c4ae29971e890270f421b2dc6e0ccecc4e8b73ed0034aeabe2ceaae4703b529271c2ec1a6f96e7111880e0677eea11d1d0d9a27ba20db2cc005731cb11f6733d48f62783df44679e2ab9905b045730bca34c9984a5048ac326b60002c8079e55c1d0aff3f7a288fbe3f6db670df09cca8082c071d7b12783b3e930a5906d706229144d2b653eccbe0a6a048be34e588773d8b3bf3261bbf90a7bc92f9c354cc3ed830f8e05812863f96c3ddd44157254fd99e831f8184db18b268307b1a6d72f49bebe5623f75a72ebdb00f890a86c69cb22e990e841647f60482a54e25ab56f5c461b969c978c054198114a497fae766a241fcdd79fd58cc6e3ae7f9de1b2541c9a1d2206f434410906bfc2a8e77e74467b131230b22e77dec81cc25d422482bea380ba353c5373645a8f2a652c0b22ce44fe3871a41b6a2e5db55253a7c6b27277a69b50e3ab6d5b7a1c20d363320ffe4ec0a01400759ecfe5de54ef15a63d4d90651d4fe93ddd70c43f9cb1c4e5ea880488c891887c91d085f0635b48b566bf28cdf1436e8117bb4e5b1814360c00139f9525a2d1d8a7183e83697a22891ed6141bea4e29bcbbbd9d6104a01e86121e558962c2e9bf2a7995df1da13a8cef4679b86602ab80a4bb664b9bf46fd884da56bfa5712528cc90e0254cafef7d28d2d0488fbbca8727cd55a25a50babd7905308939e7ef6b4a9f3fa687a30b6e13606f69d8392c5c356cc25a4169f34655bc08116eea503aa505edf2cf3f589d20557cfc4a9c7437e9db580c9942d6cbc978e225f5297eace1514d87859db7197cccc2c9e030c7318a82b9a6b08a9d58bc2507c02f13a7f7c7d659960221a644b15457e2b3798ec21679b9ac8bba93c8acad1d82f8f90fd470afe829a5d9e94abd9f51b0818227d2ace01863aa50f409817a3d01b91700eaa22370e6927cbc14b0954e01828357b560336d30ec3cea32f5702753d217f2b22973594745ffb57a1220c98efb2bdc2840a460dd943a3235df36b0fbc1a66b6f6b00fa57e0d5ba9031111ab1e257d3ecc98c79eaa012b831786901893a1959e2e1abb27061cb2671135afa55d3c06f70aca49801d1912772bcd52f5165219700be90495450b528bda4570bd96dc1921efed1eaa8ca51404b0b54b99946888f4832b25ad03c3a053fd507cf5c69f40f04750bb25a0dec2c2316d366bad98972ea700644243b46db8f605b0eb83c82dd1da23ed507f751f3454e4d68cd726923bdeb27e2f815056e0203b393b35ed0c5733f3c197d08979228aa52eb8eaccbe7ee565421d826174c47185c3ca3b0ef4fdff4fec98439bf45274ce4e9b63c14298729873fc9a566324e565f219d47624295fb12e3684d17a48e3e6019bd7c5952203f058c8ae4e7fc88e41790d9433be688aa997a9a7d113fa06687b3e1b28f22c2af2ce88fe098fce8e1a6f25ccbf7f6bee9e275305dc0911a131a595711e7bc04e0e8909c3b2466c11796c45a22b189925b45dc54e5d6dd80934aafb20100e00ff8684e5d65861fa9dded9c24ea1ff34f66b3453e586336f5b5dee703042360d6ea14f2e46867b01683b2f4991228d59d68382e3b6ff4bd2444de82c3fa74955b07717563bf3566c9517044c8d7a5f225f0e6ae50985d502c6441434bd79bbfad7c641e2d1789d752d6f92c97c73f147c7ea686bec5e111a8e4b5b0a307e4e8e78e3c498892f63e40d83bd168cba802030954305c279cd87652b6149b86cba1398262984fd47383ef8a5fbafd35b7853e2e3cebd05dc3cd596d6b30f8518b8ab933672002e830c99545897b1ef71e956d84e6f66f3cf58f89b57fb8756f30075bc70e83f399abe7e65520aeaf006001b49b7898a8889a51aafd2178142286e79a460fe66aad7c743a82058891d07f45fe6c66aa4a006bda089f2dd28135612a34cfcc4d7e34f478b74b573680f5d6082f3aedaa334c23a96e04f45d4592833c9aa50c6beb60204f6c292ccbf37439d86ceb656ba6170c70cdff7399f293931647220586cc590fc551e14e2dd3472bf51553fe26a9ac49c9ca35b5be8ca1d43cb95d69ff1430274756ab0c9b2d2f023918d8e6e6229842b43d6e34ea451247feccf4bd4305eae11e01a67dad73e4860008718eb63694b67ee0b114e675d4711c7d3655117fffcb94cf94fad9e66043baaabebe2846b961900e0b7aa3f75bfa0831d7e2ad19396338c287880e303df1e3012a8505952cd5cd3ed145113bb5526673e252477cee0d8cd7a0de3930ae6b698292ce2b611c3f7beaa661c844a169236edb325c15520dc4aa31ef1155e3043a2455d532721ed499e5f9067c0532dc6b5bc76f3e0508ba001bc69077b35722a9c72884ba22a5344668e4717bdd950994c24a41f6102a12c3db30b8c03c174f4ec15863825f7e4a64985fa071e7018bf9dee315fbf89c1348914062377c15a2fe3248ecc68e7dfda7263f8b0b1563fb00acf722c5c65c01698aaa58c3b319d2e9d482e6d1e6e7839a84880b068393f089254e6d154627a10d8b07deafa14c343adec4bf01cee584bee73d9ccb5787bab801a07cf2a9a5a52029db73328603c6d670456e4891448fa1574c7b18809e3a45eb723b8c53cf19f7b50e2699b4e971b21e7a3eea4d08ab6d81425996208ab4133c636bfc4789f0c6e8426babc4d774771c65cb728601caf1f030e483d78234c5e3bbeb86d66cd96dc8ebc0023b92a7aca3c221964071a61a0174c36bbf19ecb70e537723b6f4e517cc3251b48d68989547c40c29a8a93fe7fbb8d2e2cbb4d80b8509e1e20722af1d7173d1a1a66bdfed32320840acbe1a9ec2b227f0240d93733b9946a8a9ab22ebe5e6452625a5e70fc38f82544f580aaf4db519298ff3dc885f88a8675398a3d86f2b542bd177960d502335ecd5807056ad182f8045dc787a6a34e0bf4c2f2e0616f9befa5773979877eb4f42a0d0a6d283a2ad7d84cf8d7f2399c24b135b392ce56bf94ae0b7fb370c4af9387f6b5416b5658b27cad42fcdbe55820c838ecf64956dc602eca772af979936f290f0a6d6df1e70113ed03fdddee9f67692f8d0686ee99aacea4d65e88d79648a7068baa2ec70705ed91faff12effd27c8e7d818bd4294f7f645d752588dfff55cc0b82c10ce3ac8641b4ead7414999dc3c900c07575a3311b3a5269ebeb2ef2e387f74906c2ad8dddfcf6827f494c0571ad383815ae79a224d33ad280d1df37e8c7bda339d56dd5123de892e6794ddc0c898155eb575ac47a13a81c92af1aa6b54acf09cf6bc066fffd670cdbb45179b8ab048db4729ad1780b5ab289b470e3a8d94e157d99c7443a9aacf960f93e6dbe875e67d83721dc9949c1cda85f6824c19a1d1622cc6853a8f812bd40841080876c86d60b132843462bf0b233908bd309c69ff7efd09c4bb5d379c84302b7478b95d9f922e82522dee9de2b0f1ae8901029abbc7be6d6dc56c520a8855d07fb210c9b19842ba0f4bf235ab70877b6fca2675e9a305b489a9c69dbdbe0d8adc1719fcb9279b05baafc073adef61cc6d79bcdfecb788e6a310114c706fa8d356f8d8a23c40b7a34f4f794f522454d200f3161dae5bbf0453269bc3af4bc823f9e7563136f12b720d326c344e364339a971c50f2b4ac8f3750916acf3c4013149bc06797adfd679f578227775812d19da9b7987b4866506cec19878467de8921b498fab7cf3a71ee935e6f6cbac0cc834ef85db02dd522e558443828102708f78bf995e5c41c456566353e425f15c600b7b23d29c5a34007c8f03fb60eb682731ac1e7b7c07931ba1183bbe948f050d65b0d254ebe631b6226d0cd5d16819858b784819e38fbb40305016011ab779c2951807261984a58118298cba49ad4de196f40b8b79ec8665d38a7140acc845014f136d75eb8440ba3a01fd3373aacf3f59764d48950287a97c06668b8eb9b6bcc6d5b430fa1bab1e88f0fdfcfe81b4cd681ad4eda745e2cf630642b6bc2e66529b37718396dd6e99254fe6dd0f5b171d5513e2fd78df8295c64648fe3ce806cf6ca9243b4954b368567202518a9c4685148a368df9a55ca0495e53657034f7e09191ab05bf232ba89913e89db4df41d0b682ec7f4b8fcece23a76a4c6821b3bea0b3a857fbdc057e0f5f5a8d6b56fa0320256ce49ef9ecbf7379769f838bbc9cbb3831077402fabb0f1ee6b949621a7f9f25b319799daf7941b9d077dbae41eed8fca1b2e80a58133a24e4b1b89fc865c035b96663213de945bd33ca1ceaa149e0116ce298a61c3b32662b8131c846d053df80e697f8e5f8df5b9515d8de8b814eaea2581e8d2474936217dd3229845d8c5e3478a9cf16a01055ca34cb9dd4fc73a4248cfe68e016db4ac300f6feee48e4ff55e2ae3df94ea5ff8409557f8cf2050dc7d5657ac8eacc3bf28de9e903d9022ff03e1ab83fb4f2445bd209ea61532868a12573cd6198abf8635b66e44c08e811e37985d6f07cd4a955d1e7f0e90a045829af9e27b91cd6f1fdcf2a6a47dfb4114785481fc33138dd2359d2db26bae8357225d0e3871e0963dd6663c57fd766bc8c9443916e62a84adce40115ccfd6cd88578209967f7e234b05eebddc964e24e1422deb42d560bebd3c5fe4cfdb1e93463bdb1fd2a05ae3daa9861493ae4af878e978483df4d3cb0f032ed9a82639805c5ef617f6b8bcf4bfe9e9522f28356854baa673bd64364f167785521e769f8f5d817f36f7716d11cd0759462455fe43fe47b438de52ff9c5bfb5696b5265776bd679e62c605c47381325d8e37d8109b43c9605604c7894e2e7e31ee32b9e70ee7a0dc8c2c6d8cd822e1f29194ec7c0999ada331a6cd95c2cee6d9b100276afa31aa8efd367f27fa1b85e3d5fe0c5c6142169a20eb40413f693e04be0868d2968d7e77908baf05f416568ceb9357deb035ee2c1e1b276c0ce70ff6b3f35e027b25b2e7f78d90ca92aeadfc23f2fef80fcd79e7102f072a0dfb37f96d4f231795a78211f4a6dfb825b3ff5b9a8eabdca6256b8a2c56bc1150664fae4669a461c1c5908678b0dd80b96739b42e689b01e12ad1cd99eff57030f57e8fc8db0602eaf2983184f7ee4637ad24885cd88a92f7ad2757779bb619d09d654c6e3b69b91b7746461b4fd6f858d4db919c9573a929f67161bf79dcdfb43f20ffe8cdda3af0e515e5886b9e57d377214bf4266d06d73df3922f30b6020f9f4e5c6a89345e9257c86f95403f014652a4f10ec6de471758849921d14d897fac2a5022c6be810a37b4d9623ed933d1cbad8eaba72b13e207bb536c7a7cd66eb14b81ee399738027edda8ce179c683f9b20a84827be99e5953f2b8548491d0fcc88cc828aa37089772c28819e380d238382db973fe3f66dfd9ab1d9ff34b118a893671b32654761edb9006e6cc26c2fbb8075c7420f120e0000f4a9b406a534f7e9b572226ec9d53c522977ebd9ba529bb05197cf2dd566f3a3dd990bedebf33e173e3e1d940ad40f6bf0e71391d07f53c6df63d784395979b7377afe2285d1ec2a4701a925ee0da15143d076cea2d7f30ff9443b2d51500b251dfda8469a77481440ec9a4d9237f2b3310df473e70a3cbd49ac3eb3ebb83656238fcc73b9fabb7fd3b2ab070380ad8cf9fa46496db89413a6088d9f2cb1ec188de28c329438f2216ed4f13812cd6acf387fd50dfb79f2bf5a3c2fdfc6ebf83ff5a3509bfcba8cbb6c2ac16c24f36abbbe6de3bea7a5e003c1ee2dc0e4fd98b0e1bf24800fb99ea784afbf743d81cf3be65e823e031c0f1b996478cbd0ed0fdacbc3b15f6b249eab162937bb795e0e9e2b263444e175ce302f4857981a2d471f3eed78f2edd332173388382c87349e0b3df2801eb7771fa232de2314ca76d5ce9c167243d13506aba17dde24dd655f9441a0084432fd68e95e576bf4d561bfed3d7e87784cc0563bbacef50d9b4b5be5dc182d932131500eef8999fe0077fd32f882c58989f0a254093936594e0ca1b93fee6b62ea6be4602f9f49dcb546dcffbb9e7df89abd317a2ee5ac415f54b0d94fe1ec2245e2d30962fa26283e738180dcb63f82511085e218df1444ad18fc8843359abef1f020ab976958637a808ef5f77f833db41b67dec061f6195fa34dce8b82839d233f186a079c54c747c770e7acf68a8dcc9b3333024a065d03567d062c96b4cdffb1000e53881a9a49b3c0c2f1c2908d09ddcae86f98d28e63e59bd7be686e5f258d73ecee7a3161b169839b78e9cf87b7d3dc6518ec10ec081bd5e8109a12d79aa4c19243c0fc672e452297e6b17d7940a03a147c9907a3abc58d4e375646cc6eefae8e56ce7490051391763b5d70446087d750e774dce102439cd163142c1e3b8066bedbc31017fd3fbc575f48479acb321e4a752b68743f24e886dc76b02805f1116d3dd4ae6fd60ca933db58b80dc6ece5c2c8d27e7f2db1daff121887f68a6d3cb8f0ccf9ec932ad88857b894c8e1967e18406b3434dc5e53902811b855089271923c381cc30a1ddfe4c25091e07b8b69dc13df626f7790ca5c21ab8916c504b7209e4dd0ab9194e3f83726994e564b3cb4f64ed309bc1318a82e9fd576d6d3942af7fe63b13f208435773379399f97e69eb737613c95ea7911ca41474ba33c047bd80558f91224277feb367043a1c4a037296acd5e600b82ed910fe0b489f5fbba5a4c2c7672e70a6b35d0bb0b37048b3da42823f04b54ef7486291eeb0a2d7024153f1b31f3a19b3e6770e5fd49dafbbfb159008843ce32ecf3b4787ea8c6a23563cf45138e0be8f61e333a874ebe025960834e8bdcdd23576e9f805c4917e9b48ba9edb9045aecd72cdafa1d017ed4412a0504f7caafbe900bb8a6a76fd0c110f892c4e198ea17ef48f01c3db34df764d7cf4abb14773c33e64bc29db17f300d3cb8e2a595b8b1abb6dd8caff28e657f0c2fa76e71615c9cb3cacff0265d889ec2b28fe92dca43e55017227f5d00a43b4d5e03006d600d3c4b45bd8cc8e76dc5cfa96fb1a5992d3bbdfcfda812eac4dfc91aba4e8298bd4ac6bd3d71abb6737b4f601bafd598b5d3dfb215ef2b3814ffd580e0716d0393ad27cb38cacfe1401ed89b4ca6ef1be101216755b3f1bd97cd38843bc41ed3278154ed64368971f5588855b7c7d1ae1cdfc39451697f03ee65053c933062985043963e07db","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
