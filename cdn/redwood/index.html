<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"da8304bfd8086cb68561d12bb5737b4a0a0d9132c166228c368a493e9d585e6f472c4acd165746c6567d5fc2a4c9c2c6a84acba56eb119bc7fc7fe340948abeb2e0d617b320dd9177f9c6e98a9121e0fe416cf13cc6ee9eb52c81524d8d2e8f1e1bdf3d17ba9745f1211cc8a98811e0d7a9488fe934027b1dd27071fac32681c430e20c15561e92f33592137a414101f8c165d0c71a04fa2d9125228e07823a763619bb31a9a71d66f7f31f48d8f0997139977f84c5e8e1d545de826e42b54fa9b53e5844cf385ac4b9f0bca874105bae3db6d99a01692a5c7bdddafa55b6be0fa52318f5b0e1832ec320acb8addeea2d4100a7bcf751c95429772ad4d96b33daa21d289afb12f652b83f6b8c909e27d221dab5e52843d78d7f2aa8e4d82f93f01856828b77897f5b0382b69a39ca2820b31ebda4b11d296d5b672a3edbf3a3163ca6e42dddc08f7cd0c1d8ec28cf7519bd1ba87812cc0b38b8ff7a995b66f8dc5d573908b50311f49c9255c7f1986109c415ec8f87ed976c19627719d8f0ebbdacd60704966ae2c17e5c442eb21f540cdb61c6b7929281c2b471b67536a0fc8e0c681a0995fb75662685994ae55ef5699a0f582a46945017aa3340709ee2c407b2645fdf9f3e5281f4f1b9301fa6627d6feccd3042103024ac6751a8f0e14ba245891c9a1d5192528ad2f3bc9ac217832a33b406c042d80944a935329ea25822175a032c520b055e31e5613f9b5dc27161e3d6a1791f3932f786952cdc130afbb66144108a227f2d0360bf4f607201fc79ef3b33c3922e77bcdc4ae53e5f7083dccd83b92f8cb9a25ff3544df96eb215184c478a5b1c9e8f2bb7579bffdae320f8d7e7507f81a71ae477304a03f0cc71ba528f4215882a97dbcc55ef26f47ba3239ffd1a5a99b8770bf71fe5dc2fcf63cfb16b1ea7b6b5db8cd2cb937469c737194580fba85d6847399b91fa75c261ae14697a4e79e1f214b3a59d7dc9d9538286b9a16013d9d7e27aa011ebe1192acdff50f5a72b8dcf2262a6a3fa6bcb23798a30d5f4e2f8ce40dc2c5eee04f819eb1d706bbb112bca0876f8df2d56fb38f6c52c810c031032b21e0ce10094cab74f6aeafe54ea1d19f6969085a941eeb815e2f311d9115045d63ca00ce817adc22c5a70bb317783c1c90173a125585037736164e3e44a00239249d512e87131d576bd04bd744d86c469d692978a42ecf0b02d0478f96fa23d5d03a96914ee4a789b163bb56d418d568eaea5359322b25a935b20f5691745ea6fd86653d3b4a9d2ba360acdb60f6a225d466a36a08220e9b25652f706c49f0b464c3427435ea0e84914a01ca83bc5d7e791cd5e70336da40ccaee20565f038327d442844aa03432edf10412c9e1892b6bf1d48f5e0be8d682d638e4a09d6a46865bcf58e50ed5dd7a5f87baa93c85af37a3a3b529f5a3afdda80ad12aeba973450559660c5c62ff19858be7ed6a7c4444e62238962dd4934d234e4ee9db55bb4b208f1612e057af089300c5beb77936a4f2988d670ecb286643f470949670455c03b9a83f9138a2ec1b627ef1fef69657a63167363816ade2253d6f9c3d77c86e876a0eb74df89ec02f8d207d4ce2cfd3feebd338ade810eb3e9a78826886decd8024170c3a3f005c0dc3e018ff40f7a911d19bcae796cdc179c0f69c666fe7f1b7e01bdbf4818a439c0469fc6d2bc24cc2da54370c34398367a69e68075267b80a1a39309e42d2bc850e0f9c36dc0e91dd9761408b9ea2b1e1840c28acfd1dc00831a2bd65e92a03fb291f8e2e528be5ca629eade8a82bfeab3ed2b029e237d6ce066b3b209e3f9f19ffde9b3188e3b82ae43326c26ef0decfd65b4ea172535f3bef798147736fe581bb89eaa5dbdba74ba834bcfb029564f33be6429487c3b41558a3a26636d82f5a6c36a32c54e2ae07658123d2de65432da0d02c5f98cf234a7b44f57658e645b8749b36be1c8a3420542aa5cece5806c16700d48f8350b04558b2dbab0f5bd214e9f7cbdd12ed0f49ff9cf48aacf865aa63eff2cb69151325aefe520529955aadf7fa4a7c51b3eede4f86c3340dc9b01fde0a03adfe9d14605857657068904bd7b18f82497feef4578491aef8e36e85d85e8c0c3b0563b95fdac089b7225904f0b781e2f483c6c97699844b9b55de3c4fcfbaf1076f1f4eedcda8a13d0c8d5bde412473fa4b62f9aa2d6da7f7fe227ab2c983900cb7fd8ad5ddb00a6075e79e4928a83a1e15c5864ca1d0cfeb4de4cecceab35227a04a5283fd3fbad22054e7c32803f234faa7363f175aef17f9d22c084cf1d7e34964df3081740e52d9d95c99489b96ae8f31fa1c7472c7692aa4e7bbe1996602d549c3f6fdf0505f57d4082dfd45bf1f1cd19043ea663463f100be0e7ff7659ecffa009d8d73ea8abbb632d04fc9291aab54fccbc0b14e55e43677bc5cabb17e3b845014c67992fdc4ed955512e6e417c5dfe8e89dcf915687ddf823e357034e7cc3e14df035a8cb43d2c265796c7778fba307024d9e05ada51eeba75a701b3abbfe66a968a339eeaaa841c81af765f4d7a2e02d936057f9116872274f3ce762402d25c1c4b7234431fcccbb933532181a5aab8e2f710302400c45b580478693565b237f65cab3c80ee720123c3cff9e7040112df0740e292a872581013efef44ef5c7d46ac2edfef3f0839be8a8c24dc52eccc3246cd91a40ce0fe4c845f72c1d678c649108aee6d20aa0bac68d12164e429586dffa415c4e0782bdd5ab90c8bc1ce78451855eba289237b75d6f4528117c7b1f436f8e2ef8c5803e1e779c1b94173630476b785bcfd09bc39ae7e3004ce9182fbd37c92e8d7b2bf4030ee4595bff2642016f7fe78f00cf47e71b90938a73507608da18ce3ca075db53f40830727e1ee230938d62b0e621fcdc7bb257ad297e09c1db5dc5d1edc2ef12b665215ed690447c9349099189b4699ad34def549a687352cae878942076a2e5ab986120bf4fb21ec790cb6477ac05cad8c809ea4c73486145bf1657eb9513295aff0f98bb72dbc4fb2a888f7ae83e1b6ee5f174c11a02409c4c5bb900c0cd8acd2f0f63e6c1a76990a47d4322180cec3c40f30cb21667f915c0a84a61499807b4428ec26eda80f96c7f2bf047afa3b5ffbe66581e2e602bae78dd2b74d8e5fb371d5d090702ebd8bec2bed43ea665d859b2d915cb11439cdb2d37dec51a7f5778dbb57a1762c94c4c7b0d3b567ff89015fd4d1a3c7ccff03a10afb1cfca7f45d5a1ac03b17d84b58067e3cfd0d2ff84587e47b92a3dc9c4d9d54acee2eeaa83e09efaa12aeb4350a06b5267398ed452f1232f2babf22b4fd1b0a8e5544fe7406a51c2b06b3372d018a3a8feda2748ad02f771338c4a40ddcae2e3f8e9e568e73e3551e8b5fa17d87011ff0a81c12def3b6852a7f19ce8e57372a14d72eb69e4222c54ff0f093e402b98b61de1bd6ee41e332ea62e69545dd9479689aa2c22f92ad95a66652b2262f4fdc8627cbcf079df7548bda6bcd4c144e0a23bad30222e9cce68a0e99c03816560dfc8655511c48c0419e7c3859e3c35d3ac970aa9fd2a74fd8dd95f67f93897c2f6497c1b2bf47e97d5c8ff53e41c19a6f384a26828984ac7cc61eb6cd3613f496a51faacf5cfe56a61ff40791db5fd28df09f6900be10d1894792eccc8991c510273b0665a505e47c08e583fef224187d9fdf5ab338cdd2240d05db33cf08ee70640cf0f32d1c5d60963109911cd0dab038873d7739be2cec81cbbb331899a2fe508b63a9ab7c33cb25f70127ef07e91b049dcea00fbb90214dcc5f8de54a05362d7cdcb382e4aa255e090f94ff5d66388873dfe30caacebde4d75fff546b90cf39cc68024a3beb26a2d18bf50417a4bab9af44d6f259f27a8f9a7f56c69520994ea4879f0bfd374e4f6db55801c4840f0feab539484fa113a291dcdfdc3f243f12ff4ab5f7c723497edb2d2ef384093d020fe8994ecb6ce3b2276ac8aec38adaeefe640a6fbad7e61a694ffdbafbf64932cb3d10ef7fd400c2110526f8d9d253f89c66a3955678a6bb328cd04f9f59f206be88b2239b132359d28a58c90fddd7e2131e5010dfb7d7bd775c8bb8124b15a7b4f3a8136ecf8c099a380c0c73e0ad91e6e1b44bd48d8b60f8f8017e8c99c703a8963be3bbab04ca5a56aef1ab753de5e8cfb16044d702e188589a2698a003bb8976f8174adc19893796ad896deaa79f35c6afce2c72b8bc1532bef787a78e6ced64536697845e74f0759213e8f3818da1ed2726ff605187cc8fc36bb8d40144627dfc138ad4d3b7bc3f648ef850631896dc3066310a6bef5a80961a711a08c1f03039595f4fbf6ee4101881b3054d3f00b9a4c12ba75a5659af750e98aa8598fe3fdd878432295efe2ab15d8a6cd064f343090a083551ffa177c9d0e162d42b8448fdf396dd7875dc52e27e08eb49b3748a5d3127ec3adeca288f6ec23787b9057559a37a11587569ca1e90b4f86a402fee657a225645352a79e51081d6a5ec6cf0f745b54dea3b6ad49799e2afa1e97f83bbe987b56e6c649f79127c68b14fadb0c3100ed5bb7e7638ca61ef343aef5fb75df368244d3743e1a857b26061ba9a3c161eea551b4167f7df83261f0b2d71741f52300b13b13abfea851f63e777542f5d35b3dc74319f79a85868f97eb32ab47798bf2d4c5bceeaf35d09d2cadec72fc5aa6c4701f8ba65f8d785a1bf52f9d6bfd0b8d1d732224417805f40f587ec3fb4f2dc2f73c17bc37018064c3d9594eb2fef4316e2d0f564afadfb8bc2946b998b13e5130bf04da3ae009e47a7f97937723603aa1da85056f62264b4d4d3cbc73c280c1612619fb2bcf318594225236f80925af3afc8586b1be7f8da0b4ce9f2d061af5dcfa710caa7a8fd83e09954f102f641e321eff3434e006478f04db9dd87f082b1ca754e03db12840a657ddc2257491918409bc54ec3a11695f914e2772447c060e9bdbd2f93e0a17c55ca16a4c0d7d654e1cf826dada35627841ef41f7f8aea38587e0024267ae0b0024b9503e61ad9aba140277b0dbe79418dd705770636cc5fe8b6deb8f05934dde52fb0eddb17fe2d268b5107e691d6f4213a1c0098ed860994a085ea51c286a7b33ae3b0376ecf93c09efad6a0f5004f2a5e5e987974c5d3d0ec7fefce99954cc681c9fbcc4dd1ece03ac88fae2288fe51ab7f350607b6372e067ed4b2115c8150eae0f7f663fa78ec8852df74da8c013d0ed68e3cb459b92ca791b10d527ce2e46ee6001528f09ef7b190b6b013981bc249965c16678fad324e8aae0b2bc2e9f405d4de8a2fa133180d413779c9745c8aef5ed1aefb4694d2d87ed24cd1083c22d68ef18fbf5c2d9d117a9f7382e6c0be5138c2e91d122c0dbff8bfd641b0a9e32ec7fd1a9d746c9519eb9d2be3884020cc4943951db405d390032c5b511f112439ca84c65937699ca2368f166bb4560a74274317ca94b4a808819d3894b434ef41db221e5e5a9358888847ed7b2fd5decb42d334321b4a7a4bde88fc612258fcfaf1810dd908c74c41462dbf382917fac9dbfde1e0f7a4a3c3d7a02825dee5a1f8ea3687d8c19e8d0a09408f4dcdaf1035ed9d17ac1f13db6869df763de4decb5c41f993d2b99819569be703000a12a44e0deaabd39ba1de7638e9b53267464052bc98b08b360cf42e06c6aaeb67d479c0b93a415bbac7591fb0e5645d477a27b66148939536e6d3f8978ad585fadba38710fa2a0efb8a5d834ee05c19ae8d24fd562fc4c61b4a789f5168ff8c8fecae10206651b43305aff2170f988645b080a5b1990359cbf6578402f1a0ea6916901d1c4f4f50438154166e896addd88c7880a9dca301f132b5570b90a0761b5d029bb71edea964a8adae06522269f48459970bd65b64770ac32d6abad69fc4212dfef7949c6d2c7fbdcb0eea6712fe04612547ca50c828537fb0939c54eee3bbae9e2686e46369bb394f29d4c8242dbd9c99c105a5352e963c20e3e78b2113a3e524cf4b6ae791768aeb75400bd14fedebd96b74897862a03cc930ef907c8da36b0aec2ac83a64f1c6d94e9401a035ffabe445b8a36c5443e451a4ff22166e918aa48688b8df97a12ab0d93a88e7eef380708f73e9399a18de69e7043e748e893a4096f059dc020742741cbbbe08368c0b8b67cb85af343c1eaff2dd3f9fc43e90ab8f94f38b230a7b9fbcee351b06d5c3951dc551a516c15f25dcae90c0b687d83ac10090d856c9db920dcf6d411dda49a896013f3f0fcaef119eb93c536d881f78dabf4c801fe87b104427245d041c331df54d5b58ffd0507d925382f8a0d1e9ec275fbee6c5beb67b03adb92858f5d19cced445641e5c5ba83c5bf9a2de04c8110ceb888ceef266e243352d7576290198fd154399cb7d5a4628819d8fd7d8fa10f7bf2aa6dd7b65530906f6f117c48ecfeabd6542a1252447e1eb47dc424b141f2c8e1db1417ff5a3135001ccd5a64c2eb13a8ff2e9210fb9728ec49704bd1aa07d89bbe59ea61de24bda6b09aa895b9a3145e6306273c50f6ea4c18698cbc2defe23a6866ed23ea1021297ebd9dacef61c4b7ca024fb68cef28379d1584cc9d660427571001b970d642486837e620b192da1df1504bbb42744385c776c617283419923b738989c1ef13e0d2824c5183357338a0b1aff6760cd863e6c0dc3e5a534c93c67ac887a9562c368fe7111f9b5cb6aece9044fe99c314aae8cc5c504a4a0d67dbada78a755d5462642dfb2164007109b2388e2d34c535f6196dc2e3906f7ed0d8d9a16610cf66b2a123ecf56ab1713b54106ac071d3fadf99b078ed4d14c0989091fd107183c00de521159f050715cd196613ef14e711063487c7615f228cc1a6db7d9e05a7ec4a1d54d47140db70096d490ce5d2b1ae8c0b6769e53a98c26bd31ccbdf4e12e19c0ee6f4bfe6b1a83217253d734ba22c33f9a0cb71957ce45a9e31819b6d9e50b6af590517683f3f8198c7a94e33a475e3240bc19c9b0a22c9096f65c545346c179a262ddbc980c4112168ae622eab209bff97f6f31b85059e287785b6896efd85cc66cf9e0a92ea150e983dd509de599d3ca2329292157e6c78774f51651946dffa93ef808d6302c21512b218345dd5761a0ed1e7b983cbb69a953669f0572dd7406a720296740d79e3126a4854fc8b81f585af4f438e06ca76c5589e1ebea5d37a54710e50d48c13b8d62226e95012f5198125c37500bfd7986a792c7317a64f94fe223a61e3d0dc16fda770c55b691e618d3c154eaa35dcef6cce748e2df5bfb8e1545950f84e53c9f45e49d05b8009a04d8299dcf3f52a0ce4515dd8c29970312b99721bb0a7658a95d02d139923a9d8025ba1decfdfa9e3f3412eaffc79148bba8b525c412559967d8322a9dea6cc315f48c99fec12c88e4e6e63540cb6182ce8be28ab5fed04b29b93db5b45ebdc51fc77b0f504670d70b197d563389f89a90cc417477742e7e361852c4113760ea88cfb9e850d53bb43349449ecc3da937fbe8b744aad335eb85a5977fdffa741a0f81aceb578579ad39c87321c43966757d9bc6434a567d29792ac82fde08b714803f2e216d161e2d7843b68db4b5df74e85fd552009fcdac2056d8cb8c55a17020455b386c8b2380173697ebe9b338e78aec102922a4c30781f6b324f6afc903f1604707b3a07dd7d9a10a97ff0603d6b1cb25340c9720b9593e1ee248ec4fa36b33d9e3fff550a7a56d87f54ffb27c66b78d7601c869d339e9751e3366e93f2dfc890a49a4e56fe6046123e4e742745ca81e6b5a2eff6a5b1c702f3f57a3616825f6451b4e9c60a71f9a49ac9cbc288dbf723274538541402f3a7c0a528abf6b24bf544bf4cdc23b0ae7904f65f546eafb41fccd984b1107a96fe3f0cdca72fd8e4c26d19714d9cc679ffa6387260f9247951a7f98cb3658ceaf2a88523f38529dabac8b18481c56507a32b4883a66fe5b156fd04484ced5e76a203194fa1a51f9abe1b4ed35fdf1c3bcf95e05fbbbfe192744148b3cd8031bca8b14d775d30fbd7853154f4a1bc9181e39ef3184b51c9b91b2c055b04859d5a1cdf24a553d9a5806179bed9b2102e75a7b08a79aee1c05e428b05e152d3b6a025c4402cc8b156d6c3f3d13e6d62eacb63bb476c11acc0be8a7ba7fc4f0d03c7f32375ad22d51f0ce2273e60571fe1f40f42c3b4c644ba5fe4ad11c7b9d41f6b6dc64d1335957ed68fb78197024b05c9f8b1a72a303d9c71c67a62abd02178fb9e3dfb74f28b3c783f1ba7431bf16be151fa7839a6ae50296ba95f38341819e6cf9682030c3774d1cc2183123e06061cac9b18c579eb9aa1557957ead3599ab3078e1efe549dabd7b1c823863c77a6bc283206af78e3dbf6fe73947b2abe2908115f9d27a7107f1c8f86c8a59cf097b252da3bbb4240678271f1db479d6842bd8c766b70796cf57d7ddb6d760628665a0b4f84e191be8418a2a493880edcaa10b10ebcd8fb93c408ac6c0e62796ef97d8d91613604f8e0c42ee6386691c44c305ed8f6ab8dd042430bfee21f45c245f6af835b6925f754e557fce4e3c923b2eaa076357827c5381fbc13ecae7e140f1ad8ab9dfef531f387005a7e214b43e7c226e52eecea551d2987348bd8c61ac56ab79e20ed22145b0fa912709cdf3215c87011a20a2d5504153276e0a6ea64e248057e29b3e284e9f7ec68e6f0075225763a95b3e82d50b2f07b081eb6665ff8c657f20c4901ff425cb801bb92bc6deb11b562de54df34313f71897916e19c10dab0197cf95e8cd8e2f2eb8872ff2eb1eb8e903975d6ef22a99a05ea9b37ba364ac63055f2f893c16e85ce02c904723ea5f3461101bdf485468fb5eb0535c8afa6cc9da94d03698e87bda09e96b4ef838992ef2c0f24e0ad2432fa339cc3459ab7bdd0fe458aff0d0c7e50ac757207f9c185a285b7a51c1119e845011095ffb5d8ff857319b418f0bbfd9734f0eaa2c7e5c235c089417ba76c5016174fb42020b3ab21012ea23a63ab33936bda4050cc0ca089240beef206095aa2c24b201dfaa10438323c1d7c8cf9b9e1a636c039f1f72c3fdc4e75c7280db32aba40960d3c0b82c03da3e88684eb9896383f99fe35950621115baeeb03305fc865e0fe4f96a99588ee64c207b009f2e5c4ffcd9b3d2545a028960b48a39ca3f7c9937690336e95a4e7a79607381de0981ea155d7129a492463992881a26e986b0536cbfa47d2e3c6ba591605843017879b915b13bc647423611798c7e31da1a0d0ecf780f890ae4cc32ad73781ea20023637f87b31ba1201091dbef35502bc05d9071d34744f448488dbd57cd1994c27509718045fe3566046e4f0a079d22fe6cb7f95c5abd478491d1e74075b4abfd3564e98cdfb3f0d47e5948a9ea6f81c8e4fdfa55b3e1c577eb68db6666fa8bd84fa6fba7541f3e3950746d4f7741139e6107c9e32383ee0cbd71ef591549fd1249f62afb3884d661e52d9356513174029572c24a2f19e02dc21713413dd3d57faea0eef255b57f04653fa68fcf20bd8eada8dd6fc1e22de4e5efca54ae5c9668947c9e9fbb89fec65295d8ed29d85d1e36d1e905b10eb52dff13d968cc36fbbef48ddab1f576211323d905fbbca1edc4237ac670e19ee5ca6f71992194693d343f3b0a2e310f4697950283b7b23d5f119fae7afca0e56382af29b6855b9e485bdd42b933ba33db7f427f959443df6c9bd8fdd93b51a90af7710f683eb815d31019aae4032aa5d8e9d899daffc8cc0d215d3b2afca27a00cf9704b145b65ddbaa1cafee7b5ba5582d7dee84929409d9e0b366d1317217b105efbf4b028587301e435146145e5d9eea5bca16c557869cf2ea1f06e2fd1766065eac18ab5fe45bde7472d1572cd605fea34285b24aa5cf04d4e7e400486d747b991c17d602befab7af40cf05f01d321d527c2913799300f822867858a5f3bd9fc8e9e9d696eda9e5abb707ad2e28bf767a5893fd4ff54975011d9b004750340cab8d8e54ba8a6b344626c4c04c7cbd4a50e936dcc7477b70916123e626dfa94062ff04e7bdd705d257e00379faea75ad28243adeaafa91be769054c8ff1e423f724f58e77ede9332499f2981959066568e52c2b150b37f2414778a84cb69feb2a5d63686c67d77ecdf883bbf48216959f0e284f43145b8384eafe14bd3e670ff63eebacd1d044e5442f3c510f3f065f9f7970039d4ebfd1ba8032c40f394166ce9195d04c1109beed616ab9c462db7a31babd82f420287aa42e1557fe5c6c0938f49e200ef17712120dcb0cdfc8bf94019fd0c2422216e14a1ea8f35461b2f02b2c7251ca468900d30067c12839429f66573b1bdba9ad9be4ccbbda","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
