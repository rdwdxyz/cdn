<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f7bc3f4d0443c26a8815eda38a69ea3de471b42f7573888ad5c9e01869e3197b6449c5fde7a2a46f92ac47dfb38f4d6cbc6513526877665639d52c35e9952148025218f01a1c600ed33c543d8c9c75bcb95f8eb292c96b89602c6e327b06e8dd0b63af73b5673aec65e88608bff2c95ae1f99f1653f036efb40ca5a3f82b248635156d2a5f0b55c04a4b68305a8e9e597f13e31c71991d5fbaf72ff7222583a1420b13c38448e1ad6ba7ec4a0a219b7589701d3fafee95bf3175c3345dbce5721663f155a389d5ccbe4b7ac1c5d6d28a91c336d40d92811867a9114029d0dd055dab6762d1fda2b0d9b38fc3402b0900c689fd5d4b487d7b6aae9cccbc09c0f0d8018c2adf0df1c923e0f77f9649b8ea07862f02ec9a8dfdcf7fcbabe2c77b843519dd83a09c39cba1110a7e1c9bb0c00b10b972ee84841845866ed182abdda4b9cfd3af632776bcb9b0bdda305ee2a4042a2970e71caf09b52ad67a92a1b6a24090ac8da4ef9704b6cfb762ddc5d4cd81c2ed48e9ae638255ee49274245156920c4a7a36b8ca91a0813e0638bbdb8258c6c9e2fbae277b6be0f386e0cfc4470f38b804943f1b9f76b7e66388f440fb08e9a8767b3029a00871e189e29b1acfb1afd25561cccae535caa2d2cf501dc0d96dff6c8a1963ee180db59f8ec7cf88430cbae584a0ecaef90195d8ba1b53f70fd54f5adba5788a1fd974247bd8837566a84de5968c2eae6ed79d05fa8fb5fdba01a8e62a47f4e96d5e34f044c687b8bc11ae6c500f58e2bca379690f02af1d5442c701c9285cd5547996876a2ea33482d5ab5db336b6ff3e800fce15d3982c9852f989caadcb9cbb0ce385a660fb9343f11550a4320e0e0bbf8d38c1ecb70048e85d20efbeb4d2d8bff6da95956733f1e317fbfccbc423cefe3e1741df1e1588f6b93270330493f98381dae08e2222817487114a02da2da5cce9b309783030fb77d06acd72a8b73698bd894dc7a210920c7797e59a2b300c91aa8ac05ac02645d1f5a090016c5b1e9c590ebe38ab9654764ad4e42d37f8e6df477c96df1b8202666b44988f8e8167b5173324dfb6f5a19326fbfd6836ce35ebd514eaa86fd6be3384082af705aa125ef5eb3377c05e2a99a3caca962478d78179ec1e46a79124e7dd8e239dd5f19074b8c556c8e6ed3d4103cd083dceb2295435bfa0cc161079ed00023e69320faeb4e19ae6afbde11582e682c2a57c6f4437beb4ec79675ed28d74c997741cce67e7df11738c404b143bfb27d9b4102a405517ca1d8e7fc885fe94541d8140c0c08bb117a754375b17cc1ccfc57f70bdfe68bee7d8254d961e7114e67d71bad4eaec044a45fb3dbd1267c436e12da10ea986d65f019a81fc4300226f4be8f148ad06b18d921b964a8e86ece2d42d96775b78ef4b02d2de754d3953058af9beeab87f43c3c9ee37a5f5b19937f33bd684c3a67228cfc2f87defa4c22e8b20e8882ac1b82ab2ce813e70009c0fe64b9e0a9d353b175bab1149835f48d90ce391f35185da4959f13040c5597c9f24a8d11b35f51a3cda4a2889efe43bef2dc6914d0be8f5946e8af6052c6c87d9e6b518e058a11455cc1edf44846e4c0ac1db316c8462604694a5704be9309f63710f60de824166cb59b1c104ffbae100aa83c8ffe37cd58bf0f564a275387d142eb6129692169eb5be8f663993a7176a1aff4f474d02f4ce6842d0e13dbc3713cb2290b138ae9a0d2535512a213a1cba7ae602c5e0de4611f93a13165ba38b702d675358ec0f4f19b128e72c388f8f05b63655a1b0a6ac1a00755243129a1050ff0352f1c07c068165aaff9a3b76c1046d9a0546e1ff51a9c8ae314e077022234cc0f1d1fc4af9629accfe82d7833ec7239904e8f5909190ce25013b511dbb6507df08e878214004f1e15ece8dcac2446b334b485b7658249d34f999b9e07491b67391672d74aa6523a705561b85d64b900a32d9e0f1ea50b586c443128b55429ab1b6bb7cd303fbc8e1d360c108c9c756ba16483a1604a24975fdc4b41a17a9b84f37abf2b079e3be8e10b072f64823da71b3d84ee32aea3911736a2da0c0ecd2211a68ec986b6104f02db3e04ccd4acef5ff888f508c78d748b58325c2c7760b85fae19b3989e098bf696280610eb7e62280b784a58a3fc0609656a6f327582fb6eb1356682a25d05f35e409010559bc19afb2bd8b54c55cf797180dd27afd354b219f44d4967d6770a70922748f9ed42010eb553fa586e10948a907ff96230fb7318d17fa4237884723c6c10c21910d53349b5d0ba3fdbf1569f28231ccd51a4cf0c46d8d19939fe60129428998d6b5d3fe9013160da8d62d01534be2bf48b1a99183144d158d46a708bc0c8347a3d81c9fc54953cd80da696a0b8f404048c1249a80241793fc688a8f766a9b7f50904bdbaac870ed23b2dff98c95e824a978a7a01c1e777844acb56ec462fba158f27713694938c23bfb239f7f8b24c43852f1713662a3fa5a91f30ec002eb8a079a98adb9f8ec9c5a8afdf35969c9110b7482a774601522fb9d90c3923529b001787eed2a60f5c9dd821a8a70f30b3ff10476650a826ee9e6ac0a83ea92d6ae839db863121860faf8062ad4ac1f804d66a2523080ef50b2be6c22c06b8a925e5c638e5c878db8ad32b0fc60e4546d3d539dc2aa429b069104101ead9ae8ca32b33ee378cf93522eca144f262ba5c71493eba35d47718387083eed3acba3b37c62c1228281fcdc9d30c7a17afa6d71684fd1af3e899c18d73e64b017f25cf722ceee56b00ee7159cc69786ef76e54889cabaed948c3b5004feef2d722be466627ea3f99c35ddc57bf5d68fdbbb7fa961b98e9721021f4dffc9164f096c916f85ca7ba863803e01f170175e3b9b8a596342fe315da3c1a14764bf0feb004526a1acf5133dd24a7beaf33d78acc315092de155c683849061f129534bab46d4858848cb5bd32eaeb02eb42cdfaa186ad24e277a393a0c6ecf13a282a90b081d2731a6aa2353bb84b2ba8e24299cd956355cf865b9406249acfed7ec10191bc3329cf40c1cde82636f28c6a42c8af991932a182f779ead8398d140112ab71a32573c15b9e50af4c1ae4190bf2ea307104d82b3dfcaddf6f0ecbc40d38ca0c90640421f244e2e3aff6a836aa6933d6e736711e156e2dca081c3c1cb98f178d7e8f1abd0b73c068498097dd591cf56e2e2cbae7c9e35f7ae4544f9b6fa4d271345561bfbed935260d9cd948a85d32c0d30ba63905243d0f9d752ebd5f968500d74b639cc1cfa30c586d7278419398b313400cf907b5b2263dcd0bcb1a9ccb470c133470d394e938ea9deffcb7fa8449ca772abfccea2b929257ed25eb7d12763e2dada4035d626722712eb5fcde14552d31881fe0f0c4a09193ff6beec3e644a8714613f0fc8e319b580bf2a1d94a58032308dbadef082d263225876aac1909790cf03fb514860e97d52c88e4991381e9035b50776f3325f0b0c3cd2fd679231f57deaa7177f44c596caed8637fdd44af676ba486421ac236319abef4168ec221101fcf312c11b92b47f7887d08077f7ddc5562ec659cddb6245b45bf35b5e410a82f9d60164722a929ad40678fcc64d1fb5f051bb21fd2201fafd55ff987935a1d089663600fdf281f9d67f0d452ae2a5001c40a370ff6f0d500e490dc35a5842a053c89319cd2d8363a5e75cdb84b7b8e6975a2045bb35762fc5ff2116a395d2709e78724014d75708857132fef90b2a7919cf6a4bf607c83045422ffd82a4cb8af248bd7c7e09605ab45d4a82325a0bfbe2e21ec2d9ea6e80e39cf99c7fa5f8748121c71b8a98a264bdd00d82bcd8529b0ffcb2615cb44b2295cb457138eed1ed9ef1dbeb0b7b40aec1fdeb0787873e6c710daf84eec6dd6a8d197425b556bca0f1f1d655ade1bd77811bccbb7f072ff03750b26a4570483e35521d7d4c623246cc44778f5cba5b277509587b3a509d9735d2d8919934c7815eb7a415e44ab7e482f0018eb1314bcd2e7635e7a8519fb2dd82e43384c814b8bfa157f0083e806fd3e1f68708180d7ad69163b7ca1945088a39a6285b82358751766d42014d33f4b6bd17204f7bd964e53e49b5fb3c6af5fcb65b31748f8076b87a97f7ce9d246d8091588d00b8b96e6da70493e4993ea4a86b62a6628eb0d9a64c6ac889010d2e3ce0eed2bb6b4a5862bc9477071bfa9ed99f175e1f338bc853f7c81d7fc2bd991b40ea0e2ac3300088f93709d4ba38eb3817df2963a8b370134af5f2640c88c6fe9136980d40e8051cceb12ef2a60dcff2c86af5c9b30dd2c8f7bf34bbf0219183ddb0faa1574141b3451180134c58d63f4ceb2de231372d29bde9c3b9908421edab4d30612f8b1aeb46c9b59bc430a72e4770ad0cf559844e5f78df9b20928c7cdcb9c7f3cbfebaa663f748f73eae60a746dd60f4a6ecde4595066345fcce75d7d0c584ba8884f6f896d6220771dc123499b91fc8018e187e2caf24927e7061ac84e951afd0da6450994f76a784a6e1fb25055b0c82092af9c5e8365f501ad1e5e99ccbd69511d6dd769db4bff78ffbeb816dd94d6fd5c4c16dbfab8a9c6650353eb9583624c6550829e3908bf1203a032d31403114c86b517759d7ee9a9e84a9ecfcfa6b0c2586945837f27fbf12f63b23fe10b300b1fcf768abfae675e8a24b39bb5df263505d9aa6811fabe07f406c1d2bcd64a4b1bdf59568b1de5873ab2e9ab2acaa637cc8eb0329675e369ec5e1bbec2493636e9a804f8101f42a8f1f5bc8515b14879418c4480c52ac3e57c99cde12a9ceb71ca2ace641cb9cc0f2419862bcedbdf5d1876887f1b296839f6392668ef3d537779da00f35e04e1587d1c0876327ed313ffdbbd10c5cda6aacd168601c0ac0c0713543bdcebf6d1a98ca2fd5af27b41182708ceb9e7bc6b3439d65ae8cdb5b84dd4e0d5fe24a5bf8c9596977a10953ebec32ba9add59f599fd8e850a54e580a8852851d9bdd49aa70f1f552b457bd16b7c6c3e69f97a1fa0af8a87200153e6b3fbfd65723f4081f0d4ca9ff956d185f71f4c3718d18dd31ff3b15b2ab3a1d7e6fd29f1b8ee508444f445570904b6d29f45170b7c20fce35259cfee8b5ad8c63c7f5ac9041d3c5cb42a50843118edbb282b454703c593b8e15c00b3941eb470d3576efe763683c13184e9aebce4cde0daa72f6522b07d8ffd3f369447a3e638f9cc14fde95844e130f3605e2a1af6c3e818c7183370a58e10837997cfefaa4ffdabb6c713b93f561a14a0310bbe0f183d15d45aa4f7199b0a194af66496f7aa648777e52bd2305f87e6297595e861610b02b6076a9bb2c3c2672aff32b81ee6ffca383f45992a3a6508c561a95d9b8a327d84f3dfb8bfb577da566fe1cf5faaa0169ff9405e89b2c8eab727cfcd3440c273e63386c919e9736bce02eb9b8efd58f1399d115f6659ed9146d9ec0d86755316857eeaad1ee453ed60cfddb6edb482625471030e16d2509a67aa524c8c51404f68fb20a5ab68cc735b1ece49f0b4ad886f28d4cb5bb577a6deffe45f538bef3b6a351ccae82166ab9ac255799395803f04bcda5caddd0865e3773f09ac1594077f28fb905e0764d7ef3d97c4af01047e629c9202f549c3649982c05a0c6e1c7349798c81bbe3947bd6a6e9cc28a2c4a133806253668cc76b806405bf600cde85774d7433de1d791ba7237ba61382de5dd3dd22b42b5b46f78dd4dbb32d9bfe8811b554a24986dab906942b399feadd360521701e8d72e14264b540c56d9c522344b0ac057751877bef99614bb30efe7c7e46304549e8d887998e1af483a1adcd49fe4c4d5e3e6857fdb762218eecd0cb11a12c11bcfaa7a6feb42da728c2a078d8100402255889c9e6a484788a0e3c584c4ee1d838e588be2fa6a94d5de22738f23086530f4063b26b5ee17d5c6e4a4986f28ca1abf4aa954051a7faff1dc27f9a53a2b3465ec8620c509b93458ebd06703713396a7ff111542f77281c8db39e010c960bee0e79be6cb6cdf98b25ca92f1bf02fd343db0b62e0552b5db066fffce548797a79f57ba37ffc809c9f65082d2ecddac11cba834de23cab8a8263a95ed8edc478772fddf9484cf895d507ce66c2f3b2a55d8da6395101347f1ed51ef052c13d7faaf78c5f153ffadba7daba1bc70907c06e86c6f73c83daf14b58eec43e64fc54cbcea68a509c7dfd8a80e0bc3d951104d3b14de8ddbb36cb729671ae7a7d90996c61ad4584f870abb9d811e71236250655ee0ff252077c9ae93c37c6e2143bb950834d4607e5f623192ebba7dc6cef3f1561153c4a3a96adfd9b2667cfdfc1812b3728cfaef2fd36847e3bfbbe1a975d68fe0b2ceaacef4a0579232245abd51b94feb95856f07d0679de3c91c61a464fb615f5f63b814c8dec3536ca73f43fcaa83f503e3c513dedb9b9335445c0bd892acebc559ca578bca1aa866c19abb23d2b98d2cb6764b81533a945c12c0990bd178bd1738182ab3465ffb6aa8b5ae1b89cd665f54788a015871f1348c68bae05923b4b1c701020ec0b155d51311981c83fe8ecdd1ca9bbcba623f7f12466cd3d044e2b38dd7103d91d9ef3ba4548b6c722d0d10083fd1b1dd194af847dd37729aac457a7e5a7ac7f0ae6e60daf937e22c07049100a2bdf95ebff63259b4066670d8b228cf95e6ea87166d875fbe6a0786405cf993b7fe0b81312bf62bb5c80c5c5b4cac7ea456db4b006d20139e85f31c18bfe1c53992cfaee2b112d3450eabbc6b2afb4b341053d9765e0cdd92626e7e540a4ebd752c94018816e5470ce6a4855eb9e5042cb80f9eb374e10c0905c40b29f3401a6c2247690eb08af35000e840d18ddce8e754761c12c60110fdb03fbb6c9bc4ff8ae9dc3420b4f8b297d33bd9bb862938cb893add4f2d2b16cd36d4ef9c1e3d2bebe599267940a26671126f061e882d674fbe1728d02b26c9390833b230098d6e35e6ed0e303670871023a6a024f3152cd9990c33eec61c99558c32694786d0004afdc6d31a28467c1752e4131fb6b13b0621e574b78bc02c344bb647310c94e9a137637c0c275880307cf8de2d4136bf64aa538a44f49929bea6f7187edbe24f77d7db8c5603590e051478a8fff5c3050bb5583e30684086b2e0e84f1e8d99435f647c797236912608658dffdaed20cd78d25a258ca1071af5be0efd73e39f003f5cf8e6646e59dcc38ee117a86af8c22c2d1cf23169361470f0cff8fe3b42845fe5bc0d6017814f24f6b57acd35d299f51efa227f8969d85dc72605536108c3b8435c3bb91918d3fb15784bc6c157200ce53ad8b7c16b5ba61fe7e3c4c2919ecb52dbc21364178b43f50276757a0a214d44cee43eaa5f5dab5ed0bf35b74fac2c1e68479eab2096b3c67cd192eccb23afcd3b56cc4c8f307788cf5325cf0db544c84920894a46696674d8705481da8ed57701e3b7709e8e22a53cabe9506101dd9e2e00bdbe444f6ec1a737b1649241f455af5231f3027a037fff5065e2d9f52020e68a95002de71b3a9675a966a4263746838292907e6162bbddbf0be4cdebb29b3686658628966d5825e82a4d4a2d6161d54efa733eef058e6c0338d3a373c656a0d9f4d99a80b19776391b05111d070afef309089eee5b21b958a432118c64b0da2c58b5f1de8105ea82150d98cdcb8866ae7f1e6ef29563f9dcd0a1a8e88c08829bb5214cd807dfd7d7b0df5eb72bc3f1d011c69c2e9082a64596751fa0a25d6c79a665bc84ef03175986fc1c4a3f56cc6b3f7d014c3e81e55a7630a6a7ad4da9c1261dd4811ebf0803e2c5410f53525f556a72534acf24b2abe6b7b832795e5b911ef1a65bf0d5c4727102fd2c6a0a9efabb2515447cf80f10710bf92f5cd9a55c7f416074869e9c1b8c77f233ce0af092aa0450d4497c8b2faa76bf3bd1aa0b8c6a9e102e222c7871254ee9f3d53db4f09462044fe458b5d392489e32340e552110438006e66b4a5f49b40ddb076ccd346fa20e8cf74522069a5cc3b000e17f0084fd50bd3c24352ce87618a2f2983ff71cf934f5de972b9ff513e0ccfd642514f8ba423daef639f3cdf5e9defdc59eff7c353781676fe78c1f1531dceb4b54f2e261001d0660279ecad4898ec96ee3d00f1e2d7223ad088bebe904e78d0fa1e246c62ebb67b6f15ae2fddf561d0762c47469eac800804533bcfa685611487ad95008b251bff3d64a621380c68b8e2302e13198f8a41a735c5094b7365b596f57023e5a13123eb31c74ff76ab45ea8535d7c8dae65a58af7f3b83c7100047af5840b16989969850f51246d9b105b3f3818e08a54eb3e9cd4ecd9a4e55edfc33dbca500ef0273b13e970b15bc70dd8114052a20ad5843cdb3d03d99a14da315777ab93789ae436d99e6431f9825f776d8a6cfdb89f4387c104877220f2985fd39e32f60b95f46d691d298e766ca81d2594df17d0e589270c0beb5d7cd8f5e298707c433bbf90927bf900e776c6f55f7a020b0bce107de59876229515b28b8c9d98d0f80f94d327f4eb5a5185a981f82cc6c6754d0c5a7ba6db743594a09e44533d1e7e44ca14ad58dae0372347e6f1262adc7a89c3a240769373475e0319a1be681b1bef6ca19a60949b84ebbad5e943a11596f7d4dd93936971e4ab49e75a10275a89e436fc46d8f1a11820e38b3c08e0af59327bc7ea5f990caa9d495c28704c0a25ec83cd7913878e68c289377a9b6d9fb6bea635d1c208496d7cf42edf25d1255b161a652068bfdb448798f1147c9b66762fa2f9a7fef2562f67bafc994a4ec3287d91c8ddecd30fc4f04db86a64d6862619cccee89774ed1ba79fc6d0f2d0cdd9c1d55ec6f1bcb1b61f23d25bdcc428b424dcccdfdc732365f649245cc6e2e30edee5b2b8bc088ced9b9649dfefcecc2a274fdc9daca0d77a3bb3868d7c3d231a41f51b8d06d2e7637f9b6ad0c8a46fec4d22d7f7e6318fdc6fe2d40fbf88869f2a642c8a6ddedc5679d11db2ad3e5ac0672e6d11e2d0777ae216b52d1b0f55ea6bb150c79a9a5dcf492584a8abf0a72b7569dd904a1c5cb55e7ab1013a625e6bfb94fb3df6f14e7ed9e95982196e059d0ecf5b56081239f66c6a7ff045da2636009942af597510c85d69da86209b64fc11a04c16a9459efad6f4d0a7d3aeca7c7a3f0f99f37a0f6bcc18cafb7db082175808005536e72b5e34de38ae7a08178dc96ac4b682975703c5171c011c55e78a0f3d915291886da28a3d69901619cf0d5f25ccf5aa28226cf3fe77e42cb38788f20e4b2af81e90c4ccb5dd3f675a2180eab509678b75aa5ca9b6e1c7287f54467199fb64ee061824ceeb1c3b8a684ea36023b5ef7dbbc44c719910994b8b9197c8dd80d5794b8c201f0b88fe6048d9171b065572a5ae434c470296622ac565e6537a894d46f1eb36553f292c9b558261d2636fb61dcda8c7dd72f73e734512aac583c0de5ea54c55e8a901e9e73845e7622f94cb1f5c88e27b7c2fd67782ebbf2a54f69fbd36b1572686d8ee644862ff1d8645f056cd83c437d30df325df60704b1d6c29de0ce70ccb6221f5b5495608e47f530dd987e22c23c029a4a1726dabec930421de99ca59e1c26a073f85834584367969db8ad2f929f99b75b58d1754492134bc1e39703c4326199f28fb8095885367d1bb589307f6e815e134d6eabae13de0b5d5d930ee6f5bba212103e51969c3eabc1733bd9c8c7d8d0cf0cea8f8afad3323b13afec544de18c220a43d0d26bebe7d4581b60cda210ae46941aca7b46108d581c5988358a91b6e6e3fc7246644e10aba785efe3e4f2825b0e6378202a04ad803234d55b1f8a42f7b033b0a60a8aa806c188d82cbdca9fdf53d2bcc344ea5a4ecb917a1144559d9b83cf4bd59db0c45678084fa9a86adaaa75ee7650c7d06bbb34bdaefc42a91b8136b71de071403824f0f2471f1843a9310116e62b8423fa17df7b48a89b280519a8168c47e27e311c1049f87ed1a569c1e4c0dddae400443b03f0a8f7bccf2bf132dd1d6fb772dfd957b9fe8c284401df09dcc81a9faf053ff0ebcf9e3fa19ba0fca0a7266c4adc275637119c3a436fd853457c36e1d50d49f4d16f048567913d95d773f47699c343278f3ca5db36470dac37cf1490cf99fafbe19fdde58161dde9001b1282d84b96f4e5d5879542ac5980c975c6abc15ae7da3030332d880d9f1582e568d9966f7f1bc418c351f42f089a339ab6ed2c2a7aeb092d0399ab6e7741970aa9ced9f3ea1452d7dbe365463b8b911dec023c670bbb6d5b0de69804e692bbc34f12f8c9f80bce2747947d75dac7ca2164c0dfbdf1faf4e10ff9947c38b1557eeca1e5cf519256dd0f3a7949fd7e00a0b9b921304b968d92d8e5397af8c68721f6a08d0cf0e214693f4bb87f7a92bbcd37aa6638a22b2fc75db4f6abdd3828eb3b36097d6e3007649e21e215470d69818a6d260e293f2d46e5fe480181235eeeee29936ddefafc1281798c60afdfee9707bc5da0b47d5c2c11684fa09a2e3230dd2f62aab4e21551284ca8916109bea5c6de538bde6ca625c6198f46eb61e36c7c749e1566ee89622a7c87185166bb7d7301e7ac100c930c06079e2cef727ec9d4c16c64cc2434489f03301d34cb3b184563484c0526e1bf8693371458289150895c002b7214c797af8c47fdc5f205667e142517631e4ba94534613314003c84508e92133193e8c494c599a30395feec31712317f19d3d651956228d403fd98dd7fc05c175edf9db896452c08a0eb521d5d37bb06edca7a1cc9b84ea638f457d4ed604ec3af1755ba3df1c09e86c10fccc54be1e8551e60d9a83730d7ae30b9a4aa9ac5041b4ead475c550546c8e8e197415072e14565ab4b7a751d863beb6ed00d6728dc53160fee50e74bac0b460745ae87ffc77a98defd83d960388dee4f05821ce739b8d9dea6f243e13f7f2b6c6149480fcb5eb3a60901d9dceb854ddee78b11b0e70e12f28c26eb33890bce84debce9c35cdebadea481f0c71b1ae92eb9cd0f260a70d142ee6675a11771c5ba24a6503777b63771a70310a605396959d2095df2425c302e4ada9420e8d4c61df85213bcce3f3d7167ae314772f2944af3cf93fd3bf3cdb0108b852214a9f738e940115b8472834afd628b2246e086ebc457865b84b0bb5cf85929de81f92f8bf365f6fa46c324e1ad890d846cc73b91155ee3025d5762bde74e97391039558439ac7541464c36c77916dea0eb1597f7dffbe319fbb68daf25872ab3d7a3449c9d55be529cd24b4344aa5b86427f7d416730c1c51802b8af799033b67d4dc3c94ba6a3a26ac9bca4ff3b1b74a5ce47a13cd2681bfb589c29bef1324c266fac1bdace8b1e714ea076b841865172292a248778bb83be8d4bea38a1388bda1d9885691acad9c767999326347bdd035842a13ddefaa76f18e7f53466f8ad8dac8077ac9762bf9187061027694d48f0dbb84743966be0c23936d72c7ed3a165f71c5ea3cb77b5e1dd33b423bab04d4cbd86fff9876ba5ed62ba978f30ef206e3538c745ad7fff1534327faf88a7166f6b2b388ad1fd049e7075ca9fe192ee9bf0b49f437ed33aef1feca9309df4f5a7b1d3033a401719858b8b127ba2586f9f6a48cfb67ee90cbd11ebcafe404e6effe9198a78172dd4720168ff4c872232b8b25572a8d28d86ad2f032f30ce9705b546c23db35c43e98e5054c19afaab1f508d8e8f3c28b1251d8a6a0be7a476eccd7f3e507d73ae0cd4a7a3eedab519afa8a4b350f9646c0584d56163888e5c6b07d6dd42aa97d18c5fe6dd44c566670f506121b131b9cd70f11704ee01be2c5d4d6aa167699d383675cd9466d11f2d5360d39ab2a95923fa9e3b8a567e6f824065e65435c70fd21c7c2a0d18d1e62df8cfabfa8c2dec24e1c07b6f2435830a9ff2f110c52d1516bc5c0ee24992c9872a3ba40d2fc6d3dbfcd4435765413008d6f453dd0112633e193f32ac548b415d62961f1185ef5a64e5f75568cbe9f87f7eaf366bb29b93e232a0a37bce74016d61743539bfde5e09923a5efdecea57604e717657b5174ae6b3aa66a33a3d36bdd951f055337bd63adf49e5780db8e0960460e1d63edc1286a65e21b3821ed70f01d44f64163d90f8ae8f94c14427bda7886b190efbcacf1a3967b8db805e80aa67650877a52bc2a69526cd9acf27c5b2004b527e8ea5d46e16e6b7c76f6a9e430fff577bae3fa248d182289ac07c9749b0fa420f47c130221bacd2c96eb0a3f291325bb57b0425f1595332c88c1174386ec97d81a41c4978093ae063431f319f6f85068947e68f86ac8e8dcb4dd2b17bb8410f25aec2d1519213fd51f0caf6514da7eb4c1a8d0b97de859aa4e24bf8ee587ca923d924e5784622d367915f43d1d1ab3363452d54e9f4d0955db6f182f1039078ccb02562ae26be01e16dbcfb7558eab3545114372fe0dab4bfe992cbe761c06e218b88fd1c5cbbd08d21187ca6edc1a4abe5f25c3df8562dea1c12e38b81d0ebb6dd9fa6e8c21f7cf7231f4a47d212177f88fdccf2de53d5a4e64ea10c3d6692f6e7232995aaa2372cb8f3aa7ab96d49f6649d18b58b51a37733b1e705a1235b9a7cb06de04e314521f1feb87fb1f3d3156aaadb05b91a9a0941727cc06164683a54d80dcb7924f84c3016d29139a08d450655e90a76ea404ef4c340f3ae7f71c6e5cf4e9803ae86e4eca711c058c5375a738fb04689c37a016ebd65eade87ec3c4dcdf61d644eb383ad9210d501a444b72da478a01e33bfed93b5215565b61fe1f48f29e01197cf9ed69bcb5b182389993a3c5e12987f188295c2fc550396d661320b6b62837f6c7f109fa53178c98a7c0feaf195505dbe642e81a65484e5e70d66a514d600812ac0d582baa3386022381d1ce4edaf55da44d693ae3e41854f8b423b12b7292ecfb1a1d0250bbc30dc2b8d8a5ba9d1050145663a108b36d2fa973340cf82a859cc321d4ebe5f4152acd0d564fbf171614fcd6cb80f8a8bdbbf02db3d41cb7e98ab33dd5004bb74fed41af99f6111172876266461f39b3e1498c14491e74c0997d8d924c2bbd91aa2f3d495e4fb6b0f28dbb100c75a40eab63e67cfd13f5d5a7c5c736a46ef475edbd55689c6309580223649268d71e410f8639687681bc04f7ca52dc10008fafb02f23bb6a35a962b986ea464cf0fe3ad3769f15bdbabad22bdf0c8b6d5f723b3f0262f99c91605851709b75ef8210de494eb58ba22544b9517af6f874ab568cdaa10aa8f5359ea207387dfb6309d631bd561eee9ca579b8f83dbf58dd88ea8e5e493f8e5f5f103d2652930f292b0cacf9a89faf81644b326daa6de11fb963dc7c211193c65605fc97d38321f0b5c715b11cbd2ae2971e96b644a00a1bd32f29020391bf8e34591b9dc81fc770539f6c4f83628239b61ec596d47cc74df247b090989df58781def51d26e507a4193afdaa6b16447a1f9e526d8e677e7606f40c5c050a5005a4131d3f2bc02cfd4d4e944ed0be83fca836193fc1e7bb2f5d4e732e19c6363d8c6db716e00f67681ecce7420a5117602c470582beaf2a67d1d6c3066288105b3b6060611041a517e6b1204660c454f56cddc222d49400fc9a3410500b5b05c63976ba463451fc3e2ab9ff9389edbc93fca1d51b272b7b868340449fd4d21210f8092838faf9cffcdf3ee6b88c0e597148c08621ce5e0e4634753d2337df3431592afedb7b89ae363174b62915c0ed62d3f5afd13da4bb44a928303080a64e287f2827b6fdbf14db78de629f88a77bf1815e41a477b47cfa5e9ba9889405fec6289f4588f3c8b333a406a6d33d4a48bde861a80dcec5cbec04950256f6594b6370ebe6924a387a9f23acb8668f76ec224d76477c461810b46440fb809c20ce07f67c21d397d0f7b008a240ff484b077d500e6be1cd750715c69c7ca52ec86b83c255093bb21a6fdcd023cf8b9f6671ac9d43f5f11cb922c8ea242bdd40226429bc7323e83294adfce220bf1fb4eeada1b226c446cc1f53cc06e35f5d8f9ed33c88b572930afda8fd1535d84da1124c4fd589f7997d82b35f8500ca0a25166ead0e42722909e9acf17ba73fab18a014eca5a41d4803b1b5ee584b2b1851145491deb6a66afaafa64bf92472d9577a52b31d02cc951fde1198fb9e534dfc9ac94e7491271e81b52717a60bdfbaf4bf01d5c5fa1075a239d3d7dad205c88ddea1b028a99fe0081484519baa069e7a9c2773c3db96732c21f892e69366dbbad8b54568945f6c28c69c2b44e1b2c60006ce8092d76208f3ebf70af2081dab73bc571dad88abb866f0d798bcc57d7da7cdc116765bf477a7d27ae32a7915e542f2a726373b0947db4024a0eca90f20198635786537ed03a6b2e5e1b90c52fc8369e1a89d819b420408f8923aba475cda8624ab625076801f4e34392b51de72d7a10c027e0c0e7964c1afa2d785699b48a3d2d51e8427348084d51b9f8de7e53ab42fa85c91b0bcabf5344185cf64756215bfd2ba238861de17641025bf671c60be3898d13110a75373348badda745247b3cc32c910a99f44db0a747b844da2d3799ae502df421b8928e94003e54a6e23382b02ecce94ef4acbf2825f78827349b05d4b7c5c1efeb7970c525d2edc02d5b5ed3a11e08730e0229ad2fb97285dce57709e2be3ebc6603c243b916f49002eb9dc64037076c30a943c4198b4b0081ffd11e91ddad083f1a0622e37c68ecec625992d782d84e46db967cc3391cf7473b7c13276c7517b269c7a71d66f5e0815da214f020c2285e9b010f25e04c5f844d37e402360ffb070745f075e1da913d48a156e46ff164a6124c42b92186b8368b922f379c134198a985004429f0f91965c1d0095d692f457d723f2930fefe6199e4b7f20dfcceeb79835c3dd29ca812a7a2b6101b1f505ce432d829bf79149b804e8b2cc14ac678f75d84f0f80ebb0ae7553d67924f9f315ac17b82d8186d9eb31785490e537edac15da8a4235bb8468bc4f5d19558722d95f24d1d2eb2646515fa363a7ac37c400abb6fc442d169f44814a8cbb499bc82ee78f708edb248e364adf334ef34ebfef449adb00a0801337d60f01f88c2b50c402a03d6fa8d00d0f145f52cc703271bb49c3e2cbc37b6976ce5a5d6b45a74b6ca14e701217e2198cc5b1448e04906adc7f1af8871e282dea676d61a018f6407f6c1a67d89373b887ff45e333989afe6d810610a859f6ce7bc9aacdc1cc77a3fecb576449b8689354918ac105214f842aa4c41d4de150a6724da0fa9969884f27b4be9eb95fe29e6364836b6d86c5414ed6a79a84aab745c6cf01420ad5d48a8b1bfbb1a653dfac3a5bd1ffab563af081ab94f5d798edbc766c91bef419a950fb5d7ea76c3285f43bd880c824e16e2ec85fc4ca18d136e85f521c5f5ff68eae4e358fa34fcc23c72a8c64ccef787a0dfd8e27346944e9c03858885db94fc6353c74b0965a49119f8c51035699dcaeda6854e6b070d66812848dd09fd2444bd40df43b7d1b2e04934f271f05ecf072ec2f0ff5089c0e7eecb74d67595f6365bc8cb5a19007eb7afced45decd2bbcf25cc4d184d72070e6f2793d764adbd32ec1678da4d23f7731e158e9a464a312f403a3bfd329d38a55da4039ecfcd3e43307b40ce9b855171a7bd8f4b3cc6003a5c51d85157bbc735cd5e2172f77912b2045680df27bea2dfe690852751c928f42255e06631bc94bfcd73816421b941c937128796a0cd13f69655d1a7065f1380b3add0bdee56c7aba7ae170ff79560ed972975b1be7d50724875b442ce6c773c6429612e7c55288279dcce126df6261df7368096d1a7cd554f0113f04c9d056c2c568dbbaec44614cc4b74bbab6d2fc088381d2e87f7ea49c2d84c9a703097347db2c485f6eff3d69755b9ea67a5ae7109c3739a563d052e45a619ca31f82a99c8f7f1cbc15d892cdc3ca155b4b98939d488edd076aa1a0da984b578cc3c0ec776e3064abccbcf2dff4e6995047b778c0c406bb63bf59d0c3c5697d958c52cddf94748426dc4658d8fe3c4937807ce3f8be32568d165e60116041893f019fff4db652e41fc8bec66142ebad8f91adbc2c228794d2c5aa09b447b7871e90a24a5777178ca2dc5f2749219e06a1174d4cb77bee4af531957a19f84467dbf13773ee4d556ad55acd841d5e3b2d9077933a0f9727b1acc862e33f7f31d4ae34c8696d1d36fc3e9f1492278daae79bb85c7c7cacc46e1e234a276e3c59b8bcb21b2b494dd5cbe3835c35b0be0a46987f30f60ffca60ebb65390affc8099f519d55933dfcc6d55f11ae640ed62a7aa8da9335fcb46cfb1c5bb5a2fa57c2f984ab3c7c71d6721cab4791568d4532de9b9f74384a3a47a69bc9a173e5b45831b5fae47e56a9b9d28b2cf259c7657a319f5fe6cc7ef29dd05a2687288f89d563e6ddae2b8a9d1fde36bc0865c96e4bd870192728aae5849a9f4df070755ddcb8112beab07af83201af20e3e8f6022da732a0f31d7d2e21811c42a7eaeb1dc50da28ccdd54e44ae0d73b71ef6c5f5aa590b7be7285ed4bc007551e1419689fc6148e27afb2cf108c6909df504dfa0ecaa7f9047930ce9c99ad38bcb8196bc4bbd8f20caa429f60fecd61e970daa63dea81f591ad4a275db154338695841ee66a0d6309ed35b9a5205c41628fb95128493420cf50b94dd52e0e8f15f4015e65ad74b486117a30823bc8c6f787449740accc58b6bd558f9480f4ff269c3deee3496dcd8c1dc04aa518e05204c4789bc913e66ff54f927de0f6ebf1d9bdfeabbf7da1502a1405ecb893b03996287d3f98c76b714dbf151c8ac8d799cd1ca29d55c9342d3bfb737b8cbeadf4546ced3f9dc5f74b3c12295d44e3723f764720b12bef53ca84af2763a5c9a794ccc42f1dd6dc21847d4e83df422b6ea5aa0bb112e6376faa9ad4a9fb7dfaef86edbb55d6d91e98fc49394199d66801cd2e9c94dcba1b885a6b169c061b7d8f997ab2d6fc6c71fc0359bcb97330e4676c6243b70ceeee020eea55e27e46b1f1de45495a756c74327c7225af2d7411d80fb8c79cde13ef64fdd1aa57a48537c7f6e7ddc1c0d5fefe8396cd1f5f42101c563655bc447cb0fcb4ba9fed37d7f688541496916e4413f5dc4ba6563157ce6d577e6ccfd1966f5e383d0adc1aeae6ed2329a7abb5e7aae34a18907aabe4641b3d3f5d5f16e24e595e228b5b8c01c587954ca52809a25d7472f974af1722c49d4b12ef97ce44d29e7072d53ddac30b5bfcd684da63093b5fc205aa665e7dbf932877c5a62c42206e0e658c668e82b4132e64df7fd1a2203ffac9c60feefb2085d88a1778db5894cdc9999e60a2b79e72f2a060c96574c708b6b134cbe6a9e72917bcb05e1be52e1c2b704a3b2694afe9850ec109524805f245e31c24b4828e861b66971c12dcb1945479ccaba5f56625fa83634e7aaccf78cca25c22ed8c10bbe00e3d09aad64e6853ed5524541d91f9d6c6d4c7327bf80498d95870a35e564c9bffa788926186dc718a0f0b7143f560df4438ddae3f092a2647344cc4fb881500d268163a639b8614201ddf86e6c3f6e27fa92bc88cad6f37b4b8295f604e7e352139a90fd21f4f1dbfe6ae3514823ed082b16cf7eda74e776fcca6f2e96f4d652fce22d4e126c6ec86a9f1bd90116d92a45312e4def6d2445435ac6c8a475f5b95f30852b4c079ecaf3f3ded067222e4132e6216d0953768df2addb8adeaf5c488f766eef9d39450d23b3168411bc87f622fe6a15a44b87558f28b9df4606590d3bf4a273c7013a1ffeec0aac2c090204d48198786aab41093d5fc8d3c47c3092cf4eb4b1133c00fb754e491a1e8facb6690a8061b34e3bb8f0a8dbe7d2982aa713e3dd0d2f660d153f966be39f7afc9dae8926a4d70d180d09b5c85ba54437fde8c7c5caf8d88f1e6aa4574b3a585742b0bcb405c9909f6757549d519ff57b2b3854b478c038fd36bd8c2d88868d7d104e7ecbca8da99976b24d545daf4988f5274a7c18e4cbae5bd0d6509f9225acee2c","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
