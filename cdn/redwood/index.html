<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6c77a60d244845c97c9f030f6b279026a5b15af80a2aa89e7cf1ae213b918e56a158680a39f2f503ce9d1e4ee04577837956d0ee0e22729db3bf5b5c0a3f04c7cb598a88a48f56595b69adbe6cfc990ec0ecde5d618f047b98eb812034b5efb62fe8d3351f93430f402518d7fed0d1cb08c41ac35e6480bd4fe6bc21e6eac489592540e01d581e09aed95cdd905c11e3ab25eb1c5028d42fe7c0d34eae5403594e4ba9a1cb4fe013efade9aea17ab2707c1ac5c2c12afbe402be42652a8ba1770d898b6a92fc6a4882b3bf5056db76b4043d1ca427853da8659d84dbb5687c4783ae33f4874ad4f07ca5c98b92e133bc3861b6541a18c5d1da951426d2deacc57fde5edc080debf5b89cbb17018c211e18d41355a20180c77d975af1285dcdfd5bb47039c611b639f90d2149d5ba6000c64aa5eb492ee253f06fca29e60a9ff800840ee60a57a2857666d5ae5676aa47eafa3d3b2039fa4deaa083c9d6fc5df5e410d4ebcda1594408b39bc4b44726e6e51ff9b4e9778a4ae976864fecc01a8e0e91dba622a528e3b6a34dce25b0ce0b65139dd7a6ba9f353d84401b3630dbeddefdaf6e432a687339b7d67f40d73dde00bebe3189c1b3843bf59e8601b5799531875c12024d8b879d0563c1eb69ab0b515a9d499c99e37b8e25e50b4cacdb459dd0a8371fed42dc9a3a2bf077c4c42ceafaa3189d534ed58bc3042da1286232690cea2349728cff56ac97c0271728ba3c76bcebaeb35ac089330a9dd694e56badd0b249f36f2ca0210a9b3732a5c799ba10bba09576e58f8550f779e61cfe009cd93b0fe70523f46c4dd80d2670b4dc831a4f10230060fec319a6991b0e521b0851608b82f435a193823e065c2d1275e997062a6e9a53b2540f794d1554df36892daaca51b539e2aa95f22f202773502eca5566dfc25f81afe087fba767c79aba12ae2cc743c9a112b3b20513964d7114830459f5a1466420471a7c85a728dfba59faca47b01e6d5e2891412ae9dd8195f85c2de995ca984663ad552442052dad00dbda89dcce878b789f802ae91f55154665e8a46cda64478ddf339dd82cf2d8cc72b02ecc8a411633ccb1b4a5c71206f236a3988493a46ae2e2bed386492c28541dfe40c63addad321d28f937abea46fcb5dd4f8b35db64dd98fa49a98fa1d9d6a02474e35be37542fbef64d4f7ea84bd5569f8f9dc23e9f7816184ab722d11387757fe7fcb0beaea7fa5cba2a101b47c1d923e6513042d79a60910d0c4acbd4be9f4292c47112c1ac025e7c02bdc3292ce46d7000aa12684eae67fa9ddad4d7cbc529a027a394b79ede9ca3c946080ed5b55253b9742178cdbefe45b1ba667dafb8dbdd76f697b068a67216ca529398439a4f2c9df74eae89505faab3dbdcda430aa6de06e48e4f450a9124000f5c469a37a557b62e2927cae06f56ec97ea2da93167af485ee517903adcea291ee13fe795f9a891ebd6d417ce0242c8e5c902ac2243478be7b69bec843243f3f078fe4a06451cd68a76556ee091c5c4ac07a441572acbbcd6bf402a7fad8eb06cd98e2b0f992b5c9d6aed23e447d3f7046e8ef0de38d496f6194840f78662ede2c2298d5d15859cfe04129b05630c8b02338b64f979917a43a1611fd392c2d56d713bd941709eb9351aac15ed460af97d034dfcd7f3d07a0e3bdc3ed31559222c17828c45eb83658be7840c7d247de5280512ab46d9dced7cf667357d281b6012ce686d2136d907a21014930cb7f753ac2f1d60a0bc48ec3841cca7c0eebfd8cca6cf5629ac6bb80d7fc06a598a049f1f64c43a2e227aaf19b2b730fb8b67e55534a1205000234b9da014611974b853beeacc550d3fb99b7f00c6b991e3b2332ecd75e992c4051e4b73342dc233ca335a3de197d16e1ea7994fbaab907135ab3d8f4328f613e75bce9a7d72ee098c8cd9cde12e9bd737dde1a5a006c7c648ed937f40aad0aaffe55aeb9658a0ea15f53c10de0172b3a380c5b7ca9c7f2b5fe57649932c5c0d1c3b03b4b2a8918243ec71b4e93a991e1c16b2a8ec44bde4950d539c9bdbd98852ff5bde874dd4254938e54766e2f7afa31caa1ebe122b01c81a321ac0a2d11272725670b6d1f75cf46e93e594e0f75b421757b391f0b3829b7dac1a4aab58f42b779a8415719c3d87f9cad5990e76d2a9927d3022d0d31bbe28f3156c2c16e5c5b12abe7eebd7c39b8c8399a487d4dbdb96aac799615cc5aa9bce29632905e8fe3af822963ca016923203eb180bffc9913eabfb921d05f5df8d0b48f7d3addd75336aabb80d42504c634ecb17305550c28a8529fb03f1fbf94d0720f7a5a5c73b9791bce4d3941f3b025ceb15a3c39d505b571642ca145e7322c45c778d84aef0091d734a1f656ac49fc1a50ca1f95baa969b3ae73c8a8a44a70e77e5e14708fe333596f459dc0aad6571997567c721d38a133a6b1a3a8e9da8b506f4cada36335d7192d93f7e8bda4c645ed157c0124d25c14a6b74e5c1fae44fcb846ae5c6c8496334ecedbdd79a9ace1a511e72f0cadb4f6b2a3a1f848de0acb7e5d088860ca6cf1d91008ccf2003b5d04ad10d1020ca5536e1e0c07c5d64784051a969a06154088038815d3482b1fcd54abb21dab535ffc75becb8aec1750c154e273667c8b73e7e497f4f356d0cbc3032448ff58ccc26298c0cbdeefa51010efe2bb9cc25bc57b1c9db09c6835bc53f119dfdd9944646807b48a2352f883e9c8057ea4a889c98b1848eebde44593d78bcb968d72bb776a8f04b9c789e7f647c44331a2996c2edf5d27a27999d1ca25c36084b6e85c2718effee51b38fc6587083bbaee95ca979bffe7ae622dddd806baf7aaef8203037647c963ae668df9ec4a3fe68c2d2a6912d02cd810029fee265bf6809e0d7558c899024995fce63d928a29b4a85e4988561c2eab8e411c41a9d7eacfda68fabfe2df50119095e3a0acc8b1903c7f070e3180f3508a872c1da4cd264b03715dfecaa6cebd0cdf318d84d82c92e4193bf2fd38195669f42aeaa793444d5a00af4acebe35c617dee5a6bebeedfde264b6656602f442c4c17587198a2b8078d84ac2f49940148582f8bf5a9faf1fbccd537b0e35905c222f4c5be1d2794c978058a17c54c036ff2f80e0165efad6370c7e260a509a427640792597ccf1d8ddda1ff63c590e9705ffa057a7e87722cc3bda3adf28c95f241c34b0da79aa9fb7f37cc4ab29d2180145f8853d60299309dae72a323fce64bf172bb3a2e291b7f4960db7e414c2a04ae8c0432236ce2067ea978f737fc1ed7574704756be943a8461d6de89602a4017643665a391d163f19a29e927674d946a6161d7cdd3abcdf0124beab47f1b6d61f938f776831949dbfbb2e65ff0e59482fa0ff33ef5269a586245aad6394cfb3d9d6a2e0fa2d51bca6c56330f7db91a042c07c5d4cb44c072dbe70ee78c14621cd76a9151b59e2ac1139c0be09de007047d7665affd5cd6c7baad22429451e4750d7a093dce1f1946db9d155466c46b69de9f6a76c856566cf81bf51ef71b02b1adec89b969b8d41c75fdb72e6a9d015a0567ff9907489d68e4f6db93a874d54d8cd66bb18dd34839d2a8e3266b4f61fa6aa4093d19f87db3dd51100e3d994c69f7682326a7b330af0e3267be5bdd61c1c16d4a3f0908b8d5f16140efd9bcd95fa9146d961195d188ab818b35466ac79e565d67b46adf3c85e8c6a85d1ab945cbf92e8d7ae7c2e349e70c47fb5a9d9d1507b0f459ca2e20e507e49564ed5aaa5ebcc1285fd8388e39716a93c5ac83d53b5c728e6f74906d1678b3a891a4956f21ff44446f628838942be3c6ef545c216d5c58c099df09bffbb8edc31f66fe41ffe9ef811d0bde87a25abe79b397dae166accc0ba6af5448a0e7ae730551ecace08cd4b2e0ad7b6f62a222b562d1f0b1f5b72850d5a67628e6bf3dc8901b0ea8ee7b9341f46015dd8c50a7ba74819ca7b70ce285321ba8e3e84fe46bac7467f1a7b263aace44007e26ad452dd9686c3987cfbb46c7a49ecbe75eb49f8658a670d3bda33b934c1744eae787f45f42304b035bfbe72af3daa6352995cb927c11308aac2d2cb0329b7f1ee50aeb7e9f902fbaead4ca9e8aa51fe70e173893154dc5442cfdce155529f0ad56904989b6ab38fb90172071b1a6636b642d16b0a46539dabee0e4a5a50927d57475da713aa690cf3b51f67ad822046ab6134eff193edfa993291ba992f3b54b8621163a705d75657469e12d7a36ee04c2ddf07b7876c48d3fddf2aa6f9585cfb779480251cb337a06af7bba6dc648afdbe4e8db0559b04578cb3aa38ad34d2492dae72768588d03b12efe68f7cbe8b0c9540897ecc833da571ef52084d93f4700862a35acf87a7b6b3a9621e6c1ec2e4ce972a1d94123e8a423f3b3da886c4eddc1d4219921f63cc9076303197fdac1a8ab10f2e8fc0c9ac07f0956eafd4bd6d63a4035cfb2119d231b250bf56afd3cb493d9549e4847711f6e0ceee4b7dc2431dc1b2313da199db25cb7065aec4589ee85c44cab3f3fa2863cefb129cbdb912d722968cb9c28aadb3e88367df250b16880389807a28815a96d27b48e6c837e0ffd3f661d80eabc8d929db385989bbda3250cca6bd9343ed3cf23df636ed7abd1eceec33c6178edf574968bfec13e3cfaa607e333a5b9dc7c3b02621a57a3e898bcc4b8ed1c26df611c0d2561d62e4cb8778057c7b2667e50a4f4fa9ce4dacca806d270ecf638bb40c51f9ce69e22c2272e178960ba65f506fc713a962844fa93451407d5fe60590893917b2e3568b8f13c816c88a2cdc9cc346a11b4b5ecb73f5213403617d22a1fc34ae8e6e885cb6b0bdc8a737be1cdadfb2bb069f2894c395c245deec97061aced5294cbf8ea8a3f25fc4033a76235b40920abcbcc704e66348ce22d32362f496c4ee06164fceb39637f83fb6c34463d4cf419320d62320f1be57a52b949bacca15634f54739eeba039a0888fb2583288e86300382f39db06e8a01640c057062320ee53ecf04ae3de88ee02b0004e8850c7836aefc3613efa96897304cd59aa873cf456fe50f543914ab1db7e5955225f486058c424cd39eb092b593cca62096d0ba060f4541465191d80d2b563b90f25e099a207bd6fa07d4053c9cc845f38d8a8ab39163792a4f15d953c852fd8c0ebb36fc0b0fd013e6a5fdf401393f5cbe1fbf1839fea263ab677de24ebf19a2e2ad02bc516b5ec614243a4a71ecbed18c96800f8837eadf7ff9fa254f29dfaef1ba04a011e7a2edd4d1449f448f4972b0a302f3d2c40d2a4f77d817f7b252cb847092ab8b9a01e20c7a2c2f6d123cf2b862b50cff480f535063ce30484fd814f1a04454a27e5122a25acf62c94b096383ea27dba57e9d9f2ae48298ae3aac8687c0b839540942f9f90785307a8d59a868974d54cdb5c47eb177a120a22c36c5fbac8f15243d16f8960889402caadf260b3fdedf4d455f2bbe8f001f1e660d062b5ac02f94dbf8bc81c85ec71fe6d27804a04ea201d561c0a130e1d03265aeec444d23987ff65f609edfe66c3ac1e42f55da9720c25e85819cbf109946a4accc2622316cbeebc45290376a8e265d7e5b298c989cd71db8390af969819348f4089633371f21c41dfeda1da9f01370506ddcf3507481e874ebf7ab7ece02b83cd2fa13c90d6233e7cb1d8899a38507c6f6ce9aea1454bd4fff372f247618f2501a901cc855989072dfa143909358ad469b48d8dd3b23128cb490ad87a221d5a7f94bda0480208556289efe97d0aa6b39bdce764b2eed7844199053794fd444c3d5d2024244415c9b3c23090762aab4e7af2e29299ee4211807d7eef806b1a6ffd8778a9d52ae60eb55a3c2f587d478c5cecf7a412364128ffb5bb7eea9d605a70015978ab0fbae6ec9dfd81722e8c4387561cc159212d9142d5801f6d17ea6d9532f2362cdb6075abf11e5ba4ab3af589038c1c56abd1119fb42eaf45c9e75275993ab91e2d5ce773e78ee0478f6bcf28db0ea69af6a3733e43353af049fff43ea2c0b0a79227ea30fe939ffd25fc0d94891120372bdeb03782b56dedcffb5f27b038c1f5f7ffae544549c88c6b589f5cf12deca46206b80be0c003916cbd85353dbab2026d13153bceefff8bbc83bd4ba718f776cd7c53f32e29daeb33977f4b4bfb38881c51f375838200ee3260e144f84bef5d22e1f5f53fbafda6cac2132eebe988ae0eec2e6bed1b479c8229c086576bfb57e58d7cc95a8b32de899016d6a314ab5f85fe997630e36009c422b1d074b6f24af599ebaa8de3babd5644b88d0769e3f947523ca588a0199f687b1f9823aa6045afa0ad1eb97d948fa5dab9f66350ce7c2f452333f4369ae6b36cbcd5a5685e065ac7be9e4017d9f743e464f93495acdeb180a7de5554c0e703435e90c2984f985e964df6e3fcefd7a73e8a962170e58de92c294c97f0a9576255bae1bf7fcaada3a20d7b75a80f1a2ed1c5ef0125dd7df24a76398c58460b41066fd46a46a242ddc5144c7519063ee7b5e4665c476d99d3a9d15179fa7b1d2713e136948bb36c95be60a93e2501d7d36f144950a1e7c626e322bc06c629ebd0ce1907f9a34f101573428c7790d1af4da5ac43e4cbc4302d076649a4fb0364ea75cb6f32c92260df21172b667827f8859b9d750fc8c1c45721431877986f2bac614e68cef5470049c894aa51f8d1ac709a3c1354b848e1a2ede2e37523533c81c968a9cf1370f6042aa2f0d0e882dc437c05051c8f4892fddc7ec028c62a1bfb1e33bc9c581031802fd0680e5aa0b8d52400d88c52e59fd613f06ef28399829cbd6c3e4448b25da14b852948616524bd86f9ae51ed85ce176797900ecc0e1a0e26a12848d3d862f8479d799c8a2189deca24631c0933550282411dd52e67855663f0c762b9d50b78ab114959a5d47670d30c0c4621f9f575dd12e29ba8f7d0c872cfed22ef5bc0451a90385d7d1f49924ae3d7cd9b12d4907e20629c1c29df4915ba5ef08a9e6f6eb45cb1b3e6514c901ac904a5c71f0c7182d2dfcc791c3af657c50a2cb72f277e4ef602636a4199f19c94bb28841c1c64d05f8b716da4635e7ad154b05f5b6c853a1392063b2dba1fd0b89c9a58b979657ee3f67d5cb8b3b262b1a1b9fca866d8d0e69ddba8f11bf7efaa1d859b284df102fea208288c039ea2e1e010076a76ce0adcd6c401caf7382badbcc8a9b7f5dbfd9c77cd00d36a96042e8038057b6cd40f946c4e38e72de374e511d5f6f0b4d2cf934deb335608f13a541688af37a7e52ec4983b019aeea88a2851a16d1e540426d01615bc12c7089729a7d672ef07db3fa0178bf78312244cf9675da3f618ca9af8a41abcdecd54d0302d10f070adeeb9bb23542c6637d403fd8f9f27cf466f3df8bfc22d23a50bcd5905cbcae52d5e5c1f9a53f70b23f9f9415fb1bbee29af327ce465095a1f92e7427c40a74f6eaa2936acbcd39d688c1194c10eaee181fe069a0adb98ac934df96d3edce983812bf3285ce4633920514e697a77cbda0c4fc07b13705808a8f4ae1ce8e6a32cdb0df304804173526a8d0e9bbdd1e73d85f12cbeeaeeda608f32fd82cfc492cb424f727fa282d2bd539b51e24360b5aba1b8f347f2751411d6812740fb971b837ea07d94f1ca7646be829e83f2cb70536d199adad64497a15106aabb9768bed653ff070192cb66fae6a4ad0916237aefd99fd807c82b561244941f2e17c09b9f71c79d032fe51a52bfdaa32ea8324974742c3fc9ce0c84be834106da9c975aa13a85cc96690993ee55a90279fa6fc77d136be11b76ab4a6b148abafbe85597a054ffee77b892a15fdcfc9011f223fd7078f86c2279055cc8a14574b88da39cbaf3c784f5abd25e8c4a07041c5fd2f14b6ca8a188c30619e57cd78e516683a6dc779908393bd001cb2a6418c5b5183af906ca20f8746f4c4b82a14f69a4353761101839cec6a5c613ac323aa53cb8b51eadb61a68ff1d87af5244d76f5eb249d4045a8acf3ac7476dfba4a8acda8be87ab03c001d2bc04e7603bb718334e454dcbc9056205f3990bb7b0993ff6e9ce4e163cf14e9b24cf61979ef3ceb6a00cc151f6dea7941336512fe828d2a12393d740b576e3c7f018cf4aaacc146078b8510b1a03334f500239ae30052e4856d5ddf0e56ac5feb8bc7eb91e5c0973d4113decc10e2a237d940bcc34190cdd6bf80c5ab81c3e96e61a2bdb9d6925e86503573d923a1e193b3ae250e689d54def6de1c37a992c7351a1ad950dd3fa410d62f6339e5672ca6963ca8547df372202771fe26f75d39036273e1c82ccab7e2dd458a6aea8c143598834b60daee44ee66ba15f1dd2f5ee3d0f574c73650a13056231b64bc1811a8f57d299b8f6afa1e235bf9c2b986a755a328ea1d56769c09d983b0bb626e8ff8173fccf39861f46921d3134da227f17e9ddb1e9bd0de5dcbfa214bd5032e98f3df5e0d54141b79c81cf0608023917464c05ba00e77ddb7afb7c5c94e9bad61104882a3bed30f5d4193f964a065ef1392f628c1794eb1bdd241ab5be3a631fdadd280808c703ff19e656a27fb7feb662492001d886c03a2ce969dd9d19566e4d8a1362c7ffbf700d0a42467190eb9ec592becec7d0b9d8bde09d1d82ed06990f61ba96e0d5d22579d7cea9792be3c77202e705d358142a19f7a53f259acfa07200a966e2e5206bea06b21fd7be25e386a567d3bfe0f2dabe5bc58985b5537303f08318768795d34672678a94a560862ac8937c854c7811f0575ec7e7ab4a5b119ee27be749fba09fdfe8aecbe0824e860670ad13e0d6f56df384eee4f61e9fc6424c45355605cca69b8c76f5cfb9d82d907ed38301187e21b6c78cb6778e4927f6548e1ef089f38bcc31ed26ec88a4ae5f23f1b86d7ad16aef9f0cee037e3c8f28cadafe200609eaeddc53cdeb4d370ded50cfce5596fcda74e5714ae3362e57b85b5113b80acd4c6a8cc6b3c50a8fcbf63af10d485a261fea7a8af2d533e268b84b382e122b2d7b27a36cd0b278271a72138d3f136dabcd83b1806d12cf5012d734399b0603f942bc878577d5fd28f2713b0b82e964439ddfcf2c7cea1e48a4497c9eee1e0f5b4fdd6e87eb797935d63207b14703f9156a2d0036e6cc4caa6f566e367d424bd29ecb29588de59c057c70c47ec2a929ca656fc11cc07ba0bd2b273c875db8600d6854e188ca417165b2d053b09391d3f25b827d929e12d0db0e5c3db046023d7d9c6d61c75325e4abbfb182d996536f71dba81586d54a5db2e3b1cf0021892d6bf1310d450d9b026a1d428ce1da827226561418c426d335318418145e4464deb9a65a9e2806d93783efb9f2e5ad0a039458a96703c870bec418fd24ab9aa63c9515b9857b1dca68217197b557064510f1a34f9d3690ea1518c4b0ae0831d8521599369e3e943bc9b7e0ee4d527079ba5463c0d9d8d9569f86e74fa02bdb739fea5b8d63a078b634cf6ad3c9b5bfb90f71eb631829da24aeaf76634d962d240d3eb7122cb6ac8bdfbcf7ad2fc16f16e10c8b47c1317ba46ea0327715bc19daaca65e03c37fc015d18e2d8b3f6b51517f5a4fad8de74e9dcebd975e74daf2db856f579bd5c1ec954e68d4a7f1cbf6b21d06b3a86f321acc2d6d06e7d36ce7c0eb550c1712108441de57d665246bab09f9ef8abfbd414d45db7b42870b5a7c777c038b9c6e872a854264c6bcaec697c31252da5324950f97e3c0ea1185181af5178ca88d5b53027e2564ea5fa20edcda0b41cf7639bb0c06dad5cfaa85e1a0325ca5f3dbcee5b03d224250768df46de135cfbf5414e66a5a7bc6e98cdb6c89b47523ac48b833af08dee40d470baeb0402e6f304b4b8ed61a0b3a6d613fc6d236cf180f6061392678d545238b71dfe604c2c2356a760419d67a77e4edb51e64956c0b3ffd402a280194a5a6dfc565a763f2c4b429492d98e231c5ebd7051a787a4990cf4d1825483db70941d228f5841ce62a52eeb5318bf6d2fe5893583c02cf32d3f296e037904b74ca66d552d9ec6a573ac1a6d704ab7d31c426be00512fe40dbce4a55fb12a7965b73b36e09af0553d926b220baa1640704bd94669a939382b5cab04a5378ab00a2c2b0d85a4df6e08ad3b1164d83e2c5c6dbd439730955e9c300aac70953f669c4364c44d7f35987063a91f4548ef6c372021f0675b1efa147410b5365980a19adcc4230aeb92f7ecd997ddc140d1f7ee3a265dd6ee86872a9cdc0847c574c81d376bb87a5b6771b81e70a25ee341424dabe56d3b634caccb2d2858a65a9e13b7c0c1f7899e794eb5f8da427f70972050a7387bc7af88aa6e5744cd640360f325061032cf064befed51e4adddab84cfaa2d424932a9c1f30ff219f53ec6d406e4be3595f20772b8b03cf042d938907f4dfe39bc9cf5c9b72bf15fba6b73546156ff366f2ab9e12b8f7b8debae9c6f62ae88a21b9c26fccbd7613d6b43fe4600fd8d153ecfa7e7e0439373aea85cd26e9ecc32116f7a02e779aee48267803bc4aed988bc3b62df6915e1f308b97248362c35c8732817fb1c572c4b282b7f080ea21310048dd5ec13470d8e27e1fe3f669afe8c50f2d6c856eeec0795146b7cac398e9bcbe78fe858d1285692b8280402751ebfcf6329287792caf929d4b5572a27055f177a4b3a1ca192ffc82aa081e3d6f0a6a3bd543501487f055a4dfbe56755da21071a03e431c174764c22b7a3f7f2af0e3ed4ad6071dd3ce772dbf7e39df234d08f2c20a813b80d2220f015894ef4e602876466f66a2808c281f2027fc1a9a933fbaae7a00f066086c394af1213fa3d4f731c9662868d235e0d4421c120cb3da1447a67704117bf04eec1b90c9a24b269ef690900e8eacc5029614a03f6a7b2adde3f41dcbc5ad61fe7049d33985c5fe4c0ab021f6eb5e40272086cf72c4b8dba69603eb582d9c07d1bc2f021f1ead747e59968a6a52817788064cea62fc8df5197c5ac4e55214df88995a646edf77904e410de1199bc89fea74688ced5bc72f62d2bf682d9a5c2b7b5d1cda1ff5f316429c3673ddf04ed0aa921caf5c3a7b89a38bdc37ae21a5d7f9e34f30d9483db60a5f04e793110511c0c880eccd396e30a8df68754512c09cf1afce5c42724bd95ccde9a5784662a09db0df83130e55d86400f8759b6486c0796841ca4daedd51708c8d8ccf89d42428ffb94dcc9a9e5830aadd8f1c54fcad64a11975b5300a10d13f43b0c48eee162fb31031f9440fa3b869e0fc7ddf3c3951d5070fd3eb7556fd264d097ba0bbf4d0fc47d8746f5dd5d134516afee71c17c6554c5725ac20fbf2115a78b2b39a222b9551812a385e50d0d85072e8276342f1183066416c22d583980b5fe0e28c6099a7e6259ef83f3700cacd1e176eb069d2b5a54ab362410b71c30e9112fb005518eab4c19e53fd5371fe2fa7626293fa126903e72b62aeb14d216f641d9bab3aa032247e6d7c0b4ef5f8534a5ee9f4764042b27bc048ef4d6a40e335c76b75dab5aa91c5eab9c9d45232b461fad93f9bc765df698c49585a5aa5f3f8f2cc06a2b00e4037fe40d4bd6514b5546c6a416e90443404f363589167d3306aa0e7fff1ad81e136de52712068c6455c1f87a286e965965946e16d0e504685d9aa5ef8731c9daa5582aed68ccfb174046be3aa12a707fff4ca9598a421ea67d6141228be9540fb9a7522a15701ceacc0b533e926af0a9b8ac2ef65b2b49df8503bbf536358db39869d24d211536d1340c59c2c3f2550bb1d5d4c81b794709c8dfb9bb51a79b84aeeb9f0b1ab6671f279d2a3855f9a2add6302ca057f05d6a2f422a000cd4d7573427cf0bc520aac3dfe76a61997e9c12a6925dc00db5d9719924f47a7bfe60efda3010c95aace493fdb962b746aa4485df67fcb0cf0bc15b075d2fee8418d6c6847964c825595f3267d31e563203fa998787226a116154c121d319e739173f803231a1099293f2df30ab3e2baa4e0b597b6559c8bda18b42b422d5f82f0651795068187a4ceb7f9f6fc2edc9de7e9df873aaba6c49195d229b10282874c2d6b85d78a5fc9aaa0c62f1103bb5638915d3e03b399ceb39a3dc760d84c12b9b812730c01b493094a0931e50202b22fc5271c9620e63331efd05f33e8109b6f0c33b65e51955c72029fb387338686d2fbb5d3aab195a0972ee7b56d6a3d9969ada1e7e73af4c3c77194676990aedc4774bc0fc86add07a611c333674c4f8076bd58e099da6753db52cf370e6e9e3bb22cb020965a3bc2948040bc35bfed5e1f13be841b928b8b6aea6ae018eca118bd527f4cf013a953e2a3b042e900fc8f11251f8638d4a234cc9ad483e4deefd4c3c6bf24f18f2bb07197cfce99699aaf34983ed2d23ed6a038ede62cefe8b6c34d85a0c9b8d76295c6100c6a67ac72a601f9849b97433169badb5b14835be399a07389e21698d2a189c213a7cf93abcb5554f85e044ed00004f70bb3b747f44eda429908504041bdf6c03fe6fb4135521fae5c6ab5140eeb83d2eb01aa23164d0d4094a3f98ba0e1f77387af4d798504346a0886c6ffe8df57c3b4aa367b4f4a8822c7ab666bb80a5841df6fd8beacf1d838ff3707ccf6c7c57978c809bec6267fe2cb4e736fdba4cbc529e2caa7191502eede5affa69f4e7297ef51a81c045c60b512f3e102c32305f1e6be2239e5d51bdb990247a39a28120c2b3f7fe81d2117c3fa4e2df9f396669af60a15b76ccb7867d00d965d8933530ad14da360064c70c57d7b00503f11594b371474f3f747981ac5b84e1174eb952cf28c0c396e87d127a3e768875cf1e459857b6120980d5e05ef03d48e9c91be1661e2e1f290da4d62ded453ef8971aacc3a6e8d721787cc12a2afbcba51ef1a2a5576a5162e5e9dae889f17f2352fa950ebc2648f7caa50a61288d4a09f4f322800041d5acab14d35619172a81e15d545ced0e8cf9f1f9b556aa53fdbee0fb64423d44506bdff440f2faf309be6f384d7bc38966f403934a016fb9c9f2c2c934a7ffcfb8624a24072ae7a49ed044629b378eccf40a449cf109d58d19fd1eae7482acffd3e189fae10a95dacebd68aacea5fa47ca66bb9a2b60db39e6cfe9c969972aae63b81d8a819e6b9fdb3a4bb821ed3f98ce67a10bd17394733e4aaffcfbdfda9af5370052edbcbf8d5562fe149557073aba15b3ed42ea021de7f76e35ab9a02230b9b046e0ea584968d106589455069d96b3463194a36c5dc49e1a0f473367462935808e1311ce1cd3d3a41909d9bc45791dd091ce85066662aae72d8906b5629166bc368370d922f84323236682e5b7f61d03bcabd04f995dd0b94cff22c08344d4852340d252bc35495f65df1d539e3b05aeff4236de1d69ccc760c0636c647db4f897d90f298102f4ab61b0ef777f136fccc62cdec675c860d65283c97a781e429362df4a19e1841708801a161547f2ee915f181e190eecd4a33773efb392b9f910cf282be50d2140300c9b6ee8624ff0a4526bdc6b287c6f4bdc6cba2ef4eb81d4d02f840568dcdf64570df2aca1f1339c346fe21621db9574ad59d4a0ebd5e241d3663a2d3cea430b9edabc50bbec3db0b546a60637d8cf69b9307931fa689057bed5ab77be7442760f33e5db4751cf18bd49a107a89854904af223decdf06a78d96d6fbee1931ec2e6243b4a697773696ff94e152b7f114122bc2d77b9b8d1e2bead2c19f973c44520fec067f32b45bd8b6e2590fac38f15e2ac722fdb0682d0841ee339cec124d432ccaefa068209453b271ea9d5c52c1a968f9e1639dae460b92707508aab8ee5d9bfb3d4c7122ae0aaa75ffa3f602df20a19630dbe77ed34e194b24824a6f03c2f8736c9705577a021cd49474054edd21d417ff215e28121b876c363ecf6fbb451448a19c1504da9744c73b8b899e3a20a173c809f8696eeb759b63a816895dcddff9039371a85401f7e6816430f7240052c0649e9022227ecae5938de772dec71b415460c21a75194f9249e81449a6b13a780839129c38d3ae0c240344f620b111ecfaa80055b740955440e07eaa0683a9841d7b1d4bd743cd676daaa9c0217bff2f617ede127b211261aa8a28da1d230b800818ec3543fc8bc5ee68e46ae4d218c54f0e992aae296353d0ed7ea02bd404cf162736888ab00c2d092c122cca961fb951e16d228083ebdb10c859a356aa82ac3b9f74dfe32df17bf7a70650de63d340d2035dcb8bebc7a216037f9b87d55b7371648cf750294d7e972aa409b4a1d6b03bcf43e7e89c25c987b44f6bc815d8d9a771d9bb40b75c731332f6f987ac54d0e61cdab0e83323eac1d669c47e1bc6d675cf81c591d2c90485c8df0feb3f4f5f2f7c5ca9387deb41e19f65990e1cdb8ddb9e3df5ba999c61b13e7afb4ff1ad5f1acbf033909fe247f4675f28ef78d52bd14cd557b4f8ec67004a9caca52852124dbf5df4d022ef683292aa4aba6df48f7007d4dfa123dbadbf987ee8df382c984a4b391653ed9ad138434be5c32f4472d080d12ea67380d2e066e198d1e108d6e9834ff4d126e462a71f46284c927121efd83ab63905651ec33294779df83ed8ed2f1bef02868b7c4f2502a1e50850ff40ef3107e0ebc381c6791b64912821f950d517f881124055360f71c5ce7048ade583d2d268ffa07dd5f369dd1f15ef9756e5ae385c5ead1228bc3aab53c821922629e508f8f34d69b488ddf7fdf06ebdc32c4a264c274710b159e99208023dad36aa49fa6fee312d7fbb367ae6271ad19c2d27b88ca74a3cad2debe12581c2bd2f71b94b5a3c6654cbc16b4fc807b22ae4c68389dfd54d464c1b55ad8feefb655dc060be3f7e9e30aede9d0da31a9ec264afb3c0ae3584c253670eea5c722416564cb7b1a3727002cd4f3c572d61b271e5b81c446ce82b1d51fa545b591047d2edd5c36b26743f6a7e25e68b13357a08050ad127533467f527fbc7a23b44d44ad09da01ec0c04228cf5ab3dc2fa940cb5313fbf6e112f5eed29b885b401becb15240d080e63faea495f4af4ed6ae842dfaa1bbb92c44cb2df60da1f8cc35768f9fa48892908dfae9374838b9e12718d2d0597a67f2022b3e4fc736d31d07d26fe83ee6d1e8e6301b3963929f0aa5e7e52a362c18f8532f6a72354581e2e67e3ea8d4d39b2b54397b5e885d7d10a2f79148c3ea7ecf4b5bb159812e858ff9960193c6e825211d27720c582815eb62b9fbd75e0c4bfc87795cf486dbf91d827e642006fb8e95bd6c69836706978a26aad2387575b16535a4d0c60a0dbd0de07f6e212e6478a3aa23ed446b71c32a069edd9aec59b907b82bc46f4dad4a6997b1df599596288f9fd9aaac53b9641815dcc26b42f063b48d77ef53af37b5b82a5174cc17ba036ed7a6f1609e433f28705ae68353db85edd27eac2220921018642235f0e1383236ecbbfde824846f2240dc68d76e88e1bee4a5b9a10651c07342eebc25d89416c736c2b27059848fe1399bc040919a29d24b919384ff19fb5f81227834e8f4c65509f95955a4e3674ce33b8b2ad92dfb3e736af79c5f0d2509ae570c58ff3a15a4d72800c9c969d9b601661a9ecfb7bd26e913425deca61f71db8bf0a8c23a942601f6f3a667ffaec2cfadfea3435c20f17e401cbed43a3d0e6e493b5dd7bab798a2c0e873a9a8c636ecfeb3a20e2d0f7abc5362fa8b75f4ce7fe566148470de0dabf020ec999cf5ce02adc558cf250a34f74b544db965d47015f172d31447d6c67a98423178105f61e049dc2bc33eefb4c25d57bf0962ff4444196dedd8725c91ed23f20dd5d2483badb749901cdae91ee249857de13d85109069331bd15ee54c2ab339cfc9be0c62af953c3c45c48df702dc76519e9e64b6074a1f979866a1adae79e062062d96331f09130a3b763016f54359a2a7b5a70d906a99f41e614155e5c5e57d6c5bac32e653e2bc5afc7925a23a773b5f28733b7588501c706da642c8552d5ec2a626a09e7a11b66bfd793f6d1c1481cfd535a84d4f14425a064f4a770fc8499b6a6a87cff06bd021eabfb58c0fb78be3a3c7a2e654f07b591ab602f2b888fc756f6115dd286d64b9375da0f1cf200484813b904e6006dfd92a9d82ab2fee8703c3383de98a7aab5d7e72ae5601a2ceba5ec8a622723b1916e46458d74d7e8dcfe4207b37479108deaf329d8232ed32f025c1cdfe90bfb6f1c85f94c26e52b3d0c622f46ffd70503b22ae37c7247073615f063e4dd931bccf2833150ae4d4a08c60ad23afd15d78f659cfc593dce4d23fd4e65d0fa84de468873394cbbf9a8da586fc2bf881876e763368e475878f7960420acd9039fdaa7822454653775476f1889e87e2271011bb0e181cd436374e219ce5c365b8e30e09fd2563555a26b7848cef908a0b6e4cac8cffb91b79f83c8c2bb39526cbf3a507b0ccaa54893d69b8d6eac3427bcf25bc528d4c153ebf9f192829927cee3326b0b5d86cd101227e6b3883a849d147906d62e9b3f6becb50982bf7e235d0ccba013e0ed81600a565bd042f5048725ff09d34a91f53913b396c134c98769c391417edf8ff715b24ea8ca6e55e6c50ffb55b13a842596c0591d3d0786f6cd833cb8975ca940aa600f77b7d7a4112b3b54bf78d7904d8b5f2d07f79d43e3e4978fe7bb89c8730d148dedb89dafdd1f2e717d3282f5a0b4c9aa4c568c67b4b0ccf0df97d9edf4ae56c6e8740b33c5ff5bfb0a6ca4d3049084906c543c46b6c7d244e9e13af57c009a91fb526e98bf9663efd1b9ef88a9bdfbf25c1756aac0c5c2a087e65fa8b8826623d749fbb46173e8ebc498d4b5f2c74ef2c97d0e458d61357668a35910c4bb25d3f584dfc1d3f7157baaece900190664b395c1114f0b33de002536c1afc632786226c3b85503d7678fdf0cfb643e8ef70d85a0295629c145059f63c34c5f5246bd1c63de1016b63dd2f1117f3460c06890134ae604a3cebca629be65195ccb1b5f87780fbda409f042c31e1e90bcbb3d70bd9476e3369358afaec80e36e70a76b748e39e0d85be8ea41cc83fd9456a45162eaac6ccafbb19647790c6370bb6ce86b98d849e3d26291e2be9b84366cae280c9b16167ca50ad1f09f1871f834e40a4df6d3fa9270f544a284c41175de788e6a76a6211c4fa26d60757f47dea640ef5ace39653ee7712266896cac6d7287e72dc9669be80bc92e6f62818c142932a467b4a84a2424d20b5d1345e305d684788de5853372b4767be24eacbbf905b91ca48d7f2be83101628263ebc077e29b18e2f7fcaaeed106599972570edb23600ec8f00defe6dfa16078e487a9fff26505835a015444d3ad615ccd73f1401cfb46e4ce2c38f7a9becb8a38897658ad379b9ff990e162232706ea3042159101d196efb86413371a47a4abe605aae2b2ad19831391585c508e1e9c1e16273a1e77b3beeb43746abe06e61790a4286fe33a00df3b855701744ff346d0a715be566380c9055c9f2d32c7cdc303b27d86c1eb3f97bdb56d035cc4d9df148763a2f3ccdda85f76043a899fc069d7369913132e8ec79eec16a193ff14b4b00f512845c44d5ea45d859179ab1f1ec840f7b1445593528e64b1cdf1a3841c2c658a2397195d3b31cf0dc855bbaba9b5440e7f3c4ea097b1936ce25e3db073218acf0a8eb6dfeb4346fc05363b335b721e36996ee2839688edecaf7c56ac479ca4449b9c6f817a5f4d97554c6934c9d6a0157ad715da7a2f8adbfab907a1abf356f327d55ffe7fdef744f2faea766e09d4a06e1df83b7bb034e14c35d63b0e55be06bf591c692185ec588bea895a431cfe760df7ebb55845bfefbfaa62f8b530b33f36a5cdcddaa81bcc3fb652399799d71e731146f7d8844949f30314463102fb1f7247d497d8f3c9f5382888bb439c40df3f97262c66b0688b713337c7fdf634b8f39b6ee611d50875fee45bb17b988f7475219da6cf7582de99f2d16855384523b06d9313c7ae4c2f97823bf9198838e66e72e8ea30c5275bc76553cb58c993ae2fb16034a6166f4b46","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
