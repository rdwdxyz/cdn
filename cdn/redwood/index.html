<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b0d056297084f86e27fad97e1ed63c7e64fc8e1699ac32c572d33ff2ad2241239b16094d6236cc5a2ac07212b825d922aa6299423a2ef57fc7cdb29bdb83a592e679f4fd6786fa4bb9e08bcb184c481a7a3316684f1093831193bf19bdf7e047fa4aaa223dca2ea417d642324d544b7290115a04dcafa963025038ca51b9397dc050f89f6d2db5af88413a29aed06ecb0b65a3c5096aa4870c9cfb9f5e794c9dbec91dfc7fbb822b9e1597b3c353de0076fd8cdc3f77a2f6534f5fb352b9f3b46273d5b08d7b505f8df4b70753546978737b3bb3d03b7d8ed07f2f3cd8649a88edfc30795694e91c5d60422cbd40d000f283393aa9e5427ec71147d62f4b5b9da6f2442dabf1cdf5c4f05e2e5c21faf194ef67d1899a69f5ab405eff44911c7ebaf17ca2c7d4e83cb3962eae99f091a91acae79497f45c54bb5e3cfcc2d4fd3ae326f12b0b8d16153774da0c8818bea483014531dcf449cce2cc43f6fb6ed30d48678eddc3dac382264fcd6450bea512b7f20ff3ca17594d5b3c91e399455135432137ff543fe0b6a12ccb85171e7b8a52070be8199abb53db404a0efb6ca4d9db4671b1632662e083fe704b9dc6b0255733673739446ef4783fa09a8a27bea8629569f53ba7bf4784294e35d590af6fe36479f73a46523dd8c3290f9d9fb6d1ac01838857364fe9b2ad81a834a574d233218773ab6ff33bbaa0e98fef31f30f45478e582a528d4e7348a32dbcc2310ebb34dabca92db6dbd6a6352c31a00a197032555b46b28115e34b1eade36c02e012e5472ba833cf37c8cb972ef40e47d8d23f3803dee49c33f3c95f3c79e39ffa80ad082c54ee05f753a1155accc54e0eaaedaab4b73cbf4483aa065bbee4d1c375cb7cc9836ca8621d3f092df33d9e6cc202a8f99b0e2eb910d2841b6c26178b9649eb1a07753f5d0aa848113ff26c781b634bbb4d2f5b33a9fb58fc28b251a05e65d3ecd10f9699fd9c7c4482d305842ee9c6a6f40f2fa9b41a49cf28efe341772fd75995422184066f6fd50984c99d6b1112007b8437e27dca029e557ea12c0a961bfc5e7236d01f052697b7f4bc7bcf5fa67940a8e82cb4dd589d02ae6ae8d52ebb4642cced15e573153be93817fae393192128fd1090ec58744a3f55d2c4f9d7800963344c8a5593f85cc3513166e156093413d0d350519fb6053305dda5f532bde65cfdb4cd5f74390bd863b9e1337703b34875eb07452d6a268d73567f224fbc208a16153924847c8d264440c4d1b43a873acd101a578bb738772dc1a35ab2bde34116f9d52fd4f0a8458ae6a8c5cca67e6b0d11bf983a806fd5570ecc75796e42abd526e9abb714a9f0abee5e6f99b47aab436302670a9c222caf9fdd656d56e01682733017d780a6aeb7f0e045380b696cc7729254e3e7ea624da63e2b11fda15be2b870649a1a3df7bfdab94b82806b38cda0062fb91e5f3983adfb2f42acbc52f9a57f0f68aa6202ede69603b65906be0ecae083175df8e651eeeb40a11189752f0e6f6a6e9de7cdf3655211bfe9d3d27e46b3b78485df5c2ba8bcbf9440ff583c896d1ac04163dc42a84b29f553c3236632caa5b1afef9ee6a48140873c165781be231aa0ee429679d2d7d7eda517eae3eaa7ff70ed46dadacbf174f6ad886cbaf277bab7b21a7f88bea674b8437de6d1cb3829883c48a63d47f0d90a94fb87102db5b324b53ca2fd0a66a1c5bb2049390f0a61f7a7face778ca35a02665f9ccd7bb4a2bd0186eaf2b119387822bb3037757b46b3f6caeef08dfd5ff4bdf35f191aed17fb1189e0b033cdb3069be003ba8e5c01448b839118c20c140c15d4b3dd21e388635bec4deb07b89faaec42ef8bb93fff88801793df4e47707b150ceb74d6f6fc6fbc46df1cbd5225b35b7ff80d6ac5882d81e3b86d1b96c6452f37900b8755e34066bd202d575129ba3ae15de52b8a9796d1fbd70dca567a74b30c6b63f62e0dd3cefb472b1088564031aca1242f34d795ac67e34140e1b143266e85a23a3b6e7e9dec9fc5868202b181a3f2cd1de0fda08f6a01846fb5d2c3e0bbe907f74dba647e8bc1dd7ac85147d1765fe68ddbd7d6edd90348f91cd1c713a10dc3f3226c4c7855b355aa5169d5bf634af990d66ed7b36f8f317b9f8be6af5f3b3cb3d54e5f723d19133cdb2d8420395bebe694220ce0ffe898af25be8870ac558d578f2e1632389c40cfffe8b24977847f8f8f727e7882c6ea17f401251e4deadb322e0b2e50e3dbcd6ab7e9369fc537eb42d7eaf3e1e065b0a44ca1f0a27865ad6c729046d049ccfc84c65f43470fef8e5cbc10b4cc9468d816ad251e7f03ffa157a26c545716f9cebadc1d3cc21702f8eb7186dbe43f799e7ec67c924c97bd73a2de916d0dfee216dc835e50fe8d42a972abbe75db5dc7e0db7bf695632c0eaae2a49a3ae641553983471708a8fa849c6404624571f9f7a433c326a9f63dffe93f59f6713b938794d8f0502da119ec4f107d0f946030dd6d4bfd785d02a4025f511f8f4718c7afca35e2e472fdc7d7a565533c4631006592f56175d63af86a9bdcc04d511398b4ac2dff5e950a93eae0751813d11cf4603509c4516f2c71a8c9d44ad8e691947395f7c97f0b5879e5c2bef9d738cc7e3ab60047991cd5569bcfca3962ee5fa5a039f7067845ce92f1c940e625919d785b4ee25fd0435725e340a75e4e696d960b9e00e4d301d4ad108f2dd736ca6a94ef3e7d955dd844d9205bafcbb13f071025b83bf096e299943058f80d2944513b62ae836ea9c5db072e38aa18a267e7be441fcb27b80b51056ee6fd13ed412789a70f55fef45d06ca8612c70c92f27b7a934aeed91f3ae4caa92c705a2e1c6813e9e7fcf84f318a48f677469404c43706c3b831b5ac6ccee173ba67b93252f687892fee30b3619845a1e817490fe75819ded32d078cc908156532bf7988675dc3c45204dc7c2e5eff367da3b6de418b651dc8fba4dcdb413798177ccd5d13b467637c84c5395d702c7479dab30b12017a1b9a73c5cff4c3b0abc2390dedfbcaa3ca00e3c15dffbed76ee33f9feda540e96f88ae8c41074ff1dcd82a21d07cdc1d3fc68d2870cb1197c3075c4cad4408b04c785e5eb15d098ca816424b967b629e8a1a97756676360e84f6255654eab09757342e9c8ee01358252aa2dd4c469c8a98468362c56a2421c85132c625ec61d3dc014f828fe21da7f8e2c6512115c3fa81f6179720cde02d1df57262fffc7d5581c6da89e459fe5590eb04343e701b289cf2a36ba43db8c8f2b825e8c901dd519b79a994a205d40c08e9b7a47c1ae00c0ab15b1581cbcf6ec4b63e98da8d8ac24a8a7605a1c01fcfd4f95cf7e80791c8a662968fb6608f1abf421cca70f5b503f39d82bc17c76d4863b8037248a308fb2fcae9e1a312f09934d6a2cfcc9ccd12c29e64ca7620e6ef4a8064327270af8564eb08e1da5312ad2ca282dfcdebdc90d7796b3ce765e51ea6f0ea33a22502b3b7aeac39320fd2b098d30165977f6402d813837a560e26a96ee064056154abc83a7709e23c7dd10a044cf4ebf05d731408698729d20cbdee6fee88d843d0beacf4c1824ae4547e95e0b283421ac1283e78bf61dd05f221378ce0e44dd790b29e31db315143ef4691f75e0011d7c96214b09074163c28934d45c07485865d129c4f399b552d6ec54ef3b78a2fa427eb05a1303c8336ca1ddc6e598c699a979bc802ce165c904f6caa053500f8767dcfbd5a3f40716734f0bbebf16127fc330c0e6dddf4f69a4fc1948503fc5a069b3ed5fd3c2a4d524be8221d1c5509f021456fd86cf440bf39f89311e0026351aaecae8d1ae9efb9d6f9dce6171f35423c143efa3ad7c5f1e4d00f80990d51165002e51f5032bdb57b20ba307e873e356bbd9597c3cc36e601bba70fb118f1a2aa73a758955a974789d5095ec6390fdec780ba6658e997d76064a4810e3a50c61d86a0ea17b1354b936dcb72e399d477f5fc73d8eb80d06e6aaac3bc2f802dfdb334bcece4c135c70d06fe04fc487560e140eb9451a8bae5dbf596ec2ec777e8091d3278816b4dab5f816f1a02b6b0f55ce3fc893609606f1ba614d21e1a3e48782957bc07a2eb624e2e65b86158cffbe0b2b2db9a70eebff9caafc9ac0ff55d32f8c5795a0739f6eded1343d3f62d375c46bfa1b93913083ab47a3438d33a56e9abccc42be1c854634cff186932e257706d83d738f8ad4cd1dd0c04ec33aa9302feaebc2dfa72aa6f96750f309a80b95fa26c1f6098862cde28361286fde605970d4079cb3d616633a89da02838926b18f2a7843a336fc21dcb2734f37a499dabded5e8a617f0b771bfeba46ad9e4786faba03fd7520856cdc238c1be2eb9990c9f0ac1e4c79701b996a203e4da210def81dbbd40c8e33b1141b37cec8fcd324a9b3dbcb6d250d892c05dc662ef4bec73d6c52ee378ce247c18810e8268fb46584f007edeee0bd95d359aeadf52d801587f59fc80b751c44167a56fd24e0023ddbaaa2d649f4a8e7c0bc0bb99294f6c1b5040f0ab4705a8115f9ad2e117f727b4bcdd675d26dcece5d5d48a4b4ac41b1401f295a17ef4e1f1006601e025b7e5a26e5e5aec17ae2e8505a454342d2eef8a4b615891fa6fc8575e1175f71b9072597d04d58d8b11d3a53a09cd1d00fc1a6a94a46084e90abe17ca0c3bacd88ed18427eb4824f03c979eb282de592b2ba575842f9fbb78ec9208772c0521e40b2c34fc3427d6163a96056626c55bb97fa99825d1dd6a185e0476d0fdd530eda057a4497c6c65297ca68fb4eaf8e3c9535af0840455f6178be152e95de2b51b6c19c5218a14a305a013fef100940a570d12f99f3db60b9c56702a91028fb492c89b3da5ffd161cf2f0e3554e0fb5b29c26425e1794084a5d9f17e1f650f897588a2f54689d2647fce87099a7c757c94bcc61a865064694750fdbccb7d9e1e02fd5a30101b580934abb4dc34cac218d25efc8289ee96754135d6d3325c8507d085664b5b4a89264155112a98fe44f6eabd9324ad46552e820c9f64edcddf4855ae6e389c3b04fe0dad29f0d9775a8b4c182185958b7f0411f74576e650d22a079105b7639384e984a8143d8ba221ed4eb87eb66d0fd81bc841ff13bcc4f815d16a2b74b5980b138a32ae19af08b2e235c55fbb82a260ebf6005594c9ac064ac2b376071de7999ab90c935da3bc12b628c43c177f5f119230a89e448dc2ca3906cbcbdfef565de5095eb69c28ec1c0bee15ebfcb1a74784f0b694212aadd05739bd4e685adc0aa3c927b07b4718c4ca0e31b46d9e77de5f35b23226ab0edc8b41913f68e3c75b11877c4b939f5ef00d392f9bdae56fc1cad6e9718faa9f705c7208d036846b2d774cb4412adff9db84b429c155a23b96482f0165c34b5da5d12d5042ca95d0db9aff68124a5e0915c9280900ce6b18cc53deed95090b4401ef55aef256ea25a550d04debc4a95fd116b4f759e8d1c9b436609459b2ef2a14a2a2baed95c73697686403ce56dde1bbffb681855204475eb35d7222ed52fb71235e1a5ec747733c0efe2c5521096c0359acf3ddf094f81d69a30820d87f7684eb74b111dd4d9b93f5fd276e4c3ee42a92b900a51cae114bc45ca283c06035127c753568f5409b4d803c85069b3a187121f6a5b3accb2b5ebaf80bcde579ee1cdeac58951dc1e6a4d6adf4def40d1a2e953486070b3a785355a4a84becd034ab69aca71ed65a11fa2c2c83f0c6d56a56fb36d7508a12a762657f4cd3bc9744c57ff0d3a774a230bd672a96fbd987d8e935eb3580a7c52e94ca2879706334b2b0e1685af194cf0535bde19825b2222a17b0e55394bd174cc2c518d07d799cf4cf6a440aece15da6b8d2f4e16afbda9260d8109ef8fa496020e636a3d88aaf758ffb2e92fb54c642c5daaf484f5daee41cff43e1199dca0a3d5a53a169e2622464c8353040366d2a726d0ba3dfb51e1303ada40ab0464da4ffb7b44f996b579ca29e3b757d11339b9b393c215c1110e424fd02e0fc202c37b4efe1e91859bbb330a6a3691689d6899068dcb26e297d55a32192d17a7ad7868b43d5b677b540f76d972ef2a444562919a4b5401e04de6cb8703b90bf24055617b9ce9e48fbd58e5714e1384c2de8d0e058b9beb5d4873db23a6050429c3f1c0823002c6e2b94df89a57e9cb241bfb1b7442b8cb00b3fe2d14e0845b578b1b2af6060dc68fb30b4737847a760bb8766cbe7b189c6bc3cc4d9651a076122b79a7658ff954d8451632ba07d1e3bfe8a8c6109a493da591c50f182504f67c9b29e9fca603f8eee866317c45baf9233aeda1274c7b34a9f1c32c9ac068ab5afade27548766688421769645fd8aa96d40a004abc1117cd540d73d2b1b008d62b9136c74fcb0d0f6834f2451f2c44187f12dc1b13404e3241d5da5f6fb97394d3d078434271c4a59b5e9cd43d1a9de5f3a7a4b0e39b6f368dd9708941f49b4ae5b1ee9b70f1761c54fbbcafdac04fc39a28bf7f1fec68fb8eb616b874de6c16448352b3b8f2795c95dd2faa0647a1ca4e5d50cec18293c8451d3b3d2909df7d783c513e3f40c5a890eab0ff95697f7fec17713d019d81fb90ba0d3799fe65ddcc4f9bf73f0a62a58263624d9d0c3da1a847182cb2c29951193da8a6358e500a55447d670f6227ec2687d578552207d2567af0da69003b490330920f204c3f98d96143168464d14b951f23fed3a6765db9f5b113eff057daef1c8efd5e49de6bcdf82ec04d99a13af1ed0188ad8391ca9aaeae6ac6ba14a621d994c494386d6bb8dbbd37b03dca3561adb943357331d1ae981cbbb8e7ddea664beafcd77e49c2cb41ade4157b209b9c0ba50855daf7b9dfcd564712944c98081c79b959e5bc02d14a1a8dbeff17b65a30b9019199dcdcfc89c9a5d31d65b8b432da4ae4df26cf902fe99bdd3c08298f82e0544edbb6deda39649225cccf1cebdc2505518c38673ea1dd5e0eb451cbc7d230de10fbbc1f4ed19f5873cb0b27d83169a9718d12fd97b2bb322f95af22478f2f5d5845a5224927cde8ba3a53e8a2e6eeae1357511cd2d62dd71f8da712bfb5d2ca3664640383f1c97cbddf80d8b542a29b29cfda99c9023e955fe3087e3befd5dab1627a38460d5a065de70b4ae4072b40dac869f5b1a53d0f8162b5f8a59efe67d1d58de6a99839baa1afc76dd9146371df3c47d310617a0ed61300a1538f9fbb8f2c9f5d133c0a6d92a653bc57fbd4878d13f0946b77bf059bd4101e07f8ddf920fd84f012a333fdc4cfee465231a87076dc65d2a86f59bce54336c089c94b4b0d375bf37e21099f6f4a46c84045a2993fffa39ea34ec83ec0104025e9af5e1f3346cd9d39f39fa1330890c1302fb726f0cb483c55c3f36f5e9415c208ff155d7da37465d5c743655f51d88b42c3d42677f905ec2b6419c2d8b676d765a2ffbbc451871df96babb3b23c405a2dfa34f679d95769ff0c512c8e606552b53a2b440fad2a1224425cf6cab379ebea2e88fa8270617ddd5c76f228b8ac14c5ae1a4ebb79f14047e5a622d1d1a78d1f031edf07d8fcd1830ca335b2c54f119d27451f089c2114d51de01580319ab3ac56054ccaffa7c415b71d89228a5daee805306f9c64ae7e592373b09398472a72213a23e3d7cfcbef283c381aa8fdb2d7aed6fae0b303ae0e2aab357613758b97de39abc384698bebeed105718b53333912dd500d1b54b9e9cf2beec171a41a5da76c081d8a9444df96b6b5a1c65987beb5cf402aef0783163c98a75b3f28e725aa199c20577d15281acd0b2d328ea59d3f1f735d04eb81a1226a322970149030169a8e3957f10bb082fe051cc1fecdfc18375a7f7e029e5606508781b6fe211ec30c8b0c9eda557c101260a06d598e2b31f68a90fb84aa49b6b90a761ee73f26eb26271f5d98517c8826910fbae3b83801bfa1f87e545ef3c687beb13c01e82038a4414582974a921077435b75b9d217011aa9f98b0479659f1b1e729e7d3c7ce316afdeda4d9df6ab6af9bf51a0008378c6b4886fdd05f706aff42e68d4acc58a754f562f97c35d7c8c814dc8a21763c18d1e58c28415d32ac829b038d9f5422d7e8d0bd8c543144d4bbef03557525e538bef4b1c9a0788adb30f1abfa41a83162b11aeb3243c414cdee98209b47cc54b4b4d87125beb4a9d3d5687352feceb8625cdca8f517918138727955283c7438b33df03221abe7d1e6315b999349481ed5cd29c83e8bee9c57ec97d5ee4edf1dee8af01128a468da2c19352e79f3c26490b60ee14984f7e8ee5269cb5f4b622641530be2deb674af85f802c8d585e13df4557620d2857e6ed4a23e7a5bcd160968f25c1fc0f507ae06c09828781abb2655d334677ed172161a4df55ec885ae1d3534c376d3cef16200b36300be94f7c658ad89cd049c147f221b919833fac3bd42ca1714b699e65c6ccde008435cebb162f9ec794730b7d5818275ffb4b786d7c316b5dfe3e2fa2e27f1cf25e41d34d9720255548fe75f1f696e184d4042813b26f4f8998a804ef6b404910b5346054206c446a5590e6af234506e4385ebb795e6514fc85888ac56db030aab9bbe9764c4f89f5f59876864fbf1b77bc4c83d8ab718f115dd3b5c820fe7f9eacdec5951f6ddd55783561d989a204c68a8eaa33b3061b3131381b96c716468b19513be737b49ce33f3aee735c05e3fed06f8b6c5286e4f0d0c98ebdbe58ec3eabc6ea18ab5eb0d17821b7654c75524e071a7585e12f97ab08994c8f90fea33ac117b205ed2e1405dedf509c9fe4cbb9eeddb0284ff0342ffc0748ad65fdb67d372d26ae4d979b93ab92b32494725c31cec2f30060dc6221dcd28bb35a94ca6f5bfde23731e0ceebcc6a11b8f89acdb0f71fdf5adddff936c0ba91924db03be31acedd0decb1f054aec365aee1042e7d88d3dc3f40b467f627a26e22911cd52aa5995455a095758d9927239560ae1e11ee23a9e66692249fe10415ea67bd9bc4e3e31c6fc9e0f8257ffccfb0a84c34565163adec50e9c0440b23a21085394db81e65d13d46dacbb8fdbf02c30d80c475d1be2066b5d64d6d305fb9df9b85004b0c192ec6def38d44b4d0f436b7d4907c4b6d4e8de2e945a670dee93aff48971668fb6570f944305a18751f763e5701b1434813f27c2599416314842257ffd6ffa038bb65fe821b1a37898108662adb5edb2f8b5c8dd5a90659276aeb622cd43dec47ef0b2c78517f057062acb06ba35cc424dc5d4f195ea57751884f6269c563455d8e99ff820284479225c47073303ded85ba82aaa28128390bb66d372f9534bd535c4b44d94b3bf47c3dce5b00e51e357834f67f52dd8786f592afb869ded3a243c0c9dd212b7a30c5d4035c6f9efd47f8b80c615f926f7baf3d9cd4276f647aca8c038edf804a9870cd411157aac06184ad5ea8a0f30d908e4a2d21521d3d9e3eabae3de0f852fe3567f3ae58ed94a8c7b63f428b3185987be84cca4598fa89cb9463c6073031a3c5b7066dcfa4544af274bf089b5eabb725f807a4a7b4b76a74e161da8ce4417bec27a39384baf59c7ad65915b2965c2c681e47ccb6908151c9df1ea75603d5e8b8f09bac98f586514facc79bd328efc7bf1d512bf63bb4d11c27e98c2cc918529a5821b358b0760671df0ea05cc93f588c5758634ffdb87a036e1baae79edc075e3ff4cbbd3ec9135da77e1052d59a0bcdbc04e45b7efdb376b7fc7eb6100bf02869a451af18ea8d481e82d9ee7f8b71f0a8ccce4f3166be7524a0959911b22bddbe7def1a44854d36a90df0ffda2c8a51d76b2f097edbf9471a321bca716d1c300a42329f7123a6fd6f43ea046f64313975586670cb20ea207b7372102a350274543d2ed9d07f1695886e5a4e4305ffacb66d4fbffebb7bd4fdec8d2c8872957201688ab43bdc5b4783d7d49d1befb8b67c181cb7180c83687edc0de66bab6219eb5aa1a6321611413d27fb1a5af867639927aa28053c6390e825bc9092fbaedc97716b26bc0a86ba983257fb1441f0fa672b82e92702f0c069ef8d42841c93cbaa24a9d216733766e13ccb615f6cd09cb22671e8fe3d40ce0d58d78b7b0597676f12a22f9a663d211871b491229a9cf4ecfb255a5a4d09f2c6a1b1fb70b32e53bcc5a86e2ef93ade0aecdb12bc5f5436f5ddcad5e45c66afe4bab63e63ba2826bdbeebf3918543ac6791cf28ee4a4a0749670b31ab9fda0a1d19666302b1f41244b111a7f2ebc1dc7398948df02a0750c281ee1bffe0290e7a054cda769336c73780dab816436a0e0f02832d1a38f678feab9e57130ec89e7909f95f4a08ab306f72988e45fb4211ac417ab1bcabeacc962c1d5b4c23afe8","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
