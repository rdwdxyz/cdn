<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1456500600c30376a365a25942d8249698c0b4da52ef7234dce17da671d4385edaf247aaf8a978952582ec2f26c5fb13c9db1cbaae831dba3cafb40c28e26849d26659f800691131143b7326b473d3c39197f2b2ef9f1d6c49fb09e050ef806b4eefbcc01b8bdc2e961f782e2b61274568888b4badb88d97ca87d20be4d7b0d3fad450755dd63433af5d11a19075838e882e56708a16bf2d61e9ebcf15572404e9d28aa9ba72478ba04bda85017bfedff92080f7fdda4d5be66ea9d9682342032b218bce315618ec227b987c81dc179ea3d414bfb612194bdaeadd4bdf1c92897f10b6e2cb08fea2a6cf492fa4d44f3a000016c754d8811caaabf6741f96e186281ba9e67027aaca2fd5af99f646f8bbc20a50721760042b4937195bc696faf0dcbe5752835b2ad70241ac02f7413c99f852fe5935b1a51755125f1e15e9da8c132149f95934fadd47ffab347b7e9d9ff691c369aeffcfa2e4251686e7901c38b181a5e056f0a41d50b04dd3b84b13e5aa74df0bfed8b4bffcb816da07ff49ded64b84b1fa6b8cec6f5ebbbbb2694f9a137e3ae6beda89702945d757023b0160e6f55603e7c5a425452010bd8fd86aaf65a6e35a74ef5045de8553a6296ad9607c51dbb970f0d7380754c2b70c0950457cf35222b600bd7d671b25350ecb29b96cc35f824c3eea34936bb7f660cbcab8a212daa1ab3e8fdb20a8eb8a4080a9b2014bd95bf051e2902ba26c09bc3f111b887fbbeebe404efa70f909b65ff82c5986901e28f698dea3991a36b505863796ad09d074cf21b934575e345cb748dcbc4e7eebe1c98ad716f59de93e2c3f27e6d925b421fbb840c1f68078e05611d3156b3b4032896fc74ab5ddd8a05ec7a9fad4669cb917dcceb5ec58f853ab1700de67f33c5bf92a90e6f30caec55d6d5c80b3423bf89ca1e0cf312c8e7e0c9c2b00b1f85e0a5513b02833919ae32c84bc1a8cc43c55c44b3bb2093d8a715aa49b0ea158001c5fc8747c75cc2a77f79b90a7bb8132ff15eab77827ca389f49b6dd4a74fe6a5adb8f7b3c5386b7618829c65a01a874baaedb14dec09783a90e710dd26dd6d69116e513bfe1d663e5fa57b4a15ddfe6d113cb6829e4104609f7551fb73193ff5139de372e78e96cee80df4a6cda7d8e4e204b1c207f71237c61923adae64b6057958bc1daf3478976f9e889f48ff18e793d560ae134602856a3c9a6ece78e8bc9bfb1ccd211df9bda17db4b3ccfa2475516f8cf33e62990b55c4e1bec7887010753b05bc76bdb622293f6137901bf4635599c32d6c93344eefb033e49db61607439216fa0f5edba4207df5846c6e497840bb957a4bb7fe812f9a13455077a8e1358b0efbe63f26d328c23ae9ec479a6170ddedb53418cff15b126a4f99c5930e2bfb6985ae1ef6c75a4eee943d171058d57b44d37064b146d865e6198b775dd5c36f9fd12ac1c14207ea9cdd51014b866ebb4cc875b5e066a8cf247602d8ecb66e0aa2cf10f8ce4ca16d9c88ecaed95ecaaa03d5822bcb49fcaab84114f11c7a01f2f9f5cb2b8d2d987bb9320416cdc2cde464d65fbc05528a5d5db4eccfc265b4771289bb12660012f268dba979df64b394e7945b04973b28a32ed8d2b0a4b9eea6bd1e53fa494486470ff019667ef50a1970f5d70b4460159288ac9ba76efcda5ae034b1de95b4d917378a71ddab48fc9c8c53ec4ef118da4e010de9d31d269ca2132c5c915209df22303f60acb477999969faead73f4ea12a3d77fe4c1f3e07ed335cbce09e806f1f876f3b92a0d655b580f1b609b38db909497b561a1ebc86d63c4bc5a2438373cc9f38d87896e39d4e547b286ce5b65586c2c712da17dd2d7a439452bf8cd5fa3bb9b9a0cea311200d7d5c6213d84d33a652508ff92da1cfd8144aab24cb986aab39724d7ac28d58e7b50472287afdf881e282a6c5b0bb4dd416da78106e3a5df22d2ab30c6fc39a2f0a1bd393fb49106752273bd9b21898b8e746a340b17b74020f73d71989bcea397bad3f9137915b93378593df793972780bee7c2b5cba4a1920d2bcf5814be210da69f25cefa2ac6e280982da9386ed1ba4004be267dcaa9676f222086b6aec939b2c93b61b5067e3cf6f3521665622f971549edca3c31754055e149e3f713810e41daf4065272c36a19e1ecca14730f63d8c35d564d9ce21518995afb823f85bfb1e1dd60f43407286462ac36397abe11d4f4efededaf8657dcb8947d69c62d2d7ae7167178443479b1940c55f36785350a5e6d490aa9f70f7dda45039b8b4fa89de411dd7cec97b8ccc93a60663e9eb074955b64c0152fdd9d469aed2c8ba508dfd5819ef8272ce8e377613a5c579cd53153bf2149d249f10caafdff2e82736556f433f8bbbfe8f4328234c70a23763fb5784d72bec79c9123c0b46967951773664441b690a6d1c142047cb1b6bb5c28e9c75ee7a054421995dedaa5a9527e97fd5daa8f8f40ffb088a32fff15c332922411bf0e8397fe9051aa1b35183b4caf4c6fca464ee8e040ff0b5904f6226d593a1e85bcac25dda285a2f3c39ffe2c389543422d6a090e9f42c570117961153bcbedfa34a6587434bed7d0144c61bfd83c86231e10f67512b78e3383fd73e060b5eda33c371eb3a0954f7ee4e782ccbdd77c9caeac62e9b1a9c5afb7b5af452ff4b4db40544e8b9337ab13b4036685202cd8840b04da5e650a048f6b7b13724bfc3d29428a5f6f81b9bf21e3f6b4b8b1eca063ce7bda671e2f91e0e6377bab9ea800378ff91e35f358361cbc3261cad66564707dbf5c2292c92753b81dd3a1581728b788df77fd6345fabc53bbea96bf765d3d9d6920f617b3035b7deecdd99eda5b23cb8211f782de612f6aabe870da1b1c015f07b8d7ca62c1fb93556120b88cfa598e50f2125303a91716c448764725d83133b43f30f44d84aa5e92128fcde2940dd442774eed8946cf6997390ab008519bae823c3a9f471284eff3f5953d009db9492c5c25a89c3251d48724c7fc5fe0f828c095bc3cb0963919f79b99025b2a6d641b837f2b3d52091a703e4b03116ca1d9a1a49054475b5147450caaeec4b7afaf1c6b6654cc40ae40452938bb082170a211ceb4ac8f46efc058f13643ff840e3528d01939d8e93695970c199b063ba822d072a39016f179aa6e98bb588571405a0344caa1fd7af964a3663babf68bcdfc3b052070f44a8cfc8e819f64472ea53cb7a58d253f6c9f2c839b1f2332e614d967b8fd8d240ed4a68ef0d0ffd5106a317633bf2a0959d55cb918872bf6a791c637a1d5bc0f60fe38c5e59fa38d5c378d352f13af124bfebdde499649315dd2c845345addb10d4f12d884a3c2341e2927831cee53ef17cc78e70c230aa6a89a25ff0880d1bb8bf35069ea1b22f221cf81ffe7ed1976846735b94e3f384573055b059f904de7929a875d3354d9de71d9b7ef55e266c4db8721c0ed8dc7a3d59c9333d232ed7beda7676113776e729b4a0d16d220e651925c7d599ac71b1ed2436d26395264669e1307be840247746d3b070727671b6f2fdc41a4a73a44bf01cfca6f7d6e3551c17d2474f14e53123daa4dab64f81eac57cd1cd21cf3369f74c573ecd7dcd7d2634583466d4767f352ea1f029ff435ac80172d3ea50ec30d8a727d4722d7103f0fba29700d5348dca54abb58f30483a701669cdc3a6c1f5afac0bdb0631eb588409b1e4360d6650ab37b985cd4eef396cb52a35f35e2af9b1bf98bb2e22af1640becd2e0d7fd697ad0ca769d56b7befa2b4a4344434e81c51a9b14c2417441ab2a7912d0723214c1108afc47845e53bfbf1ee4d74bf7276842192c72808cf02c70d992313327c662867ae5af7788aeb12262f574034d86acb788b8f1c18d725d324c7196f77d892fad1ae7de6da8deef8aeb9866f8a34d86d8480c7c70f5c98ba8d8f9b20afae77e5c28c3f3cf3e638e8b809ba32a771e35677136ca83d9cf6cdd662175f6a77367d9adc664dc418010b025266f6f684a888a56dce0f900c38f7114911c1bfc13c5c611503a8166f5aeca2a84fa6603375f312d7af7fc6964889ea3495b2b0296adcca1834f2307a50270ddc91cab31878f51869ed2e06c38e6a98c2cf57ad2c2b4e2aaa390a253e4ee401ea5d0a16cf21a31e80d2cb3fe903122807e79419ee7ac10fe3da9db82bfc0ee1ee5733d355bca9723c250e574938d42b5e7aa3330a90adaa3ca91e2bb4a3c2052bf765abbffc83252736d5e2e7392e90e41532db5c8966b11eeae61d49b32c0a0e561ebea225f2af49090a75af9481e3f48e7b9f360113c565b761b6966e3cf08e7aa30259e3ddb0ee27cfa067644fcf4a2fdba59626fb030d1724600a15c86f075d87ad77fe3d27b189bff796b36898d131a0406e56b39f5ecee5eac399bee5148d61cedd77c95aa71e08728b5d260bf042325af5f082746c9d70c62b5cd60fe68803d90ebc5d0e5801f3460e166aa4973a6d7169663165696010807342779f6c48e8212713358bc83832c5f2559062617b4e923fe307118fa321c7b783b4ba3b9316e4da2b346faff33bb88f0e5ed1476aeb5e4477292af598c97c5100592c3d5f4b8460b38a92e83fd200f668511eeaa10ed4cc0c003a9e071e2bd22825ec7fe4f9ca1e183b70dfc21b558f09049dd11229533f11c372db7f1152ea86ca56ef59f39bd3ee4f7f4d8198c1c2b1dcea3cb6c6b6499d4cc7b97d1615ce3697b2d284d3b9fe27c1d8a76b5383b82de628d9941f47050ca18f093d08c5c120461ba8115d670b2a6b74f6c8473b758524828affc2f36fc02201edc81a80a8eb811cf931e4f649cbfc98392ac2d6827d02cf4dd9e380b72d7e7e5af83c015689fa092cc27cc3efc56e39a4bc784fba2adb087e63b5b7495ba9cfdc2a19a5b3e15573ee7001f87a4b3fa80792cb0f706edb52158350211641527fa599776faf80591d04ec6db6870a580c64f49b2a0eb11f4c01a08361dd07375a430c537a757681bdad3358f4654faffeb6f3026c655a402e9e296d0418814b48acfc38fb10ef8f355807135bb67ffd598dcd198a08b78fcd0f9e8074ac52b0bd1ca3724ec9167d803b37d062658bc010b6fd5b2cb37b13003ad7f1ad25cf7b5b2d82adcf802d560ec528a26802508711eb3c2c74220b92bce0035ae1acbb1840d744a974baf4f271a15248802845715bb50b603e797d0e58a69878bd12ac0c718dc650b2dc021ffb9bfa8a2fd7f9084d38e736589ee98a8658eaa54ee305251c8cdde89b09688716ec50b4eb75b1e90ee8f4b4de38efea60035055038533ea09c18b2503c4ea7a34d075a07752de3bbfba3ece2dc9fb4a6b5e57a9f214effb7520271542172972a5a2691fc559886be59a1ca49bcca7cb66df357d7c69c4410afa0b3b13ae50304aa36e3c311c3f74d3b68717c7395d3d1f1b21ac501ea2707bbd2f31a3683505617a29ecdcd6cb182cb7ec4c966b3fe2a40a0f7f01d9f1ea77e1371a294dadee74feeb039ff239fa7d8e183c07583dd3ea3f65aee17f5cf4156bb176acc6d31bfd0750de7b79e6495926606d852afa3ed148d55662025ca79f103cd5b9bc1e4ce30162bf51d0f2aa1e3e79587ca2a03afbc49e0405e020f01ee26a80cf302ccfffd5b817815e5e23f7858ad3a452cdeb1bd38e7ab0aab79c48b3a1d2d4f4162bc6b9d650b5409ecb959eacd93a3aadac2d39b376c9b72ddbba98eff4df32edfbd12554059395eecacfae8eab0deb0b950583f2cb4878bc33f2bac4a16910a80e51fd10cc169a65fa5f3b6da2fd57daf52c28329dba1913f2f1ee49828d76e7e9df1484eeb4a5e372febe63967051d3d47008d5835edd824f4b141859406ee654436b3714202414221627974fbab6470d006b0591f7a8af29fa55c7849658a8e0712f1f2de5a87abea92a7555f298f8c7ec1a395f3065067e72d5d820efe935048d4984c6a4399da38a481d578126d7480c76aa308789703762d060f0d200b2ed9f2cbf7afc64543c008287158611f1e8c419d0feaeafd30a467ccf10c6002393f8287aa28e3032c007f6f752bd3124193e8669c493f60515c97b59b61c7dd3f1c4d686f32651d01f127d70f47c2d3e2b3a18be20ea1383cc631d33e53c108363cc611e36462aa4718035e5972aedc531d248d69c1107bd066acdeed33cd855e89d0eab509df98c22eb89456f6c119e71716a0e57bb80a3856d22389b3fb3c8fcfd7f45f06b653dd9f02159c74030cda3ecdb25a23350a68acb724ce1b026a2e9904dc101608cc0d79775b2d43e1f74b5fba5e87bd1676ca4d2edc54d58825cc869230518f64d22c9c073388e0c42265868374ec06eb3228bdb25022b0ed913467353ea989d20c161e0a33e9188f573f987d0a339a502038d1d3e0bd9f77d9fdad0789768012b7e21e10a7f9d89c98e9a2f9beb65694280284c29cc8c5850989f0bfec643144274c4b6b8cafa727d358ec638ebb41f41cc25c9a1675b9e317506c652abb61bd024a463d4b2dce9317147cc6e015010319ee430cda0ab1ce6442ee6a94af71aa4599adce5ae87e3f2263f16ebf58c649e942b2c25f2f0c918df53ff5e27dbbdad439d1c45025f67494ef843fb59f9ca840e718421656b7058ab187d6ae6a132452dad67f9fdb1ede1b08e789ab4b3562910f0d354e86c005eeb7992beaeb55e2a7d9610b95affe76ec675cd4e4bc2fad2e9640a42f87d7866b2c596f287b5ffd72885b27b18275a3415ac7c92acea11cf407d2a0aca8a91c6fb7b2c170c5cd9040ba8c872f6f04826cb011b6a96d06298708b2c15e403681b32ac49dcd8f690ea3a6387f1da4e4eacef17ace92ec533ec9094a8401db2458d9f0138c3b031eebfcbbdb527336dff10d0da7740cd7d98c9e7b6850a22417cce560d99f49efd9fef2b25d57760c93987979e32c72ccaca9f2520e6c41b990191206893b3f45d90d2f47c6356ccd759c86b9ddf54cb4a3d69c2621fcb9a675171f070e702d4e8aacef1510b48944887973ff5c674ec0c7abfcd82480725acf227084b34b97a09e2ee7de04ee0d0f4aad50a13f7f010867909264fe0d419d848588f3e1ce4a15eab54e8615c4dcdd676e72df0bf8743c80443dead4130d92b2e85aacaa5e2e7d98289233722dd5a8bea4f9f21750656264503dbfc811a1b9718c077b49c5a48444e0d37ddf720b4d5e48da5ded334e30cc9c6770c244965253dbba9ea6b4d5b960b55499cc3d2b99b7a1729bab6d6ca8d0d2a64370156e981bf4c24c0dd2e2bdb806174790b2b3472fa42e7ecedbba68f413175916c0b243d3347d870469047959de32b139e47e062ff6dc060e2abd82c0ddad92afb8fa2cd740069cc24cbe7108019ac32bb0287476c917170f32eb73186dd34a7052dee6e17f50ca3577181ef04e00efcef68948eba738e7e7eb6db1c7c196532dd0e2e4f13c868bd803f60154dfeb4265a8db0b2df92efff7faf42a4f05c87779bdaa9633f598ef2967b65de4af1a9a039c865d95bb62efe29eecdefebdd267cef8470b9b80de27aeb5dff5fd57f5c6e044e05b5bd9bc10947efde4ad644c3346211098a85a370841d88218b89ce70ff0fe1a11e3e6c313e6f98e5da1d88a6233e340810fa68cdd61c328c3f30fa5235d9da63006d3e47361c2d04424b49c0bb1ff4915440a12cc2d24bc929368c05280b8cbc80e36827bf5a46c168714c7f7aa3fc01f6829bba9c6f8f95a7453ee99ed7185894e82574a465ab88a7e185b0796ca5f0688f4c2b2f84417ef4b85f79e52e3aa338029017b30c6f7ac5b7f7346d3374c96ed513b2a14b072d61e15e88dc0ed694158f9e25fe4c38847d796826710362e1876c1c99d16698e7dee88b2479855d57d3b892935e1c0c1c3f7b6f2cdbb5fe20c65d21ff9b974c282e8eec7516542ab67f0d69b81818d234a3f414d5bf2879dc2004f0d590f0b465bd3a1b92aa243687e9193259f1a11cd501288c8e438e0beb905648a4ba8afa6a9ea65de77f9b3f920de6c2e7e4bf0ed649d3a3d86ea7be578a17f39f9ef8cbdc068abd27e86146014ae9b88ca0512835f3596aa9daf79404373a3c8f1a646c13a45e2d2c5a5bd06bce8ae85a74ac45cf63c5c6a635d343bbd423d333a18b53b06547c82d886bb03448385697c800b9156cf22ea197e121380f024a75d4fa63a644d8e2c29c70c8be5670e518a8f8c26f6cff0a661ed2bdbefae1b03c3a5a20824d729cc180c1a9b4d82167e0616a2d04385212bed56a49c69af87df2393641ef51ef7f01a11706c4698b37240afa9268bd15bc11739d3b6df88f4576d75b9433b95912069f3586ca953b92795ebdd0f7203194a6e799cc661eb52596d9267681549ce7272a81ff91bf423f5da138efb388225f4e50479f7989900597d768929e7ac989a852e3a3034c6e680ee9d059a3bb9e292cf065e24711598f2da0b9c9d9195bfbbf9d431fe9a1786e6297510defc81a3405105cf542a26c665fb592f75155d057398f591d999f8a459227e7380f97b5403dbdb4960cfc2478c4bf33f7c74c0450987489b2336df79e859b65fbed8217161cdeab3e899fa0cd2df09e8ca5c3923f2ab0721273e893336b01eaba89b185b764f36e93ffa42f0d6929370ea1643d3e312ff8f8e51fb4b282162d31523d52760f396cedddbf6b14967c27cf414580b3265428ba18a95e85e003aebbb699162972eebe0d1fdcdfa1ee15f35032a8046ead61e14d6a6bcd6a567ce5da183e3b8dfaf82fa55f1b4f898173bebd2bb5c460d34f5f940d1fae5474e70a5cea7122c682ca27f5904507f078ee8fcb29fe42fdd150e7ae4746e2997eaffaf258ee42e319c7fa46729a40f7fc2cbde55c914587e76ee2c0f7266b5139be11954de41c02262cb7abfb9d5e847c92eddfc95b829cb31d1e0488031919e4301263d41a231a1a613ac5961f27725ef37c81b30dcb9ea4bda9a80acd39ad1b730ab3d1f6f3d7c7349f8769f60071bcd30ded3021857dd0ebcc98d3af4daaf68bf140e74e640b49d2bb9658068997af79dffa2638c4e4b5edea6fb48f3920ffd8d159edfeb7dd7296f35d52cfd3de612ae6e7c8bba0af27edf1bcafb5da1435ee531632b078d33ea8f186487a8e3addc6fca25c7a3e80228be551baf6c6ef859e139cbb00b95b1ead2048caea9cdc155dc12c6af60e30345caec0e45a273c00a7ea62f7afccdae2a867f87bb10b7eb1236c3c48a8f9a2831dc3664b5ceb684d8060047e69fee710cc44bc8968d817dfa547d77f4f2ec6fbcf8ada2b71abb3d3b631117fe244069235f6971db557d8950c7ee3319a0250c6a623cdc91082b6c6d192f1a660734b62991f486eb77907215c3a721f9f048eace77251b48b9271dd433e11a0f767169a253587d4996882f2c952f83a29bf75eb70362f88ea648ad60872e663fd4c6ede4f5e4289cc32eff90762ff4056206dc75e5743ccf05bbef4179982b69bf1e91c2c274871a78b9d701d81d435b7c8dd1210a581602db757bc26770867c01d4050f3ad91179b9fbfeb4edef05d5b8c229a28391b81456de8117cf9ae4a484589a698547863f1c7cc547d99893d149299c5d1eebcb35611188a62a33e57a44a5a24e74a10a265671cf912980d4277ef3aa0c76636ee6fcb83a78a4da95a1cb4e586fedd64453c95e94c85151c74b0d7aac3553dffd565b167a4cbef4d3ba71a258bb7c5f42c1d4ae7a113d48c33014b50a324e4e2d4fb3b32be3cd72209ebee76aed0cdcdb7229cf0e0119f236ea4a36646a72aab25b03a2259b4ebcd70ba17518fc35edfb0ba177f4ff43fa2e6bad46e0cce477e5c9d9253ee0df992ce6b25cf6eeac8290b5cb48655d2239f9019ab63e630a5d064aa9da74952ec7fb224172181d569154b44a850026f08a51726f44ee805276bfd0cd22111e0a82aadbcb3b208b7f58d7a8f4c95eddcf0eaadd0f5f258b4204a8f9734c1c0f270926267dbd968a228575f68b7abaf1bdf4d6be3802417f7745a0d5190883276539ed5a549de5cd27e727f572dda3935f3ac14cb4a7ba5ab315fab1c7edc63636302bf31adbe0e06102f8b8e90b8aef80168672ff526ef4ee134d7edee5f5d5326b976042b30f3a58e6e28008669c484c5d72becdfec46a147dc49ef7520515f503300e0807b898088a41554b86fd27524aa2be57c3c0354221a7d5dbd82949b03fcc2aec18c8366351065059d972dbae49ab02bd9bbfe75a5a719e91c862d9586a695578611ed4b0b89e6d6a583c96a0a78c30dfd6d67222e872e4e139ee160e450c709ec918fd3b307d60dcf413864f276ef34efd5a9b232364a3593be992924c0d423879a15fcbce46305a5450ac9e53c4062fc93d4b1bf932ab9168f1aa5d8a1d2e1f3bc7687b1b42dbb6382179df43afcd155eff6f9accdb02020e0cc704eae7c14ab1c496905aea8eff1d102a52c9f1c303fbb2cac23f521e7c7933785a2f8b7274e19743b26272e3081d0a329643dcb7e7c957f83a6b29d7456b41c339649bad994ac3b8215c0446b9fdc6ad4318214b41411a8651e166df343c5b204f12fbcc730d200ed9b7dd8e87ed0fb39def44bcecb49061823885ac8a8248822007436914a60981ef3140c9760ea8e239cf67ba561f24b8f3ed6b34b65a13025d0d66cd0b097c000dba21b16270bc11b81df2f6f06bddeaa84f2ec652c4c32ab6dcd223c189b4f686f9843a132ebcd58170637c8fe184d820fd32d69ea922498521854aa30835e4605cc28aec73ada157a21d32ae452245a45a349bc0dea8640dba3e8714ca7041223fa93a55c7e45f7b23478b689208fa62234f7b09b9ee91638004343f47041b9eccd2de12534ef8d57eee1774a8cfdb5b4b0d320e33abddd610644259a607e5b76b6705cab9602341905ee0f5192d8163ded190edb75b10969cea164ffcad6e01dcce15d1aa3fd1184a0112da7408c24b8fe68f1f1589943b3a41807bf218dc4455930bc2a6f9b8bd863178f1f20e2bc2717bb175b6561dcd2a0eafd7ea664f84acac50e0759d4a22034f91b3e257683385c1c49a4734a8a6b596866a259c398b0b599886be01d6c1bf52b98b5310c374643bcce5cdabd4c19fcfb70e6add98730590f8c92e220454c6672a8c30ba9ff6311d7e2eb320d316365b952fee886e739c4d2895add46da481b4be66c8297aa4c91a34b6c28b0fedc7194bd06da8bdca81c6d8cb5b2d9f477c6b4f58c1203a0dc530595225e551980858c41416072829538d979e3902ca71d09d3351093f0e90cf6ab02a6b1e0289164e3897b892565e305613321e776e97dbd32f690a4f25b117fb6ac244af44d35f71aaccde8bd106ce9b3e89be9fc301f80812822979b63586ed3d055a45bcab9ded8416da0c67ce72f5e43fcabdcc8025391fd4f28129ff00d3ec310d4ffa88f32f81276a17a4bfa7f4c0d68d5613897fd7dc70df7a1b3fc98c2c2196a81fbeb0d096a73195158591faf009bf7c20cd4eb4785ef84a819346b9d84543df02687c3a4e576a7481e389a88614c0bae7d6a714f0a9b598808a707023e275a9df7fba79d551d60b03ad815c38a9e7edaa813edf2bd39c02c9d6d4e7b766de22c491b70f0f090641d20de0a671fae39f09a2b39507b289483e11f544ad4c8be6b4c0428837be1459f5551e61073e1d422ecf083155e3b1c8d1c5cce41f03335eb66325da26a1a029a614e700d3a7cd42aeb8f8933146b22e64d82caa38fd45e678874f8b2fdd52445e185a50e2195b3e88aeaa50e98e5aef068eb6d278d6425b4dec2fd9df250a553d554592b0c15b34af13e09f534a649c0b7b017a9b60fefe5887f9d62fa5dad028e06ab68d045eee1f645dcfe073babfc9fa3aac32699e5929dd7e5ea7ff286d33eb74b2f3348ca8900158cf4a2ed3a52833034dc425db44de0a4d374e6dce7387bda0b12a64e46fb091cbd73362c2efc6a623dfa14aaa39ee06910b7a87f9eb0f7326836b4405346227b1bf187ffa790a0fba8779ea2dcb3763f76d1b995f82964f82832d4933c3e2ad5ec68a28dde3ba7f759c817d1c72c217545ee83e9a03ecf041be264591411fb9c34cee5c856b38962101979e8547bce496aadac156858e5c2738cf4752afbb85ceb08b3502550083b49e5b9843d850f5a86737e0249f8cd4d8b693b1eac0eba45fdb96893858c93a61ce9f8731aa54d7494ba801efe306fcd0849ee382f69d98bb45837c7fd81b6f41d687497801d94bb3f08ff367820cc72a964bae01e319272c2555578f03589b98d5d3c706d32e7e7428280e58396fa80501f6e452a8c02b7bb22c06d464f3d144ffbf4810a2ff8fe47f5c2e2ec47f60582c3174bc770ff16cfc049345ebd383a51a110f616f12d95d59e30420e33d4d432fbd6fa9e86dfdaaf4e34821994022ff5803d43341fb8a076f98d244040079b62337149a27472a042fc97724701c55fefa044aa7e19a13462ee7621b08f4585f64e7fff72b5f263c9ccfdffabcbe62d0dd23f92f3919193f2294750714e8a5066603b97c30d38e10ab77b75142bc881f042296476142af7b33af69c1544c3f3d04a57c1029b27569fdd23ee650a158e336a0a8710a6b5dbd58890fb6ca15773066bf83ab01de565798f7c9daa16adfd09a5c67ff13d789a13eaaa33f7be7df4f2db413e18b5336e470d9be71e05789fb90041346d65996fa045311ee505d7c0ad7c2654c5a597e8d15045a6c17551d48b5974dd42cb9d39769b2f692675a289b0e168b9a98ff670aef82d07441ecfa392b25106d97d9f2dfbd7b39ae9f58f523e01257ccf8bfe86c97d0047bd13f881817909d7866c632b35fb01a5375c41292917722cb57a45aaae10dbb10b01eeb126168ae15a0f07dffe0dc76c27dc9cfd8ee890f5602ddab8ac7608d4726bbd888b237e022a1bb9fd0f4ac6f9840b03f71b53c4bb6faa2d0d6c296eae02ac6803ac24a5a7dbb74dc0fc8c4459682426bafd9c785f8d89c560e107a67560c821cb923bd76fc62a4fc1435166dce425118c60032f35a504f57c86c46d594442c8688b1ce49338a7e3ef9c9be4c6b436d072c8bd4ef80adb5502e94e33de3d03fc68da3a4068fcd437d79006138e0e119a15ce7e96b0d131e4ff206654e5c07634fdef5b0278b945482503865f8e4594296db0078489a1dedb3b483407631252cf1fbf238c769754e2cad9430125506c52d02c82c623d8075876fa070f0e59b6171eab443e0fde0bc43e040b232e61f665b7e9513b166f9949d3996df09a4dfaa761f753a97ea70d6e1b86b88712b53ede0156c2a5376e7c0c3a3404b01a32798ca54431e3ea830a02488ac428f9906b76ad4ae78722f7714dec804bef5244a7a8764c6007407738891553a40cb20972c556c277541f520f76742658cc41408eea1143669f5783f05cb64597c62c39c4e8d8f464da6e58ca05ec502e63f0fa443cace7d2ea312e206f404200b70955b46ad28a19d28c98999216492165ff36f3eced5f8852d3c9d6cd230921c7d738ffc0eb43a9e45a3596ec5ea1f180274039b7b664d3dcb10b2213d28c6134449cc49ebc7634e5e56e3ae501fb3597df431497726e9b703f94dcd7fa048f258992d05e54fc3e55f2b1ea51d37cc6b8470f39845ad1e61aa8d3f531274e5eccf50023515537a132ad5081a92749cc7769da8d9e82b833e7a97af233dd9e902706b7fb1339797dc78558c22e64983efbf16f584b04b55d397585c02bb0150d94cec8075cdd20bc9658ba7dcf60137c08191787f45d0e18220a6f9dd6b5f07f49d1e3c45c53188a61d1f1e9ae9f81e9d6556b7aaaf52a76072eedba0657c1815c5ea6d4d85b64aceb785f873aa0b8cae0b866b6e0c5a18871829f4b5fb034ab110c59c8e62ef48bb1342ad727daf07a3aef7ce92078579aedaecf46e43fda2eaad7cd474ae7712395fbad1088954f045200c6faca078a5b088947acc644998958a0ae4eef3db30710dfea8ac8646e1479918845cdb57942f5cd1ff99f8a9d4111bc7eeaa09251962ceabf889f019dc3abe72b81a99a0a93a8383a402ddbf765d13e28b7738d4cf2212ee079de7f09ace8ffa2b621ae5179ebe74bc401b33c6d2d8308fb53c74a541be1b26b07db1878a29f7b2304939b40ae2c9db5c7200ffe71e1b643473649cccd4684e97c0bc799f1ec23f49f868418beb69705d8e32f43d7af8f44ff4f5451bff5a1887b22fe2d61acca06ce5254db2e3c47f1cda9f4c85d938c37bf010280fcb88b8fcd8494a9dce4667a36ad36cc9ff93733fa86c918b7f390f3fe3c077575d379ad28dc2aca3e79c294de1d5ed6271c528cd9f7d05f7a7f855889167175ee050b9b78793b42705e2102ca23a9ba997c05b54c1492b9101ec7079571d8021cd8689daa86193377405a63e7faf0677ca13dd942224f2be99829538b18ba1569c48214f9fc0f6287c973a5561107e29e051f0776f5863833cea6f530edd6ebef17cf0f4f18aa75edf92e72e0ee59937fdb0644c94ba154aa3f2b887b12b7d0bb827d93a6d8d1609b09fc85f63d915443d57e35c81149da0061d89cd5a174b35c986e1721dcfce0d38bafe97095dc475f0c52358d9767bbe3eb0f9402938d5d55c1797bfa3c7ed11a073132a74665acfa400253d584095972c146c20336bd5f2a2676df7edb7ed34cd39920b4e63731acf7ac122d9f6fa167ff8f3059b70af4e37e70e1f98d2bb5be6474a5162c6bf6b4e417f5eb581473dd9586d667435820a1dcc36f601b9436a29d28acc3627ecc83736d0ce9bd9306a4250e80ae24fff6abdb0d9a8e0067ffc4d67d769bb9cf0651f07cdc57740cc90ca4a7fd3436fe8be61a456c40837e684f1bd905604c0f327f86112fb98231522b0207c7bf1d3dc89e12b4b6d1330e92490b23e6314c19cfb41a5746e033654d86aa958184ff577b2a42da735afb5165617e6eb7833871cd8064bcd37fd08e27e3ecd35c2fcdae7bea2adf9497e110f8449c686e5fe9c1ec2d16ca624a648e16fdb096de9e44554ce4ab7ecade6bf08ad9ee8235a52ca2fe071e20990e077fb59cb08ec7e88da0a4750672fd7c9f376d1824baceaa2c7560ceecddb407913d9ff4d8b9b5db4f872e0b821a5b5d0a4726513f1df4662c636d86ab3e89e36aa40eea2b3931bc5c1292ed4dc3e5c5358d858ff0a35ec4e13f0ee4682e6a15279c3b1b0e1bd585555d7a2219c2fc912d10cb0c555ebaefa32efc4e31791da3b1f915515507563595357cdaf351f2563ab4aea8ad443dc1004f61d9a25bf9313094a712a6e9c200f5662ddc817ac7e5018d4bf74fe17273133162dfc3cc1fcc995eb3baa94bc7f63be9f40abfbe1967ff34d7af3fd459cf8728ec81fe88efe3905f83742cc2cf94a56e43af151c41d033f4b639001fe7fd037dfafd60840ac7e159d422776b7b2737cdb532291e319d56efee273da506aab5040600fbffab00fec66f74ba92e2632e2437afe4f1f9202baa39759ad32e176a8193fdc67d42ab88e844dae4fa94c775b8fcdfd0a8253676179004d6a03a13bd8982a5ce2cecc1e701342c3baecb9d16b51ab9562e02905bda6756f720fd88e35a05ef7936732e3fbdfde916b1020081117bc86c3a88fafa951b606d1de92c099809f7fb057774aea3f10cbcdf521f290e4f9ea480271daeb99b03adc90c4c01a356b313b3283a2e16587e34e2e328622f702fd5e07517cd264bd0113e0004b70f106602b8ae11c488033636b6aed5ec150555fb1a077dd1358a981091c8813f24a9633a409eb38aa30d60108ba7d966a0ea05166b741bb9c93a6f37b594195fbcf571659999eede097dfd242c1f1acd6fc7a6ea3cc9641a766bb6cea34dedd6cae65e9b2325d846902679022b8b04a6491fc50565f552b7fbd5670298ec6e9f24060adc2a8d2da1c79a1d61b08506f79e709621854db9ed7d32581c717ed271731986d58c02843e96c7b4a6e4e0ea911fc31c4b92afc17e1420941a976e0aee764f35d0d7aae761fbff6f1c7219f28a668bb360de7b6dde55093c5b439e5a3640c6e63f6066aae325eaccaab626c4c3f14ce3fd5b240ac8a6c2ae110cfd2e21040d8a421a511d402f274de650db0dc35d1ce826b867a49b3a97ce8d5b135c01ea47b7298d685a1c204c9f5eceb085ebd22cd20dc6337d78bfddbf6f9e6f8b94243fc3dd1d4f2ac7504277615010283e445529ce9a29e31d5a938b99b776b0425772d50ee5c027b91f6dd115389c0c6cb54dbd66851cfc054bdaa0738e799db831256bbf0d78c96a3c3c9d0e00b23723c86615b90e7ab7b41bb048d7f66f8e856f660d3002eece197413d687b367a8236b795d2909717d46757966f0a24fa4b9716ee934fcd24d742061310a58e5239eb7554beecac4509cd934065d979b38af388fb43a6f1bbe0ab3cd3b754c587c09a2df4aed7be76dc0c3dafa36272559e5f2dab713cfe4db972343223daf84223b8389672aaf9098edf2f2dd96f1b6f3c877c3487beb52402671cfa004153e2530da2bc93eb74a9bb3b18b942f8f50c554a4c42ffd6ecb6fa3d18f9c41447f9a27eac477e92ab86905be9cb3aa78032f2399753ad9a2d8fee71f635967a4b1b9a6675c3594f0131eb9de6c9e739543d8d23e4e1efda31c86df4ddc1b8344bb02e743632afa4911b053bc7c07bc650a1fb4d52a58e2c1d7e7a85df94659cf11a1a36a650274c7ef8cdebb3ed2fb139a05dbf16562669c41deb6d25674ca0af149436fd898ac11d71a91ba41cd2c481aed06cda069b0b9183c0879d77a47c9ce7a4c7d19880cb665f69f66d69d3d47f4aa0f8768521b6c506c64402ad750536510b6f8da4ac2579c0d9d03530b070b45a2c41fbed521a93cb566e89bd1de9483475e7261000f0232637f76da57ad3dee260d78562e6cfd68084fdf040b8cd959f9033f721ec25ecf3b1efeb110c2ed2379ac59e838a02a07bef4cb4e7902a6ea2a79ff8ba118ce0efd45bc43d19a254829b6781250bed464b531be7d711810b2450ce312f90ebe1282788c87565e0bc3285c3d1f17cc8bc28f8ffcef40f95c146e533d2c77704b54cec8ba894cdbafe19a3bec7cc645c9803fcb0e7126182b31189d29394f30b27ab0ed1c26ebd1fcc98721a22045cb0befe2bfa1ce0159d6ef305f180cb086d7645d46f8b1595dac5b7d2dfe8fde16cd53688cfe4af6a340e44aaa47827e326357e8af564086d0e8b50a13fb88e17838b3e2bbacf562bc7ed42af37383a8ffed006ce47944b56db4076e6ff853373c85c06c07922c687cd304878eeff59bd54c235297718edf2a9b4d3389135d30b21ff424a2caee4398ff1802c625d6d2d34bcc3fecf7d52fa559460af375575bc31978269a8714a047c3372bdcba82c00deaf5d735b328715f2e7336e25ebe0df53356efe879d6519c271f6ebeffeebcbf226896a1cbbcaaabb1255394d8d442fe6f29d93f9d7eac4e9e7b0f0f4ffe9c5e766f14416dfcd6c24724f1f3235d00288679c2e2562ecddd9760fe504f9d1179af9cdde953467e384e78324348abc53e3d3932c3f30fd918dadc2b5665e06af54bc064a473f44893d3a9947ed9040a96c819e8e6d2a8b89c219583817af33d2b0ed65f3a0a6af620eed512ad7086ced9573547e9c5417999da7726e54d49a1dd8567ad10dd87def44c15c000464ad760fef47c72d05c618989a17307ce4c110263f6c8b88436019980641ca179c6b8a7f3f04614618f70153b8158125539a4c3532a6ce6922e5dc44f18bc4c9214f86415a5e8e194bbc956a335a6c19c5041b83932a60d83dec0bfb946c498c0eabae1edffbde5ae60c161572996ab54d34460471b33b760acb0441794bba3acfc83a0ead393074a48d7cc10e8210d1b0d9a5639b4c73c91e790cd31abf2d4c3cfef9dac2734aee7ab9708127fb642cc8c66e77ca228b0109408dd1428ac268de8744ec8b070e062d04523b4e711d3a285b3d7915a5dbd36bbe41af1232ad869811bda3b55b9169cc07f25bc149c83a87f2a0cefa5d380d6e1ad0dfcaf5638391712d8187eb17","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
