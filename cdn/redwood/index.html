<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"50c0e8da8c7391558891ac47d39f6a505482e5e0a2ded9d99c48c0be3ceadd9d23987a627b2557cdba8bef83e99c08806847ed40da41b6ad0e11f0bfe6fdf07aca1be56ae21f3b5eab841fd8a9552e1813fae0b076783b47bdbb876af460683f70e7421b94408368b28286b4493c0d9daf0249735f0e6e2faafc48159e94f60d3912ae0d868f5ad49b4a1a350c931c84330d8b03cc9d9274bfda4159b1fce02c015472593e1e5aeb8955643ab9ec7efab3b3a885efff9dc58f02736ad80ac3455804dac758a0d51183963a46d485b3e4e048fcab541d5ddd019a0845318c52f8ec2c197da7126fd97a37d97e1b82b951fcff41c3993c686f0f8b2149dd82628e01bfdd7ce40c522dac4322c0231e7bc326f5f44dbe8fbc5260599af15574cbb26d523a6eccb518795a5ffe0079cd4c2949b1df7c3d8ab97096b7da1606643f1d36f07f8d91113f072dcd30562c6c63199f6145b4e277958f973d347a2b72718bb35db9d6c7bc06e7445da713ea43f54306ce4fcf6e375047aff0f988cdec8e5dcd18aaf11514798787607161506d67964f4f334f73c92d356b92e06c4b91ced4a9c4602d1cbfbda5922282d87da515a43d9c87dbd98f9f1c50bd48ce9abc58ea905d95916f8e8a14a3a6a2f721f50bf7572106651da69e66852fe58b70ccdb76c6b8834496a320d300cb898b380d3b3f2810fbc2ba7ce656880e377bcfd193de4f845a168b035cf9cfe8d5e5b9b3443c07607cb6a7298ff18ef2ad8b81c369d52a68b2658591cf259578b4c566bb1722e85691e61e13f620ec3960b23f733146b201b35c9ac60bc6a795deb2c9affdfd950f77e3bf21428b3d307f171dc7619a9ffbd8600cd0cef7b681953a274ca211bad53d878249a1e45a593fd92056486a6495802fd28753b41ab6876ecbd0dab9ef09320191507af72f7cc173f278bc20ec52caa5002fd414fdccc901b8f68cf74799979df30948e2ed15aa39740c5c39dfbe4f55bc8971eac783a7e010b86ab3f4097a3972c118100b3b177a7c9688df97a895e4a739e230ec3adfbd04d21d3b2022aea90d782dfaee4565729c69dba2230b67e754ccaed88ec1fe920a7c9a2fbbb8678cf2ccca499432a5fcd94987e568e8afc18f78980d8d8c25752e2281d72e1ae2feae6f15b895d621f357b2adc9bda033ec21bda5e9ec43dd2b1aba8c9a1d3d36618dc2e7ecc82a41c33d70f7ebacb38f5a34bf658e44129be97ef7e79c2b0f31c4d1bd45945034cb0e6119c37575365ac3439e70e39d5f091b24b12833a8e4c237e0a6f6bec650fc3408353acba96ee3c9f5e666a18d671070aa0b63f5c04e1ec0c74c7d6e2d2fb7cf70a875bd351cad93317477df411694f361bbc1bd450849659ae38076fdb5e8c44cac5e3fdd28f9f692cccecd1b51e6b3766b3632ca6056b78be4e04b610ad5051162ceffcb82c00d0a8c38d0e3ce4a270904c7e3ff91f51db851d124fb2279a794cb4212223848121a0afa6bd4c58f880ebdd229e9ad2bab724872f7259e4a852bc52096da19d6ef7d84c02ef816cf588bd953e17c93ee9f3bbc170ef7ecd57aaf06badf1840e05989f13e133c774e7a25f42482eca2a3594aa4907ed4e767e0a688b3dc88b4d0cb8545ae671c10029f11b32e12838d683ff94fca28c69dd4a8ffb24a43d861ec191677475e8e40f2762325e54f0ce95d5653fd1c911b602232f9affff733ea9d6e6982964b0a1cb7ebba7f85d524ad1eb2e4d3e4a7c49e10a4eff3ef34bc2caa4eda0db8ecbcdc6c35054f230fc67763f5e57510a6ef1bd03835b71840a63d0de007ff6d182ee7845a92f785b41ee93bd0040f51a4f4351338261d1cbf28008a8f3ac656998324cd373766530491ea75961d99a3d989ac4f1d79d0376119319dd1a68a73499bb5b20317b1cc46815c0547822bb4c7c25d0eb59c08d9f2a1ecbb47e0b74c347b335c781f3ecf441435299fc18deeffbd6a08d6813927fbd64f841e60a54abb20c9f04bd539ddf98bd20ea7936d9df3939cbfe4fe07edb5204c156c2e490fbc19c9fcd5fd841f75f893074d931f93000877362f01a724e124bd389d4575eea320d643f4a55e03277fc359df82ee6c3d72a3c9e2b3f9df1a48c7fb41cc7592bbf96dab0e8941859147ca3a18c2a835d6d49685390f4fe26e1846366ba7a79437061fa649ec354a48b94bfdf2d4e89d3f816d753bcec64ef090fb953110689140cfc97f72fa9e615bb19cd5bad697689998d60cab4d66626bf0197ff917e02ebe264ae73736559f8803a5814d23db23a8ca75f78d004519e43a7db45a27ad422ddd63b3f47130ecec0875c6f9afe17c523b083f7844e9caa96b7edd453340f59075695b4b431575cf72b80afb0d4c3b2b6efc673f138c0dbd044533e82012839fdac70595e3e7d1e0c178a110f8ef3ed4fe570a23bb1a1c5b34d3acb3f62f9aba53e0e34315c1dbcadd88003ed0df0145eb725958a64d0cfb917e8eb8c32986aa905d66c337c4d6764a2229fad65306d8bbf603e92435b75255d1ed29a5bd56a3178caff3c28218efe7c4734a0ed4d4bdacdfa0c5541b7b831bbe5d31b6494cc8ae4749c96f66f72361062e7049b5856fd503d792ce83cbac02a562128ea7750ae6c7ebfdb800d68ed9713d4a955e5410e85e71e99b91906074e0043058a4c7279be37770ec6c128d9b7d05c70aee655289734d000184579e454956b73316ce33f2c129dc44ffcda0a97f2916e85755e37dc4eafa666fd9cfcb057823012acdb714d71c7f6b42ad2950ed1fed439251af5701ce8f3f46bff1d43acf517f7944cb5ea6475f87b2adc2e5bbaff89f6e57af6a87eeb20d1dc498cceb6f6519d360edc6d66b9171d59ea07c6018bf88083fb7421752ebd747a21c49fe5d34796108292ec6ca44c157b51a922e54f93aa06cabeefa605d526d4f746177b7bdce6040d2c4fc65fda528081ad1da7655566b8093b77285cf1157a8b41f3c3736a1ce7784e03f27c2ccbeb13c38f9051a22db4a00d2a78e5f320fa0ca5a994909f3f96c62a1abd659138b7f5a321783dc93b8a96f63323da43671aedfd990148fe7ded72bfee09a6515c091d18387d264ace5d14b559a8728365712f34ccc77fa2982d7b7be5f0e7e3711fbee37b085b82d9868ea37e472b9ab82a69126907a9f21b7f4b85aadadbaf83e6f07fcd567a7c7d9a1219f48dd95e4206598d799478b684d9c94039eb6fa533527858e3b0efcf521ae69a1907c6832f8e48cf4d1336fe3ab4835247eee4e44dcc516a8b47930aeeaba7aa3a610168d623591dc9490f64f5bec95f9228ae9fb9ff1052bba0d6ed07631981e2ea42111698f0db599b699121dca0986aabfa2c66939151b83af0feb7d002fdbe2cd0f197f010873b96b0c895b125d8c779a67bddfafc9d8cb08c168292e4100d32a9cecff32c28a14ae44c86ba60b5a84c19533fef4b8a48531cda8c876542143513336e927a0e78b3561a8326493a6a91f4ceecbc2b2f2d8c632f82f280c81f9139146fa0c66eefc4a134b37663df2a2746d94c3e0353c7cc34d2ac016fa626ccb8a23933add28156b87e970f4479c41c08a43ddc149c984cf5c31faed3e7eaaa97eb0b61cc29df2ad8f4e5ab97c7b2c43ce5d2d944fe68eaa7fbcd13e053bd6f010fcce71292014f2efa621d8c6fbb0c717e8288a020e0dbb039bbfff6b5daa59656913b40b1c538b7def6b2c4b9cda31cb75270b0e72c8ce4b0afb0005d100270fc4cfef7c45be7de6568919a95ce10e40c0f22191f348eddc92be77429af18fa46bcf5d6d76d318070bca3634755ef4ae512b004e3d2873ed6f9fdb3dfb81470ffe1f6992ccb138327b69984114380ad22d333356f651e1c9a434e7268749f02b18d8a4ea814ad16fe5bbaa048da13ebfdefe4fb867b74756f5601d382821972df81bec1efba723b1d4ec95d6e4d6fa67d689f3b321fd9499ce7121f48f89c25616bb75cbb511c2beb86b29fb6e04cae0eabf4e6274a4254c8072ab66add5e7c521ea9a53608c58470de6d3f18b6ccb664483ae7b521dc2c981bdb66bb58104a68cf40b89d632690b638f331c252f2bf7fb407fd58c1da1930e9884807b3d9f482bd0ef8cc0119d8e84432e44214c4593ebfa6ab627d72fe9f9b5976139df82ea8af62a6d76f097cbaa3007a1043e4fc7fcbc55dd6209d83fc7be0af7bf95de04e290d3e53051064da792701da68917554c8eef08b30c07ddb636d8e5e314451c6ec11d2bc6608d3c59d6b7b22c3b0f5d913cdf08fd9bcb39767da5b2c1d3f1094728714be51bb52ab518960ba20cc029ec1877659e67028fe40cea0dc0a40bd1e2d1cc8bdda60fa3e63629211740c82fc9060153977ece43e1e32806c53ea3225c5df3fbd0101784bbbe431cf428a74b72d9dccee7ba961645f439ffd762b8fe29024042e8ccfa1b272119e69621454256a4fd68e4d5333d94d170d941f3f591fefdf2e6bfd2a67e1f13ccb4047b0840622f5068cf370773583bf31ba3ae799e6d2ba74c4bcf6d19efab3b06a5c81c5e8454b824c398f92459a66b949b71e2c41ffa5012a87bf8532d7b457a4791c1350084aaf5648a159c19a61d2ad6910c62375453c8377cd71d0b9a2119a06fd804beee3e5d4f0d3516b1a73d0daec7cc1db9161a9cf77aa39d8082f28e34d20ca2e175c993e6af4f2193ffa9dfe6ddb18b43f76dac7ba6c51c063ef0664afadd8e92abad79601c6b1c520ad216eab8283fea48a9b277eb4fc3dfca5ffff37e4217412be040ca30e4120728d4a176c40743686ec73a81b0310fb7d58b4a2a5035b1278766e6e19d62249867ba349cdfc722fab83adc0556b33529e6faed5b3948194c7f45b1e271cf4957bb075bc639f25dba21cb01a56a7bbef27c20c34fc7b86624051a77c67537eec5240356dcf2aeff933274ba2ca3cb28f284885b58ea45aa59b8517d5afff6fb9ded86d34843aa3c24fd5dd53087d154138cbfc8653bffd67c9cf1fa4fbb79501e7f01bfa9126ce3b20d7288b03d947972689a5f5c8e0b40466e5720f334e31140d7f45cd6c51f519914c897eeebd627017fe487fe4ddd57abca89768d66efc2c5811f3b78161bb7fde86327e2ad86e23b58971add2616ff677d011f1ab6f9dc62e422b00d075b903ca6243c2424a77817b5c245d79aa3594bf5e61d7f06260e6c673e75a2b19ac5f7e001ea5b4ac8de1641a718d78c4844755ce09fe31f8fb35c12670553195efba8096af70318f6b8bf8b4cfd8dd10b466bb84c6344bb0bdd80b600006601a818496abb4f514b51fff41df3c8419d2e0bb1fec56f08709a7a8ff9197f2e8e5c9b4ee61d6ab6118a64023ac27ef04e5ea77c56e7e6e0b6a919b177189903d0171cb6ef0ea51edf30f4a46c6cd21159728d4c84410b38c11dc3df67b4e448541f77734c1702b21aa4041720bf29d85a1c2e6f8c0fb15d30972c0738ca7f98c71e7eac9ec0b6c7abee912fc64dd9c55c31d96b2e5c82e10332f0ce2916fe85076456b89567c0000b45e3db54575e05f5799319bc43f15f68a69acb3bf03e6cba10c232dea44d3245baa80be515274a018e03964da5a858fe42d1d49d82039ea74809ee96b067157878cefe6eff35f70e43499281a2e986c8cd344c2d229e298c634680e247a8abaad72fc84828216cddfcbae42716bb9339b57e96d71b7f3c4b4007883f62d85ff85f4470b0cb493dae301f7e7d39c79433c3ec82dddd9ca9bd7f069392c5c6b0b4c02dc6f53b1692e2009dbdc29b05329b6c23800e0df569b456988e077ed5fba2e29117e04a1205bfd71421ca3085722b15f66c723e5b0e6aa4affad5d1deb298247c501ba56c6cf96566edef7546a650d69366eb4bd98e4c008daded4fcae5699855d35ace9958bc37078a421e906602144236b611a81aefac1d664f13a47e53695d17cbff6c37702dfd8aa4fbebe8baefd8c3ca039d43493775e9b0c78e117dad557ff0ae41600dea92333dbf8a7b478a649eb7e1e884ce6a6422605a802e2e61f694b85e02d400a617832fc3516a5b15fff1adc14b1e7415d0aa52bb3393e0b6d89ecd65f7ab42858b65474b38cbef424ed6fcdf4d8e888830d10c15c20ed43d1dda35cc258c4da4cab0b48058e7e63c13e34d346750b79bcdb96cc44583af93d0eb9deed8e789395e02c89252fa41d4fbf8f96ba72c528051a810d1890c477ae6185417e084ae65d4cd5e68145aaac5eb359bdeb0fc1b4c9ba45e51913cdd444d1d6f323e5915322d4826d875568d3d17ae8dc902262c730160de44e1026c475c79f2319065153eddac0ebc07d2b0b79f23152f58f53d82efdf87af13a8997ab3c4f07ed8ebc1ea75f353de194199d9e04e75000c3e968fbee3a4f86144f7084b231370781abc1307dec6bca555d1d63b05c066abc3cab2842fec88e8f068fe1e2e73ced57c7163657380943df2df196281987d8f94c5831f5beead430b8f79e1bdbc318bbf1c653cd8976d3755ebe6feb475fee0ccf6b2f0a1d8bf590709e42caee220b34fc8057530ad2e59884d65ba8f3a4d0a302de6a75eb65d40348075e115b38ee44b9047a308ab83c5b437359f2ffec930c228b93edba37b4a71af4a26cf5a71addba7e0303a4013607b529d88e9731ec7ff675522a6b2f44d6468d25f423f09b2f6dbe77fc85ad0c0a57eea67db10d7de7101be2a4d96182e032a807f2c16089c8453574d0955617137edd220712e82feedf439c19249ec677691d981e6166dbee6d758b0bb0d34911e045ae8e5c91cc360a9a66643844455e1893864c995650606a736b799f85a8de9a2cad31d67fd118afe36be4c69bebe7f5ad8bac2383de2d67f4c77625aa9c4cc1f0152db10f0073a929edc51ce6b98b2c611e32717135d8ba71363e08e7960545cf839bdc5a0e4aef2b5677a0062973fade6f1a0647066bea7c010f46164069343ead814046d6b3676109140d910a3a612c1fd6db2e4f2734221a111392a520a1778ced0a85f6e9c5a4a5ad030efeadf94fc1ce8e1ef9f83460c6d1e2edce41d6858f32e2386e53d4eab4f877bb49e80bf3ea569ecd982f132d2d37af99d5f73645f1fc4edfef3f1c264085e8269f447ef89f58686b8a577980f8dd34f90a56a632f33f747e81052dc8c9ae282cdbcbbc86934ce48c17426a44ec647fd4131406ed70599a24cf92df69d81046f4643085a4a200ac5b44f9e3efef89470287e6cc0ed44047ff18a05e119b31300545ad1746ceabd95866933c5c7fe5b7f563da457ca48df94f70102ed184ae04e1025b9e8f006780ccdc8dcd59f8e05f62f51e73904affc60651b769952677857b9dead49c79219772fba43319c6d187a356a91d4cdb1e12bcf376dc9757271cb649598e50767d072ffef8d5a35cc2f40deab6ec3dcee9e6e5de51db047a577863ecf7689322f98c560d3116e6a7d03b490059336f4c2f6aa17c02afc0ba5917ae9700e4595b5cc33d0d4d7a0635ecc28e80060a769ff188359cab46431ff3fb921de5cbfa28931221c847b9a439d6ea9c46d3ff571dab435317c69814df5feb79d6fcc3ab93f98184584a2129c37ebb51be58eaa5f7bd6c477574a96a736637241357fda470351441b6899e57a8e22e5d31eaa06d03dcc5a66c8df7247742ce880043642438315b128793c2ea6db9a8e2e99810aeef2160911cf63d174f5634dc4512c005f06b3da3f6eaa85f281d1b7004a17becceea65d3d77d6f11df6397d4e097076971fdba2153f19162adb9772dfd75dce6cd97231dcd24fc011fba9b3e33c9f5be0137db68f6262c10a8e73d3c18cb0c584e23d9f199d981d8047f39b9928630a8ef453e0beefe92f3df6d1ce4a8eeecc1ac3f48edab97ae4497bfba86796f46316c937ac62a12e4252110cf6961e128637b6e4a0130f83ad9946daae1ce799e68f72745d6b54db350b26a7d48c326fb30695be2b69322d43ba3b655056d0534412d78fc37226cf209c173d85800651417e1a3138401aab3a2d98d48e707469c94a0505ca0352820b80f8fbb928165328b89ee710bedea1a7ba84e6ac3691c4babacd78de0a1230a851ad3baf0db75ed61615c93e090dfb3c03fa160560d02627e96fb16c5bee1223f0dccc9211d55c4c6d589025d0521293864c389ef1b94ba056dad2be166cafafbe93163ac5652e66206706f37eeb71e26dd71ce2e7ba8ca8d0f5fc870636a15056f87fa6cce140f8550a1e6c5bbcf187d8d61868c1235b3916fdf32172cbd31934c7194c09e80bc53308da2c1040f31bcc63b3860c7b0457f3b86e94f7a482866755c225a0e94207a3ff13948f6092e84a0135eb6ba151ed3a29933127fb9a73cd52f24e1bd5c23f0e900364b4d31737fd2c6a7116002442fa81e5c807a11873abdf05ac06aef6c4f1497c662d5d6cea14df292c726ef97bc3ec12f6df260f0c4622a94fef1789a8bbfa526411545ae113509a34f55fc4bd153cee703a529e65ffcccaab19d82aff844772c49fd3748db0e4dc1a12cfa5d557e5be8bbe0dcc26b1acc0d497bd34c924c31a9281c2625a61e71217d05dd03f3161fd35baef1eaf84ebbb74a1d8db51594a5f2084b796fb7d163b886cdc5573dd120f5fdbdc397a5d56b7669b3750835f8c7ae2e8cf317bd0392466b3aaac1d7aa638463675bb649f3c4067daf8fc7fa3d390685dc47cd4a7577f6319aba1ce66d0d542cf188ebf03c97b940bd737ca728698f407e0aa13d5c13f3d9ba79f6b844f5e9b9c3abb5d0773394d49be717d4ca84f9277164685932e004f75bb358f23c82099ebf1133e838a72da6fa7fbdc0172bd4c2d44d4379b0f6f7b36c905f73d9f9694afa4d2358b605d1b6c22dfe04ff797eeb19d8470ac950c0ef1e2e3038e251d9293999d76d4e2f7a2fb9afdf7ede15cb4c9a9f422d47c2afa0a0503d471087cbfa58fdd86f443fe2d819bd9856040fc70e823f7fcda030ec4b60683f79679332a4d0309639193ca084726584ef50784904753b9ac1e0d3f021d152940ac9851d25653b407e396e435d1e39e3a6adead4d5744c20c1320c9a8ef747fc9ec8e0b8ce3370e8f6a8b5244959334c5a0ba9ef6d87302dd33ca9a2607bd0b071c61ace97c56d3d9c21dff3e4d0c85e5ce4d9798670aa0161d235ec709044654db1e061c46afc9e7cd87308a0e2e858b2efd5ed6af1a8bbb328db01ff280da3865847ff235740fa48c7ede18738f7b17ed125c0ae99cef6ccf541757d42a3b83c337b8163644aa4e780232a33d2654fba4546d2ac86280e2e4bda02879156f3e5b8dc07ff909fb362dc47fe8918b4fce49e9d6d47d9582086afe4604a133496ff936c2d8a53efb8bb8edc677d80dc84a8ed7c8215df17aa0cc26ffc6234c130e7e5d72bf18c465f07a504fd540c69b1d8e0f0bde93cfd4854229ce1dabf68b0096bc08832390a76aaa64b82968f35777bd37c51fd2f29969bee5a08f917ec0641f3a8b427443e7b9ff8bba3a03fff236929d48f51a4c41ecd429af96b195a18011792f26ec0462e2fca8f13a8f5db6c634e4e0cbdb579e750e3dc20a18f48f809486b8655020f1db8cb371241fa72b23290e137d95a30e4a18dc3e4077e95be5279c2a2f760bcc5ca3c2da6a63d1aacc31047427eb19221a470f406ce1a0b01236acdbd41a8183f044fdf841e116edd731cfa5e7676e680f064bc32d882f93b680a862601dcf3eda9814b52f2748c487a4840ff1fdd4b0cb52ec571b4341b00c9af9675a6414834d439fbd7a51dc130ec8b5e29e57eef205d254debf963cb2d1a36e6377731155f94563be90e0af48d12f2ba1ff66123f975ead0dbad361a5f1cdf6d9582aecf2c8f59d8d3a55a6da67ceb21edef2db799eaa5718fe75d60051b14a0192cf52e388d9b97eee39aee60a7bfdc8473c496559d461ee3c1c419f4d6371f12cd6900b1280686b4022a10b2e552a5b8371e56ec98f51e29a6d1c53594cff21f59d0292ee843e9d477e0459c537073cf7a984588bf19963840a8e1c824a920bd29050d0fe11d65b507743dc39508d2cf4bda0e48dc16d6e9fabdd8df237c605d367dc7aedb1900bf60359ff1595be6957e713a8b6bfbaeb96cd8980665c2aa5f5c9619f010bdd283abead4ad54ecdadd5d5a3fe2dda20dcbb0cb705fe65763106f4da06086087e5e9d8a3da5dabd5384e4c60709ccb16b6b76fbaefa395b590285b82bb6a317e6b483d19e5edc94c3c4610526bd9ef38c26d291c3d0a335785b06f807175a92b370b7028ed5bb6765b620935beecf271c841217687817dd347b805ee6c184b0c0bd2843ceaa83d283d971b5fbba1a0c10f671079226e98dc40d9f9ae734010698a1fa843a2bc5724b95c86e66aef4c133b504549c4068c3ad1a41a2ecedf9cc2e6be63221f6a969b56edbf9631dea9b3055f1a116963a73e8150283cf5e4c06a83b8929ac0d10041cf32228f894ff40e8eafaac6ce348ca22ce1eb1e23d6485442d1327d1d4e31c3ce06a9da2e47d9cfca2e82ab4c513c558fd0d3692a087adba7b0c7e71b642afd5e5e088f4d432885075b794b6e69ef0b3d8137115c4f0c20ea7a6446e6b915be97d1b014a918464a7adae1d1881945fe7c92578d6f5756e70a8beeed4ba142b2c850fb0fe3192d5591f64d5778fed59e84e02e8bcd8b0981bc160235f7b3d1c60712877b2d32c0e6826344705cb81080fb6b0709cf62eb39be559c8c82eb77230afb927b72709dbef0ad29fd849a061085a092f5fe8c5bfafcd1672c7ea50b14d0cd64185afff1b2ae25a2615dc1fde2609e0cd46fac261051c00f61a32147f9d0493cc0ce5fb4591c9639a50413725337a265878dada639af8a5a1224f7a280d79ceb2dbd0d5477a7af1a5ae2cbcfb4b39695b4ff49927679d1551d855ede328873059bf6d2407794035b3db5865d421fdd815a52dc6df01d17a29999d7e4ca781b0b09a347602a4767f19ed5fb282bf19d1aff0dae9b14d43b183b6279a6d194d29cbd317d355176582d4c6d7acc5ed1c7c85423439b1b21f39a86fab2964ac1ced8da7035dd875cf6dbc6aba66023d0c0d4040e6b629b92f9186f0da98216066f21899f547561c5d8ee2522ac3355bcaa1a83fcd7ec709732ed858e4faf2f3cc0a8be60d275f0b1c0a1ac7fbbe2afee5205d01d4b4c86e22b80b832e8db0e2e0f374ce3093fd2a8c3d05e02f81a84860490be3f1a69dffe180555b90331641bfa4d1c0e533fa52e14efff5701b8d7c94545b600ab848b27e2873ca1dc2ce736041c0491ce658a059e14cb24ce0aad09af6b825730a24e429bd95ffc991c9b537e56f5536f974c59485bb7a651c81aac4d92b108b996bf64e583caa84b6ed5951590fd55b7d76fbe3f8fe87b65e1b0b9e4b0549bf67d4591de06feefda7f3e3c30baf99ee0b88664388bd94b376233858cc284c3e5bf39cfa28f6c35ae0a839b7e7d06f35254dc6de36b7c53e03c5fa169db19d7d201ad635198cbb35815e878acfb0201846a1eb886f583fe762189c321a813f790582e7139fbc42d859840bd0fae3a03c2d6cae9eae20b48de05a3a51fc7b561c04bc8f151f3b47ba7849aeba1af7103560af92f571a484118e1dd621beebd987e1d86d97441cd0c86ac319a72d3336cc764a95cefc1b35ecc3a4abea4ce58200a118d7652ee30a49f7f8df8d25e1fc7d846c5fa335a4881d3c455d7ac04d98b149dc75e46b823e3ce4a9dc6cf1137610966000d9ac9727f83a5f546fe685baaec35bc61d37bb28a9c8b0e339e4c4380707ff214e41fc647a3b6eac8122afba2296a5690c252d0bd10078bcc468ce56bf86a12ab775b1a65d2d0b6130900a8ef340573f9a50969119ac83e1b81452a1516d1df8567154eb284c976a4f29049b979b327ed15ce2dd5a6b847ae23491794beac0fa2aec90922cc204c130df717cc18c883771251a08fb0b94f2e5aeb1a74531eccbd3b8e0f4c92e29c412e17b69151a5df777770c400dd6e44f0d3dfbb9eb5d099a2efb6aeac2a842ce80652c88d8a593eafb6017d57c0e81183a5d5230b31a6604554145872de5bc9dee0443f5285a861d016d9c465590713343cce6357926ceab8a0a9c9f21c5771c60c080a4685d384681e65a67b52d503eef77fa751cf72ef10df186ad9eb6f27b0d9613680d9f29bd43fd7d32bc476e3c105b94c415ca959f252b6ce70767e7e26b609a9aa76de0b3ae89ec169f311137244738e3ad5f5f6053503da72a9c631a9fd8c206b076bcc4d0fcf27d9557aaa146d308925281e7609ef3cc292902ae5edc6e046138fb9e407b1e65182503eb945aef55c36ab9a7d1d2f57f9c63f7afa24faf95e8b5d88566b7dbd5686dd0aa2699e38d43ea51e5054cc4c072eabe33a41ae7cc2c5e52581bcdbd88f1f9bf38387ec71ced39819dcf2c398314f0341bf4b47654755ccd67cb484fd3473291bef0bffea969bbf06d8c600d0f28b7d4db4347f1a41d66c74f785db3e1120fb7aa801fb15681ba3b40888af872c87e7e672643495d4de4dab6b1f77986c51ab3d3302ad450c8f78ad01007e5f1248c0279e93e0ed8599e0577ea94f0024022c114d48cddcbb3719319916cfcb5ac6332258414dcc177a679fe947cbe2d87713cc4ceecb7c81deff51454babadd25200ca989d2403cbb8dadb625be62254d7df9a70226840cc3666cda00f2e6fc3600f0ffdc24ad800fe250f725afade87c8edda1f77d8a13e576f886c614c1d5cc13342ebb2536bce592b9630281d83f7acdd177090e53c3da3224f5634b29c8588baf51c83b914053c2240107e956bb8e4912a31a915be443673a204e744e2171a22ed8a46ba001aafbd0d23988f98f7626b637467d3c48281ef3ccae0264aaa04ceea3c27b2e16950b312ffb51fa5d8417a8dc6c1ad03709c42390167b2555f64afc983cc83478dc0d2587f2a5eed36a70333b90621cec122124c7a4ffbb84800c0758a88dbcc022974c35db23d4f7dd5516b49a07e8b9f99582ce4b8dbd0ad0d27960bea0621e2f2ed3d2f280772fccc514f30e857c6bbcb55b0c2136305a142a04bb6871b56c0addb26503222642053d36a924b5aaba973f1a5a836bdd1832a4ed5b1ffd4298d38ab408393baaf563be63eebb8d35717cf55f9eb75ad169402e827b6449fad809cee550dd46565a126be3fdcb234b746800552cd1c963832058db264e58d6471e3e60bb9adac1c7557b8f149c4b99243861963a023b82b8abf20caa92e841306038ec6ce2b4a37b9db500350a7c16ea5db5f6ad03845d4ace3760c24730497d16a640c027499338a50bfb6b1e9fa6d7e3f7f81039c729878c86de45c8618fe5c109bfa99a0a602ccdd81eee1b72dbac59190c08ad2f8117e07939cc1e2bfab045208fb650fb6b7487c9781c5704d7ccc9a2452c51b0f4eb6625b03627833c7260f9677116dab6780a326814b1e2d6fad9d39dd5b7b01865ea1370a93d441e94d29cb62e5c1796071924c18f841c8470d11c861eb26783a50e15d7584a135b91e2d324910d9b99af5d3eedae9ef46183cd903a6722ea99eb6a10a22dbd2bb5541a1cbb4961c3ac6cd986082e25e8eee3a57612379c26bbc4f0ab1b6427c851ca600df0e69d8f7ebd3bc0f1f86c1dd9809e2562a51d73b8d22ef6ae4229432bd4258581b3930fd97460d8efbf19dd7f2f2c351b6bccfc3f2ac0f80a671a1302eaf09d77ad8e30ec1de6eb7dc1a3ffa69f90bec3e5a3d0b6e548d8bef3887fd3ebb68448a38ea27465c497e272a1e62f45898905c0765344fa3bda18f938712024dbaaf3a96401838eece6645851a0ead498c1d86f04d66fa85ff7c49e02047020a4f040e6ea4be79a9303380532824ffa24dc5c48f99e3926d2eef783ab0786fceed42adf9ac9a1e142d9eb606dfdb471468ccb2aa3b193457c74333392c2731424184e56031e3efc62927492c76f6630f46955564830482b03ddd7ed6719708e618124ffc6824eaf1d0a40340a22ea6e75ad1291cf67874d66edb5283fe091a1ac7506fc63ec358f92fee4bf6c4be09b84704332610e3b12de4bbeca98e0a2a33be37f0ec0e96e83427b0e5ff8774fc773adfe2d0fdac6bb07fc474303379a949da470e8b3be7060a2336d644a1d6c7347f7600d03de746c50205eecc27405ce6f345183910beab8af495d0ed43861a2f032554b69e3adf4910edeb6584d6b7fd8029d169cdfd52f3be40993d22f9e72d61b3317b07414fab734b5f95854c5317bd9d9e3ff47939f2d97dade1ce02be4e7af91b711db030953b697e2e0a43ea3a65a9e8e617b0f5acf68c6802311220469ca9824214d9446e0bcd35978a4eacef189d25e82e5dc322819301f2ff54272174a8e24a38bab75762f739301830532627c5c36d3723583e67004e8b60f4c9a225b75e8f60eb570186e3b2b3827705774dff1adca1a2a17664b5ea444ff0112e739edb8549447986d335fcfb505dc1eea5f77aaa29035b21985bf358d1e0003b57b57e1518179267b47db7a3e121d5060013dde2c3a06a80fe50fd8981ea9cc22e42f4a79bdf88a9bb59b7848dd20129444f0caca7a90276483e96ed51c514f9c32a6efff12060a35f0738a42fcd68ad4323b713abb899dad65f033760338768adb812b3dfecfaf7e4fc040e392164b1421001aea1ef090fe80fc6c66ce002e623db0319c0627feba276b08533deb2014e63807a19cef2763aa2d27f6e15505b9f2d5a2bffdd6d451772f71b6321d71c7339eb1d17db5a13d22bed34a075ce0b78816e6f23b87bef5f146e2bc877ab0eaab3e0dea2a7b21863504c733c7aa6b258d8749824f2ee898ebd81bbe7e84f53eba57266b19d6ab3b5721d278fcfd50e471c21cc01e480bbf4b7558448b3e4c2c89340aace45653cc137913c4277c23cd3dcc9623119801906bf463099f71563e0fdc5a5b851feb455bb38226568bd901abe3760144e2561746be9bb4d40cdbcf3b62ebe8987c6f6fecc9ce6f22330dafb121b3f3cbdddd6618632ce11c4a68fc7f347e9d5e40b8638531f0e0be1e2ee37138e91fee07b5187b3a6e01bbe98d816981c9f063fe551df464841b7eca3d69351ef8ab55c1e4dd1bdd4651f71cde6f6a30c6a050c05876cae9bf13ad5d2e52d2772014c9e431f20731b0bb550670dc1cf58199626d0bcff6bfda713cb3d7bf396921fbf806c820fa48a6983f71f973c5e1cff3c76320b20bb551c4aa9e767177631b38db5fc3c9cb0295b43bacdfff9eeca457636e837db68ad1eeb20767023e35ce2759db97de8e3c69c382883f14c29128ecb1ab5d10442c2daa10d6c846ddb971f9b8562f94f134f27fb9e42406e4c279074d4d4944628723c239f5aa8d0b05cf9557ce9b48788731f8f342eab6ae51aa4c677cf6c4110d076b54b37d2b216ae0cd1e317c14cdca140784660de0725d70c67b0d08581c0201a368835cfbffde0b5127b4ac6f96388f0d4f44732287cbb8a456d5ea1b5fc85aa2543b7d07f99a7429e829e036247efbdc6aa1c441c851a073345799dc911118e75587738ad72ab6084a838c1c55c9468e2f21d2ee8214a3f739671b34ab72c6a48bbe78c2a64e587356556f970bfa21edadd55e3759c3a267f00da72ba4d2f76e84ab836ed7df305e465b14fea534eb702146482ca98cc8b72f4d6b3b2af03f5456a3078a5dea2a46baecdb6cc9d9195f35de1a3f970f435bb5b5b951b569a1f4532bbbe4f565126f3b18a7b18ea1db956699689d4194785daa621570594ca0cb7527e7ece9bd23a31e8905edad3583b198ed2b3a7f65e16b78bc1fe957e199d2329c954bbc793e750d305e741799a6abfe558a527e25db25d9fcdaee5b6c5c557a58aaeada5d2abeefbe90a0306ba4e2e83f21798463addfd001e3288ba0237722fedc2371c68266dcda1f45889813f0915bba45f9649c964586465937c4742ce21703799823d5c81555971692ddf2aa3ff66e9c8ba99fe0ab8a4620af4ffe185a8d7fb59a6100181fd84ba143bf9487ca97002211604e0002b9b1cb112905ebbc3af3a92eb7bfb386d442e70d68f071493ba23f098912805f837afec1a6a6b54b8a465bbddabee770badcacc237c9582876db8b84d4c9d6a9527c326162da880716a62dda41eb5833d5b566c0bb3936b74c55554a4b0aa9249a1590439b1d832c7f54d28693112fea26b682d44c6160feab8deea942d2796efb8294d7f6a6d1c88c6909f1b25f7ccad30b18d1591b2665925ffc7a6b865a75fc3379bd68db9b7f196e4c8bea6b03bc1598331b087dbfca5a27bf562fb40672d195a6c0d0d888ef7ec04cc7032b2ddbfcd0a075c33baeb9c2720cf47599153d2e6ae1ffdfee5954a4ccc540b22bbc984f3198207a0c9565ca7a3d38aaeddeb1d5aef1e0ed76aaec35f971ab1dcd2e54ec738749a3b0056ed3b12bc5f77d1f100893fa178f7fdce1853f0476143cf860f999ca005d7f69b366dab6b9728dd8740ea8efa38c0b0f486258d73eeb7c42d844e9065cbe46d00601975c0b4264829503f657bb325dc3d906474c41fdd65e9076bbf702983a7a6b7347adcd9b7986c0e0ae6c026e351d389a1f5004f983d20dde9a59f87b6f6122fe9a4700b6c513e162273d531ef74828eb735c9f518d615207b31bc80f99f89d6fdc40e69cd89a36c129a3f93e5953fa5120b0860fe5e57a15d97f41a05cf113734a250a2b745699ad7fefd4ce0bffdd589129e7d933fd0aa2d5ce2b69fd142e87139f412ad9b025e86fe864535419fb311c412690db84827154e09f433fb439b6cc2b562ca977aba69a37882a211c65a7596f079d1e3ab531946974423449128701aa1dfc5db93c91682e1fb01acba4133b07fd10b6c389e5e2ecbfdc06b7e0ae24145b11a1c2e3718e12b5ac6ef5a0c669566d4731b207543db65c0a36cf3aec1c576497841c64d87460243a0ca8e7859b8e45ca3cc757de1e85813c24fd4be6f63b8a298d6e1fd533a9fdeda624a9c3c68c57b5abfe98fb7c8d5325789fb4ff3c012010e8ffe7c9eb15db2a48a3af5887fcc72bdba53c9e44d97c65fdf44698d30711657a6dcc5477011d7453a819c21690bf1d89900729407a16028a4738e584d1874cbbfbc18fee64f13ae5b0ce92c8052513689112b6b68f234ff82cb6402ed6ee8671178907d035208aaf1c47a13a10f33c18bb42bd45167067e8998afc7e5b5bf71c4e0f1b3cb859395ccab318a9e8e7022763b3ddf307957921a5edaaf903d1cd635eef891a3846ede52607a089705d4eed9b66dbed802d4a4f05e93a6a51f9ef3f3e88d8dae8a65049d59422c23b7d4b2b8c8da7fceecb6817f7440cadd923a88d21399480bbbde85c18adef140f1cf1b9b4d7656f5a7f5acb27ade69c9a1a1326099d057912bb7328c0c9b254ce92fb773b91e5a1c384a6b2a62e10b25b946ef2629e9a4b44d7fe049cf1e90f31464d9568bc2658add1abd6d45186d74286a8c2f6b12da38160cc2463333848011dc25848c2a57078c836eaf50b688a981945f682c6cb9e405be88a79a76b91b47c3f02865839e81deed89b53544c9b316be009afa1fdd67bb8db2492af39d79a32fa06eabcb4c0b5a54f20404eeb79d58a32bdb265fe1eaa5c73356785b17e0d7cc1bf65f33799c884deb3faa07e7890d33c881002930773acfcfe4a8b118be7e5e4b7a785a0c3511a3526a8f2ed1a3e202f6b05b6f4117bedf1206382a26deda1aef627b7c64a878ae94d2528354d84cf58e045b22c61b9d31afb255a2678a6f530c76525e8bb96e10cf8acc71198f315176fdcde0d555ec26d5987b4f72ce071aa60fc3aaae6091e7ff32921a509b12b3121a9ded1c0e8792adbf455fd63a8977c283aa5cfd936cddbb70a32f2ab41d84100a7f48a24e2d017b863201cccf7840b0645d615d6d488757fe008aab3c35efa2793a5eee7183014bff50b95f3cb46ee51c4cadc41212b69803fef1fca2f2de6b7a47191fed0b46d3d5eb5c8a43b8c5fbd3244cdb9305147330d25d88f27b18cb737fb5c49b92fb64aa9a9fa86defae3ead0d75062c","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
