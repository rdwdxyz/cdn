<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d9428167d42226c70b00c733c9d04deaa794e0455fe515bffc45b83a70892759d1d35a896bd2f95438e62be28072e4f4aee59213f29a46e6634de900e8bc3466979182c89a84c7e69ab33e0a355dcf9729e4495d784e6345d4e245ace4066be81a1fd9639502a50159b170e035088412cd9374e8fee042295f17ce9c64492028613ea17c82ee9603d82856d06d357f94227a5d4ab7afc2e3327024846ceb8522db7a68b4fdde050fd833abfe26ac52b92b9a8fc4167b6c78ee8ed478848eb3db84764c0c7bd23ecff74e8d9ce04cafde778de89e6eac11d01a7e15d7b050faab9648c3eebe861cc0f580d5f579f0baac65d41bb206d25ef171a389e9827b8ea977e3bd1803037c66504b412233a8eda227dbcf2eaa862e92dd1f8296cf518bf4aa0a788c756646d5ac4400f3d3d14ec7eed00e793d63d487701de31e7ae77ead22b541834aff52557ecd9959ada4b6234628e9566d037295a2e43c70a8b9edbabcb9bcadd6992d8146b7017d4fa84f3f1f600d4fc599f929ea6c10210777a8b379f7e620afff36d480be8ecf20b398c0676b8a9dfbd43e111620fd8906cfed4fbf8acefc62cf54f0c2f7d6fc21a164c341c5857e190349469ece77091cb87c9c6ebc5c4c9d25ac2d9aa37208dc122a6c4bb6401b77d214b52c3fab6d146c9298a04732e41d8999829180fe0cd259d3857456226692abb0b5fa983ebbc2d382256aa2ae5921b54c7954f3e1066cf82cf963405f4573af4d90f7d9f907177287ba1a295b85f995933f55d1d026df77c71ceb5bd6e9f7714f412f339612e5b43465a0ff413cba5ed509b73c7f0c6c7434bfde6119c249a0edf3812aa2d74f6ecd90558f5405b77ff5f77464518bf6aac0bbbcdeb985c5796e4cc8c0d7b9b83a8cb97b8dacab1dbe7236e13ed3c9b9042dd2a13ed17583025151a276cc43377b2fa1bafe2473e96a252cca5b29b37359603100afa5b8ab4bfd2726ff0329c64599bde44a664ad8bd81f92d7d2f33281c532c0b1aa5b7bfc3bf16ef87b107be3a199836e1aec8654288df661320456a9209806b7929436b0d42bd060b7e534d082308abba7aaf8bbcf0c38dfe31e5c564fe48f1a6261a2745f35a502f1f7a9c1ddd5e7c67f18682798df809d9dee55535af44937dec7954f78772401805e1a30bfb0b25e1902fefe3da2a5e35dcb668bd513b6482a34e55df55eda257f11c4445d5ee625f4778696bebbb9ade07c15b869bc1a875befc2f04b68f4e3f9f1523983b66e8ded15facbbbd7b10e3bbd81227836a76208fb29a0885440b671b650cd3bc3a87eaa91118375fb23c9110097748ba78c8baa6447786c54e047d14ff4d39b7f8f8fc2fc4449be00df36db675b113fae4b52cb2de398b2ebd6d5ad511e51764265b5357347c73c79a98c192fcf6b593724784cab8eb3a25350b72251d8fc82ed8ca8fb4db09c294cee2fd16b3f3f08dd414d24426adb8a79f7efcff3a1b68e5ae4c2919af3280e089fa7da8c923d30cdcf2577c2b120881f875b381b6813cf6779ab3845b7e5cf3b1cda160175439d93188d581b7cfb3057e81083e8823af5aab018f5c640029d7275a1ad840b2a56843e0ce67d9ed78a51f3a789603928a4b136fc1840b1b1b1684b92ffbd2442c2f7389d539687794e6fb523869a76c6c2653bac588dcc08fdbdbcfab9ba814d0d58b97dbee2be5ebddc414a6e96d92ad20871a4526bf933501c647667f251c9543eee67831d9b6d7106115c4e89278891eea3f048f9772e4211877b8ac264dddcd21187255f191f1053c6d8fb29043ccce190af03d681b2557bd7dc7027d1212a203fef1a54bb4fa5abfa2a9ac9cf1d2f84a6d7b353807c1c1597a0bf0dd07c2bc0ddb289e5141eafb6246e1cb0becdfe71e2242ea8274c5353e28bcae7997a17a2e4fcfb0e0946d7930189c4aa0dfb2dae823e92112e9b180c17ac337c4be6bd0ac9a9d0be0698cc033303a2d4805320ce8be9377d6f8541af259d539add213991ad1d0160331c076d211fda88d2cfc332a5c20b93bdf0c2ec279d69bc9f18e1d9b128c7a14f9889068204034a3e756c83e41fd1391bc713f819241226bcc4a464280ecfbbdd98fd5f4e3780313a28650c868887b23ff10fe56a81a7f8b7ef02e9e526c896ae672a46fb822cd0b38a2316588b3cec3fc8e7b31ba515b02fd3682ceb2ab589f91196d426d1f51ec91ecf000d8275cc281e5ce12deac77124ee0d1ea6d0e450eb61571efd3d78ff88a926e335ce4c0a8097221ebaf9810578f0909f3856f270074a95b2afc03f270feb935d144c800c4a949b6f7594702688a9524fa4aaea4c0ac3e6d7978e65d066f554472f6a80dd8d1facc43d51eba872d13d8fa57bead6d08301efe9845ef37b778dea124f4f691221ce10c0700cac7be8b0852747c6d53cc4b6c7976ffc610da5ecdb213c50c94e3c853c30ea15087d00cc128bbfb5469af1824a176fa4f16152db6a077e85eb31cdba438c035c64e3139d6bd71fe022869ef6a2a7513a35d5177d804a6fb7b635ffdf2cbfc1fa0e194adb3f123df2b203bf4906f19c48986df5de626a08c39ece403832eb085c24af3cada9e8bf55abacf8be10808be9d7905abcda6741cdc0a9d856e293423f673172abdeaa787edaa9ebb5c2354ea0e302ff5e7606b020a7e1a656b0cbe1479414906d4b253c24431af920f1c96f15653e78c4c0ccd94415b2e1e4c874a5adb6c9b31fad52f6c5a59c695decbe82a2120ddf0cc3373fa4b7ebc8792e32e14a32a3f88769f4f917d5990272a94ca7af79876c7a107efae49f50baef32f915f881de9cc6884c7aaa9ab263e03c720e939ce2fcd97295cc10687a265a2ce46a612df187c01dc82e077dfafba52b4b79bc1e165409659e9f609a16b4aa3c08e7710bec417038c4cfc3f66af14413991b8eae15a494b7471d05ce63a14b8257192a0d5d06e16364530464b88b6a43ce8dcce21d522db0ce64feadda62e47af30bea0ee3e08e5249a434e88bbac09b2a176532619e44fd23954a262c4f9bababb033499eaa02caa689c601d3923dc6e06531789fb3e25433889cb46ea919df535193d184379702d8ecedcc0e09d6090ef03fb12b420fc3d87558bdd1dc6a1b42e84e36e1358b89ac42ed6593bd997efc7cdd240e63738e77c4ace7afc0105c552271701113f0998a5ca80e309addaf5bfbb32703903b11bacf608f903cab494d3a32c4af9d045d42ed684e2947d13e27872d90eedc356aad5cd8084e52f80889f011020b8f994d93e3815a3911fd636148e0e8e9f53d16bb8123960a23ec31bdc32f1daf6eec83b1f1b4e1e6946e68b0ea6fad0bc2413cd35f2154aa4da37005621948f202b0b53af694e6743b043a93b4952a2fdf26f2a174f5ad08d40e0199072c24865d300ca9b82029df85a23656cf456ae5be338afb72a501ab72da6e1604f4b50e395305989a8f9951bc186e90dae847b7e935c25d53d1746850546f62b97c02d3c37d7989ed5e35e0a47f6832382e66d056ce7849d331ce9ac1422c2e5830f63d8a43b2f9d723316c6f22788a73be6be16aebdd7dffc9d3a6ba741450b77f53347b8db1caa0791d42b138fe62e4456beff060790357ec18a24ab9a78a26b4c2959197cea1ac8da5a144678e208a38e2afcc1639efa5ccd5cc4e6fb97423ae26d5fc010a83ab1d84528626db7c642d0165bdc262ff2d4968f5e97e357dfdc7fcf6b505c31ac9f6f3080432c110fba60bdd76f028a952cd70e89f9d1268a6ed538a7b7e0223c3fbf6c1f856cdaca7150baba89f866547872cba72d583b348d278ec6b7c74184c617e5129d0357aa79940e1f2cab4360fbfe0d698b97e733f123732ce1c90073f21d9a4fa1d71317d375c727c7de93383e003bda8d44e64c80af5a952f173e4485343ec0627e821cbe6c237dd5e46d9d58d367c532cc55db3f27c749a3ea2cb84a6e245915cb345af0b8c14f1b5565e4e05e460b5b8c300d2142dcc161380827c78ec1d22b3c1ff5c25f92b2793784d27d58d41194ec1f386a6629151b52e0b05ab14595c901b8354c101f8b064ae1ff0f3efaa3a0a9e55e3ffc2c665be2b5f078f656ca0c9839a02e4ef0109b3464ee03eeb27ba9a7e9e4448e466edb92148e0a2f9f8d8b2cf509bb1ad4ee52da9bd48cb77e00d3e5de49771b523e6ead7f72f625d9822350fe3bb89bbc63863f7e90258ae523fbad10fe07947a2a0727a1b1268e54143d1250f91bca56ee5923f42648eef12e177b131ecda55ec123ce6dc9a7e4976e0740a5dd05e7c85ada4c19036c560c462e7d9edfc75f323d03a3aeba1d15bb177d0429be0cf0b1ae197db93e7f4fa0ca52b837c0575d1262819a39bfd62bdb136be6c25f452a2293ec6e2da72e3c23e73181060626a3ee2f721f221de713aba9c40f24d4c8bebf3d06c138818a9bf02a74c67ac001fe6872ae17b0e12a5e7d59f4f11d8f0c3060dcf29e6fbf1763220a902a290297c7bcc38ace2acf22a5c5777aa0e8c9b558028ec0c6183efed3988e97aa8da4fa8a154e27cfee4db3901c0d19ee2767ed673242f309822592536020ef7b8c267b3cccdfb405e14dfc3a0af4384786cfde12d8e3ac68a032e0dc8579d23cf7983a4fe8f0bde62317df7160eefa3d1ac7d508519b8bd51ab600a47543ccbfb60a46ea0b752f3aa491047e58fd796267fd8d03620af7eff1ff0f7999b3431a2775af54a1106858a040516bf621de3b1add2e6502fd6c0409591a79c34f499c8d8a9a607763fcc50cf82df0472bdff37784e42596ad388499aad6988137b00aa952b6fe4c70cf62eda3e1a32ae62e0d1c464c0eeba99d8cb3c4004ce188911415585eac729c27ed3fec43af69cfe8655caf2692c7dd9521219103f29f7967799225e7a422dc71876beb32316c9dd89fd720d5b2c2c001428788769aa19a7eddb1de9b7079cdc1cea8b8ad77eadac520cd0559dcadddb20ebb8e3c54c1e112e5bf69896db040e6c17973c3e45432618ba8696a4e95a12cb83a613b900203ced967c936ae0b97fc2bb9cf722dac1f4db3acc2b75ab89544a2d5fc1c42cbf60119e38884c72bba7f6399ed5821647983ced83360c9df621961fd194afaf6af05c32e2fc6982270fca57094c5ad2832f4fb15cb9adc909c0b78ac490c80f48d28fd5c4f0379d66a8ade4773fea4bb1093875ba9c08ed75992b60dbbd2ab74d68afbb3a0269a581e6dc722568b92177da3e0cb5b367a4ae6691749f2f403ff8d36feb88928f89df7c46fbd0600990c3f0b1cb6556cf8c51e89b9a197a9a048949b9e8a6895f8f3780243d11262053cc82682be8e9b928ea734ad563aa326ea7a26fc92865586dfe30aa12035e01902a6b68e2d4fea6848e457b52aa93a4bc8432a1c9d36f82dbeed3e5172e49efd45998b9685e3d8837112f111666c27c90a2cc8f93733d347cdb5c69fec77f80b2b8700178a33692039c95ebc47c6438d68a32523bb67341d167f38f5e5d2c14a836f5efe363a8475301f47397c077e7b4fe0e2b08b6cad4bc64e0730c341038834d9915e8ecda52f79aaa8e45dc6a732ccbde22c708f8ca57f173f51a89fc23b387ee7c5981c8f964d4894ba10686cb7eb3d4cc1b8bbe3ee7890d576985c543d1fc580a7c854f1a7d31f5d9aa69e1b0e20c69a5d14ee5b89aa248106074ab7b14d81b87e98010b55da46d5671334e7a93f2873536ef9128296b72143603d13682c5502b1bd71f38aeb58bb5512465a6f8f28d5b5f6e3c4f682a3926a007156d08c4e3a571ff2922dda570b10eac574ba5388e17abde369d1e636d8599fc2ffa00b3c0493a6b21c2be4214d1e3c088c90d849a2b17d16522a5bec7cd391b1f814c617eb42310596a0fe64fc3fdddce6536ceb254cdf272271496287d72af5171bd51344ed432be43f00688a8423b8668d69c646b3a299ad4e1fd9ffccffef217df3d3f500ff56e2cd2e381a808976a08f3f8aed38753acbd3a43859090835b4b8ca15ea0f4527053c6ea6ad8e43f5a1d7800e182e151ebfc33f7cf6157b1b1bd3335d6172309b2cd7aebe225bff9b9977365dc0f5f77cc2e3af77f608964bc0b2fecdbd9ddd2dfe17e16279fb0823fc64a305bd100232aeaa51a67c9fb37bc0ae3e9c849ae6fb608fbc8ede900489031e1b9430680c5c72ef5aa934f5f93f8e532108099f79055fb5defcac5d5c38a6534da2d3d58cebd65dcac1ed6cef5edb262da2453b80b1c94450f7d39a64dd510eff205dac03e27a55d4f1a1e8798c408390d44c5489cbbc1a0b17ab573abb1b3faf3247b7cda3c489ae2a3c1b71b8f00339746e55f452c1b9d3162dfa03f91c329d462ebdd2fc7271d71d1e1e9995e61d79a537a817279ca2d61b531a8c60256a1db0b71f708a405110a05c4fef9a0a90caabb90ef3c7203a9ba70b1175acd5f601d5ae7f3827f8badee3bd9de1aabfa8c802d46764465f03004d8442850742f1e5ed199cb36816c88b3cb633ebacc424dfa900c7ac64271f5f28a515d33d38abfb9d5151d1364a06cbff922b9054b044cbf8b1a4ccbc26af45b95977fa2134aad750ce74cb389597d2ff424119976666c39beaa27476af2f87be0a1bc9216dc74cee81e341bbd9a8736d2565f490ded65afd706565d8022865ed4d35881e92d2e698b5faad6ba8a87c731c6fd8bca3dea15be080b90701fd5d0781f2afb1490fff3b2a036297accb0fc9c8c6b493175a4d74c96dbbdaa9d84ea2ed0771c42de9d3f0ca56a1a5df5495a2abfc13afe0e871cb3c253dbb2a08ef6b947cf962dda911ea220b00ae7a9bdee91bf4bbdbbc778706235ccd859ecea3c2f0ec4414c03f6ad6c15392d1d0f0ae6f1947eb574fd849e1cdaf1ef2e9804b5afb722056ce6e811e555ebe3c5886635b80ff28de804aaded6e9fc11ff27eefdb969e0cee355dd01f451d2316ccbd0da6559eaee480d37612e8e62b3688ba99fe9fff5e853fa38af58c77ae79e5565b82646d528812f7e9f1844d9a054f8ddabc7a1e2a9333100c61ac3f5e8e2e65e841f4ae4b7fd44aaa72bc9128174d3d19f50e732c3e407777f9700cae6b94dc362cab6f95939bc914a2cb932dc2e7c492b77bfd8af1fab24e14b3603c05a1d75b281f50f28fe268519e2fcac351d09f336c73ab40e0f515fa1f8e8ef0b08071609c388fdff3bb03eda85053aec222b87c102c8ba7d3b6d93b19f42c645664b9d657701363787aceaa96f25732a8ee2c8b39840778e75bf68fb41e65a3653bd3ad0ecdc2075f782ed99b97757924004d6489c1ccda77300341164a9680cb949c047b367ee4e7259604f6da42a4405f4fd97feb6a4f54982b23412ccb61e1d9d1f6424af18ca37d8a75dc756878db17fd34b4fd20aad428989c2d4ce1cfe9f9471d0856f06bf12014e4cc0247fe374d140143ed87175e80d6dc40e46572300be14cf765e41467138dfb88b892f1433c5a0bb03f0a0e932fdd1da08d86dc94997b6a1dc5ade65fac6d0f788f61ebb82f34123e1637cc6ba41c74393eebc81e8daae78cf7bd40441de6ad264f67fdef3ad6b32688155ae16941b5f61bc99c31f4712df5813142289aa91140bcd350d376c8711423328820c9094110663b21036af17bd84182edeb8ed1114304796d7561e4de271289e90892a4c4c05b766991afad425fdca1934f25fd804c0fdb26beee48eaeadace6a8b093051863fd2bce9608cc988072de973d6870946eca400cba2fb782730ce2ed74b122d38a1a759e6840e6faab86de6497352bff466e25fd6bfc24b7aab0ce2ee0c80219098ab2469228a2ad8d91a8aee527e5656ec6e0c15588bcfba9bc9ba691c8b59d4dedc4639de25f9b76b56fb2105eb58d1f2d26e0e7565e4a88bcde5f46776c512ca07294467aae0ab9950e89d2ede5795aece2917543434e8cba90cc51477872966b93944f86b05bd4e3d4386121609d94eb7add3b44b33cc633149a637cbbe4fc3d19ce189da22cd256fd9bf35be92585604979b8823f2b1f460a53d4c89823fc1776c8ee4eba2c98af9ad5e5846f99022981e877b638ca064ef0109b3af1ae2e3af81e2a8e51ecf1d2b51bd81d28e129cc21c2a70401018e7eeb3785a7511fab1b088dd5da7ae8b1083844fe75427136f3227da639ed0769ddf143926ad83fd14bd86cc8584076c62906a23d888624e3e7c2d2aa246b090e9e5c53fa72e98ff957497693ca55f3e3fa3639ba3a8154011033be746cadc94b120c5cf952cb7ab6db5e7901e1d18875c79592d284149bd3931131480c056cc29ab7abb3acc9a111db92bea49bb1b7a80e79715a997b1fff97f7f31a7d5a9536a8492a3f5aba627bbb52e79ddeb5dea544d2869e86e8f3d4b006c924ef662ecabc6245c3794691f74cab864f980aae9f0df60eaf1612e63dcd31dbc973625e6ffc9a57c2f6f121620abbb6dad0db4f845030f64001004671f748f1ac224132303acdf7d36bb376f2acd39db9158d095118045186c2746e8395e702aa5048cccd9c0a2efbf76017dbf1b96d292b662eb1bf553c7e159357fdeedde54fc233994b0135f1281a57bff4fd48ca78460a42f27ef2f972864e5905b0b0e7c7140ff635f52b36ce91b0e6f4f1943b5eabe9dc1f9e45645e80c1714818c344d85d2ea77f100dca8107b4c0497066d6c11ecc6666dbd021e1a377f81aa4de6a19b7a84dfab1185579eac7d0defc4aa85f951a9d81f0a03f3f85e5041822899ca9f3ead3dfadccc516e8b1eb961fdd817d31ca0c974b2e8da6953c26c91b49049680796c9e882efbd6bb5859e0d9165cafc0874efb1cb7ae908197f6abbe24f80823ac1677b61f83be389ca30cc9f0757619a0fa639e88b0e394009df2d0b631014930c4fe4b4c5c862ce8e426fc8f4630e76a18f89e8b7a1271a8ca19ec4d2b5abfbf12b331042aa455e6b48d6d47d2a0f90007cebda28cd6ca29f861c14d30be99511128b63faf76990bc892bbde29562db23f49667ac7dc85328999c90bc356c4bfa0d511a7bc506f1ee357e055568522543145c6527810ff10b0934923ad9c3d8d5fe5e319aa3146b04fe08cb45136f31febcf89c1065661206b100dd82b7a9295104c798689b3b96662debfa555be9eb8e90164d44412d9429fd3e5079425933e9d5e048785ea36de071a2c83db8db7a3d41dffd6bd9133b8774fe1d857d7ff285320004e6a4ee3743ce3e4d5c438f9a1200890cdfe00be8d570161634367a3011d865e028307cb446cbbef2e7fca79b291177d6d560701c8e4c3dac9b44ade77955d8ad22b5b02a09d72fc73c3a33847ef41c54730f34ed2682bc052dee798c610e9f71114e74e8fa822afc9dfeb203aab52f949603441cb179c3f6155616c3cfe4356d61883538d520a08b2ca9e72aafe1008fc5f116ca92f5e9500327446f07902fe7fb2e9d897738f2cb97275d4ce864ce6dc6a71bec9822f7dd9b25adc358bb1b2eb2ac79aa2e8d563511d25303a632b58c261da1515dfec56f489bc65cd2b336e045e3b76776e359289db812948ee8be515052edf32bdbd559608533b267b95498d94298ab38c7229360f877b5ee568607532c4cecce23a21c18fc449889dac611e9e13bc4e3a61fa731eecff9c128115a78bfd4c6c6aaa717c588baa68df8a619553d1350c09618a4fa8d79d587bce1a60b261a6e169aac61c0c4140e206875723062069ec45649df1b61afa260c16ec4449e66ab9c50767fca18a7aa17e38b788c47b1302a4263409a25f261d72346db66d0edf9eab94f245bf5ba74adceab62fddbf0a8bc0d4727b6db74da31212ee6103a87cd6042064af0d830eec4ece9ef364312c783572ca228aad242d2e594e2f33de8084b18cd0e338a14485d1cb451f359a235018ec69c018a7bc05cbec5621c86736e2127ca58d8001e5a7ceede0fabf2211e28773e80a0eecedfe233f389d1db0c1f4574aad31158821d2a2706bfa272b18174e391efb44b4fa15efafb5ff5d1edc92ec107d96bb457abaf32ec9e2f2cc547a20554af4844b0bb542e140ca76a25f7ff3eb2deab7ed8e1cb54c6fe629d29531458340db1091082d65fab369cb298ee9fa0ca8c411d933e2158590a4a1fb0e6e8c9ea6afb5697d726149a44f37832d7169cd2ac028fdd08b67cec76a29e12ccb0c54a040bbca51e9d0f18db8ceb60bc12a14f500614875c58bf0c59bebcd2107979cd15fdaad3b95e2bb1489f8c3f04653e9dc5fcdd2a6a4d274b1b654828b331f594e800946d134503556e617e79e8ff56e16712f6865f43ced49258c6baf1f45f50a1e55b98990c269015be42c8aa93cfaafb4db5ed030bff2c960c89f3fdff9366a2d6399b91b67faa54d66a187388be2413d2c75ba980fb72ca6b909ba340e77c353060d83c3a28dc77d973bf56c1b03dab953df49921dc5d73091b5350a5c53fd6093b6b80cdc7f78b28d8f20f3a01bd6f55ec2608f5cce663e315bd3136ac19c0417460d67313484cb193b3803d4b1ef3938e5789f63093b3fe3eff6d5f0f6dfca90db3a5638dc4a65a6f7c9fe517ad69e24a8221174127c3dd51467f2851ab79c6d09af25f5de433fa95700b35fcf437043bf68f86c8dd897c958150e3d97bc15fe8e20933ae2155ad932115a733251a8df7c4507c10556ea246b241f1b9e5f53d546156749be33d77e095e1951006bdd0c0d72c87eee8874509c3964547d9df5eb02534f45670f172e1db93b0de796003538650f6176e57eba3dd2538781a0ad3b7fa31be7e39eceb1fed4dfd6bdc4ef892688e132175755b887fe76ea61aa2bfb0e289cac0292ceb298d30cdd77f588e11e9206e6489590e554a7b94a0164ca5aa25cf7afa6f8cfc466d6c23af331307f14db042fd4c82fd9b5fb41e0a1fae6bcc1d4640a43a7842f6744d7ccee77e6abb237c2513781f6960f574e300659a863853aa45e72f2d330b6dd0ea27518a90ed32094d1e703e7b78c4ad06c3735ec52929f0853bfe0e7388c99b474f6f5e1c083188e4d25b8da0da4f41b6e956c51c96fecf65a294d723e25ca4019b9d5bdc32c6bda5839745c96b02a22dc8e1dddbd5b77cf0e9fc7f901984180dcd3d3c1ee139cb4d72ae70a6b46b37b4ae6994d52cfcca8067a4cf0691d316e5ab243a79ae93faa9a18af74118f07552ee2b6157be016042fa2551283aaa485a6a3b8bcbe52b1ca883714d9b8ae4e5b71036752880f432dfec170e8e45097d7fd2558bdb7d361fd0d3f214fc9faab00844c45cf4389717ac447afbd4fd88ec7c71e73373fb2bcec1e13cff57057774e740adb6eab2f1fd72825facd8f1935b7719d4b03105db564fb74c9a99bfee1094755a7b945c70df90413577e1b96907c55705eab6209923efdcf8c434f938e6f553d126c3d81972647464691ff6315e55c21097ec6543ea6a5e4472f11656fc664de3af6023b07946657638b1f0e27d23594c3fbf791c8d4c82c6f148f636ee87210d49c86d247e8d514784aa000c18151e73f653c3c6a2bb5278c151b2478b0627e6e6046400bb3465e8889a74176b48db4b8b7e6357221b5d635f23e85754a0a11784e81bb33b8278c480db1c943063565c97e26c7ab03a82d2dccb66772179c675d7777d5f99065c623f6fe86b784c098bec4af7abe9fab62079964960638b9dcd78756725918d15f2d4db8b1137e6d2fcaf004ecaf9239ed68a24e8a4cebe3a3f3bc930fca7d6170e79104452d6ca0dc9596ee86181712c5bdf4cdb003cde90adeb76d656e8fee39585a08a34deef301f098eaeeb14c3e3ee1047b38fa00a3b24120466071277b1b2557970ce421584c90ac43fffc33f33d35e9a47f430fa2b8afbc39b59ba28061dc6f3c6da9d7e8f253d2b445d8ae050d226787cef04877cc7f1518f74d8ada21c8580aa0d525a69a191c6e7b24cdced2149dad5e4d8a412244a435230f3b03ba96d63c846e0f4bd8e57e71c6237db90cc6aaabe3a780d1d2d9b46e6c0fbf1190d86aa4fa14797c8deb680e2382d6aa3847c753218563784e78210f01056a2549a6a4d6d3361942c36bf726575f01444edcaf8991f1017e12387aed0c3f04519f27a9e236ae95422b77f78c7c8c216e3fd833e1d506e2fe9b277c62534fa834173078198c4b2e331ae7f087fbb04e81ecbc3fe9e1f77d2c835a35ff3f4deba4ceaa6a5ffa95f51ea316add7ffd0d81973b2b23cc8f62392f2240cc628290bf85be72273876b0e3b7035c4e467ea2615e65181887da18e81fcab9bb7369008b39671bb605ba541efc03581260fd9c6062f51ff293425a663972521416e9adaf7a17a8e1074b16870c45fa9be3eb7b756b8c5c8d923c1acb506243d6ef10a19a7a6a27250e37afa0855cc56d2abc08a88d2da450dd5fd60bb96444963a6853ecb3aebe897d39e27768ddb2bdf0dded52a59dba95525bcff6519e7685429f39fcd043985a1894f07514092f0aeb0f58c70e9c906875632952294ea0583e82d8b45f3f703e0d66fb38a738d80878d926a02a77f8a8c538784fb74846b351159cbc6f285b112236802a2e30a0861213c8c401f33ea573d9008e6b2a131e1a6811baa73f296cb486dbfd9d10cc57079bc1ed678a708a40e70cd3e4a20fb08d380c9dd2a980bfbd578fb158e7fba18fc9148bdaa692915d7089cd3565455fd57b607678ebc1fba9aed791cd21fef23d4f07fd6c76c4f637db3b6c556e763ae640017831c24b3a7f434455e7256427eeeeecde0a4f81126e38eaf527536ecddcd7f7c5a9efb91c8fa04a6a290bbee6dd944181f9cfb77950ccac2c9989ec59390137e3a0845bf887a4217fe0e0540122dcd16486de7662d6bb6e733c598d05541b7ccdc1e5e4c118016dc17eac52bb94eda58afaae6a5151397edaf840d993da67ff8d72fbd36a264502e9b3bebb35e9447da55bfd5e6132d15b8405bb899521b68a41d674a2482b4e3aac39c58c41ad4ed6fe1895cd0811ef1deba24edb73fcca5af7bcd44a4dd7c9f4fe4feefdd1b199140b4ac9d5fbecd49335c687a0571d20bc858bb83f99ca0ef7f04382fae40fd574e65301b477c4e38250a183e58a68c61f3ade9cae33e5d0c09b6f771746398d69925fc0f5afb2ebba13572a4f7ea7358d145fd83bac477440f2a61b1d8abe9abcc85bb99764c10a77a944d5b0016e595b170eab0844202c552fa00530698a020c65a7b4fdddd6d5e5282633dddff70b5f7578cd35107312213b3e06f2e9c5fe99e7a0221160b03bbff0d8dfede5fa2e2f71de26ca434ee2740437a658a5789470b54d5fee17dd7060787a8d7d15107c2d4230add62995cd41394f8c013f2ca6f8dc54de28fab48b5acfb06fa32aa09119ef177f37c3ea260c7b4d88d9a01cefcd249c73a1e73bf78ce1dc6be907f8a4f925f5f79d495d94c0d6285ffdfb273ff69263a14f34e68444003e65ab4bc9570801cedf4a1a58fb080bb5e2c0c0e48c2c9625e8b2752e7f9c19da04098cd4219b3e4607767cfd76fa3d6da6017348a69dddedf99aa0beaeb17f89af1757db457685668cb56815d9d5c8adfc8f1b59db5191f4ee894ca907123bb01f3940058f7afa0a0927687445633aef3f7d513a09bd5e9808e7a578c7e9d2d82b4ac7ee626467214b0cadd10c0f6b6c52ef9099039285f8aca870c6700f9103f978e85501f0bc0e5725e17579834ea8421ee62bc3073516fce0f8d17338df0223940d1a2d189ef9a153dbeb6f26301bb65293b9c6c30f021c6df687283b5ffb9753af96af0bcd90823b31ca95ce6866291206f32bfac3812681c9c274889fd7eba12482bc0eecd4a29356f4fcecad012d959877a4822b660318f85f3e1d8eab91584630b349a00394c4a554d9e2abcae0a5f50751c86ac4e05342cf964ad03198ef686a1d8d684e6e3161c8b7cdcce95a77e20509bbc46b5bb893e73dded78e3497e3276bd0a18fc9434a5f0fda587825d4cd152d06a87a96de5f3a6577217a0f166ada2e24505f9893ede2575143f96af6ad5af8ef19b3fdda744e4b433fc10b66cf6fad0b7e42fb6660a7752d40edb1272fdbc6fcd5dca843b9b0057a16036f1f153f1a3ebc0f81f58df7b367a128de43ed6aa10d2ef37803cd3c232d8459966a064b086f4a220a20d1dc8beb6a4601e4116b227165a5d3e48439cabdde7ecc585d635bf3f8428c0c57722a09008a0d29b0982542a024152bedc561f24113e88da1f93daaed71fb461867dfdeb2df09508074957ccbcf8c0c7ad06a0d366cb2d27e3f1804b34e4278494cdaa8ac66efce621340980b1eb3d3ceb2212ebd5eb7ebd844d6bb84f5d64c911f22d3a66c3fb4c590fd9b682e8ba96392c52e3192f3000d16dfbfc8cd3d4ba23d85bba79916795450441903073b28f5246a52180c19a9b1b01dd2daac51d3fa75c800985928dc875f95bc162bc21277dbf01c28bbbac01d3a4aff646692499fb66b15413b02c49c72190de6ae5d3567bf3328a96797441ccb36965cf5fa11eca71ef128e23127db894c726fe4800e5f2e511d386aad2c568e046b07bdb5eed7c9a0214436803930109d6035ead494236e4007f307abdf9fbf7a3f5bedcee64bc0f6a0836253a3ae41da11818d2e0fe7b0f8a566aae918a82011d0f70f2c1900abb7ce76294b85f2f21bf6a9ab16455e0fd755b931a83fd4b3499b491d71d6549aebf3ae76314e829bedf726845afd65b867652331ca8c385b8ee6558b3029a292e2eec9c957062dd991c68182aa2300006ddda0cd19cd7dd4bd9968711fda917448772b6128e6f9e8d342ccb9ec5d1cbc69ada06094b97d9db310a1db9addb6c9d6e6daa030b8d1e95b574f420f8523a8715d53ba78eef4392e12b1f29769947ceaf60b9922978419f0e1299b763e7e3c8494e683bc6f653b837a0d87dd625ddcb00f507dcaaabd2aa08040f20ef32090d47734eee57df2c219476177b7daf0deca36a405167a022afbf90ca3ea6a8c3cbbac0b5bc4c7f5451f00227ab459e21927ebdd749eff6e0f98cec8814cf1e7b98270c0e1ddb647c6e01f77ee6809efb1067c9c642c395e4add628ebf2bcea33c563b0685402921a310989c9799086b881d95b79f4585797f0393bd16c9e79b6d42c41dd0b331340cb6e99dcf0896ed8b0244f1cb4d84c40bd746331e41e6bf","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
