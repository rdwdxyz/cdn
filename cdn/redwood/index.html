<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1be5a70c65f33566afb335c92d7a16fd3a63009028b5f8f4651a0a203dbd2ebb81ea3253245893cfa67b13e8efc1583996dd3b65328fa78ccd73721d14c2e803c605edd9c54b98cb4e8a16d7a2c23788a9f7e0991bc35778fe0fd0652492779898edcb3b95e2f036a6a699cfa5ffc9e1c60598e0f4262f17a1cbaf1610c8079032c125574dccaf0c97ed8d9d97123311e5998a5d04374ce0ecbb871020c6b8cc6218cd8731fb36ef7c3500641438fab5e4754229c67ec32d999b24a47f8d6a4eedaf543157c56a7450c03faf3d6027f254c03b1f4f06c0b1dc1236d8f06a07a23587c64c334c0154970225c20b9979a36ff3108b0818ae64b78a7fd5c73f1e232cac47efbd9f138f559be0bf73526309d86da78e77ec477425647967984690de25252cc23a68234fd0fdd5c6077fdf72849ff16c80173a717b6a2ca88d3023e713e284f1dcfabe3fe206268fe575ab99261d389b3ca3663264c5013050e7e6e2d8e064d800a9ee7f0b90c99899b45ec25f99477c016761b15fbe748948b3e628ce564aafe576035f99c2cb47d56eb8004fbc4023a2cf6f36c5cd3780257fa20ea1f67fa25a1b9a1a5c2708354e57ae7303bf6d64904ff544dbfec676c8cf37d73973955cb9668ac25cb65d0a4188982af7206a3bba7e9e38a6718337821f2dcaa1f384b543cce0bc659d9d44af24310d395027a0e63fa8ec0b818e85e48e785e43aafd0bd33c6822ce0727eccc280810714643686f8bbc5fc612afa567976033de7082d39d54b1ad00f1866970e3046cf6ba99c198d95a461b60d5c4c6d989e6edfb16c953371d0572496dd89ef64471fa1c7f3dce595fcb6003dd2bcbe8441dcfe7194203066cf179ff9e840f615a12a9c859a5baf02756f5124ce1259c597572cf1ae0c20abf6088fb99dbfdb8ff5d52b20f3c0a3bc77fa1b924a0f3adcd385b119b7436c2122b617a3fbccb6e295c1fabaa555a6237e94883ce7b757390b2278bae98ef985efa7fa3d0b1ff9d07bf91423118b27eab8a14fdd2d18103b67f030156446c7882318422a65bbd87dc1f04c84ab25736382353ac862d182835d8383c001fe64d0011b46246c6926904323bbfd57639eb3c40c0a7d3f8c98a5cf7b6d7a1a71ea8b22e65642fcc5bb557b383b66a05418987da418ab2c6bb79267d936f1deb2cf3f66e1d3448684ab43f7e4445b53ea3b8fa30df18b16cb0f810cbbd25df84bff580ccabfc4ddd736aa3ab24efe2d2a1e575a06e32e940ba17fe3b68d0db3b0ce934297cccd4a124d5ea99a299cba7450aae3cabc596ee22db93371561ba1385186580cd8f070e4f8654fe8ff0e5263b292c5d041c8e284b9cb2df17464dcd71ba78169e72196bbe6ae26b544edf3edc7b926bd1bd57c3ecd48a017b9848799c351e3a1419cbf175a45d34eb52660f6e3b1bf77f6f68b6efd5e5596465d5d21e739ac5d1f72c42737b7372ee8b67685d3a0b159c21eda3db3c1dce2a610c9cf51b6a1a86193a5dc1a9ef98734e249e3514293ae9ab0e79183c4ba1ce01186e5415b19dee79fac83ab551bb1d22233ae3b6a2367bf73f3ba4bde1cc334a19aa66178b1d46040d21eed47d70b13f97e9b4c70deccec3d2fd352a19d5b0fec1f41ac610a94185105134bc7beec26094352b2d67a9a0394db8b13b82b96b751dff687edf2d9a76cde769ecb496fc058c3901b7c7de5d6ca5df50a3ffc633b23ab2b9612fe78e7ee1ac61bee99d8c7e48689252f5c6c4b2d67335f086768133b8676b064fdf5025765e0bab5118531228893ef2cc3802e155caa6b6c14ce138809661ca313d03c07d88b555290ec0002a68952d7e4408d869fe3544010c25b0defde301c4140072a0defdac35af843d61321b58200012e5e175b99839ac9993394a17aaed8de3392ca03d712d85978b3d40e8f7eebe23b0e03f74c9ef546a661b3978cb05fa38148b66a9ce612673c1b092544f63eccf683fed01ab1171a17869228e178b3cc203fcabf0860388cfe0aa5d605aa7e6b4ff45851c0250780b4b7e89093e84f5dc4790f54e0abaae752eb2f9de95717f3552b4d466976cf57cd19918c48b609fb3107c32bcabaffbecebee60ab069251254e61b1bd5295ec26f60252d6c717014b14c60e9984f3ea182583fae1307daea12e3465fe30d21355569446c969099c83043d49f2743f21611f2109809989e5b9eac29d7d71c1ecbdf95bb7adf5b64b14e208dc3a945f580e5ac05504d153d653e007e46e2b07516fbad6134de38750afc67e763565527fb2ebaeca678363b0692aa4a420eeec7f5a6cf93366c76d75d0d4786301c7483b26d4b3832767eff7392aa3abccea6183ca81a75b048392fe65d38299042419c0448fcf970500668dc57df2fea12b4fc96881a146698a81061bc324450db41ddfd6d6a53e90b5af20be9f4e996e2057a304cdb6620aa3cac1be3a830ee778d832e283b6b733ab984e7c8a167afc2bedfbbe26b89d629192c2c8108f537500f32c84656d849d73dff28c10528c20e1d7d49c9c2da8586ce0e9f2f18c63781d6b0bdf9ed9530042d1a1acc548b6bb7503bb319b4ede484f44065601cd41d4610effbdd3fb34c2cf8d0f3a95c9d6a44fa953a432ff492f48e5f68ea8a18ed30deda688e6c881162d153bcce097f2d947fe322108f8be138e4adf31a73089e9bf91d219476a77e09692bbf7c19d135658e3c7150e5b5931b4a1a240bceef60068e9a2d8c81064ecfb092e1a24455cce5c502b09613e30b985fa5bf1959008750381083b9ef557121a128f5a900cbf5cc02a031b578f477702bbf64fb6cbb2c6607dd8326c593a695fbe76513bd20c26288c46322af650ae6cfc690015993bf2f9f845a548ffa2416e91feec33106079215d808cb37e88aad2e5dc0f3b09ba8c57ee9b818d19cb800f1dbf1593140bc09d50846a8e2f0a2d04f1507510cb80efe3ef4c611aee15317661454f4536f98542ea6553a5d2880794a21bedc3bb0441e7faae477a8444abe285e3d1f597f073615f22117269b05a612f36c8eb4a7533759009143a68d1bebf8babe7fada0de6bd660d07430dc8306676f899fe8851e990bd8fc6bc661c9f44daab20fb3cf4fa5de0088f9ca42756cd2dd9ce81eeee3251184928beb1ae87504cb9ff56858fefdd67c741d2da036863b859d426a1ca51f2f0a5659cfed3e0627331981a4ce5f871fb46800bf55ef5145cbe2f114a9e58d5faf2a589f0a30382f7c35fe47a850fb19346ea03c934f382c3d147041fcf2fd3c3d0bbd63d035d6f08a385f4efd1d824540a0433ceacb6b48654874977c71e4e7ad1ab56fcef5c7505ed8c6af354012cee910dec8416354be12353044e52078848b3d801acc7c25e9ee7a839e441bed2b5149f091707f695941062b5a9b7c39a701d0d4e6a686ffedf84181a7d68c5f7091e8ed52c67db4a839b22dd9a751a73035120657eb0e806d28e47be8fc0047b792db6bb76457ffe8bffa1c490eb2a4f9f23b69f08d27dea30fed817681a4ff4be2d22cbfc0e64bb376685e4fb658f5e486ffdaf22ff2a5a9063d08315b81b845a73bd7f973c1fa4a0d70bfd9533920ba3a8682e52eeb281a167f4a7c6449b7d8eae654c6f87482e2d880be7c84fadd2c27f2420716afa972ae31c5805adbfe7a515a4febc2a749a1faccda194d69b8c3b02a00b2d7931cb761d34bd25ef243f07372167414fcc8f27adafa2d4ad46f43472879379150ce5b982f00ae50eac35c0edbfd72bb9a05654a3eaca4de42a002900b4541843b0e0b7ae2c7c304aea241c86279e7abce9983d61ac41cfb7b28933b59870272643aac1eb3f4f7cad9692b47da9a940ee4e2c5905fd01122ec396a72ff0b0acf9dd8828d35f11899b446ebcc1c542c9e7022fd52f76d0e2bfa296013446580f7e25c4fbb60b0273d453a10d64f41e589bf69db216496617614a9f3fca11eea1ce18023a3333365e918de77c4bc589d0c6d915ed67330fc2936edda482a5fbb29264c395a1ab0bd7cf6dc15b744a345ae26fe6326d8839661adb8c15f2869b7cbac8123407776557f9d477c6a8895182131fb244f15ede6ff1228930b375580b3678f13c4e5f86a0276ada913ba20fdf8c91f666a7d9d54bc5bd3f439486e026e447fabb625b1f8b90c3a4ffb0305946cdea2d37daa35ad08e72d24c4cfcb419bbd5e12bdf9ffc804a8f45404a5eb5b295164dbdd2eaae69c9e135e7e7a790970fb13f05afb12c4c24d5020e485a717d2df06e62c1b6601189afd6e722a534660315cdd552690ef87f52467bcb95c6461e5720ebb7522c5a071ab0f6dab506fa7fc004dd554b51cd0c66127ed7ce162ccb92354a760d1e578b98866bfeacd35937603cc86f23a4c3e5ad28dd3fce29913159be6448a81fa4f408c45e966cc65ba3bcc402f0cbb7635edc6d116f54f9cbbcabeca5a2cd03360e71f36f4b2eae88a933bbb6789c9cc2ff4574ed220bf1cd8f7713d3541587b6f081c1d06f1e149b2d2b9b2daa74f3fff97978090cc4247916b750d5316d9ca993d7c332b25b49f4fc10268c5d1d96719af354594cc82a541f19acfc99f35d713634eb96f724fd5b4e4c827e124f8970d4f0dc35ca470dad0acf7e427fc09dd0df93c2b96f13dd90fdc93c5d2f5dd15c11b49dec6c946ac0e60d6fa23ada7c6882efa6f058736e4ff2d17e8dc5487b64faa03207ba5cf32b7a9681e0394eb2dc89a1489b0ed2de44603f6979276bf6ebc68879624fd86a0b55b6b5c32d00d78a0d2f0423d26945337a2b862a2b1f39086ee315a870a16b8d3d1c353f8c068f6a1c39f390916018e9cc62e5aa37efdc5fbecee3aed127a80cfa1451243739c9970155ed784466904ec5a5b9482e6723f6ed9b68b3f448353252441dcc5f90961265d75108e70fc384630654d6006e0d7cd55daa93791ffe33a3aa4d42d094cf5cf54065ca74e0b9b91b68b25e6441a75953abcce1e541abc22de4d589f8241e136adba7977872178cdc3d3652218e24d43df05ffa30db8aebc64f2d8e92524b20aa76c93415abe06720bd3b252c5b9e24991b7d2a5ceedfe36829c93bcf6cdc4a91a2dab16316c4df3a1fc61897794b8fb8527ce22657004709129adf707df2640397944362f1a2d7852b57c813ab86ee9de7cd9427c2d248120545b468a202ac1c6d98b4cae64f914ae6b01208bc0bd67f8822f0c875974cbf7cc787a04b79e3496bc9f02c3d11103318c664e456177762137cb0c63e152efa6d1cc2e5514470be8e9980fac2e193b4fc94fd3111c10157ca27d88e152e7c5c18f7c4814df7b41457ee2eb50f06135c9219f358c3345cc036f4ae35f4f849832765bcf788c07405464b720fa1e2432c01a141574c63e057b58e486928fb58cb044052e44db6e31cf7f95ffe0cdf834b7fa8515d9af4e70acb12ed70dd33fe252661d6378f26742c0994bc3059a74aaf284bc0d146df0234fa5323fbafe71d2bfa29c8b80668ecddb669ab2958d09dce1a1742af3c47d640ee4c53e9ee8ce5dcc770302c1fad7574df7ab07e8924737a2c269c640de113cd96f9694bf2064832a3b07465fbbb54d7c2c0d836f93d0717a068798c36e1e780c362841b3982f40f7b9bd7818f113fe9eb774aa75fd5a4455d4bed5ca60648271f1640c037bc037548b2ec7301f3c4486df96e9de40eb5cb6af074d8229f3d0e8c90e3fe3b8a146c87806225075995e3869b370148954901f7a7d42deccd3b6471fae80651d5790ca72fc78ef688be057a28510c0b1d2d861d221d3e6b370ea1f5cd709effcd495d6617c2108687db00ae16a3cd3e79e7d1ded6cad288ba81166c0b9152851520c9162ecf77fd06948101b1badb205c08791eeb321d8b7c9f35282f8fe3084e8727d903b64ce410d4613c9259d7ee296f177edb6579d03df56825afc639401bfa76c9238ba64c1956160f7dcfd78cd9e02936d2e9376d839dc9d4ae803d9fc17642015b98b9ac3053f6dfd6a76ba780a7aecc4642a433257cb9a711550833af91158ad9a7697a21ec670782c4bce2fcf08810aa19e3898b60c95b0bf0c2f103030356b8f32ee3ace2fb43a8d908b53a91db89a1c0707eeadb66356016a253d3e8f50921517dc4b3b3c5e906d4e7c3e73289d20096031cad45c90abf092874042ed3b1e87f4c00090873da7264f10bcac06dd1913f74acf18284fd166642070dba51cee047655eeb8d8e6386799a93d4eae1b0c3ba18c2cf02daf16fc4603c79fdedd8dafcdc1fc0be215040c5edb7167fd2d25a1b1974660eb0dd2c93c24cb2482833d5c0530801c9b218df3c8e3a8f55e2851748a1e36c6e14380e7c300f7d1be76bfc43d6693ea8b296164a862bd7f55d345864529f06b408a04902dccd2b78bf2a5b0dde3fc27faaf557fc5dfcf10962558ea5d144f1d3366ade6476756dcf6277dbed096fce344fa411a02b3366a6d1c93f863d4a159166734604c9e7622da6e4af6967ea3dc87391059837d4750ffb5bba51f52775f4ffc36fd05b6cc83947e9c23c5af984c1bbec15b1950f6014040e44a423dbeeb8949adbf2eed4ff26f1f7505eba4376f8d97fe881641bb2fdc6cae6ad8482466fc0d3ed351494eb86c0f5ee0cb0165e314ec6c9ea47d39a034ceabb351f3848c42926ae6c680480485d315f727c5304ec8741f42544e59189c1ff638d342107706aed2377ac6e8d8c61ef905a39951644fbdb87232155c1175f214403114cf8d60e927882aabdab05dc71e67e1f678eec244b42ca865d8f4b11df8e34a8b3fc04e59b10f272ef3dc8084c46417501b6f94971c99853e36795eaa47fadee1bf85dd87bc26d13944a5b01d77d52ec1b679321eb498bc74ad44dcc728155c07b891a8e7beb6ef282cae57ae9e6f5891a7f888f8b451659a7b90e803fcaf54e6982983010f7b194bab1d6c37386f9e5f9a36750c4ff7ff8b5d82fd4146ff83eafe51ec445ef9fa163e68cf7a6999b3274a10eacd1ddebcf295ac8d3f518c5a5f0f22a637880fd785bdd9f68e7a008d07f1b20d49c43f1f05d0506d7c5df739ccd41520d2399705ca37d791446d7b66ac91a0b4c8da0d6be0d1cfa771cf4332829de5ad9dca597fe848a4ff781607e3b44d413e8cd857ff0c8e49778cb135a524fde863ebd61605d1361e6097b5496a15cacb96310bee627ac9fb999b8978d89458797754674bcfa53e3f872129afc3760ef3ca41e8ea936d5a40298e7742d2bbb14cc7e8d15835eaf481b69a7d04c994073eba875e5a4312fd8fa586266525cf3b0eb2fb2f737e928882405a7e4c7b6af49e41723f68a775275a25cb366f193c3d17c6ecc518ff88e1c7213bef5f43edda13b14e6b4e2dac53f87ab84b8925c23f74b08185db50a4abcd5b98f2150559d0aa0a125d4636a3f3cde984f4fa7bd266cd93f6d88066ea4f493be8409edde4d04f37d559f649282e8129e79fb02c454f93674d3de443d88838a92baca453f48517ccc09a9ba617e0030469ac7e8f8e10c044f81cce57c6e0244f2ee827fe0c57002bbce2e2c3878511198d0f279394e2925780233f11a532696ad972a671448692e94bdb56f7fd5b0648d0295d11747b0d77c54a48b1c6b833d3fe0969147bf4133966b3980943db0f1c44fd708aa0b499cb6ebfd5c9827e1dd0fce919e06aac1ac14175f2ab915b17141a7fecc745fc94e19eb19ac0c6186323a78d55f01d03b9556f397d32abd694816990539e57958c67c2ec12d5f6373b83e79eb2594ffbe051a1b4dd45ba28f1481fbb00509dea060dd222f99e6ead26ec9be00d2c7a373e600290261dbf07625e3acf1be1a5974688e2b67e319d6c36454464c7f1e35b5871c19e2d805314d5be80a9d99c1e375f6a891608db82f24633a3a0bb2cfba5c1de56f6455a3833e7ae811049de4c4a695ac29b8bb2f1b39d229cf845e6feb22b742177aaad25fadd5f044200e46770af28dac71694b8e18dde5746914a019aab4f67cd8637c7269210c8961aaafafae44a30c58277454304dc08b940a43aad40223cfdd57b4e6599cabba6514a32a543cd5f2abdb06bf82f2d4efa8ff91ce46763335fe84bf2d9de91728e1f9f17edb53c5eebd7250a6bb82c26d35ae436fc2be43e1ef2749eb45030689e0b479a208327eaed95946c37fcf5e47f482d0dc9e658b3b5e70540268b0771adb2e24565cdfb690e13a3592670937554e6863a2a264b894a9b23e448998946dfadfe328e9c1557b5a02a5ca9a0631e228620096bd59f2127da7ad20d09019f84974e192f3b0c9f270f5e8c81cda2924054f8af3a88593d82e97b36b42aff98f2ccaed245f536259cd05ba0af4a64f5eaecb9a66f1e8ebf55e186205f0ae181027ed2838a1e62298395c446b62e85d707172ebb41a2d0dfb4420ac1757004a2ddcab8161e06ac3b9d1457835aa6769113948fc0a9af624b856a4a54c1dead4620d495a1b5ecfdd0dd88f136d444cf54f8cf831f68443cbd1f7848f15e4d9f5d9a0092dfe06a5d97b6c82d7c8967df76ce3881b443453e1cf7fefe0d3197e067510417223884b952db4d63f82d4fef5a1f794c24979a3c2b89647e73e818c1cdd829a307a06dac4b3e85ae95d19fd136ef189a1312d27a47c7b10a8f1792a4a00d31ab1d4353b08bf3dc91313cb422d932468bf4e359a06870b084069ed5c5e39394d85847c79a07f5ade12d2addc39af220f9edf3cfb675b29f07337236c3285de800e6f2e0bc1556ba38e491599db4447173ee68776605124ca690818f18efbe2543b3ae337ddd035020f6b2f0f8f69405c9d401fe7f8435d542957729f291094d9ad568fd43f1267e8a3b71e486e570c5d1a077ee162c6e08e315e9a756777f37835b2573bc0d842f9952b7db1e38da401b6f959af746b7e404cfee0f5e3b5ee5edf6b29411003bced81bad8f0d057921dd4ace2f512892c4ea592afc1f11fded76add880bcade9d550f29fe3c934f06abd0439a266f27ca6badb9b6b149e3a60ea38e2cf9e1fd7bc1c063e93c709111a7e33ce543d1a92cdc882cbe622e4fd4a670ed4b0b0c78e004146e416d96a0f9eb7ea4b9e456589b56bbe91f7fc2c2866b1f3b586ed8154c4175855aba0e61ff30e7d1d556e0e060848f74cab08005eb937d50eca7aaa398eb21efe02b357af1ea1e3c9a0834d2d428324e8281633dcf21b92318820ac9d9ccd05fdf52a2f27448cfebc8e286b12c82e11c6d322cf9445ef1e06d610388c59e99b68947ffe2879691063bbfd11093e14ac660448b16fc531c82dcef4e7cc034207aff2f8172d500003fd3fe6fec559256d5525728cd3b33883286c7d202790bbc4dd08853089fa0f37cb6e6a6af5f58ff837ddee2c572cd877998f4a0f770e6e9fa18312e4fba2ccbba2719df99063957955874197d01b18cf6019db131521e24581589204080e8b540d5de90afdb8457c33d2f0fe729e888b4db347c281b7c664411a073789675a0f79c29cb5256526979bb9748e21bb5ccdb6d85933ebdb59ea1bbb71ef0c83af6b9e86e32fdc920f0cfd8a89177efe1ad18f115768d3201d08527be51f963fd5bacb95b3e2cec6691a7a1809bf4b94558d9d1b990af96aaf188fd7c811bccb3a1e48a0bed7bcb07fcf5aba77ac960e92b759b00758828c2688d0741d29713c736eabcde518239d29300b91a861aa36ac6933cafacfcc8b4202a3c55cb0686c072ce4f9021971aae945f070d35f0d5e36c51974f2903b4b4210653bed1a8988b10a64c1ff6bd11feb86034ccd7777a2f6dcd6383512410614b9978ca1c4ef32fcd42a6e1314cdd25987186f8f9eaec7cb62f405c733a887923bb723626866b1700767904aee678756c3de4a65c9cc2b17883637f2d045dbf5a312d91a4bebdb3ed8927aca2e3ed8209b5d5456d7f0fb554a590b47423e07cc94b3fb8360c918fbed744c9abb4ebcdd775c927e1eca3e4ffadeb4c4bd37d09ec5e7aee386ffe0b99f7d1026f2a65ee217d57e2fa5d62ebf08e89bc4c5639915b287abf993da958f02475f404cf32300d547f10e0928039118ea82b580fb46c9f42ae7f641e2924419725ce8ca3377ae59d2868952e60a5f03ddc599f69badf08a62847b29c8c3796d9f35e8c6dda7d863d577d32c008461a58ae6056a23ba80cece794f5ec477156c1672947d9d76f297cf8deb0cd9c3b81d4922453d75e8c355c39c7868a99c88ca0bec851751a90375e5ac3f3efa4237747fb9c5a41942cccf3a1198fcf8459a39d43cafcc0cf36aa36cd7f2f2df02cbf4a1bd463eb8a17af4471855dab4257a66be08b8168a7f11ef949f2a4708bf047ec698c2e08da6e03cadf4df4040dc04d06c35eed2e4c41176f22b734555f225cd2554cf1a4434977f76a1d0b32dbbce6b46427edb28a6c5495b36312c42de74da813e0814db3d813cd634a9cd87016a7cc55024b3d66b65175c2cff43b351731fa2354445a0bbb32a4bd9c18faf16fb6331dab5ed08297ea13c31d04818e21a2368b3d629ed31fcc54b787826839ed8270bf94e539f37ae807eb3b528b38bbfa6df3086ffabf7b51db3a59aea0f687afc73bab74143878a0fbbbcfd42d577ddd189a38e78aefff4b4cc14fdcbb286388429994d0b9566d9d55248a1741d8a704b542378ebf7d9b946f4295029b48a2f083a97cfada685727df875570abb7b1f778b05adca492e38333feab871264847a8a7cdaba2fd6a31fda4978f4a6349d4d3d0c681b5855dfdbc63c75e53b12eab9e82500f74ab863c7b733018267e66d10804ce245352f886b491bcc5e0a149a1cb112e12fa7580b09ee1963868f9a1a73e48c817b6d70d6ecd33bd13d98cb1e20de6a2ddd9aa5dfc740ea23250a4e11ef0181be461dc5b2a97adcbf358407b349fc7bf37ab7b937885fb47145ac46eaa753cdf4a0d4d6c1ebf866153be19f98c1a3446b15edef82c421dff33006e4c904113c640424c0b48076a886a18d30d75bf75fb9eb016c8d76e4a1025abc899d01ea8332dffd2259f8f653a81085e1dc79a2cf939b2925535f67d2bd4556ec0e2f4ee6a5f41b2aec126ba2b6ceb0e6d2fe526d5f6d34a8a300c5a6ef0aa90800063ef7915ec50a77279edaf40d8a9e5bcb611f13a618f35ce68ba0ae14ddcadb6694e8c643d51e0f91ac7490c09a1adda3f53a9dee06d88e969a961168f1a11dfd9011da9659cedbda0e89fbced9ec714b28ffda961ad4ddfa62e3fb85828ea52ac96c1e5b27b7ad2dab046adf67c38f922b5e3462c171b29bba7af950e12b2e11ca1b1cf545ce9ba7f31910c9dc5c5768e9915d66af83e6318fd608dbeebb1c5373ea7dfb362cd5f38e3553956ada6ec9a6eb7ea9162b80f55cab8c38d4a0f57852b3775889173ee211d81bb2c85cbb8c91819b45235abce286c3d7f180008b07f79d9df1b7fb6a2198fb74df3ada213ce46d363d71f99e92830246bfd20700ca6119a5299f71303a19404d015fe36684c406ef330bbc5714832e9c0ef52d05fa0906ad1788541b89ed083e63a13a0a1b9b05c59263de546d0a06d5e2602fc0c748847bbc398dcc83af0605a901b03e9084facf7543b1f25c9b089f7315058b4bfb2baca7eba367cba8e37a7d30ffe314627a19a2766c56953c7adb6f25fd05287a6f7473202432de9548e0e0ff90bf4f34c39d1326e4a565cdfab781f6f1dd35842180ba84df86cb7b36aa91a33cfb1c5d1250ee7678c0fbd39b0d6370004e9249c197f1b5f52260e890f5d04ab3f3fdb81f5d83dc8305ed528359d47829b3cd86cba4d6f1b04662c60df9851ea92a1c44bfa7f6d1b010889bc10d31f711e52c0ab1a354712f9bca9be149c0f3cdb7bdbd86d30cec71b60633a30627aaea95d1249f1cee107779b48ce16ad94de1424dcc1054034677b5facf3c84134e210fa5aa3be69d3a85d472d3e80ef80fb8f64c74b359a1b48794fe7538485d35e22c0ccb46a83fbbf1a31705ac64e99f8837f527bc114545818d632afccde4c240746bf2fd79747e48e31d01de64126061a346cb84919b416ace71bc78a3bf5c1c1f00e41af17bdac3212bddae2e0baa6f550b6b403694f6dc4d1ed44b421c5e83d7e99d20563a67c0bf8bfbaa213038cbe2adaaf4730bf2860ef1eb0dcd27d719cbfa0f9468fb1ae8332fba76c56bfdaf86017af4442572a152088ec793a13b4c9e6e0b2ba7db4dc1aaf0d77c8d2b0a21210f70d586eb04ebb8fc9bf2ce41a855a307a32636af65981df7f4764436ecc5546cdfd15b0fda46d8e096424d9c9adbbbfed3afac00c865f5eecb6665c97835f0da7e0c33eea770eadd6b2f7114add4c7607bef48b9807431675ed0befb31e831e84450fcdc514b8e4c547fcd67e300b5de66622683e81a1dc32cf144114e3f1b0444e3081ca20ff285b1b52734b45f53bef52212b6aa8b87bc69767341a0ee2e15353fc62644150514bb9ba8d03d44816177d9e4a50a328c616a18f251900721d81b841fa878c5bbba97add4878ca153a2843f1f13d0e8f24d7b30413cf0475c2b979b61ce896ffdf36fb9db5a3a5aae9339331661b332f8bd1e21ba95e3d5b3f664e8ef7556bd9558526238805cee7cecf42d02898dc0c69f58562e66e05fd58a1587324676c8a03663cd1d50944b798deeaba16a745da58225a9438a5495ece2890ffc302cda6deaac07ccb57976e1ee2e4a83f9f76966559ea7152ffdb8fe48716a5831b39d46822d1455719ebdc010a7b566c01c2d9384bb466eb3482e36e16ea8348043cac58c65f974a821b480620c14d8b61be60a7ca2ed1201cf2423840b97d0534917b151cef647d5346a3ac2d130fd35076cdcb819be6b60bb9a18940a86717d5ac9791221534d978a88ec389600f2d9037e5ea68651672be1b02229860e927d84a686fed989208de798bdf24bb02bded8cb91e7fc6d1f5d092b5266816c7038fc302ed796ccdd088d129d147254c145035f4cd82b33a421e55f86f3b1cc742a6aa1f313333eaf4b24213c52cb0d3024332789f7c267fda960366c7a90a5ac70f16f538496263cc191b77fa66045c91632ddca66c2c2a833835533c5dad47613d3668cb62956ddc43864d5929ce4c2bcf83a4e702565996af141f5b20abb3b1f6029ab8e0a2210af25134c84e52dcfba5841616b54a58074b0b89341379318566df3ca1d75b74ab22d1db7234390bc26841807bf9f61efdbffedb277213498b8830ebc0c06cf70b3f8c1fe0530a27d0630a8ca872ce3fb5a953da8989181bdbf4018b543a9e6f4ca616968383bf1b0ff23f2ef4f4bc9ceeabcc804f7ea5f687d7180e11dd90506b446b504dece45a94929063456687f6e9b7f4b8a2dd4f3efc7c45cabb789b7b160d16957225a94180809d162b7aab04cea3df5f09f63f4b0ee17c30caa662738ac7642af3187c3badfd2d7fc0756c13accccfb636bb6aa844382f02479c0846646b8a145eed4371e3997c3ef749383824441493062920bd43f019fc7a45325a0872b6ca2508235faaad0e98f723d9dc8592e4e98492cead25bb8a7dfa941e2a2541ec6cb3a485e0b49b7700bb02c3fefa7f35641d96bed305061ee66d0762d3a1060510323f6b795a383971d4fc25253f8b655e98d3384b4434043fd78913e1aa34f84383129841f946fdfb7f8a7a21faaa44576711425793433afedf934bed723147dcecd83810ccf8ae14dc2e78674559e10f62a061976314e4503d4f49db93af2aa4701298cc97e393535bd0d95050ee47970e3e11e3dda90e3e32b455d95f60a6c07f0c3372cc630fd1ca18ecd1d71a71e43d2c5a73e1e298fbce6d58da3335c8bc8ffeb268c32ec08318dfb8d4770448ff76dae31b01fc1167fe86f0b1795de6eb09256d519758d59abe798527c29a7774066fd33a14b872704159e5e78eb825562891f34464dc1c12ed54b58eef625944477d62fd513523a88144e734d5ef2ba7d7986b48a68468d7710aeb7fe0f7501a4470f36b81b6720d5d9aa6b90c146943a72d3746ee562826ace3146c2a22bd90035a0d2ce9ba1c5d03da45ac5952f341512a65ac87fdd34f2f5548a3db40b7540e68b412ea744e333edc80a547549d8441c70c0a966366ef5f095008cfd9c1592081fd6bb7f43f9696f4ae0c83fb57690fc8142bdb0ee14442b3b5cb98a8579589437a21f3b33863c88d63953561d335469420bf60fd9bc63d155a6aa0934cec197570b03bd46e2c4eb8dda5d9c32d38f0d255a3601f8ee7ce5cd307e2c323ec60b2e53b4785d8b6b40678222689665b2ab10e828151ff2299032a41b5efd0562c7e5f080ec046941fb64cd7a38ca64df726853252dd754f7c975b6b9920f21f90ed20edfe98f626f371168b104348b80c4e6b1c2b9371bfa1c142db42f41823fce0c995bde5790a8001100dc4e7d7de7f06d9879f440e58e20638d76323d002c9b0023e338e1670a075fa736fc8a3c62c81aa78f1ed2f39d206629248728b1c0c7bfbb129b35b7f0ff4bf5792f0027ad3b973b8ea8000551e062bdc259999a4f077758152e56715328732fa147e01a269ec872fd12873f80fa0bc027d6f621de953f580014a514821c002ecf784c1da64e6a76d698fc998f4ee017f90fd6e727fcb35f49bdce8dcba863e03e112772f63415e0e49b635fd278c1a1275691a0099a1969a6d162fb74436cdae399438d4ba57ae4de264fd2211ddb513972c10fa9467336f25e362c0e02badeb8ef082f741b13e7774517436c7e545f9fde14ee5157f671dfcf521be2d649ec01a22c51ab54f7db02ce4a6c2f62b70f5933c10aeecec2f0e3707df89ead311fc0e790560b4b9a15428639e2c653d70b8951325c9da52eea2b7a1cae25d36c867c2b94868930d01aa385432597ae4cc410e6dd079dd12b60b3ca0ef90e1f5cb62bb336eac13306c14b2b3495d7c4fa087a5de9e6993c778e4daac00de7dbbf1b664e6ab407e7b83b11f7657b9f5ec7b2b436319cbf9f70d2292998a3c246f9995cf40b64f517599c0d41b1e60607c099c9c3936cd7f3ff011c75f2c331640ac30884c6cde7e84dd573bf04d7c6d93b7c409f32a7211cf8b22655f19b7c9dc61b7b0f8b1977e864281fe9e982ebbe5e611b6ead5970223c1f32775e004a63843301d2755925cbec9ab5b0050730c89afe5deeb95ea5151df2f8d5ac00c38a9c9d7b86c60cd44ee2be205f60b62aecfb6a8076688334eb1b5332af64af6d7e7f636efb8335e17a7e5c39e029ea211e9194796475b121a7321d5f4b08113b8653503075188d551b5050047dac1b8ebf1b55dd12651c140a3db3a227c058c758d906cf52f01b63faefa339c692e1463d8497d4a2e5ae8e22c84afa1a0f9463e048cf181fd6207b4be2ab34d9b6baf4ba44b1cecce88aae459b8fa9aba63c2f641ca1adb572d793d1cbea350bc5b189223fb86836d79851c810d6631f034c0bad462d950788234fcee148e3c58da73b3d0635666f22bd2ce118310c634f98a11e5279a9fec21bb25686694c00044b807f84488df4ccc465cab689fad4b878c3a14e8a1b82d2e26783233ccd622306dd3af6c094d27ec0760881d260482dbff4c18fa074d5c9bdcc6553acbc3278ce178a71cb19b914f3463a9971b68d03be0518cd51956c2c53234ff61acecbfed19ddd54cea1578445aee790def454dc380fcb71c85a19e62f3772155c8bead212ddb673fc77b1be51bc71629cad61b355e011af19530dd2f1cab8251d0b856f920316b1b5aaa9b45a19a9f8b4cd379fd477238e528e688734b197cfe4f4aa6f83127756095121a3db432c6d029ec96cfa1136d7ce9698fac99d8e1ff30cb3918f95ef90727c3c5a95172ba8d9c808ddd2e6c2f810127d04a0cde6e91c7d756c77369673dedf401245b88909de8f2dcd0bc4521581454a04d90a17d29ed6758373ae7544ac903d795dc905713788f5570e41b16c8ee80737263072afde67dfd432421f87571fd716f97fca43b9911bc7c60f7748e9b3af63039636deccf4ebfdaf67876dc4cda1e01567846250554d904818c5ba01e5473cdf4baee43ba5b7cf2a6773439f1d19f939f603af1f602ea64b3776c3c6f8acfa131eb2dff091f6c87c53b2edaf36dc6526671e90542054ba7308572b85cdde95cf88c64a939201a7d442364ec5a804f739ed9fdd1a25808d8a6ffd1700f235e75bd943d4f90b56e4e14850c3fcfcc4d4cb1541032c339f2e125bfc9c424a9ac275c9b186d63f1cf80777dabff368a3163c1a66d5840e4a5f81013a4dd8a1b28fd179656fd19256def6246d75df860f1da43840fb710791b525c39a14d16d25f66d722737ea9995cf62f173323f1c1b2708cae2dd6fb40d6dd0a11c8e9b816a959abae465e629374f71fc37de605b81a36523b53c7f754872e4a8dfb6395322b16d379f7045bae3e09d49ef266a9d16ad8f868334cd5e9212e6eb3c83951b44e76894249df52064133483acf7fbee5028b15216a122047cbd3d2bfe704914704a022c62a4b8634e69fc18758b21b50236d9097472ebf694fc78ad3967072dea17d3b2e492acf5849aca1bd7208a7242e5c021786a81f3a95cbc7938e059ed0e5e5587d4d1073b104a077d3b9a369f36eafd2253320173bd4265dbc399e8b4ff368626263ab28d2e43d2d7660bb53cc3866637fab345c0a628e259a73322a4f4364fe33cac032514d3b2005f3de9223ce5625bfecf0b9c276a3bff516f7596e3db04ccd9e331000c75f41cc59ac2ecdda718eefe0c31b2f9506f89080d1fce7b194f3ff977e6e77e439a79c29b11f150e5acecacd2a392343c404244a4a2bc99ccdaa12a316e664dfd250459419629eac24b0effc5230276d8e28666aecf06d26dd9d1c08bfaaf41dbb8b8c3fe830f2667c875e821ed38f28572a9d1aac18f25eb4c660cda66b6654796aef7dffc5662e91bd5baca1a90970633f594cbd6e4563eb3635dadca17dfa30824ffd13852788693e2224a29804d6bf2eaae045dd181537112e674c47073f616af0052945469a2e88baf42877d361f2264758de6bde4929c44cd8f1810df931adecdc3b3448e14cb00dc6d9a71898ccc3d8c8ca157cbae5f8f23e87eb1e94a685fcd49aacaeaef7d57be6c785423dbdc9982e570e660186239fe449bf52623f3c9948af18d7f6088a9926dd90e26c6eed620ed8cd7b586c3704e34cdfc3b92b3591bc963574666d30f07e20bfa8b39597d5ce2036f333ef4795725e1f947725bfee9de27c98a10fbf624a630e4d33040f0a2b0ab1c816b9a798c328c4d4d2e10edb85ab4c55857822140d8030845a022fa689f6d4dfcef37587b64a598a18154348e422d35d8a54f55d3227b8e221c170b47f7fdfe7041705830e56edd3d27a5cf90e2aafe88617ffb2d6fb548ad2cc619e60224b2fedd80488c780662a4ec9354e1590b22df33b54b19ab59b01da5bb0f3df4136d9b1c6ce3c663cda9206ee8774d80dad6bdaabb0e93ca212d0f51ed6a64399b0699cba8606ccead7b8d3866ccf3c7b539631b78c64a6dd5ebef8082dfe5b40bc1449fef9e435975dd1796d7090b02ecd4bb75a0b0a421509ad002c242a1c57d65cb4262b0ecba3831b6b6dff2ea83367d3c90fa04ab7d6223fe1e40786571fc7f918d807ed8e53e60c16100c66a1a4f3417539d5b546b670e649d92c1c7c6deffc5e7778ce5133c1cc4028e2c041af0c74ee054e68195b4b044f24e1b430890eb31fcf66565d5b75548e6dc046118ed87e7d2fa700c7fd6d85820125c220ba213641ca0788e08c464ba32b40529866701fb303f8b68b309a5cd22a21387533402904abeb202000fb25a784a91edc19a09e4e81e16f6bfdccaa51eeee10385b2343710fbb548dcda6ba582a1235924b5ef68bc83af99397e1dfb8ce94204e65ead3e9d4f2110beaecf6918aa0c02de64fe6aedf602633eb051a5d69c5a00fdda97c43f9fb5687bd74534464f459d1507c341dc484023b31d7fe7390a07374ff6632e991003363ad2db8c5671a0c115023636c408d5e4de89815ba4bc4440e5bf078b7dd501d26d77a83e8ae6031f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
