<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"80e7757bb52751431ea1083fe77249855df7539a7ed1b0195065b1687a8141984170bc5076e8faad4b9a24ebaea5648c0f00496148225ecc0de074536e48a7f571fb1cf488e3c860e477e8e20dd92abc54461db83f9b0a35f325a1350b04706eb0a2344462e19821aab23218f0fcc750bfd12719d523f61578398b1fb22af7d6ccd6137baa5f6f4de680628d7fc255080b55c0b51de249a313a452fedcf6b41be3a62e5fe6aafb391ba177537f75a868193bf8f14ad7b38b93fea97862463860b168f95d6a584ae7ef02bcde92611d62e65cac49d166323b9fa580ee2d57d4864940c2d2889e53341aad5cba933b876f2ccf24080227333cdf1ffaf39975c73325ce87e45ef32a39f160e37afb50f122baf3bd3152ecf78e268c4e3359e9adca574f6b556f6d093756a79ebaa5aa8ed0ced01b3a36eddff8055c8810d9c7ec15f1eb3d665c26d42491094e8ceb3efce5e8e0a880636706fccb0769540ee73ae7e18ad4155fc1a4bfa71114d229a054fee02e592b793b7face1f506068faf5e00d2311eec1e7096a1fdeead0cb734371f43eb111a303f17fc1a244aed376dba167b9883db74d6e9394cb3451a63381ffc03f8f7e8374ff0c6550dce1ae0398c988395d0015d353719f767b6000d3b0478097a436d2921357c2802ef3d3d9d5f02008bd89243a89b8d04aab957ee6706e051aa9d2aea75f6eddf4dc7bab46f6e0fe3a6e19463649481a876ddcc3a9fc5882c4a8b348660325366ae8f1fe8027d9ae0a25874f846d9c0dc358fc323323faa86a53a8909f505b71243fc24e82efc55d5ae00d5b4beede1fbf72872bac07b16f392534aa5bf133c16224e506e06d4b9a3ea7c950e9620ad8ecc877cfb274ef96b5f0baea7eb85e1c295f03ad0635dc68ce2af21252c7bebd29d35416aac23d5e9f44a4de59e2a48e20b060f5c5d5677f90f2b9a0371d65fdfdabab5ea5b37756c0ffd0f4849b72ad7a2e580313e374e72cd455ea1b4c8d741e3210a4fd5f808744e35e72c4fa1b4e79a3b6203f36902f48d6548b154160ce1d52375fea607111c36fdb9c44341e2a2393a2227964a68fd6d7eef6f136f163c8a1f18dc7e09d361280270809c7ed280329012c49aa884249284cf695f4f86f93cda5cc41aeb3592a39b20b1db72d09396546e9ef46ef0f9819f7d72d2876f8c61f78da2490f063bfb919ac80db311169ad4c7bd038832fe09b7920ccf44382e3dab4816828c4b56d746fbb5b12491b216112ea6f1c074957dfc312daa406398c8f00c9469767ffe8a13bfa09e733ec41e8ef9bd1ed7b1844d020c8845eb6d13c8980bb4e50033a2a305c481520c92848e15ae524cef718b886040c0ab3f8893e3c0485203a5740c44e8763afabd7b5d0190f93f914c36efbe9d60ca8546678492985884268965e0f44ad1990cb7d9fd3491f74a67e04520c7bc17c8abe650c9f8da4203b712d3e8c154ac083c384721a2bcd4489f24e1473739f71d4db36800e2a97458d9669ae0c55d5d1bba3ef0499fbd13a9dfe637fbb4437b932bb6337305d0ae7ce0d6de952fa500185dfd1625ed21f79d1a6ea72e6945449f89b78f3239f4c2c38ad570d3b164c1839d94b7db71ca88e529afb1f2f852336aac7e7401d965ae06cea72548ecca0af205080456b6a3723b9c09faaf29620514716030617f58535d10392060fa402f336f268c76aa90819a0042b625343104d8a2bc546e50dfb081296c52424f0a219d27e1e21779c820e2e4e91db6069f693078325d1f4d24b5f1951322849de2a9dad6c6422b87c8a29efea763d59f69b7be28db8edf175ade67bbcbbe6c05243e5fe605abaa8c173f5a0e34f4db7c1d1b4d0ff9a9f20c01a793744d976df7f4383174c67c65cd3bff66e968516116335b965a47d3cfe238963c832dd04269d7c9a73efb51ea98dda0f73024235fb107048f69bfa3c55fcc085e6e2373a4e1230d9fa8b8edd8b7f0764478e31adcf1ac5e85fa6820dae86abce81c63a1b60c8f5ae6f5367fad17569ae4914a048e8740e575bfa9abfe6fd3e7559dc24a18234f3a4ccbbb78760be7b931bd818b34e91e4949af142492c9c64e59d8e3a88582b32ffd12507943a637d6293c74294dd57ea8440c05ffe237437676d7f5f9262d71a24b1e03b3d5ae3395be90cf85e61ca392b719f22e703f7122096b6ba9c2f4bf3e93c0aed43f9c399039267b568e5b0f4eaeeee04a7f6e06db181328eb1a9d534c5a708b9265069594e8183484a68d9d4cca7f702ee79027e83f051c5c0c5aec67eb3b066fc6c1980e4f99627de5a66cec065f2a9ed90e30b997a00dcb4029a1b51ab3d5f6a940af37a4f838787840f112c87b50b7bbaa655952673e8ec8fe5691888a9a421cd1f43f55ebe9f3c1c4be534e55e93d00b3e28c6e1f0cbb76b02e2a920c77028091b641596f9f7b344c6bdb4308cd0d2c3758b600a5fe9b129fc4e72239cbee217df7fb2b1b2c39f24bd9d3dd53ec5e76953ae73427e18baaba34079221d1942d79eae1efc028276d92b38d1dd184e63c4b60cf7b582dad91ce22251065fd4f91dec89de67acd37f2c773cdcd4ef6c5947d8184cb6089f221882e2f14c3de81a9014cb5cfb8ae53752c9db64df5446ff6a53c8e8fd397b8953c2310035ec303e13f05152f417dd5ad0c899ee612094fd585f31a0224732b79354e83d68a02d114cd1b4d893a2032b5cbc0a1d62c6d0787a6343daba62b089725bac2c99179d75d32d51aa52e7bc268688f579f87b75efcf37501744093db7a1cdff4190a25d02d664c014ea4a9f73a0e6bb3e90d47fb7093b2a6a0bce34ec9270dc4ac55b1cce019119a00381894e804fe0dc45e8664c6207fff4b2adf2c2096150c69f723885e82f6d7b4aafb8a80aa9c16320da63e0d3313044fee4c93a3a9d0cc8eae784fd6a863fceb7acf8186732258c371209255bc4d9536cd719d951bc042df1bdb0855fdd2bb4f6dcac0bd407d1b56198524d6d3960a08d8ae3ab02d65d9d981f14fe22622d070cc3bb9a2546f9d7c4ef22be765c8b1622808255c5a2d74e00433467f2c21b9f9f1be4a0ca2a27e33e9e5442af0756ec02c4619cf28a75f388a80e4470822f4679aa32b6766baea33383345c3cfab4834337f5547661fe69adfc5d5371d593907a72cb48c3dccc5736155cf73f06fbb26f4085b2c4a5db5951ab3e25f60ce7517d221435ec18bea8972843227d6c8988af64b8e2d5ce4534e2e3583d7d061c65ac8339e5f64d00acdc5865bb3bc8b23106c4bb50e42b5fb2c09b714243e2b1777d09642044d583089b3b69b0ad485e3a2723a4662a0220da9183b3491cb0b7d3bc02705424929ee06bb2c374f1ac54bc585e1100ff4e7241fc2d02173f4e75c3b84a467ed2e4994eaf948b7470ad7bcbdd345f1fb5568f2722ea53ac19b3f4c065da5b3038d109c2e9918f2ba8a67db6293aca5a1b7fecdf3545e58a88160711778c6d47439ec15f0097aff48a224192ee0810f28108e9adeb6d05aba9085f4e5a09ee113a618bf4146b4e2e19997820184d3ac1b590a500849ff0f92a6987d6ce59d0c90373967d445de5bd6b8f51c1ec1b50097b1ed312c287b9d6be24235f184f81092136ed79588088c8c07ada258544f808439cce2508f5eb6ef7176530b5694ac89e98d629447cb516a96881dc2e8aa34e1d37a0f6ef1ca10568260a8a0ae2eebf816194c248d1d4695f57feba68e2b5b685c47f73c1c2e029438d54e31ffc460496834b120f5270496b1b36bbd99c2ef52b7bc5f0a9162cc6ec91dff605d8191c18e2d349e46ab4f4edd0c46e59469b3b7e332b05e68dbf11c551f73cab48e3d5e9383d86a03254678f869646bc2b733fd756bb5181d40955b469ac352b35e616b025cb13b81eca0d7af1089e2b5bb7be97110b2fcadca5df883757c1e024163ded84e0b68137f800925ebfba8a16196f28f3f4cb2114bdee535a49a1ab12a653194ee838dd855f13533afd8309215c25a4bb56f0e758ca9ad1abfb7dce9faf23ddd95106c91ca1c899a10930ecdd7974be8ede0e4d77ce92ee5a0276b937f5fd64a41c7929ebb486dc52e5f2ef978d1674693293a94a4e532906eed0d3343424e539c84151d6a01727833f9eae46a8b424d155c7ca3326b61513054c98bb6f32973cdfbe620faf8ece96fb71b2467c576d467dde884e7f2090b53a8e7154706c310d27503dfb6732993f08c0e15f77cd124bd4237596d34813f20ac1d7f79b33efb19c2708a39a5669a54346279f90e9098b6ed7fb7b6751651ef8c0cb2b105a5958ac71666dece5fed737b7a09c3d2c43cba7ba5def71ea9def3d7a7f0828be75c1b15259c491a8921d5facd8e78fbed705169e338666961f5c02288fc8be6d30cfd673847577498009b591b840052ea572a827644b7f8e756ba412c2a11e2eae3097ec84b27d8f1b2196b8d228c386000158bb0599b7c882bfb2f32bcc2b60414a08c3a3c263a90947521ac0376bcb5ca43b90b5bea21db644d871967e7d9ab15063f810165373fdb8a39886277ff5f6f0cad9672f19627df0e42ccb450ff27b30c69a7e49f32acb368a394244a51d22f62293037fc9d4b3cb69c090c1d4ebe82b042c1454b3bf8d85007e1395762eb7abeb7ea2b0b7eb26dfac1bd88f5d54c4d9e5774e3a899ee2c4fcff2872a3771322859aeb91fcd121456a27f248149cf54eecb25942a921b3c1c99462a3af8c2ab760b0838029910bc1970970cac49ab3e848d661e8767508f94cf390f4a5a36655f80e8e8c4161db5685fb65779295be2f69d8d3143de3206fd8fd43a14ac18691a4ac97325233864abd015a9b7645ca9bd9f10e82d4631cfb7c07a8675594fa333ae9605ed5be87acab512408635ad4805b46dc03f19e4f6c3b3f2beff236bc4149a4f28c0af27c940b2a92e841969a58d03122c51a83b8325a4fa23dd9697d1d36103897195e5bd05d81f7625dd1ec22fcc5d9838d2b14e33e7eccc142ed0e71f6f43cfd68d38fc53989230b5fd0806c04b5594cace51c281fbe0058e1f98c9a858be459ca06f283843a9192cc0d8a948390e56aa2e2cf74a3b674bdf3ef6e00e1e0de28dca73c87599a6c1c6d79dd74923b15cc934128ccb72ef97729792763fd8c210f4fe641d2c6674a16b89f9a88543efbcfd993f9a03b95999165e5893f0bf9f3bc6586bd49b16a4190dbf12188f625304abadd18b7bc27d302243663e002ae776e8748c22dae2ace545ec7a78c2ae0de64c4d99fa5e9cf165b39f9ca6940a367f7f08722f95c73b9abafb1a1a367c0d225004daf6fe6f1f23be63a4660d10cd3a277132c8c4dfbf17e817bf35d2a1ee726c8bf523c35e647f7b836907d3bdc84c8c64109c3e1337e9fef70dddc168f2b93b632215346694f78f1b797d667caa649d012d8af898a03ba8a05ca5335aa2443ebb7585977c3ccdf74afc19331981711cba22d39773c700845cf909a8fc0e8ee5276e265d6bf528ccfb97e87038e36d4e31b737607ff6ba91025588ba1ec670ff480ac813a75fc34db47ba1e31bd2159dad24f2b9b7e4ffb95a8444761917bb09bd3bdbacbbe5403abafaaa39d65d999faee5e3820120335cbb77b76d90507ea899889f8d4e327af6e9a24604c0e1695813c418e73221744ea15e6ea4f6bca2609f64ad669af77cfd75cb8b4bce966c7193d83245c6b57c4431aacb181dd3ad55c11912afc001bc4751b690eb4247fc851fd267e48a57471198766ec5c821d8de458ae464afbbd3b910f4b36ea8f3bed4b6a025087bf3a44419c3c26016ed031f78a6fa74117fa58571da16195dec6e8b52d6a347a0ace65fb0c149b620661f30154f70a5b93aef692573becf4a4a2e422ecd84edff4d1a5bd5afee63bd2a2438ca5bfc9f5098177a6eb2091dcc476f0d1a925abf19d37208927b05539b4f6fd898cf1ce8dbcf8cf942afcacb4412481b4d117b72c479f747954f9f2c58a4538e8aa707fb651e953caae34c0247f7e1a9194c4b8a5294bff9c49cf837e731225428f3e22dbb4e0de96e710230e6ab127a60e2ab8aee6e7244f821e6468b54346a0d891d822b5e2910741aa52e734e274653d3aa46542112764c818dbef2c567edcc60738639287303ae7d1ce0bbc0dcd094bac7098c8e1ba76aa73d624cf6ad38cb8847ce621187cb86e37d435ea88acb7a7f44e4fdfe43e3038ae64b513b7dd71c78b830a2fdddc33219ddfa2327afc688e15522451dfb885295c0c23828f5f0bff4234a7d82e37b953fcd9ebb9bf3ddf8f8f970d5bb1a01bdf8044d6931dd80765311f2fe8ff95780ca134277fdffde67b21811a4c857850c208927fc25396534b7fb484aa8bced94b58c2ed10820f39fdd0cffd91600120428f763b7f038b745719e7ac02d778f6bda1e20c88cafc2a98237841353fb0caca07fc773be7baa1fbf53b32dc3a70c79299be9f71a8bba2549d209d109c9f45c5f3156b8d44ff0eaee0353f15dbc4757c73dc5efccde6c4c5e2c95aaa2eccece331212d08b3be6223e406c93c98522969f6b72dddb98e650aaa7ccb184bb5ccbcf126da7471da1ba18938f774ec5334529d26aa777fbe615525b25e8525de4f601808d18afce964473d7ca98cc9f396a820e2702efbfcae3db4398301ab8c2338890bf6f42694b9d8e6d695bf8630c58ac69a8c1299c076f392858add7eb9f9cd730d90c61fd5c3eb95d33f91c4422859d3b4b5d7e06050e4210ca678da95dcb44798ac4b2794e2e456f5d3e9e140931de66caca6b2aafd509ede5b0dd194efec90e99c30b9badbc90ec518fda9ec72f92f8663727ab8353f3443d9ae9323bf497e456899c047b7e950c852b3bd7a97628e9a0ea5c7dfb0f64763f1dfbdb2bd9cd3e456cb109684c5d3d5d790325d8d7c3ab38879ce87c56db07515a885c955b4068067a6a78074f1c71ea9fee76d4609fbf7b4f0b157ff2e59d848297e042446fd14c324cafea2f9386b191e2937155bd2f6be9d6e8abdc16dfcdb27c4aa37c136aa8863558b0a69dd695284aaf4a15eafce7a357c07cdff66583bd8a4400f659b5bb722c008b3fa2c7bdab42c096c0f30761d456ac33d09ebc1715809750835609b400e5136b50dc6d35f395dec315bb026a64c64ce896f41bce50393bdbd95918f9c2ad501e23ca02cc7653517716981309cdc827bd7496ade137386befddf619a884a30a18c5e3a7ee48aad57f808c98e73576f206002099b58767827b2985c658421e637a7815032268c88d6e319b40e0adb337dd701adacdbebcf684ddeea4d0425bf9591dd09c7fdd55541ca206763fa10cb4fb2f323347995ba8fa2f28dc44a3c51df5fc6ccd8fe177fa604f33d3d8288890a619879cd1d024ce0a627e821ed8318cdf1e32b549f31e84b3362cf56ab570dff99a8c1eb2d3b435494317f8f013657330f700a8d258e94140002fdeafc2650d7bd7b3e79c1e54fe1d8944edc47131567172e469fbae455a31fc9a300faed4e1786001bfdef9469f781f2c922bbb95758d0cd2bb93965af7c5b69564f171047575e86ef1ac3c7bd0a12bf1be4887638df6f4ecc42c2345287acc9df407a09327cf9f2ad8fedb5217cba8ae2973bd9ed970b5ec60deee76ab2c4dee6ba4da4fd0074a555363ec0be75559b344a7bf92ff4cb3b5d68aea5d70e2eea2ec0880f3afa25bff47313bbe925336e0d4d7efe71758bda3ba9cc1eb42f9d75a535e1cd67a93c1c8351171e6a6148862cdad4fe7905e0bc9fe9929e2326716c1c1e8c3d03b4ed4481ddb5c90fb40cf9b730659fcebcbfd790e9c19530f22f01a591a549839439c71c98d28aeb31ce856fdaeaeb982135c67e9797b9f0d93eb54bc723b671675fecf8fd02812e1f4f70bf5055e3789c0509b418aefa40ea15013bb8bbb05bf0b391048686f6b3fbf65c5275c6b790f5ffab701f623a527e946a4b984b97eab8de81117bb466ae454fd75e1fe2ab32c41670a19d217e402bd16d849db23220c96afbddc02ff66a810489b6759e78722b5a210c2785ab64bcb17548ad21d322b88de11d1741ae3db5cce524f8d8112b52f2cc09a209cd10b8568aab089f656ef6f813e252995f41739c2666d087789f0cac258fecbbc4f0211336814291b8e6fe2985e506816a3876f024b4e16803d8f5a4f1238ab963c77fc16557aec180affcbb31a040974a4e120abecd2c87f1b7a3ca34d848ea1db0c02d4538fbacf37b77b6cff5511096a77a5087d132889075c854bf44cd6120d29d77b0185f6cd5c3e91fd6a09f4af059374aedefa5c0701396dcc52fd0333cf0aff7642e727ba9f9976c18a4d4a4e5a61a661e4fc37bea42a259b0b4ac743ad61172191c1a420e5f37bb6e18df28e13845e970532b0ca92acad9c5e2731ca54e98bb601da452c622a7f2a4508121f8b595b938bfa5a3c69e3bba5c294db05c6dbd7c361f54734e9e64b61c90c7f911654002d05a437356204b2dc526f1b2f3cda71b6500d73772a2dc28dd6c3e0f7fbf352915c422eb8e27c4f413b7c3a9566d8894d510c1a81739be8e501885bf38d4d116a3be8f66261f067926e4f3469414e29aaa88b88299c57fe29e27dae7780501823d33ee3d8df52c5d9d8d231fe3fb3f278dc5cfe83d200a6eec9195d2cd3cfcfa17e809e9d852cca25f169c0b67be01e91a41ea1f384ab28826249e0faa6e21d5a0c66fe4fa28be50d7a274e3e20eba3b5b2524f2c3616a1bfd4801f8f3473bfb138837d48303452397742079292062fdc12787191fdab83a47ddff1e36354e0415b75235afb192ef76fb040397a9f5f13380068ab87a110a7e2a245be9c452ad747ba4e947782f5249410e31680269143dc39a8df104afe7c5793ef47f47798d9e1616d049d0d1ea78a5a49900d2eab56d5e5f2619663f273994447a003cdc5e76cba818a7c8565b08b208768e26e176bc1f16878ef67c9e199a2f765efc4eb68ab8199b58600fb240b79b83329d06164b0b595b612fcfd1719b6c8860290f13e3191cda4703a07e2082da06ab05aa572ab79259d246b47ed83d1fa7b89a23107be7915acfcbccacfc925bfd9fab2939c19b4c7ae10ff13d09c1d99dbffbc4362707feee3d74c78d8b942d9fbcaf0c65192e14fb9ab37423b72fa00d92ed4d68852f50c3e27ac0e2d0f0c747f6ca48ab1e457bbf6566b52683d0aea797d525411d696c639e1c720e4daf390688291aed0964bbd4f12d8bc8d6a5e8d888c39ff8122b3a39c643dfa2daf7e08f0466c1b80c204c838d0ed5e899093fbc23a7ca325390d27df39cc6c3e0f6fde2075f98da50b19050bdd2ec9f00e942fc9243fefc300a9f44b25ca27d0e45e6d609dc97e2c3af4c92e897814475013d3c3f682d75a071b60a22d8cbd2dc360a1f1bd37ce8e5f3df4f9930fa623a75b4e57eca14205755bb7c923093b81a4b857ac72b29a3390573296ede46fcb4d25e65fa1dc239de5f946636db7cf4a0c4fb606c4c8f3702a448cd6f92dd6b8afc1edb4b003209c0c1d62040d7c931db4818fb00268baf626ffc165a36e1d28e9ad64f999a91898a9d204c0026330ec701391cad82899af869e2acac620c9a6f738759411eb4feb67508aa3f1f73450b1f89e9ccb07cc2ef6d051c09c85c64673650863dfbc595c30c70939f3c918369efbff5293ac26b0b14647257f8c6088477eeabf092a396e7e40c7394c7dc80cac71e93644841e6299def47c7af0b4920fe43f7877698a7f0b6aea3840241e2ecf5dbf644da34c9ddcad24aea3b235b689543e6fd5dbec7b838144651c3fc43db245c252eb1e8fe9b8bc5b021bb0ffe828a0ff0ee51c4d19386c6b6ca193dc6b1e5e6da8efb04618a795dc921b543963ae0de3c7d9277283e9346fe0b692bcbacbd527cd24a11456cb6727972d3e028511ceb7ecdb09f6249527e0abf3441853c4664578e074cb1994f6f16af586d007ea446c4db9789d180653a32c62f8e01c4e380dec8f366fedd32d3bdae71958eb1d6874f00215faf9ea166e8984ae6c699c74fdc99a60b8b8c1c8c69889b1bb6294805dd844d859f65a61aef6a2827034bcc0f505e786226d072c19e7ec47ed923966072de204a99df89619077b29ef05a4fe3406140a240b3ce09a48dea5dc23981ca98d5d530a03c66065be479e09469dd0a6fe19cab0ad3043dbddd27975b63bc50cd656e2592a073f81c2a020ca67f669795862329b298a1f2f15b9ada1e04889d5ed2c4a9ca1d03d7fe2177e3de1527e695ba4953c4d5dd9a41978cf44f58807c6a78f7c2eeb35fcb1ba5596fbcd86328b1fcfd5aa31993973d5d3193c01bc08ba316c9bff2774b36790a628d692f292db6d3d69c7e0d56697e6e241783f8cee92562c1bfcaf6ef2862853c9321344938364604dd80322df1b221619d363c692c91d5acc72aa8b5b86856d9674592f6ee0479ef29199266334b59a5f1187bc7cc6961d5272279ab70882cfbf3f2a02d98c7adf7bc73531eb76229a4d1d686bd9bde20066d537a7d8ccb2f4d9e214c37d780ab44cb40dd64b873d55095ca9227737011dea198d477f5760bf621c4daeb7d5b1a380247fe6c1d07e2fd9aa8e7ec3e3a9fcc7e342b6e13e2d66b16ec0d1dfbbbca193c79c51b07f737da3d5947ec21a3c5883b312bbb246a58d31d28d3bafe70a081d00ef5312b9bc9f0698cb26cfbc465f141cae8ddec55476fb3f44ef8c0c5b688dc519b7af264b19e2fe36b12d2109da9e173765dafe61de2a5249cb5d5d808575a1b90881f1c4934bfd2b84922bc5a898f59e3ad858f79e85f963638d2045f69feacd3cc384f0482924cc136cb8c38a9e33fdbe75682274444bd02526def82a17659f6ee9dff76923736d6ebd3eeb8941d11a83436e82e1d613b1cd68038349e7bbdf85bbaa826a0f57874aff4a6c678cc42f848bf7ef6c38725be3b018612d9c257efc40377b175c13abc0c9f4105be3249e3c39f2f730e77aeea897f6fe0b39fdda97a0a32785dda15e5a25394f53f827e3c3f4fed84cb1671ebb2078511447493d2d3f99812f0277fe6c47f9e8c1171cb3f572b34dbf0feac9304c6eab3d23d09739ffd4cd43c3438e1f305802f9bf499f21b84926a4cfe6cae2c1a507864e43677703c2699ba8726835375c47b9295140f6cbad92a63518c3cca5161cfadb2d0b3979d983e9f6ad5ff8c80fe3b7f68de8a645e505f21d74bc3a6be54d259e80ab37db0ebf6eb705f9fba1b323b90acdc4b5f0c84da3b9b417c3b98e8c7a311118db3bf9fcde4c571251c7628f5ba003f5887d6130f49dad6784c1308f63383ed70464770e7dde6d3e9f0045c66375f2e0692bd46f0d1fceb9ec68c33e7632aec9565911267a997656b6b90b27ee7a666622aad3c43430c23a037ebbeb7eabd454e8110b1d120ae3dbb4da9dcedb4a2f7ce14c5563859070a165646faaede724d6a32f676b1be2c46c879fd249819ba2d584c8ac1883e986ae800df89960b04958541fc4e2b13fa1f71c66a4e7666823a6ea29f7a6a9ef197377ba76a9487039383184dce3954350eabcfb5d6433873cadc6c163336c9c9f209e7174d47a34f75ba38142118fdf5e61d201f1b1219868c042b97c451c0ef0ce88d924cb698bd0c7192a402830626020943423ec2dd0af83e02f3fa2de86935927d529fbfc12be07653e69772855499e66055311b291d18937170eac8f4cc71850a4b2fa9af23cfcd35b9f71081dede8982a211348b4e74f26153af2fe6210e99b0efe63b35edee289e6cd6a3b0dbaa5c2f8c3a27792c261abe002d78aae7014c730f9130ca6f28b23d86b44aa7615ba6d2020bcc2de941601c9dbe72d95e158306bfc705537df541d4430e1fe75dd9ad0ffc8b67c4fca81836fbf5c24f3d291341a84df110a27e17a8d9cd9af8f77b4f22b80ce42592031aee4450c81bdd0c6256b9460446dac3651576603a8b93e6d88978bb10ced0329d5acc0cb07c54ed03d1f22eac7ca220438da21f26a878ef5da9438f1c52a12ce39cd1b64c2e0b3ba9c484a83c4587485ac7ea40721c19c3777ca230c1a47a515a36b23f1871273b8a979714e228812de5aac61b2947b967ce1b8899110ca4b94733990db3cdc1393e2689bbc44b17ae6fc302e92f3d5b89d5683509bf134f2230450fdaaca76ff91fccff6a86a0582cac577d204bb4df8435ebc325b2c973f20827e215c82af05c6b319fc3cfa64dff8ee22a983c4ab1cda61479a832a264aaea526ad4eef80b904990fa38217b1e687eed431380e8384863fdb92de0775dbbc34e3bb0455e71c7e5487be018c67dd50ee6d8b7b6958055e7b6938d6af7c8fed43e8aade8a920b1a8a5636b8274b06889d672871d9ae24fe921c49e5252c97f3ea0154a03d825fbea89669c3afe444cfc4565aa6f8f39d837aa6e2fcdef5561c46569140d9e59b5a8ee674e47b98a912701505f418d149b314eb4b01b1b72c9e39bb13998c22d8340a6564aeabdec9d8811b881f4b7be8987531692e010a34f40a0629d1ed11717b03a4805f8dc699935956aa5b8b785a1b935308bf984b6c721eba40740854c7e7a609562ca05c9f72ad55cfbcf5a3def5e6c33febcc1e6e2ea73a9fb07c8f9abdd1c70d9355876cd1c2adaf8dc714508ff695eda35d68d4b72a0a09be9800093b43028f2d04f9b77b2fe3954e0560f5f7b80b0068a496387289fb8041dca4d8fb3c1e78cb7a1ceb9630d7440f90c95c37382ab6a9f89c1a9a068359b7ed76a29d6e0beef78c39cc8174de823c2f6b976bab0a683848dc3c7e97cd15607f9391466844e9f9737f5ac9866789097c4697269f47a5a155697f8c291f077f0c4b2dca86148bc95bf3c55fb23c59518a9042dd38a5b904dfa26277b650cac45b3480869b9d426fddcb070d0f7e28f9bf51864ec2c0427b321160fbf994894d37337ad5175535e2345e0a96ec8bc58764499f3bd77c25e1af935117163cacc892b6b6e537ac4eff8e6151c717f048a75b6838ae6780ef50876b060517515c12f62038ebc4fec1fb509eb490dec343f229b60ca4530328635493410cb32e45f18a91db93adc56b96ac346c68071d32177ab07293bdb8023a53f92b5fb20dc10f71a2eaaa20323b1d04ae1f08a35f8bbc192024a108fa695c9ebb526b754fec618a4fa80fab0c5df00dd4d7a460c3000de9cd56af11ebee2f0f49ed69e5ad63d88ad40caf8a4f22eca8a41fa667f07838f51257f391690d64e48770b55ec717bacc0180722c24cc937f22b3f2102ed87061295e00005b9699abe891c75032a6b924e03d29b3748aba69a1234f907e3e8777abe3a60a0032165662752f1d33a8be10e73baf6b62d3b5d9d9500369f01985577af2fdfda88b992e151ec94b1d3fe9da4ac4e3f08d8bd1983010bd0767408bd672e8b4304d92e0281386209bb49e50651b8347c6707ff713adec4453beb389883b2c59d8f87b5e2de1126b8d454fbe2875f6c539327d694385d389666cb47b827236c7ef6f61f286192731546d396f91f1bf544ade6a9901e23e480dbeb4778404742f4dd7a8bd270a619aa15eadec93a5bbf804f389baf38624ad94c94089efd2815dd5ced1e17a218bfa62a5a5a4754eff5383bcc0a16df4230c7a26619168fb36b457ef3bcf127776a49eb50f20ccca677ebe715af0cfb95fd7ab86dad50a3045065385abb71e2e8686ded858ddb11561d8ce735285a05cae4d00ccbd6342750d86646f92bc933e715f9a10dfa771b1d64304d9ec8b0f3154760857c68e39bab363e3bf2272b1f175e4f7610be74397ad41e876d3dfdfd2f0c6642f84a2642f37511ffbaf4b64cfd39c989c60038963bbaf1e8d14f03ddf7060feb1a211b9f7d48dff5ae9421cb87366e63665487b6d7cfe81070f792614a86b29970375175a1d6e8957ba1082a773d685a9e48b20e41e7a3f33dc3f1d3f94f6fc23314937d5218cdfb7dec9d94e7170ce55a200766279f9010ad52fbf0ef5c3c4f4907d25ba7aea5272de43060ebb265e34c9e5e548af54e2683e158afa4a9ae81f6d9c23f0fede6b4fa3c3a077c6b2e070b95ced17008d99e34e01b02a621f60bf735df018728f28083cf6f4ed58b2f2ed57ce5d87e9a992b2d9e2f2facaa779af6512203e3ca9f8a86756c48f6b9bd8de2f1b2f5e08a7c3c44913080bd9b26874a4209b02b18128d11a45142c3de27d77dbe0a2bdcd657eda27858985a25f8a8b14d27f9b056e007632215369435b0862b030618de4afaf3f3e3781bd8bf8a8acfccc0ccb8c7169dfa7ed16aff266afa6e585eb3f4d1d58e16d2de164dad772fad8fe8898982d4030d154edab58dce0335d78a70a44883ff02984a7c31c7505c68324f898c9f99c1ce6b641f65a00917183747240e74d5504c6f94bdca6bfd77b3f1832ed89450e6e79b90d45ad160545c0bddd59f5f4bc1cbd86789880730f72a18e8d4306901b7f531c538139b5dc31c50285f3b120b6a4f83397790854c85958c8b6ca8403e35b0ec5635b595c8ff44ea6be4abef2e961b34f14276b75e17a0cf310959d40f14b1e2122e303acc1350edb87e11982cf272634d698dfa0418ddd91eed19c79ca7cded07480af7ca54577274ed8fb1a01f3ac0d91f5e438962a758b477fc88f669a4f69b061a241c4f3fb085ee595ce2b654de7b03e337330dacaedbc56775d05d243bd7f31f640d9726c16b07ccad3cd8a01268c30efbab13f0b5363e380b2836927da8f064dabf9007270ce97a9dbdbc4f08852ca2337df2b9222655113d8cf95beedcb08ca55c80a53c11dff761cbcf2ae8ac53c97492b4505d0053152fc7463d09e86b97a0350d305131aa65b0a0d2a84147e731f2d880856a41bae26819b77367620c25acdbd2537156816bb7c9b748f012336907502328fc2313033acae7731a8f6b9c5a18687f8b9242d4a77b79beb616ae5b244bed88f4bcac3e77a996a25b0f2baec81f954325792f776a45034756a668bf3e10eb1ccf529d1c08508fdb8903794f59db46a4415f99320ee4abec3a499e63ce19cd14c01f2635a7d0f743bdacb47739e553fd84ce376b9327ba029798fb744ce3e0d7018ba14d16407aa3037d447df4443b1eae51311b0a5365f9bf24aa34e022d6e4430593a2cc90593e637384622b8fe5f19a637c6a1b881de473c54743246f339e1adc92aa14d17689bebd2ab65468cbbbc1e21ccd6d8c29499e7a8a9ab4f757ac244f0c6af8c1c51f15e5e129128b2195840425d779a3f1ae27f16452f04de19d4aaee6d4d8b8270720a2abdcfdc6db06fec63718e8577106fb7f5cae32ff7ede0512204b4637e20f77f314ddc111233ca9e661921bb982c14bf9e222391b3d4371ec0b1f951a6f701f93186bf0b50466d3e1fd6751dd952e5a060985795d869a892a9b4487455cf1aaed45b68053ad42e560c6d713ca7817131ed212811c30bc4701259f719a502976164e4b16b63e8ff080883b1020d41575eebe960a36795d6f15fc8667e17f18b35eaa8041170542adeae07322a190af4f324733a7f8f38c12719935d5ef4bdb3835c811d132b785c1e4de0cecfc6d716c8fa471edfa173c55dbba6c5a8701ed300d10530d0382fbbb01212d62e7395d9232bac775410d7b4e778e82dc3b7f344e0d34f86be34f7ab8aea96c581d38f69c87bad93e7f7c255bc1188161bc9f5b703a26bbc2b1162864ef0d6cbbafb8247894cbb8866aa997eeb406f2f459fe64093879a5f32dcac49bb0897fe924606626d3d29289ebc995459bc79f6fa25ef5950039e4675518806c1f7aca74f5efe443a63883d5e829f02aa80e77bbf493e990ce6a86894f6d9f3239defe17f2702af0763e2da57ce4b716d5ae8c008a2a9620454e3cb76d7d835ab1e6cac7b1f802aee936e36b6b80b799fef7f098e0ed76a183e4404a15b561bac720936bdd5a49e9b1e4a1bbb718dcfd79a39663c270755145e7d627722ac87d1d4420cfb0573126d70f8d84801c6f0fe6e0ffb0806579c94831c2167c39862939654352c37fb3649f446d85aa9e952935f53569b9d8085083c675a88013f4d7e8dd2502eedc07b24bf09b5280140fa6f236fb0cd6ae1a8bd7f8f22cc40621b11f9b337f5ed0a7e15745e4104eb6703e4093b45d89b7c76a8a2e91cc311f74eec148dcea77ab8ff666d120840dcb8f2abf74f7d5fece8ea0fd2d28c554dc2536d58266827168e79898ceeffbdf2892372053a215b1ea75cd331289437a3252fc2c0a14af36d6dd9c0b1aa29b0cd129eaaa4515a8c9621133e982d01fa6cb42d8cfecbe30804d270315d03883f4e15f914ab182ef0e46ec1014dc14d624395be28afe44f3a42599219fe094e8c959dec6cdcce369ff12a6bd08c98478b34d238e28886e2b2c33789b8c41baf6f361f3e80cf125ab2be8c003504e8e522aaec718812286e8123ac4747482c68cca872e391de85b7937e54d5beb7245ac607e4fe387513b897523d6578196c1ccb8aa2955704cbb456ae6bbccb4bae064c6e43b47b355efccbcd117e726ed9c6f7adc5fa9564469ef60ba9a67a3e335c1e99ef4c084ee697f304018ffbcc57cb18adcf72057a6824a392d0450e638bfc07f3a0955a9dee7fa4bd154a73b71357f6e188e5a252f910be53b39112c7a2b5a2ab59fa2546d8a650cd77c0e3a7e023501266003e12b187297f76793371ab5c709a22419e245b3f429b14987132bbeec27fd76a2a02d989bbd9b249a4cf8655bd2cf5b618b186ee0e8f2a51c9a5f6c4e39274511b4a2957d0c333e2b1fc0b677049e2c4ef5c63de49355451e5989de526d2ab86b7d52d49ee3244e8c238ffe35148fa2666d5ae44dd66b815c370dd1f48963ddd5ae8bf49d9906c8780696d6bea229dfce3759581aaa6f9911f155a2b86d5e722ae51842c5e7be71f4a709a0129f32923e1dc30e1c5f5e5db516d00058e8a6d6debd8c53fb08a9b59e802058ac8c0e3955b1917d8bd9c2810e4a6e9e2f0fc7b092846d0ef0cd0d658f4a0a1d17d6ea117588c06ba04590c39263a5dff8bdf05b156e69680356ac50e5796ad3579166c105e1587ee0b32edd42f751bdbfa51c6d76ba91a90ca7d84f2c265786ee0bc18fcbd0ffbc9edbf91201b599970679eb5c3fd2ab8e552f433821e0144e8cbd22e898f8882c9b3ac92c32c37127abf1186f533f1b9fd5be9dc3c90fade5d81a14dd1c20335d80d12a2e9f0ec38f5a2f51e01196daa718899b854a0f15bde8b4111b7eb3982a41768c2ed855e493f403d46791383786a5e1447c91f2c17e501f928264e0a82f7f41e8270fc608bdb399fabfa9e173f5b26dc16d9aaded8f81ad12687de4ae086d8cae238873c0ad4b366981b9a9b0059bb7d4b841f0889b1a8bcff29a8936ad61c02e4e549df9624fe6671583ff20ebc521dfcc4dbdbd209e400378f4386f75eddb77c4f475a1362245eca5037282f3f521835af2fe7e152812ed235531a5d0650654bf9bcec8c9cb9a2c5bea6e1b54900c88346d82327150d177147005ec4c7151cbc6d84980a1e3155d3f8f5976bd42ac866104803287fa2ad80ecace64ffd282dbb1e9a38d4489de61a27ade13f142c231d8ff2f6287bbb9cca9f1b1551b4e5cf1304fa80e9f32f50409e6e106ca081840ce7e732baf6abfe68d1de2842c9b6ff7d312f2df20cfc31bceab59deb02f045a7607271b44c1f6e49bf1df889103857ef5c3f4df2eccc5020611773e106876f25cbe69594e9fc9baeb401ef04830efc96505ddad1a80b9ce4241ddf600470644df46d31dd95cfe9ac36b7fd0005a829468e3c61f7f8443d830262ba962e97fad9277885fbc3bc5024af486db5686e4d18522c386d8ae6958e67b221e3e7c556640584925dc5cedf6aafa4baabb6d88c8660a8bd4074ff89154cebfc78ae25b88f6301eae12a0a22a0ac4c499c4403f19aea375e6ff463828e7f5882b5f9bd7077894bcb1f248f3f9c7f42c677ae8b8f91443adeb6d4fdcd2f57ac841ac48640dc7dc8d1502e7638e48e86b1abc803044bdd642fcde5a06e82718bccdef1ee3097548344ca562d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
