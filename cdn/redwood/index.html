<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"0655eceffdda9b66669017dbb38f60a0c81d0ea0cc2f5ad7d86a27239b1e2903c36d77e5c44b4ffe1e8b9f95579d6ab34714483cf5ef640270461c025368e5e5574ea71ee3b4b0eda9364af52aa4440d767e12326fb41e3e1b69b9e22fb50bbda4b0b3a16d4b9392087a95d35e534764031519a37fd596b321db2c65d900846002a07d980cc742208b94746251f81f2547393d717a25dd3d50e651e2cba30c54e1fb0145658fa614b1e882640904b9b51947e58edaff0dd8d725178318b5377eb59029df441546a35e0eafb77df4e0793ac12dd5840f28a00ecbf75f40085ce48e6c3e91301a3c9828102d427581b46060c0c3b3136d3fdfdeea85d094c479b3f959c3bf37f1279f2d664caf364aa691cab4047bbe3b7d717d258d31d1b06ecb54f64bec52dd0de928be6f91627800198e167968c6b4c02469652603236b0bf4e212818d0450900c3bfedfa2480d6114139e62c638c5413c13c3ffc227a594c77a7def91d8d7efc1d94b4768162e5cef901cc70a3a9417b8ae6f720f62f97d532f0864962abf0d3d3ec8d9bdb87192b16b97f11ece98346d540a865ecf9f62b55e83b470436a59dc0cdba51f15294572adc5b6cb075162d6f7843483c5c2043c0098dd551880569121d7632f5cb2c433fb1aa0f3ac6eb1334af3454ae32aab1a4787e0f9b509b99acfdf70c1fec4cace7407f30280035a721295752f0d9ac35bc7ff0bb3782cdabb1bb41a872622efb6a053cb509efdff20e7de910caf05a055e16f8e96614c53ba17035b194c3ba54b9b3d6e216e1df42ff6593309194f9d2311e60dcc78364ea7df870e144572d5d95184327852ec3faac506d3d5fd272dbf9ac8deb018ec7bb630acfb329e49fb0902cf67f60950f344c8f77ef87f5f00143b5166c660286b00156138becae81a0a9ca240fae73d35ab86a92c85a84bb970e4af6c6e61642192e00df1b9e41a85d675883cd448ad10e6561a4e544535c05349bd0ee1d2fa2490ae2b5fc495f418c53eb1208fcb6da6261ce29d294ce68bf60a0c6eb7b0e3fbc1cc236f227a7f6e78832f371910eb26d997ff3f7e53701a71f6251406baf2c6a870e09c25869ea34a4dc3e19110cedada78a4c2bfc72f6e6493236a57c9caa38c3b34111aec93dacfe9cbd8d86dd90d62c408064e2a792ad30d9b0d5f7f4019b9adf362b026c399df9aa130ad425328b5483bac818339198e6bb418261dd99c14563eaedbb03be898ce4aae10c0b7c6a225f5a9bc23893e4ca8af21dc225fdcfc1dd014da87a8e62e08c43dc83212c88a976c4980765bf671642070baed2adc726b13c1b95064afa864a6b033bf1334a00d20e755121b66e87292599fb8e3afced144f1c7000702618fa3edbb4e06c050dfb25a8e4817ff5885703dd06532981efd22c42907e2a55a0a4e1684f8a64b950245654937495413ee718a7f9fe65413daceaad81c2f37ff1ad6c5135ec93cf079d85e3810da08460b4b461d84b59ad8422348f54f1dddd58e431a4abc257a6759b2f4e0198057b45b42f38a2102409b0133115f9ead444ee8c5bbef4f458921bb128cd10b3a2d55f6fed8b465201ada14daab4ec9a04e01ad6f1e4bb2a086541166d44793b12a2519f3c69b87fbf291e72e371a84c5cda301fda7acf47ee69d1d547d6e743ab6ec8d1f2618ab64725872e8caebfc1b83c1971d75e9e3aa0817aac8eea3b53fa631ce19d463a7e9c258167d656fd6f7c806b0b806fdc61dbd00e1292c4632f983ae3d90aea7189decbf5204bfb5fa7099360b7658a4acb77e215496cf20256b0a8a8cd40e08c97e7b78febf101da115a619611eda71fc02eb252e38e0a8066ffa94e9dd109e7b3fd4ff5d4c0c8a8c60d64f21c9714319e732ed57c4cc9559b5f6660febd8bd11c9eed7d53bf9c0cba30f2ef3c92069dd15da9e140082aa81f53c43f5c291a2f08939de70b38146467367d915d6697e981bce3e5e29fe4c0d237006769cd13749c876ef287ceea569519a614e4fbc43b5cb72a9e5a0acb73ec6d71258e0a3b2dcd3fd96ee71f4d09c03cd30444defc609eb81a762d91c6edc263963d45fadd41088f4c14196867176feaeca0bcb3ea293135ef345841fa21ecf546a9d23bf3c6bfdf3d69c9092a5c6b01918f7a854c924ab8135b7405d5c569c8fc0c2e9fc14b27bc808855f77a6fa7b4d5d2e77a9906d588e9e88e01843713e3adfe55162fb67073920337b7b19ea871d7efb17692e63a1978346d58437d3c8179f37efc9bf7b12ed1f7e369bc5fce4c5e0de7472f3526fffebd133ddeca7826ae1d46181deae7be38f08d5747c60121f1496a90980790b67ec30e4d92b0062722812bed71a3b8459bb63a6a7380c2e45844e8ae4fb54f97c76528159703d31572bf9a8c9ee3f80a7132b921ff624228f9ea5ce95a5668b71c74ff4d93ccff676e3c4432e3e1c8b3e59b3f3e70cc3b5801f38c122067fa294fc0c12ed4ed23a32c495726cd288a1574c2b7df64071c797702595ff916e11126d0b55cc9212f2c4ad47c59bcfae80b200d758952a3c44a6cf50796e2124cf8d6ebc8d10843616a103c50370d8c6837b2de0f9323a563217bdb3ca928447e5be287a30bb7d5efc94b8daf98b95927ad1478c6c9cbbd9eeecbc2a5e84d8e9039c32aea600c677c1afcf170542b0391452035baef6e33e294c4fe51b7fbfd35f69be1d93245d14a65871935b4bf122e1c9bd00409279920d2bc9203f38e5512651f0d371ffdb33461af3755a741604802e82387f8786456f14bb5489ba891988f2f91481c7ee5a509d363534b374eaaf0e9628cf1af2c865a1d0e14d6aca90b74cee0ee7eba167ef3331924cd38114b94da2a5e4111548adae97c8ab97c6ade17cde17f93170e7d90ff580e2dd11f364f0605a816d6b4127f5e10dd1524c29adcaa61941cf7f402680af876f3eff5febc0b49c56d995963e8af127bb322dadc8ff66b0af8dacb358c68c2ba8615232149943372ba49e5e6d8e54ee4825ca4d8a87e25da1e308ddbf9137c4fcb35ff38fe63a262011713bcb7dcb6e0d2092fbab6e9edc26839bac1bf52c64d39ea8c08e2c4ac59138da8fcdba751319c31dbe7d77773ec98c172cdc7bacec69973ccbec3b86e23f257d4351599515c34cb4df6443d6309c0a932b4414d9b3860ec53709f0c43dbd22ca8c2665d88168eb5da3a541fc776db18af84e64980fd3579535ff803a3c785028ac388fc92db999d13dc7b48aefd735037e26bf6c550f11d3e45f930b427112f185b90e831caa6b0ff1d24d18071f4f1add994466f900ab4fa2627259a8988a85225b9a7a3058f5d64179eeea43c3672855d3c199b60e88d12767b8698b9b2b0c67acf550e550a0efc32d0cd085e0d9bd79ae0bcd7e100588e7ef59a64bc9f94810abd2d60a0da6822741f7438c4d5fa36af87a8ef048d02b705f5d04b9ceda62da5b0ba033df1929edf79d586bcb1ac5e03c0f1c54271f313ab96e9e562f38bf5cb5b867644e052d9408792379e266fbfadfb1a008cd48662efe54fc6ded869944d3e9654ae1f862baf85fbb209563bfe8fc2865a6fe8f6e97d398f3e435d8255a0beae57540de683c4a9f42334141224dccb540af971489b7df69959fd5afd6f85e07b039aefcb55c6fce6ab18ca97f7b1099c098af587927af6921dc27094c32144df522c207a87d912ab2bf8b8cab5b29aab988ae17b84893e1cb0c104040be36bc7d5619dc0bc74325c972e14b86033684ec9b8269e0fd23669e05b71dfb06b2d9cc992af25471703cbb77dfe9c29f70f9409b0a3c84a436e0347fc656f95c4fbe50601c46160c8d8272cb88c0c2876ee1f90a8023813c459c990a1ec8fa102e16e6755ab424cb0791baac3306bfaaab0c8be5574848ad57e730b8b7324971373fe6eedf572adc093fcd160f457e13e239d3f427c9af810db78ff61da3db9a1163ef1e421f80e4b8ee91948fe66e0b8ab228660612a4ad0ea3f762cbce625f495a6707f573530f0b0ce62cbc0e51c3c173cd7c5eba3cbcd3bee2c875def8969ccc88b0eb02a210398bb556c6dec991b161c90ce2768e21635348bdb132eddc065f2fc3a24cc2e794cf1203fb83d0159f88193bbc269218c2c417d4b4735a6416950df306339c1188b5c12d15d182b7208ded93a37b9ccc1b799b6e7e038deb3b0f859ab255c9248968121b867c3cd525803d20055335e8a187004157c3d707baaeae74b8b1ade21acc1160e9439c5996676d88ca0ca1418b5429a018a4ed3eb0219dcc657c138c5c082586da9ae1575b294edf969a0bc77b1ac91855b79bd10023727c53083732ddeb9330e9da445dce223850f164bc950c612d68902e4b0d94f5e7d2f5c93ac4d51950135edae5cbccd63beaa635c2af0cd1208782b2a4cf5ab2f48cf683d17893e9ea9d2d338d25edd4776f801b3c9f03d2995cc94f536f4031fe89349f6be291f59228337370e982a49bde20aa73cdb0f9c130b6394b98987c284bd111c2503e2c553ffdd87acb0170b64393bca3ca0ee76d775b086c4de5bca18e65196d17abe934fc607118650c5d44bab9740b9b7d19c794664c57bf38cdd652288a598249e44566fd4b4a1ea00abeac802249e0b758add3a6219e13db5daea5eacb7207122f0f13b7e811b948a2607893f76928032c53aad2082197b111587d766586ad7206bdad2ac3541ab539fd68307779b358e269489a21e5b1e01c4bad0e48613eb02af58d2e74ffba909e6278d69436a0027c1ba6feaebd3715428c0363ef4e45d2914911f73ad3430dcbd668fdf5c6b3841c3d76e7414fb556c29b75986139c61e0a27dd5bc82c0edde1b117caf55b7d16830b07cb6d36cb24e6e4c664eae27d400bf9bbc7196b03c27f26e6768264e3b3403436cafa1511ef15682944b87c004b0a341c92d5691e9145b081f4de1ee451050a928de1d4f7f44bd9b41a3c1ded1621ff6e7560d8b9a8336e1e1574c6fd69f1d9a68b495d5759597355f5cbccccf3596d665c9e92df2d8d5ad9584ad239c665b290c0adc6cc79c0321980004a479c004c4db23929ed8081e56d5c47e3f93f6953d79036ed3b2f216f6b2122c16951fbea96f538b0f2276abf18a5a5b62dc3656d18d7e03045b19bc648ddf4e45704601c73a30be8c6d02883fe89c2d9210dd7eb675000be6e32c0ff4f35e1c82aa6c696390ee4805844458a4f46b79f6ba9015eaded8a36de61ca1dfe79a133549b37c736f319ab5c0809a62582ff271de8de36bfbf70ec0f79e019fe2bd12fcbbef011268b810ad3b3ef4b67ae2b5c8e0bf45cf9de9778fd1ece7a765e06c845837d18fe67575a89b250d99cc2b69c64ec0a30f3ea476c9f71a5b815b3232ac9f5bd85f60bc7569db232a16b546fda0966e08ee0eed7f8c85d83273de64c9d6d79685e6697f0fc46421e5cdb28c6bde9f373dd1364c11c1b1562e1b961e266a2371dfcfb5d92372c767018bb7e45ecab83cdbaa6017ad304b5fb9a1c77efeafdcc8f47e2296bd99b6275886461b5572e08f77d600f8ef0054b1e2c29b10ae6b430affc718c2204bc3d241e5c646d20dd770fd38f14e902a34281be0cbed92410f367d21f1996ae9266cedfa5a3ed11d47ed53a556b763e3ebe251daeac8a4920279b2960290c8fc166f42a605b25f065ed3694774461f60eb9520e9f3965b10f4c9dfd0ebfd541bc7ec02316746787ead1b4650c1b5967ccbc336cbdb4aeae2e3513a6d18c5519fed2abc5b9cc7dcc62c29689742a73e2edac40fae55556182ded7bcb8b2cc67699eb2ae8209aa3ad00186c187b6d26bf35edf6dc895780d06af67c6ccdb8c5136ce734b0421f05a5a8bbd6557b29a3c87597c57c02251ac9162164a261faeec64f1256c7aaba0cf3ba1ff8e88d76e936808d5120917e26c93fd726796f81aa2b1d37c83f88f8a8a187657bb0775d12e3f3f7acf6c4c78dcdb465ee52aab6e728959bfed621bb55bf59354ad26a364eb315495d84b4d93411bbe206c903874acefc36550899e5582fdfd2a01b441331f9bbd112a409c230965321400a4d6b6f2da480c4decfe5580cb314410768470a3901d8602f4abbba2b7a0d1db8e17878d2ff840036a86fef4bb01de6421b3630d66fdbc93cd0fc2ed5719e44749c64c99ef278b913b1944fedf240e4a7c729ae684adb5e1aa53dfb1075405471388ef76c819c19b982f0241da42825bf99076a9e864d74c80205e14c342ad15837dc252f886da7049c4a1b49fe08a5292891717562846ac52a35ecfdc4b0ba0b597bfbcbdaefe66e63fff78ab6b73dab84a04b41233afc543ae6a93ec2631688e211bb57af1d5db7fd62af6df46be769be36120ffa76123447c7076f35bfd4539a24eefb1686fdf1bc36e4b499900a297230f6ad335fa433393f89cb9190d16314384b31e4e7771016e96aa065dadda121110ff724ff92f731ce7095cbc80f5a8e2951123937fa4892d689066e0bebb4df22c80b5a161a5e5bdef5e1e15cb99e76f34805257a0d755a70474f1fde2e328104b1b607d486c4ac8b0f62e4437d9df4bfff44095bd37e497ae72633d48e55f14dc49c7057404c6c8ccd68928b70031c5cd9f285b9c045a5e85b83e07067fbfb5f51ab8b626a107ad0ef31c856ba118672bb983551d9f73a4dd3fa07618e93ed46d07253d07719a3bde52d086af5e264a7c25db3aa6e68809023ef10ba83097ce0093bc2ad591752a275fc486a10ca8252470456bd28ec0d273f6e8111eaee8d5e7b83b012ae6d410e71659f52bbb90f97dc0ef61db681dc8413dfb97582ce838cf4cb2a3177135bd3a9a3c1f22a7e24d86837cfe7d9d2c0710f1b0abb0ed672dfb27364f67b30c421ccc8289079cd7cc796013b119bf9897f4ee99a92309ad708440a3a50c22fd748491eba350e20a270a23324820796e9e509d5b9e293cd7ed6799b9a998caba1c7c46c03317823a734358b6b2b0700c158158289e03db08dea3a27b14da02cf0cc3e75f46a1d2f211f8a8e2b96afbd043f023ac600627827b39a7bf3f971c0cf67206bd3e8a2fb180c9fedcbaab5657560f48aac7c579e0eb6217af4dfb9642b16bdda24bec10d512f91aa2259e74099e9e649f4e7f78e8524e9b6c577a71f9b494a7a97dafac612f3592f5bfd2e10eca647eb76d26a21c29a5090a7ca457b096652d3d2c5801c76202b127edb0ee5e3df02b4b7e409a3cb213ec4eaf86805c6220053e176a52615a73afaab202ccc5a76b74b6d3e487a42c9b974408bf0fa4608eb7adef0ade495e0d6b6ac6ff48e296fec77a3e83a1246da4a90c04776bff4d5c02f0d7ad87d941d7d52605eb05d8c70031dce6daf87274a56b3cc1aa775f05d21c959d4c30a41c8ca1e3dd70953eb3da21c2411786a72bcb789e4c49140ad7f165b58bb6453ff76ec74caaccbb6c2d80eb24338195d3ba1e1839f800c26158a354b38704e5ba1483f65574f94a3ae7e2ed2137d6331150fa868fd61500ca16ddad9be15e7a028e7f5b8f2fa93a738735316b4167c2eb2b1cd621e666d835b1ccc1eb1572607cc3ab15226ee6ee762412fe1b95629942f932421f20f6e39b737c37a5d59ddb40f7877802d99e0519709bd9cc5fb0ea769cd671cc23e1b97b924c4f2e01d840e6a7dbbfef9061a9d3966ca0ae00f2bf734efd4b35e4246da979fb06d9f1c080866a9174251cbc1976d8a50c1c45c21bdf8b44f8748a7e9784f4eb1fec491115ef0ac8fff3dbc4170e06bd9ec34568bc5469f47b00233794c5fe818007e5b021d1c7ab1196a4cf30d70d7f4aebebfeaf7068ca0fd0fb70b55268c26b1fd675bb6a86b9640a269ed45e52616e1ed85781ad76ae7fc6c846fdad2939a26439a362147982061d13c48d2e00c908a12ec722da0f269891b80d2eadee42f712c14eef1c1c72d06b581feb12c3b3697806fb8912a1c67d693320d2caba925a7e7b1827fd048b01bbef463acd08e43ea0a194adfa4140483d2f37928da4f3e279f36ea2a2686058cd5ee6d84f181fcafbb90ad454b6838278fb3e1485a1896df03c0800b3ff3719eedec1e61ff758edc7e1170b10c578b40376cdb70464c4b55f77c3aaa1de9068510f29e01b13fc08f16125be3b9cc48bb1387feca8ce5b5feec37c6c209d1c5c451b4e07c096ab0d18518e804b86bea54b564876ee9d4ed44a5d3c96bf197e4351c3a0b33a30ba8949b376d0cce012f3f40c3d72e65abea604b83c1dba5295bc073c69b5c9ae2df6e10b74cdac3f3fb47c997615f687d61632aa324c20b23ab0fd21971114c6a91ecbb4a408e2379767e5958a339bf308d19d54d9c033265935147f36ae5281df33aead84d465fad398a3f2fe6049f818a492d46e4a518bcd3c19f5eb4e2f60c89a216c06656c0082ba2756e4008ba820bb6ae2318dc5324f19f6c20cdde810ba8b09d6989e1233e58693a289b44c72d2272f7d1dd004864ad21fa28c1e844ffacdb1cc2a9b96d30994bfcc2ee55df3a452cefef1936f654fb1121de72ca61986d888702a996238af872410146fece4f19d348859f97d8c3e7c36396db4edbf883bb0da57bd00073b513f27a2bd3f35bb9aec26bf2f8491d52fd2e032348026d08327e1be67ea5df778bd84fcd8d6d81de961d9a4f754c768b4bfef5f2050177b3e8394fbb37221d3827c621bedff9a288f29ba856f83d8781303b1de46991dac082fa88209c4d6196b92bd4156183b1dd5ed61e8df9d46c5523630d5e135dc3a8ca9bd3a770c361ecfb0c8ea30526935aa2dc2bcdc9a669f24dfed839127b82f3ad340df8f45132fa3d9a6cfa8ea509656d0352c77e47b989f4973406b880ded36c4f4ffaafd3b6c52bd3cacfa79bd8c9b311341c8bc185f2d29459b413ffe56e1adc6882b12b2cb6670836d8ded8063531ffed655c4e32f3a3274f41cb03e20f3320a9793702db420769b9477d849e5c69bf0ed71d19c57ce8ed384035ad15152e1761802b33138fbecd0dfa873bfdf6bcb3ac8213719bf34ef50dcbc720b92a6522c79a82eecf78ed9507e23ca9e4314cd59a45634ffa16f005fd680d195ba82ce234d87b85ff96aa8b4df77203351fce65117688faf81df3b1149352c7bd48aee490a78670845526e044fd4dea541e6b56ce4d6a79f9ca8497f2fea1f98c5cd48ce83f0c174797f15842192ceeac79cca4b9114331af0c8122828dbc0fc755fecd00b0ce8063426e59c7277da76a7600894b26318bcba2ba35165ac46b009e690e05835393b3e699bf8b92a9b0b5c01b75cb95406586e37510ba6996b2b47e4c8bbef261eba58c6136ea26f959e55fc486c3b1b674c8118e13dae594508695468a8b81b2e2196e93221db35281bd95da9f7900ebeb91cd0570b371d38f35363fb06703fae6cbd442f95c3a7094dc6d11aa1090b8fd333e80e6f0b4a0fa7f640f8db784a9785741b1cd97cc8e29da647fe40527f06ea92d8d1cd642b26e8c9cde173556783bb29039b257de3dbec990c7c2f9e43f3b38af026f3ab0eb377de5226cfa8ba180d3585f01c9006558ad9952379fe8572e899d43a60c207a0715f52d89ca9f712f377087b5a4f616961e21f6a19533c41b3c86dcb1f74215911cccdc7d2ad35a1ff613d6f264b50e53483c161c85e88642dfba3d2afbf0b67d5ec775ffd11dc73e86dcc34671f2dd132297eaef1c02eb677039e9fe5b62412783ee49c4d16e885fde9bbdeec63f3f7925e04977c66c185c0441776a8051991456c158f472593dbaa3ada7c69787da7c3472960203f202b51a866cd8f28fe3ff753b5dd62b3975fd47468fdf2f909d9b07c821fe18f7352708bc6b3b796d94abc8be08063f4da51039c33d4d60600f2468f2bc0c37445dba8b9fb64788e0473138ed6a7f41312d476c0e4cdcfd7c6941ed0d654053e7c54e885fe729de3058aadf2681fcbc223774e012080e74c3d7add65255f2f492e6cf824c8249438bb625266e6485b2dbac960b3343fe803d154dcd48c0ffe7ab338ed2a2120a2bc6ce6248606e82a7cf446700e43c8f4fa2bdfd992f25a29bab8013430b46a2adbb31c5059f6c18837c7d45b119c20053f1cd119ea34f02976e7a488752b1b398436938eb4ba26cabe9b7ff4992cb1be1634886027c1eae63dccbbafca5af6223e6b83a26b5d9bd4159a2692a4c873aa48f31911477573d2070f847caec23111ff004beb73a9efa996b457b53902df23868790299e938bfe676321d6d1c9bb8ebf778f4bf43eb19f2e8e1c771526908de700232649f358129f9251ff44a064cf66cec5fe444f21cf4f9da5c809e0ac985d73cb9f7d45de1a3ec7c97d4b992bb04f91504c0c573474d3b1237736c368a06aed97bad863cf339caca7da7be11a7f5a70d7d3aa8f8ad15487ca6076d83ef12693d2a0a0647c7875cd778f7229107e657f8ce4e23571e55f7af8c27ac04d9ba9c76e5854be4a18d9b9275bf19e0e5dfb1d57500dedf178fe93dc59618b8306a9ca64c67c012cf51fe415b3e2011b7cbdf9410ce247b1e424705b1762b2b58ddd724bf3f96d1b105ad572ccd9c6807baa5752f18811f97d51f7cc18a30a99d853fb31b1278352b5d3f83fa22acbe83fe5eb19e5e3d2184470e882f69d8cacc376c1b8cf95c1928b3983c9cef7b8c5df51b2e66f26cd3231f6626d3a710737b01a22f38ccecf3fc7d480a45406704f22ede8a44dc5e5315cef7527b775942cb507d63d84a967088888b01861f57363a1ba2b35259aacfe882a26e4d0cf4f7c9bdbcd166b30399c8b72059c55c7c0ba14c54d479198795f2a7a76a0e2fcc76ca5829d5d9c62225c6f08910812e5e015cad1f37e10defcc1267bd0ede786c5a9e31e16e7e2bf4698b674592a2f9681c24cd7ca5693e94827ba11b1e85313e3755f57a7a8b780779802e617ec4e6475e895be5d576a5c3b73a4f82bb6e78553a9c3e340b107d0d8cb7ca5197f08441a7c99c016d3a2a615c1434f47cd79427feafd7fa7836b70d45482c643052a59a03b9cdabb9e571adcba65ed1529a8772a25ecf66701c65e977527c0b47b8be0d2049883d53f94d912dd13808313029ef9ccfbfabf5a912b076a6522783e638c6748864161507bc5058dd73013581f9b294dd59dd5b50f64ce88686ced7bc08300abc3409c4bee9fc622db48fdef6fd60459ce2c53ae65a14fc078564075dc14b5954c6797eb216d13022dd951177071d845af6e3711d1d04b12fe89214b9ce79ba39c039541ac5366c9f98016dde3b016303eb391624cd6f7532cd4d9225a7a1c7e754e29e99703fe3a1a9f8186f5c8351a8752db706b776fd53fdf541be01954663d9350e1a2107dad04f22d502d3c63f6f96a40968c5b93c326961919908ab75a3420470cf7d8a9c1f1eef59afb4c7916e2b9012439d5fc48d427f987e3b48c9200a736f291683403788377ff5362fbbd3fb5a3f9ffb948b7df60790f549de544ec20d253be152af1c0ae65f12b87243b4def12da2774f432cd7b6977cfc868a6df608c607b4a15c900487a6f557178b1f78a753219118fc769f370460672c976b54e94b510b9f5a0e03d856445e5fb2e075bc9925798bbda2b7daf3178bd0ff144d8476264df5c06baf38614cc1226b2c327724e1dcdbe1ecbbfba6629c0476e0332181e9c3ee227c5a7e4575da71cbe4280c14887f74e7e8034ae6a91be80f7a0fcbbe2d516682f65b39497c5da467540d52f597202d881e18f8107c57a89cdd10d8d738ef7286c7a0f4ffd612ba4ced1d8d56b16843d1e19b5a8d79270e8787fe4fe3da57f382d30bc6e9c913b32de045e2a95ff72ef7f9956301eff009d67287e41210b1680c029c469a0b0513e87e9fbff83a8030f25db543cb127f7fe3da71423ab6ecf348124e21c95ca69b723a798bfb89f883d1b17862efe6276270792862058f78fe6555195254b2c0d2c9c44559da99589a752880d71c7550e2c7ee274963c40dd527293b36c674695fcf646f70a29c57f52eef50a6e6100cd6f445be720155940652e9dc1d0c1dfc74979726d86f2b6f3fd71fd7f0b4c80f7f448829da55be1fa4045ea94f289c1f583fa6021be106943b204b6fcae3d5cef3119b54c7c6a72c32b4bd7b6fc0dbb0dae363ae530e13fa8a6ad2d39ea2f25a4e4f35552f63f552882bc19d7ee5106f000456ea4033cd9ee764c06f70fc8ecd5cf657829921f344915bcc81ccd32e6e4d424d091354767760d185c2be5d89872e31ace4d0f7404651462fe81e27099cf1161ef9f1e51c7b63164f19f58d1e7aaec7537b51f0633170688409a6568faa4275d093f3ea8dcb2acc9b58002effb9d193fe422e53e3640e2f156fa40dfa147afa778b2a46b93eeaf061224dbb34ce087595b8f3d2f8d195103eb6955b5ffc8d6fc989ab6d9bb4079569a4bffe80ba71b79d03d51e9fb9fa66586a5ffcf5c62e7d0b89ca849f229c1739e7ef51af7041bad8a3774d83178a6e5b7b7659683ac7c307981031211423eec6fd83af4908be2098362cb972cdedcef13ffbf2701c8fba9c37f26a6107811855d0d02cea71c87a45bc6a9bceaef2f34d83d8a30ed5bf3895c4ba6010f1692c768be5a038a9fb0a9ae0c33fbe95774b97836e404d43a51c9b284d5eb2aa96e0c66a359c9298807b62d6785f8f08a030f03bd89961f8f82a568387be322aa4716145cb89422d32a6537c5ef0f3aa567a82a68761a396d3ee683648e88db10d7bbcc3c1192eac855f20e7ef971e143c8f1ba1b4e42af320edea09dc36b746d1b8e9ed0a546414c7277a7e88312d546112f15cb1dee06d355d04897beebbcb6514cee3236a3d2ae636c0ec2f9f48ea6611b40b74541ebb0f08200efd3d15eca3d14421d0da49b1385b5a53c379f400efa514d983a9f40c4a1e981bc440b8e679dcb1d1327707d612ee6d077d4d0cf661681815bb03ec4259a45360a9b4f5d7d9266311b55308379c3046f5ad7858780ad879c4f97f91004b91c9e36ba27ef70fa0fb79b32969f395111ae96ebc0f9568e5994aa5eba2f9dfed17b97db543ec59da8af789d70f7524d9c42bda42dd7e195b22920216213a2bf38feb8a64b6eceb651df7bf01722e2b24ecdc9c252de976b656c1a212014d8710bb148f17c96a5199d56610104900b3ad9197e57829bfbfdbf943c96cb16238df8e47a1a8824d6a626a75bab744a8f3e45af4b90a3335504b239ff532eb8d3da03bd20a03eefec9cef337b9c998f5167aa1d4d621d5d8006aa440b098949add14cd2df38b091c5084fce00bb985d47bf5d389b603e822488176977388ddcab46df1c5e5f31ac41c457765cfe86609d0b6698be0637073bce8425ef6f2950d91e7326cc4fc6c009d7f4085e68b8c73b3bc8331669c522ccc5fe0556a46c820cbee34b192606306befc5f706d1e5a922357280d714bcdd4966e97e7c106d0b4da47f2697e08669069db61c7e2743c607fb1330063925ca0ffc30024edf3e9c87b44a8353c7a561548c7d876130bb0b6df4f87c122d3745bebf3c94de4668c96d2e82858b04f0ded4b7a996ae14b498cefa71e5df3fac8bcb2929144287045aaccf034e4cbcc431a3cd0c126df197afe006905206601476f399a7a017d485ed6f66f2ae79ab5253ea54c293199ca7d7026818dfe8040fa3a607b25d090f87fda3285c70c9db685e5d8cad18764db678e80af93a981cb279f33b45a9ee04da17a82b678229e5d89951613593a1e63eec42142a8dc21ae6ad83e1d1ea6413cc3a190cb4bf4364b3053281123978ee436ac4fa73a5f56defb0bc8a182f780761c2013e3d26d14cd803d9dadd1d128525416788524eac4e87453341b88f7f26b256a240fc83e5081229d7475b5ca0e6bd6beec52937900ac359dbdcfb395107179a757bf0ae3ce51b620565eff935d1d201912577ea19f6d4a6bcf06a29858fa3393b07e4693a08d39209b4bc00d4df85a8019ac4e46cd46143284692ad061cf8995117cb924668cec26c2c48d7dc0e13e170ec429f63ef76323573656888ca29c27b99628256e721027a8f6ffe47d5f717f7b8ca394c4276bc9e6ac8adf21bd0c4e874797f42ef8b25cf006fbf5beb325ed0d40fb7d06bca809a2067ae91961e0c9dfa704e396aa76944972f8a3b8353b43825baab7309ac9aea2a7d18095a398ead30344cf61b1d161f36789fad26f27fa98e72461fc4d3f2e4aa8635a4900b16695bcf7d522c6306d93684e0660a56c3b042c04d649220356e67e4d1b7449928c2214108012d5a40fcfd7996ad421f8384bf0b204176fb5b1393597d4d044970a1e26779d85cb334ccb073d5ac6dc1a63c3b238687149a9b4dafc04929f77cd146cdebaa5ed7287504d950f962162c4f5cb3f18935b993aeacce9a03d05d6e10e479d2821873a03e2cba429433d4da59ee2d7b6a32e0276b6b39ec7369aab906a08edc42f10279082204e09db6d5bae216b1072923e94e738d41d6add75272658ebc40e9ca9c079c90f2ff1779a408911fbdb31bc4abeee51543238c58a1ff5f185a4718bc85e1630a1a356ff15a2ef35621bd0146cf487ac23bdf26007c036484ebcb3b9c72b62f2f218a1b20c5a946c583562840802708cc0796280fbe52177d07114c872db8e7f4b4c24afa58a0ddd7ad5261fff9ccb89d1922b20e345df3ab2f0aa90692f3fa8a77ff7409f4154d4dff712389451c03477bedeada50deaed35f2039ff592dc5f4fa0fb88b7abadf707975c5d68e22ea314c45ed1a3a66595bf598132bc4c8776c1acbf8110490c892ec13f19be83acf423793797f99f8b467b7f2cf9115c4ad5dbf774c5c122bd140045a7b68c18f3045dff2e7211f5b0b6d9a69213443ab35cb4b8c712705395b0c6e59d4ad6e69c931b9f3cd6da9ee27b9f8eb77c76a358a3c757e4b88d9ba81149d9f5406a8a8aa3066e2df9247e5a4ac63e8ba49d5e5c61bb543f6235673627e1a7a742bb1bfffa01efda4f44423151418c997f3eeb75daade91b8479dda4da904f07f54466d83e179cd0387bb7be45a95ec6e0307c7cca2a438579eb1dbee586ca208e8c13ccea5ac048c2cb020c6527c72bf72848eb2bb8e6c16d7c7402338ccd9f0709228dee39ed2e710430bbd400f4c5a8dab2f4f02bc02da56c37504d664ba298c7b4d5e65ec21e1aaccda1f4446653bc735a749aea9b59dece929156c63b705b04b4cd4ab2816f7b85e9ecd2868b9458ee4fa066cb400a20ff99f301a4697b84ead674c5c5258f75c1af5d712fdfe0b7ac9ab4f90ea2690cb00aafba4c9964e3593d5be4d5e5f832b66ea00f4d3f87e28dd747c1c47b4f559e8bde81ae282d05c6dc9359c72bb31b5e6ce60048ab94cd0d2b4b13f5b1162823c5008b1c778b62c0489ccc9fb133f6e433c666bfa871a95967a4199f82632560620ab3cb17d4534deea6386e072b368bf68bc21ef35ad5fc5cef11255c08150405d52e7d448bc3f793a0f9f00907be4b2bc3e7245066aa1a7e5c8b0dbd715da4f78986bdd4647680055cdc9bf6ebb33478b64fc4b1e3c85af42ea74f7cc7e57b70124033f28bc6919b65bcf41f6ef44b8829f11a9103cdd258dcba75ed8dc84cabc899c8553f4779580a759435ef759789870f01204ad5af53b4be3739e1db9efe9ceb3eca4901fd7166edeffa380bdf7ca5924c039c345200c0f69a1ab1b21fba7b50a56cd704faf27eed4024c750788f0b714224647cbd334e9101bb9069611825998c11faa0ed99514aa4c186ea2fb96b5aeeb8f4242c009052c1668a12117b1dc253e26d47a1161ba7b245c7a3507d361c4cd9b7dd1d799ea6976727f103d7642b6e7855f8938de5ba67cd7804506d5953b8597f79800dc1a8149f09d7a31450f88632aad11b20cccc9601164f7e4c22ea423f22f12f97bc36ec13d7da92cd7e3ccd4ab8b8752e677bc3bad1c61f1fc078f1b967e267f72f9b5f0749a2af5f13403b54530284d51e4617271d7782932d13d8117a41016144e12754fe4ec21a69506daf57a34dff1e4272f12028114fa9869d2b1ae1bf93a3de55dfdde78b7de341a5f37c7531ab7c7077dd731b818a1e5d7fbb0d77c47818596d919063a75152a2723499c2036581967b7a591f5b0362b65406a623ee8e4f983d9f5fe464678071cd3d45dbcbb99aebef6bdd789323e79e50f04d35977bf0b7e82990d7e3ab1efc059a4336e0e144abedc2c216afb432a84e8dee476deb25d23c7eedcf2dce420a2c249c9213f664dd6a1ec3bafeac2c52fd423c5f3ae7789f0d5df7784dc3ad79177254a65ff98a7189b1a10d0ebd7da1688ecb6d83d339ee1c41fac83667ca2622e260a082d68b863f2b006448e4587fca2d5a9af68ecb6376c4154a14975d3a78020027068d8123bf7ec58c2fcc33fe5f5614aeb67755e2cb3dcc3d381c858e4dce9c5933ee222d2ea1d7e3bc47562dcf9a944aa2faf202e01e346dce2a91f5d6ecd519c9f793bffc178900c675ca2c1b2f24af51dc5d3b6ec9ced013527f85116f8c3f8cb8138f8458cd3f4df321ac9a7e7c21d823d74e26971311b66b26a672100fdadf4a219461a512aa70a07bd4b38dc60bfb349c98e03499f9d4393ed476eb2abefddb41065c3c8bc766fea6a99effa288c406acafe10fab081963944509de34b0d98651033695b4fd6c9d4859f9e119c2e4d5df9a6d65fe598aaef60265ee5fc1e7634b9f6990253e5bb510f3f4b0fcdee7de4ccf674a912fd98036306ef39ad425ddb53b41fefe04f9fcc0c0190b07309ef9ac82b4d72a4215368c1f4403cae681f5263fc850caaaa8f1a115a9d1dfed5125d2486fd2c0c1e873f4dcafbd778cd6042f20866d9802e558ce329fec0791bc51917ce38c0d330ceae946ea25324a9e173dc7a653423818c67d6e7b1c653d7c302be685b7943726ab4a5cfdde6005f4687de0c11b9fd5a76fde23fca7934bf4a18515d07209f853d29d0b382e54bf9800007453559011253a15f7f9bfeb1ac86ec0ef66e26c4e2d354943b4b88ff52a5c5562a038560ea3763fd0e50ebacad965cf4be3b5719edf28f554d7a5d4de4efd99bb906d8155aa780f91098410ebc34bcc26c9e2ad52657748105dd37a5c26aff0297e6041dbf863ac5ac37095222b856cf787b41d18b2e6ff5b146ba9a7f1c95d5413760ea793317847207f9d6d91a1ef3f7ba63e3c22d7b8958c2afcf55f927d3031ce18f963b88994f2dea10018786bdd10c0839860f331afc0d54189f7b5a322cc879e6ce2d91c6c49a5b6dcd1e4f182f6f6d8981e6d70f50518d90a8487538f09ad8a3f0e265d7ffcce701c83f10798f1d6f0912f970ba35cfa5b1f40c54fe49aac65acbca727563e52f37ee77c8bdb261c4b86f00790337e7b4cafbe10a7d008d2b4a3df05470c72c870ec85c0015f799a9731fcfb3a7c2a8be44124346f7027599b024234511c2acac0ee021bd75b79d6230f0914a2824129937369b9f4eece2e06f82068f39d5adc32aad59e58630c488aa0ed09c32b0aa625289d0be34ba7ea66d7ef5ff9e3871f429c689069df33c77a474727d77e650658d584100676296acdf4d255bfd06574e9810445dd8f37ea76ccfcaf677c0a5469ccc707967126e4a6a5877ea9155ffee07d32b25120dade02f39cddbd4df9dd576659ac5830467a2f75bf4126d23819d35bbb942c482a94601eddbe6afc75c0389425c8c7f85262fd9021bc41e9361b2598cf4633e9931faa95aefe7afc49409987786f52820224801e38182bb8b79c3750b2e670210878f645b847ed5718a4bdbb3b569a10e4e92a9d9a94921073daacfbc94704ac789d32ae7fd51db8a2ca881443b709481ffc4651a953053faf3e2968aa4303bf212bf0d86cab7c980a24899d814ddb17eb7134e664a7372d41f4eafb376e235fbf6d2878902b9bcbfa32e8f45b03afde9bf876dd95d29f0f84172d93bdeb35fc74953521381d0f80fa96432bf9192fd065f025672178c5acb53c633f1fd43d8cbc6a2c089dd79a75f0a2a32712802e2648e39460353c1b383979c1be29de8a60e814bcb59e6bb9348831182a8767","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
