<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"754d8fc76699713d1f5a8aaf9ffe540861bdd1ff3ef3f79a2428675d37edf48a4d4c93bba1b72bdecfc1fd2fecbe3fa10146ca6893908b28785c37e17f5c2772b3808785e9fd28b8ca29a3a06863e9d6f20a20bbbb167f74fb2f04d6c24d44103a8c1a42ba0aeb9f84dc619e7d070bfd7ffa975a67bb07e251c43ee6b587fa637f167ab7b19e3dba51289d505ef94d6e8fecbce2a2fbc52d8a3cbac4899a36917096b3da0d73349e18b52e8d752d03a557985949064bcec9312c4a701353b357a493d63cf0cff06d68080598ccca2b9eec78acf3181cfccbb42058c2f4955b6add7482f2d958c157ed9d110e901dde522e9934546127173f9e663f23869d63fa71a344a03dff7ed2ea916a2637ff05bc890d5f54a79bf8d24aa1fb8ee5d80d37d541681953f3791285584b60e6f06fa0dff2cd7c4f4a6b52c06cbaa605c1fe5e832a93673c9830c44395d53886dabbe8b4e181641653f8a907b8269b0c9cd3adfbd9cbc2d349575475924d3b6e550e4b63d15751605869acb0ce86dc3d5aa512eb73410f35959c4b456421ffd717d47ee0be128a60191005583000d6577271a247efae55a745ff36a6bf3c38e777af3d44cbc5d45774d749c017a85766ae1acf64a965b72fe229b7ab4f9a423dc864b912c628540c888f29340be58ecd9224708a3a2359517decea55aa7f2b7673ab4099d2186a9b4e2800e4f8113ae924747e1d869e70e70f27840ecbc2b451128f36ee6de00f0494e6d12e527c537b42bc41bf996c21bc8f5dc775a79abe3aebb8f555b8699f0e39a93cac21a2cfdd574bff4819e9cc150d53bf803845f50e818a977e4db4d824df549bef312d0e85b4fc205c550b9554f819a6b9b2efcc86f07952ffdbfa4fc100b99897ab72eabd2b9b3b5a7d98338deae646be017243712de5bb0fb97b91b4e8bbc90c91188a4516e700aeac98e2df2a34c9cfbf9a43b567400cdefe011b18b8c829bb1975e7f3ea711bf728619e0aec9347a8dd0c313aa8a3f1fff05a39abedc519d68dce892f06e79c6071845bc9e21dad4a98cc43ad9b15ca551b2112c6757f529c0458c09760cd7f5740837033daa493d15438bf6a33cf09a418231cb6c4bb3d680a8883c873026a0969a552ab14b81200c2b7c521961858ac06ca3ee22760024c2278916229e4c7c4f4faa9f503cbbf84e209c89c4c844a258d7d6e78553098807e9a15dc0cdf24f5743d63dbdbf50c9f33e630b24ebd5071fb964a9b30561a982e60c7d7e541814f470d0430522b94332cffb7eb9412ec719ce5a191fb04d9f6a7744106d7cb82f1b37a82b2d69319bcd1aa59ab4549e8d9ad1e2135741343acd91ee7d4cfb8d3d55675f12ddb03e7cf657177b7de96956e8e51e3be8fbcc1acaaba19dc7c147d31098b6c7b61c938aa0798e546363564135b56b1bf78760c7ec90d30243741a153ee6d16dc666f0ef8a70e44fd57b6a9c95bf35991f43f791626c78ed79c1bec9a7494edd03893f764946e19c85f404116dead6ab2fe230f9abe26c4f0f1bd6a54328ba8f8475f0ea0931343fde05ac34de0f4d91fbdaad0e8e32ab1b1c46c1ef3883458bc96f24e989f2073f56b2dfcf0b5af894ad23d6b0a37bbf252145d0e8194b17ac6cfc09f5b34f18e2717d42afe599feb7801412e075ed16a5ae3742694b721b687fbcfecf0d1486050e6de9636fcffd796f67c5be484371460b6c81cf7cb62a6c3f82af1edeaaa27c2084864ee232a47824d3d8ee0e7ad9b63b4f025246ec21ca681cd9560cc57a7fbbe02b770552f045e920f5033636183d7501a2b3f6fda5db90c7717c9706ca432eef4e28feae9350e311829160fecbdbccc8788158ab9a549e346b0e1a5da2598f91b14818d6402ccf3d2cca4431c3a549b3184bbb73edf7a3a122e0a0e826a2a2e07d74638a98cd4234eb48501340c811e90efd68ab87dc1de0cb5e591a4ac424f40e5902c4ffe7515ce05f79427409b99fd95f88c8512c6d0e37ef10ecfc4b2b8f433e14d6d9485bdcd2bcb852ca94afa8068f39da67152fb6bf53a31df5b08367ee318913d3d8189eb217f0b492a86817a5c056a4a01268eb159a8b0684051b95c8cf607cbfaf0ce00f2f8fb7738b2e24be8da1e8a958cd12d9d37015de4312245778fd5437ed799b48281aede6580cd100cdf7a25cfe8536f614682cfcd0e98a60c300b22e6bbf15145c8d0136780d605a1179a0bd48591c9ee95673f3fe324ebb16a976aa8fdf7c513023e10ec539cf07ed5b9b034a1ace9fa686ebb3c89a644327a50ed46855ff8f5134a4b9b76a732eb1444e0114f0431a40b92d3133fe5fdd04fb30aef98cd5f0141cebea9e44e6d93d68b3ab910782c7d581222ef8c578b04b05dc333d4a318724364d6a4a72fc017535ac719e1e13d35d351fa282b0bdfaa1d1dcfa9f0b06b9e658343761093f586e440601e7c7b05d7c3ae72787d6cc91d6e7dcfec769268747202ba61d921e3bc3e377184032207a3c7a31b66015b307f0f74a5aa6b400d5966ffb5ab5d1e1ff07d4041b1a8fa2ee58cd752302c21f7f20e4964c5a6a3a3e2112cabbd5cbf6284f3f0984349555f4e8c0439b875f7b8dfd20161edf77c41dc7f813a0a27e33b9e8bb1dd89644ae649408e1150f4a653cedf0b10777463ca62b437417629fc2bcfe27c768e6b966e6acc897bb5b609c771144b6198995be583504d062d2be3be0880bdb493f20a0f799f54899ba22d569695e9c2ad74abd76742a125fa30dc48a7fdb6d5d626b19e8fd233fe4915ff22c619cd33316445e4d8c85958473fea6701f6440f71fe453b64cc7b0b25e4703c24468569ca45c721bb1ffdb1f61cbd0d17a78fdb019929766d286077acaeabda893ec2e8254afa6d43cb1c39f3f8fa67f049303cfecaf1728c13d45e8f438d02d298b6e154f1f8bfb5f861de4fa61a5bf411af7d94286a6d5c9fc1321b56a7d7635e93a3b9a35111378fc93d78b0d76c99f8403696e319393a5f049cbb84a15d982e4979f92a3b0d4bcdb73ea7090864400d70ac2e16a5da684e9d03b6f414b0080ea023ab17037c0d3a6878f5a0b96a6c17541bc5a10a3b4e3dc4ea7735e2e8a8867309a4ff67934dbfcf216ac7029687b993daf7c3bef98ef68ff42e367685827b04912f741b1c09a4070b797eef8b39d3a0d5a506eafabfeaa878e673c679cba2938172e089483a72981279ad2dca3a22e9b3e89aade6993bf908cf3cc94015f2f859dba240a010a389403ae747395e7d266e1e52ae5d5abf51f1eda14deb741cff432c1742c199a8f95b48c7728643dc5db7f93d49a08be42386742c8d624b8e5a86e33fe4d9d9edbafd509431267aca39e921c2b56f478dee8645753b9343eac4840d534bf07f4eae5a2c05072546909cdb45e4c3dfe23234978f4c5055502776147443874f019c965f3cbe80cf1b80ddfa8d9fa1c09a9feabfddd843d50284b9b41752cad5d1214ddcced5c97b7ba87abe7246ae120d819f471e0111d87d69bdc0d6816a4b0355193f6b60c13395eeb78edb5598c2bf9e572fa70693ca580638d164d4d411bbb9aee9d7aea02dcbd75de0385f688571a667b69471cdb691109303d2c0842131dfbc6c45b28d54ad246605b3e4e9f91b454ccc2fb6f26bfbb2ba13f6e5f40d4b4d5091b4b34ccd83020aefedcaf534dbe6233ef4d105cdf4bcb3a9350476adae10b6eadfb5dd1a178b71fee977afcae77aaa376a4a3cc86ab1dde89b0508bd935c344b151d6db0ef4cfaf2b2650de9cf6f72215cb4637d33b2376461552909aa3e81feadc0e1280382f3a4e905235bb52c497a9d861c23aa2f2dcfb09cb79936d7ac621dfc878005d91d19c1644f6ab074b0885111b503f5c0d9b7dcd7b1272b64287d789be3caa90e33143b04a17362cef51f80ca4c90b23dc958ef17ce06b2988b8a5d14f28ec8d0b1fc55e042710f48fefaf2ba5291b814f02681e067269decd54078e966b6adaa47ff579b17e3fd5dc19b0551e3a15c5af3c23ed0a479b6658381daea3bcc667b6f2abe5b1dabdd3cfa0f139d40216680a1e62d9e25bceda81fb6c7803ca5f62bc5019fe3275192547a4ab5896bac0f776ff2b58af1f71064e98f6954dde1cfa76f1f77fee7e5fbb66fe07bb0e3cd01a4f6244cfd2ba39b78c06cdac8e301b5d6880e22b37c25eabc4662815097d8d5336cff6742e1b7c39ef3ea5b2659d4d3090e839d92b70736a784faf8dbd5bf9f64887d6aed2444a97ad171309e913a9ff5965c85980e68835943b8174f565f1595527db872f5578ea1ad1853ab60b463fc4527f8a7720597ddf9c8f9660201b71b8aa62211c9bafad0a0507e0d0bbfdc0bd0b052938e454a5ed4fbef6a208dc05ad300c19937478bf5579c6d225069750dfb0f3a57c6a8a1c99f862372f86c20108c80c79fb0d9ae11190a3574f68441a357c9f6cdca14f9ce5e1b82a084b73c46c1c0a6b246963bd698a58c0d344da3a7d38a37cf7f7b95711c153f782a1ebe20f6222d635f933df878bea161b93db5229455922de1cc4e99d178431d99db6d4381fc5482e1e4914811380aa85f2f6a5a32c49b4508ebd6a6115dec71f33db53a925edb9fa6627bbca630ab644c7526eebae922876080fd6f9f12b8a79944e12df0a0d5c5dca9ab1bc11e2c90cccb1020ff0450a0aeb2ea21c940aae4c98b93ca041ddf5d35357f9391e14d4a8989366743456528521b379e1cae56ea363f1a7880f3e7578a5ab6c035ad314f0b1217eaa1a7edd5f335bc07cd68334d0653e5fac90af9ebde5f05ed4155da9bde5d4e5fac9dd6cdb4932c1cd313dd5c7c1792bbddfd30c31fcb5f727b9a3210937b8a8988a823a7e570c661acd6d12651bf19ac9ae7afe6ff5c4b7e48276953889ab7869d7fa87cf3962f3a6b26deb843dcb4ce0a3d03c85e90beb4ea0c87a5f82ada9f90eb6651ce4f28bb493dccca0d4e76228fa39452d08f7dddf1797dab6d07ec309df6ada3495dcfd3e486cbb1c48a391a0289c9fb8ed839a890eb40e73fb39a55d1a15e7a00f4fdff2dbe69dbaa353cefbb790fc9730b5d597aaede87ea62528c9219c65de51c40bd02cdc37319d567afd8acb3354d7622ffa23fc823ab7442e157afbb762445eb2a8bcf773179fe38cb94c23476e5aaac05bd9590bafb6bc4348eafb7ab470613236e7116a610641a29da05dbafd8430480d1cca7a40c69187439ddffdcbef3f41aa155826755c6d9d08506cd8d0443db83babc8f8385b9247aca9da4d70581de526c7319deb9b31ca90307106603170d217b375803ea8f140da987c2b8371dae59ef5d6d2e5283c6ab652ec0ad48699707103259912928924071a034891cfc96d2b5103b061f20ec1a2a1693e0598c83a2d2f68cc9381bd4a4e1e6e3719d2997527c7667219f8b58a094a2d4423627936ff4a710f1ae3446735568cae23dc2457817aed90914b6d483e36de2fac89ab229eb62615e5773ea119370f258c4cc0b716e2fd96cae33c5857b1d086a49642308bff7a48ca3c7def17d7ef4f851425f6aff1b78633525d226ca85a744b3256b5e3cd3c4d8ff4d705292516a772b4a2c1ec17254f9cbd67d9b0abc8a0e74bd418c72ac0d279d2947111f06a6fdc78cbf4bb9eb8befb7b2b785c08993dc3c182890a52771cf74ec9012655f9aeb1119dbb8d17d411b83a84edee6a736c923917d7f21fe5a8418c05a202239fb50ee983fc6d5f858fdebf417dc50e332627182267437042fec43f5d5ebb8a78d50cadbf388d681410cf5ee3baa44593dbfb846392a27ac0395419abaa2cde34cdb3544bdce90462132e0917ebd8875cf38b00c7e0c3abbea55f2c6051e7e2dfa7d19230a5a710db4945093924c6ef7374b1012db96d70f3186692200eafee6cda1ca328d2da0c20ae64b4159d58c8a9bd96975d85811fd0130188cde70bed54de50bfb6ae15c95c44cb50e09a5f8067461ff310c47ed4c03789b028d3bdc329f47956f032e9729b79c59cdfe860240f4bb5320398b24ebbbac004c9f0f23659bcca3ac79dcf7861f19545718c491acdb3779699afaa163512f015f14dc85dcd35f9a6f7b0597a0aca6a3162981c48b197bd664d987b638d7c783f6b3aa4b52e5bdb34de43d56797bd4c4a1ca28db754483c70e664ca57a9c8afc34c60e3fc426c3494b01074cb5e2ebbe4519c09532243a6192748a017742ba9978843f9cbe3d0428ad490454ed3c00e990d372f1de55d4b89bd5ad19eae9be64c0ef6ee8be1b43389e2727fc07bc858cd1916952d227bab8b8f4d63dc92aee508043837911d1826d8e5013b0a309f5a1f694a02a04f9dfe0b4bf16854391e8ba9cf25c6e8b40f0316d1ae200e7dd632e9a90ea1d8dded3c4af2ac1f69be317787d214edc30a5d06d1871f71d692206011a1ec3e7c6c2c73886ee1735e85702394bb93070994d022117339af833179cba2111622025f2a2616861cf3dab8d6106fd373a60b68234290fab87e4fc08d3aff059aa857d15e3f6261981360fc628b703f03a0dc032a9ff98e4b87fe2b7d3406a7dfa5606c70edf16cc145b62b08a1a6c2e4203c8877d5d03a5d4f92f000ac5a58eefa11ff7acdce173ffae996b95705cd709951e9ca8bfe37d5f23c5f125617dc2f2ec986a8ab788aeae8bd99cfc08206eff1690173ffb7b403fbcdbd08efb6b975cb811e493eea7869600ea033383e5adc05fb11113c87bbfddd0a94b75031aea70ff0add09671658223becd190600287b5b1a800702a6b9c0ca711d7f2565854fb87008886155b362ff6c4f9d8f82a5b9261f7f14a34974ed7cfde58828558ed5504033254eaaede634eda7f7dde3c2709f7ef72981be946f9b215a5b9565437c95e52e1caa7c21a08a73b9455796b570be38231a49f03ddfa752ef0cd03d3f95c2a8ed6810c53c6a1975e2eae2631a4c9ad9820feecd38794937cbc54d521faf79e976b787433ae07a26564b437a54f9774f8b30f5fcf0e24c9f194a50bd48f7f9e87aea133362be5f1237935b203766494f2f87ebe31cb063c58ba1d035d35a9ffc0acd2b330d641031ff95075573283c5f04cae6400d26335c283782500e81869b4ede0ea5e07e90f38d928c4aad804d0801c91ae7c7f8320a5dc2d09207ddff55b4775258533139a16253684290b85a38275fb51e309baa9ed0f0df6cb52171a9a02b34f05c820b5398497518c6d925108858287d6c001203e06185822f945c2af6847c856a2b8ab8b6e5a73f3720aac4d99439813c056e390f6b77327e1cc6d011bda7014b645cd66846dd25a35454d03a88b82c9cfd68f9e1ebc344c98820b4e365750bf918d7a7b3e6b39be7d0f1756d35280b171966497de50c731703cd055401863820c6628ac6d91f390ce36394387ef75bfa0cd8f8f96ed0a33b477c8e1889458f79a51ed446654d1c9b5e0d34f61c000476cfb4b05ff64b5895da6d0211381be0977628e815fff05cc36638ec1eb31f4be3aff4b6289bab85a4849b3e87803c8d2c5c9af1217417948517df53881b1142d366eff84d61430bc49b0250ff65d9ab3969f9bdb7016027ceca43394f3e0891f2672c5a08ba8002e05c02218d77e470902f73cd6f1da86840d59ef5a464d29062d5472a7f51142b1e6b0cad04b67fdd7526b43e9bf8b41c0fa86aa6b77d64d4fd258cdc6771b34dae63fd99a6963ea5bfcfd4af385ecf872d52291813eb90fab342e23d65d3d090a4d17db46f1f0f66d3a8473261b046ff9dac7929f3c5586363f0159701a7945e5c41ffa9fb21a75530898e7f2fed9ac790e8c2c53f17e1dab68e24b8f843c7cdd14680155c6b1361cca1495eb1f18a86ec8870c8c982c6b1bb135aa31c15136b44c3a2fbe1fed3c0252c756cb0321b2d974064ef0f91a7c499178cb6799c2f4a8fde381036fbd665b8cfba545130e50231e1ea91a0677ba2e358dbe22f0c35d84356e2b634bad3150d7ada07bc8ba0e0d23d3ffa9ea2fa2b90d244e9a69ba42b99c0acb6612806cc74e3843bd02cc3c581bb1b2e436ee29bd46b61ceffef757a6b3e2ca4dffe20c1a6578e6010dcc9fb2c54f9ae80c1e03e864f7a1c9754f7985b006cfe7daf16fd3b421683f6db4a95530ab9bfa8692a1d5c735f0d42c10acd8e1be81101f31561ef51a5037eb8a6121b627b46bf6f0ea6304456afc713496d3ef360b5ac2cfe03af6a6be6b37ad6b1154310327e10fcfad8a90f411dd3ce0949d9589ab490cfe80a6aa1f66030e9647eb09d47d8811d83e186cabeb206c60ad1178f0a56eddeb50c3ea000b8ccc52551a413abae1685477c1c8965bd92ef7be82c73004ab54ff1af12fc1126dd01a8ae21e6750a180f9bd11698102dec54d1ccaed05c6d5d44efca0f75e00dff675e9f49dd6e7de08135330cfa7248e455cd1ce88ae7c5e30b5f89f110f29a9b679c87572a3301bbd16064e72ace64c7487f310cb80bea5c6e6ce79b4e55d66419e08f274e2dc4b46d4daced21570fd2691feff0620a7fd2b691cfd9e46fa733d6b5eb317b1d25edbb77d5f2b6433eb6e59d1f08838339fb7bc0d07feb9bc404e801d5fc1a17ca48baf81a2af777f7913db37345abadd93baba9995370a6913cea2fda44902b687fcfe985880ff10e5b2bbf1716763a24df5c86990c620b7319b59dbd167accef9e31688a446a3cf4ba8a594cdda39994e70daed39ecf578df971159f3322e3a7b1ca6600ea57e05711eda28f1a20f20ba91272751269566309660224a7ee384dc3a2fda425d2c6b408db06fcca22bfa5a0aef04e93becf793f8b280a872d99c2866e777d368d1f2243cd921cc86e01313dc82e4c3f34b334aa2780d4c0df3007764ad4e4a88c0d0465b8cd4ac96b8564043d3eec5e22ce82ef4378687cd34c705d7230b3ea2368dfcbf151feec6cf9d9c6a788b729bbeafbea7754389d3fb6f4c488beee80421c711d9b3a809f8a7aa4114c74357794617b96dcbb02f60878a3c2a3ce6c6b79b00fb83dc0453b7ec067fd802fe1e394821ca56fae1da1c0dc7171734f2ea2bd28d19907641f81983403cdfe1b74961ea84e4505a9095f7068fbba5369b297917848fd982db531d68fc2581088752bf1933cc9f0f5223aa31fece413febcb3fefadb6fb454e677991fdc3d7d19f22d43d71bdd1b133646cd935dc502f373631e65dddd22c114864a83a984769a4a95737776f5a48dd1e5b438fbefebbd1bbe5e4ce50fa5e1e85c184f12e6ae459b903b4ee7fec7d0dda132e8da9fa568eb0525bff9529fcb3cf18187422138a182104c82dcdc24f2e17909f7666c1758e2629d41b56cc5f4b8c57a48c71f1d425ee0de2a96303e9c78d930cf4514b028eaf2dcd783801e7eb69bb956e5f6fd69bb76416d6b26b2d20ffc23502fd248124407215bc66ae79bf2dd9227d0985b57035d68f92821a5c8736acf5317b387550ddd16d5e02afbdb71629ab5f65beb123602328bb0e93295b2006f812486c3c7e0cfc526555739bd0963f4260b8e72a28b65e78712df5ea24389ec8fe82ebbfd7749c090e936bb87fc42a477ec28753bd7e2c0c4abb442a3a7ce24295ccbd8bd856c45ba5efae55ba7bc4d4b352d2f1996761bc922cc6ad0a36035ef2ef8238c77d9b1a0d7a9395d75a405d8546ed52505d924ed9a177b74fb2f61a44cac1a7e8d5d6fc60b2823641d747cdd728c69450e1617a434ff2976ce4d57233bc98fd13a38f9ea7778cb68a5a48c762e699cdd82fa2a4373b1f01df8e5165bae13bc972f5741420cf2dfdf0e7474e0082c952c093ca401862cbc6a3edf329812f4762a324df6c6a59e0b1e2fdee285f2c59b918ff34276669ed16f30e951ef7b33cbd7df5bed2f18a575f73a9ccf5067d856b47d0dc549165fd57e9deaf8b062cef289678845e2a95bed5aa5cefd8a5d11c3c0dc717bc83f73247e8e34f8d014e059b8420052cfe0b967d1e7eabbf79e666a2ff7845f78dd95ed081c490a573788b70425781af52a20c3e18aff23909e3461c841312cac8b5ea8fb62a44aa77987477e73b7b77cb6dc098e55a8efb27053ee426d62c51390ee75dc192c7cfe1666ef05dce5060c006db60c664ddd809563d133ce183448ab0ceccfa0c85835345e2d7709473ee25113ccbd66680abeb292ac8fb481e8cdfcc9f531ac5f6e13e7f78240f924a973a467bd077ac98eb7d028a842ff7cc556805100aa03493d19c0306bd01cd8a964f0e217dd03a4d934a10d3ddacc5c8508ae7d4dd7c560fed83ffe35d76ef9f22701f4626a3c67944e8f0f68206ce50b5ac8a1a5f3d6ef23d21416f8fd20652e829855006e1252a73bf93b03c1b25a5f116994c19f4f876a6e5f841536fa6fbe550d6c132e8fb077f5e1e5ed28714f3b04af4f0510d19093079f8fcca1b8b17d95bbccb09f668f77295624e42707161154595e6b40afcba0ed250bab0ff15167104a124a8e18536e41c22ecb62d1dd533014980662da4ebda88542cdcf8a413870ef6c1564224ad669742e18731107277336e2ddf6c7f84ccbc4f8fd6ae21a8ea43f4cc079387432fcefbdd050fecde1bd8583cf00a76aca973954fa14646637b0e66199946442a2694819175353c0893e66153229c4461104198b35664d67a0f268cc71847968e3e1c690ddb9080898ee36ae0d97ff60ca8d6b692c8eaeba2d771002e25be7a695849e26393b10202fa2806de97c819aa0c4520360498f7002296b64bd8d2509f7d2560af00870058ead1fac708a7420b831c726da9d51dd2e20331eefda7f387f5198458a7fd6ae4aec04c72525891ce6f9fbd31535152eb98f3983a6fe4761322120b8c35cf3a2f8bc85b48a1c718f3f0c900df303a2b25c14ee7746c30561803f3c1d5e7cd6b42ccdd32fdda36c8d76f20f38864402d3d1ea4c3016767bcc42d7381cc6e583b5e043434217e21c03d005dfdcfcb92f49e1cb67bbf11fab4e1a840f9b0be634699d8c4c5fdf2c540d5809b5060cf0854397773bfa5eb2b3bb7652936532a4ddf232078c71cd3651c84808fb7950e0ae745fe9baa1dc47c621dcc2c7907d683051b472adfd9a24635304a0fe26b6d0034b769ec551490ef124a5b09f255f9fb92e89dcd31018df8f5334f75aad579e047fd1101b0e1b16d7e385aec656ec7fe0ef3cb140bc9f2191650e4eedabc0514b24841e468c7494a8bd85e011fdc8b7ae5458be6ece3d3586f871c6f16967ef5e26d497e318ad514d785ec94b6f175bb192179f5fd7f8b0fdcf6e1c8dd9d9f87bd2d8e55b075397b46db0a688f250342f4ae3037c68a977820609dacbfed745ae0619f56fdb48eedf4144c8498a15aaac9092cdaf5cc811efe8c2f0cb599f7dd23c3453d4c581216fab564f008ac98ff10045b122525837e2a62a3b9d5eebb96097185b7a27b66f1848f7e3fbb81ff366dba96d377d77bea443b04ce579578c74ef52c483667158f1400811b513c2d7e92a00607b1e71c9ba9baa5d2b9a67b23deeb4d8e97a44d4be67ea926dfccb6c031c5f8e794d77f0a87e8ae438217f8a965023dfac5e15865caecb3077750858cfce9c2dc117ae9a1a249c58e28f97c8d9bd2783b803215b1b7ec8ea375c5fa3a7739a267da4b601d13d99073d699fbbeddd5166aa82696b98a46eacb9baf068c3616909db092deda00fbfa7d42c4224dfd46833764d77adbaba98cd83c598dd659342eb4c4fb8b403ff576188517da504a40a25b778343c37b1d4d5a496c210864f82c114bebb9e9361e23cf3e925d61926c54b2bce73e786d19a035e094874b2bfb8819bd4209a4216d4de5644909d02a9be4bdcc718b7459e411ab55fa8efe59a8a9909b574115f14ed15606d07baec067b5f1453afa1a4ec195cdd28725d5cedc917ef846385b90c2b97d602a4173e72f531093e2626bafb855cd13caca4f50f9484e9acebb882576f87a8527c55e2b2cbc859dd3d73e75d88b6e9adb3bbb80e7aebbdbb66a6e5693aa694779f384bcdd9238c98ff0a98a9d1144aea67a429dd73332cc0e8bdeda6cc3de1fc5f4338998cb8ff0b21fece1aab8e15b441d2a07f34d151259ed0d42a5e906071ca79a32e2b03723d5174003e80fa85b575bfe52b177c9847339dfdf29047201c3eb3f6af7216d1ebe6830185eb9ccc65fd957e75613557aac777c54b9eaeeed538acae3af72efd7f24b637ff6154e79aea966a9e38f8bdf9bb47ae322601156cacccc3220749da69af9831a8edeeae0c3f1bd1c8aed5eec5c3d73e4e2184dae51e035f061ba3c7e52f1c372a760e6e072d92705dc729a8f78548e7f60003d149bdf8b0d8b0c2423f9d08907e9d1e6f48791bea9e3ec436d8f85bbffa0af7243c4ad6e1ea1a7ace2389e2fe579bbdbed4d77765ff537cf1ef2fd3f516a8b7187149c44ccedb2deb1cd4d6fa4547fe175102a10ca6cfcb583b0655d738887fa78fe993a9f77b6cbff0c9577739511e6f11176026d54c9e2aa6117192c578eeb53bb77f1f0f124b7caa08e094a2950ec46ca68808fcab1d479576c313abedb8680d677edb18fba2c4fb3ad0688027ca6e0edbd653cc2e4acfb78716c760719e3073bd0f643680281d190cd8f4c0ee1078eacc93a9c334267b5cf5a3d4cd8b455dd52bc03fbc817a58059d285ab8de963428ac629ec792fe37d7c877405a7886e7c6845b18533e850f31076636f2a53226cf27dd8e0e62a802402e3323bbdec4272d88e71f5f4d6dae89d26447e15f9097b3e2b8f5bbc5b37f9d50f7c26b85f11806025ea5cc5b17cee95c74e9630947b8a0bf2a14de826bf0e6ebdba160f14792b7f3d387759351eba8a47adb63708e5af485830f528c87f934f571c50d7bc81d99dbbd9a78e357d4fe4dc7694a43a0ea47fb1a6d66eef8aa8c03d9706e9556594770f6372e94b2eb7add6697733ff0133e083d29632f47f141dda06919a3cf06c79d7cf1a3bc62ab92e4644c9bb2a89835354402c4a5731f3a22dffe686b7d13fa97f076a1a9249e74bd8f515377a6f94017398141989a67fbfbf086d5bfc9c04474fa1693a6459445cda6cddc251ee44b313ae27c8293814d43247e9134fc874600d9d0a52cc634cf25fe47da9e6863f89c76a3202fefe1b022f2dd999eba169bf949a36e33bffa221714b5102765755771774368464be2ad36808cc96ee62802802cdefaa98c2cf752ed9433313d3b24dd75fe069562a207e93b12b551cdf1fcc491a8b7b4e4808dabf76b3a05523c54f737f27c5a38abb562796479263e696b7f4020d1893feb8be7011fbd49f63daebaa9ce35af6254ab2adc94a5cc97c545e73ae6dbb3578f53f694f95b39b592d0b1018195dc0b2c41f99f3a879dbea8f6ee95a7dc62836527117f4a6ba7a2d4bdfa9aaacd9b7e1a0641c803a053399b4ffa8aec0f86d633e161141bb1a9e9f29a82e0b3ba412ae36fbda6f2693a77aafab01aba5ffd77466e6b44e44f91ecab1b4bcbab3d71011c90245b01b50ebad69d6179b3c6b2cc0e7ee0989691a1040e2e4c925b2bde226cc6b98ba1c200d219467e4d5d940f956caf2f5f17de970e4b11696de85645fd1ce4d661e3c10cb917c2673fd1f5ede05110c1b04f9a28b09c91ad692189b7984e00fd895ee36592729e3abc100fab2e9b0d29fc82faaca2e919b4d8d854fc80a3976b1cda6b890f9d8bc7645c3ae663a7d287f168023566e92f662e44e3014b60a415bf2e42e9b150cd035e2c57d2b2045e11c7b430e0861395b3762358a594fbd23afc6c7ef93281f5e9b8ead98829c9559472f6fe1e5c3799385ddde5c0bec06edd99d7dff0a0e9917149950cbc316fa13fa2a8ac8360ce26df0fcadc1e9427322fb9b93962446dc5f94626791f6f70327ec175ffaf085dfa6936fb189405f799a3e4f12f4c60a857805da3db4cd74bc09ce52d3b89097ce41d2e18c2c072452c2dae23ccc088effeb3bc05193683a62994a5ecc3a07d5f192dd73f6f98cdd9b7554214cf8a07ece38f5bd1b301bb176220ddd8537218d99d510aa25bcd552ebfd392b274cc52e87667e6723ec778446926d6e9d3b3b28c7f90787631fac9d793dee609efeeaf48043840bd2519ea636a9ccf3ca3771873dca50c8d1c13e34f201c34c4722a055463ac36ae633bbb49dea557fb1e5ad9263c0e569c034354b62db5585d29727e87f6b42983e593321d1138a1839d45683eafe2199d378c9b0961105e1a82c34b8e0a590ce8cfe3d25aa297f5c7d718d9b5c13d720451ad3225426f79049e8dd44a7e2e9c9a49b96f6a4da87d0bcbce442468cef1cbdfb35e7df53f683e55fa1c748eab573623eefc2e434fd90ba8e5120b9e86024b328c586037e1d54f5d6d5b91a946ff0ee8d7587bc879941c8c4b9f4d279fd4c3c27589086bb5cdfcc270b1e9f8b236ac361ac2f8dd48028f6adc4b3d4eadcd410d2587679cde22bbc62edc08ea435ba99e8bf7808028ef08f4ecf98ff2afb30079df37600912a9f94a1a4cdd1145006334aae696a22284e240ba252e3fdff71fe9ae0563534fdc560a8ba5982e0c0ea29835d0fc383d49bda178aaa40777599d397d124dbfc713cd0a671b037de305b430300b822d418714c631ee064ba9564d89f8dc10483169b0f09e436a3939168253e93f769e155169e7ca7e02c4936d6e153b66d3e4bfd9ca6436b976f329857f37f5409da24f021f4d42627365eb6318a02a0cb4feb6b143f62d631e9497860dd6686e525936c6bfc7eaa9dbf46923322109bcb746710921e9b3adfce3c280609f36a04470abb1510f765069425aedff7ef02dc129f49640e4c3b0fcd55a4bdad7b3773d57b223817c04478862ff4bc07c08311c5fb1fc2e846b9a033028fba3e10331642039bfb7306a01ffe844de1edc53e682404de5df312514c0c1c7a5b0afc3a6f6910734a1056aa059a9f91647743395cd2dacf43f0d1e0c432ffb2ffb2efa74370a6aee4b6c231c2560b807b25693260cb820af7afb28578bb585a85e6256c0c75e1e9c92631c080ab33b7fd27da74883ec840830f204f5cba0fbc8b42c6b0f31ed028d8e5f9061c0e1da999026b1417816e1df5c6138ea01c1a8bc806e1dbe388964beb5dc99c64f76a673183f577cd39899e752ad3e63dc8aaf34e1c53cca2889a2b95658dadab6d2235e0d837edf0da3c3be991c316532bbd980cb0d4cbcf6bd8aafbfdeb595f04909b0f009b003c56d8673240fd49b684a2717b937773724b9372792b1fd13faee0f944c7630675df8acf8711f00a350785363279c29c6e97d6b243e8b31078859b5b53587dbfd02ba6b63bd465568eb35f2cc4ef21386c24f5b9192624fe5db7434b80c3d1d7a5eb91c3433a81d8ca60cad7dd3634fa996b1e63d6b0ad408d9ce3bd1bd7c548b22adfb293bc9997f0ab7dd03809bcd18d2833a4aefe85a83f944a02a5bd996c4be691895b623f8e15e8f7ea0754b863724cad5f4da5124cd32e4fdfbfb58788dd149815cb6fdcc062b821cc8d5e5598004f24ac6f516bcf01d57aa448c6425fbf75bc96665801275cdc4ee3deed8e94d35a5715532ea92916a948c17f7f0f1d9d4c56fd0ea56961bde5ab67508c4c0febec85381060aa26e4fd87d2a534edab86beefc2ab5b47e033b1b89b71be132121fdb548ca9160f70d539f72a779b0d3d53c742af3683e886d9cb4f859c830b40089461c76164ed73cdf2751d9c21ae2d74b467eea93181b0b9fead600b926ec3743306417c5ca5ccbaf3c84b5cc18322c14d0507101f3a259b75fd9d6952bf20bbf1ca34b8075ba1411905bd74957fe13e6263eca0e7df127e107245e79433007f4091e406fa65724b2d075aecf9c8e8e081ab58392a5564b7116fdc30c3c515a8895dd057a9c18e685a4047db762c7f46a187fbeaecaad1d96845540f557b314779da401b551ca77665d832e396ce7e568d846e62c90a1333d93389e33066625bd5241763f7a392d258a4fa6efc6c862d34a768a402f280ec4182d90cbf0abeb4d2455745906493dc3d662fe573b9990f811af0fb4d7544558c8b44e1f8b69d851f8667f1254c689b1a6ca60e7eb80734095b75ed216af72f28ea78434b94b50df6243dbe48a061e9668bd739a7eea41f6b3daf0ad44a1969ba351b625aae3492dbf8aae4db4809e7762c21c08df897603bcad8b97cd9a9be7a81a38ba6dd85b3516b99cc3d87c18f5b37766624ebfcc906f75c4f4b22ae61012b5b4b4028c7e7fb7e9946b46fc4ee99d466cb4cf720f951a668360ed36580b3ab6f1363f4b1c861a09bd5f00233aa32cc346e38fdf5e9dd5c07d0484724b83b176912f545b0313de120162f83749992b0e302b9759e44e04c89e4d182fca7943ddab64005af223b5fc1de14b3df085b407a80814ca089bafc462613ff0d3ccb02ef2a6f99bbbeb0dc2e33d8628dcfc75bab8f525d9af465bac9f67e6c515eb0402651642f45f305fca5dfd6b1cc1c1b0c21a5795d5e13ad324e6138c5cdf5af4e0c00cc2bbdcc767ffa7045a0540f274b6b1b4e6112b4c0c3288b005dcb124dcf364914388a15d8b0e85100e389a3ff80d6206b8b409e1f849ea935d24a8b6ea8e3f24f0d5e4d4872c3a0d74d129d9487a6f7c5c3836b559bd4c59c4835aaf686101ab51af8cccd2f545627d41321f05572be6484699c455d6febd71b0436115d2fc5f21f7215b78c10fa18b4acb103f0926785f723527d5192a8173ec2c67d9686af055fa1963762d72d9992008e1e00eecc3bc976c22819b1010aa5d0db32edcb570c79597e81028c5888151b38b5fe265cca8080b84a1f03cdff6f9daf654b9c346ff1ee66dbd459ba7da3fcd81c59819fa8812a346fa781c05dc0d45b9f07044a6333a3e102de1584cccc315c1e5df835a5209275a86a9f2d4bbccaa860efdfc64a700aecff0b74c8563520e5784d599d2dd37ba3b9c287f799c86a2782cc1026bc859c5b5fa2d2d026a811f3139e478b27061f1e7cf80db3ec294965cd29405f3901ef295e50bf93abefbde01221c02c5cf45f5c40ca9a556b5efcd746205a2f22c2c0e8afeff5de20695c3f005b8c97fed908722905b58a871b1ebc5c53a1453b362f95db4adfd0683fa3b331934722c1592e355f54087015bd7240a6472cdb8a4bbbff2426893cc5dcd7346927d4efc634d741c9f2e15e83220e40ce7e39f72b5892d21c1bf9e08a8de2e4fb8d98812805dc716f268037231d13f0ec96428bfa81397f4c58866c5bf23f7f5cb9207a08f887224aee31fd6c7c41b450f54994459e52fdfc385e55d8ee152511b7322ff5f759c48ba8898ba84c9aafdfc872b76f25b7d9f97fa85c31e9907e4696a0b1c8cdc5ce9acb163ba023532b631fc0bf8fcbfd394b5f804a5c74630f4a97c24776d036424b0d2b899656a920b3e58f895ce3c146b6bc2c445012f849798c3f4cfce96965b3da87b77330cc759a1dc4766ab03199d450ba8e9a173840c4b721f6746c73cfc252677f1bd1f7a40badb44fa6311c9696e73652ae05d18b2e40bd1625a45d490a888dcaae0c3d67abae037ae3015be85a4d7b9a472e161cae4e3c697ca1903520f2d20e7b152ccbb2095a30813efcf028a17f941d2eec9ae3ffe31aed87695960d45fa76dce838738a3c81a14f1bef829372ded9b7fc553b8527ee8e9e53b1ec65496bbed8522ab671072e3300bed889edc7014a44a7c9e069751f74ff93067a4d7931caf2f78181e25eb1fa3477026d8eed85a8404d1a2beac1dca305bf35489dfc8eb4cbd2e060e675a06794a3f582161aed7586c1303ba0c4cb392a4b59e4105e47dadd6e466b48c3221878b7cc30fae751396ce7a98d879b73ee29d6140e15c2324dbee9b56727cb3dd36d02bb5c1e174364372b5cd8177e320773f440ab6fec758328c66f909f989acd80060b76fe09088a10d664f5e9d1ef4db01ac1e76d7c6b9ef3579b13a5905bf6100ab6f2fe53c73fb00ed2f63fa4015499f987f263bd2b46eeb18bc556abebb6354419c4670407d76f5d620e729b665d7b3a9fe63da07a41178394fe649ba7e1944d41e03f4642e0fe615fb89d52d715bb2fd45638298ba5","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
