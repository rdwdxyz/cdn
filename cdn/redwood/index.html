<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"8d144c33f1d394f94ab505570e25873795faa6014940fe9988d6f0243480607585069d9b8842e8f355c4a5fc2cc272a33aca24810460c8015e8263c7bee7c446906634ba1a808580c7847b870f4a22c831a4b8b1b01f5e842708eeb737f6c02bb054bbd6c99481aae1be2402a69f49d929915ebdc5367c85db3b0d796249f21a00df97044e11c3a816819dcab1256af8d091fd577e91ba30644289f69dd179e2db90d545f014984742563767231cb8a61572b1d4f3d91bc98d72c2c968ad4ef8afdf6167215c2215f3de53f64715b763a1ebca5ac6421ab4b212709f7a8f076caa4c1ba1235130001e7fafb4166649269fada8fd33bdfb32e712cbe3a6aee82bf1d31ddb3c791368280f4835b5e81b86a5898e31b873ea06bf4ec31d086372021e31eb0df0143c6756641c96f63cf09b413972c87f3921ff7f791e0b23f4bc4999bcf7b748a983f88be6d455aaefe5222806bffce107b2862f3aafbc73929fdcff990754f63881e1397faa3e388bb664540e8527b3120fc10292c14dc25da780e6130d34aca0fbedb716c39ec3940270744ccce098be5b6033df2ae24805fcc63f0a6538fa3e436b500c21957b70c96e3c09934397ee16a69823d95cd556db00bd5cc1101ec3e1cb30e5afd2303512d55ed6a29847b57ff816325487066396d26e3ca9104b6122a5754e9648ea3a031b03b901ddc1aeb34cbfc594575f321dc647c9e154046f746864df0c0b181dc372d4db8661c70dee0a59a68ae51f55a9bd3cc5c00aa88fbf334a9b83746a4ce1c37d81ec32be7ce35a0ee31f9a4947817d3cf5bdcb99e184f8c161a3d82395bace318467c12951c04e3a53039439c0baacb627f708288685f3811b9d9cb7dcc24e839cabfca8a5e8af6fa6773b8cbc808f97a5c973dcc6cec769f7566ddf3475d6f20fde6b24c68ddbb4cd26ed90b0aacc6627f866579fec7da292f792487e27de35e2cf78843054c30a89024d0e74866c3032c1a498b65167e2a95453b1d4c3cbf393372b693adb869d5b2d6353e7a3c1c1eea15382bb0d391c9a19d8fe9ff7c2ec36e95814b78a23984a98c6a051bef73e890edcdebfc0a7a1c3997eb942f6ec22438d8e17b2ed3305d793d66a83a15c5ac5368b0a50186bb2530147a5ad7b85771e929565151b8eadc92588b004b32cac6c1cc4bac08bd6cdb2c98d15747b7e54ee327db66a25093eb769df4b56a2bf0e128ae5f8ade952a0e18301a5646bbdfb537fce36de551cbe8884af8c1425a73e17e6662e22d425be2814a066b04830e0e584ec72f7272700f7825ce712d106e60b083c4c81011882924ec040c0b464aa626f77da14c8b23570b8f7b44f899ec1db9658fde77eafa328be17212806fc14301dfc439a5c798647906abdaa1ca03d31387daa12923e1c0c7a50f287359502e18805b861007197b886cdc673f304661b1fb41e05e1a53befa98a5d35fedfa2dd9255f2a8ef34314124499b3a78c29c25b9e58067efdfc64d55c5ea977677273f42f9c6d0371185463275a0ce452ef7dafabd557d485685cccff73a1e969ddeebe7a42e8b82cfbf9c4f7f21b11c2a0172e2826b7c8195b1b6ce9785a2151af7356e4665c088b747f25f171700ba52e6fa59267d9a8dc966b65772ec1e0d07fcc1c4fb29b4863b74c019caa223318d1b8692ade9891f2696177aaf53c6543c7ed60f7da2a68dd3df78d737fd14f452c5258ea420335541b3df9542b4200807d1ae6a861f1e035b5f13d38d0af4f54ff095dbda351da3a7ca8d379b54662dd3f09fb629091ac29394ec62ef939055fa0aad093965af95fc11fffada9e62007d3cdbfbf63815c283026d517fb63749b7db30c60f71df3cac2e130d0365f55e2f7467778b471d51f95bc5bd26088b7e4c482088352712b41443f06a61a8ce371a65fa873d68799e90a83b454e6e89f6d9c0788705ccac6e62981a26b5f737864bb49c12c08485e95eb8a4f7b367b831a17d998cbb20d3010810fcece07bf8976afd31815357ab2b2940c63d77a277063f7023352e42747a375a321634b77dc9c5f23535e745e1f2fe85119cc35c1a62ef5ef200e130aa074572ef0cd03148c80c93709c54bf5fe101f1f4dfde96cf99673f03fbb4e2579a9908eee214df08ff03ef8308500ec83b65f32a56b1e8d4a7e753eba23964b01027ea47c2ed9dc0042f1a4da459eeadaeec607344eb1c3a45b9573b4fa2090134affb880d7e71a50d72b38c1cfb9ac1a40f17e2040e623c0c4f07981df5d68b71dc97fb1d67bde0f1598fe9e246be3791f582ba41090c72d12662835dbb63d50df6be7b50fb1c5d16fd91a6fd4e0103849325e7a9380949313d9b5c0dc7cf46f5de798e59bebdf9f7df399a140f44eb2c698811294a96d38d6dee79c63bbb2cfdc52bb1b7d458c3b11027869872ba75a589dd105ddbd168b3e7f37e538faf331708fd02397a46ea34dacccf69e8b344b411f97091f8b0241e612fec75ea5c42d2e5cc731eafa69f0e3742718e58504e1277727645e1aa3d7f075f1add842b8fe7ce078a32035d571c352c2e1ca8112bf4a4858f56251324483eb1a048e290a032d5a9fcb33d48752532f47ca684dc138b46493e2d16c6edba468841fd6941b66df12adae7a9ee61e5529dc5cc31559279e4e0acf9a1e46924ceb648dd39e6343e20df33256caff5cb55b0b260ffa91104e9eb040f3a6dbda99cbc28d9e716639a817c23f6a6e799f6a98fdf185a7b38b081c28f2b8b5e85a6ec775ce0ee43e2a007e9264edd54441db89724872580e309fe019bcdb5dca10c81c6b616008974f9dd8ec64dffe7ce80bfc347e4b188167865dbcda52b49c12784563ac68903a37294fe4c37845a7ddad1110401c0450e8cd862351f8daf90f33f4cf7aeba3195a47112640d7e41d7f70261c733f4197fd95cc293125316fafe39b4ae2b780016591c440845d3d4c32d4e5b8b6e980fc6011969445a98e799675f10fe26995c819381a33c427fcd961f729bb3c13a7294f8b5953784a5a5631fc145a4a00f6e9d3d78a87cdf09cbfb9f60b5ae247851605639240906c8f665155f13865f2296dcaf0bf42b6507a7128381c616f3d71445201dc19fcd1c549e79a18da00fe259584ec99c10af695ab706f8f5b6804da8fe4d14c061ee83fe245ffafdf24c939ffa4f29c6aafdbafc1092edcde0edc6db9dfd71888fe8ff2c7069a7d399f1ab9533f7c310d9f1237987113b62da26e2a02aa242da5fd11b47abf8087842d33be8117682daa57f9a7cb1dfbcddd20665d8b862dc669b69c9090e405f01478cdbf6a096dd28e3a0c56729b41bd6e5604e25688b252c62b4708154a4a1c17789686467254a9f70be5acc9b4e15cc91d34698a4107a4f0122d6bc5273d4cb875e0fee0dde811693765d208e0c4857d09223cebd8fbf17d92f0b93c00f7645fb3f918f029cd3d55bdd0c5f3a8e10fb37c894cac37ee8f54d2955763b8c244abeab662120ca1cd2b4be0f9144a7c4dff6066299c59cd32c4a5190134b17451a61ea9d45ccea4427958b2286813f1e804bdb3132241cfadfb81243077ff9c3db457c1b1018f10654e05552500ceeb5fc7896fa90ef59d1daacc620528d3a0bb717de21491da254f59c8a1a2cea62c7bfe24cd19477715c4ab9af11576383a2cff9e99ad8a72c9cdceb3cb2a39d1e943fdce210355efaad2a2f97da0387a7a1fcd11e2134470e896679a325f5fa6e3b2d12a76d84f18c61c6cc3323c066177bf2b5dcaa077a61c738b547eac27c403aefb42cb130e38dba69ca89f71169e0007e45936dbd135b75332c23c6837f68406a1428cf4841543ffd814a3160d885e67b9bff9b9b36489d0a2dbe6c20f654f586ef047a0d6c31c3d0bec6bb2b2acb1a27bcb7c67f385d828474cda9eed0d61c8d6894eaefb199aa8719af300e50c7b27db7bd9fc00fc368bc3f742228e5721d7bb0646b492c6e477bb7eea10c9787835c7e493cb9cf5a4bc3ade9381492c54a151e4b72ac9f8ce7089dfb810ff2a582df2417abde5fe150a822fccb87cf986b508986d03d6256310a6ac1426c484c4d6c35e2e8969ce413d275b544a51a24056731c6858f84ee326cade6214700e1daeab763060345d789cacf5075d67bfa298a17b8e5ac293f7b61b5388179f1affa39b2969f074a58bc26b59596261d5135b96bd563d6c0dab7f382278308f7540318964bf5bd6c95d1c5cb0726e8f358a77ce3f60c498ebdabaaa61ef66bb64567e24d783d8a773fff834cb74033a6332f8dc292071fe20308abee58ad8829d0c57efaf53f3b45f4a35e9b19cb3880ea2a62e7bf69db2a33310e635b1d62fc94dfb90121c8eca84b2f3652f852db1f2f46fd10b9cbafb7f5354ea39fa08beb3dfbadb88a23765635614c32e1d298e2c6c7edd35c2134af92e06052fd01898cdc81b78f107cb472d069bd832e94ee2a6f23772952f2662479798da990f2594cddad5ca3ea2b5c27848e0dfdad2c24513094cc0cd5618a27c6a846c27beb5921f5ff41003a7c5cc66b8bd35e7ced672ce70f88cc59577f1989a07709ec234acd3d65d3f8b1b602038cbecfa2800d7a6735dc374181be8f193e234d5b6a5002a3c50eea6fcc2797b729ec126d02cb9df0bf07dbe7eb170a9e7ff6102110c88678af49fd744b9a4fbb6dacda5a62b3546e6dbba39ea7d25268172f73b9a7d6ea6ffed762dd3e4aba15f9f51397c41294e9108c89e80bb061e3f260aa7538fb8e724f78fb52ddaa2843790c1ca70aa4768e860b43e6836cd970a4134190d5ff4f48aedeb192e982fba005a6bd9180efcf19d5f242ec07ed47a6694b13420bdf21b1b4892610f0cb7a54aab6085a4ebd6be3776c12a08ef74f54ea96fb00ee86b3368ed9182c4f77c24cbe13e50d048025e387d856a363e725bd17356f8c9d4a66f35062d3c50a5dbc5c08776a2845fe863d31dd8bfeb3552ae56415ef3b300309847367458b6fa7c8c4a528a0165e8ea2a4c4fb0d5b7ef996ea36d8dbf593d71220e5dcec20a9b733357c8d7a01a458604c9bb497a957a575e3233a303a26709b5d442462feb47a5edc46f1854949005375f4070622b4641c36b34fe6e290d0ec545efaf9da6dd6ac72486d7956af28fc76ca6aa5e3a3bae58ff95bc71eee14671fbdb9855ea315ecc9bea251af5bb131158ba837c2a4366fa6cf1c87eda4f35261ac2f6671391911c5a4f76b4498b9ed9f91b0fc870bdc85ff2d729018da96efd088c2f1dc1e8391457ff962fff01083ba98bc3a1d0822b40867e55c9a3007c138c065026f023c51b6f82d120bb5e1b4d64a00c061ae8b217cbf69cda599ca3b606d45fb8f032a66a1fc2270347f4bed078a2337c2199223cb51cd8a95297eecfc973dc551bb46efdcc0ebbb01572057ad50bebcdd05c478d2c02a5d96656a5da9d9907e8cca2ee3a3b44532ae99be4123d20c8265cf4084f27d7831ee33bcf6a00f04a952d91f60a3053fc96f3ac72913f24068464c5320a748b8eeece68ad4a54b8b935832a9628d006190911044a59ec8e7d874bdd13164f32c2a6af4058fb33dc35dda7921ff5e74323d4a4504578cf891a0e9ba0b7f22d6b5651e453f34d836f0b8680bc1be8c4a70538d15ed2b1ccbec35314a0816857958c2f2de03ee3d116f23e135210ab03583dde0931908213007213c603f65f7bea163cdc15290135089134b57e4a9b8ce770cc8eb993954edfc4aea9f998c260cc4aff189401d0672afdc20bf0ac18803ac68dd6517e1a328c681f689832ccc5081d4ed038e30e7cd466cf5c870b095b1d71e12ef56b230e0b0e83fe5bf47486551e6e887a608fe097c7bb6cb49b140ca3bf56e48d349c8b2cbd0c0d7115501355d900dc271a606ef5b5fbacc4a680548fa93e26aadfdfde97704e54e28394fc6cc1a560feedcd932f0793455f1b367265babf057b469557ffbbaec4a22742fc1bb7d22d8a0980d5e0dd269cbd3c19e1510623a009424f035498e98e0f7a9b20c0cf29be8e31a7ebf01c69f3f676601f863946664c23860e9efb7e5f3b05cd0b9a71d54ae316906978fefb2f0e5d69f4461dd533b5ad6a6bf1fb02c42227799bb66c72ab3cab681d71969681e5f5519a85e41d50b2e84add0082b46d3074d1c636991f800f7a2a19b9493d51ce650943986b1c851433db31cceab4f306372ff2a2fef6801083ae9895e0eb37a018410ca32a73af8dd41b8ede55b22379eb6e7508bf8e021a03420c53db9c8286f080c9eb11d0a9d61c5139d56f35669db6bf5af436d41601c81fb2edfc8d8a9c3d3ff1435815a0404279ca8942ee06040e11f33eb271cbf2240ff3d8e64a6711ffa31be449594a35cb784907fd478e6b0974178aca1f5946f02db45486c6be37f4d2fccf9c401212d56328d1c4ddbfd7c9cbf24da6b7acef056ff3159120189c8d4cd556d8c1c33b532ecc471f827214ef029c166c2ad641bfb3e595e542bf70a3f234a4375d10ba2613caf7098862f117397262150a1df32b256ed7081a1e1f1319c3ffbb82a6301acebe6f245fa4c2e372ca0762958b00a0e6a3e2a3ffcc9ab35554b58b2147f80a302126bbb4e152164474d5f31c4931efefb8b4a0689515d77abcb2560c3807d471c0c6aee6d329be8ee733d7690a20e07f9e246fb51d94c793a9c3ac70711307d8ba7c5147c8f2e7ef7b8fdf6add2b25795fbebe0044463555df7b89dd5a18e5abbca63b935833cb00a3abe8eb0ddf98ee7042318c382987cde991f77d0b07bbfad2a197046d113990c8639a4e1afc093b07f4b7f344cf3aef86e164cec3174109c45c41d81754517253b063b3f9f4be3fea6d8a8ddec3e7844a2b2cd87bde957167e138c77c415182d1403296123386485ca32d59e6fc00421f1a99f94970cf899302018535db46fa5cc74b249977d92a55133c8a08d6fa96c9a9445c34f40f9d958b8c1f9b9546b99b210209e664090c40e79f018ade56e92600a9e0cec1172aa7fce248f5b347ca395bddce60852107969873bfd3e16fd1b53321e35142c8b03bf20df71a32247a6c5b79501df6c02ba57e9f2a01bdc6f8a75cba34bee3a9507b9c63260685434e38e3a3bf765e14784c149ca774387a684245498552c1c5f73d2414b6beb9e1c8f115af02bd679d87b14487a27a9de8b979844924b11972e319470269291e3a89e525a744f5401dc7153f5fd4cb6997abbec63ad514c953b0bc70ab0eb7d4f99dbf81b6067018a33362ddb28a80cd44204d961e5d122ae0a71ec8e8cb60950012bb46ce1b79485a368d0fe388eb53d404a9b51846b16f73e7ae1c4f6892be568357a6bfc20b067acdb40bf3e5f0307877e8d9cfcb31702aa124e364a94b9a1246f5407804d229657937f4382838a0ca8e77e28f2cd12c4ebf57b4ecbab1c25aa6d6c394d065444693d56357b2e5b185f31a4c1338d2d2d642e6413bf2004c4384feb7ebafdf11de82ead1bfa4408c7f8d888d048a477c86dc57274952de1f529946b4f776387799cf355fe8dcb8855ea91e3bf0776e8f0c22fcc7fe216b2a5bb86d5ce1f85df7f2701526d7cc34c3d3c46fcc1cdafd27e3382857cdf12e8686a7e96348928b2f03e0121434e2f2579290741235fe80f418e1f455ab9e7363f09de6824092b39e91485cad60c769411d42a0f98e0ea628853e6c94a9d9b1c0733f329e01f5faed29fa37a9ce275424782351ab74a8af1ea1743f310fd6c47adb04f45dc0bea93ae5efe21c759864c5a9e6d3ddb43e78b31d6209446c4fb499df0cbd302260fa6f14bbd2c97b0069d6f9064acc365d7c8fae8392d4e6a61c564c546791960ac05d156197b135974b47cb70e7e1519fc66cf4c022320ffe3e7b0ea926dd534ef320a1f3304c798dba1d39e9e7b034585a9eca380bc303ec06af8c5b8866fd7d74b7db24f044c3cc2bf8d12511f4b5dd3e25e32914f610a331354087a3cd7cf460c52f1bc12264787df6fbeea227fbd008045096b52175b857bbe8b49bcc035d086e8b4d06243c216da27a01570c513a0abde22552d1b49b8903a10d0ee67a4a1f54029790b7d9538c53f7fb6acbeafc3487b20efa07904bef3e157f3317ae7903f96a295c7d7a9851acb8cc71617c946ca1c6863c14077dcb16d8458373eb3b3f717ce968c3da94dd714a451ac49615d48fc747028ddaa7e2203fb581d751b7e96189301c1200c763c4a0207522a2cbce09ecf1fe73c6dfe5e3478f608c73c0645faf873bbaab0e152357f2a5eeeeb3e6bfbae2a2c7ea1bf08be7f01de30b44329dbcf026e21fa457d2e454c5b3bb2c12c55036515999289816fad02e2ff43415c203d50fe577d0e32bbb827dab7402338ce62112b9797be5cca006a8bb32bf7d5e1727f5ae688f327b39a8b68f85a647b009b0f0de15720794d07d102f2cd1e47c9fafe22f54dcd1e3ffe8324a206c0db34a6fa43a8884a78d134bde828a3b64f4d5f298c79488ed95d4bf24021b191f6cdbd0457ae155cfb1b8a42d1f087eeaffae3f93c411b200f27e7061c33aa307c610ca661980bd6a36875279a4768fe8c8700227c635c9191374b0ae1fadce2f1753d55d6ddde03bd8a8ace7fa1049e04cba5d414ad07f449a3cdf458368695cfb31e65474a00e70202d00038b33d6753ce89899bd771e059bc3f142405847fb56a08b6c97f7fd45f322bd58d0fbbcd2d0b15caa5460b42037591898107f425a89a32bcfa5919b93da65132669322888ae2c2b19b28e7cd52d9241e46ebff1c5aedb7ef3113b3029bc08b46993d578535d33db1d903513a94f77ec9104304fc9828c9a19574ab60bcaedcfd8d5ed96fe0ecb5dd610465cddf512ce97da868565f00344cebc10e571dd135ae7d92e70a3a5c43e9ca6f3a8208b1e32d7794842df98ce0587dbe5316bb4503defa0a457ba4e3c23cfd0cb5178358c913190e4e30eef2c76b93e88f4b300f6319ad4cda9a20342d65ec195b705bf00d5b3aa4c6fe92dfc543314bca7a248c41776d617fd6f72e528a3c9920eefa18f4ec1c89134d5235ba4c6bb3c97a520efa213ee41f36527fe7dd8fbf13aa79e9e5e6abe6b9492ac1a99b26416deea69e117229175923e6f1ea5326f1b150348085e4fc1d272dbe0638cdbb81b963b21062784a02867fd50fcb4fd1d8dbba0198a7236c207348953598c6b6c0f745e7533fc739b56a7bfa98797809e64f5b27f6e33252fb8ec1a732ba4aa539b2497f3277ab48794e3135879c2980226e5608985ea3af95fa24df7dd2b00b6bc7d285673abef4095c53e6ca12df0beec47ae59e70721f9ff8990a9a9812622ffbb8814b9d242c37a1797b71278a7ed3229819768399a2a96dfeaa0246d896ef804fdac6e12bbab80772519032d650a5853ff636ad6849eea8cbf0e1aaeb2022864807b140f53ea17f1d4fe5d33bd5f3764eaac1b5b9cf4614537f8607424f434652ee0c6c840a53a10e2b09f146552e454ff2c9e847479279c32b264541c0f6cf880d9e5aaf9cc06915d30b3c282aef4a9d390d83159d899eaca947ac51d0ec427240fd6b76d6b52bb7a01da01261ac653885046397cbcd7a58ac25a52dcee175a8b30aa29c8091ec1dc6554b8d1e36eab4a59dfce19651f898b09b50c27955f1abd166b1577cfc87e22adaf60e21d22d42a61b043c0a7d8b1d832c5b1aae5d5e35fa931c812ee88f5c580921aff5c1a446713c57707f5aff60da7bf46df8cbfce0b126237e37686b81e77cf40429446449ecf109dce9195f2549acee2a3a67c652b67069e173d8e2eaf1e8b180c6082c16f22cd22770e51745395442fe988023d048e956139125c16c383553b0e49ac9f2805430a0130d1140510837b0f14c015160cfa79985ed8e8c3799ff2ce1fa9f7027c2eec66f1692b16cc13a96e831061d98afb32b797d897e200efea09da1a8a9b14a602aab50db9443d824399793d6fa9e0673de8bb7eb4c08dfe9bf17c415779d8330304afc401c58fd571201aa3d348db6e1f4053b6b4835cfd0601582b8fdbf9ffa5ecf9817a53c102da837e918e7ecf6bedcb8d1585b438c772e496965e23dbc00728b92cfda0177d85a0ce5fd4f06308e5f6fa2e0e7fc860a9af63d252184ea96f13745f18a8996030d285fd9bb9f989505939377d15defc7005b2e69a6b58637fd04eb8b543688487aa91b8f8b54aeb1f7f3ac8dcfe2704b82d3a29ecaf430f441b2d1efd93a4f61573458a7fbd841d3504565a62f0fe842d868da0de797816922db7dc9201a32cf74a692916d3dd662438948899a006a777d2336bcaccd64d0497b201425add261477b90d4e298ffacd1c3cca7f2b6c663137e1e6ab4e6920a4979f9429f0be0cd2d2bf8add62e205d745f1c08f6c061e5a8506fa69ce4ecb36ad58522884ddd61e10af16bf4414a12043c0a615cc5cbd281e921ddc1db0a3e1f593d56ebeefbd2daf315d372a27fa20899e22dbd8415b33741dbac79ad9c43b6509a95de69e17223fe1cef2514ef0817ea959f9f05e85e7aaaf505bc7b36a0473e3646d107e6336e7eeb2b3abffe47db32f8de9a9c08c263e6a60c05ace129e641f74529b73bb5924c730dffe9dff6dddaf42d34f6169f88f6f11a78a27d23bff81e906cda59b45d807601e54b1aded5be5a179589452e7316a5ba1b690bc036fd88fbf22c8ff65be91b5710dd8b7e5421d9cf5652d0c47bab9e7b7d95079dbe42074641ecd4606610db14af79131a3dc8ea42c5e7e7923628af3290951f51ca19335e467d923dc31beb2d51460b464a8a82e3ec7a7a4b74a0a1c9d08812d4885b30dc5ade2c4da827a9e5b19c5c0e9c291ec1856b7f1d961a155020bab296cf7fa5c99179e2abf238e9976b78b965850b7c626d8832388e767f4b587fe0501f7e46e7cf24dd70b94a8ef1ebfef1d8685f27ef4f51d7ca1d49b279a435b4bf36beb0d9acab9db433d0fc37c2c31726b78bedeeebd305f5e5813c1c3c815650b2dd51df97fbdd0e124f6ede8c71a1cc3aaac06047ec18629bfcb65dfe13683ba0f69c0c2f9292833f4fa6451cd94f89de4ee71081d6ff5ae1e8267d8dda83d98ca0070c83334819832fc7bc82ed4f825c1ecab4bf73a2bf02ff7648c8aed354b58ee45359e5c0f91fb125a98c24c03a014e48dd014af6cb903ebcc703243d0ed64d9085da81af1aab31d409d13e0a659797004feda7b05feeacb9077c63339dda12c470567b0e9107a7e71a84ac6b2ffb94b3f850449133b6d512de7b28a83eb9b64cfdcf0ea5455903e5e13f9e8741e92e63068b3b5ddb458096dc2dca6b419fe66266c763ee26f8a03fd52fb1681dc6c2431cd8bcab20733c8f839303eb5b16569da18f38c14d0a8669e22e6eee12b627c7aea0e6a688c55c479d0cb60af59ce38afbc964bda2efc76093ad9bdf9b7a3b17f0ff95a7ac09f6e6d400343500e5d1d8c74129fc195b7ea30dc92ae5b4599435a03e8e0a3ffc5699e3fa3602e9e0857934ebb93cf8aa0794085a010c48856d4cb0297d58264151049156698cbef1a0e4d5a646979a9b958cbd5c845cf350248a1b7ad7e68561898322923194d083ad66bead39e959df1e8badb6664bf5b437efb01d885c4eeb87386a372213356c8fefde3fe43d16ba0156e9958800a34eb36c94954f18df5184d456990fde51cc066e8aad60a24a86e4258b27c68486c792174b7cc874efafd4d192ddbef761a3a461ca99e9461d2a730c4ffdb07b5d288922c13c41fd6db7f10e0b0153447b264a152baa246d28272d014ec6ee705fa8c1484cb4045fb4387653a87cf2375c223b5c52454298b54c0a5871e390c52b5d47958171bffd6f5e04c89de2def9cf47971c05f027c4563c3ac03fd7c33d13b2d689451316fb5641a8d90f8b6639a0fbf72d555ee9011c16801a390b632588bf3cbb6802019b2dccc2a6c964c8aa8e469370939c2a724f0f499be1e55883c31274c311f31d392b286833d850e22120056b026843ac40d4bf779257280e882990fbac5270fb17aea4072844ba766ce854756e23083b03dcc78d5a578534b391ffa7c943af788f69abb2a18d2fa80018d78779ae43996720cf7174880fb97e27a8833a86558c1314bfb49a4cad094740842c265c3c8a2704ad2ca975155b83276ae6d417893e0cbbdfd7ec861f8046f37d337df0e3e7885dfb2cf04b793b3e5332f7460be7666f339dfba887134856d86774c8f45d166a1cf10c73c695767cfb8aab0f9a5ccd918917dc0fd16eaa07c5ac6649ae5785b903d7ce3bb7574c64f3f2f9740da1763d33d892fc2ed005447f474494c7badaa74709aab7b8942359c62ca9408a2bb40756c771b780d0947a7f5f66d42def0031fd7ed8b77719e3eaaddcb52356039dcf80b30c873e622465e6f9e1aafe5e64350407f918d87845fac4bf1ee10ea6c075b7fb1c11dd331372ea150564f72456fe4aea141202ff03d847b1e9e8b75e358075eb20839ea7955012868bd282cc61b775a254b8a4fb3a7215c15d77b9fa0da63a99773e2d5e522703de39686799465416f9a579e3d428260c476af264c3c4cc94047a0a502ffcb930717164e07b309b962ac56036cb6ba04050e634d77287a41ae9d8c1beb4bfddaf3526002292e7b658a1f044f29c17435ea6b2bba6cc35eedf2f5731dd5e727df04b9329e8c4bb6bbb29634ec2bd64d6da40746f103e5811004551deeaa0ef092d423c6accc5659c1fab714209ba3ee5ef2ed4e334befed1931ded18540638a690a249875588aeedd4b226db14cbf9bbb0681ae0ffa69756f16400908050450a825923a57e8fd33ff85fead823a32523fdf99433551e6bd5cb057587d9bc51dadcbca24451cc0c9dfb557251b5638089d4ed8fed8c67c167c03e23d3166add98ab4f3c3126d8e77340bb2fa9941aa233b9e8b0a24b2a2f6d0e4403e655dec80a00718fe5ec2f57dde4225c5cd3f8456c0cc9458f39dde716cd986a8bc847c179dac08731732836ba02f358786c62ee73b3da6f0ef4cb5df93be2fc24da80eab6a4794c9e9bb076931ab27c7068f95caebb65ff1f27ccb974aaa61cdd418a4a4a3f52bac07794d1d719be91f1d56f10935d19a514e32c72319812184f4446d5f9a7bb9a9469aa9f00b306136dd922bf978c1728270a7d90ccd9fdb7fd0de839953f5d7fdafc87f8eda325bfba55310d42c74b0dd097297a0c547935edd4fc081e58e27065c5b423fb7bd8d9540c3f00390f28eb502c4db4f191ff8e39cd641b833251be73e8b5ab785be304eb3b6c40a7f97f77f226720a129a027ea18930ebca8b5dfa60a8172a48edf2744b653eb34ed888bf59ae363a07b0cebc4b1118f1168d4a1f41436f841edeed85eea41cd72efe2bc4db634c905c540d9800cb1ee86940488e169bd4d49cd5f3d62c567b8b30b01d560967f2369d6dc9096db03f7cacc23481b2c51ca2d17dda747a61d0009ce9797270e0f7d70bde65214f3e77471dbe70b1f670534f93d2cd842e1c41414ec7cd48d5963c58f7cfc835da4811a1a3f972147b20021a1948b47d19729447d5d1f5c289c3cc3380eab96c2260025df41d037cf0b901a653b885df71d35613ebd3b134b127782c9867bfe5ef0969b39c5caf46b8cde10f778e33e18b24c25a43efe3d748c0b956485cc4b94ea2de7f013b22a739ae41f04f7164255a3c8dce1ed0a69197faffca80c27028a42592721fce058068aff1827187cede9b1874d8b7983a90fe74a27a1375edf0226eaf71ea708b60dfb262db96255ee501b604fd3214970ef3ee6e29aa9e26bb22d494061830d0475623579d66abe8bd37f43970f31557477519c5449299955a673551122bd22bc42a173914d87f611531806418c1888c96bea000a21a99a4ee6912aad9d46915d1ad8acc34e6140a8f6000d7455a1d8b574f231d1476aa4e5070fccb8935a94c17f84e1a34843b1ec6cd387b5039e1c03a2cb35347f15913cdfe0d409e2726bfec8d5a69c9cad666ed00b21de15c0e7c0deaaa744cbdcd274d59c4183c4f3f2e532c1a4a284efc154788d31a51ecb18178d1fde16f22ff64ca9225b2e6e1c5ce2373a33c3ddacadf59098e882b310bc8b326c0e3988bd8fb222dfacb7397e661fa890795e658bb5075a3e0c0bffc27093e373451bb7ca5da4efc424aff3b8eacac9de1813f5533c1a7b47792d9ad7ab636a622748a6732bc3da3af2ea6e60eda3f2d2fe3d72d76a5a60a0ca1243caa912c9596eab2ca71d2452515799b8eecaeda08616d2235f52bb8779ba4aa4ee97272abe841d14354ca5f8cba204caa46903f18a98461cc05da9fa33662448e1f5c1fbd0eab09f700d643dca74c381d17b160c2ca83cfea55bd6140ec3000862dcc6fb4887e6ece1943f95f4ce1401bf4999a173a126201744a1599a15abc8c47614db7a4460d2300eb52d06bc0b2e86b86485fe81efde5b862f04962021c1228f2c5bcd32c6d6c36e63b07196d6b26ef1370e3ab3e83fa4d79e1a83aaa50f1b81ed3ed63adca6f62d4287cc313bfc69bc458b695dd02ccf1bb9e20e3c4881d4b7d5cf944c0cf5169b2137581afb86901560581408d1734d726e0aee92bc32e7922c4de532bd1dd21a4e056fa54a66da458f9117febef30ff5c981c40aa5046c8b0d787da3a919235950f2e3d2ca30007d9deb5b6b445c0c13e4a14499d7f78d070385fcbff3e0d5cd4859a8faae686ee339de8e67cf50c5cd3017dd4cb0dc879398fbe592a4dcb418ecb0ff4585fef8969c487640ec3169959f40bbd3a4c6649f5ec7d3f3c92f92f6eb965534ecff7d2fdfb3d81928e2ceb94afcd29aa7cec0a36b48cefd661cf60635dbdc314fe45a2c6e0398ccd258628e8a9aa4542b8f6f9f60d032dd5c08d7a37ee2e9231c66bae820d4483e919cdf5da0740b77d4e73084a5332f04ceba7db646f202d8fbe98aa1c994e0aa8255a581cf3a6a527d9151a36b06d0f162f135905db5ee75f865849c771e758107c5ca9a69fb5680033c2ea432debe27b02829484721a1fb2108f62e55301298fcf2dc545239495444401a6547212ab6dd6722a057e232be7819c271f10cf52f2d150344279e9a9c483b42f44b2972c07a685a587c11dbfd3176d929b4183e46abbf3d1d10223b6c21002e5c649b1ab55dfaa6ec23d9e8790658146a9e3e7380278e01ae1ef6fb7bd43e0eb2cbffa01fa9a5a4ab0206d762773bb4b7f5fa6f3244e405a8f95d7bc895ea5e7e17845abe374b3dff57d2b20a907db471c6fc1cbd61ae487092b4bbcc99f6cc3f876d145bd923c1abb3fa4031537d860bd97f3bf0dc20408697ded018a621cb698787ad3f77b023f294de25c8bdf21b5c1b57654c40d5da5305700eeec3128944bd6b2c5a7bd3340d314b6561bb3319e5febf84264be66c683e601c42f80fa262f6320f7ad66ff3a3b8d14ffb35a1a7f1b02fc5a077ebddd91ffe802f3bfb93497e5784f99266fcb6584b38990b78d8b16abf85d5151126f8aad05f0e68d7c86ff91b6528ed716f977bf9b3199936c0f7f867904e6314ac86b0ce9315ba23829fa82b249e45aa10ee829c33f35f1589e7c0acb08d4fbe1eeb6d1546805a86b8719d6c33ff393c152eaa144e5896169b6c27bd5e03acf6998d7f1df61bdf57eb06d0a9455c7ae977e4f435bbaebcf0b1e1d02ec24a9b5a09be93e9f429128a546ae2f17cbe17edeb953728920c105ef581e0a96f53634e8dbd94f97410ee019852aeb44b295271ffce89286bb4a162b79d0317996d8feac4e8b95e95797f8b8bb56a82f35cca73531a6e1d584c738bd21a47c447581055e027acbb47dfe11f9654324265e65cfdea0d06897dbb5f94e33df63e63c586c323bd870501bd98e69986e25b067954f399e4383b8031b03dd671ec46fa7e0cc0721a5db393ccf2a0538ac66dfd5f8a4ac822d20fbed308276761f264286452b1a78295571793a9c284c07febe721805aef6748ac51325c2ab08fd43cbde0313c53770363ed84ee2cc6f7880c07ee24a37fdf2b24d1ecca5099176072cf1422b68c3d20cfab996ef1b6cd5eeaf1c45986aaa24b99698c76811be50890ec9a847db01f4bc71c1e0f72c1043d4860eee39fe637c7f28ad6c791113056355af45b3dd799c6ace30aca70f85974a0a1ea055365baa59250d3af48be2d6fd6d14d7e5f781a6de5f530e1b2cc5d6b91a628414e58ce3b5bf8df891fddd20aa6f936011109baefccb260921e99a9d5db5bfa6ea6b2b3bf62e02c1c62f0a6044753a5235543a253e435bd52f8822142830174063706c997e9df0bcf7a6533fb01d0b517c6b52c4835bcb46cbb072a3af0413b4452891a2b01a03605e7eac1500584ba439d6cb9e337f629082f272cadbcb18ff023b3412c7e68a391977d190cdc3bf836302214edaaec187cd3c79de23026feb58e6f42be9b1c7e33074c957bea6956cc67ba53d61879cab4130980df50b04e1b9c6153116aa0fdb3c1692cd3b7e217eb5f267e160e437c812fe36f7715c135dff838c4e8e252bf8a72a1362ea325d12a7dc65a1b23ecc8bcd2e9a619bd30fc6304e3a8d8407589dc2b56db6e5afd49478db48da7f7cd5ad9295f5c59233b58192f45be3b16f74b18ec6b1fbaab9fc1b766fde4ad6c6a4c111492dae4b0282a385db54ffd632a0613a0fc6a25d64b85695fbd988f169d625657f841e90ddf16c9bf3e66d6405ec53c5b4689a31cd412b3ee1d0b7ce019d79469b0129994de8dc04136b3d104829cece42335c332c2a30cd7610ee7640ab618f0fd46f038df2af3e8d8583ac417ecb943c06f933fc2ced732c2c8918626b3ebfee273d05f261b39a3986b77c2bdc3444590bace3b931246a1d42c3fd6cfdc807189a66470e031fddf04916e83b053475a72c5f2219bd01e833d71ddb82a4837c604b45b0d0d75454aed909ccb79017dafdb4e66287c56443d834ef6f4f053fa11158b26638069dda104bd02e5cb6d08b1e70e419f7fa8b56bf5176e20dd80221e7e7bb29d98f3b36083009ea316bf6a52c0b84d4f5a333a224472d4e5e2fc8487b239d57862bc99af6b4aace3f71915060e65e26011ba60780346ba28b8eb5d08f9295cd651e5b4a2c1b9e6f4752ffac1e6fd84467b4fddbfff7788dee6aec0f5b570fbac654194bdcf7e766bcbbaab6cb3f9fa1eb4cab2f4a2d911cd9d4547da3faeaacc92b348229b4725d78d039740c51202af3975391459e316a4bd1c505f6de67133b4066ec077e4774dfdfdd7d6af2855bc0ee43ab575f08073a8247f71bbb0d9ec8b92dacd8efc671dc78e1fc7e1ed4209668b25d8fe54456349c15c20fabb531970daa6a5f976617e49a9e8d9a1f4c411faa551c115ab20ff4cc872af167806be6e8a39808a95eab2244499b2e4fe7b773f45b73e0f00421b499bcfb68a29a951ad46d8022a798f52b61f9a8e0143252d5b2586520dafd613e02fd61c2aae6f627c36ba45a1b4bf0a9e288ee2e54f22129d39db45c5c54d222ae8f5c63b545bea2e72585672542f0d237818d4b9bc4617c3b1df66f30a8cf89191a0b88fd68d015fb21ada8a7029b4bec93aa8f8285fe6661bd6cc6f36cfbaa4802a6064847c0bd2aaa1fe83c4f473e111278f11cd4d7e76cb025bac23a4a10e3f482c011cf7daccac7639cab44e1ec73b8a860df8c3508cd597c63ac6c69551074aeb6aec351949799e9a8549ee32918cdb1907141bfabdb987e4f388a81182d98587497d0b47147d70632e54b970f747ab2d9567d626782318cb0703c234b4f4ac34cf873e3d56cdccfc3a3471ce02b8b775e5a349da9c58d95ee38fd5771ab22d2f9520a54465f237d66f28bde8faa2658cffde4a956c95140071f98583ebaf87ed837873c982a3ccff35ce6be7c65b4b1149db099194782189d4b3881d0623d806fc08fae4f6c442ba505247542845de10ae36b69d2779d824d03c0328721a16fdad335b92b5ab6acc9df8a272928f6e1bb6b50fc52b32bbe8834b85e943c07caac6e509d3b940e43b106a9854d70e26dc6df01fb5df41d161ed4601e55e7e0539d446a5b98313d672e8c22983f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
