<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"cae33e728c7399360d677d9cdbb8466c4de255fb6cd148c377feae4298456a983b59c46ebb4b39498079710e03f60596ade130ea68b33fd08ee2e4b8517a98bf9f49985c5fa40cd85bf669ce18255ad04b68b58db5da3c1ee2f521fc935d9fa707b5382ba93aa9fc6ef3e97c036f1f57fb952fb9255bbc5b73b7f87f66d7294cb980ae2537b408c54cddcd4a018f8be4a85ca3be9ad4a818e52828e3025d4de1d18cf4842947fe61e7d7477a95a271b6ef507b5fb81edec5a76fe8b393bc40201e5caf2ba12e20a073268c747ccd3bfd576b9f163c433d349f46b809aca273af49386b6a0a0b9e81828c980b6375c03b464c1eeef399c66fd6b4ecb5aab25fb8b52e5a41ba57bc48ae6eee70108c5ef4985e7077b464c4b4cbcca3c04b34560bdc77cfa7878fd97e9b57a24e993caba8f13422536689031c6e1576dcc580e99374e38cfa5c88a5a738bb73114444317ff41906094735003e395a409ff8f40b297b9cfee7e99137a2afdb18a7e13d24167fe617f1a2c93c15667b189d9b78e47fd4e97c3579a08d8e795ee473c5f56690bc11fa257114ab692260c0e5f5f09a8e2302ae1b9bddd4ebecc93a96fa8688fced33d93997b9f605285cf2eadac64eb76509269368b2cfc6677696c0eae4357e6b170d1f3910e41e70d8f5906e824272bb807d4f5af462880296f5d0bf9412445970b897257a5b7bf85d762c8f0d0a275bef600d829a11df4cb2b099a2cef39098659da8897d6c8ba2e7a95a082cf02340e6a8893a09f1961e7313ba7c619de487284910173ab08ea1ae3644e49277c259447362bd4979d6c34c8fbfb62edbcb1511ab5f4c99eb3f668b68b259fe0094e090bc260bb227297e9e114e1843783e3051ca133188aa50c10a547e3192be4ff5110eb9712f5f03c0aea4ccd1792033bfc248516b20452ca74c929aba4046651806d9a8578d665f20bd35021c37b4bc92b2808c3ce66717641d4aeedeb0e93ef1b64f35863ad82ba3a96999e2d2a7aba8b0e5d645263d7728282284ea91c76b1ac1ada7920733b3a5f68c168d1c9b9d54cc45bf7bb6e8909ff4a8e7762a4576d34418d85e48d6c6325107b8e9281f1149eb85f46fc60de63918f850b8d313d471d867b9c2e083add879a7905cee2d52b70df27770c46a74aaafe813d4f9d103091ef9d96b8e689c6fd99e9f3ca90ab372e7fe03392e42d4426fed16eb519d8b799be8dd644d2aee08b9bda32c68e4d969fbcff02e5e268a48ac86d82453354e94f89c493856374d700203ba936f184c46f4a1dec1f2cf5b02042ee07cb691392dcba3a734b429374376a54f9112341e54d0520a5773996be19ee573590501deccba966c7d10542bce5ac091ac0680f09e607cf1e6d1131d25d5cf17a34a1d0b774c9c675135ecd570b2d3aac346144f25be72650beb30691b47f2cb9760ab2cac7b65bffae652ba657c60b8d0d23a74784d40d5cc315cf25474d252cb93ebeafc99c15086779ea932d2abd749029f0adc63cdea6491249e167fd8ad56d99d032b09f4e246be2cab72dec1eeda52ee4b69b408409d109a7f406d3b98d5a074c26185ea5293d6bcf4b51d4581d3b392ff7b93bc6fd65c6bf62401cab4138a7135fb1c2ce5f14454c952b99ac7f3b148e1194740e2c20cba1e84d23c2677728e2e0bc200272837568d32e1cb51e6960adac771ec39d0cea17606317cca5876c9d35e37f89260c42d66768b9e8b1c3a811f558a2bfd61cb24045a013ece265ff2ed797caaa52b003b68d04d2efd0fdb99a1d8a9d2dee30e23ef6181acd046f2656c2a0120c57f3c5c263542893ff42cdabaa4f8b503d400076196d0520f659bfb528901c8ba9a33179101b3bfac8d2e591dc076ac357e85e4ad841f917d6443634e2d1fca7c743b0487ce231fd0cf1e81cee1964501c86bfd0c654962fb87ed921cb9f63926bfa300739dc099c61be9883d7bc2f8a520d8092b100d78035c31594fd96f960162bbc2e2eac204e49e3369cd366f6a44eed4a034430545a3f2ecc186682193f5150d4ce194416b14116013c2e2465894c19e07fc311f1ffa7722ea079ee167a36de9754e62f8e9ba3387d003ee92fad62d949a16b8d76d049b9f9bed8853b078fa3613748622d143c212193533fd93250b3d4529603cdda2f4f22f7ee8f54957630ea289cba672dcfaaf4b884e2442699df7d3ceaf693673a3d47e2fcb765825d139993dbc4e4a96b3dbca869f1fe67ba023132a0722d9043ae0bd78b989117cd3e436a79cb876a0ec67e003e64dfccfcd6cd234a12940cd6a86e6a371ca9448067ebf441338e89021b8730057fba16e0063d0b96f5fc627e8492b8d13e081b8be3413853f8638430102f1fc687bcbd0abde287957e97dab780d734b64b833ad95131152f80e64dc0f13d4b8252d1951e77a3441ca45b29754d153e7cd17c3a6d6225118eef6bd91a4ee35092c6abeee89f854d9cfc9ce77955c28ecdb15bb38b894f1d6ebce05f8de46b82cfd17d511cde1f276a605f6d47da116da23d7b1a9c98c9fe8974ea11aa3bcd589a669e165423c938a5f5fec8ff9ad65cb2ff25e80a3df16288d7790a833798df95504f6c4302347074320018752d3e9e80cdbc4a3c161468c984483882bf1402d7119e9084e34347d6236c266d826dbd64c4cb3d24cc5b6183cff7cbe0465d9c753901cf12e8be4670423ed2e9a55686df6a874bd0f391bafb9743cdabdb71124ba37a0e04280207c9649c01e953a3f0a8ae6ab2e595fc751b2213856ee712bcba8f945af1c29f8153e628b49c3b7b1eabb86c050f636180159a80273f4c1cf880eb6ff60f0b2c4e647dec1e8b19399f80f6819f063cfe7dd9f4caef80a232d7973fad3fa5b44d48be8ea76162b6ccffd167599f66cb6a95797626c61ab46af32c4511f305fe5152d62269c1ade92e7389223965991e108f55a37aabb8e895c4e496ecb99fa8f6635c878ad4f72d5459d296a92dabeea80efeacebf54d0d7747df50e8ba2a525ced34d0d5d83f3d3c159259c209154b3672daa1e35dc20ec779f02d06101b77ba12ff1621a45c0a14a36a4f01cc9c1fe95f49079dbbc0defb88c53f5af36835dcca21bb5143a159c0d4f64b439be8aac2a853a0e648a51d158507e90d7fb37433f73a7da3354b2071ce17b0291617ff4cb79009179dbfaa65e0ea2114d866b189cb6ff6aab5ba00708d6a9cae49e070a7c70c2a010d3bc8a3597340b579cf2acc398fd5219d1922c0da09a2e02a5d0ee25ac3efa1469bcb988f77036d90c04a5cbc9e1403438897013325a5c1e8e51da4854bf631563905ba27be6f0ed2e506ff1492b111aaaba72a65a1c2577f92c2bdc4b8944974060258dfd778fbfc751810929de092d342d6249c373eb27ee6681d2285b7870b37a200737b5f63a017434972fb756914362000177cc34dfed21c5947bd490263fb54f7fef0bc1cbe3d3b905448d149bc0e40724e81f6426689d31afb8fff6a073d7e2633b75c085dd55a9cb4fd9b407e669abff29d6d1e9e16ca01e3a362356de5ef3c232cfb9baa0e812a90b3e3aa4e510f52f9d888548903f27755c834c332a49f207d9d05734c4ae25f4703e30548974e6f89e2a1e31539c1e3bdfaabef57597895082dc86655bbc7aef719ec33c6aaea0cfefb53cb28a7f2a49c686b9962d93a30811d664a49a783954b0daa56fb815c9ba737fe4477cf6f4c24c4b846c3b704604161ed0527ff985fc9286c8e353cd40a6ceb36de2bd653514d37f7554af9045a4cbeff272e575004d97c02d41f2ba3fddf8902386d38a70601b6f8b8b9c410b895974e9f89f7c0c79730c6bcda77542b1ea1f557d08af6072fb4b45ccaa14b32d5a8b3eea76a56bd0b81fbf5bca0c795f5a38aaae9ec00afcc03cdc8f925b1b2d11c936a222485f5d57588ca6b0d3c16fb3cfbcc33f52d41f2e3421bd1d81b5f369a5099e3d390180c0ed0d699c02fa98955fda93b6befe098f68dc0899b817b896aab69895d84739fc4f491fd3742ed9345a026938754b643dcd119bb89ba51a30682de1b8ff81fcb84196bbb589f1a5cd315fc7dfb6d1385a6dbdee43670e350d47ed0acc6dd7ac21e627ddbd1bf50aa64ac183f7f9a0305bfdab97eb1255fe68e60d9d05f32c0d70750bda932a089c7c84e98e77f727128890e436a5060c13d7d39c26edcacf28224df62bd75ab92787543816824f7fcdfb9480234cf2b675c23945d6be26864f80efcaea89fc41e05157be9a8d7f49e0b107b5f0aab3929c9d26aa6d53522085b2a25ca4e78dea00acbe52f26bf8b80c4c0a5b39fda5f632defdf1516600a404dc5f585b8572a437898ce050605d6477c89443733aa4b287da3deff7b3467d5f76a1c1207c04e8743ac3f6f22dd83ab4e87d2af84459d5898cdbf31a90018134270d2da6fca2c808fbf31c7a215a4689e0a65550a226f2b1b982545821fa80fc30f38d7fe2c33a4377b81bf539089f38ab9c75a0b37a8bca6257da69927afa3f5d63637bd8a75d3cab441aad87e5eee6a8555e98592b942069e034eaedb007ec6b1d9470fe7b88f468ee23198ab673e2b83ca954238a943f8647b7196ebad7d28a64578a6e61c230a76ee8d9fc954c6b7d9a71d58743edcc6ed64a73da12562c84481f045d3a91b0936fd083fd33aaeb950a21442f1dcff0c509ecf5af3da083916998d94fe17cea6f02b0aca9818258f37528b12a135f7d5691e41828c566908655a78224096af80d14c3a59a36cc9c2a78fc3ec4009bb28b86637794562cf4663c61b4d17f6047d1b7cedd3fe7dbfbe67e948b850f38a671316e810b98bad670ae198150867f9cfe304fb340782dbdf71bbd999d452bbe0ee68eb275045fa7ab2b037504b74c51ae48e001ba68d2d1985fc9863283f616f8629ad827e7aeb16fa92ce582bc063df0a659b5a8688a079bf4cbad797f9eceedb68d3d316ac2f4fe6b83ffe28e87be9932a7875fb606aa95519338b6f68a82f4401347dc280720b7a6cdc2c8b44d2456e6013e7f3bb216578b5f34ad012c66446bfeeb02ed7648cfb77fde84a08c83975db78d6c5ab4a6ee429dcc39ad1a1efa8b704a1851b0022a01f8622adf1ce7ea999c847b8821d0355580e0f975d9b8b6511cb8ce2803ca937bd8cb4504e9920a35e142533938a49f2df47846295534383a36f56946151bdcf92497d3402ed9b774494bb556ff489117aa65956898612ddaa8a36c38fc5a808948537c883ec3b7eff67b89f8a9ecd45d2616c191430e1575d5b65cb6c79fcee2d94cc8b169fe09114fa70e893409833ae003944d484a815738719a52d42576020e5b40ce83e0de2d1ccfc3ab5b4bd23ccfd089e80415c9ed569b3dbb734053c03ca98a8c613b798ed05000853cfb66f384c73947b1e68e2b3498c0e3173736ce3914785235692dd8ca29b88920477c31ef1eb4feb4f9a2aa42144cc7155ca3841721c38d4d8d9f10472656d754220ef06aff9e7ee115676e7238dc5385f929221c96a82471748de471ec20336a8f2584a573385c02b4232b0937d1a819e371735556907642e258c3c2c7329c08ce079b94cb1302063f4d00d0fb76a27cec8c033fd92c1956bd1802462f8d2bae96e4f6a858260a7ae89728a625187bca5b5cd78da27480c27a8b3a8431258d14d3465fe0564c2287b228412ef3f9c99bc7c6993536f77a398723d8770e1a1703990e35a89019ac743c8b7fd7b720a1241515fd0c003579da287eae541c14a9d6c891009b754fc92de4daa29ba676e01aa9cd7b73045042ff9eb06b36e6d14a5e350e18a5bc0c225e6a647ee5e8d36eda98b66de8228f245c45945aa60bd88387b7d519c14508aa6ebcd79385e49a82f7c2d62fee6b3a839248ca10f327693807f8ac3f6521dfee3ac601e61f6a429e799e439f289ea7c74e7364aabbc50c6332b35f7eac7094149a87de31c5633e47dc21ece8a94e94a0d8aa66319d0f33ed48e94990c975518cdd463658d25e853a5cd0f49accb2482c930bd3c02b22c4073ee30a8fa70fcaf492e15b3d264ead9f9b082880281163cab70eb704b7b2118d5a421216e1b2bab0289c5a8e0e0d0fb0094424808c2dfa17047b4e536cae9e881083b9786c4253c5ba8c202b2cb91c45b2a5f9445bdcf5149978010899ce6456eb0f60231378a24cae5df6a9d17c202ed33ab08344840439bbf14469f18e9a1b1447dd6b0248c9d5b3e5917e8fe2a2f553cf9a691f601da0445555ff760ae6a99c9f2bb7cc6d485c07aa34fccd920d4f2cb327080f425e3affe9b2e3aa43dcaf7b884a724dc214a9d5c31bd4357d8a60e91960af6cf4c0a5751cbbbb6edf697c4a7c62b4a2be6dbae2f1720ab3eea924737a13c4574c45c6fe52f7058cf8d42449b20cb803438298a0bc4eeaabd7d3d607b8d9963504e7dac7215b843acc8a424ade8c1b6764a7cf247723196c8f69b65e385d1abf6e3b23d7495402ddcb41ab9051c2368bb741b85fd8b6650f4519fea539ec89590e67defca1706bc1df5443ac98d367d7f3164c980c715bbc054d0d63b7b8e21869507128ac7d30794731cde5a188bcad1cb9db67a111e7f66f92a4d5ef31b9da530dcd04cf09a2fc272f40bef145cb0eb3c0101f310bf80ae1ca30557d52071b05c0b76a2a240f6482ccb34ebb07fd2473bb306c6375bf18cea9e7cb07b764231e199d7b084de4b264943ae3c8c1808d4d2dddf31260f260dd896e26c5fe1ef8c324ff4cb54df97f4f0cc02ffe761f6fbbb5e36d92e2a2497da29f8270431c2cecc969d95a8f3d73145b703777a672c8939bab2900606e0c68e2671777f7db6a002b443dac266f1586186825ed7633454122bd01090df01a649cd9f90dc268868ab089a1f5c760e6a82a4f930fcd5ff4c725b9b0640659a6462f7fd82fc8b559d82344c0c0b582e4c226bfb1a18f20fe58d00900bb0ffee5301e420cfbd51f89b5afa327d5e445abde17df0854ceb98642665b57759692c5a678204d93c4abd9c6969b748e581b55d0efebd75cc88207f15f380e02f45683dfaa6243874f5847894ae69b0a02cdd2acd2ecbba6e78c52229b7cd963e3bdecd63a60713214afdc891d18c2743cc92132e168f6e178b0d5b9bd1eb2527032854f64ddec0cbeb66be2142ef946dd9a403f4acd9820092252454d5ca84581267f34cecd177a871b19a73503a0c71a197f051746c1e2b824fa54d030d7e9102f5725e7d5cc7d64f3f6db9f9e65282a414072e32663bbfe4480dd5eaa13d54a93db8bc3cd9ed1338f418966ad90f856f75cb1fd6c65e4185f788f6257142d22f25a9af7020d9a55dd8180d146d87e0073e443600f87de2d3439a22bb5f72286b2e587fee4ae1adfa64c027e1700e26c6577893737c26d66d4592c48045e89dd4464900d6ab84e73483d6bc562d59baf49ade562be7d093c645578ddf061cc79c595c2688c301103c6b8588600a63edd6a9cc13a2ab1354ead53b29850311a002923c49874b42a4dc0282ec8e59848ebd84f7f0afe51eec845a31eee393d6394cc6603fabaced0083c33aa63e535faf8c6a3058610b7e45c235a1bed3b3b43ffc4fa81c205467f08ebb4e4a2140dea295ee99f39f46de4e68e62568d01222a0e29a0ee217f91b8772df1b4205639880e3eb4acbb379799297838213c2deab0ba4464e27350d951589cded89341ea945af9e82228659d4af34f0c985153bd2993d105530e56ece02217bd6a52134ea5f54bb66a51f6ec839779613c735ecf6dcec991f15e7905c27a7b97b7d6d746ba527536231a54a45017622d7e36d8c65d5137f6b930de22e7e22c55084be0f0c5afa8db3cc4cccc5b327f7ab7136d007e727b06da5475da359a21f577ea6236bc8aac4de7746a731bce8c2bda9c4942eac25df7bdc484257836ab72097677e430d212cefee4fdc2e8ea7675c23c18250fd9fde48f5dcdfa3368a4e4075e2bc44d7c3464f9a96c51f04ff69f2ecf2c2138ac28170f3a0c72e801b0d37f79935e904f32cc438c2f71c0ed92a850d811282112c1efe1cf1f34774dda6600086f7610510cbbfac33d67ee9fbf0fb7149861480a2102fe23c7f259ae23c1b442fc2a9f9561c234b56f747455ea34f48107337a976bb591a4cd39a6058cb28cbc6d2e410bdf6796f8b001670baf3b84084c4dda52db25b00b62dc8a2e1a4a4a79fce973fd8f2274a15f6bd7316c4e746b6298011087c843c5c34590433796dc5359c701d2305c221360c65e396b23d86e8b39265844be95166f8fad67b59d98000f8c11f999994f4f3d69223596e445a0cac4f79c117d8501b60acaa3746ffaa37efe58479af0d1523f8a46fd093fb254b82433448155b9880a5e469455bb1ac92ea9717ffa94dbb4b3554dcb8f94e910cd46028122101013f07b1f61513c730cb9fddeb6ccfad629777c6786b19e94463a3c69f216ef4dd34ea8a16bccbb5714efaeb7df53629cd2393f29a32a5f2467dcefa5da4d21c53cc3896106fe17250ad65e84b2f6172e898d7328484214397edafdb497ff96a0d8d506e48080f840b1e1483000e24f3ee61495a7de2d0b4e4d3b3c9680d8a67351786e9d1c05ddbceb740ec24f83a3c40f27c3a1507df9dc331f4118ac42bf62b870b579600765ef5ba85d80649137909584b1f36e22a9be7f4eb931a306ca6def3e6b427222d54241bae00a9941e8b8ad541ccdcc6dbbd64ebd8769d17da7daaf41ce298dc46c378627c54b7166a8467dd234bb52a97bb468d600106fa13a0f9a36d55384029f0ab29eff5f04a5b8128410ce5c55438b748c04a9a938b2d92827d27c5594cc4884eeb2277c50ead02c929bbd8b3e101303e77f0badf4560b0b037b259bd552452d0d7f969ff9fa89b30d41e8b25da1e07efba8eaf95424c5dbc2f3cf4bdae579c18ff266ecb4a696f35fa9bb31173daeabc8a12db33d4e596b68b28d01fd356714cf096defc7426e0ecbf6a023470e6a0b3bb828925223961f137cc90a3c87ce1d1fb0a4d27b0fde7974e1b2d2a5cf1e1b46d4d8c573ffc7ef08137c362d4e9f0fc4eb5d61b8420c4f5369992c9f6877e23ff833d386ff9b554891352a93a36a643022838d1377462134f35f9f2eec3d939fbcac38e8b10b021c4f54d40b14314fe44b11140073928ac2fd5c0aa2e1be82862400e6a01897e9d9f399b1fd39c19bb3720a4f31c1f5ffefa195d445f4779f9c1076aa3526752058c27704026e7a6ea481d5abd8a682e5e0cc56e26e9383b436f733fea405fade7918208e46595dffda812f98fc85ab9b7bd36e5d5fa2fdf4626b650521224c9527349ff5952bc68543897ecb16cd575a704911555ab572768712f193cbe2ad04c3c158d961346ea6234bd46abf8e285047628245274b7fa4657f338216fcd3f55e95d77225d099f8921ecb2a7562be1287a0f8e16745fc02af3a796b041ace81b16a4557ce03f9dc478c277fe3a3717e3366cf5367dc503ddfa94801ee1a079f32773792b01941c052e4f641db82392478da5b24ec58a0ffbc7b141588b79f5100aa145a5fa74a0848655da4beb7a3b4280cddbcfbb2a9672592731b20d61bbca7ad4cab26d7741714ce1f946e78a7c18585773802921951f3eb0d1523b2aad0f50f2f6d7a232915806341dd6120f766b325940f1e9ea8bf233062642b9f5b7b0b0f60fb6448d3b2c3395595e7270d4e164ec373fe027cd6e0b1f3bce4df2a6ae2e45002b5ac4c6f18f01a81543a1346ee986024d4e2c6a552563a94b45fcedf560f8a50bdce2ffbd6006bd914fd23573326de907226999ce7f64a2033c94bd811aef81d48d2273b9a6d7ef8be635da3b3f7045e955d2e141009b395fd1aee1204cbd0ff1fa840a4b0a9bd671a0c3323a0a975d93ada2ef7d1a893fc75db85dcc99125cc16ef84591509ac14632dad8e837e3d836bc48ac1c960c4317bb54131ce67a6e1fbb5415106aba8d618803aaaf879ee45b69d778f0132d90469e33247d61e4ead6f67be37cb123c98e678200a574a284ac610c1d5a3cc25934244c382c70a5194731e2e27ff9b7a8f2dd2efe2adcd0b8a92424715d068d7ff0f6c33a308ba659ba95f904efd3a0b575cb8a272e0938af1bce717631588c37d699935687e45aff6c843599678d08d3492378bddd561c45866a09809972eb9712fab8900fef2c3b5cb60ce1e6bee4cacf030bead24387bdd6c2c46a8fab64de46be6c2fa184513b573dd8104b794aebdd168d1d05a6b2d26538dd309393d38e2a38a5eee7be39021d616d5f74e89b56f37b261fc313860e044f4e184fed55d219f87dd2dc70d4c66d867ed11590f779c4480868ce94ea0b3a11b3d26cc1e294a9a51a204bf76472f704583b5e01fc1466d09ccafe9a3423b03220238c4b3a0ccb69795d74f424fb84e380c0b55fe6c78907870d01c522924a1b5649d3f5fe9451ba5fe15c51e1e3e804176cac2da0e4dd8f208c008cf1f92b8dccafcc06878b2c9751aa00c596f5c7ab2f775031bc95f5f0fd5a5a8a4844f5d1df5c56092b15856ce5c83094ab2e3f22e2776e3dd840af1e1e20e81aeea0f18a828f2a53a67ec2aa9b9200068411c369d1294add176f0d012fda0fa5ef41888abcdaf4d85aaf0f43335742a39660aeeeda126887df8b87c728e5d545ccf871f55044a8595678ef988e9d615dd217a0374d9b23d364890cf36d81968f778141eb17b3a2e617ddcea4f4c067aec521acb216098e759f1e77f675688aa438a27e343168b9a379dff42a651d57726eb276d39aa20f8df848cdd8361c9e517444ed63352d2a795a235529209d89c474d8f5508bcc08a86a0fce35b4d42d2ae076ff486d2a1fc35dbee60bfe744422d0fc01852f1f73112a5d7f2750baf2a7c5ad01a27d07d5c658841b082bcca475fbe25d97312c8bbecd34a01ecd38f7eddaa0e82b6bf37f7f0860e487be211236fd2673422b18a361fb03d50aa1d51354a692152a9f9704a4b1ea2a028df44f09273b792e98a876061d7e733282d77aed30cae1149faeae9aecca2de0db3892a4dbfc9ad4e9ccd14af14a6da8e50d51ab7901830396f80782626caba393c12f228cccf78f5672fe62e6dfbabe6c8f4a7041e7f4e42b1264990379672fab931fe4b1f63b649669cc20c3ecd9c2395016a3772c8d88fca5c7a4ce4e25bab651e274d7fc9dab9272e05ee5b2ceea82fe28d59c5a77e96b6eeb49c5cb8761af20f7dd1d04e57ee74926c781d7084cd5a21284bc3a40d89914637f110418abaa499dda0d837f905b90b1bdc14119b12b02bc19828d1253a2d6742a4dc960055fec0f4ad44ed521350c2546f896cdd338e367e99d2c0557774a9d6becb8b3ce513c81edc1b527b5a76d8c881bc875cc33fd1324c41702b4f5cdba2bae0b70bf79f74e226b6cbce67672fd83fd069f1b7c1c84992324d9aa66a141ed761627bfe6a27835ad9b019b8de8508095dfa29439fed14cf26be5f12abfa2a13c9ef272e04d8b5e4df365e4eb70b0c76100ddc0b4a28e4aa6140377945494a685b518a1a4dfe316c582e4370586b3b33bf630ceef5c04a354ee4390279c623e89d19e147a132b8719f7940243c27f370815359e4a13ed66424d04776f838e67869acfdd72348805d06ccd9951baa8d50235b98020a2cdc35d228b2d4ecdeeedec4d55f983568242fbe3bcc994d2fdf95c52838400c8f4a711989160b8e591c796dc39a6dd83aec7714890017f78dcde794b19df36bbce0aa9adb1b798645ac136e1193311ba0a3340b182d065794b3c50e6b0cf93daadf7f7cf68ac55a252d2cc669f78a3d261bbadc7adcdaf2761f50de1556f92138ebc4f6f5c20870dd3bc8b4f95ededa8a6081450936bebd268e60407d95d4561ee5181aa6eb8d1057629245845b0c22e3b861e73bd3498aa404d1d987da1cc620163015a1e94d504ddaa7373345caa8b6483ed48cac1585ccd91872e77a93f22e1386e68b18f5ba272ee165bbf19930dc9204bb62dc41bffd9c77000f5a73b5ffe86dcb702f0c93212fc0fbcecc36a5c50d6235592c9b1edf24bef7859b7dad6bb59215b2397f30f8b3603a2b16d7f73cba6021d502a923a6ecbf9a83db8f12b9c8adcd9d1dad6aa506b93fe4d2df824215b230ab31dea95d79d2d81e12805332a3c6e8ac8b3b981c4240307388ed12e8afc5837a2ab8bbeff71efe6ba3e999ae7df2dd01b0b48171e263a8d42e2021e3c16e3001b29ecf966c5d081ee77aa700b9c4131fb40fdbd31cdb4ba89216b1541a1535563e1e31f202295122f933104889f85ff3c610c2880a6285dbd7d7fb900a4cf4eb9856e70c07a51168e6a6d3dafc342986aeadc58a85584400714fb806ea4018a87756bdb11baa5c446ad20254fab7f373ab4af21d94041ea849e158326ca700e4343b2a489738030bd9ce9b6761a19f77d45f753da345e0f02a956332f44c1db62e2711c934122e28b154b2dd5b064d65fa3fd865107aa2bcdc47b0bff8af35975f42db62f392b252f7edbcc31ce82b0bc507f41a0ba9441faa0f2a85c0cf02c13233af7fc4b02a066c0f2da448f1d6d6ad69ecfbe93bc7d513c0d87805d9d8e80d4d4d28597fc4c6941fee416a1a7e279d311f2f75a998e8e0439b173b46c027431dda1618b912b0a381e25d9fbdd234300fb25a8d02272e8a9fb48e9c13358ea58dfbaea993f8c5cbc316fff1309155b6918d97bb30fd07b269f605740c3997e8ac827bb198aa8149bef279a19b51e2a6cc829e36541eee1a4adefaeeaeae9cc5057835aeebea9c40c37cf5ea401267970e30ce8411ba56c4fddbb57860674a18f1ac55d0e741e41fc1525082ed2ec4f21973805d0176fabdf59c3df4e4766a7f06debafb0b20025dc6d0fdeae9ef2a2a189e340171263facfd72f2682f50cc028c456b502dfdfcf600d468e06e0aded1b4c2549aaf877dd763c638eaf42fc27931d43a6ecfa3b5ef438e2e308625298587d4849328c3f286439c5c56a1dd8d98b4eb2ca89aeb99c152070f5762a39215d63f59c616d582c126c24fd9920c2fdabedfc96cd027e71aa5ab98bed4b01908254d4952158a5906dd1b70f0a9b94e8e376f6ac1a9692c971a76c6f796f35e21b70feca9c45e72288be2be61ddf72306554f66fd3d9185d3152bc28e1bf991b543d4d826f86b5892cda9c2b240b23ec13015f1e97ae914a78dc5354c8d6eadff434e9ecb5a16f7123aabca792c41b043443e97495016055a610c1c722225ad0daf38096c7a9193533640e1f0fddc64f8ec279de13c8431534891e4e8d6c8bf0ce5f9a4b83010f2f7f160d9eb915557b04442a7c416cde9a1b80d3c27f913c495defbade5e88ebc1e57634c824b883ba77e60282358a338b39bc7024963af5b01d45a2f6f751216ec23314c96627a687a968d865c2f8bb7dbfaf0530048b8785baa0a1971ce3dff33e87519a2b4bc63d0c7b7c3e29f0b3c6cc0f445f2c2fc231d3e240b80d3c6d587b115a707b947dbb7954d1130c933fa7e6b8a99b33eb5c1b9b903ee827805a641b8c7ab51e1d7c056a1306e024cc928a8e9e630ba1e06311fd4a4f306993c7b43ef31b9dc4d03c53ad358f9241ec5693da98b114bfff1a3563fea63571523d561583c1f22a2e82f597e80bc2fe8c5ca4b0b072f833d3f3aab0ffd72f09e3afe3d2347d83a5e3a59dadaca7bcfb1ae199eed2f54be7f08684b7e2911a76d5a8ebf015c8c83ea709154b8fcb96607731c8995cb5fd6e348d0ffb440e7e10f02ec9441baa3e2ed0de2855853655562918bb0f20acf571723fdb7cd642a7cbc96309acf58eb091d3a8928675b8dae18d19f557e1973f691f10b29b83c3e5b3d1040bca7dcbe4e3594da1de6fb04323d629ec42441ac728d60970cd0ef4b7b817647805a22c6843fa1f75c9c522850e83de7975d64788706e1236796cefa09e785876d8982ab701118f580095add25bc029d2ef16ac2bc3bfe5aafa1e0f83e6060187d1388e7091a274bfb3ba4e7a4bc95228d57a08d69d32668419b416e0720ee278bc286436121d9027aad41c18119cd1e655ee2a5ed6d6c23c1ad6f1e080059dc4700a32d5cff1ea39f54c1622ef9b33ed1784e31b2612a55d582a6d8e021cb94a396c1432d60deeeceda2850f988da5cdee5141e9145cbf35cef3972ab727cc505bf1caa5e67fba112295b762e262b2c14582eb86c9196789ce85c0ad808c75413ac7dd670ee142445ff3561d6203bf81d7774f680c6c1f29c163134bf244a4f21d8c808c36d064e472bddc58fa6b8245aff404014363224f01ad47df50640af316eccc74aca07331583824979ff8bf0f71065de171ebb950b6902196c1c6fad4cb2ad3c4b3e4c8b5bf1d9c2507aa998dd8ec2b612c6c52a6a592bc28d80d57647ab47fd505688685d1ab9675ab2d3d75aaeac19cbed284298f0ce8fbc18b7183ae0292ecfd2e1e5480532342b692394823fbb8face4528e33ca19f7c50cdba512553f83c45ac4800e7fc87652ffb46774119e5d85b1ccfa4ab8f78f61d77a853ec5b2dc0dfdc6c52adce464d0313c2aee5489943257b10bac76e61e02f25d10f21229239cccdad8754f4b722f85519a053298ecb8ccb31af03294cdd9b05ab96d778ad4baf71bf8e8e0b58a59ed0afa7926e8f9f60391a133b364ce09e772137d5dbfbdedafc38e74090bb32e62fd1763075c5e288d0cb09e84501ca40d0ec2bb1f6bd805afcab29661369bde0bd6a3a4c415268a15b555a27f439dbe94cb223cad8429a6afba1295c4caa581d762c26378665fdf802de463e8921883ea631beb9cd83cb42c80aeeb922f4b3fcf62bf55e0a2eb684c374d422023968fbeb77d819dd876858f6f2236f9d4571d50331a2861cea7a2232d54fe5b32f9b860a35a32d58f918e11a6c8996f927fd3f9c193f7dd2ebb762607e1a49a6c61bc31c73df7e83a57d4094c0de23b59da1a2619883f257568b77a73522235ca1d5a06cc960f3a7e52f74fb000e4efcc89d694ed7689191a57f2e5ad5b27dc9df51826a2e5d28f757f6b8d83018aad09b6c6cb5780bb3e78e4bd1bc5f5899b4e06f61ded4ab6fef39a8b62197005c4da01d817d7e9c92de443655d5868ce9d385c9a538b2b6973042a5579f933ea68b71db6c29e9e2ea4549004d1f54186af716019c51cfda72241964cccfdeddc17e1300a82547e83b051ddef828915087fa77100b3cc76cfdc4304c739a2fd7f9f745d897a90b602791014bc81e1b335317ed600ab43e275cbe2b0d90d0f0a46ca42e0eac8ff7632b0a29d6719d080f0803a8facee42a581e49a3c35a9dcf8b47f32a86a93260c59cc64a9b5f917cc6995208428fa8829de78bf7939905cc21ccd173c94abfde9a786a76b4bb6898ddb867e1844e6a3cf3280828f8bfc7e38ff5d2322d030fc144dcbd44d8c62fadb3f44b07747e3d6ca1ee64f481f8eb324da5fad0de851f24d20b84d6bc6ed8a3dbdb63e96857635d1d67deca638ad18f20354b3f3e99e2362b0feec335e5b63288514dfe1c9fb9580fc8fd24dc75a4b8b06050bd7d5bb867bd2351d25cb9590d582124bfdfa66d9c9adf416c2a236f12448ca8e29616935b7351053f4b89866cc138cf326541f40bce01cd5b81087c1fc6c4df15f5a0fc57bb563bf4b720568d11debcac9e666a25d2cb8f5f4c29bb545ea0174a6bf37f6ce3c551bf13fe033c20bd79df66587a5fec2d2eafa8818eb46c5b43a928d928eae34126e5cf278543f4ac1ff280fa9d83334152ad03ebce37553b74e5cf0496a8ecfeccc790e17472ad0d636409455e19cb4dba94aaaad819b40dcdcea5d2c865a7423773098cc80f85c464cfb3e2927e1033029dd38e15539c24d40e398fe63006b2404de1a2237fccc7587151e64b8d59c25810953ae0a4662bfc7ae95b8b6d550353a5d51154294549490e30cdd572888deae41139adbae0d507259860a0ff9fd8d6cc3b3634cbc2dbdb0fc9cab003c98e22b37f3a834229f3b80cc25eb7896e583bae4712d98f967577151383315155f2aa34bdc962394cc927693eac830547feaf24fa48aba353cd1349b86afbb5bf5339d3bd47d49be6ad8f156b1bd1b4ca9b4e2df017f30306f5329d868ac8a319e877789bec6ab00a42762b44a5e41ef55a0a0abbcdf03e2da5a9c21113cd2692194efed3f6662948ddb988d1b1749dd7336490a73a2960180a01f1a1f395b7486bf8f64c3d5e0f1e281ef785d7b578ad6faafe917ee2afd70bd172d95f56a169655037597d916746f8031b356ae3e2fabc77b2127f5dc6867ed8f8f4e6cc032e84bba2b84d7d3265b234c517000a923b96c0eedc9b63b2940d6202a9eaeddb4d3b929843e96ff25134dea5d2220bb82c4abb4abd43dbefc5705a41b91a07fc29c8d684aeb1a19fe08c9b317773805fc814c02a010dc456a465ecea32bb91a3b384a47d929fd0fc264f6fb7ba15a381c75c4b2e54bbbd024a3348932c70377be1d51e40eb83273f2b9f85f3246de80785052f6195d6f2898ff470ab03e8333532b3c00708b661b080fd51f13100c2ab60a77f2d9081959b085cdd77e1efcd12a38f28c895a426fd0d256503722caa3afba4c72a8b7ca27c404ecc67c54c18efbbfa30878768775b3d20e7550fa2de8b65a1e2be380aed356a76440a53033d08ba18d6cb629fe27645a3bb333d590a047838ff9cf6fa20fac2e7bb2afbf47789e765a58d660f1d780a6bf693dc76cdc749a95b5fa61e371a853bdf30866bd021bf16d0ee50c97da15e77337b6ee5c7d6ce88d05c0cee7fdea1c1a05bb53f8635fd52c3282aad8bc29e2028f2b4034169dbfa57d0151df9230d24533ca065b64a39599c24286ca2b29b980f7af0ee27553f6cacb6161e15cb2917894c541ece08b1a68f454bb8f97ebffb4887a0734ee5497839f701c87c9c37d3619c234078ef7c31b69759da1038187a4b2b42259a7e6be43fd869b79f79914a50a64e5e1349c0af06332da9504da4acebfa6730ba16ffb3b227c570cf107cce8c57f3831e688ae21d3bfbb4d774b9c7315131c386db323de18cba8e1330e4a18102dbc5531da2c8027244639b83bd8a8b71ab2aab205ac016fc44d3b128206bca4a2c2c09c0d00e5e6e76214fa78b1a457da386c5b5498128f8b356b95ba6fd91900221b361ded0e68497da89d3d89eff350715da0ddfd4cc9d724dcbb4032414c1afbad1cc1933d5119eeb3ad168f8e31d561ca01e69a0a16e4ba5b4943b730945660a565326e7bf1c17885a87f3affb60b332536d7f41b56e447278e4e7d5ca2ea8cc5396b079053a778fa3dc3078b96b4b0f6c5f2673c678fb20418cb3de84f57552fba4412001c6b04f5a71f10749770c0f078545e03237b8350981960c46aea6b93cc4f1ecd5fe65f42eee2b513914509a8fb1d66c6a34f6785fb4cababa3e6e3c81a81cc665809b8321b1d76ac74600cb1df975c64fa0d930f3a0e0b6a3e0118c7ae4da1740d1faf734b5db88a5eed1fe9ede96a81c37eecbdb4ae9f26fdb1b013b8cec219cf39426334e00d4d9328423ca8d25c18e5ab14f8492852906a59568e7b33b0c349eb89ecc379f09515fd846ba0ba66005c118ffa7a96305de97e38b5f956f1a761b2e63ecb383ed22ed46cc90e8a9b3d6550103cb0c0ee88bdff5a0bfb18250c6a57da7cca93e3dfee7372d37033aff1fb2e563e0b275bfbf6cc7805b45a465dec79222543a5f2e5572d70d57c1a8e2cabf1d08eddf033e6fcc75b5fd8140a205eb2aaac46fc119cd8eaa4286662e7e9112bbaa6b4496f0a569a2c3fd3dc6100686be78ab79f5a40531439505b30af2f7c368a814b8e525ff94ccf729d57741898d0d6e3125c1bad6e7ba45e7b24bee83b36251c9239f3d397af1ce6a042c9930de2c961e7fb16a50c7653331238ef1307147134704918877d4e13f8594e6f4f744a4193f144c71ab9a8c684902352d2b5e0f2ed72147cd03a5b6309b15b3c718ac6f12bc505658e7c4c44ffbea5f74cdee7b487c5edeb87323bb7545191f05fde9664583d7a642f416f620b70cbc7","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
