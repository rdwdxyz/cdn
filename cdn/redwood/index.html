<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5ebdf61825c25cb481614b7ca93c3a6a08dfd8ce41efb88677dde0a2f7e37d1d4d3d74fa1d19e93d7d14434195186b2c87ee7f1bbeac513b6ae742dae474e859e9c5393025b873ae67b079bfebf13a881dc486d823a2a95404d777ba75fb659b2e5cf92fbe34e941a871fdbc27191075fe2843135abd492b47273c725b5dd1d0e516590cec29d80ab728b0707e84ff4142cf76204362f96be71ffa4b7e8fdcbffab903ebfe6897b1ee6ddd0d1bc06d36263dc5228d511a3e56573bbbb441e97a2bb6c3600ca153046efb5d84e69563fb6f0ba80844cf510dfd09e6cd8617f7f161da3ca88ae963f07d2607cef07075486eda7a8e157b36e0487ddbbed9ed59b652b37c61e80e8de1e54ba6a03ec8feeb158f0b72a3614f0cde12233ae2c1be720871b902020c2e426e1bac883d0abf64ae33c19861d481a5d1adf533f673dcde4fb3fcda14f81bed898d881c54f9f9d4c9eff00e4fb99863035e041dddb0e94efaab68b21bf010fe1901c504fa6a94223c6851c3775ee5a441044b77b2e2387c71d52c3a15ee5a3c6684caa7a844e38ac08e3eb34e387126f0a45af0d7230cd9d46d73ce59b6b2f682016f36241c15e514133ef7c270e6b30568d749ca18493d2c908b9980d1117622cc4584312224d2d0722e16293a423e2830d38a42870555582be7cc3dcd83aa5b546522662e945240a61c3dc706f83afe39f4472f5d237c8f81b875c52113995d8826ca8f7f093eaf6bf8f69d4fb4f32688306e319abc42dfa84bedff4191bf66af2224c649421adf648058278cc0dce7021a3d4287da7bbf2ce64b1185a8e2fdec900c9b6ac2bdcee664d6b29433d76118599221fe461a27707cb1dceec8663fdd21f40984a0883b703625c1f949a560a6f29de3ad1472a693115a829a51aae954231267b60bf52851ba5a2936515bc05f5a1e38ede2ee30fa36b74b421030137c7bf623d6aecd8409b1ca114d4f16788c3edea85ea174a7f673a0876fadb26c430d1f91952088f43a2b997dc1567d01a0f2332bcb540da1eca38a65c46f9a31993df0bf7da73269ec135375dad6cd17b67a40f9877269be623c313834566dafa84250ecd8e8693841bbe830a9dcb931698c00292b108079cbbed6bc04573ad33e6a9e8cba57fa8e99164b2099b1886437bc6625992d524844c7576842edf833a779083cfe99f9b83389156813dcd2767f58d0f4441edd4c7b5c606cd011e22cbfcb3683f19e029d77273b3140cc57b61307dac25fa14e28cbe0961ceaa3d1085966212ef8e86fe04ae83709e6d318d8a7c0f07a3a6d2270f91497a4e2aec506a1202c2c6387b118d5e968a1b0947c080d1339e8bd45252cabb12e65395af53e418fba70815c9478496a1808647c53322700a7113fb8b38f196a6a11a061122280bfaf451059c88067f636992ad496cf0bbbbe08bcac516e9e5ccb2a681f36993304b2546616f44d235f260bd486e7881e29149718bfb2f90b605a9a252e9652bacf2b227334993b242f56ba000e07a56832106e8beb87e2ecd1f1633ba1720fcfb8bb873d1fca08f0779bf1cfc77f7f348c0a981a8a5acdda857e6f71fbfd22cbb758fc078f68fc105c607dc33616fcfa92bcd1ba1c0141e764375521c42e1c565dc912b3641c83f7311599a0c780b64da6dadd6257b0780c75dd7fd1eab32e20b9bd2465c29ef3e7c000adadb8987be18e48e731da7989478b297073729f6b12b1ee91920965918ef02415e490bd836506632cf2f11be380e83ad7d207eda3c4cb71c899a5ebc6a5452d84f3f6e38e974efdd91cf775b5a2946b077cf0448198a8c61e6f2f7c785ae3d7be604f158295fabbcfb1b82db0205dbe5fc999de114636f6a97ebd3d55ae71187cd27c8986725bf26e8d23200d3e06496569ec721a5fdb068e2ed5ff6101704869370e8f0c349508724197e1876585cbcdba85c10f8d969bff36f166cb911f365bb2f974fcfa9c4bb5e9b9d1d9cd2008d16dec2b1f43c308ef01179e991447688140a1e190f9c3878b251a6fc109d09f21944e4f16bf0b2d2ab59b8ff04440c860473a90324ecf1fd455924b07a5d79cccaf8befd9c0c4ff450f34ed88c8ebc335eb47054508b4db9d4a1907f8c345cb043bfe02d815f8500427ab17cf81c5f44be5232b4bb1ac4c877c01e59cfe2e2a70f96414d779d1a17dc673ee4776974c822e4471c862f785137de3454881d81b3253f58ff9db9891368fa9cb1e9cc41154a45e93ec92e66be3c71681488c0dd88f983b99fe807c4d1fa81550656a82f6fe768a798498732238d9e913b978ea69f94cd5541268279de56f94801308e2218ef30a9b11352faace42047e915af41ef4c5179f2bd1614078e9ffc0b002d1da520a4a7932c5c5672adf550630cec473002f3cc4efb6d48050db4c9c937823eb86e28d662f29b35739ecd1bac1bb01cb6e2960203564e3ecdd23561e5610a242ae2a940ccf05ae60c1836f64731d78ba4d9745823bb7ca1e0d2940a790867d0d600d11853f7e0c91e6da0696bb5f10efe7c0acb0fd43dd04967f241c5c571e017aebb0fec9f9481e17c9b5ef0fe696f276b2ab2842e37fad61d7005b9f4be927edceccd42c0f57eee78771e3f4e0687743aad85fb5c7a745f8cdf0a9ac511a9e9a7b1ec2f4b7a1e89d960744f00423bb11f416e8defd23b4306a6a6a6acfed013acbbc45ed694eb08977d3b6e5fea49a09c37ff53d2e360bfb2ea44a68fde3d3236138b34e3da40f5d51debfb59b691108d9fa0e2a8de7de9d8d7ca512f8bca82fd8668ed9da6d30e42b7511add361782bd6eab66d30adcf4a3910fabca76bdae2a5be66ce7a5168b99fc9b12a98f85769584222b2106ffbe087edd62c4a691ebe648009165ec35a210e09159868b756e3c9a499dc18f1b993855628c63816572172d716993407f4a45742ee5493ce55352a763719692dd129888d89e41a70c2385d54578fde207f5a85fbeceb2c55414cd30183a8cfe62e571c5f891fa0c32e224fecc62c55aee109b100877490f3f0e6e19c8bf7815d3b5ade5b2361df146eb15731e81740d7c57c1de123deaa05d6a447cc31ac5480d82a2f19d64b266dfff961167b69bf8aa6be101aa9c85c9f9904a07d3dcc80ed71d41e7f3729a8df1bd8a10133d9134ecf422d7c90e3965d39e9fa8aa5f97ecf2b547366c3b6408b6dcb27c0fb14b45cdb218d2585a67af82daadd039b8a83c3c4e2eb51a9412d4bf155b6215c8f11ab50abbf66d67578d1319af5d7fd3df3cdb47c973ca0c72a09ca7fb5990c3c89dd51228f84b85cede7d969ff2b257b0457d5c87019843be01d9613646407d2172be01edda0cd11ed2ad9b9b3a8022479a6c539d4b23b86fbdf8d4f16657816fe477864f9247ff3ac0d11dd78aeb6169ddf2a0c6725052df641419db924c4414331e812fd35fcb0e198df142be9a2d917a33bf92dcf550389d6813ff177b8d23aa0a2a54d10623e688062b42cf7e34e00b1b9b7a9e4938858c009c9be2929422f11411d7709811287649549d4cf9ea4c0d17893d63fd1b23e49e6dcc2a3db4262147a353dd1ecc5fd0c7ca9b8891e617cb5ef5e7df652f33507271c281044067f51b9141b6bd5ec4b2ce978b7fbaa4bf6048bc77a2ac8616b89e8e3dff08e958aa7bc16f977d1929fbae426e4a13c462f5a4e187336ec48a988e0fefb8a51798fc7dcb21434499cf2384b54629fe115fe3d3814d68c0b557919e498034eb865b655dcac36f5c6f23b91429b8a6837b1218cc706edf2361189665630df45d0f163ae6e4318844abbe692236881000ddb555c0efd775b47d9fe95a5a144d655f20ea5111d150c081471e28fa909a04ce80f9bb1c04038c78046617747c25ac294d72b19d1b75c65c3d8e5514c1c98862a16c3adc84881670a07399627d248a51dfe9756b16a9c65d0095b6389a52da0e6d92eb21aca2c06f2356ac71f8ee7fe72da35d73ad2c3b0dff1f7cad0f075cf958c274a1eff741b038465f34d39754e825f4b996d058f84cafe0b02d782f2877dd3b76b6a1bd1737dadb66b5fd11f2f99ce2dc6f844cfd52a42a218c9496ceb7c139fd912582e8de87b9f71d50a6d5d07bea6dc8ca653aefcd754ae816546ebe8b846cfe21ecebfad32823663ea7a8896145866ce55b53162a3f7e96ac4b090aeecfdea0e5cd193eb5139214f3c4c635d7f844d0ca0fbe134fef26a5a68098f743a67dfe21f3dd676855db93dcc2df70306b5f066829785dd6c53b6b5bf5c3b1e83f722b7f7d1c20befadd9814da569c6733314e5717b7a50f38e635505abd9330bb470ff84f218e1ecc0f610d66a306b5778784a4c8095b18963ce00979074ca7e973d7550d47805aaa72fc020c4e9fb021fe88ed5a6541add66cb9c2a20b950d2b0e0b4ce6811ac8a38ec013d727167df8ec0f1a9fcf6601a59bf4a2471fb995d9834d38d674d5e9dde3cf84c33040de290f3e1269801db4b74765d273e73ae550ffc90fec3aac1d15e3e24b245f9dff7ee2e4c672960842914a6476f58afca232fc898dd9a1618ba871a957df6f73b822ed6b1ba56a712dfe128f1ed8ed36316a1c78e677bde7f7d3bd23a164bc4b5e90d3edba57106d4ebdddd3555cfa08524a7f4198848e23cee898a6d46c3a53b954eee8fa58329940939076f199c5772595a9d6d967d95950a841868d46fbbdfd8ac9ef83222cfdc30c5e84994898717432a9be3c74a87c6b64dc318e335f5cf773562a8daa734d06aeeebff7fb6bce5ed5855a112e32ec83e3bae6ce9e7c194898dde682bb516c4fb4050dafe5aafb7471b62f6120b11747762eb382a7a487c45b9cde05e01247dfa8a9cf3b7b4d95662dc15b891d6f3586899a3b3ad7ed3ede3d6cb1bfdac158f4082dd56c08fac85042b150abe66d48065a4cc50057329618b590786d605d3b77c043893ffe2301ebc8a95b18fb10397e78b7947ddd1e14a0166467c52c53f227f3263809c0251892a9d2d17856409e621667c33637f882e28f98a3310ed92ea3767550aa39e1b8934c9abc382b1191fed7d98a5447319ee9c051df41c2492addbc88319b250b7d5b71917e596f7cebd6e9909135e0b1b0e2ffeb1b349f7521f37bfd9957cff9e0beeee0cf250fef5c55ec08427d0a4169b46d591bc25f5294b0857cda7fe1e8a8730474e6a267b55cd67cc19391bd6085293fa64d326fb0fc37b0a28a01b3d4a54a706426028d4652c1ecc6e2ea8f5e9baa89381efe8e85ee1f22bdc8981cdd4cf777ba389c4408faf86d010a7ecede981d7c9a0feffa4483303627df2046cfe7ddeafdb67b5588c05c217fe0b2e5fa914d174066a5634fde1284eaa9d3647450dcf6033c31b2908a923f73880180c8fa6316057b9a01b4f9d6311cb72c0d86c6ca824adf76ff292b73333b4f8c9d88ad40dca4c1ab63a4be99acf4310453c57aa98147fb320365579abaf9cab273327895120b8df991798eb13d696762511bf66cae36642d30f929517dabe69925d34d0da73fbbe36f9aabf597dec65d9f1f48843730cb16c57c59f5af99b3ca00fa59c9d0453c1f627bfdd1efdd33b7bc671538edfdba4be6d19c885b65be65b9d13d34ded4d2da04eab97ccc289f189a95aade1d2477ed1ede4cd09aa7757d1d375bce3b1ec6032a795eafb14c859a44381b17dedec967848c3df0d12bcce41beecd98bc975d7b83dcad1f2c318ddd9e31cc89a55468a50fcd5f0b0bbd077e76639af1733cb247e358936dac21109e8b7eecbde6cce1f5bc686ce88a7579cfa693075df248c9dd8e062ed573ce570294e9532419a4fdb5f491836755f0443b0417c03426d3ac4dc588b38c755426e004b15f8072985e6857472014fc4bb65ed358b1570453598a5ad18192d91fd76dd8e06001b4af6199962d76633cd75dbf84627c697f89d19250fa44f04946cf62c582f468cd58a0126537e910682b37a0e9a2ea7c17a96574f5811a02c2865e230177eab1a2d027c87f642319bcf2d26980c27638d66a860296fcb714ca0b2f1f3b9e42f4eda821637b35f4777b7a4c22a6712ac9ee86623e3deecc95b9fb40903ad657cc2c4b959adf6d985d23c9f9201315a9d2832ce0e1c7c933ed65b653e30b6d35e4bd3d969a549b5be8cea9f118aa0a8492ddfac46c2e4e816f5575ed741c6b44b5e63f9c715c08a396cfb647dd3eb9c0d0a106aad1971de92143251518161cea483a8d17ba3de1b918d79111292b1e9a239b224ef07ec89f6585184d11ae79ef87b07f28160d3cba5021e5e1511088ef9f550636c3bd98dc10ea4c76ce12cedfc873de65c7c09dacd4902c9ab46831620eaaa52c4c4f4d2f11e4ae556a2cea340b9a8e81905670d6a9878be14c050fac57f26cbb0d68c5383f7557ac0d23cd4d728dface278545f6336783b193595811f4631b502cf0dc2b9fc24362d9db00e052c950a664bdd3739369bcface52a02af58ddac57a39df43e9017f51bd1e463fff0888e47db9ba06d5c0a638771545893c047d72b96e44875ac41c2503bd0a3e1be9e840af8b4ac73be01c9a1f3ca74cd061c7d4cc564ffca9881278283c29515ab4f557e57dee9de1e4920e9de6d2fd19f5a84b5cf3d3e36e8afaee0278a358d3de326681f7dc37f4aca12e0d33e9181370a055343cf773b58be2d9e7e65317260fa6387eab9825b167cedb5cb9310a0ccfcef51063c789fa4990483a481016cb1f1a322dae70c33d396eee1ab8df9cd45a359919908547e103470133841b0c1d224737db46b4dc0b38c636a5d39f1d3c450eb9cdab2577f340292bc80e3ab2a208a695161f4d3afcb10fed4d4dc7fae1fe4a11360d9bc37645d0ca5cc0c74773f738db0fc7198dfd53827029704aa326327448faba6679db8de0b495b28215365096e2585c7e7342c9e3a5dd1ea914e3a3944810debef119e8daf29f6632add84134b8fa327ea40d98001b7fdd16789923f8282e355cb86be4fac7bf80523e74e8995785ad1f2dd5fbf33226e54dfdcbe75542aa426c1659802016f8c14f23dc2cc071a00bad15f82bbe1beb8997a1bfa01571584aac1f0de5d9b80d42d04ad90f9b163f5992b02503fde8706de86ed6a3e07fa937531ba8a6bd21dbd62c69da9801e1aef3ced293fdd102d2210275aba30dc03aea3d2757bca93511aa1fe7959b061f55444134aa895506acaf29e7de2ea382f6a1eac58c0ee0d2435c94ad99839110abec248da2e200d6bd6478fd19195fe4bdf9b514ba9a95ab1e40b7ef4228bf6ea1e909b76f2df4708dd19974e345827a9cfce03b5d2798ccb6a464004bcc10544534e051c0eaa667c414309c288c9976bf981bb70a2a8a6a222b87f8eb21dd7dfbc6d1c54e39e5311c63ca7ad2e34736c281fa5091e9272382df8fea920e6046a16115332173abdc8d6d1dc29731ba301871f9bf38638c8d8ebc2ffe3c2115a30ee810c0d2b5acbc17031251dce5e5d8e7a0182c9fc5495ae92013ce68444b8f763d007eb54a6dc36cc2fda5851fc2a42ecd50a5dbcb35ef6c700f73f15213692ffe59c78432ac3862c4746b0a0dbb79aed5c1c175bcb725cfd4b572a298b497b14a4b58ae527b0a2bd7a59836efa68345e21d1afc6676a3b08f0a06d417ed55365b5bb401c8c7fae736c2d4af75202d77e2e5a828e60a4afa04b47cf56e20147c76435dd7c307dc2f69ffd8f93325103ba4af5031dc4d4d3e6d048568b781daf295c29dc3ad48c63884471f7ddbe358fd45ba028522f9a513f0121f792dc5386711d343ac9d1b102425f5cda488d0cb3d4a958dc0bef4148526100272fee0bbbc879f31b30914637069da83b8d17b0868f41a0fddc7e4869023cc22afb03cd39691f228eb615ed3134f782d41ae1677811dd6f65851e16e63a2f9f65a44ec68e256a630999a3c0533abac4052b18dd331b7440e8c8fd950f76f512e27a13839ab37190285adfdeab12b63d102f45ce7220cde716b60d2875b1e7943adc62aea1899bdcbcd4845a9f3ebec37c3f530981edd96e77d15b01b4cc265993df14d1f38e890f925c1005c4d59ad4089bb16d13765b807b3fcf7f3156b97c2c4b2e18096d1e4613cfb12568c9108d0835a177c65cbeaa2df792d606e4521f3f247132e7a5de92c756c5c8f89ecdd09b1ff71a4ed014a03ae2f6943f79aaf1ad767d2beea7dd920438fc13792258c45474c1c1da0a1c7609af24c8a05cd7f880d9b5cd8ee5740ddd227c320e3d0242dd409125dbc36fb0e2dcfc4c6b437f3c077a0f75a2f5a1d418196b50647a8591c7fcfe01b74e190454136c31170c795da8a0dbd1014e5bdcd005c39c9877cc96b4c67dca786ffd5c0b61a22248c32d6c4c70bdfb2001d96213ad6ad9474d9d455b3a3486c865cdad2d3ad5cedffc2f6ee49a4ff2566de58219897691d06481c02f01be487b6dd9dbc3f86277e1c95f683048089297935d16aa8fcd8019486263122f5f1fa81eae8b5583d8914cf89bd1f57894f45065e5bc1c8a998f017c2c68eb4c58aca8442c913910658e1d725f352b28c065f983510b103c16b4a892bbb06cf48449ddd6d890953723380e142b4b835d6f81c4dc6ac28596740cebd5172562cf7ec752b4ffdcb55d63f00f1dc159fae5848484070baddb4e94a7495db80c5f3864b0f41bfac4196307a1eac846e132ca01350d357547fe829272eaeab2ea31fa06eaf20a160c0292327b3635165a34c9ffe83f32b9e9e94847dcf4c3444ac7c7410a605a3dac3987acd42e13ff8c9380aec386b59119f18b1dab37ea4d8a2412b57ca3a4957822b196da82a601da2f6c9853b5db94ebae1b8f26324a1d1fd06deab56d235cfd17b9399c6139c55421a778331914ad2fa700e178c7a581644db5af096fd1517cdc7bf26964f5566449b656866b11d24bd27e94ab62c0c4dbd2e9921e86e748abdea42bff0b6726022f53203dea24748fee4f3053a10d6d2d63cf43b5c7ab5dadf950b230abb3e6dccc10fd485dd65f6596886608c8e6f6307705b53e51744b56d21ea53f255fd0070a4c173d7260e2deee91c6170118692f575e4fc8a73b9e511d1f5e6b4da6f71eb560aac82ed66b6777f1aeaa29e0417fe8c504c8ed8a2ba16c97c9bb9cbf057ea93cce0cf0cf3a49c3800dd924276b17fd1215ad9a4722ff7a38a2fa861a18bb17d1499e046662fe674590fad687e326c3ede98363d0a4530a90ad2bd6c93f18d8d4d8b399965d3a01ccc5b22f61d30746331f83229e2bfe05bc510f2a3aacda90074eefa3c5901ac71b1a60d6e825798efa03ccbf46b12c1af4862296d0d5853e768290b61132fc9aa7528646e56c48e764c104728e14404926a5be26cc329663eaf21c7cc22b20cfa17f6f657f293431a60eb1762b3dbe6cafcfca804f81079dc6031ab0e44f55610c5c4ba0029181b60c77b51a355f85919dc95afcecf4804446dfdb1b879839e64baae38968484dc286b922860ca6d6218ca26db5fae1196bed2789afac055d4758c7d5fbc09f45927cf1c5c486f61988f91b96c845260370d69ecf72dc9dd486857dd75acffb5f91f29f0d7ecf9db6422071751035eec2608b299998d87b4109255e78268be79f9ef8ea85c1bb5318925230e9be9c73b8ba7e88f3abdb0b38e32dbb2a3c6656e9c41cdb69db6f70807d8084d7efcc426b5365a758212c8bb109a7dba8777364e025bfcacd8d9288dd1cfa33c195646555a6a5e3a2ee03b3b9b9b2c04477533581c3c2f3849f96da9fa60a75ea7c47f33721fda9550567d6b8865b31b7884fc3b579d094d25e07338a3fdb2bf4c1c6353504739d7268665b16f2bfa67e9feb605a2083d467177e63d4eb1837c306921e10e627ddd3edb5aaffec4e5dd5f94cbe619b61b4219ce46025845b1e8819cfa866d28a29f06695858c7936719dae7c4b42c0b2208a09b999c920d1e20cb345ea661ad945a4689e0d2f4aee95e15d9daf9ac9bbda56996671038644164256de8cce0260830287d06dbc91845d82ebc883f343dec8e0e52c21bfa9e07f21252f482459de13553d28bac4629920019d3b4fb28973dbf845270bb59eff7615ac5d5ab34522273b701a8a9c61b032fe636f7b8318fe596de43fdaf1155a45525a28671e49efc5e4222473c8919b559bc21a99120d038f0c609e89578fa4a7974adba438f890891b25af36888f92556135beb71857801ea12550a3009020231ea08e8e073320d013da7d3b076c6d117e381348a5a6588b72c4b165ee5518b082642bb7a8a7d92c66621c9f1ff03adbc73713a96ddd1095628480dff59fec5304d826ab72a51a47b4a5f30e49ee31b309d73d29faf94d255188cb9669f22a957a3d2a9f6785a47bc6d59d207664408306456e346bab615c0dd010e5a63a6b3f2d3480acba2cced9152d6709f6fc78963a31b0740e3308fc1d7b0cc934df44f3ee92ac24e8a10c2ae44d5402a5b72af2de128e55d07d6d7abd735bdb6b24e802492a232c10b49cc7cc603059a872959c4b6b8545c727f30263e22ec7cdf888f18ec6ae99ed4567ebc6cde62e8f6ee6ca301c94f9ccbf0878f2d46f17e9b600778f74f605b0ee4e13d99272203ffcb02bc3be00353030f23c969809256c43264aaa285d9db647a87896c4018970d50cc0cb23874669889da493106ca80dbb11ec1f277a7e31df89af8a7cfdab75d66db2d7945ab1a495afe5aefd969205b8773fd8dede641a9c1164cdb8291e60937f9fd2b20d3477b053b6c7dffb67f52638c897704f0e0efd8da60c5abbc076f54aba5c00b07489d0f353d3103e1b2e980e4756dd923b43ad68099286bc566041fcf39f511dd4a3b961934cf642ed775d62a74a37933a2d60f4f4b2501ac102e86fde9a355d79935445ece6cb7d408c2ce37c22b6c70ab558412db3faffc5e27dc367404f8f3ae61019034f501187f7469da14cfd75fbc9ce9459ef592e4666dab0f7204957e36f4627a03d834554da1c41318fa0a38764e4b942f13490d693277da54e911a58fdfaafd60ea1eb5950ddc6e3318c458aa88c389d04a0b4ca23a511e4345b9b63bf8af56a33014f0e35f326e570e12b7d900f44aff7e01969426c4e9454722e7e9edae0d0daea64644e734f1df28c5ec44144fe06cc0f24550de6089b8f4f76d168989c1b86bccb6dca078c17839fdb50d3234c0f8356f1aa188ab382fe8c1d3fccb00d24ece5ee9c78e771a85fa06217dad910d8d180428794df05c944ec015f354cdd035ecec47c38a6da081a180aea604ff082c02c829121c1cb1682bcbe7860337ff51ce6213f1093e69866b7f82641faa59df4cb28fb561ba4e6c6e97623be931d8d246a9ea4462e61c8e836240e31e9dc0eadd14ec6123c55e5df3640469466f5546b6c64d03216648e85c27d23d6cb89ce6ec87d2caa10dc868c2d027f5b7ce3adbf55c0a147ae9ec47f1413a7a18c4be25714884403dbb0a5e6d60c95cd1ec9e40de174a0d40ff6bd4073072b748ce9d7189a60356467cd712ca349a968203df4e6571131d560807523663343d70c6d9845f1c0b4a41a7043abe938c7cab5c453e6cb7915b5003d060d2e1d732bf8c0c3b3b6b081e72323835e26d340f3ac77babf7c2c6eb187d0a390d260f28e6ece75c5b97c63582f340f6d30e2b910311217beffba7b57a3deca7a0273ca56de99452d9a89758fd5543722311819d3430afd210eefaa9b93c38dfedd355b4e175fa50a877a77f29eb03a3324a54b48205259b091e2b51a3134fbbd8f3a2b571279e7b5757feb4fd3180aef17cad4e7903781e73016069ecc37ef8b2f1e7ac23acaa443d2a65680483212376fcb1f2c74cf2b377deb9bbf6bf8a0a54a7e124131bb16d04554465101c9a3f8b9f8b025ebf946d8e382d3aebc4df3acdb8b0f4ace17cbef174f4d6d543c6dc927795be5556cca767b4a884579c436f5e36d533d67f2f2acd5a23b1a6f50fa4e2762512540a448b86315a41c2c0ce626f146ffa7fa909f194821c874885194a3ba21f713af06193909f2bcb370c4416a9c9d7a15aa64f870a0ebec659e87c323f567fa4a5db1d5cd9ebc62aea976c212543fd4df29eba476fe888f79338f73f10614491988447150bd54ff9ca80b6e1099066ae8722a3e9dc1f314493d6f9e14d1b95e61f4ddc1a85a69c8b4ef1b42b752f8a4df93eae06e8cd394a69040d6666ede2ec4ddc525c8351c890906b51438f847e2548ada1eb073b501d5b4896b1f6e01a99b8aea160517e533053a8b747723a5d9fb9bdbf6e2b51e5cff35e2edb645931770d05888d130b67826dbe4614ac3e5671bbd2bfa0cebefd6eda05c5c5d8347b257472ffeaf3dcc00886477ac360e991dd9d9beabd0eeb14d3e12743e94d6f24ac00b76a7b5f220396df4c7dae11595bd8325c20341a448bdb8c13cd1a79a145aecdc87a5c6511c07a63f84ff8559c9b489903bc519e115a13e9ee9bef459462590bb19d28f784708f7c2beb556a9df0194ec3e18ccdcbdbafadc4e147b64a8fa4d00a0f56cd940a9fd8d4846adeb5627ca797ee9f6f592a5bd39dc2b2da1f74044bba86910577d4d47458bdf1eeddce0d9e02edd66528cf9f1356653beccfdfccf89f0f25ac71a0efc33dce8708b06cd49c71904a2fbec98003ef5473f961ccbb40b8226cfa99ad3c0b44d839b31c6f51d97ede554e421a9f0478d899d911d6800b05d4f7c453445e0e76228c9f3956a7a834ae8a5b517f6e384aa5a2294595213f48702c0c984ecdaa07e6d783ab7bbb41e0d4cd84f8798e0b6cb26afef946732c853e51edbd478eb36be2a1bfb40be65abd9adec4db418d9b0529c2bc3245e7e3cc2acdd320edb8bff192ff45a2b9969cb06645206820b835363c21821d3f7c18e3f191d0c33a8f659b316e84b38385d9dfba213b467367f0602dce8a90cca9bdd3b3ca79e59a2bf8e13231150d4cd13def77cf33afec7eeeb04cc7be24f9a048456d054e9fefeb8ccc950d7bb2886cb08096cd73aee516b9c8f1bc752198b8ad8c92620fca69db297d5e52932caed677afaf3a2e054f133e6e5479a52a83f59ead28a007f0b2a15a16a58634ae209c4fe80e8ae3ca747ab4572201699b29ba75ddd9a2cbe479d666bba8db1433a5cd20eaccee4fcca5e91b42902c22a39fcd262917c08496bbb2bb60b54444e7634b45e9a74513e1fccb73ed344d6da45d13e4e9fae1a106687386d43491fc571bf662bb1e407e84cacbdd31423d056cddc6de2ed057618b376556805aba7c8fc47ab2626214f91aab818549ef3b4b0cd3d011248ca755196a4d85eb725c5b15e447823065431bdd7b005d5eaae72f3ae30ad343d33c8efaf36fdd1a65a3af1f4a37c778aed4f3fc11b4d69176d71ed1db1dc0a90ff48110290d92f47737eec947c860843ffa12280d27a336e23946db52a759ef38b2b6914edb08fe97835ab35e8e21a66fbf5af5a2d01b642acdc499681bd03f9cd0e9417872ffd0568d3e7a0276d50af7ccc9f7720ab8f532a78bce450dce5ff152c3da48a8534d35bc4e6d94264a61ea5a36ab6700a6da4573bbe02de4ebb1e7c25e14950b21568d1f21a2efd3a3d9e2b8a9fcb7e017aea44ecab795147fca47f20ce0ccbbe724a765c868bb4f4c719ad7b0cabd8019a15d2a3fb1a9571ea55e484c120f16a0862be879c02e31955a12d1d86d67f4fc0154912b75141864329bc6e1fce575e051d70ddfd5b30f82605374f89e6adb3b6178a8d8d92c5d1b8b3ab3a4933880b1abce6cbc611b737d67efaba7817cc992cdfe7905f8ca94cf4ab018e10050eca8de56b17de1a443bb20ab3d54d40c390b822a18ebc6378b24ab827b9cea9210c8143646e7855985c51b4b072d94b4b9dc7da6c1dd3ca63d756abd40a819c0747d93d941f23a6ce7eefd0483540cbfd1dc35babd834dc9c936f2321d8c8944914e743c4ba85ea46ece3b1b7bebb918befb0ca28bea881c4ee55df3e56996c3ba44030bfa643965261b710e3e7ca6589939dedbeabe0d98537b477ca474309c1b93cf098abc26a778ad2dd7a48151ddafb088776fdf095ae96a3a160462909382cea1758332617ea5fab4bcaaa2a7e4d297dfa4dbc2d9d128f4e0db0c5890a7d136c8b44485c74768ee74bad637dc5343306205071c2917fa5e0740423f722681e8b9aacd95679256c2ba6d55cc3ab4cf598b855460244ad16ec197c0c840e9ca31d786a04d208145da7482216cc7ef673229c77158705fd4cd66b97af1aac6da3ab3bd4a94ad84c7dfb3640a9b6715c80fb9b7d88d49adb0217d3a6c74cd30fa27eb8148a7d95adc23456a668bbce1c9d2b0cf4e2e1b29d60cf7be59e38fb1ef0c991c596b0a6d3f5477f5e23b22dde81411bacde0c2ca6b1be594c920910be640dec288d7703e261cbc07e2f9ffc0ed7d8c7fd41593bfa705e2d35749a64c2a602c88314e6f330d83bcb8f270564b9557e909cb44a680b0553974248d4d20e80a821e7b51050e45039c42dc575d6e0b0924967ec47719c7f984e00ea64d28ae8ec5b4b7a104797724cc5423ff67460e5f8e63c6b18db56a0ec9fc1194dc8377b085c97e4ecf2b63ae77bc5fc9e0b2f483879f2b74eed8354e9bc7bbe84b4b667b39103a25ea6394f0cae2adaca548efde5a35851d95a2f2e87e41422df36bf906cfb0f59d5be91778b9fb4d672b56d6b0c069b99a73d30f8b0d772ecf097bd782504d626775c49e6cbd095ef5dffec30a817f11e1a89c522ec60e006c3a4f01c1a9ff460bec418d092df99ba3ef7acabb0569f9667872e3ef16046093a382b402e65f2aef8f51fa993c089d630d492a819db21bcc9ea16760b9544dbdf6c2deb37d6f97c37979254ea73d00e8748680a86bfebf91a0cf08df0d676aec30cd974830b5d938325cce45e8aaf73581a42badb7c43a572dd7d242a3254cccdb384be903efc7d3fdd2637286a6b8c3081565ed38caee2580bf7b689275f523250be020f703d68f6b9a291b9456a029fbfc454fc4ba10da25d2d13798e77908a5c611a82d441ac7499d4b904677c72c8ec865df025473ae7023118729551226928df0994b999183fe921a17a22058f6a45e17d657f2f9046f990cfa0bdc6bfe7e9fd0b1e801940a78d6875a4c1ea4a892e56f5fdc2798e5bf2b43e754f84450f45daa84e1aa09d17da79f046f90ec8ead5e878c116afa840f8ad58010dbf58d0bfdd5395b5518be43f34035da6248bcd8ccc7da4e43bad0085c0baaa127a2991a0e7ec6bce104a507a421ac7cd5906d00a66af024c9f117a53911d531eae81341c127fddb55d2aa54212d567d49f31db40bb1eb864b50a78236ac032b8a8fa95f9979a9266caa1f174ded8105d75d973dd16846aa0422cb7f4b50c953ceb8dc9f9d9d02ff09d92572081e29414658c38cccb069d78a75f41841e047f7000da072b224b3539390dcc1764dbca5983870be6c3d44011ddb666f3dca517fa0a5cd279f1611fe4653b958c3d0ce489aea66101dfb21f9a98a7d3c35c2cf2836e98302ed3d087e3a10724b2189b67c85dbe8ded89a9241d85003b9d6881b26a416d9f6e07bf387150b4aed54627ac888a066551f6b7b6fe5e10448cd415d91e9d58301671114cd083fbf415609e4b69fb554f99a2341869a4e3a2ba12889b26ad0321e60438c090322c2a11df346665e73b84eacddb51b86fb4d512f0faa2ac795e8df44994c6252cae68aafd2cf2a03dd46ada0df6f9adf5d1753df79a3dd7f21dd068fa05454b788fcfe9ade85e8c15795b01455b7fbce9881b52ca88e1e693182a0b7b9c21cf436d67ff13c1fa5639263f74076557bd32ce4acd37bad5c58bf012efde3b367406077be41daff5d3ab5aca2d5404b9ee055b90c32ef3025a98a1e89950652bcc920688f00367da518805dfa615fbc340c671f782e7b610cd4e61763738d580750e3c11c8cf05e45095bf4f2bb4d14a42769b5b7aba0e10b020f67e2e953cf2b611f9c73716aef4bc79ba4b172c5d9549d378b02f65156d56bb0f11b094ded5a2af840d0c96adc3ec81767793b0d6d99dc06a269628060b18eb3d60ccc1e0a1cc0da992dca4d24a3917c19b5631e6f5be309c6cfad11cd56f0159d76feafa58481135786dd16b4ba6d6113494c654a9fabefeed63263e747586789f91cab8a0ec01928b306c5241c9f7fed2a5abf5dd0c6d622501f5437f99c46dd984541b790022c23a0d3f53af1cad060771a7425ab450f84896105776c045a20eff9933249f235facf24fa30f774c64eab7447b33b5ab137dcf57e503c6669f4bcfefcc9d92c6c7048f4c4875ce6630edb7ed93c1bb202fe3ab4619faff2bc3380367211eafc4baf075b865776f2c3944583e0ec4fd4660c8c6ba8aea64a5fc1f79f8e345c35f49ddf608631375e6d460cca196a542c7202604c2af3db2c229d663b9d30da711061014125d986c6798e22b92fdde8aaa77c48a8e1a986c43c11448808eb3923e0c9e0e237e1ba0e69db0b8d7fbb057c85794b39474b8bd5b03743b64aea4731b1d00fd8407680813f1ff6e8758fdde9cb9bc0590e063df0b911240048de032ad642e5f3d8631c7eba84f5ce541b197dbbe47f52c26c495fcaf12050297f6e875836e693964bcb0288541e0d7de9efcabba3d0765407b4e4d4d51f72d840485881f1a7a58ed68e3b53ddcfce24e1cad92bb5a1a89dc0b1c64274e40de32cb4939ebb8bd5e490e40a55375ba94763d23107d114e5a17792ecbfacc2e0b9bf0a5ab9dfc6943339ed98aa4a9a2f8be8623c7e791d87aa2d9d93569f86a6557ed64eaf201795807da93e26be19a622d92afcb9b2aef831984b0a86756fa6fb13910c7233f08b6614c402fe6ae0e13c53a00b8410db682071b4d8eb3853b0fbc8dece54220e9e3513712494f222e178617d43b0d52d3046306ea971e82c176bd1b8ede151ee28fb7d04f74867c9ac61b0768552f6741e605ac03092bb22c5e7823c395dc4fdf9c525c2a1b950737a072e28b3b841d6883dfd45c33921e9e8bd4101ecc621b7166ad1ab250a43b6d8baf0084c6fd3decfe13b9200a11ba4462b8caf23348b1ab0987705701e1648dba3ec726020eddc1ee2076ef3820f46b6abd5938b2a7d85fa2f6e2072b49f4c704c7fc04891951013cc6a64310765da534f07480fbf0abcdc072866f95749ffadfeb43881a580c6c2dc7474296929df472b87e9cabb472710a5331a8afb60ff44dbce9e32d281d31c2cabc68d6020df455e3a320895bd39a1e2ebe4a306317e55e1392c9874bafc69513beba90ce06a95796d6890c6ca8987f9c69f9054b60e56da07a86eb931006454432bca6c3b7edb62964530b281bb6ebbc9cf66b6f35abda16268657fc1c8596fb571c1d06a77e0043cc606c892fc5e0289fd8c92f61be15a6a904eebc909472bb8bf20deece576f0cc34587da08d00259dd0444e55d30a0669c1c2c2e3037c3acffb00b5e40a029899d67bdb89ac22103441da9958b816d0d0b73be79d4afb25448851d20b0172fe1712662479f4812d6e349e81e97b132ad7d94033fd590cf30106c7af23d24e0b0fab7c5927b43dc773b414df22bb0d9ec3b8b154238fdc080ee13f6c3e94cf50377564d6516ff6e87ed2f7904c7850b294a497c8908dfe1c31a0bb0099ee81210495071a09cbb9f8bdfb885089647e29cb3b7bfeb36839a0e0f5aa7a14754ee9c6fe278b9cfb5371becc145986000856cfa29cbfc7b52e8eeceaac4882d4e508d2dc32682ee10f1f34c80f17047fe5329e80b43ca75eee9be11f0daa96d4b6916ffa6fd0e68ac6c69fcf83d5ce960ea8ce7d811de7057dce9e8888e21a98af595685a7ab0ab353bbb4eda1785779302f5ee33c2da8c55a7dd14d78a6b87186af944256fbe7cf47fc82e8fa4ad303fc5db62dcb70ceb6ce1bfc1cf356997bba2d7d2ba8a1c19c06223fc87f47da0cf8b70e0a507645c5771aabf0d32ba17b349ccb6c3b35f1006028c69c29ed53fa874631ec07642ba83ac9a23a18d77a3794d74fa21cca41bdca883b04a0d224970cc77c45af41ae91fd2ef3fe7b794d5ed7a17","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
