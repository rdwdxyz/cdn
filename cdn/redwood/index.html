<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f470924fa357d4f8570bcae099156e328015b55c6dfcd90c4e2e714472d6f63bdf237ffadccd0af5c0a49a0afbd6e2461f167bd0de13b1993c62069db9409b86791b95b786c6c1069e2354d77c5f5ba9f624f4783d1b98551607424473ef01772a4eb99edeb66402443060639ec2c1272d738e27cfa587b38d9943c094f53011d17d64ba42d526c54529371431d1b48d999da43dd9eaba178648d6a77530f87ce370d166dcd4e295c06daa0b9e97cd1f8d6fc442a99d5eb82f592c28e25092a512ab1f1090085cde6005ac797c253b16aacea9f0ec7c6f87a9d7ec2a937517dfc5e5199bbbe4da996c1ef64cbb911e6b6fb4155d3b7f5ef04dce67d4c0442e25218e510e1f97a77361ac147535afc75ba87df856087617238e11b9de19fa29d2219fee18dde7409e922374fa3d61a2152ea312d9e49226ac293567be656dd79f0463abd0fa168382a6c9096e66676106beb0e7dad0f3824a9f8504527a8cbc4d8c3df53bc968eac9f72df1ae92c5682eaa2839cf92c67118719095933836cb79da3c0cfb3bccc7d33322b745ea18f4db5e8d2c31a8f39d31809515f07f6d1bc5741feb592f69f173969fe8a74cda7316a0bf7c7d7b96f575376f513efa4bfbfd2c8d734af51cbd09cded90b603b54c8a2073cf720eae815964b7e2d2cf6d2dcd37043db6991a4ecac1b2e60f31d8b7d64e84b7a7db6f7b06cdb048f01beb2db66b5a842bf8491f63f354d702dff8ec310adcc14a6b2bd1146dbeb4bb461365db7ed7a552f732c9286596c0fde9c9de72421d0d4ae95cc907a4d218fbd59a1f87af05e8e6c270244d6aa50b52c59a427b5757894b6ff8fc5c67f3fc468144329ed660017490273d730700a6d923262cee984266807d7ca57cd5d63cf75d2af701e66a124d4a8e485ed1410be5de31be1a42958549315cd90111c6eae9b8f584d476ed702babdb4f460d3e94f85b4a1bdcb0d2dc3b7979273c5cbf0b1fd19e7a6524ed841cdcbcd4ff56af0c3578763cf6ba93dbff5dbb29a3d35b59bebbb0446dea532a70130c6047e985edba1165fa90d1e4cc63e9915c3b7df7cd8df5db4adc7ec070215843be5d493d849b301e636f211c79b0349ed82fb3eccca81cd0300d73c8c16fb748487939f11aea61d558d8b0c1d39403b34b6f36d1a458cef6c396bd564fddc330d71b88903488cd291991fd5349307f52591ee09d6f97c658ebfc9a5f8c18c8cefd99999e54f039618d4c6895854106d0756c564da9a8d3a7cb3aa4eb8bbd321267f2ff39b5852d46f079d29db91242ad5d17338ec1379e50858f24efc2d811ca2e872a23950b8a36b9797a2ce662876e7bf89882888936412b35238f3da2ed3fe4dbf2c978ca5a47eabfb1077fbc791bc3f6d545c5ebb9ca0198d332d4ea04db1073d3d67e7bac64e84008d82c6f6de6ca5aeb638fd523f15382542a88c19c9001bcf5548329f2199d73df2c9dab3097bed40342ed8353aa830e6cb050c13e2cca957a6a92dfdaf7332a834490eff290f42ca092a2607f6bea423107f4e53e07241561dc84c402f8b73d0c81c7557fda19b3b51ab092cf4265571f5e308a4fa0a4abc0b86b6a9b75db5f518cc3c3d9cd576d34312b17582512c6b82badd3c0f70e30aabef3893cc70c70566d1b7621865af9d5217b581d174493455d89c7c6c86ccfe76d87ed1fe6582035135184ac9eb280963e5f4cb0069634af4b96b3d5d7d659808e3262d9396ef53c301cafa15c36532add9bc8ae7ca1d32d635bee40db7d7a7d90912e1804303991f0d126f399b62dff84ca01685ff0aacaba9cebc5cbc6fc3f88eb68639e74b7ebf1355febbae5cd3d7a18a89639ab3f2c1ec0d2961f7e43387f9663aa45148147e61da6954872dd425a348383871adb6d650df974f199a7fdd4d62d333bf3a6b0013b641fa5ab1d28ad1f35f2b86b676ac38eeface409ae4c2be81ffb884d8bcdc20434fea5268945343e4cad2f4e058c25c5c2258d9d7ba5d7c880ca65c09ea81dacf105fb4a37b4b61794dfa22db58d80523360f526479b7e458c7cd4d9eb283c70133c71db1a68e691fcc4e38d92624a27cec247e05be8bfe0ca2bf34b3a84abde3ce9e11cdb54cbfd507e33670bbeac3b9d85477bb140406cfe58adcf0575668df415c19c442ce4f2b095839ee0f72b6509c2dc68c2c55242b98b522cb0a2855a030fb7c3720eb51a084e6afa08454f6ed9b7470fada3069838c81f3b2b7a39265e353386047b82262d5cd75aa86cfa559bdaf6eaa02cdf4f9ba40f72cf7fe57be6aebfc315dedd6bc152c3304118609b94ae0c22fbf7b0b138807c8fb1e5c466f355ae0be94ab7ecb34a89e2ebf9f4d40892768367f2219534cd7670b4f66591d2686087cb5c693a5e8f207d65c0219c74a8ee7d1c2f4e5ea90ac6ecdcf0648aae8eda1fd6aa2e136c2c9f042770be2e1a0cbca3d6989bbc48f32abf9efeca11dc6a8c0edc255e3b2c85847ccd2dc28881f9d76cbb0d475e4b50246cd683e3a3f1f691667b8355c1641fd11496f6f45c4df9bbd0db94d93401d69ab43eaef7510858f59e0e1e31235e6929da376f0bec6a44e508e672eead6470df0f7974063bd8305fd0f5b4fd181532e0b43246c1180bf554cfbd8d2d8d5e1936f14641719632cda8b6eeda370f59e59babd1619876fb50389c824c3eac555b7303f952c12235e170853c1e6a41056e645b33ba66c33367d1b8d999767bc97d37ec41a87b7fe85af60986022906cfc802b274dc2858ef4858407193f1be33e2124c773b1c9852112f08b5469f7c51fc039be4bc7bb599b79b855524e59cbf9808b4226fa36bae3eff7dd36e49f48860de2294f826350ec1cbc2eebac6d2ab44921f151594e07f788d8e1f141c65a084f3aaeffadd75c978c1930c5053fd8f876aa7fb59df629444d64150652a59c8db648c362427922b50b0108b094606a589966046dcde759d74ba67e6e172a2cd32e07ed73b414623c69b5c726a29c7c3ac20ca71005bb541585fdc805b85e92cc2d79200d7c080964ad93e18b11a46a8818571c689689a17e64e7f84f42f5c517622edb388e1fa4dc855723101d5876d9fedae182d450083197badb5b640f7bcfded6aa79ebfd3dc80ef665a9d2308c826f8052da39a28c01f1935022b652e0069ac9c96beb9ff796a80be358c6310b918342f532035e40bc04f25d3426d65284ab40c27f6f5eba1f5b193690fe33d0eafcb50b2425a1e9d6cdfdd5bb2697e79e1718632fd79f64be78ab3780b6b6d8a9174261f8d683019d1ca529ffd3da9e0a827e8898f5b7ac4438c2657b17b662620c12bf6a47049596c38c72381f60b94c3ff23920dc355c4ca107789ecd5ca321f7a488d0be85103e00c8579a4bf6aca1073561f8f80ba1df157acd25efe6abb1e56f1cd43fa7e99d6e5b65e8be3a93724aa439ffe58a11f3127b4d81f5f663adcc964c3d6619542716b8e21ab88140ac576eb1fcd9da624e6b8c4375fb4b29106bb91004e3dc3959a0a7581cb65581ba7801956dbb25379e1eb3588a17b9811e5a87c25f26e787778b6ef044f436eae63a62d97ee9722c2974ce3f439de22f261b5fa9b46d235a82bfde034a82d03b4c851ce4c354f4c472847f36eb2305ecd26df68cf20f69541d63225ae0ec76b50cb73509e046fe817b08305304e4404fe9cb060f6e6600d300e0ecf8e672058b67be34384fb329f45e7df6ce5e0e009bc29cee2249e42f33c594fe8c3bcaee4878a642797e915500917e4e7aaf6bd99acfc782dd103efef9e6f849941d9391ed9f0a9b60a7329546f71f3b514b16aae124066d7bf34161149761c4cee1102943121e4c5e73781e9d82fcfa17dae630e4206d4dea0a0672494cf0fe2558bcdea67d9d5ce0c253e0826e79f380d3c337ab13b0be77fad22de1d7dc92644d4c05dac12b942eb7bd7fddbc15434c03c9316788b40a3fc0da6215209f1cde0a361e4964acdc45dde2a5a806801f9aade465712d56fe0eb282831fd7ae35fbe8d9c8e14387619ca586d95daa46dd8bc6200ee393cc669fa174c008cfc10fe2b21b1ce6497178d9cea8e13c8cf62b1e737cf2d84888f05ad30bfd17aa277c96ac43aa97380caec305b17169de24de8ff8ba75d0700ab86cca10c4fea41a3451355b944a70d6d675fda06a51d72f7787ba61417191420cde8d0b59da0416656edce079f41ab9fdd7c078f1624fa826bc5ea1b539c5c38da752d4a527283ec1285bc67aa6e8b0e905950841b203437269ab9e280a6538cc7537204499d3d22f75b67b85b5c2df73422aade3019bcfe8a7b7ada4a2ed6713c484c3f40658fdf49bf27d00f41708656a3ea9214583a644c9543db87fa2316824459013b7535ca0ede7b5dbe4c36e11118d1f14de10d8fe5fafffdc178be0c4807c7f491d1870877abadbc28b56d45a8ab06378c32c8a287bd087e29ee2da60161da256537b13741bdd8f8df70622832bed58f6446b381761cbe7ad587c228ad85e1c3731113ca893271e0fc1c4e993862f85a06783a8f7e5148367b832d29c69309b4fef3751d3f5527185dc623f96bff32173883f8ac1cd9acdc42c63fa5e5c138cd4a55d457a2a20b91d389abc840d0fce1bdf11c52084feaa33c29d2825fe0b9610f7c0f239c598eb3d8552840da64f6feb269930ff83d75b05ee6eebc06d383dc60cb0fc61609b58502525fb5f8a0dabea75b91a50752bb8a75c1b02293d88d1937ee03e71b30548728b3e8786e2dae9be8a6189068318e95ec42dbc5e4180736f1dce1d264dbdfb8f56af1bb8f5b5e86333143a33c1bd40b44e8971e4ce8662e69f5e525548c4245d08c07ff16846f2238cdca121325c8a1aee8706ab9bff8ef1c48bcc30b6c1a5567ae292d2fe2f6d393e0b92b6d751a0ab4b07fb1b9a23daafec957b7f4277f470db8529a2a0b91687115b1f9a1c6b9656245bafcf071e73e12837eb441c29b26dffce5f39495415b7392d35e3d20fdb2c8d305f5878103aa3fb3e9201fd9078cc0c30363d7de809b0ea9f81dd98ddf2cc241f6bdd30703b98a4bb6ef77364a3b221c5085aef19dd14d8e975edde64709783ba1d40d428ebf09a7dfb4e45596cb75a55e2d6d0ac8e8f14e38201338367142afc830590036026b61c852eab1f113f2942e01584d33cebdbb87394e990079320b4d1e01d3fea6642b7fdbc7c20c0a3d1301198b31846cfc58ba516ccb2841f192a418498b1eeb043cb28015fba258cce84b9908f693777f41fb78236411ccda4bdf3d59fdf3e22c01906d2b45dc6b9120556cab91f6ebb4209f4b4683f73ce30cd7eff90250d5add6ee4af4c779b86cc382b159c49b76cde571d866396f0e3d60d31cf5ff13464baf88a31b61e22a862694330c511efd12f8103042ab7f87af540989d44c6b2c9bd34464bfc9b7ce691352462588e276d1a6760e71f2ca0620720b26d5e700dd4a5a4bf588927ee3f8066df025c7f891f3c014d9b12cb31fabc79abfb166c872931a00087ae18f19c7da2e1722e7cc75c58017cf9ee042950560eea3b7cb74301e2f8b0c0edca58c0fc56a1527b43415cbfc5b4a17479431e3c2381e292d374fc720fb7860f0d21de914b5cfdabb50f52010b9693be7911b70b930b9ba4e8df3beca0de94b5a0856643d14006b7de075708c229aabb6cf5fc5226eb1396f023c2b85bb90d16304ebf812beb6f1025167ad50ad92f0e3d4940cc87ac5b58ad03ca9cad43a2b42c498f46a32b4329f1751bdbce0464a81a68f2ce3d0a18baeb94fda3bf889fc45f40cb04cf07491ada0e9b6083380d0adc84b53ca4deaa563b27ea89b135b0747ae261e611b43f4ea7d5dba362245a17e237964b85d4d4f8ed30eac3f719b4a7c944852b4b1c5b3bad432f85a2d19cc7632c3a5a504752ce6a836608bf3c6ce4225760d86d95a7dff7122b4b143ceb7e595a330cac892ab644214500229c27c914b937d91c706ad680bc787a794bdc47322ae2fee90dc1d7c800911b8e314f11f7d0e00c5e6b1b60effbd4d809b89ce075182784ed8ce643b45236a95e2dbe526be515684bf50b9c311d9fa8d6d9a85b0145d3f3b3cea2ee685d06cc4c93ddedc29e548d673c0afcdcfbbd03753fe3422c9bbf4d768f5387acc847889bc13d2bdd7c2970fc4961ef29e99c3af84ba0b4e5fe0355b25b4acb17e6b70971ea0ee49f19d0c2fd4e59d6c84fbeaa9cf8273bc5035287900e011a39effdb57fd57e08c46abeb12f592e2466f5bccfb0f1f8a7aa012526ed392984b3d725a05becbb7eceb923c8266baa590e93547755d83c11d13e1f46c2f6797f1410d68a37c97722072c6a34d5eb8524ca59c3cd2b57ab522dda246bc967871648e74f1fa55adcbb54df0b6eebb4c23739f3f79f814f396f67df874cbee8ec40abd7cb22636afe2d7498e132c902a1436d82927ae13bbbc55bd81b764aac87e3c96e060311f27be10d22704f18d996624ff73a7f7750d3ec943ef0f7319888c4b8f381a006b5ae242ae7fd206f62ea493f41a5972790c532f01cd938dfcb377608a0a465c237e1eeb739eb3dd6e24717925b5de2714df0f99eca1e595740d9447a051568f97083266217326144f6e10106089d718c57efaf14ee4a05b6668116cbbb1ff0804ea23f664ddab881b27d90c7b555e7b3b05a8195ba7c3e844604cdcf9e6d64c707dc166a9608c0dca34f73c27ac601e8838913f71f2eb41857ebdcab935bf25cccf00be9621dc37d5ac310c4b0478d3995a6181499184c5712c730ea0e0528442f1bbdc86214c9cb920215a7ff7dee9c3361f2a8b3f8e05aa8bf003b694871cbf433b19b1a781f7a42ab251a18825b1f56788f3bafe7a02186a62bf1c8c9ff91553d004d809c9b7d52597391a13042ff0323b6020fcd4cfbdb9adcd19365e2121463e7a63481fb38bfdb80939f18c452333261c635bfe35dc147bc277ba2db72f96d905ab8c862b25eaae3bdd21d77c490332e6b6d8d674f07b2df77d20c99b1de3a907045b12d1df01dd4b2ee4b21ae636398b6a7dc0519d07f7b9a967f721d68f587ee655d8fe0d58241067fcd9a3dd24abb3cd2638164df1248ee41a3e4054b1cc7118d0fe10778bfaae309f94dd51cf117505c7869a5a222b403feea3ab40f8a1e39762f8fd20251e2b3d4e5631106388b5bf66880a4bcdbe961f277ac2dced69cc3ef5f772769fdd24eb88568eec07adf942fa2fe36821ca8376b4954f309b53473cd7cf30c94b51f04f2ef78fd5b8ececda69f1a773f039e7aa964ef071ccb621f1e51246bd0746d94126f41116a40eb06b353ff40cce14dead1de7958ea9d3b1f299b4fe608227df7535ed981d62f34626f73054260a11b5f4a06af5daca992c04ecae14a735bc41aefed23e8969992bb06dde3d1d6303eb77dd0d9973a5230e0aa0ca4df931a3723378de0356e22ace6a914b991bbb57819c542094c5807218bede67af6afab3c6555df7615180dc9a46d75204d94ba84a5f886f53a7987f39357f2e65daca93c7ceaa34733d5dcd70f6b4718ade4f9f38a74616d7071f9d9fb0a04351c57088a89ee70fe63d25b7ab6a0d6914476bbde3fbed69624936aff6beda912ca7bf3c9c127575a1927c6d4a9daa72147bd528d492e3fd91d0a62aa3cb9f9b763dea16355e0adaba016a5b64bf69bd0de658dff3a1871a3a72989b4c18eb4a6fda984406e4fa2bb8c9b9457f874389f0f652e61e6d0bf73cf12c54ef79ace2aaa1c104bf6d41bf9f995b5f7fd259f169b721ab1ca8e7d4d192d4ca9cf665ae1f3d1f9cfd472c2d88a2a10724c153bcf65fcc8374c3e944e99985bfd62b9231a69b2e231764ac83647497331fcfcbbb09597235ead20d531ffba4151249fd4ae8eeb0a8b7df468f9289d440496fc3059d1389ae3d6a4feaf571619ab821102030c9c491d704264708bfaea0af0da246d5d0171a36de39077f0175ac4dd4561c0356ad5a134910aa91e03e76642dd9da3df39771a23734647a1b49bef42de4dbe31e893b7afbc3b3d5daa2a11d2a57f6a29d26ebcbd220228e0ee74e624b22df4aa82afb0fc029082ac06d49ec00460ad01601518cb44ea8000a29f944990df27c3959ad22d31e7e57f218c51b686afcad0ef25892f23c2dcaffcf9da81e1ac91274ff2777ff9e11b034a1c20d2be3d596be944c0cff0a7df2e63df9b59de9753bb8d83967c575fda9664dec8f3bb9b73d574e5714ba5ccbd5e5dcd4149b13f6fb6d84e622660ccbb9ae57356776cb70fdd36e75753338766dc7498d0ebbca65a3b363fb90fab36d62ea7a796eb59e7aee9e99b80e6e0e2b5477a07c67c6457418dba002e3e3f447f47d6332d658d0eb7cc3cbfa73e387cda7c230859f017780f58a2d3902a7668e6f249ab543340f5fba4d777584d6d3cc48df8ec74f03947c092060a302fd1b5786a9199b339ac113bbfb52f0f61f44270234522d0d069abc5f538f109321754b2bc3d7c78fafb5f99630fc05e11618d493b1115340029d5ba6049039777cc5b246290dbcdfd7e459e25a5ecd9d82073d5d5a4316caebe5023ec42887e1093e0f7e841031e36da80c6ea638958ec35ef895caf3086cdbcec22f32ccf91cf3afee541db9454e80398e7187ab0b9632a7e986aac6c2635858e12d572348c56540d990b271cb0c9eed30b4cc4bd4bc466ccb1d4a9924215b01e7984796ec9515b7f316c4a40f24d690a7bc18851730edb56777e4ab6c99fae5aae5dbc3ccca69493dcb01c11da14e6c2ee9726702092c76a4ed112164b23909b034d6fe20f96ad951ada02dc764b2631dbf8f5f3eba06a5d3f54323c566b8b4b3d281b5b4cec24a92aabc5a4ef72d84a094d8cbfc7ca70c0d3ae5f9d14c7f7ba811f85206d3a8c5ef7552a7cc1487213536a002d3de4ea38c57c7d1245f001c90cecc2233cd5c67dc15898811926788b5632372ed7e596d5d9da71cdebe5a2697892680aba51e943793fedc00d9f90f443767a9781fa2626db600d2aaba182cf1bf4a5d7edb2314680c074865b220d958a64c13006c2ef8ccc04eafcee19478243869a792ae4d7569a817d4a39177d9356082cda554fa1f3de7c72a75b92afc65fe5449687b9465f8e03f1703df0ad6cfe781547487a014da0e81f5514ae8d17b2de00a483d43bbecc280371ae6637c264b073d6eaaa838ff1070d27caec89ba97b6ba5588a158a62e173bbd3d809d803638ed7875a3c939d4b4b2c781d06b7425dd6ad9cf7679cbf7d6ad4cb73544b27b6b7779a2ea881b53503a99f6d56009e7c9b99b5324fb156f11ca543eddc53a516633bd25084fd8dd8046e802dd98987bfe550b0eef7d2fa0553493f77ed14f56084f0cfa8437965300817271703ada2abbb15ba158777120926efa3445c17812246842192ea0dfddd09c7f0a6571daeb68cfc2729535cf1caa62ec3a701426c11cef954f8f919c865098b73f6e6179e747b0a5f1333eda4f83b1c619d98ca204ae00cb0deeaf9652aa1dff1f8570f06572528b78510fa8e93b0075fab552bd455b8fcdf2a8b85f0c7e1d5564519fbd69fc2cb60e8ee19b18359241e1a7c6342ea3aa127e97512cd4179060181ef77509ed7b78c667f55c5b17e46773b230da2b711abb36081bb499055d8ef276c408aef56251dde2d27395a3622013e34a7b746f650149610b5f0dea1f6660e2e1303fb2337c3cd1ff63307e7f00f444dcba05bb72b493ab712cc803775c6c800c036c58a9093bd4d8841a99b3ce4c1f764529d1ee1a287134ec669a9c9c786688789bc11d21a873904875987583b10939e2d951e7d21b7dade66223dce8fee2d94e9ac99f4eace9d58893f815ae2899f61e9d7dca2f3d35bc592d268b721f5aaa27e4769a561e4bd1962407a733ac303e1e23e4e13e3566a70b296cd940f24d87a5cb2c09505aead1e5152ffc65b71cc5be9eb41d787fac601c381515ea6144b4eded4e5f2f932354482c9f57aab5870a627e1073419b163c89379f66d8ae8479076b254f839e31be2c05d8a2e7cb655b9e33eb0f7a59e0157b43d621b39bda81808dbd49135cfc89da25fe029b8963b02d8a65c129de17e39bba432395ebcc7e8f621c8bb89a5643b833466cd94118df5bff9752d3b46140e5c433e189dd23c6f55dd670b138299029e05ec27fb1d47905c0614b44d09120ab9256fcb6170516df9feabb2c13145aaa7de9b287d925bf8e78f932eeff1eef21b248927c802a99f431128c11386142a9bf9c3c586ad04f8ca87bfa28e7c946f1f59c6ca22c6e49051fdf8c7324c8195f31be20c83773364abf47f6ea67f5196213ffb23443b71f1b4b2e367fde32d17f01c5f4f33882b2d971134f087b8e8e6f41b6a25d479f53c600fa66b7cb45db8ef2746cbf8657fab06e219b78227f110c7c95e1ab182b0083bedda83567eb3c1a0de3c6dd2b9154baace1ba179eba7607c0795bc974b17e076eaa544ae103216d701487be9c9d241e970c4d98ecf51064981b04fa23cbde366a264694fad8333822a4c375337c926b64511ef34e3f1d1a1ddd6f3ed345136cc5960e60a2a4fc3bf02225a8bd47c18948ad0cbf3e7a5eb3feaab73a0be671fea4e0710b29e4bc0bef3a5a6d17dca5943f39948ac85264b332f502f1ace29cc4e480db9dc2b451c878909d05dac8157785373d326f7981052d6e0b794e7f5135eb35712c6f196e6529c5bc5bccbb1498c3e386491a6240076f0323e92ef7805f294402d458015d8344efa2cd1796fd3ba851d53a15e5dc8dab19dc4e77d16c9313b93fc991618db02d22cd98319380ffa20546fadb007e35f6ba3e6933c88cf685a6ce75eef9f90bf26d49085c705b97a5d6acaa2444fd4a38518b63545ed966ca61e74ab8d74ad874d66f0123c4ab1d952643c0fc24305a622eea55ce63d3d12b556f424ab929a17c365d65363dfa17a95b97261cf9b119efef372ef242efeb0b1a032693d480369c48ca0a998bdecfedd8e48594f3a033c7f374f3830a2198fa7d7cb6f385a052c86c420c56618bbf3386ff217e57137e18371671dc72d91b888d824be81ac51bd54afa47eeb5c47b86ba191c9b3bdeae8d91fd670b4093a896d73dad701be74e13c05916e4ac2a3838d8e393bf2e972c83888236a8fbf3434902f948b765c1093c4c0bc94c3faff7f88680777b38b8182d789c9ee9729aaaa0e5bf944d5c0da72ff9d98f2a50e0d99d47b39956eba6e6924b57ca927732bbdeefa2fd95f2af537cf20811c88587bf5609498fe2bef27de51eab4c7765a295fbd0c08fb7a35959589e24ef82a0fa9153df34f0db2e364f10646c1cdf0ebf8b1363557584b38c567c1c28fd0d9567dcc9d855f1b3ca0ea7e0654e954342c676ea0d9961d11ec4624fb26a434a733bb19138a2f81b4d4565da0a8f13f0939fc075d63c41afec490ee7c4f12fdc5fdebead19c827554d375f9b6dc9e1760d7fac91a631c09ffb0168f7e33ad18f536eef3856cb168a3235454cc8ab01e12abf35c6e2661293e9366ad6ac5be3dcb5d3c262017fd0a02d19b20328fb9db66ac6e41ece16dc511705da4421137d2c36b31a358299592ea5968197b55682c33703a043ba6dcbdf93a1b091e3f8b78304d596225cf8d1a89d3ebe520bd56639c3c49f8bbb5b156c9f6dc6f65da1f7c6628913152178b3a020ab93a5346414a0bdff72bb04a5d528511fbbd289f3d3c67b55949acf18cafa864c6d1b2da9392fcf941bf9da24bb438fd6e8e793ae6bc4f4afd08763ba6a22e1f93d91279db7689da5977dca4f5f1b4ebe3b8a21081963db67d47b07836ba014f4cabb4706555525a46276cf39d6b6d05bc193c14e8e85af8ac94b58e2bdc40c067ac7e12df74bdf7397b126a5e857cff9e4f43c9413de575db342d94273dac355d168341976b8b625e369b6cf5751e881cc0fa9f3fdccdc059075b610af49c2bdb9cabd40c8b9ca4f110c685aae73a9be26abf33293e59bd60ef8d1577cdb54ea101ac26d558e0cdadb98efc16d0fc815138c77d3a8f2385d80710041de3c26a40b8373372a9641d7e150dd68e98ea106f1c7166fbb687cda8bfaa35ca310d9020e3b07c347792fc313093c24335bee534c39decfe8944f187792bdcd04a82928931b23fc3438d7c0d88da84c03ab14f3a58a9d964ab0bbb33b1dbbc1e35c0b467231edc20c0e8f8ad509e1d79f1789fad35833057691e71f4e3cf46c824a2d2b4f4b990b0b6d726c3b7019cc1ae6f0f1faab06bd319863c95983ddc10598b352fdcf26d9650bf22fdfac488277ac74f4dba5ebfd4ed2d92c45a6fec51c2ab6a9ffa82486187da5a7c1abbb08a114ee32b165375f4281bfe725dcf558ea111883008b62f51db6fe15825d7bd0b9332dd84e9573a9a5645df230570c6707c9b8ba61b646654436cd5a38c56b98a70d2a07cb3a54c22a7f9332068270a5b86161ef098f822ece97a78c419d39ecfc9443173cfa541ae79bcf7bb7d28571437cd4ae09e520619165ca122d7764ab8db58d2aafb55601b562346620ad4d52afd47f20be0550347e2acfbabe9af0fe889a688326cf012e4cd171ecf61e2dc230480205756265bbd241792fa71c1f517409a6d1e0f0af6878d7ab1c85406b81d5cc9a09a3c7e78f374280c7e8ed5b6b8f2e11773fa5b6f2c7c360d99c9839da61feba0f0b5954ad57665a3536b588e41e0be2d2c015dce78cdf83cf8be9cbfc6b4b19675e5f431e45f0677c4dac2fbf12cf64c55b95651a43f3159c8ce71bd5faa3b62d0e111742b30ce64142c6f34ea6a27b1bb8faeed6887503bb087cdbd7b21af3e60f0c474600cd607ec5361badaef0cd95281bc11e0368183f5da9ee3f6876e63ad56342da45d1e9560f9b07cfac6a6240bc5f153546d86014d93b098468c5251303b3c56d31cc6d83a2b2bfeb45c44976ab09037410fa63a8d9080af6ab6ec36ef37a3af7ebb2a41c5a7c1873623385a51bed98ff25294460100a0f52ab93c393e8a2277d7c2011559e2f2a7b852906b4005ce32b4c31c91e69f3a7ca73af2c03d6ff8411e91c1afae77d800f2218b2d2212a08ba2cc066e00aaec925668a346bdc63da4d03d3e46a4229fac6106b06c770e4936fded95c78cbba845f8d9511bfebcd6f84b3b4cec095a129236ba9bc09ec837c68849833d48032db0bb180e657bed2ecba69fea2836b2c34606a24fd73c6e1239ac5bfc6b209bb964a21bb96007c82f5d09ae291b88052e724000bb17c17f145b6bd9af4a1f0a7a01e95873c0c89ba324542c4a084589a7bfd622d003b586fd08ecf46dbde445beb3222c640f7cc82bf2b9221b741e400c913dff9def81132990f477c3fba5c3db1127cf294631225e05c3ec912f0bb0cc91dca240d44e1638e7509a9c2b12a66da0746b14dc6b7eb5cedf265463e7a1c0768616840a13ff2e1d1aed6f6d0655d973375405d37cd028362b94587b195efde4d47c858269bc7ea399ffbd5eaed16f278297deb52bf41fcb331ce0cabb39f2c3675f5b7876b361658cbbf273cea9d8092c25d329f156cf3a03bd41c5cdcfd1e310a4240d6fc22262fd3c73ff7b4bb40ccc8e7105aae40be836657b1e611a00b9e7a7bf8adff90e5a39a740019e995e78e3164857c67715eaae16def4dfed2028ffcd819a6aafe418a8332e3e16c4feb47c7e73a91aeadc3c0afe34927f2216c165feaec56d3839402df29a1dba13af620531feb457598984d2fc5a98daee8b18f3a2655b405ca04855fe6e65c1d0e6245c8da9909e728fde37ea229464558d4ecbb8840593cdc4d06b3cf910efcb81d9e412da84bd5c173d203f473ceea10e030a9f87d4ba303bd730817d3094d727bc07cc964ceff9bd37b474fe7987d399024449ae295f3abaf2bf044e4fdaa00434da2351966928ff725206dd6e1b5dd830f742f8d66ede510e844d080731a2a5c3d5da15b5a0a31be00541a86d20bf6f5ebba0cad3fb50e58520a3c591af36696af8816976db04b633b62c2a703064872e603b37026300990cdbf623a9c4ee1722021ff26f56ca0db4e60faa8ae423b8557dd46f7cc0db72afe5b2a45fa957976e57a827eb28a80add942848088f5e85173edf5a4cd73d2527b1c5e7bdceabca0ff3d4160752249ef96c1f6df660724ae7a99b31b1ea3f6d5af17ffc9a637efcbc4ab97906558ed63bca3071a86f4db90021cca4386120c7fdc72bfd0f23a41a14fd85ceb0cd23b35f6aaeded99bde0874c4f169d7d4b575aeb20d0057d102824c0b45b55de8c67daaec6e073da718fcc46de62a15c0215c84564d1bd0d4847453e56da4e529d2629f21ebbaa0d2d39b2c5468eee30cb7a3fa164e11ae02fb8c5f7eb2153c5f89185c2df0fe0ac3852d4c3bbdf5c1dbd4a5514aea7ec7d74aff86adfbb0dafed4c3c2efc65747fbff40f8c83b4222112f114b3ec621f2b3684b59fa6eeff3b4f77a50e88bc2f26a291157081df2cbf873e04f655e79f3aa500dad4245972f57783166fb2345a0b0bf08a0eb8995c0f35f0fe2a938d7caf5abb8090fbc34e40b855118be49d17e9e8c303486b46fca4244b6304f1ea55e440bdacd27ad91cf3558607ebee54432a55aad4fe7769252f276baacf86440a03633623db1a0d333b9dd831dd9f6307afbb3ee174ca96e0f6f33aa2935bed3678ef48e4ea4273be1f8871337cade723c4ab5e47dd9ca67f50aa554998a352e661c928f113923b881d03417bc0935183c89b91293746f7233de85020383ab61d3edb20944e2d15f88f75374fb38831bedf79d2c2fdca89e4bc88e1d1dfedd98fdda0df9a592dd2739718469cf8345e94d172a563f378405fa2664d070638edae6251a8456e6a06663daf8bfdb9789bb1351420991d926987dca53f1ed53ef7b0b7f8bcf43ed53db349f3e71d9af7f5e30ddbe4e94ab911fb7f5e422246b1ebe250de6682494985254bd4c5fa4448f58e57f7d1f5eec7d7bdf19027065c2b7baa31def3e50039071784d0e44f808150229ac2982fa718d6d885a69df03db05d9b0caf54d4f77aa6ac0b99c0f3b081af18c0d633e3c6f2514ad479078f7fb51c56e0ae8ca870a64be635edd0800279e558d9691b2a9837ebfa4cc82ca724d0778afe6ba6823ffa392d2b5982bc19649de75e4ca8d108a1125a63f34fca4477a670ee74a9a23bf86df77a0db1c51f49a56c2a36b642d9d644adf2adb69928e7d65da12c1e7175561953b8a440162da3c38ba1a9c85404972fff7a96cf5859b43ee043a1bacfd87e45412280b549ddeaf62635817b4c04e3cdfee0847c88fafe175b9da6312bce94ce373c4bebc352931fb3d5a246c64b45312de912a002a58862783f0df1a8be1aac2692494b952f5df6f4bcfb62e2c0d55eacaef3e568ea510e9da569ec9ba790ba08f19134d2ea8d7b2982ecc53b505f170d47866d84d1f53a92fb95f451549930bd14752bb2d303fcffb2ec2d78ae50ad5e55392866af0b5a35a2ffa2d4a99907ce39d440df7e7b3f5f1d0ed51b3dfc8896bd4b3e3e7960f36a88d2a8802f799bdf023db7760cd9fd708b9069dd2f0cc93505ba64694eb29a8b0fcf13d33490c8f5cb601fc9706ee4babe9f4b02f92b4868cd5465fb5a86de1d6ab621ba5694423f1aae75595c161bf068ae24b9577b63688d52f294001e87eb82c3b3908ba3e18ddaa5823c999ee1b65d67abce539ab1879374596602c4f37c7bfe6045ae5e35af0e83e8eeba27cbfa2fad764684698777f38acd50da74b59dc70492cd0b069f27590c9b8c510e0889a37847c62fe8fe2c7ef7d800a9817b103b112a684bf0665c7a926bff8775cfff5cf79d8df65a1083985fe205540e731ce0416b527849032b5a1c184185f38a5496d96da559769ce196fe58ac842768dce8fed98e9e207a4ed361e3255388e2968d70eccd61b3c9875d6179715359ead068920703b8d9ef3488fdcedd1be24340d93a4e3d2a88f994f09228c76e3e5cf64d3ea15367d3de2028128369a0b7388867bce38596b1fd591d5cb212121f16a4b39e343ffa6e33db3ea9cd555afb8f2654d54a7d8eb7c5e2a7a810627da4fdb8d7108a936a7668f268d35c768daec6f6116661c1eb5b3762ac0be246fcc490c61385412e600297444ce4c2b36b52be879e8068c95016b12966922c41b8bc2c558db976cd0092c31aab3ad97097499ac3ae0b4cb18ac20b12759ab94bdd8912830820fed65c5751e27e469c1e48ea797a7c1bf10355acf9c10de4f0070b3032ccc63b3a3e4495552360393fd36b0de79df41f636bc55002c385315a045a88422d29cfdb528e28170dbc844dadbfc3049423823f97139c13b3c0b463bdd1ac7dd49ecbe936ca91191a92dcbc829b12e81ebcdf1fc046988bca329d8ef794e7b19d49691a04c8096002e9776eae8537725cda5432d76fa62612d2689acc4133af15d221f0928e070f343234c0981c6de9d51d73457ce57e00598f3950f025772e8290761d68166004ce04ae253c3ab5b57accdc2032be4778e0ffac253681b8005a257ae4c0d4fe114fa42cb9610d4f6d3911c21e856137a89ab1fe7d7024649d07e1cd1d0ac88239d6c9ef83cd87786923bbea2098aeb59bfc4a6c6f172a4400177a19567857a87f288c6466b6cfe520c114576b803d2135d2c70aab9695047179d3b824c87c648c23484649f2f63f4aa5b9baa7aea0b14393ab44e891c41b00bfc598931e2ff2369adeda32050944804a82a5fcb322cd44fcfd7e9f6246bad60b557d7b02811e30e24c53e78db4cf21d5f415d2c49aebe44f5953a580fdf52cf61f272f9d94bb2f463db7409d1fe2516d65598e05ad22bf05c8632c3b749e21d7df86b174f2db175b29a2956eb6fb0cd191ae0071b3b8f6d7c20b7eadaf70fe841681011fb4cd1ccb6db6dff2b35b988a148e1e2fa6d68362d1b15232de3b855c2d5210878acd5cab206aa4d1f36883360f2e281b164aa896008e7252029290b2dd5dfc9465648d02f5d9e2223e0b60d198df2158789cb5afdfd6f57759756b4a8ada3330f459081d317fd41c92376b3d687927afc4d4d5c67a3461f15280d4c9c642a1631768f7722da25e30323fdfb26e17b79aac9c1638f8d0fcbeb2a438a693ad7ccd56cf48a5f392a454b48c8f0cbc13302de67659587d6497ab50a67d177ed7e3737e4b2b5c5e187f2a5eb93c88af87caa7591e93f3029c541782ad558c5719e167d197b5892cad8de6815c6d7fa84f91d1644c89ce87d4aaf8b5aab2049cb3f81f38ac748ca6467ca5b54c854e6655bcbbe6ec812f5344ce20ed8ca7c73c50f052c6b309ef571e83abfea31eaacf598a21878612f47fc3b80aa10a57c2f7de79a32f1c5d8e4bf4529c3e19342620225644e25c4ab76da19709924a2541c89a37fbe1c13b2123f91941a1c26eb99aac8b5d1125d54c3d70ae1e7063de1bfed6fbc36f464730e430b537722c3ce6d64c688afb633df0b486bbcc7547cb4c78150676d4c5b268914b7ce40c3748862eb485a76873a82f3ad5cfb4814992d71a7445402608cf834640a0964cfe02248fb6ab2f5e0eed3402ab3cdeb48c50b7c2039b5a7b9b9310ea5f8a7cbcdf873aedb6d2666bd7e596fc85573b4d4fe6f86015ed02c5fbe3e64ca8e362cd5ba3272ce24ebe2e482b26c20eb7b5ed9a31bf67578882402d35f9c7c0e5a2c80ec152ef074b249b854df4a5af173c0515e1d40f9abbc8782e073f4ad606c6aaee35e1ce28b5e1ec4fdd52f278ee25e748642c349307ee96ec5b086debddba120b3028b884ddb95c2aa57839d29ae5dc86ef4050ef57ab26361cb9b898e6484507d444bcf8a3c5122569231a4e399c4dc0740140769d8dbcbc620a23bd7d77ff24f1156ad6b1a3d9d7f7a28f12737597e608a0a270a2b52ea155ed091e56a37b6f493d006f2517c59344413ca8d256525c717ca03573ef96ae2ab2cbdb43231bc5c60b30511e03e9c3f4d655f9073437be2c448b2c098e7c14b66765b948dfe2a428e05a6ee0219f566b6769b38bf6968c7afcaa0157e0df82ae3e43e0904572201fff5071875c04137d7","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
