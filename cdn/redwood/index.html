<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ca7dbfa63bcf9659b2180c0ecb438ba2dc9c8011df9596b91a8eb3839bd3edb3606b3aab4b80e18c15632307db402b613183bcc48af7e90eb53ae9dc69b572b1ca334a6c58780664b9c152167d2059f67e21fd5352374d796d24b54a3254038a61976c46fcf7a87dc6139f31b2c64ce5ed41bd89befa31baa88c51de2305d694062f84141d7c9ca78b6546bbf7a7be060ee0a06eeb23f98bbc279bde11607471670bcb0534471ef834cd9b9a850645dd0e7f1740f2f081e7ea5289ee1d7be2982fd3c9f38ad63053317c11c8539d1d8394659ed508cf51ebb6eae10668617de6e8d45346af9321c4dc731d86656dbf54d69dae84464b6337ff470950d26cc1db0d92e9cbe58d465d3f25b400963f167e667ef7b01969b92639560ff29c9f91b6bac73186292df8527fdc6e131fffbe45aa8a01366b125b1517a6d611b1b74ec5c80d4d4bbf522d122bcf51194c1bbffc586c53c825c076b59cc665fb5c51e363901d808e0b9282252b2d18361ecc2210fa5d66c21bdd495c73c27a04e83ba25c81f74cc02fbcc46cfbe28f9a652f1fce6d546a8b5264474db447a74ee2fa48ccb8d15b433f5a7f8c31caa67d3e65b071e54e6b8342651a26270229e3b93ba0f0202cfeedc1bd1f1b1931485628396750bbcd2a79aaecffbeb9536688e53e3e10b88fac727dccc3fcc292ae422737f12a8d3c64a7d505c68bf48e1d5a6a14147966dce8557e42e7f4bb3f438f84486ff938ea7027e1149c9217557f629c0df5cc1c353475257d27a7430c86db39f58e9d0e669005bebbdcde6ed068a33f372112e3b98b5cd1518eda5f510002001bb799f7c0d969e65211bb59ea2d6ae0692095d95120cb6fe0cc2249d32afcb0fab3fc3dc7aa99f602e00913243622c5b13516595014930cadff8e7509a95c807c6079d30bb3b08f3501e2183a314f49987b3bbb32d32d6cb1a775f51af618536367f62186e3a6f86cc8e4d78ff4d416f9117d580870e65a79efc3d2fa019cd54a5322014834475f83ce27df01638049131ece96dd8089ac308f97081fee7b2b4d117d3b03d47ba1e4ee6dc8f36e73b5e1c169658415633da8b89b73776ac781e0d1dcdea1a82e4445b8fcf19f4651b08b3fffc23552f853e972d0f50897aa8c99366c9c9329905097ff7bf2a080c3614880a195e5fbb95caac9fe51b306cd812b4a20cc20217b5881deb55eb5dc8f839e0ea0cb074c8d1e7daa48d02f6a409b07e4d98d539501a1b6d47aed3ddd6a982edc92fc15a4f37d43688d48198feae1c7d2c2a11bd383be8e03f7891acc3a2d97391e015bf6f8b0ec277dd70125c058224e5536e66d8c61af9261d5f3a13c1aaf1a5b3ba5b4bf236c0cbd2a666c313784bd1fb1515e1203479a8afdb834f5c10631c4e2da334829654f0abc5c6d4505779329cf0ca482e5e3602485ba0e1d0c9335ad53e64778a7174c08bac13109cee235ac9f704a0cb76787c1d86dc5ba182eab9746c1eb0d3e9e16dc1e3cbd979023fafd5466be5e490c0a86be3833f5ce3617cf8e62f7692376d5227f52c9b5b84e4469ac1b53e1b9a58cf61a6fd4b88524568286c3dba72d5d77d7f0ff79dc5be374cc15d84a123075a5d1625e80d3fb1bd8a5349e8ad33094d5dc470fb09f6aea3cafe1e2069a3ee14ce66c38b4b018e1d9a0ba6fbbe89b6c5f7758e279bd9b77148ed4690c4f0b3b5510ff08282566f219ed8fdd9a6a498add5165cd063ca779f5db8957bc9c5f04e830d2d5e973de0c8be8c694c6f4cc4652e1c51d799ba71da7815a448544f7498dce15099adff5d4b2881f8b40ec743bef5acb1e65c3c0a989f9a9bc2e04f9200c9292a2d730b08bd95683c2db4c37fee6af8b3fab74830b241839560907861c9f261e2664eea70ce82fa59d647dc4cf92b0d8135a1945b82aa79032b310c04b3974ba7e439e061b10f6ee01c9b2898cfe3c2a0effa01ffef2e524cc36886a3e0f78946d513a3de5284968074a88ae02970ffe4bf0b9eb6ac3f5e02f5d1938c4e0eaaf39fdb2f7b219734521d20c29d95cd33338f37f1c977df780fc6d599022afe2794824db95de56add343d0521285978604269787e5ff354fdfab7072ff4bb2be73991cc38dad3269695f5d8e0d780bc9e42a7fdc2ebe568ffa094f2ed41a72cc44a179dcb0862f7f106209a678f37a8f88049ab61fd5d41ff103e4ce1b07e6149dd7c51f66dd135d62d7c5ef4826aa5b0f8c900d179326ca7734b8b4098924de2f239c206eade4a5145c6cdc54f8713ac1c2aa981193ac48dfe9123f8a2c9e36a487eeb0318d70931df34acd573581c15c181e559d1995d2a0dce0c1036080db6a2ab96c0fe83d907b6de53f584f31b3c83bc18274936eff0f02a07976f798137e42e50f8d889041944132f22c71a92af3a7a2177c6d616353565c87db26fa92e1d5fc2dcf50c3587f29b22639dbf18eff2ecb43596deed95feb035eaa0a901ac55bb6b3708c763866bd4fc8d5905cccb697171de540be3b417d9ecbd90497b9660a92f14d32c53f793d480c95ec401094675a52fa0c9b70d727432d289fef6156dc5ab29b7d01f280047b7458f7c003ad5ad7feaede6d973bfde3dc7912838766d1d564b5e893954f48d3223422a6400b7e1060aac894b3b0330a1194e8e6ed72bfeb8be66ec838d62da73e0e6e96c9be0f123f1433c25d1c2a77b9e129bc8a4725e9296597e8e5da820227cb2d52846461b5d75d4a017fb96762d014190ed05293f9685308f4b695479f6b9fb0679473b09deb5745a65a10cb9cd38e5d3684ef866c1c45dce2efaf7de2b3d320ffe136f8118d6881c315cccd24ad8082db42213eccc7f337de7fd225ec0043e08556bf88ff171d797144d13e14564e6c6861f7be540b6995187bd5d1c115877dfc8e98873085128576ca42110b2337902c33b954f35ba5002c61a376412a2a3cf718aa381ce5a71a1278eda23ea88e618e4fe855eda5acb29f9ad0ca4546b619dd5383656e8343581ebb0c84ff558f3d9499b6acac253b6d8046e4b5a44f23f681f9d08238fe8bfb50382f8e5e914395f43d0387ab04e62dede91180c194e88bd6ddf9db3b6adbd05bb6c89a86eb2849e7e75b17e73d84cde6a9f2b5f86da9a908019b0c188a9247481d1f23fd4a5488c86e70ecdaf4648b90f5c713c7e52caea854af236c30ec523ba7ebc3b21a4e61c7b96731b84f6ea3b51ac69a867eba87d4fcec63fd1770b6a7ea7f7cf851282ab9bdf3fcb35ff53a0f966f580cdfc93d795be263c5e5841e12250867d7722830b817b40d1b188c88a6567fb5595ea117ad52e53264e786d21fdc1e1163464a616b67d22f31567327b1f79876a7e60828181ac56071d202bda5c159f8e7970840b02028f8ec23cb6b6decc3b4981b198e1fe3b9e5f056a892d918fa2eaa879cbda56e563969d6e1aa5042053ae203348fd10969aa0c4af9410b4f2e901f044b4b9b8d21bea853ce387727e20adb8aa4ec1c496cb31ca3a3aae6b9b3dc1ad4eb558a206e8cc84c997ab0b3a7d20e5bbea41861e407e8f7835997102a8b0dd894f62b3e31a9878e82832e2a1bafa7b855e060597af39d486eef531cf9555a69ee50804af1a3ba9b22f945f1ea00adf9f0cd452e608f884e7d506539e25808fb75fd1fdbb51c42be2661abb1c6685cc24b4fcc732e7c30a6fe2832d11b0d84c95218b67f739ded792f0e1125edc97cbe334bef41f25cb57d6220557aaa7b3b5de55aabfdeac881749a1e26af156703a7cd61ea1a695bc36e9fa1bcff9eeba8217dae148f16a1725de1d8cd89ba5bfb860de8b8757f105d375eaa9f4d0ff8d82b9fc6b4c5b2993e4154604eac927db7fb778e54c989186a0d7e002a8d0d6222e47f81103e89637e39041e5ccc6e9fb4136f2ac3e0aa4040803753d52bc5f8cb6d6b35507623465c790d9cb36fe27605c4862e4b440e36691449c8382b2df3a2796caf7e8ea25dff4ac0455d3acd03a0665711f53ba07fdcf5feaa24886bed4f4c32b8e5def50749245cb428772bfc2df46c50de707144519523649d91c5d9edb11971f12f7286e5a02c0a2476d16540d620d17abbf1db27a1b50d5433364a529882734412e2e3735d9808eb676fbc0a3cdb885e05e1d9c3c9c0a8fc7f12a772d54d7dc23e7be95e04a5c585073b7a0fb92efe314f40ca41114ce6e57453ee5542dfd5465b2f002c4ad65205bbcba7694f1a2daec444bb6269a649d7f09a27585913f82019e1cee62d6486ecc5aa7a4ef744402d25110c8720f17d452728bbe096e75a8ddc2686dc9a097f51e80fe16b223f31365bfbd3d4ae777b6fb7164fdec8a6324ee57c9481bec56b8c71dbdc1cf0a96863cfa3aeff30537e53485a5fcc36c2b530e64040fb76e94d97136b28b7a3c377c0405e7675aa24bf88dcb216a95be2fda02cda6417e17a76d2d30a7d11fb0f42ebe56653b6c3916c930f449065c07e6a4c5570216469caf878f05ca8cc1c7c7346d6db9b84c8bc9ec0c2f31b0dd3029254a75b7c9944a92a7cef58b6fad991870c73724d2a8e8952db0966e8682b83c517665cf440fc0073898584b3fce5c6b95a084d50428948cc51e647a020f7b548de7814f15f211c77d09d7cf77252cd75a9961223a02e0fe9fc74bbc1a23d460bf289443b8c5543d26e6dbd20135a8835d4ff5c226c6ef96921f3ca75e6deddbc5712e228480ad25e1bc4fc502c056f68176a3be2faf981631fcb40593bf0323db10eaa7e5c358d4548aa20b3e4556284df6420e221a1528f2ec1f35972ce4208604ac4da82534b0c75a7d5d36ea2c50ba3f5d14b8463c66d54bbb0b6bff42d867ccd45d78f001096dfe69032ad25cd340710962848266253964e8bffa15a5d9be17b6f7389262e7a9c9c9687eb08097176766d90e61ae28da5b3c122940ec4ae077786fa77f67543b9e6bd052b13a5f906da1c749d02fac9c61befe0bc1553faa6a6afc97897906c4773cd082389a17aba636eb17987934c71c5b762aed719088cdce5038fc5bb83f6355a5545b5771cdc99fcdf97e05a97f6119b17944fe9ef2093a51f20fd565416229163a287bb9a5332bff102abe454f09ac012a6cace96046ed8fac935ba9b36ee42f816a10db02f32b2841f8f038822123b2bb8a6d1dd9bbe796a27bd0b1b073beb90dbb0f8e29746af280c757bfd3241730522ce44bc36b3463cf88bd75989d298a68604f7c0de9b848ddc1ba22d1a63f43772353d13770671c280dec1213cd3cdbd55547979c7a17a65c93466f6539af8cfaec74e80565ab6c696df44e9ac416b9dd7c8085e68957e272adfa4bf5f99f54807eebe3153281b95e58cafde245e82e4e02a5c3a24942f1807b6a418c3480fa2a538239589e0b49ce43eac7d4a9a68c936903d9b555611ce2aa8da5b32d05cdda6ad84af870b480b71b740825e976daba6f520419d60879c2677b5dcff8b4b9469107aad967f6821e1fd4327860e272064b40284cbb1884022b7389be9d05c7fe818aabf44fb54af86d82794278a0c82b642fb7dfa096167cdd73b9ec9647e64e69d60c9229a3774eda197fb1b09863b6e31714609d74ec5b53631cfa41e50a6adbf0512ff540e485eedfc7abf08f1f4017b8d41a86b85ad671dcba22ea3f926bd188e84bdc501dc27b5b444a1abe42d0b5375d1928607f3d61bf36450d6b34ebf3da12b99061e953bc5b2c36934e8ce9b39f468da13400100b93c89812989a72fa6fe5037844fd2cc4c40bc093a19b0a7c90b60cb3b66a87e58d9dbc475647b1553ef19bdd0e5354202225db93bf78232dede9908a38e0b8288823a2adafcde7bf9238b2956f49bbd4807eb5af70d52547e6e4213a722ec73566fc785036356d52f1985794e626bd20ee9e2a17c82665225364ec049fe284b8e7fd8451079f0b30fc920cea5e7c685c066bce197a6811a55ae185ecfdeaf1c3432987aaada964005b8753d171ea03c1e1db648dba14f91887a7ef1fe35374bfb7d58bbbc6b4672f2a0a27598db1b939df18f9de9b5793fdd81cd962bd66b3b13f448bc6809f4b25560ead4e4c83dbbfe57262020039c2c1ab2f1b54ccfe4f5131a181988f98f290cdf074d028c7661c63da6c515b1d8972d2735bb76fcd452e0f3b024481d9d32f96fb85030cd6e47e55e61456fa2c0a5521d155c9af3eb83cc75379caf0fce4703d46eb578e1f8b22db5f53afe5d92848f58b743f7812be59b7d7716096db9eccf6896d81efb307bd4c987465b51cbf1be9357cb9097e192f512f4d3e629ffcda75ec1628ed4a18308da5e8b5fa47c37bb05ed3e39994ef29b30a691d7b30ee7959a9d6aa1d412169ea7a5bbfb173efa01d73d775c74dce606f050bdc2f4d56ac71d63f2dd281b5a6044380ffec64828c87614d4cc8cea4b28eb63c4b2b575d571c231a69398d5332dbd3932dfa7e0664fc98cff1c6f3e4181f9c1e8065c2a7c7f9c0edaaa67eaa83947dafa7b6fc83182abac63828a2603806fd434fc00d39c6a406627a8189838c50e94a102f7994bfccc28ebcee179d823c4c1396aff672b45e848d8779add8721975798992e6e091be2fef3dd5a4468971e307a2b66b0e8e990e785a7cdcc5941241d32ceb25d993e4a62b7d10c564cf9fa1875d24b921dbd7a877a6d346f9ed00e2c36f6ecf2ae3519cc2c4f2a33deb512847e6220b1292162291f4d597041eb07556cba9d7927cdea7f262dd7625d82ff4be86bf5ab6facbfb21120a4e53cf4cbff8608f344b0c363571556f5299fda8890ecc5ae859433335cf69441035ac1c9b4ae62a586e3ceb81274ab4a9285357dd4c57f8a8283abea177dbf37320afbafe4f243d33da14100ab8b8547d06976bd1938cb363bc583e77c722d08bb1c98c33f7fdf573d3f8511bdd16a9b497817c311b60877fe594d35c05eab9a16b3c69288bb56652a487a11e5a435c010161477ef07d937f96b650d9aef0196c4429157ab3e3f769134560ef9a1742dec59eb1111e683ce4851263a96c40686e3fa6765c327705ab8245ebb87297adf39ea6682cc106fb84b494377a425c5c1913f711f1b2e192fe9f07aff0cb9eff86f5a2c3e7819e81cd365a7b4ce8a0e44568f14426568d54200b0d0a98cfcd31b01d8c562634bbfec6e05b073bf5a47c6e26e5d8ea41c1d006b88371b3071fa4c26c6c9589cb9e2f52089fb93cbb76d5011ceccac8e729c757453ffbca311bce0d8f960a0cd9c822732d827356abcd2c92c6f59dfed78ef5d0699b8b88dba24b24f2cf306fc1fe9ef8e44bdd35241335f1bee1be5901c0168f9ce334ae0d4fc6b94b705811d3985e9e8009e7d6473b4d89f0991f076d1f4bdafae99e56fb01262e14b356891447c092194261fd086f0f518fc0a5fd15c9f8bd0290e49a4a5fcab938a087891d515f0b09ecd92c9ae9514aada75b5fe5221d5f9f6ab61617280cc2d03f879c7ce15bcf5578df5d3dec278f717068a0e089cd3a5fe0a584a797b884b6d3153e88e168fc7cddaa185a4afcbf5263d028444d48868505688f8ab034643952a99594503d7166022fc99a514b647e4075fc00497986d929fe8695eaecbde0ce40e6ceebef61356dfb7b753019967dd6b9a111b2e05805d319560087e4d0dbd020e4aa3421834ec35034619a5513d986bf4abc561458df00c368ae0ea4e9782b7c9054fba27cb7ba2e08d63ab9d0a56155917d93839c4b499cef2efd589290fed0b7f91d9334cc482bef2896fa8319805373ad7f3ffec3ff5b7524ebfa86c85713e40cd56180c5c910f75fd67555eb76b5d13ecf374d267b1c3e30d38fef29d50c85b8f9536fb6db90d9827193ee3915fb45a7057fdbd1d0a813adb04945b8768bb8abf6968792b311c24a68b6ea60990593d0213b090cb8e3ad3696ed651aabbbcce3b937ed07274db3a85be3e7d4dc78df98b0c3235599c6702d34dc60e6d615d1e0db9010c5b6c4f47394a8346b756c17f7ae5034198620a892a5cfdd06f9fa0471d9839ed6cab2eaf8cc6b8ce45cc945d01b06982ba64d6dae99e92fd0a08db5de51a942ad18fa9ea6090da0ad9251210217006ebf2d6ed331b74fa59958842e153a60054396fe5929d20c170d128ba307c521bacabda8d8b6e30febe06af4c2acd33e3a2b0d1c7d64b675b18376d719b6b5af3be5675137ce6e0746d2c29eb12f957d6527250f6abc0abf3725e1a7f054248aaa0c5bfdce2b8dab4c350d1757e71cc35201dc9eb0d600e5577c15c3d8a2022e19a77fd50dbe8d75f0e1a6e34f534f0fc93ba352cbb0990d4c42d5c7e363a4905c6a60f15524266b0608874e7130dd4a5410573b22fb5094a58482e4a403ad128efc84d42b5b7fb1ec327d5055fb12440076860b5f50f70f5c6fb46d83d08b2b4c5cbd9fca489abdc4e9617111aa6e5a26675c8c0069da9b2ae8d8748e044d3fec8ec42288e257a24ea0efdca3431d3efea135314ec2c3df366152268f1c704bc81292f4024ea8b9c4be190f0247d29c761c0cefd449d7999d2452832cc0003ff687fb2b85cad16a88b3a7e9a43fad46d22b4af8a3ed0ed67859bbdc1da6a1c3cde5c4ade57ac594e369ac857c4095c9889f85e5148751e1648ed38a39b7bc2455e6cfd7df826129be45d0f1bde7f352ee1a9ceff6e9c30f843403ba944e57b0a18695e8cbfe44e9d4e73e3953a9020490973852ae8642e229c6d5eeec8003556b7588ed5f43ae47260929881c0151913a554882ab7dc3ff8ebb5976a6c74eb2e58f7b72deb81456777a8d5b4afb4dcb65889a1f8af08a673ed90c99e3f02192124ac743c8a09f90ac28af85a331a43a7620bbf7390e48c12f97fcacee060a5b53dfefb3cddcce8c8d1b63f49a319c6d5a69f6069c5b260ff5c0788eb8f8c7392f048553c3158955e2fa77b3077604662aef6cf5a4ab79ab4a216f805bdcdf41bc1561d595e5b39f5d736132e65d9398b837b414b65688fc525abf002b65990e09eaa7f8b2d37967e9aa67c9b2575e6dab96626c4837b7c9f94e98284c6d4e2dac9c3e23f8c22189ee90a0a2bfe85079738bffae0752ee2ed72d9edaed9040bcfae8853922dd439b2461e5a5abc01990e47576b3073e082a3746eebcfea89a9e410fb3058b12546793691087b03b2dc18c428de79a40169f0401318bfd19bb7e3aa79863e1fb7bedf095c835ec3c6b31bfce8638dee25bdf9be0dde797ce3a9b18142a06970fe29f78b39c8a82031e2dc72fb0cd591e959867f342f8ff738d8404761fa12db0f68ea0e3233d177c3d0a7476e7535a4959f562b464a78b0800b7bfcede60ada89793f1ec211d4bdfac2d73407a00a02abd8e3cb79a6eddc8a57ab6600241f4e95c1398c72342ec166e47cf2ad1d0cd090d5b1f4022468594b46bffe330892d2a7a28fa6f3a361ebb4a88bb960ce3ae7c738ae839b767a0af2e9204f44cf7c74c4605ddd1dd19bc2a6d4bce7624d410e23486e22691eb4ba64348e1c2b22d3ea507f1b4c87453c102ff0a15ca81a226b171f418799cb30af2f8df508b95a8284cba2d7e2a0cd7e9401a5bc408ca7978a3faca65f7a83c828ac5f51985779bd8a9f6846ea41a0d5fe64ccc95641d5f753c29991c4946976a2a7e8794ec0dceb512e4982294960dd5d369879b189e9180842a8ddde17acd99bb3d3e10187a5deff78f61039b266e5be6b96aa0fe3bcee528c9c6d19d3671a997bf5d9a6678075ff350fadfca03b34897326629593726eec821837560017a21e426d769b93e7c9e7a11bc4d43035509eac75e0795018cb14f93339e09934501ffca50bf1eb232421c503b0f04a3fc0bc9142eaffc017840bb704c0ec1a69c1b39d1818e1c5cb463b0a3524018243cdb02f66bcf612b462d295bd394ab276d05d16cefa0c66ed127dd4c0b2ff871a9199278dbf27cfef4c1127a04d917adef9c4df1f9451627b8bf72c31f41f35b6ae7b60eb5864d2f3ad1013ad694f3fb9ca68dea2f3d2a7f4362697761cb48c5cf48228446fdb4cef50598d98b6197a2c81a3c5e1797246b50f79d5f4193bb85a8eee5bbe746e801a49cbc766523ce2ed7de31e0c6b27c708a66dc825623d7e7ec2f9a2916c01f18057e9aa82f4b34f96f089bf11c8e1bfd39bec23bcb52d317756419fe8fdded9b32174d86360eab6534587f0d342cc27622442575f2830b2ab72ebffa790606e641e1e3d51d8d6a657efda445a0a7c9f64f7ac62d0ede9ea65d8fc82a3426908ad3ce9d7d0b141d5fa35cafd54520da30c703d282781938ed98f59eacdf52fda6d43313467ad95fa0fa73ac1af6f1cd84c6180b7c450f4fd77ba2cc3ffcb5c5ea94ae893418733be168f49d7a06f25028a8549630a8114d2358e2a0af8fb760f58e5578abf1b012dbcf12e304d1c48962be82ca60f391b2fffdfff2cec94cb3cd2c8724e5c13fbb7b0cdf102580882a2676b0ca2ca1836cf8ed9d076ac8ea75e1824e72945a3fbf17b2ba87ed3919fd24988fbc09ca97e26e522d3b1037a24024db42e503b7e466ce68aba141439b948757ac776b49b76cc4cfbc1394d3c438e843f8f13c94fcd65f99d0d25b63cffe94c4d4417251bb1ad16d2be8c1e7280baa6cf9b2b0fbd751593a2f5b9df4c346748233e3846569c13f6cd2cca76b0639b15e758f4dc7276b31c752e051d34110bb2f600254c884c1b4ea20f9b880d336a8da18f89ef7e5d1615baefebb910ee138e3b0c1820a925f1195a07c4d723ac0f80677efc23507c321d5dc7d567189a78d08821c43eddb6b3172b8b5b45dc6a8d788d2043b7d2450c99fa4db428f926f0c9f89a0b42cb76fb04c1a9df5add31a1db68c3622f8a88f2a6aed6d1d47b37c58acca92fcdef9509c53463834037aaf8b24e40e27bbe6144cc42247b073e98324a77496c2868895b1a1e18cb563fc3d12cfc1f895884d3c4437120c9d8ac7015b2b2f56b1fda762e5b82f4609f1ae8d2a52085b4144e7c22edea1e13fde243163786c3805d90bd413be71d2e1f601573cb00967038660fade69fce7338618d823fc5d3ae46f5289992006bb1267005d0ab41452bf56cb1a59ca84704822a3ef80117f1997e12762be9a042d8cae2a4722c5eec2ed1be6a1c1715a9a1453f16cf6bfaf0fc48739d89e2f7f960ff4821e39f50e592a7f7ef8dbdbcb1d033a832574f59e9b0fb39feb87038725b26c71c4d27f105af047ce3dc710f235a3982e0af78aa4cc52b9e57bdf9a4added8e4bf7721d165c4ca4a8d2f98b2aa8d70a2a62b840d80b83effd6f19cbc171f217b6b9152ae559ea3ea26161edcc6925780e010e16e69f7379a10d7143ecc6435944f067b00a63484c0a3ee434b39df9ae5f95f76aae6fffa20a93ecff90f05f155062aec3d9d70013e09685d0ed78df6799ba92a1a4fe1fafaaedba24dc04afb2826a8c0bf1b04d2791f0720425871b2aab67c80cd5b7a69ad2636b09808370a5a54de8f3efc2c033a2322b80491f5e79ec6d3880946895ce894f5843d93e7829f1b77ed2dec3e0588edd1d5c0910ae22ccaf3c480352ba33fe60efa22666dc7ec96d6e69f30693572dba6c3031f7c6aa4ac41d6cee3cc545fe2407b133dcd494b88e4d72322d691fe8684428f4287b878c0f66f715eec5c67e71edb6166521ac87f4a8eb420a013cefc3f3e0489ab8a1e362533f2742fe1bdc8c6c63bc955bc348ff1bf8e1e1d5d7637db8c5993b17cc412c7cc6d61245f466cf283a520e72a58ed290231ea54b64096c2a67413d932e4dfb056057843f7d26bb3d402da1032bb81f4ac9c2706ec6425cf4b17a43822c84098ec09b84fb4e609f354208088d541f5b147c2ee4464340edd53ea90ef86815731791ebfb4b021b927aed0418885638b27fdfa37de047fc928e282182af588f6557846f6f9c557b66e4bc3a1e5c73b8b875a1c5875c3e095d8fd6fe452ab72318c65a2a2ed9c5528a2f4f1ce223add0fbf650aa042a74587d9f1cacf26677a591dd2d3b306cf416d58172219507987f86ca2b0d9885773c9d4dfa32655ec9e09910179f318a27518cc1b703f788f06782897abb6870a58d58451025d7e0c0d5406814eebecbdb4b502f89f53a41c452cc06dc11177b1d97ba0d7da9dcbc5e1aeef54b32f5369229f9241e364e213384cbafef6f09de576d5a6f3999cb53bd18372bc1864a3f1d83e41027fe3c7c406393ab8c35ded13c568d8eb8e79af08f5950df2e5d68de2b3ff295454c361cc051738ce74f4e83f0a43397ce2edc384077d6794a5b78c27a3e795003846fae7728103ec32f60bcc2ed1cdc18f5f621cc1a49a588bfe41ab2bbb808d25e469ed7f241ca5bfd71717277b8badafa6ccf3ab45452c9b828b6381ed3817ba420e8418229a1fc85ac35f23a95296f378f4b9845935f191cc505abfe05408800118f9b08e1230a94102e8113fdfc529cf76b4a5a14de948f57f8d9e9259b9b6c88a83a2e496b78d1d3724de29c9dad46ea5cf392480773008cdcee4fa2a9d4bf05b32fa67661ef632202135e360b16306333560cea04193b74020d9ae225aa6b8fd8150cf6b3c6351e16d4fa41f1508df4a25af57c3b18cfa2f7abb8d798ca2d2ae7dfd6424c0b7c4d823cba7fa907321d2368ef6325415a95133dc24e8d4011522a496634434378ab93d82f376ada0fb64d7789528882dec2e9a8ae9be575fe5dfb90412d97c5f1747a0031162abe05156fc807cafcdec5e5a0a437b351d7c8f57b8d2ec24297b0150250d3bd23d205aa3739025b86e3d70b20506501139afa5a4d12b85d92aded1e72a178fb87d884f2b67338c83a76557e3228202de1a04f01c905306adb2fc962ec7c4d0eb303b7a5e5abf9cfe4e93400ba1c9a46d7e8acc20dc5a11320851281168f82b0f362be233d2ef8ff69ddb155550da5250455fa77711775be813fa7c14811654bf7137d97fac429b698c8a0d975b620e5177762186e60945836efb9cc9f11fd178ad7985edd89bbd2a94dd5938fcab5ef5e27641fe64480ed413949e7a5a2478fc1b9f5f3997bce7d10156b2be4f2436902420d26544ace41fd7c03845d665d0cd038308bed1c34c3bf46adb285f6a08cc978cca008c1035bff277f296f7dd581320ddc8c04303bd8c7552966ca221fe8f118dbfeb8ffe69f1de10815c1df3c17e1ba4fc1cd8e607702aa75d314cfb94de0108be16019abee17bd3c0dace994c250ed2afbb27c522d3156705343ad24cfac037a09dd4a71a2ccb433d9598931cfec43b0ad374511c4032a779d2b6c1a8b5099690b98f0a09af262815159f5bedd26004406921806c102c5612c92089b3db7f31f13a093239b9d1f6d236463eb4b8a6461d92a5033a50895d188ccd137d967508e8ff257b5f00264c469e7b4998c2bb39283929219581ae4f34ac40ca7ba29d4bfda6099dd2646ab323a46776e5e430a7ef64109ca6b5c26d77105adb655880defc196ec7306630833cae1a7a42ec9a02470c975521e7da373a7b570fe0f4877a13dcb39b7aa6aeed4caf4ec664964fb136baba63be53832bd64583ab02a3afc0ba4d262ada4d3fcc2af838c374ca5a0b5b3c93e90df2d5b2a1fb31ebac68e9644067849a8b21376a884846313607433b164c97e3b954a9e8d802c35aff2e41defc97dfa17054f70f0ab33c2b8013e564de0270c5ff95fa0dfd8e8ca22c0359ee3c0c20f0d304ed1779503290ad5b16918ae7afc56141522a0470979a6fe33f97ebcb7ff4f929d7e043d6cc2d730b5bfda7aa77555d7a1fc2cedf236e079842e57f67c37cdf91978e27eb2544ae839fa2117ca486119c219c764c7fc69c4dc439c1f680423a52da9f2be89f01969858d739feed4793dd721e3e9032a5db15537390bc0c711dbe8c994f0f6784d6236012573bb270e2676eeba8af2390cb7ffa851c33db39fb51d750252a5b39cbaa8e09670f1057ad814bfad8155a2b7f1b2ec14977fd7a7cb511c776b00d571b178134dc965d31b863914e4b2a700c1e7abe0869f623c878e58ba2ffe201c88b31d2e2a591874f63084de9f511928db2d2fbf495ed95ee9bf3bc8f9b5ba96571107906e15d100d225a31c4c05f2277adfc9ed3daca8593eda933c740fdd9e0b299b95a6a1a899e7f382cc50a9c65285c32a860baed2b7f1ec2c83cf7f6f0df6133aebc37b4e396b6f2e83dd79bf1826945aa5e3366864068e48fc48cc781858bc7a6a7f3db15027560dc2eb03d01ae301465b8e3033261240662236a16a15b5d7595b31c901aab6c2496908f256484ac3d6e2aeb685c8de3c75bcf477675994efceeb676fe6748347165d977ae4ed04a193863f3b12c655a333b827f8af473b2b5d7edc3dc993d8de746863423ac2ea706a3a550fe823373f2edf4e0c7b4226f90ff7eab5c1afc4fc7619f9dc0d73fe165badaf894d5e8db4e8d17b58ab3ad56999bb07324f686785199718d06ba1ec85410f613497e87f2f22aa95269128384c2da3080afda5a3eadcfa0b3cdfded0d05b9aeb71fce6fbf40cc69f14d52e8ca9b08c4a905c4c0bcb417c7dc499d9133b71c480766e65d4f3d74b98193b48c5958cbc604401bce9ca44670ca71fca0df46cfa873a101d00584a1e640026c80f396f7a4eacf6c36dc9917a973daffcaa1854c35b7a5399c8f92df39facf16a6a0ec6feffb9b0b58d8f8838abd183898ff0b5252770d9fd2c5e36dc1da4617358393755f4ea57bca2a64b85eef50367a9b4b568e316f0f2e6cf73cb7c438fe87b5f308270e8f9a9dfe69def8fa3c2133d44af8cd803ab775a0be8a3b75ff0037c33adbab482514a1c0f092d89641d47d5f468263446bb621c170fff842d6a9572d1429b65010ae3dbbfa27ae02b109323541883f22d55ed9c6511cf4d1075ae6af67927286a4e49eba3f6147228869afc3283ea2cd84f0fe33ee9bf9b1c951dfd1cfb93d4bdee46aab55e51ae9bf629d17bffb66cadd5062c11604f9d6629b88d9af16690976aa3bdf17d983f550d70765225144ea736a3b12505940c21c708feb48cd711efdb76766880000a425003de105bfc8598dc3fe7ad00765ea4a79536e767b5e425f123a9a65fd60072707a7dc3fed76779a8026b2a4b16ef7b861eec120bd84a0dccd4c4e41f3b152a0a9cd417a5bbeb85b68517e66ad4107797c55cdb18d339db99b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
