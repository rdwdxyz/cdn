<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6093e381b44466ebac944b86b10e08d1b876f79d224c02bd3dbb50a6a78cb2cb74d4def61f346d5e1004907604af6d33411561683416af963478d7ee8cacf5e9b519d2166b4c2f1358372ff63616b8bf93d62c64474571cd28eb6996d9d864ccb1c09f57223fb0dc114586851cdfc690aa900c8464be46b318540f0a76987c254b0a470f938fec43a962e9e93f746f86b9dcd1245dcf4f2d20667814bb13d57c5ea6042a97ea62afaa11c2921cbf11b77916b01734ca29cfe8098bf90bcdba53370284768e13f5cec7485725327d695e0bc230a1bb3ea9033cbfec6340e6b8b4292a68bc2a39b8c93345882254ead0516aa08807730b3560fa1696cc465bbc6543485f6db297cdaf23808e71e144e3f8e30878a9d05ad07c9666089cdbbce9b0b3d7498a18561d6388220294c4f6a031c11b85f3564dcaa8c7586bb5d9bd2f0f4f2077904cac75759580bb5a119aaad440688ce42d92816198b4b25914c096f3d475d469f85d37f0fe03cc0cda3d74d613c202406383bc936bd81f6f267e0a81542c2695e1412eb90dd8dcaedd4d970f7c4c77d86930942e4ce4254f468d6abd6995b1e4f1cfef3d2c1332b06fc93e848e9c0959f8ec52380a540315a9cdc7bc15f5d422fd9242a302b2a6b9d3a53e0253f4ba42fa4d7030f07cef4b1b161a2604f4e51da3cba56441416cd84dcaca1e31235e57e39096e8ec81c2a3639976da0cfc8ff334e3a4fa979ac0b10395af94612bd33a5124f17f677a3f26b304b3894de3f94e3dfe1adf9383b6668998d7f3d7b4a7126b98ef3264acf76d2a586dda7302399d2fea4516da803de6764bbcab381960a172062ae5328e7af9468b2e7b92354b03bd8da1f2bc561752549c8b68d564bf62299f3c7e4e679ab95b110a9b03563e2da8c1226c21da76d82a097862f9c073da89d686ad2d95113a31974d8bdce8c84e7a3cd90fed71e3edf76cfb7f7aeade71d45ca3f3627aa120556ca734e5770e891c48f318aa4414382113cdc04293db06915a007907f774e4b41db8d08dca105fe42266cb6aadbf996c336e501e735d6a92d831356b4692ac1fff9df8a42d5bb68b4e1e2ddffc6e44606018f9e2cbe724617ee2feee20b63e9ad25c7c52524910adfb747d3b88e9e8e736d0dc35461e10b94809c21ae5c99fa969de961a43e232cee0d7e166e4db1ef3864252d84b7dc0ef5c59ca57ead0f75565166f4dce5d319bdf8fab3778768d14204a3c697f748562528addb714ba1c249f8c784ce21cf7cadb3a4555c458055393ba92b3bf1fa0508897731ae0a2de13efce2aeb56a387d13c1b91012392652929233598ff94e7d23f1d1cd1ee720e3e480658ece79916cca69e5f9d2e50e7f6060dc4c2dbdf57604df33838bdf0128be38f492557a12e822e854ac3ceeb721db3f1b9fc092986e59134c17ebafeefb90f98baa40f22246da4908941d39861c36efe5cae8ac81be65861663491244432fd448117eca44777c4670b8edab37c59df3a58d474ccfd46bc56ada9da53a43cb465acc27d09e0853a214644c9bc0eada7f0bce2199e29de68354f257905795d0a61d05b9e5976072d70d6923e3114409c2c1271f259237ffb98b5ef94a189a13eb8423cc14aec692018d3ab6d43987df4c8a80d8e8ade1a4b85f27db0c8017722ad363b314cd8a7eb55edb56837670127884317e5d622ead4a3c3369b23136311ac44dbe5a18673ab2cbd90ee27932359c3afd7187a0ab9cb03731ae0a45131b6fff323dbf546e40d5f41dbf2d85aaefa90a6eacb2814d36a019b2b8e20ef66dc03faddb4f1aa549be4fd94ca7f6a80e1c274f6182ddd7181729747f920259877f620fd9e62d7745790fa4ed753541c5e5670dc046f21b97f3300b333ac3078d4b425b6b2df4ae10733feabd3d56109a81996bd375e3604ea42c6f2ad9ce292d6127cc547a18c71d0dce2677e58a60b63814edf3af121c84b9cab64e6e1972d7f70d4a0eea8daa081ba9168b828f2e57fb204c235d8af028260c012505d192758e89423601f25103f98ba9e5c688766a52f17e5c16b191b1795d8787b027f49cb16a9678ccc6c018fb11e9228d26d99ac2d467ce2c1cc71c2c85d221cf26a2e2c532737e47cc3d583ac6e0e0db40fa0b33a2f33bc6857fd2da38abec03250188d0149258fd2675e131e162f8c1b203981128a98fa67d47146c5353ceca574338a6fd57266ff4b157739b20933a47c0e4ce0bf66cc41f8794e9ad4cece3fafe0d09988f2d1370474279d513cc6bf90f00a127831142debe5c9e1fffcefa705a15bfafc95d832e2e8d01a04bc1d4834bbb6bf73b645f737f7818ffa57ec9e029ff3bae5b2f8c0328443e1b92e193615a7a061a46bd9cb1f0a7bef83e79916572ec9c39b37b5173941401ac619fa824ca55ce5c5615b1e861e32a390282a7d10394ca19470e14b5ee04622d89129493f9711df47c050a63df2fe9aa39132e94d10ae5a8898623c1c98ceb0f4bfa76b72ad3aa628987272c5d42908090c87c44773183f1636f02ab9717e0921762fdcccb980fe35688ba42fe6f3c2295f362e47e2524cbb2ca416217f40cf2a63861c413b3f3d24c2878483873a0bda9eb8bfbd6fcf98aa33cd2d58da113a2634cf0885bb56efdd5a7cd2ead417f3dfd752a878c931f804e8613c089db6b46bdd24cfde1c0adb12501a7ced3aca479d0c2b600d9eb6fe6d37fa269dd99721ceff9f4cc799729718ef23a998a6e433901c5902925154b9c9fe8ac913ef84e55affae71e6ac42b977868e96864565440f4136c721a2d92383e5419aa1a9e949a87bce8b996c89f5e5418e63868db6daab5bd4d2656ea1e4f63d97fb09b320c510082af9796ac5fa37620de5bf2c1ef880909ef1cc1d76861980388fa816c2f3dff8fc30e207d6c475f307ea4f83d3b8dd831fe9c610dc3636b9c5f6bdae187e525875e1b573f4172e40c024cc6e53ab139f3efaf72a913948bfbce5501ff0f0c13f0b73bea3429df98d54b77dc5e9dace4ad1092131309a915e74f982db246f851163e356f649e836c2a0c32c3324882619f17af358582b94dba6052ca056f5109b4c52f379fffb05ee003262581ee1c8009978ae08be86eb3cbf76c1e1e4b145d6a2fb65ee0d31ce71138795d4d75418d45d859f717882cfa7be07a32170acefe560cc89882210bd52a08ee617162c0fd3091103e5d13d300c91cd57627be1c53af6a2197354dc43253fd7a379a5a4456d2722d2d5e56540194dea1bb3ff0e39a7ff95c0b4057f8bd7ac1f2432a5dda8718eb3e376a719328aa4a2d70f6c5a0fb0232358eecbe2cb376eefa7117b3a8d6394450e8d2ae6fee008e3800d48110c414b0afaf5bd3f4a50633544b101533248e085f1b5cee8308388090fc655aec51150bd5d5a7ff03c35b4e231e2a43875eb992c36bf7eca5fb0972249d7a77189fbc19e46140f9ae0c6225e06bf745ef2a18d7d04760334314334fba70543566a0a97ca0e967269e422994ddbc98f2afb66610813239f2a8ad53914bb78ae4a2a354b21d056d71ed9c8ce000038c2d712b8f9ad2ae7fea3a39854f6829eb91c03753f715987145229ddc7c81822a0440189e9fc8b307c7e2a2701bc8d0c6754e7556c9a2dab099bb2305a729b75b6624e18c1a93e26d609d80552d4bc537670ec1add7f8ae3801bc6322d3a0f8d20bcafdfa220c3aa029d44033cb4fe239921ed6b90922d411146a4bd778f25ebe04e4bc06353285e95c955e7e20a295555cc9d5b198510f4e1e2f4937d1c69494e1861c5ba70d49be00bcda5bfd2a667eaa74228de806ee7c2e1d4eda1ab2f051d18544147bdf94ad524556ccfaf7c2084008f53381275773b1cdff6bd55eb57e4a65fc950addbbb057ceeb04bb582ac40b33e8c56baeacb9f3719137fb6ab576020cc096ff48ba92a5019703449e0532b4bc5eec9d46a55290e34d75574e341e1b8508f0678053d1a78c3cb78781bbb01c6f7113f18c7a60bc2aca1c13adde612e09463775f40d7ab8a2c7b77ef2ed9704c3e0d0754f1d3a2b0d477037e52e238bb06dd08b5823af7df292e916656dcb7f4c75cd50de92568c192c5885243a08e1ea15fac451179f0a85afee5c25cc4da7d0f2592eb37501513d82319495c87329c9908196865b69a3bb1c8baf5c1526eb02c0e32d590f9f4227540787a19e207bc7b29731e4b2e724d854ad8b43fe94cd9b301bb0f2f3b3831814a5be19dc018986a8053c3e8a906199efe0825d75fd178b9f06f549109394dcf533e822294c90322c363974f099d1064f928e18f3c619b1b270f1159d4c91be1da5b2afb35203a390fd96f260873aaeb24ac883b8a76177195cd0470fbe002c2219de2e9d138355e2f1ee224096c07e0b089c5e160aa8df9d19355cc2be290c862a632a1fcba53b1b41e0f15ad784436ac6a6403a8d1e4611f6b842f14acc11037f4aa80e927fa9c24240d977ba60573b4ce34b219769db956579a354f6c37a2db07564d577ff2d92ecee90941665b063dc9e32f27dade5f8917547e0aadf82f1b37a3569aebb7b746153c4bbfb69a814c39ef36b74724c2ac867bd901720284df425843b511f1fefaab9f48e021c25f31f5b849c3aad66ccdd782f8c459ebefba91c5d790bdcf29b0d6e9f6bea9133bd44abddf48a97c812196a3456ef3d72163ac0c32a909298310f87b7e245be1f46c44086a77a3111bd66790fe253b0cd9901cac2e14a45c82ccd23a2ee1176869e74c54c1c9df4c9b453b31c32c8e6562ca63e39d6ec839fb4a2804f0576d84d97176f5c340c1612c164e1f55219dc5251a568bfc6a3630c08234d2b078f5f79a652e3b34ba99d818526159439ead134bcbac5c1eff03e4a2ecc20403fb9d4b911275b8d32bc00022360317ae1e5750d40f4db3798367a964b45d1647ea88a8fe03c18e5ec8b33b0ada9a2fd32b58a6e6b30ca2472dae54d8c15ca56a978a69f5d2a6b7e8065c12f32554f3586fc54fcaec088cc576adfe8f43c8b661f6ba10a4b74c5c2e4abdc0b6b9e358f33deaf7be9c995b37278218c2dc48f829afa1e74892c27d9bab87ede544aef301594cf7f860380858484d35b5d1fe46871c53bf5359647043ed260292fe3398522fc927a26c4ac80e7c8066a13147e4515efc1c03ba9e3c9f1185a95721b586cb78eeae57f832b17399c48d1a44c4b37b626b0c7f079d05f047cd6d6cc121ac53a7d9ad15965e15049945c6aa81b621d6bba2b401d1c9bbcc8aa95da2579ee620e234734c0110e8ed9ad1911f257fd66c3e9ef7d45c468b8ff96397d7a058f0bc346a7fd87dc5bf370f6a3d5e2a927dc17692265e8848b1122a5bb627429bc082f37643402371b34e56a2cc1bcfaa499dd0bc4a2f8bc5c1463bf5b7008b0a361ee5b077bd08a25ef8f0878c0d3cdc3cbbe831d760e0d692d7d434f0c85cf0cceb9a7d5fd70108999d500e9ca8129f6ee65b28d44b22ff3f5bbf5dd01682d6cc00f7e301c8730bb208c52651339e08eba6576a92b11f17969a87a8b93d624f8a1712ad10d95c0c59309a080a972704a25c547492e0b52c93b49664d5dc62398ee88a39157d1ec1fa4a349a90e95c32378fb075782c651ca06281901a02d654141d2f1541b7db22fc6d981cfbfe4d4c14aebccefdea14e89137e2a8c15a6a3df6b2eedd816b2c6dca48e586f871df165de996649462a8ca5de33c0789e78de569f2d540b6d4dce42cc00bbeec8d63311da5a7dba008a0c5536426cbf498f071fefb782867789dee4b3524c7f76551db05884bd73d2577cf15ceb9d4695eaf3e47d3b59021071b87440604ac613fcf96dfc97ebfbbc1908b4343740b7d683c8c03e620ee6b279119d5bf35b19c5048dd88f35caa492874c07f482afe051feabe932f524d061161a2514938d3ea088a90be31bbf7db89c027e3d285f4006d9b53c7bff3ec787ed7394375deb33a8e21809a69cb8f7927a5b896fda427e8af4dcebb604751c5071c10d12d535ff7bbc1059542be57ed40f5085e8963a6afd3c2a58e028efccaa5697014021754010e33ff2038aee5d177f29fc4f3db1bc8fa05989ba233baa26342e07fdeabb6a146dfe70a034703019e58a2169750d8879944c4c22db109a02156b486337594228608713fb08a39f9d1df5d7e7d45ddcad3354f9c58228217da83eca711428ec4a85832a6ae07e01ff0a77171fd9e62efa272d09dd79ae97403c5d75debc7438d021c2ec05a6bc64934c66aa61d135f8db8a60a8be748e6c39fe1e6c1447c48c8bb8b05fc1c7e82fa26893690d9558a52ba981c468aaf3cd618f00087f3be8ae71dc367c762efe60e4c5ecc87bdce4d8591aaddc2e2621f3819ca4859aebfb2e86a0b46eaecbb22dcdb29857ad11ab63a79fb7cb5951443642b13375cfdf94fbba68fa3e93ca65d60a1a8e349de051f150f9a3f06fd7f4d88874ec6dd42edcd8eebc80d8d26a5c0b23c5c06c970680b02b8144335673c546d18e589d91c4f33e41c60ef0a3bb609fc8a7102cda838846f231c9fb95cf0f8691ac16eab777e430b5aa79c4c43b698556c29fe8a0517db47c2813b4cf9820713c27a64bf69b91d9d409747628c38cfa07ffdbfc96923d1590f11e120b25e3064f07fa4579dfac5f8e3ae4e78438ef221feef92992523daa2e0721360869cb28b3e02733417b9dcc58e301bc1d18237eecefd037c844b3f9a00b069448d572565dfc2199d6dcdcd45a22c8a3cd3257cfaf4a5c2e7c729c3e5238a73b926138a1c9be098a459a939d523ad7f45e6f7e0d4a15942604a6d1f669c670f6ede49fe7649412ee2387d83d702b8872b1b45bd56810cad909133f42e65682e26820de1f2568682d03c75311dab035f00b0b29114f7feac5fabca545a31529ca0e1c30b1bccd4aa58a16bdd6e632e13b1ebb0484e3bef9e6323f5a6638678e7563c6a42d45f5eeda1004f5a2df3030e96c3ae40d1d3310ba9ab476334519bce0c70043b74d990b84b87e53c395c01ccc4685548a4137704c78ad269a7d6da1bdf97867616476921f5ac20df456c664d2baf9af9e7e11f17ab933fad8609d9beb0b7a378b831675fd25e37e8d9682dad6530cab747ea24d30e78182ba9d9eeb530856e37c51ea088d301060b44b8183d03d60110e899786eaffe79d1294613c60b8b41942d5983f9b7bf68b85ba19c6e7355b7096c2a8937439207e505c3e25cf0c640a435f7b56345d3b423adf433db3c4f3047f56dab7034224fed0575b6650fbd181815bf75c3fd6161d1abf62042b40f929b5ee0c23f538a0e64f1a2b35aa447e7ce9c35ac8c48099300c969b917b03e97899a0f2cdb89e156cf2a8e4146dadf3b2404ba4c323ca07e39e7421ef46e6376e4b5154db2346f9f0a2932411116ca022ed09d86729b00e411cb0b686faf41f3a258146bddde15a65de2f2afa0cbbb513928ddc77c95cb0e6b3dd5fcc5ea6a85693110f3cbe7666da681db5f71410f07e0fea5df9ae7c42f46110dde125498cb6c353a17d5c2c043cbe67adad662494f7b1de9d06b33be84cea0706959c27c7f02901008f4b4892657e1f7345b0fba4f2e7d184fe82063efc97f29b974ad248172797074ec272263ecf714f21e5496fc13917bce343b379c31db60c98a77b9ef8c85882d968d4d59809a783424aa5110dfeb703ac64e755f394d7a9e132a16df18d3d52c3ea67dadd3c119632b2352b2febf8fc178838ca482e69b169e2a28f9e2d0ef2cb125cb1d51e5a6575a2dc9df25c6cce0d789ef0ddfa0b22cbf633811a849ec1e36922d1a295a798eaf5888935fcca3d2bd7423f225ad37b97f3a5ebc490ff6dd4155667fd2a9c9bdfb46e69e723f012862f040abc0d5e63579e6dc5c1715cd1bafcfd4d37b2bf89f7b97cf3c5239e77248f06756badd3400c424e5645cdd113bb1e2e6325fbfc39322fcaadeb352c42bbfcc95dff9ee03795f6065c05218e4dbdf2b5220c8269e2eaeaca090867b44288f15ae2843b8684ffd6c2a5aae22ecf4edfff6802ff287156b26539445be7b04166560a7f317845f53d8acc09d11d55277a3cd03d9d5b50d67235ae5514fe76d6faa9cf6bb811cfa580319d8d6a6c5ca618e1c6ee4a72fcb3c04fd99065722031cfd9920b36ae78f4ef92b533f664b93105fdfac06ed76d5e28763f5c5a2dd92d66f59cd2ae5d889f736389da632ed6e5a279b09c81d9a953f129774999dfe6deb45e2c87ef7f4681aa75f53d4c67aafb045f04d4a78323696c2002095bcb4e4277d0d35274e9b95bcc1c3291adab9dc25581bbe929b5bb7510e4dac0de1feb45aae3cde1255b60ae7147596ad7034beb7416f9b17abf3b050d41fbe3009958c89413e6cc9846ccd0408a1dd6dd7b6ef037127cf08a8bfa9ffc17b68f86b8b52a6b85ef317e9828cccf01fc17b2b0b3051614329aecfad0e8c4ffe8333deed113532d0f392d3c8b30135de1b1ba461253714b980217f167d79c450b4cd7424dcee7768c5a8ad95b5eaa5ea7da96490679c904dc8dfa20be46ca589ae7179ebda4270cab6b065e2235aaef0254f79ad9ab36f71df313f2481879b11073f5ea36fd97d5663a13c664baa107dbeddfc3f19890c00cd7be37c69649e098cf22449886a15f122f78e52a5a8dd4ac428809c4f12a886a316548a56acb6ff35f18566eb5cf0970453a410ab0b7132097a4eb7096604a20a3a88531255d044f87d40b9d5bde2f857d6c1627711560ffffb5e080f9225343b3c1de187d2ac43576aad135ffc176677441ff57ad2e420a2963ab9702414123bbdd72036737140f9561ef708eedbdac98820a89ea59c4343fefc729adb7956b066832490eb9c3f9bb7a7e78f3b390e45032ab3b9decd449e336f7df6e817dc539ccf96570d6f7dcedc622337cfd91a5a4d6457ed6ca9cd240bd6509bed8de13c5fa1b4270f36020679e9b1e26f5011c999039d6653193eafe51872f6e28164bce6ca0648a63dde594b1172c6a4d4052a3bc2e3a90b1d7f98100ca5cdd2cef21faaea81322433f96cb73f4b450bf18013335fb62f9817604a65025be888ac343090a3e7a8d86e57ffe107627229aacb73922586527835a3d3262a644af3a63efbdab143d8dd20c06def503298c370a392823d817e917d84cb66856564e2953c00d95b0e84540b73bce7dd76e77ded0c23822f01924d387fdf3a0f3ec6c672397a2139ef8471b900dd3f05210fec85d641260cc754a865ab9ae7d50af801af3da04b625f3317bdda6bbf4604c8d76c16b22d8716f390d5b5821f701d9d3c9ec86edb317b93b8b94046df7e6b06a7eec87d780cf0fc5ba625b56e854083b5c812f9d465e98409a991acb79e066c454eabe92378b6515e16d047d399317f3aef3739871c5147c8d81bcc9007c0d52903dc069f3b598925143d81ef1ccb1564fd9cf03d4c53f9417490d1dc62756af1685f3669965b6c7162e2261caba437a285936cfa1f3a4e2cd86c0fc3ce2e2e6da65234fb0f6a4a09a6d6612e082f397970aaad50182afb7ad179b5f2053668c77c50689fde7422cdfb0e3aa023297c1b90de7a38b13f00f809af7616f03c7d81cd3baefbb9f3b272f3275052e8b6083a0335d087889192cdffc60ff5a849acec888c7e99bafc57ba91b570ca20e505a6a724b4fb065b91ae796dde1cb27fd541311dc702ec94947afd41d4ed935d710e8d332d332e570992a38ceea241c838a785bebb3dd5eb2c947629671ede4234d889fd8ca8e4896e6479c20a1ab41e00856eddb2cb3685769073a9a088c3f75d2ff50fd774db91cb2148754089e58477918cc0e4320ed4221d3d40e879e98f7da64931b55d03fa5ab11c10e2c8e27f1dafa9ee1730947e0885f7118bf7e1458498b6d952735044c835ed4212cabe20dc0add0788c83f1276c8c6f2cc70c8d9939e68adc2035cea831125d876e8f7a98e8b3bd3903941e11d03e87ca6a4d8f4dbae5e927946c6b9f00665259b4a4a7b3d0d2f3f7a807afd57d91d9fbb3f5fd3751322da1e3d1dba0e390600dfb4b49a4299c69edb14784c7960b86c16ffe498faea454daaebf7c05d1f092bd744ea41c81dc9a70438369eaecd4114ea0a0dd2792d917cf5eeef4952497a637b14f57bc0fb535e37f5cc40f2afd55429c85570f1af5b94e6f642bdc8344d4a2a0443a145d69c5b05694de019a9f2e42a91b25c9d37c76832f5000918c65149f4d7c7c24c12d8442003b4229461ffb5951af9148208a6edfe5ed5cbf8216447b006918a7f486e207340029e1509026fd2a72b84c8e2e2f6aa26f8a1b87d1d1b68993d4b74c070fdc120711977f431eb94e01a1eb75dbbd148722f456db58b80469f93715865e1ab42096322cc412ace4c60755f1a52f995d1fe46a6a8b5a214d7e41e54177d38bf40149a3ef847563d33311a108c672f65b8e16228613e7d1b3b14d8bd3ccdea6d8c2d103990050dfeb348ed44d733f28c68a11b98f1698461d6c378b0a554810f86658e18f7be320b6a0dfb1d0fcf9de6037febd64c87f13d208974fda203ca81baac75935e514196ed1c701cb7776b638e7fa42c8e7421854b3e71dce80466ae20a383668e36f1e603840c08c306b130bcdb1985756258e466bdf9b83c485a9b09d64f39473669dc37ad3cd39987c45ecaa6ef2e97098332b96641a7efa86393779cc2bb1416ebadce33fcea487093a7c73abd9101fbcedf69e46dd6086c7f16431f52e1e4a225f2ab0107400710b906f9da79504069866a794566c6c8802d89d5af8a331fa03ff2db9ca9af0a100037e04627c635bea7b185cbca49dbb2919cab87c118169be55076c87b3ffa036f91f777bcaff08405f9ae5e980306895ea1de545c60aeb63e3a936e86487c624a5ed5f48a132dd6b05ab03e4536f8d7d0235e7b1edf05be21b8a8d4bbbcbaa30ec6d8dfe8860fbbb21015d45f18551bae433ef2b64c333f9fd7bdb53c7956f5eded0a167bf68bdd68976152fddb1433433a137db8e234522df57f4f5d0415f62b1f059ecdc9b980d874fac155568177c247d90d9349769356f042db88c00f985a9ad8f8619ecc14df6b2b13607b1571e0006230da07b7909f9109fbd6dbd746ba23cf5beb95687fc435d1421189c51e07a2b57f189d3533f9e84da8e6e5202447e6eab02f87a42baa0e0cc32c4aaae083eda672341d0b5c58652253cdc2b540b840a7ce8bdc684d94a58f0439719b6b053b41fbaecc736c15251696328de57d46b3685c129725770158a111635b53f7d218889d329428d3b8cfbc507609bd3c04bd44f730aaf0c2426496577c8688a2cdeaeb8a93536f6a07d4a8e0957a6934e3fba6e448082dbccd97bb03f32a30124fe2b8d39c23e96565fe1ad6be00ac14f086ee2231d7f3d916df6979640db1e1e6d709035def42c99854437e937116486912d18080701254f342e2818d5bad85226057d2b12f7bec7a3db36b94cc6731fc515ccb04b610119bed6177400f96bce26e460eaec2c98b137abf6750c608089fff3fb10f8b162eb5f7ce118c982587743b281ab8c77cf69994b81987e71d834ddf425f87d5af85a6ed281771f0d47c17b3cc00478419276313ac4613dc53798e364d94466b9b22688aa6121202b61e243c3654069870411fc4c37df4f1197c93a1aa6032bcb4e1a6085372b1009718cfa8bcfd846fb70b1b5d56a9ffba6b8b736999e9695ab0667ab83638efd39ad897b8e43ea62d8ad9f49cc74c9c6794a6f1b0f212bbfa30e722d604139e8fe61939ab94856a4bccd2cfec8f788c3d00101384933fdd9dce9debbb8823656f81648c8d022c73d89e72d3fd46b60452f1da6bbf98ea8173a8561695498562cc2d0a17f47f3d08c4716f0f6016811181b45fed69c94011112e0448abf3a490fb53df885a930b3c1b8f0974e343212b5cc6fcd577fb917eb1d3f92dd42b1a6b2c0cd6171b5065fd55a98bbfede378808a8cd988bb064683a0fe83053ef8e1637e622a30705dcbcca05eec63a17df8cc48b0e072d4c35eed1afa8477d83a77a20f622b78e4675a426f51e387bbda5b37d9c02a9eaacfde7b42924146bbb6b1d35df225de246051cefe9cf789621b4c1f3df46cbf9393bf5195e7069f4498c362bc49819a12b6723993eb83e0d26d095c46e30e06fd2a9a56911f801e2e900f470e95a71dcf7d622de8101031775a17271bfb97841d71cc2e824630672535b358c77b7ac5827f2bbfa57929df7b3c717e66e73e16d61ab8a5973d3e136eb12cbab4c7f05c9ae43af907ba85a716da742aaac89fe3ffdde49e7741ef1e66740ccda4af3411236312fe9dc38c37a16ab1502e857ad820f9373ce1b56c69db014129ffcc1c9c176ea49ece02a3c0c289e5f7284357842b96142cc6f9e2649f233b8eef68af12c8541311be25b9a09f3ae0ccd92cee519ccf299d706d2da5e70ac33e18b752eef7cfef01e1228811142b62e789c19fadeee545bca9d5a20c27f968df16b2db688c3e2d8ec4b4b9202863875aa6240751062878d8000be07997059949d6738e5306aa648d5ff5601343d38ced89eb53c9298f6f82b6c004bfae76deb81b2028ff7739be317fb2b4557729d180cc23bae5698180a61ec78522f4b47c24e20296eb5685dd35b5346cac63d54d27d8771c333c8aed6b6152238306402822ffba2ee3450b7c3a15e3eee89fac040d4a29aad73e4720d887b832a5d70e8e97898ceedcbc5b2abc65759dfd49d90a240a2afd38d704d2e7c8a73b2411930915abd528e85fd6178745675c3ee8601e19763a52118bd77f3cbb41a4335af66e787db8375bc6b5510739b222e59fc944a8865cb1feeb81da9e716ef8184b0036cf4bd60f8a271b5953a9442a303fc809dace868dc6ace59132aef7fc339f97a6942357e4085a993e9dce8474f370a5816a730e137222ae4bbb757cda9cc3a16e2af5e8c276867cb43cc089a42807f8be83d376b2ef1a00894c8c83d9272090abea67908eb7bc8d06e6f09e18aab933d3ef2d8dbb328d76fb6ed4ddbba042b3d78b6ef29593f1c7bae9eb6d05b289eb8588b37b5a2331c705b613cd8db441773fa5e16c3c956fa2e0c78a3b5f2b90a142cace034ec14a6905175315f0edd4fdeaf23d59650693bdb21e3596b338d68e2850e4adabd6b04774fb083a85c269439de7a6e04866e76b81fd82edafbcdaf34d4a67fa70f8ed0d6b0b22e4757a3dc7be5a7fd1616b20dc0d633a52c304022f0a99ec6694695a7127e1bb04d8579f10507cde524f998c30c1b1bdc1571ecef058f414a92dd481a7b1f727f6c9f3e584408647faa83fe1a8f869345efd6f8015d2455b71086b7ea8064740bbd2f295b2d532886556d6a1a48936f7dc5838550dff4ff97b39ec252e6884fc169815b38130c447df4a84e6ae6f7dc0b88d2fb895da585a22d45bbe0eeef2595d55103fb5846fc1ba1708c5ff9383d44299e1246c9adceb7d524cb67e5a103d6c5a190b02d5c04ffcaa112f77a969c276f26dd2bc2a5e9b12ebc753f82bfa702be8238a2b3855c478593daafdfe462ee78fe0f9248ee68c704176977eea2700d4b088e8fad3d7ed9f83f1d93f2bdb19d891f92bfb8894e360657820d0979b66540118bab63a19055bee205d01f5d73f87363fc95d72a243a584a8cd24e2619db7478c9842a6b79e5b72a286ca78999632e73a442ce0916d7a53c921eb940afe705c211886afe67465a35ae26ebfa46cbe18be92bdc0233c16ebbbd123e7f3eb2246c7449d35a301268b2897e2bdbb9c41a866b24eb6191d408e1c739e49cb9785c3225f6e4c7ddf309a6530d29d13322edd7d4f2e6134e8adaf660567194b6aabf74aa11ec1abf2afc37bf438ad2b1ac1132498c0dfa15c8b319c8f2cd85562639c02d28ed046b95e9fff5dbacbb489b0f405ff220d3da1ac44661c66d605e8c181a7412b5bf3d97c6691e6338f16483f02a337bd88c294efad68a64949f043a4896b01a884102e1063852b75ff4f435c2f5e3063f40531f1914d8993408e0cfbbefb4f85c7b0ff51f139a2baffd5382f0cd5e6ebe2a24bfd621d4403e43f8ce5cefd3de5c46e6d923602b766a05283a1613c065ccc1d5713f07227671996d1ee665621c9e24eb5956be84dd261c6d87b29a00a35b2d5a42b67d638dfcc89849a0c321c644e712aec81f4a76a3686655fa352739e521073b6a95a72c31e2ab612a633f2b489432e16d2e638bf657e4d569ca0f7741310fda42dee73b7e7e85dda3398c371135d9cc10f4e0c3842812e03a8b5821d10019d0b1c9ba6c5655551d4813c3cebbec301680214801423725d07244e040928143b717fe8b669212b3db340983c9c646e25f2be77a3a27f990ab92ce3015226a5843dfeb3f7bc116bbb822a79d57bb38a4e93b359464f8e1b49e2a839f83f645e9dbef83888e663af894dbe36bb0f8c59824192f6a41a73b1464f790f4239ef7aa44d89aa1d21b8f1843a00649445856c8fc5df6dd7380ea1975c2688510e81a02f5cb22eeb575dae965280da6ba124a6d03a06408af83ddb77b9d19f4247aabffbedbf174eebab48df43885bd39791fdecce5498860daccf09dfc57848d18b6eb2e03cd0109c2033fedadf5a2d7182dabb06a63755a7566dcb2c04459b70a1c467b84dc8b50a00e066442d8695c185ea43c5cf346ead9b3c62f533af483f1a7d5b106ba06bd86d5cfa04f14d7ab830a102303e3779c583c50fabff16e5c37995331c49a2b91c803165b5a2c6594f95bdf03e73c60a3d2b5de5dbec839b4b641eae0b2daa64440c67bb9693204ea5df91ca241fadeef1ef029a4b9f7ccb2c5b9d7d2b407a1e471c05d7c6f2e5c60132c8abcfe632fa65cc7e25256588d72ad15caba44d143fd68568efc2531eaade366997e1a690733e8af95b1a72312793e712616db71d6ecf3c533b0251ff5c0ade2b8400d2ad9490932003723c6423d4084210f0f9592573856d5be689f592d50e88436bb5ccee7888115c4ce81cc50e6a3d0bdfaf3d8cad6f4300f28a979e8e47180ebb24987ebf53229b39bc33c13625705dc7bd467e85f74bee724c601072ff3bd5673d56469ff63c8038f81ba0b2a60f4ec58e4eb13cc9564ea6395b03a38c7ce189c673256026244dc3782455bd764e100840fe0358fdf4bd51d8237035aec5a849b496f0344297e2d25800488cc0fbe16038c0d204f0cc97ab1cae2e07ce16eeca77aa47b1aa8ef1dc0d9a129e96a77bc86b06014b05c858eefe2286b765ad8c3eb41c878dfb2063e62cf2299978600aafe942bd0e27e8c9e775d16e44d72b574ff04fec7c8784a35416c2afce6863129b9d385a221d639a76719c2b373cdbc65c06c0d1ecf78fcac511c1160a2e6079cd4b50288f0acb079f89c33dbe80dbfa219b1e7f69bf11cfd2cb628395e59b0e41a0c5c6b035a304b5086d191c15a1ee4f5db6343893d1777c022d002c90eb26226cfc676d5a9c266415407d7ad84984cd2009dce873a1e5a642f8ac52e6eb890a801d4af2f16008e776b5c11c18654b2d4b05c7f31707cf54d69c82eb077280d3df191f994be4b72d91a8a2203bac1a5e8439f7018bd2037ba7a2664f8cf70334fcb6d1ad15e07695439a68c480165f9965797099efcfd91c06cf7385d4eb62207d63ef798ad559d32389289822acdc3b999ccd18d8a5c7e33da83c32ce9ee9d2fa4cdc9bd1e3c73aae6dd95e7b613ff2d3610a0d8cde91b932fc989437724ae82e9f303bc8cf3cb338b2e13f29116e58ce51e5f7c9e612d8d3f7afece2cb23e62cd6c4839d0d9dae0a8b609168f9c26acd2bc8df625e5112e1c231a7f0f3df27b496aa224f3bab5d40a0f70f45fa5b7fff8d0c66e5c2e11ed50a77b663a73e134d0d25affb4d224a1ece543c4023198b2dcbf660c6e850ff7c2802bd9d7e3f327a76c3b0161f5d155d7108ef1fbebd5292a39b950b420f20de9caa1292dc5b41ea19c7f0d974b6aa92dc932e066641c74a92cc6fee4a2d8951e11a9df916abe88251d0de99686045c6a21bc39184d76cf3b682e9e87f253e07e7212954e0ec107610b6504cd769d9ffe99f3972c8d9072a19f681e70ef8d6a864ba0b1b55b99ee9fe2dd2a185a0bdee93559fb4b4b484d94136a28ac6af334ed8969150302d4ef80a24d04ac3b9858671623db4697c9a85a718aaffdffb956041d913d3b92ee5de30a1a0ecffd09d284e009e9eb7d9328c49fdb818c734833b5727dcb3157627269fb54b4fafa021b6074ba64b527f3289ccccf577a5f520cea894e43c06645b187d4103035384ec2fd57e1146083733b3e927894d99377d3d7141ac14eba0fdfcc24982ad821ac2c5cdf26004d15591a2eda63ec00e8f18a40312c9098ffe2498f7c913eaab033c9e22f33c2fa75ff6bf33e233c74678bfc1de6ec301209595f38b40ef03d0c959497788f8f6d8f9f1f6a5e33300f56f5487f5ebcefd5b5fc6c927a8466f3d63c151eadfa2857bd6bb498126a86ac42a7618db5efd35ac10701bcde12088804795ff8cd418a599486970d266f4d97091cfd7ff8836955c14ed8a3f5e7b21d5c2bc06bd91bfecaa357564f95aaf23c52ebdb7d8bad6955e1f060c17f55d31587076c13c6aa5242afade95335008bf2f79840472ed60a3d632fd7f597f8464d028e06670f891c16ea0f774582ac521c97940a0de98d5c38ba4329658ff45c6a83fcd624b6c057564eb5c5ac639922ecfc525cf3bf1f8cbaf932fd6ab51d6d4736d0f1227582a959e21914c029fc5ccb222f30e29a5f3a343383de6d8497b3a7242fd6b821982fc352d74ea61441d508a76412c3e696a1c1be89021cf0f338813a0154512cc3253e00f531cdf837195c9ca8d70bdcceb861c4ca5b8bed554798387d57a63ba4306a9e55c73e655ea96f558b8602b85a54f818ee721df779283ae2465b86f577ae4acb86dd9ad38b706a143d511c97253740fa1e3e81679fc6b21819b403cf471b0943a7c64be50ab5e7d0ddc15476182910405aa2c9569a874f63755fea79bbe563124f27768829d345d313050b2af57ac534f4f0957e9c91f2d54d3dc672b69c824be5760bd6a9bb5644f6585f5dd105dbe828d492bff08dccfbd2c43b3512aa375c57be6b64a40e73fdce2e40a8011cea3517f79c87b1959f81956dce6f46659ab0ffa8ba2a05701d6adbdec9e78c2f78067e608688fbbcb90cad6df1c7fb450241271620c89f6097001b5a857193c9a5e79f934d8848c254cb5bc09f5e0239bfaf2a87f38ed2db998a6ee6bd4ad39a30f346d3a2664854eac97ac2b702d583187590b0820b7d24129d4a04e147be86d9c766026c9bf8495e730b406cef83c51e3bafda7b42823318709cc7a182f5ce4e19db3dc6c7bbfaca6ad37763534dc35e89e55327915773975e0f13b2ae1039574e8ece7d911c881c80fc5b717f2ef6b1e309f97b67f1d61b86c949485b2cd69142d7f6a5ae5a05b327e18fd2c10b914a72c5d1c2ab0f38e3a9650d8e8263c99e03ecffc48db171a27fa8c1d62be69edfdb44849548e968ed1fedb01038c500321224e09a25b8afc6482d8bb6bf12fc23608df322ff1117d989221a5659e94b538239e51d5a3fe2db6ebab1304d245be3d2d0980adf9bd5ddccfffa0464ce4618ce4dec40105ec687e7839c0e315dd67f7fd4413d5a704eb62d6bfdcb731549eaf55c71c3c8aa0147509469d636d0094b9ecde5682826fa3958ab35a2f82abcdd62f558516411180a5dc4da914af91556ea47ebe6c717de95c3b228537d2e803943c972d5b6863f59023a5409a259fbd5919cefb652aac75f3cf03e968a2eef1c1008723cdbfbf4f018dbbfe20ee778a57ddd189d661a78c7953ace9d146c92d29218fbfc9d248cccb3373a24c7ec720bc5695acbbe4568db43b7936c86cc5aaf1ef6c3fe4d31925002ec892e2d2fd40b2b5af0accf9305135cf0f39027ca69390fbcd93e75e0267860edfe180f0715a0b1704100bb67ab305363902bd1e05e3256d2c7d213c791c49613ad643f4bb982e5e81b1f29be845464dd2658a894bd496c7","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
