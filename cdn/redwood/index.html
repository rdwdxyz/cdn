<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"34e28575cc1ed71cfa9a3c5b92e5862efdd037e21a939c73294d22c0ed5a09bfe0899de012e7f4008de163d5f7a2a55fc3f2cb6002f95fb9879d4b1360295347b0d82361846c4fc652851cfad0f34b09128cb05cee7551c5e52b7cd703e728d35f4cbafc74f4d200a801ab228f39a8c91ad50630737f2e0bc66bd75e1dcd8e67fa9963c89894e962378f74cf1226acf9a695e3584c876ae63710ea8687b117e34b67e2c40547dc798aaea4f7fab5d18ebb42748b7e42ade9b64418e11d19786e06d25c5832b079b62f075e9760805c5e9016d31232282a417ff11738cc0d090e3b7ba78b4eafbaf96c0ac16f7156955776a6cc4ef98ead63f848fc3ab56ec9b19cf3a422f222da29788e81bf604e9e8e96dd82ea8156224b2ed61e56ccb81c06f92f3998eac4a6e345a46322d1b1144b6156b7ea42faeb126571e55ce54a87ab250b1a4a1e14b832c6b7d40c87e4d7f3c885d4b41fa3f0a159f3ed14d831bbd3644d6b9722df3e4e5056cebeb706b69694850cda4093d299547ef307c2afc1dd4d2a50333928a7290e6ef65761f0007b0fc363c7d00a423e37c0679a93163898aa9a08f05291e3ded2f71efbb803811d4042e9aed9da2e30d008d454d5bd03031646d7f3320d994b2ec446e3aa63ad0644ebb383fae7d7158cef61667f01a1604332af0dce6d4c9e082f68284668186f32109b2de3dace6f69c4e07df99f5abf7cc19930c0e4a07befafd701c8a22dca5a2cddf9973fe7561e0d7c6236446bfeaa1bdc144c53efe924fd8de10aa555b8dc880891b03f41bfe00d156ef6ba268c5a870ecafeb9d8390bd5c545fc0ad679d5e4208cbea957b0b8db6586c7188f4710bbf0868cac8f0b80b829c4bb4a233a2ee9be1a2c9ddc698b1e390aed02fab00ab4cd74c3ce1e86d7b2fd1f89043ac8e53a343ecee36b5e5bdf5fdd4cbf98701ab91eb8ecfba18bbb76abc2b1dc249add3391f3724f65da30c1820b432f20dd23e0eb926a95abed8cca3503686a90c7ba08828c76fe1b10bd342d0740120a0ab5fa5220befff12d747b188786a6d49ff048c93d19722aa5ae267549a449fdada60022223a277f45ecb3eb81af4fe2439981f8f06b45472b62ba7699dc50c5513bfcb8170e27414800d29bfcae1a296718f340e384fed447fa72424d22692640932ee5726136a8dfcb944465356f8b02799235170f37564ce82694e19a293e50c34290c9e1255c4e8f7d4c0ec1c26e0d908108847ba495c6b10980fd3df58a3573c7e3ec9e24ac9ef511803c43b3aa2d153af181c0ffb8ff8d50a2c0a47a2cb1e29b461b035c9a0e4da7e44c861272e1788454976f0f24e62a055e749f178cfadcce8c78307657d2de6d8f10adcafa04f1ab0bc88f193b2b98f45a06855156691a4612b1faaa83f8341a5eca2d4da5b10496457a6d3d6da3ed9c53cc2a5e83cb5eb2e4ffdb5e2bf09f5c7500722602a0b849ec6a6838a7f1ddbffa263a56e5ee437e4afa2a304757a6460a0e22df16345cac4717f3aaee249625199fce9ad41444c77240d02e08a4c4dc1736d62eef10b77d66fb649c426445add572d598203469825479c7372db3a57343de6c97cdbef765634ad5739862f8583704abeddc60e2e5be1aabd2ab10f743dd8a8469e806a9dd6e3c31953f13c96dc824301af5b2d7764d04c4799a2d87081012e5da52a723664e883204f17fbf5832aa0a29d7f40cd800870eefd3ebca99a9df9e23c126c0d26b315194e93ee4f561a4bf1fe9ccdb99e66f91d8b3cc2499df3816260823b3b6d461682009733ee174eea02cb5d1615747c3f888f7ebf4e9f590a93589a759bd6aa0b0ff590894b22348ad7a014a1e9a7a31ab1dda8a8f756fcb6bc0826db51958dfe1015c4849a5180446abf70f2ee44b58fc69331c9cc53f9006f923a67cb387fa4c4de4588277b59224e6dbc7cead0dab73e3cd78cfaf28dbd6a56f17d8cb0d4af6714953f7daae31c9eb5db11dfa26a3d392916f48f9f84a709b1fe663449efe5b0dd948392ba702f0249d0a295b6e6d19f9ee9aac3470c8e99ab2832560c3e9be6c8e232c53275d348aa40399a0c347425f487f4e74b2944dacf82164097eb873d8d79805822149391b420dd6bfbf38db8f20f37a1b384081926eccc56295453c4262ad21233b9210cbcc88cd816c54b856d1709cc67735fbdfb9fc2a54e6f20fa1f853e84b7c726bb6cc757571af2099d122368a443f5d5c0e092b4a2e5006ccc0c5305539a9d2b2681ffc904d1781cc7f512bbb0bbbbe21fe8d4081a1f2905812054faa3f2249cfe683aac128a0546b7d2b7813a533f86c081d253dd989ffadbdf5414aa1b9dd812ec60b1056f6fb869e298901135d11a3aeafc4fd58c59515a85a1605e4dd2987765bd0afd941b3a1972ea57369b9309531c05d8958c6fb41a52c9e6cdb696b9cc75474251a159c1a884c5706d8bf841c9e7fce8a5e3746757a9065a8a4bb3a506dd82cb87d8bfde4cee3d1e573924ececcce528d579c38f162fb685b56185eccd10b79561277391dbbbbbbb60c9e48c81bc7e10c2c04d419654dc88cc8b3890277391870f39f1ac22d7a3cc1ba00f3993d4822dc00e5490a63bd1d5baf01554d5631d53bcf65a77ef20684ce734b27e7346799a1500b149ec95a6c2f0a89783073857a45fb7570737fa7eefba14139e337e1675173470ecb7ff14544ab7deddaaac9a3acfd7ab6449ef7cb54651f2389f87fc81214c79660fe1811e9be4f1a57e2049d8908a88a3db5e6650b3bd134b71f56725236b5913b3fd5677894647dca75f0f2ea8a79286dead1db287fbb7b9a922af29b67f84a1d48156c3fd6862eb03964c12fe8d29ed2e9bc09bc5e770c1781c9b19683fa176bfa2f0518770567977027bb13b2cf7e3a3c27af00fcf34bd0f1d88f31b87b04587342168253e190056c59f233563a749325592c111e75dc707dd68b75ee7d00c4d67e2332c4698371d230e7ff8dc68842025794e58365615804b36649ab7e56f661259e18ad9836f20a64e354c11ce7f5e906305aac7e018acb2377febe6f45bfdfc7cea4c8dc0d072fc5b7b2bfda26ffbd7528951bc1000e2f64ddb2c8ab0688cb042949d0a9538fad9f5eb56876aa463c275a94c38b87557aae815f824752baf7fc488bce26804677b9bab4019e62878a0857a92b5da5ad9b430cd9c29872fb0a3f75aa1bb19ff99dfbe0555b07f64105dce961796d6602c4f83e7880c20a8939dae5a31f1bb905d9cff04e639aa3bd6733001e1f189f50dc3d431d3300c4b6cc97bd0224d2f97050892d4b2a087694d8278eca61f3f18554745cb006be6d80c1691abb6ecdf98a78b57e93057058a1627d7fbfad585c6978d2cab67b82afc725d237f8041b3cc9299d0b90cc70ba860df4209d3bf4d32dc5c0a74e2c8ba07ac78bed2cf9d54351ef7ac15799008034bc948ac2ffd0eee482aecf33406671dd6c30b423731599990f293bdb1b1f6b4c7b4bc52cdcf2b0c46eb0875179b7611a798fbfab225bf988129f4be5c0ba8e8d1cb851fb072aa787003639fd409b469c31039937570e037a3e6bb6486619e354d2a1974703f3a37add04c110e5961e420f041a2f7d9b5d9430b9f32b0a1950eb751cec7ff4eee1b11a705b618e8cf04426e6a4c917a220a2e7c44cc3d4eda353ef73d6170735667e13c43a34c2738a573a79d40829996d6ad368b4c770b2096efb38cc5ca06fe079474b0dd77ebdc824c7cdd52013c23ce8b7f839c06acf32bab8be20344ede9ae6777686cb01dfb58052cc5a54df14e53a5569f5ec51df611ec7bfd4639f1a524e1530e78a05eece3d650c2d7079bb39b40458a051f47cfe8c001252708ec45f65d413c0c73b11c8d589b4896c166ed0f1a1b5267165eb55a756f665987183d154832bf28726af0e50649f59fdd24c00c659008029e4dcf7823d78c7cd8ec5fd4ba8b22765b3c8843a2bbc9b12aa7a197df7818ce843585867b7a05582785716e61de63724e56295964bbb5c50bf0dc03d1c104bcd31de9ace4df53b93fd07df3258469d8ad8be83b33cc0307f8a03336ca944012b6dd6e4a700c2f102917befdba7c1b473ed6834d5e4427f7846636ebfe4cbafc7153cd0816f9fc23014447b9e70d25ef369dc594f0342dad4883a983c96d5be384956ea84f7cbf505dda3dd03dbeef9dd196b67fd9c1d97a066d20b90de6ff53ad3313ef53209148dba1c39c09f78e912988de681e85c830e94e4ba42969c01130bf1b545104973c01563efc36cc8f2a41f95db087453fb0663444079d09c61111d4d4372c8c3244224227a67945b8f5de177b8e5fe7a74a44feaa9279a556ee1120d37b27df1674e4e9a0cd6dc495b5d9c6a3856dbd8a05a2e58007512807335cc4da2eea3b6a5e8cad61fe091642b77a7f89d4200580604a162b00fefdd77216a8560011481964906f43918106512806aed29ec619aa8184d0485d26eddd2f108b1147803e6bcad08b2d804b521f31b2aa1be83fc3fd81135ccb9b91bc2cfb1e706c427ba02018531d1657bee61de3aacf7a7d07f9e1af5148f8436069ce2458bcaaaf049f35579486ff493a2c6777afcc47f18a91f4d8ef39740d651750c8994514301d160bcdeb70792c51f3bba736fbb06b4fccba0f59a9b6d410c0d9477698f85412e6b52e8f5a6ed073e76e946a3576a1679b871d2c0f944d9813421d072617b57081ffe71268fc85c2b930065a1a6d05b262923650b1d2988876d5ce1674ed49aef3742a464f79442525712e800a1f070ab0cc5d33f9499d0a020f28cc0646b2f10d80472d208020a7e5d48f9671197b2f4264c034f15378d5a42cd53254d97d3dab48b0cf100e6c0541fce29330e0e3bf2c96b29d93caa4e8ed6eaf36638d94cd4f74f429735b9edce8bf45be6a57be183b775c16f240b8375428cfe5ce8d59a23ee8465441b8616d0b5dc2da57d88eb50fb9b7abed2e5da26bc544e704ef41ca6a56b864287831a72ab740cb3fed12d66474abbd681afbe1e725a2e13b247f77cd42de948ceef5731fa184ed7ce8265dab2cc78bef4929712e3a77e019f76328619f687713b540c132194b53edc8ef2ed4279849bbb960c5b50b9aa952f414dfccf25062df87ba4b94c94d419c82bcc92e6ae35b18d0fd280c1127849681a36d3337ba70f3c39e14f2b3ea319c0a0192d6fcb060f4171ba4004405613e410c529e1b72f9020b9db22b9f0f37472ddbef604b5cad60629e75fba1fc873ca7fc7396819d6496093d8c8536baa1dff55f6448b0b350dbcceb46198a537fd5772126897c2e4c44c038bc1e8be06a0cd7acd8ff7cf5d46ea49a058a67932bbcbe450d17d72bb6b92f20232620d2024b788e00fb32c502bc672881a8927a3152377de94a021779aa4c1f993dfa8d9a195d98a99c019194a7ce4a5bc294320ef3472766faf9353c8757c0ec268c04cf52ee52a75595e79fcb0c97c902d9ef3ed90cdf58eb3aa4a4e4c949aa3f16853e2e790d7b838c647d124c85a35bd2af9bb8497581ab00d374949bd55e34158ca94965aece2c3fd771d9a64e30c59fe049f6f94f9442292a7b1e5c2187a4e0510c0ef5029bc9e656d6d2d062e429efb5386201e759cbc7bd1b45268163f20c2d80538d15428c70b9434bb941d62c6b76aa918460c743809b0c9d40eac9bf9b66f04908443d8c13f8498e97b879b851e594eb436a5845b5fcf2c8ce5e74aa1ad330f31615e4a35fe989e28f0d8b53ff659fc94292937ad50bcd8f4655d7402a4dab5b09309637f9975c8bb221db90caaa3010301f0f88dd4dbb4e52d24b57a6062d2c737f534a1e5cb7bb8e376202e01095b808438a421b0e0d1be1aed73b7c19e96d933deeaacfdfa095bedb4c295b383b435e17de22ee4bf8c21714683db7290f9f408fde6037f48f65474ea332eb881845e14c474f7516f03cad5661fdf8243f945929d3c75223d3fab92c9b44dc48c33d64deb15b76b777a7c0bcb9c5d69dcf5eb8342458f01c3a04405221cc12d03a551257e9b8a972ff0e46ad16d31538efed6a9383c3a9783c0a0b29a847b8c4590bc1845bd6a38aafe3f6d8ae29c0917dad5c04dfbfca9ab356a0ec55e668ed49beebe1b74ddaebde69c4c7d61c4499c24c731552f7f0a39211e9766db9502b535fd3b0dfac14c268b4024474d52c1fd6b006ade36ad1177aaaac6b2ecec93b89a0f8b9588592cd0e2f5594ebf81508c126edde8338e2c92cfbc22bf45b9c359a7ad749ab73d965d8229d994f8e28028187e237d173e8b28ae9b8ad8c886f93a3000da67ad5c49668867f9f8dfda45e39147df35bb2a8aac8560faaeca5b2827d254e7a07c4af68413261e8e0677c701d94cd696fb062b3dc9e1f674b4c99bfc5b61fb0bd86ba57640437e7c68d721bccbd3f3fcf09efd78b0abfb1929cebe9e79cc9cda1b61fc8522c633492bb7566e09575deb69fb41907be1bcd697da6a919caba91d6b26d72d952ecf797101e44184661448a81b143ad48394285997b7a0d4f1f5fbc1490127a0ff7734868f1b5004d235a6b3aced9fd7463d51dbd272b1909c2f3220514602010318dacb9741b4a989aafe80bc4f2c7dc74ae60b46a4d1b0d3c809dd57f0c385f2a9d600639a5ab3b62c12e880e8c0031546569e8579313d62aa1966d1d23f7b4444c2119d0cb666d3e331d320949efd186393f7f5692819bc27497b904e084a81d8cceb83d12c81970063e1ba88817523a760cdd66153f9a42925aa4594c81dd32b992fc902229256cdc95befa2e38e60192ddc6397b8b8f7dffc93fab60051aa962e6e9b8b55a14ced80dcb2d69baf35430eae81477223160824721418a82b530a611db499952740e3844c8a6dcd986649ea4b6d9ebbcb6492a104d2750addd08edc3743adcb826c5152b3c598c33fd343b1448826340faa8dc8ff136cf0759d33666f61f0d30ceb4b196ece4908412eec96572e0956f134cfb53667da0bda53c46d50a6a036af7bf53debae54c3322019441673262e481ef59251105b445f9e898bd4b9794bf04fafc35b2b6bb6693b26fbb12459a43fd7757b9bb93e30166ce75e7ddeb86b32afe00e0bd5ffb56859070011c6e8f427b468b0bb62c6c8bef12fea96c1d4b270ece722467d07724c629d33cb2a4fa6ffea68330051a7c39b3ca924feb17a055a3face7271a90b2b5b95c68d1b81776e511680d48f6f525c1725dc56349d33e166f237bf841919888a861ffd1c62a72c5ba384f9bebbaf16cb1815f3e044e64e4404c48ae3510bcecb6dae960f0d770d65c6c31c7dfa956e4fcc2421854f6b1fe194bc38bba3836774a0e09373453bb39264d0892d4ad4159313a0660f4826326645228f444bf8a5d03f49cb702e6c3981ddce13e6bff0438ae42a8c1459d74852380a07fc6c36169cc6f48b3b8bf8891e0fcc70d01df64190cb9ae190bef98178f0963aee1c5a500cf3e18cfbb4412ff739e2699d3c068d78b7175f65e460f87a180f4548893f96d9760d9d8de8440520605edd1d47a1ce2421e517fb542a67193245698d2209bce10aca82e6a01792a2c3c4f915ebb712d2694158ca3d16ab53c168db08a8fa87241cec3bdfa3d14e02758501bb560122082f7cb0f95a4c3a5cb8bf5abb0639c5b59bddc7bec328aa02361651895fff5f909f4cf0ee5a2042bb6c1eaa0d06ed8246bd6ccc94872c909c821811440028e1887f67092a77aba01cd9706d06668882a21746e805da99902ee3abd58c6916343e0884789933aacc542e70078ea3e702dbbaf7971476ac3123da075508277c970f89e96d644ef96b27956c41452fde1227e7c01f2133a19760142698ba7f7a86c597db4912f4c59b6ddc515d11e4d2268b0c73eb287aa1f3b70fed33ea66f5d5ab081d3f024be48d96c0b2b9a9d8c290770ec469d57d9d18b372a46ed9884160c675640da2193bf4503c8cf1a9a96365c85d5016f9324a88287d6221deaf92d66195a84a7439a99e240a893cf57de65963e554125fd3879a4ca24d84fa144d5896a608aa99d05e2f68eb34afa214fe536da87f95fd2032c72ae406c255440a943ed463f7bf1076a4b9ecb29cb1b12361c190e33e4e30474ac6d327ad9ce8b008562fd5c19315ef9e96ff367c20ecd535960084f4a5e1fd7531f5804feba181e9939b3c7148716c650e9324c082289263fd45180370e9b7bc394ca69fded51e89d3261933a422104853a741910ebba197471827618e68047516aaa63f417aea9f42f9bb98ee239333b3709147a5a41cb4438d0357e5658216baf775ac1073d866496ef7506d4e08239e935efb9e9c9b12cecd16487d1481b3ac57fcf3f3309118c19398cb9ca357bf7c206c7bcdcda1ad372410651bfe9f0ce9ef2991048ca367784dfbd70dcc597317739997e2372094ba57b8312e01822d852ebb235829bbfb36e6c61bb1a10ae246971040e7e47cda81461060a17a8454d67d8470364d85edf4340d00ba2e77a81450a31690904a30c0f626ac0bec4db77f2a39bc4e5903250e0d0331c3ec42b125858b5dd19663d974ee8a69af8a9d423e0d7f20a662f2a4c05bbf5e4bd62c053abcbc8a21dbf0526c159f5af2b80f79b5d7cd68095bc4993f58159b82f8585c875d0d40cece6a8f58b01fea8cffc6c5878dfdfc2fdf5a3ed1d79d029ac5fb454b7e3e7f3a3a3777963cd78b70d4bad7f6daae2fd1dc1e543bcc3fad311745c25169163a52897e03b5324208a93d66a2ca41323073deaff746bb2014ac1031df4d3967fc2ea01b12e052d83b177d794a052d24de5158421f7037ced99f6b35778efd8f0ae4582d508886f3cf36df2f7500ac89d0d2feb4ebcb94cbb402dcb77e18dae8eea6b72ab8cc9bd2cdab153bdd391e44e094b5296ba51d4c82fb5b782582287ceb9407f00cb73681e7a2d8029517d71b7b9984611648701eba4f7fdd08a8cf8c6685686d9c383a0916d984c4d618c4309619a18b215f5034264e7af0bef8704bf3c17f357769bf144871a4393ccc42c08d6f29efec3ee71e29b8f8e23f38813e03d850190dc90a1ab15393813a686d691dba9dd2d7a9ddb13d7aaba1c7e66570826e690851ed5cb8c2ad65974568ac25580ac404827c051f8b7a9860ff14874c4223e3f87409d0c222d356a3c0656801ef511b5e08f97e68d80d8d2f6ff1ca1ce2f401d73a1a4be72c455210da0cd9dba9a76331fbae62d3ef36d3ce4674d1341de1b9a21efe7cb167990a3a524ba0313765fecffb0413b6b07604999af156621404e961f9b775afc1ca5412f17ce1c8c23b48a3c34722115ab0d69aab8dda19f96055741156e4c57b468df557109d9e8d05c32bbbbb239382cf40bd15d52225fdee64239135adda5e4b33842696658b52be25bad088185b9e4bb97a82822e0886264bdf5b8ba9c09e488eda617b2e02152a69183377c65f26813e6951724894562dafbd57a47590225d2703f16c92ca74abaac76057b671b336c5dce51c6720d10d2403f1d4538cd8a177a500d8cebf3be16374a1fccdd87ba184a83bd34a7e30c3e46a71ff47135854d87fd0e9adf759790a7bb92446a0f36ce434ef1c2f072b58acc1a057bd03b288ad2654028e5a28e887f83dc363937209c73ecc8aeb43614ce15d2f6ca227c00f8f16681862e97eba57bd98dd05873c22ed972a32c5812088beeaa009229939d01798d6d7a63465ebd2aada2e1fae59803e207f0bda008888098a5f5088fdb5a58d9136f5e8f6f945e954b21a3925fa0187bed18afdbb2604d85b906c611c466fb6a2f6062f66e18407177724c6dbe546dea97a80005bbced76141fe5589f2b9ea344a3a51ee6cfc251985c312c4c13b3de7aa446d3e3f5a343420a526151b1c3ad69d9ca6b199200985aff19ee9aa1aa85794d46281102e71caee9ff01b78a77cbd826db113aa3ff3e9ab62d76bbd086f2ac08cc9ad0e5232e1183e06f9946f525e8790f197cb8ca922221df3e84282760fc762336b5cdb4b505d67379d636d77e296ae931f1866ed792fc3b7dc773107d9f1bfa52f90b9cbd21498be83b27a11170a742e9060ae6e10d48b76b620f86d534a0d16046da25c58cc8dad6dadbe794df2284805bb8f88fd2e322ded5f12df611802953342283b4fe7a6f99a74411636b28c682b507ae4a44a354abb6c88f6a85bef351b7339f38544731f9363fa93c544425e43c57915ccbccd2a808c792572c593c72b561346939fbb636963892c405f3176b0abec7d0d99d5597d09b7b5f347b3492be7651fde3e95a5d83748f630286d5c1d8f21d925cdf5a925703b6397187b6f478467794c838f6cae55d661154b21cbc1d535c13eab04798ba9d5a1a3e956cd6932797dfef00482e27d3c987d4e2b224ab6e683163966c322a7b95ebe3422ffb20837ba107042395875604343c1b4309ccfb807ec587fccab3d97b315fc35c6131b594c7859f4574eab599fd8c08fe19d024994f9422d2f83d7d9689a3e8387cf0369d4f5194f10401a1c26e22078fd8d352ada05e078e56540e01f153f0bec8d8da6e061a745e8af034e2757459776ce1ad55f5d82eb88885d87f6a2408fad047797dbd2d4ee256e24b24c2f757ba61e7667b22b4e8e7c9ec116aa7cb2aee4f7723e7029bb6742d28bac703386937b0c0300afb9edae7261683e4dd11da390d578db947468d779822cb95428478813f2adbc058ae126bdfc85db0861f51be1b6303c0a214f462651f3780f47d3f0cf65f7fc60f48c460bd6c06be415ebd5cf8a47cb8ce2e20c94243e2629d8b8eb6162aa269aface62794bde32363b6e324e41a1bb00904f03f6197a778dda1b27be11e15145f494a7458ce552f4b9cf637c9a54efbbdb813566f545b97e6606758d3bd8be098e57cffb3ac3f2cb119b834ee8ce06c0622e34d71be9248c636578263ecd896f5adfdf879068b3be22d3cfd25a8fa86aade6e728073d1c020ccaf58d831ec9bc5b5835f06a954bf98c43fc517c15b238ae9ed4d6571fb432ef843c37be39f540d2460709acd2e03118f6709c1b52e9759c23504367569f570e8002c5a86be8154398a94c469b393a4b5d607bfc6f0d7b31904b7400d79f0521e14428776ad9f04ae48c24573e18abea44b261ee93ba551ef60ff343f32ec2a39a452a53a0bc2e68760c1e2fe9616d732704540c71a4cbb6d36bc14ac097113eeac585373b573089beb4a0b401c36fe8c95d3d2152dd5aa8a8fd3e7ace1e412aa5859469faa7577c2265ce8db0fb27a785e8f87fdf3c3dcbd534403f2d493882720ad784954acbce87bd16df4dddf52ad233318ea863fc50a24bc9558957c3621b6338761d26ad9935e7164d124119a182fa1f1088b8a70b1ce2fe32d16576c6960d63210de734c2c39d1b51e9fdb331a45e7204b3ab525b1d5f17e9f881aa475d9f6d087242e56ed81e786197d7c185ecaa862b149517c2c743c235db0de9c6b5aec7c3a74d4706d3f2b0613cd4a0efecd3dc6a3d653254844bf02488f5d0ae27e7a23ac5016033b28c69c3c206c1e61fa80dce41cc20cd4aa9bd98aaa873be48cb039543ec61fe8490ffd5bd67f8d0fe907d0fd7b71e0b5fe562e188633daaf7602da9906d2ebce797ef736b9a196948266d938338c1d3ab399da7005dc470130e6200f9c70478d8f24ec0912cc83a5842e4d38d8b04b789e483125e140cd58fac84c26e2bfed2ea8df1dc0c74f78721ac080a216e1a4a8825c5edd47009f7e754ad025a2582f3e5da74ddf44df5ed7c8fc28492d39d23ea99902b1ddf6dde643ba5752b6dcb4a95bfcd3656d7a47c819d4e47339156a52a7cce02a99eab18ba0b870669c3e23f803281c3d99e7f45132d696d70a534105665b7f2e0c1bbbeee72ce63ee5721163901f7a5db03748dcd57bd94bb8c177fce658dd0b7d35658a6d9c4d6f05cd6baeb214a26bb7f52a484c5b0dc55080db14a90d2f8079b89d98f8ab423594da22cbc6307a387c9a7509034a716d9212463936ff091783ad1b2559fa2f1a10d182e865f7db7c653dfdffae3216e4f5e215ac7a1759c7b5a4f43e69f4192673530fd852424845d652923ef35a99a462b02615ed87cf54b1cca317a9e409b753725904bb26e6953f2a8aa01c647bbb069bc90a2f5730f7d2015087c68df6fdb742ddce4fd7acf3c54e397d21e247a5bbf17a42d5b30444a5d5ebbbe8ce00e64f23d017fd461b1cc10eb2379115519b37a424a42740ac58149f9609c7e75e0ca03eb41696fa9717df076cfc4fffdf04f7f6b1a72ca6add7208e851f09c2c68861b220ec208c486fb06683d16d6a183ad53321f8864b4e645dd32715fd3dc5c0ec39e34731ebd4de4b0a4ab9faabf7cfcc6c9eeeb712133b27b1fe011208aeeb66077ed874fcbcea0eb9d4860a6d460f8766205484de8b2aa1d6ee55f5dabf039221975f89018b8b0c4ac395e4b4284d58d8c625028dd3fe9a36b4a45ba9343253976073c99fc89255e518e8c3c423268d01c33a63fb9ba5eeff30538327ec64d3426adc2d75f5cfee7372bc983510ece0a67a060920700b3ae228164d87054ebd17f7fbf42a49b8997565eeba53672f5b2da50de09f4491405b54e56f91699188524bf4e2d1ec72fc128e0fb53ebfb1bdf5f9e72c1a4b96e4bdeb3a3a25ad38ab683293b9087e03eae4eb89e748e73d6c4c888690f281b8d423931100a349db383e5ad6db0420e656a7100136520acccc6b6617ebbbf0bb2e19a7e19314d50c903e518e9fd6f35d3f7d0480525190ac0d8d20946b188eb8e44991f0e118c39b3fe028ba6eedcfd76b3b76924213493676f27b3a575b0d24956fea1156a002541e3ddcf72602365644ec748e771e8276e97dd6804f6da6dea80940a733f9f6bb08bba3373a61c270435e5ea61e034da2a77fff68855cd81430d9f31f8c19745b9cf93f3edf091858b6a2b3a5766d45617fe58ab4d347d99bbe85f71fe67a7ee2fa9d265fc04af722774c1e8bb84c0c3747e024896daa9022cecf70474b7088aac1976ff7a7338c5c6a995e6d6cafa4aad31370010eb1d2cb204f75a926d1386e6e5fe0f04bb584354cabe0451436e1e0a85771a3927e23c56a3fc873e4b947323c2fccf4ae6c60413c82a8efee5c130d07351d38aabe60dafe001b4c8bfce717769aa4371c407c84f35768eb93072ace2c06241377b4b463b031eaa807eea1dc7c336df0f3dd531262c25305b0acce65a776e5837f3128e8d0b59b4477bec8b833c223dc9f8128f1d7f86b76676032f1e4ae0902a4f3ae4d8c931b377775f16bcce4027d0ea9f95a0ab7cf660a0eda67c428905ba47b038dc1faea74d2e066a920e4671a14e1831992376cf1c3c954c2bd81751565e28ee81b86be6346fb6d23f574fdddae1382d9704aad91efcfd26dec0c7b1ece8685684effad96e48c066de8c17d43f3c0f415bd000cf1d1d50acc276f49b5f20b9737fdad19a2460ea06d12fb7203f16183d65072471bc36effc177bcc9f503854800129ae19767531a52cf5adf898ac0d6511f588de11e893be9f2c6156cdd9b35a88aa841fa0fe7fda1e2b32dc1d6c42ae3bb2da4fac88993910b953abc183f87c461de9501412c86001de59855da47cca66378deabc1fbed05e7236b164f5da3840dc4d920cf5ab41aeb49ff5633d1d3a244785e36da793cd001eb522c55f32744be4326b17ce9eb51c69d18b874a562a185e3c68f0367a83ed0f687fd193a6e7372b999474dbff559cc4fccf086760ee2c4c48346d5789bfae58db1f22442c456313a7879763130af330941591a44b56b018236fe725d0bb45574b448ff1cc63c1575d4ad79e8d69947a7a0f36efa8d56ac732896899f971592c0787f9dcc88fa5d45c2f82206d12eacdaf29ebfad3c764a47c2d88ee95d5b022eaf9bd09f0d6b16a5a1968d7b9c7fd66bc7fdb389a2bdc42ee8807fed451f5b323dac23ad7c04232216ed259ebc1230ad053d1cf71097374180e01a39331f3b03c340e9ae2b9b7eb09c81895155a44f6f8eec2b1f2f5fefa36820447ceff465e4f5dccec3f55a599ab0d72a6f363ec58f1b7c9f0cc490c545e6c2156cae4df8e7e75deeb63bec8c1a41f4df51f7ec7c03e8d04ac124bd80a3d7a7b3e2b888bb1853abb0faea423e1cd4e801968e7591d5ec128734f45d6856dcc464a6ccaec72ab2a2e94b78d060711a90e4a880d1775207ed4bc922a2436a059e715ddbe8baa4b477cffe83d6bb8e1fb5c055a93d9880ba0112133fdc017875b0bc996648f7f7b0fcda1b98a3a6f9f76595d2a62e1e4a3fa14b8b6169d55eca49f91a7dd6fa5ff571a8926ef43c1d2967da38eb0dcf488bb222de6bb89d19b6cf5e2da30b5ac1a6820eea00cea26a16077307ec23a99ec3cffc9c66ace52a7cbacec9f42051b5e990040e70a4bf8fc906a58044eafa6fdd9fa8624b95a2dae3d834c4dd9bd060d0db514a37d62127d15bc77682019d3119b3f171f4d554ef79a0c0f49d2a25670649f4587dd31ba99d83589152e18c0502b9a789d1090d49763a64a0e81809b762437d3335a716b4051497f2d1e4d918eedeea7e3648f4f75dfb4af70cea0577be61035488db8e5a8638a2038c8e0b348dd4ecf32405d54ccdfd1e1c0d20fed6ac6c29dbd59a85ecba4ea7b233af4fe9c7d6426e94198cc9262184c5fdce15a1021fcbf3982bdeda88f43136bebb429ed0699e45d251182ff77e2dd26beefd799f6a8f06391eb22953408b86040055e00f8d3fb129b0547786608eb6abbe1e92981a8175f7e5380fecd61ea21126976cdc6f9be68ddf3832d67480c2ba950e43f3da06faba2099d9d292686877b02427c70ec56a66b70f7d85bc0735a4f5a6f665438943042daf7ee3d141c9e28285579145ac6fe9816e4f67e3a95ff22a627b0ee5798a7498a81e641f98c67dd19c51bfc2f15c3fa674cbe39fa4fcecfae12595f8a63eff1b39b27b7c75f0a41e9a28fdeca2abeff54c8c135a41712eb875850de69f0ea7becedf4c4f62daa1c7ea1cc0a25c0c2bf686a1fd4c750ac357d20005f44118b25d96b261b8264b80d29d3325dad210c6676a8a467e57ec097ec5ebacf669d82373efa5f75762ff5ef7f021e28ef9be39a5cfd50545aba48124801a5442bbf81693a99065a48a07b6b43ceb8327b45cab6fa869145ea8752a9313cd0855cfc598cb1566a7ff69c4eab982af57f18f79830d2ad4a8e1c84fa119cf169cc7e74aca8dfa273c524c9e8414165ebb239b7faee612174bf8dc6a88cb7fe5307030be3faf72072a554537b41f4424ee31fb92a3cc0bdca666029167e3ebfbabe1db0c128716888c18cd28dc87ec5298e9d899fa9940af1389e2f53f1ca5313c3bc7e96f3e9fad5d4b3efa72078f926c816d0d10825baa6ca6568e20d31d41d3d2df45cd92a0fdd2d03bc501930b26e048654b6410ff5bd0650575b77728e4835fb146423c1b03441e711006b672b919306912db07f163f8b71a360ab91098fd74d63413b1de9eb689ed62453d6a3ca990af1a4a2013b3c6bf1921410bde8cbd3b64bdb1eaa5097d3c91a359b983903e74c0749d06d747cbd6f2d75df0b74f6c9ec1dc4eee37b4e7c40c2c3a3358f56b37080084e0ea4527433e7fc66a43ef761717dcf173ce9caa107ce732887f957b75d3c16ddc0bcbb55e6f73be09ff9d7b01b6698a3e9a1351dca3db43483823540265d860389b0d36eef6675fcf7681a321a41214dc69a9488eb0fc69e8ac865a07063bc3ce64dfc0405045ee89c4cecf7ee7b82809b0f61e183789965c48db3924c2bd789dbc479f7802199609a3d4475020c94eedf473d457b8b4ff3c60b82cff3638f828af7741526b564b925a31a175c2c6e418d3916a6cb0f725e252d3ef8862b784f7151301450eced761d1059f6cc6010e0eb61bd4701185577435f713f77031c47c3466eb16c5906b28aad1ecf7f8c48b1d1df08e67244b160f6b9c36c4d8843cbfdeb3b5238abd824ee25446864f6662e65ffd028a7d4d96f5343bc72e0685b165772ba67d8e6ecca7b47352998e1421cbcba386d58fcd7dd9ca3b190b53fb0f6eea9e703bb37739830a3b37764cd72b22e80c4093bf1373b0e58e268dd9249570bb7fed086ab3843b0f29f784bfc1bf95c48128bbf24803bab5d4dea7e7d3da56f17e8268fe24110a5aa7a46a2f40aa37a4bfe2d880a482a72e581edf25a2b670aecbaeb396ba3a3c11d112ecfcf22d0769d068bce6388dcb0386480e4b303bdcc53eb00213055cec38826e0dd77aa80950f8f21a615d9818d79c5b75b9d42cc050a4ee21a49c6e484d84396a8f494f0984d0c97640681a9d7cceab9e352e9ce40236ad31a2c47a7f56ec88b07d89594f34dd9755144f1955740d211c3c31ac5ce7c88dcf1633d9c6bc6ceb42ea328a94d68a4c8846ede0066bc1f12d8070529da0f509c8c56921e8ce3efb1fcc12ed4a81bcd560783fadcc8e2a2105a5fef5da48699860b66823241ccd52dc3b2bad6f919cfe8f405b8c5725c4d78f11e43d1a7a0b242a3781425d68d7072bc7c84b3e4cdc574ea68328fd4820bb92e93123f00d5ef7962d4300a9cef5edfa5d3e23ce5e44e2d9c49ce110d344c986828ac39295d28c6201e593c3882edf74084412c844b633aa1d73783128b9541ec820689c51f2234589016a20a43cc8bb6a634e6f7058e5d0304e0e5874bfdbd77b12dd56a736c0837e0a4fc6305e7560f8aaee1798359ce2f2fbd54a374d1bd10bca86cbe82a8ed7ab2e4c627db7092d14666df3da703839e9ed65a6e80f0f9eaf889313f6b869bd62c6e1dfa3882bcae9639107e131d3375adfee81776edd68a02df8952e90093a1e9be41540633451292c7fe9ec2c688055355ffd1abcbfd1c306b24f063eca5467aa57fab5259c660e18c3b2695d203d25a36044955527ea3624447594f45e9bf2e01494e34c7ee747ce36c8045d9c859a495ab0041efa4eb159392e7c891cd8bc7ad32426e7fc5046917f5d6ffc46b45d6b51f8f1be149b5258b525233583d6e97250e2ff89a49371ac740428382fae35d55b201243434b6d4c64aff53b0993f4ea2f5b429dd109cedb6bf57f7890782ce0d9b80d485ff45e5bd170aa4a376f3162b33c838bd9dabf41ce4a5fa5401ed02404b7e302f176bde623f3f6700b9c52a23b6a08edd0ed6a2f2b4b9178daac8092df7ff89329b5f1d2b04dcc4fe3f9239b42cb6e0e4567675611d179259f0c6bb9fbf44042a2ee4e7f90d1328f5ce1872a3b4569f019a32d1194baebfdaa30d63ef5425dd41fb5151d45469221279a62f4b402438d3f909cc7c45dfd6575d618c1006b2df34ac8e23c0294368e6d759fcb03e5b73184adf3296581f8d2098cfe2d4d966315c73eb9a2324ac48e7142a2f298bd271e0248e4b6944303a22345949149dee2c110810021d0444b5fbb4b8287a84f82cea2d4c6cd552b619be5ce27a340bb5569e95a6d4c7d022189e48c2236d839f64d04879060a398769e7ad9d470349d7e9f8ad4d5883a3a7e8468d2da99d7246c808c1284be7bcf7e17260df0f78e628173ff94babb44f29eaa2d44711bc259ee52f965fc3eac0c3529e39611f572659935a7a7422b7a4940a1723bb62baf39643ce67c9d86662a00b8011b1a95484a3232d15d61c1ca54d24b56b994ac2bcf54bb4a937a615e8e5974583edf16125329532f8c77216005f75d71b25c833cfc48cebd711311ebd3e0e38f21a8be02236a39bc08e1141468fb9fa899890cc23d58560a167af3355476303115ad37d1f017084e747a3591be477cc15c745810350d05cf074aca47b04502bc0f780349d6ae00e34f373b2cb13f3983bf81c784ca674fc692c9a0a6c18244107737128fb83fa6aa9ea04acef6a8ae2a4a0f3ff82c5dcf81ec5d8f3adb43b2640f015b75869743afafa8c930997ff96147917fe665e0ae74e1f178c96510a878387ebdd9ea39e7729cddceb19160352c082fddd6c5c3c56f4dc73f9cdb79a8f9b7b419cd66acbbffbcd90d12b20dd898e2a8914dea4c3c285c26393c59bf05396","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
