<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"4287ebde45027215b22fe1ff11ee09bebb9f130798ab036dddd608d1fef33d76081100a4f7602552e24d3b2c57e823a71fed70bb71d9539fa27c64143d1ef43a52ffa9ecf9fb6c44b173e4be28713b095bc5742e500c9e4dd1d93ea9040c08e4332f95c0e142bf298e7f5499d1cf265c8e1bd12a57ccde9a7053fdf4d75a6abf67b8eba65d3e9d72622812c8ca05c8baea3b44197f365fc5885f6e6647f46c5ff3715b514c21c5c3c2541cab39e809859a578234f1858aa7cbfcaeb2b5cb3437f58fd69249ee8a89449fa23c2bc256153ac797bda1954f717a5b349b36ce0b9caffc693dbc8ed608583fc35f29c843151efcd4a016239e8cc4f169bbe36092b525831d21c9a2ac578afa3e66e5048cb2650bc410f245bcfef058738f95b74258afbde1aa293703c4bd0bdd598984465367cbe86cc86cebbb5c389a912904f46d398a07e68e45c620d7e92351439cc30e37f49cf0b85f73df5e95e9a9a115a949e4865e41840d64160f0d388e0889b79f6f9f6c68fcb0a6a3bd454d53079f07fd899b6c4ac61eaf0dfe9de3c6099ea8e401035910747b5e82d32d320b3203f5acac4cd1b2c810ef6992e4c5f5a343d4deec2bbceb4a97dfa3b971031b294dba659e4f0a0ea45f747b154290bb7f7887bd0a05e9254385d1ae0a4ea35c6dc88cfbbe6d571162f08c5609a0092892d242ebb1b55ddfafd2277216fbe80f58094da6d2f6a0d6e70d303b67b32f0e6612ecccc48561410d1bf0d69c0ef4c537a5ecb742b6a6cb87b48ba2b93bc8894d8d8148c98412667917438e478da7d4c0112e9488b17867079ae6a6cac6cbf0f5488b6ef8c554bb5c85f28a166aa35d784036e25fddc95ef06b2f1ebe2e0e3676bcac0aba2f71956e3796cbd72deffd9cc37c0231b9abd4b45c7cd25f7777e6acadd1dbdc6d9f7f4089a4a2fa4b70a90356a61c244a78ae53e85955c0f86e4b9dfd33a43dacf8498399593f34cbc218da882a767bc70520c3ce635506ed20ee3c83741fbab62f3fe034d8da60b27ede18e7d08de59898161f5885eec9ffd33b39d1bdb63d8487f868f730998cc326ef74b9a38f358d1819d73556fd4e56f1b278f47c0d197a901c560c88c1ddcd57268126f130a88233f6b82975e9e740ca0f61a2ef02bbca355d46613be600fc17bb6e6bec499d3e3cdfb6ece29dd1851827a0d7960b7e3ece46c9917af73adcaab96c4536d59f5faebc63c07b39091cb2a9e6906472a10618a977857d3970fd6d834978eb6e82da249a95d4e03144c08d788abe8813a5a4a749c9f9e452194273ae73876df8030c74f914892f8cd6e883bcd2ea59f2d057168650038750feb2ec54be537d756abe6089d4a1b59d40f0cd1057cff497a59987c5c543cc28e5c1c31e55314aed8c153209d9cd77f6444e33e22a33b09dfe295123c3ddd3cb3a06e1f077ee49de89f615c61f8cb275791dc0da5dbc1efc64e78ade3889e44c90e544063d87a093a0db71a6973f613692ebcb866a62c9a1a6bad7d8b1b53619e5e7e5576b2b5b9f43684eb6dc13454e0277fc8c4c907619ced43cf30cbfa4e2b0538a6a7b617bf01cc7538998f84ad41bc2ab70a4c9a73408c33e229cd4571513f7734b035a553237b81ccf30b9ef2a785cb9d4128e0d75a8d932f6e5e50b1fca6947b1eb9a6d21fed8df0bf54cb4875ab1ad5b1536d0a740289227f6387645771de72f868de18e6f0cdfa3fe9b3a6acd80757ee6f79fe097a321e713deabbc3380744e9d178a9f822451aaec076db7e255b0148aa2d83fc1514b53bd17d095bc9a8f19dd4c2c6844bce6e35fabc707e3494c7dfdaa1aad2e7f3d32fe818cab8ae83fb8282c53da9a4bee8390d14fc313f9096028b70e9914cd8ec63e1215b7bb0579d2d5e4ead8242ae1b4c3e86c7c759103e8c8502c20ade3f4f4bd2baedc79ef31fb402a048451c30b23aecab40c3290956bb00d013f164869aa42b808f8d3ebdd1de46a5e82225c45091a8f15d5e10bca76205b1a5f64c15b3d4e5cc90a2cfa7b0a3f2f5c1f9c4e7199508e9a6e6fb4ea3c7e096c33946ab75c445f93cc3ecbb973dd9379eb29d275c8b1b25a16b941cfe3f550f5b6feecfd0cb4343fa3a09e0fc9f24084ccb6af3b3f14cc10ac75232dc789ce7735147bdc4cbfb6e2857c3537943c9bacbec5f44f24970d122e421eee3aed1a534d4bb1bf5810489ad19cf07d1fcd5430845559f866cefa4e1f31e7c216ece5fb90cfeeb0edbec405010ac65b920b78f697280fa5093601bf520dd76156b9f79bb89bb8cef2f3382718b46efcd8e37e94ec3d39ccce227251454739f3873ed194620fb67d8c4113b946efb363264bbb99b8c97c0c92baea5bdb757ec177ae4f965db5313e5cb94ed9375ade408d6d24b7b6632e8cf9a8b9dd567de707d788926ca0a93d5dbba23f1a69a1ab1a22119c2693dcee9ea8001cba2d23bcc012343530e419305a24c887c812ab1ea893274b3409f267e96b0f987fc33369bbdca6b26afd2d861e70ffa038a9ae37206d91b869085bb9e3371d2eeaebb82168854c7b402c7322220fa2f1df973dafb4c9d0ad0f17c34e82a46b42e20fad5b97036a897027241809242e73316f23d47505b8808119c1dcb67cfa3259255c81fdd59ac069dc6a596e97a67ca6fa75857a8a21371c8688ee5f25fdc16fa7095e7faaa20e9a13a27e0c5c3aac4f246c6b81c4e30884e063754f99fc39538c49e71e76b43b2c8e38622706ad437301380dfae4e96c4226c8415767c059ac3fee89b405494fbc2d583aeb8632a1855e3980ef5442b2a6c34ded29c7455751140919b4e8010c8f609c530d9cce66753ab0611f7711e19e44ffc4b75be2b9ed28d132a63f2e2090860d11fbb576597737dde179d95f8d98154a243844a8475ba9ad798f60ce0323ec0153b576a5d5766d9350a2c2d94fa22d80201a75d290c70b42020d3f17d2cd4c4129d261d24d3fbab9a3132e04857a56e773c2a6bfb3158fb1075db29cdb8711b02e192f7e9e1dbf96ce82f9c9024b0644c94385d6fdd7bd346e0df2a5c173d44e4da94dde34acb5598acd16f8778dd08e721ed222d3d4e65a0032526ba264abd7ca5f540c75921dc53e09f8d3638d662cb1d6db2150b7a5d2a9f4e69aebe11edc47ff6b0c2be8ebe2c1278e4f29ec9b843203a913382a12850e92e82086aa91ab1cd9352a8de602f86f4797f3539801d1882bbdf805ed7ee11a7390405bb16ddedc763ff02e34da984445abaf76e9548f5e92fbaca7b31a198f0ae4b58d80eadffcbc040337aaab4a64891b8a69d5b34973c56c74050fe83b00a5b7e7bdfcc3196374e892173295b03949e6d5786a67633e04f8488fe5a8b1ba64fa7a6ca8133bfb9d1c0fb962257555ec47f02e206d05637664bb56887acb58651c2902fe9767fd66547bf3d66c6df29391735226ae8f320dc719231a851467c396add0f20d54af9cc6eae15ce7d08f19b37dfed0ba8b2dc471743cb011a22f51991f66ef7767c29f2671e35b946c7bdd2a67941edd061785d6bfc0608435f3ab97cd137f4e4525d252738366e841c06eea77e8288f587f7d07bd74d52b66ec319f5ac7ce76f7d80674a9b4a1d7f2dcfafda8af37ccf4f936241ab4c7d594f37c680090b4546a737a40af67d22bf389fc013546ac9c1cd40d521f80dc27ecfca8829d61222fc1404ec1c9d35cbdb5bc8f481d003844a74f09c6d22f651d7f2787fac0cc0bda50490e3b5e6fa0b32359513ebea63dcc80e606e9d98835d0a722fb1085983caefd34b4cfee5bae842e63b882bd1f0858047b7d828e752481252a29b2870431ad13f457e1d7bd36d68266a1d195ffc8e979d709a628b14a317d9e9b6b560ef9f096a3e78364641abdd954badf2e5644d9e28cc8b3bde5773411dfef298cc9ba22471a144ce59947759e738bc88d9dd900dabe10196367ad7dfda0df1d82db7a9267eabe004b5ab584e2cc2365a4284a7ead49a49bd9b5c6a2059e84a95e2033ef5cebbc5e7811ac516f5e8235df6f4c5db4879b5dac527e93aa627f2545401ee341947214cbc36e1239cb7e6d4efcdb2c46eb293f6cf57f23686ec9e037df588b1540b8448387530b51ea2635eba62d511272fae6eed912a92648075f441e52ac03621ece406e03c74d31e6e534a1ccc79926f92368085dcae3d8402dcebcf7dfa0600ee2098f2b7c81d345fbe8cb8d2b5061bb0c86ee5af306e19f2bb4e6531be7848243ce1f8e02aef7059eabdef462d705d20dd13413b7a0cca79380ffc382204d85339a9aed4db13b68aca3ac6dd2446f55cf4277a29751aff8b12315a90e3baaa7ab15f90fd98e4e530248c10c34fa519ae91162fe9de02ed6d7521c0720ec96ccd0db686077943da7e1af0ce8904975afee549aa7fb8840d79206f520cd6f829ad8e12728721906758d4696b98fe965aac96ed6656d79534a17a9ceddc6bb6a95cbca515c6a7f45823a6d1a20f4318d985832bf2721262654d15d8e2bf486ea7b75f8556d0a2b9c21418a71fc274036b9914a6b939cf74f831a28a906a4879ce68828c6d15202050e8fb79b6b5966fa0596a6634aae59d18c6f699c6e0e8f70607049a358014a6c5abd715fc443669ee307222b911895fcbc4ee0adeaf88d1a0359a700052f5bc003e83e076cab3e8297da41076549d17b626329dd921e66080cf3d9753ec0dc135f1da9b86aa6abf1ae5740541b747a35650677e7155028606e169ac5c5a196d352d033c344222e058b9329a069a11dff7a9858fbbeda9a98c66a508dbff71a24e85cbe2a305a1710211a0552ecfc1857710b5550918982e3736db9945d29a39cda7cf6e6da8f0f51efbd56aa8be6d823825fce95314b59686203d32bc22547a57b65acc90d45669b9b00f78b2ac03cc4b842961e7d39026cd5ed6333e77f6beb62a270295fd9a574b0fa3638acbc666d2629f42fc812b6e0071327af373884248ba7d9158372c9b4f4796a386a8b94913f26e48d88b0f13d4ffed50ac117425d76963b6c33f1cbbdffbc0d0d4ed6c193636c7ecfa334edd564a08f1390cd03395cda3059856fe91450b362b87c36e6022dc40f9e84591deba783d4a06e549071f8290efc944bf547f4a980783e1a912ce994df7d9a2e6df3d12267809d2dd211e1cca9eefefe0d2a3d3cac034c506b8e9eda0ede0764d7a1d15d4d069f0a30ccdffe2d0d29269d9d000cd2cade45da3e11d7beb32b68a1c65590f63cdfce9d3487e0832e1e61a6f25d9cbae9c6897a6595c28060df1b8a5d67dd0209da8a9cdb9682b7d01e993b311e657591da79ae649bcd638ae598487aa82a089512b9d6037cba34faf0ee44c5ce1b039eb2fb118721b1a08d3b7b5e05b037dc01255260a016967a9576bfdec36b5ac77863e2fa057f2707641f112f1c3be1ecf68d2b38b7c625c4e96363c8a9a911991e9309934275718231658061bd9f049a36d87b7ce38459c4ae509e3035957fc2fb6d8b47dcd88ab6d3fa68112b3f79c53e85d7ef231c325996d7d4f26b1d9bb1d06d772884fa996161ce8ac0871f23ae1d42249f6a5ba301e2595f8a003e250f4915298c3c623e3b6ad20ec70a70b6e062cc746a2019dabcb79072c6cae5530ac4937f02642d9ffd1613360292fa3459859d160a8cf7aa082256c8f7342048527da4f52f18afeb8050b282453c020ac64d8d3ed1c6fb7be1f0bb31339e54eebae7d03eb5d16322f99cab336dc6a5aa6fdac2eeeb737593c0206492dd2c6a64c4132361d66b5f03fd113661e408a2d328b410f53002f5737c422ca25a7b8b32e76cf4b862262fd549c140da5dfae12d5aa3a9b97d6fb3c15fb21c32f49ef3c7a6e01470dda3aaca83600d2dfc962c477aa5da1159e4c8652235a50c31053b7544f7dd3f4d08608b4c521567b762383dadf92435d7844c06cc1f785e4c24faf1b69945e9cf39f5cdfd21eeba86f4ea790f4e8735db22412d75aceb4536785b3acb94d8c0a1a5be945bc64d2f73b3835502264eb54ebb406a51f5269b757b42d223958fdcf085293467f2dc06bb4e84142ba5e881ca245b385582364e29b7cac261288138128d955de437f6d0a53824b599b461a5feb5b6e19ec629036a5047b0610a5e7ccd5e766e81b91decc3b225f5d797c6f78c2e66724dcfa7b9308da959288cb0515f45eefc8f0415bb0b59a422b41118ce3f4e47be36e72cab4d4abbaf5689e57828f4aae7b140b89e7484e3e65faeb00e7a6a9ef5c93327056777354e182f8b98bd075fb59e26de3ce43a1781e72d96460e060ec395016f68c8a836f3bbf4a2fcfd5508915ee5e615f150d1891ec3b4c01b3470d254299882166c2cc7883066acce48bd5a9f85c515790da8dde29b2eca4370dc05835d998c7a3ef4d7695cb1c3e1b9ca116d93b6e1465fad12b7ec6e5aed65cdeb3819e7e0f439924769159e7a55793c8a9714aee30b20da16b1aa13c34fec3fdc37867231ba32a0b4f2c3ff27634f2b6ad352a267b0dcde38c34fa1de22bef79acac8a0482193ceef68db457604bd91043b8be970ce6bb74fbdf4d1ecf7e20f438060bc553b3586cf0669486b4c4b178905e0b0d1ed3980c92dbbfdb36359cbd451a2d805abb915ac6dc08f2fda8adac258e9face7d1dc59a95337faf662a75b06326a066067420e7c7402f182520da42d4dff855f6195c81391de97384b7bf651e12fa5564086419ad134dae91496be838123c4ccebab2f33194604c525fb255a3654ac600bede2b868550a2a5f4f9ac1df58c797f224ccf8da23419628feec8e1c6c8c6026fbc1543f67da03e13bbb71f9f588f4c9a07e3fccdf4f8a24852dd0fc44db6f253c0679f16cdfb93ecaa2be8cda6d9532f9ee68840af7907dabd19152fba42a8aaac9b188e24801a741edc15dd7d01276fa25999cb202c9485bf33a9563f38b30dd0b587e4e61cc07173b25121a8f36de541b60abdf2f6e30c6197e9011bb49e027d85ee1574be921c93cb98e7be5fcbfd90dc3079f52d34ba9ec2b37c658eabfdc7d82029c61981460aed0ca7bd127dc68f6b91a34e25759ab8768bf18d37a6f67547d456cb6cb4f7e709230bd14e18226b26210a00adf87bdb7ac0482075a91a82e23d9dcbe4279acb24d9b07540c2aee831b645368633faacd52aafe5a72cd264933ebac761153f046fd682fc9326c0d9096267a65f20b918c52d1da67bfa962c7bf64d725104475827183b87f9038eae2069291975d469738a941c78f403ec38ada34bc55ac09e0108f9f8e0307372929da61e3636c4fc31974b04a38ce26ba5823f8bb8d8d3db432e591cbda25b2e16b6d5ecc9f949fd6ef75d50f54b2ed3da6ec08036a407b3997e24dfec5f3ef2b9c9f3039eec33a48a635bece38ad46e6cc907095a577ef9b34c58031ae777dde013a43b50e8e17c9445c3840cb9c23229b1d1cdd69f379249eedadff6fee391def13ce9796798a42249fb51cbd90b893cdae0114221bb69e977f9748dcc0d6d2205cd743acf462f2b951295f794db0cb8cf06ef935dcedbd2ce1f172e8f78dbb28629560ebad393a5651afbf722c3c250a67421f47969a47312963d30a3355694c4d6e5e9f3022ff5bacf0783e0976670c036475dd1432d4a246392e82d105275fd81834d088225abf3159395ab1837b74e7df11dd1867de6433d4118fd789c6fe5413e104066075ebbeff8a86b2657d19404ab9bfdb9fed4ec0218ea1e1ffbaf7e7b0ca9101321bd6bdafe98f041be496f5276adcb2927a3eefbf0188f3f6fd896fbd4a98ec84dd8d134136dde1a4f3156e581672c9da3da2d1ef5f2a3be8f30f4fde46aa32f3872f19b6cb52a73514657433a4d9b7e32d9d5cdb2463dd5a383fe77bef458169cfcbbfa4655a620a8fbaaff5fe4c24feb0939ff7f6e72ae88fb8b824e374a8daf942e233a28ea17c6478552149882418d4ece68fb8ba103bf2dac385ea404c2aaaaa4f0ff0d25a0e906e8b43034d393afc04f73e20ebd3718923222d1dad10385d5b36733bce8451c089901b5956471b4085c4ad7ad409846a484840e4161be84fecb85733a3ad89e134dbd17bade0375f43a57adddb48731244ad8a4f974def1e0187e14d457411b390947b5298488b264407ae59b7487dd9a31402b28013b20662a544f311b47fc267150b47307338ec6b7bca4c7683e760752fcc881480fed3c605ddc6301dffa405c48875df11f72af501adc53825fa05eea351637787168b54309d1c03e7b71a7481d4f9603984e880c570a8aaaeeb131f3dfe3ad8e3f011b11078648a8be2f69fbc8ec66a45d2436ce0e3225ac2d7f5bfcecd7b542df266e448e679c2011f470a14ed15b4c40b1bd48afcaac7271443169de7e6300e69562410c3f309fca11af9af7a971c962988f1539134341ef51592aa85a753b83d18a237c0caf61d92d8874c82f5a599a929b9b5b2d7909087e0e185079785d23879163a90309721386682270301a6641f3d4484be81e682c122e90c8a188b44d05c5e5c5cbcfc8855beea8c403d771f54d2277204e5e778f23c8c2c97b87c8b114b8d409e632e7f8a7ec93cf924e4e7b98d00c205411e1390cc0ae13678ac16e31527f684df0530fd557617d3061a69c19859cd4bfd2c5e61b050dac3c34a3d658b7b337d8287f9f4c74aa5d4e2b813a4acc8a1d16585285f3d5e90c438723b868d8f97bd16b1d827a589f6a703b1980dceb4fe404e07bbaa0ff12e66fba1e0c46bb0185d8b77e154cc12aee5434dff1cd9bdb58aafcb13a829b82e8dee5349522c3a7dc50f152cb4d1aefbb02a13d21ba5bf959c21d6f8e23075b1fcc910965fd2a9022d9374127fce7d7667fd784d582b8c84301b053ab91eacf116b5b191f30eeba200963a0400fc0eb790eba673b48f343fb5682f3c38926ea2381c5f6f2026afa172101e8a9d13ba46b704f87a050727ea17301862ec92fc1b8317a6bb7c073ff139bc7a025a433e3989e11314ce977afe3298cfc288bc7255239b37b0a0dd0f884d6776e746e9c2a32073dd1f375af76d0b761ad639eae6e1e7bfaa26ff9e55dfb9ba2690f7e0fe5d91bbee7246e8945ea4cdc3775ece752ff8502ec61c546b0b296d52b811ebefa1e902c20ac4286d5993bf2b5fc3d51dd4597f1c0044dd78b75d256ac0c41065318ed3b3b00e73d417c18e8024d5b75b1e73d6437c4635453da25d6a1efcaa5b7cff6b04e65d4ad342ab8fb2a13df6058c3365f15dfaff710217e2c18eb0bfeb6685b938c8c63caac0d06ce06f37fd1d0f0c5aa3912761e3fd5078f6e8ae602bd9b3a7a3860dee1f85a427240b73c03f3aa0c8453449048e12ffd58f69419742dd712b0576cb4d7fb6e9df7018ed023153e4f517cbf24e83fe6feacc814729e07f4c0eeda25412aa44a606f02e309cc6f9e8c34204007ac35cf731ab02e7257837fd486266f32d6e970860b5e5f2b995408a7a2ba584a46157b5c7e1ab209c3197661f7c5bf9280cda10bfb0cb9bb996a5be2d5696fa6b2627805a2fa6562717eeb4aa14fc04c7ec2991f0ed4e2cc1de2beeccd7eb801f5e859210c1470e1d3f50e859fc90bd3bffe8b46b0888394e62d876ac24b893a063684749a175146c20b522db8bb902b8bc5c986b958150a9e1efadb160115b88a474b0b16c3ef2fa749eda5db11e3670e0933a66a11028ff730bfc84b6ac5531af35ce7318d3ac49df053c450d50b35374593bdbdb7b27a92a9d60aea846008898635d199cefcdd6133ac7f9ddd8343197288cdb79b4f6dfb3762ab8ee6ecb8b171f93f1e526747dea8db2713d6cf635c9809feb5dda3590b521fae4bc78e7a19bb2b8dffb3a353233e17e979473fd2b0f78554718acfc5bbf490907cdb111d1ac62da49a7d50124cc4efe8b3e9f526e4773e9b719617964dab9bf4f78e060d8a467cd67802dde864eb55c8d46d967a70dc8fd1efe053e6d0d9baafbc6f43d77590e7a4704344e0a2821651ea5a4330a8bd2ec95802c269afeb39daf16bc6743d158df073d098077e06bdcaafb7a63afe28bfd22b4e011a1658fb829dabf14cd8eb4aa4fada3bb187a9019baacf7aa294bea27bf7372422502b9ee0061520e3fee25d5f62cac9ca371c449df8982e829b2477ebbeee290518f06475ff34e296645bc8f9a372ecb934def5f4fd47c84fd935e320fa7b14e35b5468cf280882a8e688f4885f41a3d66b1cbb93a9378b3975e755a457e79eedff876a67c178b9a793d31d3ea98e0c99ea55538cc610d4afa426d0190bed5a0faabf389f8d74163711daa848f6530357b5e4621e054776077df87bb70c2c9008c649bbbbb5857e922a84fa3eef7c0211d98b19da3e1ec4e99c02d5d20a698fb3ce1a6d5ad74aa8056eaaaf8665094f62e4033f755f377b9342169c7bd1914e2d299d2bba7499bbd173ed8a477501807cb79a0469f261c2593bcf5d34222a29bae7e532ac1644869503de688c85289c7d08a987df9cc518ed3164e4a2cf7d87150eb399abeed38efd41a5c73c110862d3dce4eebf0f3d39d77a08d98ac57c1db20bb6ab72af1c8c51e5c4726393407541fabca37dd9498514cdf3606e4714d4891a5ad8aa5359a10862e75908c5f916dce0c06ab92970b1370a2199d323e2ba1bd5421a3f6feca4e552f4bbc7a4950213db75bf43661a4bf9566c2ebe4c7f163a20e6bdb05e31439b12484b5ef87e8a55d523cb5406c71a2852303279a2103daf015c311555e6671525930a0708403131805a0871079a3dab1565af0c080dd45f847aaefdb0a8b9a2b2594005fccd0917654a2360dde79a5d64d546303545a981ea06272e2b5de5bec3548ac9516b7e31f3254ad8b1a33142a0d32d8b6f1f56069e8c59d45dbcff98824ba9217ff98d50555e9f43b2bfc72e7fbf468ef0774908897742b7d80b2998cc1fcc2ffa722e3e0e0523591e077b4a9ee003115bf24545f09c529d3564f66550f70cfdbc170152eef70fb5dbcfddca1fb72c56604b8f890669b7f480d251f2e8f8b9fa9af10404e1a90168667b8bdee6722418b11a66b6890b26f097f57f6d2ca58943a09caf217d0270dd5d29ec8bed25ae608944c2fee85131e3910c553a1a8e759bf73b1d4ad8b21d98e1182dc40502087d8583646b5714054d0349d405fe1bf8458f0e16a48ffa846bad7a14be9ad4fbfce1eefbae6970a3605f98e0aab4e59d9a0a76ae4bd31be7e5995c0a2c06bbc20c62577739a4b6318b949d373cbec9a121906fb7200817d19adf87b31ede573f2e0af0290c5052e576e1829bcb6d3933d9681cb148b0707c3538f57bbe883fefc436248767bed87190a185cadeec1a457b02c5671de58d30fa31167721805c30527529e8d63ef02a55ac955bc6ec7fd73d997d9319e7a6677825c5dd32ec8b24e892c6994328c01161d940a334752c3deb07d88511e68425f76abf17b328369ab2d5aeeb73591da70d14e620ac6c9e0fbd9cf2ed6bd71a93bbdb4d694aa9f20c521aede09f0213d3dbb5804900e2e8cf2fb4e499ea58cef77018da0603dbe3bd45e20831775dd7f3cd54808bee3c6702d5b68ca8a51a9bb55b062715274b0b375f6eba3c4a845d93a3ddba62217f05caa6e74c9ba3e7273ff75e582f0d006e2b3e7f093761c3607b672619b83e4afd19975da98b3bc1e58a793bb670e8724d14e848ad70a0737a3788da231ffd2ff8fe2585ab89791e1718968a31345108cd3f84bcdb677f7a72e4beb2f4823399bbb688a3132a14f08222a89ae1a3fe5c6cc948e04e6e47876f8331193b05aa1389db3ed3e3d9600a1ac00fb60bf03522041dded91e339e04a1568130fda0daddab6957b6d829a9390f25a3725127a441745de6f00e453aef82c783c26fde42b3a6a4b06409bd71e1f696d01b2e746196cc3bc758d78b24c8766d72956763b7eb179156e8e9bc062a4351c41c8932522f94911b524a83445489f86b6cfb45404ff7eccbd93db13957e5eec96a814f79b5b73024e100f0447e604f8ed7354fee894614d05e95d66314fce2d0e4662a688eae385022c36a63cac3bd351b1040081838e15bd424dd56f92f8a0727ab19eff6919cbfec1109303795236c886e19ac11a8afb23b6562961c6b85e0177f55a614cac1220e09a5532a53c9268e9e84dddbdea0c0d729d47ca296c8259de2e2b914c19aa92720f2b24e12b3b84381c98149de3cec1ba50b35fe41817b90abe478846023e4298dac26767c98acc6fab58501d04d202178e322c35e828caf489c2bc696e9d1fcd94b8314a9ff09e44ad5a925ff88eaf3e66765935dc610cf42b5931da738fc21824b84ea9134e73e1a5ff575f2304efc6da4f56a8c65228f136bdcf2dabd4a17e8cf04b48af4e141b649530a85cb8e659516efec34792ac66cc1e70936f5a44bf44c26b6d543ee150d43c7a2af231a744b08d68386c47a08165c21abf57f8f49db7ca877b757d49ba26fc19091689848079c18e90e4522f2d483668201c1e0e3b3ac945322ef09f6a2e8e0f60c8b12541f3a3ac805e5929a014ffe08e0ddb099aa60b609a29ed82f7b7994197b8b767c127fdce5f6e1c57d3f3420298184b8d83e8d285e2b5e127da5bfe5d856230dd20556a0017ec12c54034eff8b677d087a085665d127ebe5adabba040c6f528d528fa3c3f2542650e683df3f4d99fa306f78339cd4a8a77a8d56dd816715e4296762001edf1a36238ef0366497c91c62cf7e05d8a4f67a0ed8837da833522cb20bd152a9dc340386ea042a09ac652159fd3b2e9b97c5f04dd78b3e0b6d26c6f02ca4e00515805f1a84c6ce92689f8e6f942d08d93e17dd15cfe3c3468197a161342b304d6e1998bb7d42d243822ebc126fb9d1349f412f10c965b8399e1591ae6c7af71160258490d183298723c7e36eb214cc8cb65e0a789c68acb4290df1641f561782015c1a5dc2eb493e671d0eed3ed6cbfa479d192594f46878dee2a94ffb7e38f7833f4e40f071c6861dc670ebee333686731926722c1eabf6abaa916360097093667cbc9c6c21d60b9d54fd60d1bf8aa4ecb64c366ecf0a8339bd3d92a19937703030a9dae175e165cb5ea2e8aaa951f52390001fb6488c0d1afdedad9aba0a19977b857b109e05a3a48a5bbad206917a4a72b1d1d504f1fe26f45ded4965eb44d56e89ed2493929cde6c55a32cda49b9c6619edb88e5cb6427465fc1d029aeb9bff7659b1aa4c7a66d69eeed38615ce6913f1f626e5754b45eb265874da0f56cb827b35899870f83f8f0c9470d129482ff7277a96ff271086a817a853e92ffba589dff635c92a1d31c3e89dc6b5cf3e394f4771f9939786a7d8b4532da05216ec09ac9c4ddb883c90b30b54210e7f6d7c2ed3901abcf2f78288456c4a6694b58d145bf00d17f94159e20642c60be5e36ffb1d7418fa9a1ccaca1e74ed0cb39250741db37cad95aea2e67b5cfa236cc5d151a1dde25b30c14bd4dd92e6665bbb70e5f37d76adc1a4a5710e06ec66501974417295ec2515b18c22de75bc12f45f98520b422a5caa8de27732c996d4137b5fe2097f8753aae865c3f5f31a0202111b2e41cedf54ff4d21c268c18f9b5cab6f3c50e8ff878bb381bed975dc8694ad3d5d9362525e59806d1d40455e8b1ad4a00d69d87e27cbe71e8af96e1eb69e6194ddb4d7474bae2985f8f209d2aedf5374b48cf0b6c3ee880a7ee2f29968cb75ee63d32d2c1aff8a4be2e160067cd60cbfc8047cddb90b5f90c4611533b625707ba8f93d145fd6aab9b96ea0a9e5108ccc4189cf7cbc0064271436f526ac721b3d1554e553aac265519bbd781eb40dec4da9e433ccfac2c6249f65d4c3cbc6c1b0335565d4c51e2a6c41d0c4e10d8ba157f7232f2801c992a07182bca66b6ae7c0a0b212bcc1730b512f60b5a0632f36fa73b0e0639fff9eae7cf66dde81306e3d0affb20306a98e83021508b3adcfbb2dff19378b650403e7b4f5b6aa02ad41d5ea55286ae4fc1f086eda6cbfa196fb29c51bc050fb6ce3ad78d4965f6e92453a4ca963264eb8b261fc38f1ec8ec80b6088c48ba35e6fb2e1677b1c5a658b5323627bfca6d999bfd2f4573846dbca4c5779551c489f1fa96c78993fa735447b62d91af0d2f022ec35627b19e64ba33a2de130c7b70bbd851d20ca251cf93280cba0ca12c2d735d60c8502198c445df37a19b6f55d3b0c7968ad87b61e3f8ddc079efd04112f4c77c6dd55cf1122cae5d5b7f5ace97d7d43a74bcd66070d97e6491e431387a2706b5a34a05228c73df025daa46fe32ada0af0e9c4d4e6a90a563070bfce06e2d94fa6a59de49e8678fe47453135b76375ab46767deb550b3532bd367782cb65e1f0e287a0a5e11fc2b5df5ed938a8a050e8caa191471b7f1151e8c5f9b8c68f5d777daa9f98fddc42cb4a017dee4e14d16b59c53abef53aa8895283721d901f235f5930afaade83be443fb056bc06f7aecc1ccac9695432f78674e6c4d1d3bc64d8796aaca133ed5231292b7844f7c5a659e69a3b4d34a15e18784c5f558be305e35191a2b56c3a6c8c320cd546fe6e5e086de37d806a4349c1c09fee3d741895358735980f9dc0177dda68e0c2696593891486a9d10af62d7d99ad68615e98751001803ac858878a3430db0d582e6e7df67f90c62ef09bd3a7cff38ef851af9a4147e5fdb93822be4461f201eadbcf437330619ae6a375fc7f2cd896100628fa8357b625926ed9c33a4f047f44c168237faef212e98e578749a84a2925a1c3742bc0bbc14095f1b81b6d75e04550d40b09a6c18cfa3b6da0ae4445cc4525d89f6195183762b0425b98d6727ea3d3985bc783171c86290cbfb9f1a54b95b8efc394a6f90135717935f77f99672b20e47868d2ede5fcd5a27cd73ba1d25e0308e0518c6fc72fd74066899606269de3989f8f08f8fbd33882bc8db8fc428f8b60e03ac9efcd86ca4545611d1707d51ac27ed70ed39a8be0a310480f2bd7a001855471d2cac3250b0fd2fe83654b28e4c0cd0739ff7bff9e909667fcca7c67ef7717927cb1c1b75257bbf72d7f7558c0dc86920348961c7a95a33dee5c8dad30dac8837e62d56e4152dcfbce5e68ddfb52d999e2eb2bba44d5fca6627f6cdd000d3fba5b1c0903e610fed93dd68f09eb8a7e6b0166783218a3528553fc7fcf978d92cc0e8f049dfe2af317afb3c60fdc6b70752ed55be5c1e72e1ce3188c8784878c83c493365d762775e782d6ac2fdc77dd76fd3e249c35d4c283dbaeabe0d835f37c5e646c7fd779f279e30d76196761e0488a0159635153e71aed81e28a62d3eb05a7637d86e6fd0fdfd4c4a3615f0ec193a0a9f4f6facf3ef409e7a99d8a62da394bc6ab088806740306388c5ba7177698fd96b904c7d98fc21a56703110f355d888bc4c4efae1f34bd639bd86728429bc2c956a8136df3aed4975dc44ce9075e4b52fdbff0719aa529082356e5b750f4d1c10b72b30a0ac2062613949d74e5ea975838251b72a2b1a30571ec80c37c4e03bc9af896159dc51f400e37bb0e7f6391aec8db758bf45385df0ef6344e388a5e6379c8131f1626623efaa9dfb95c96fb3270a74f7632515edecfbb0bee58d8bf2ca2ec5c30bc720f7bbbba2ce1dbd485067c25a0fde2e61e66e34af37c3b46333f286541e2185b44e01d695ceb60536e65adff30ccef5ca2d5de5c61f6776a0975a2800feea989585c4ca594194095f3ee7cde9e37677ae8eb6a984cb944398f2cb4447339ed4bf06afd9033002bc0933f01cfee9ccadf69b48e45bdd488abb925f547b34bfd80db29b999542f5eebafbe513a173bd6432c56f5ea89bd1fa0663b45fd92d884fe54e5f6e3b8ea3d6daf8cbda7f68c47f3c2af00d72525daf25e05ac5a008e63b03226d81c3a9657390c324d085b8643cf37788a21e1dc7a70af634c0f8f8dfacaf87fdf05d619c8eac67dcbe26dba9d2ec2d433fd689deb52e995dc6334f7a4cc985d9eff779e1b5fe36a6bc74d28bcda9ec505e3c86a1f5a4a37e961e4d2a4f14205f1133bde860f9d10ea2801e3d2bac6a24b478ff85f66ef83df0e86a8390c6189469c53e2454732cb5866c5cc385eeee8d244ada9d73025728329597675d8634ea5f25f20b6424993a608eb74e46d5233e93ae15d5237c5e69445d27841ac11ca5aef35a8844c24f0bb67bb995ada987318c1572aeda8b4220eac5967014157c4875011a60d35993a4036e409defe1b51adbb882a0a56681a1a886f7539e6a743c550f73709c95175488dba0440553125b8cea17b80ed745e72cf153592a20c00f4c6b8d5963628199fb00307f115db7a4d830f776fe32560ae698547d6050df6061e33758273961d149edc6d73077edc42c02718840048f9c5186ae0238847b16bc15d3ff1bf4321448404e5c0c031e03d77d64b16650ad4500bfa98ad403101578b8198236854bb0e403f2c33b4a88d41f33f137fb1d6d315a838b4f6decc7a7a9a34204d54942566ce605533850ec4982ba12a76a8fae026a750f9d916863645fa750cf5652eca7917f21e79b752f8c056de648134980eaa92db1ab3438df658284d8fd450b3aab736b4ce809b094b580f40446c507c5e4d6142b85d48c33b1460ebb34f07a6afcff692185a2acd44d7f97b55b72ddacec2ae4e5c7cd16f1d882dc17c060058fbb8a0d6d3f760669e150946fba218a067d3116e82da3c5aba8f21e88b787dbf6927be25a52436fb42a2ac90d329cd7ba84a430d6630f89592ff2a5413e5c11b3c38bdd2cba0831f9c2efb1d5c8f3b1d230939320f9f6dae7c8ef4326d9f2f31faecc77d44d661b041393ab41de293a9d8aafb5abfbb6945cb476ecaaa1b3db6d322c0ef7919ff10f04cb153aec843defecc7a2a3ab52276a5f3fb4a019b7ab6271571b47c3336cacdecc20e2665783c2c6a97265d8d1f710547185054e2602851fb164e22c2078ff231e709818a7e3df49820666878dd884b95a276b37cdd1db8a9aec5f91fe8ba25a4aad70e77b8d47b493b5e98a90b915ef4e28133c17fd0cf2a70c8ad933f4d2c9da22e4fddf0f0827824ab223cb25e6a3d2fc14b60796ec7f1db46b450dc3463186cc8406caf07887bccc25d943e35b7f2df168d09595e194b4245a6124db1887ec4a785bc8c36c12a75942a9236ad5390e4ed65e7c4536bdf1ee0100ff851a8d9ce9707a8d9cde8cfb5388df7d087290d73f0277ff99c4887441d76455e6da6efb6e5568efbbd1b50610e9ece14497999fcbe0829e2eba66578534ebca6a7bd55461cbf7abc6707413ba044f51286203da35db5150e9fe550bb2f4e2c4616b922633d55db4fc75ce71242e01f46c61e56b011c23855dca6ef90484c4d6cfffd451d38f0a0e5f33b678d26ee33622abe3bdb6d59062f0c903cf2ed248be86c2a8c17bd76b21f1547e8b6350b43c6bb28225bc9d8ab8e0a458d4203b146cafefeb6919c5637b51dbc659e62c3669bdbd61f6942f25d00285afa63c740aade854ddb9bef190ac055ba96982e4481d87c420fa870b6f9af2a7f8d7a3317b3cee0712f74b3e8aff8d3cd1e344f47742609bdd903ab590f1c5a90e602e5f34229fd9a6446fa13417bf421809d657002eb45ec4efb79c39bb68f27130a4f823f967eb01469b847e4a4eccaf5e7f0dff4066b37f2435648e8c0a26bc0efc181c6076b589ae982d9ce5f3f1df16a91be5654a66f635f1e2fe50b65fd2ca41242c960ccd7595aa5e33f725af656abaf131b8ecb981ae64f3d2851aec21927f1356ea346222c814ae475e63c9b1afd547118eda32c417d146af683a873003acc19114b5eac5425f552cb919eeb8cc9a80d7211fd31a977d76e566b8d19eb70b8ef6bbdce66b8cf0393b4729512f3c7d160aa048ef55eac2bbd3248acf400ca913bba3a83242c8294f68db818481b89df3ca393d1ae1f6aaa13e32b29fd5d351f7bf6166ecd6eb40cbf3388c55e5793ac57d1582bc6d7500b33d994f58689a2464857f3029b4b74c3f4bb3d8d682e7e10ae394e3dc0f87e71e87e66d6ee4a38decb69a288d99820feca5cff0a1404d64e163a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
