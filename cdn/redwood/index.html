<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7cc1450ea9bca8610cd92843ed958f9e16ec1957fa03eb197fe2c45adfb5da16ae4090c020bce1fd6d741f2d176181ba227114c8bf16db6378dd7804726f2f338cefecbe490617a291165d5a816d589194841c5c3cb84411bbfb560ca16680e60edb88c45d20f70e54260cce8eb97a18c8d74268e178fc888dac32b70fb524b9a0af86a2e58a71ff14cbe5923fa7129a9c51e6332abfa44ac058491ad12d7a235bd0afea6759734f8c10e33da1640718a4a665f47c6cb1e126be1e6600c40d40ec656da741c54c2450bb892e2988c8c312799efe7a74bb78bc8942621b79f0ba77bf260a14a2a89abfee52d16e3785e96de7e638327685d145e344d8805ac6fa60af7ed443699945b20fac6c4548796b75bbf3bfb6f6fcb246079b2a180e9160ecbd500d06ea24dc9c870c1ce02cde60f82e93c079dae89edca840fdcce44d533d61eb3ab037d21db53ad043131105685b2dc1bf5a9e9fc3175291e6dec4a650bf5ea9b9123437dcf8ab9feecc010bd45727f819b0fe5fbc392753902db764026da6118b34558f94812f942d64d1edc364167cce7a56282f97162f234c26cf33c7711d0a71264882e260738504d85cc313141d5ccca35bbffe0c587ef2b4025959bcea8dec59767aafc0f403e72aa99735cd6cb6a7409beac36da423b4c6ab06837e392d25b26c61c4b00084ffc150cc955d29d4137cc1139a121d9a403f388b76ad749dd9cb8842763802770ddd91018b5d0410b9a3d320452986e7a5bb3339cb8338c3de6fafa11d1e095af2dcef8872f90a91c400a9e402757e72143b636357a7efb44f709641c35c5b52130140b302cc6c0107495caf269a7c772c7e92713aa1b40b0446a6049658200b04b42ecef82557fcdf6ed63bea0b7a31f36d7ec4de89d4226a767cc1c527fd60cb94276e2b420a70b75a0b23c0f63a7c184e49329332a05ca6f133135c483a1fd5e12a78b88f70da9d5b99cae9167521519c26f929938ae7e74c908435d7f0fd5eb7b3bae040675e36033b04d5c37c61b4ddcaef382d0dd54206bddb96037db97490b4daa086f8db2fb49b6272902e69eadd3d2bfcbf8ce8bb3c932a39f1530c66b16a69544ba8a7dd5abaae567b0a2077137cd3160ec099f33231275a3575485f0e3be6ffc8580f36f2c6fbdf26cbf32e7a88e957d9f36b3d159890bc4febc3d43e2005f04e8ca79f773238299dc4ab2cbf445269e10076582f81bce3cb29208d6fa147805509fda60db25e8d132da5cd8312e2cf536abddb5e44b7c3980670faba3fa168d86f6da353929f2bd88cc98645c20cf4209a2d05ceac4ea8519e91f60d8181b0fc7adc191639f7b9b32611122a6bde4fa05f8cfab7cbbe433fd390a4f76b0ea84b7ac984e83dcabe396cc0a87e243ee71c31d95db94e74c05fa7a7b9e3c3b7d1e3f99c0a35c79fc2c98c0cb40b6b7a7247bb3e1529f89d8d8e6b2e43ab1e6e3ec98d95133ca42bff63b74770a9190f442ae9de98dc2ca001bcba26b5d05e145ae4fb27ce4a2b9cdbf0b3e7f1df153c1e2640f8b2dc8b60b0b27e92f7bbaa73d768b9612d3f5d18d480ecf3632b1279cd3673ccd7a69d6012797a0b743e0baa92134558ab6bb519ae767b9b4d295619a5db188869eb7fc6e4993e4b1c8e8cbcdc83e26dc7ffef1a5e2d1079a3795605d323bf28c82224d5da068ba47a2abb3aa9626d8ae2aa9e37355dfd2fec1efdaa051904ee5d9b4709d41c8d35a9af40b28ba57f38a918d772a1d2721124178ddaa0f5b3e8f169a35c7ae2f4138c044ad0d9fbf96eb9e1e52c924da581c84414b013bb53122e31c9557f93e1e6d518bb2696b09074c80d9bbefbf800a6da53c950006a001d74df904ef7f5ec5901f3bb8f03cdffd7b53c6670c0379d3af998c7692d1539b37189de0c937824d18b95979cb0c5f758b4895d0fe2f9ee6cc36228e57728869722e9b016658ef517272df7c83099c60f7aee6821c3151878089f6082b6ece46f922e27bebf66dc5a3a19f2d02cdba0dff2f11569063560342321b8a055d26c0c8465a75da68faccd953ca137516c379ef1edf48598f155fec29988ade115721dc2d89d71a306fa80467d9cbea6c0e1cc2cabdf024175d9ddfed486bab009ef8b489514750c415c4e0ae0fe2514f563de89df1f44c245034bec884d1343b6146538e47b286cd6ca4bdfc1503d2c1c0474e4737cf49edfa962eea466f208b0785dcc3089799c9a2f08ed8e9aef77a213d87228b4c4080f9b5a3d02082b9a3e3cf8468175e2b03de385ded8c8107759bc55a341077ff19ca8f0b4406f8d59a80125f1b8c84d1e4acbfd1914f0761df9368aebe2d40c716d8124a0d05153b39a89c18e3f5115d832ca5a2cd239867c1af5ce24e1e61eaa76da64cbeff0d4a556ae41b9a2ec97e3da8f757e5a57028148931af42de525a3d3b4740d08a709ab476e054883823ef16d5f036981bc1c7a4aa983b5db254f31b00d31226ad40e47d6daf6ca1d8667b4bfdb34d622a784eabedd2d68b04b9979dc969f37bd38d277c53f481693e7a5120325fa623251640931d638418015c5b00b33cac3ddc8e5e457b88b564f56457a788f637e8ebdddf7f843d67384e5a1ec9604c7978897dc635ecdef56b2c78866e33731cd7cba57dda5f8e3edf2de10a92f376d99e07e866aadc5d7b8ad37672c22a9f434c20999de740d74176639e341fdf502f5976af260ab28130efa2f889300ca7ebbdb7111496f52fe8d16d9017a6a96362ccaac2976aa7aea77aea319213308e1a0c4045c9a18695eb62a154efd3b909899fa3cdbf8670cd8eae1e999ae7375bef5f8f48b1ec8e422b5f93aa91079f94c362761c06aac5b487cd5d2ff4c5709b897314497831d3defb4862c65ab6d6e1451a3c64b53a49421ea6dead4938145c6ba38c8ee7609720b6cdbe5f13cd6f37b37c3bce75bd09ffad5ad4b61de9a6adb0d0412caffe4e7d373240c23008f8538bbbd589766a3c6488f3ef12a15237dffe1f97dfa9d010a8d769f5b87a6f35592ef17439d1f06578f62bf30f8207c8e0a571ae5069930911aa3d9470ed2e52352d9d651579d2d3cae08662d0a2bb13964a9f5338d245198a5d944ab3b7b9c88700224c78c9c186c3855b9320096bc0103b6da22b8f870a85c99aa0e5596ea276646ae5539342da9db74ecc8432b60b92766628f88144489866ea9c8d95a86c94d48508d4456b71e89c200e7da6d96420ed35b33c7013f89cc541aa81693448ac4a6c32fbd45797d72f9d7aed3660d03f16554641412389fbc37c68505c8c1031b22404bdc178379cfc5a8dc1fa5fb767228da433694e5e83cafa91c2c904a1f85f9583b8df94a95ee7155e1072fa977655d57030746952d647334ea8e06d0fc72489a1558128533d0851e9009677f454edf8387fbf7f7def26db4b4efea5c0a9063cb3ce62cb032461e440148e686db6c14f24e1e0d0cc9ccfd290dfac417c66a1132faee20a54773fa351b2b1687b435fa920bb8fb5d2d877ebf77f828af424a2bd5a1efe1ef49ee1b268c9d56c931a4392da934daaacb65ad1dab6d637d2ffa20182329703495df9e45009dff1c578c3b661b1cf17d68a2b435433c5640716bed1b0b70a84dfcdf95beccc847d271e9ed3c3830edc727f9f1f3831360fc322b8a95602373a9393bbdea3b68b6257ece99725b8464e66ef0a2f40476f9c139e6e50a256688e56ac1d057defd47b231e224ccefe44d13b21cbb3078f3a77bb501ea20324fc3de3e1f7e743dfa36c07979c0710d43dad5a8a67582a679db2816f53ec71d18627de2f3173a42855dd36aa5e7ff1d21e180250dbb56cca3b11a0f9184ba0726e9adc42be9b0c1e17ed6f63e13cecea0a6f0ec48ba310b507b698fcadaffaad9861ce5b33f02c66318fd09b9495c854ed3ffd94cb1d6d114358b5baebeac4768ff5c01a00449f3ae9fd4e6835deaa53434b5ba87271b814a43058ee008a957aa0739e7f7b2934d445a2e54cef672dbc4a04738266f4f2a1e6a0ced5f49b627691e6afbed99cb8f87b9fbc13d0a4a648f8e5ff007b887eb145ee9426a4f9014de6e6658c9a22ef1113ef7cdacb9b6541a6dcf8419740f68266978ac8c5b490d86b91cece06f48c65c81266c8ff0e0e72571ef5d3227da35bce2b782766db3d0e314b67724283e68e0cfa83fc0a8b3f70b625ce62d7411206d9079414bcc7331b2a21c496a1bf3978a5cdef0e56595d967e25ca61efa4c6a673c62d435a7b17bbdf8beb03a5559c234f0e559a6170ba80c1d83c28fd26229c417b7336dbd3cdaf6b17f2f0e89734e7c6dc79a9b3ddffcfd021ae100aec74e97caa7f09bccfcdb1556bce142a09e3d640dc6773aabffc89cc6fc1b378356e57a36f634b68329cdc957afc3b0c28ee6b89056c87a35f008d2844275dd856f7829fee371f137e946286a8a1d330961675ab61559bc424f3aef8c9b7f31fddf6df81618129c70bb52622d9dca66b94b3f34770547218e239a8b89d0ff37a76bd278b736834f92b2871ccab71fe1f0fdd85b2cf3a44d2a0b8f207f33b95f8864c7437f0178a92c48657249f21d4c766d9a1d757b7862c9c0d1b705af2329448ea6f30324e771b67863a15e9eef26fcc44256b92b2301c0997beb879d63cf9a560885a9393eb1732ff8c695df64dbd04b75160dff3a514c5d33488596aa77fdcfc9e28b0c58ff0f028c4173f223bb00585ec6de82425f20d110c4b06fb76201142ff7ceea0b07b8de72a37fdfa4db9c47879ec8d2e99fc8eed9785ea90ef7eb3a763fe96a47299b534004293fcbbb70898cb77e805f19249bc5a1b758fe2cd4b2c981d045b1ec73c795aa05c95f6ac7b68cee12e09f20a15a0cf84226ee803ad7fe5510b5b306c8b9a3e235bc2d22bbbc5011c191585572827f82fe37f978097bca3a47feaa8b497e59f4d91479102e7b661188676826fd8c8979dd5b2d4711f495791d2fc6190728812dac3b8af3cc8582e007a237d459ea92273089293bf599fb3a9206fab36a26de5cfff3c2db576174fdaffaea04a320add98cec89637efda87247108d5df134225836f492851156149957609c825cfae7792303a355c7351d1703c468f16e3106d2836d9ad45327f10e31ac0445972738379dd93871ab47d2e73d312381e4ed234192bf33140132cff5e5e4178aa417d8a2c58639d17f7b9a713d3c4e7dbca49f61cf3fe72361e7a147434c0950dfb48c7dd31c952c57e88edf7723b0130f6e2d9c3ccc82e36676dda73ea46436c65ab0485ecd0b3cdca6139d84ffb8697dd2f859f4d212a946c5b12793444f10299e4d35d999aa37a6cd0d4dcae54186a13b68a797cec08eea6ac555b48dc5729665ef7cf51c8bdfa84ca08efae9c0c6e1dd82318747b3a2236a0c131c090ebee1d02e625431bea86feb7108ce50d7e2f65a46ffb80dc7438475bf3f1f9f97896c2c5fc412f2de1f17677ff81526b4a7ec69805be3e4d86d36510a39f63c66cd5de605f9f7f2078f7905b3220d41b8ec9baac0ad09645ff42fcd66d357bcb900f24c0de897194231bca5c7f5ede0ce8db48a165a410e3b92e0d75be568c5d7a0597e11aeb6e2a8f3d739c72dbc76241cc936f1f19f695394a0f65eb7cfaf04f1b120dbd78578071538af10e62a1fbf67ad09c57a6212bcddf73461036eb823ae50e0ad60ed55a7bdb12dca4119e7576824cdcdbcfdc1b5f8f382c91555fecbde8cb72e1021d1408ea998db95dc5d5e8c118c1e708af71745ae89daf670d9b471830c2298ed79e5b17704ceec5d256dc3f0a1a68475d0e232a03578bb9350887aecad10beac928f5d2442a6d79dc26426677b0aa4f899484b286cef5cdb0d4984631bd6ddf9fa66e405ad06aa500ba80d2b856eb462199392a5c8e5af5c7c178d2f622d585986d56b526ddcc0ee426fef062469ca45ac814dc1e61f0dbb6327f42fcc4229b6fba4b4e7463437618b883c1f6a5d9f59df33cfffc4ce963a78cc0086ef7fac614bb2eebc24766baf4dd167b537d2ca24c819a7c3d36824e71626f174655240fb6d81b5b8b6b2032833c458aa36ca4a65dcfd9fdd22c6a25647b5c1f6560d07ed866ac7e2a285dba1510cbbcd3c9d63469c769e1a3f89fee532da706e33f1ec466f718c48174b6f3ac4b0539f213aec98ad3c397e5b896fc766f406dc8009ae83f55abebd6ac42e61230874278bdd0a8fe453b112b849a8de79d8fe4e3f3512c83e9bc9c81347b30a257f00ec83245deae65384677fb6aee265c7a3614d1b75b293d24b3ca96bf6fb3e6b85b8b811ae6d260e84af494c9f87503e420954aea011ab238c9230187a4cdf46020287cdb7a9df33b8f9f7dd1cfe6c172915221bf6a6156a542face1b3b0840e8065501867f4db4bb5662ade8b4bbc337f638fa882b654b3332c3c7534dbbf66817340b6c721ecf2d6ef6a027236e5bc81c9bf74385ff1bce4a09c9e2139178944de8a60a85c740067679ea910c440b0c40da1e9aee24d07dabf02979580616b7aabdf6a1b95c073b53880faf2e634064b3601662285bcc1066b8a942e591c0b8ac5dcee71b7ce830f98a69f2691cffa12471077622d3d5eaa50b1ebc8128fe582b364515142e57219c9767ed6293326dfa6b53f104a83a376d52950cd7db319229ec2401360b197c4efadfbaaa8d2267cb51f0df8337ec00180f83486981a742901da1422906f6238c7d6c887fa8f4f26ff1002c5a7caf3f656ea75ce30745ed38dc35912774b520efab394654c3c99a9f96b29433705f0bc6834629d6697516e42d7cf6e7206ddc19db9462599dd24f3ecf24fef43c4f19a0cff8a63090094ad834ac89316985a50bf7c26a98c4707cc794e1b6773166460e72b05dfa866002ec26914c4ae25e765e41be1c00bb9f97afac1c4ac9adf304ac33ae1debfac863a15b4d767c008029d3dbd3c4100fea9d982fa8cf03c7b24674313abc134fe4f2c3290609cb39a3cf139f1e0c3334b39ee5573af528f75028f5ac0e5acbcdf4d0b52d4a515eef2fb6ef78c93045b7aa894291788cdf7a8d4ddc1fae892384a0d340fd37ebea94ee6f81740aa376593d4152e2d18e893b588f64b9eef13ae6ec3251404027166ab29d2603da8ef57328027781d567504f1e571874ac7304909baa7816423c335297aa91f8eab1edd1d44f32c62014c51f06f04850aa3a69fc022123db9df4851e024547f50ad9327bec6b869a6023395d942ad34b48807c2a35ff061a9cbc9818610477a8bc5deaa1671dd567f264a68956a67341ceed8900edee9a50a89daebbabf72d292e5ac47a0678ba8b113c37768959dc9d93437f08c66de86f1aa4ff40c50ccff2a577c2a6840821c82f45368f36df6c862016fea5014fb0c18e929a5371987426cb5e43dfffa7a90230f0a286de27fdd26650a9982f686ff23bbd6810d6ebad6394f10780d606bb46c5af413b96e0480af68624de3e04ec65d346099125d8f0230ffa0095b2cbb711ab116df14b67d33163862548b480ab911edc8f3a3be3e716983fcea71c660b3766f1083cb4edc59bacc6140f90d6f39242be1f4717941e6281d4275da336475d48e055bb6a027b5255f08e6be77ff968d72f40a152c571379d92e9ac6fa070ff310af6c638a5aaaaef1df0b554b440304f00b726a5ae2139d16301693d5d7fc6ba86773a54d720cb98b715943f141d2839fa9d51ca5f90c9891ea11a57eb508a1b2ce649e5d2b06e319ab60490960bb4062545c1e77a3c2963eedd0ae5a2744a005c0c41d075b599d4e6a1b326a60da515b5509acebfeb61e8dd099fab9bf292bf04685ccc7439ce215194ce1cbeb4b35d164e6a6b52808e1612df5712290ea1aaf9506cccd1387a6275d16589846dd3a745f7aebdec7682146fb848e8fa9750b5865ad0227b558e1759588a6626ea351c1c4268d21584ae43b3bea7cc759d99d2de60bae82635d84d7c1f2a3f472d7d371f9d29d007203aa6fb9e403aa03240ad90b9588ad54827e81179427d3526afb535caaed0524bac27780f7eb2fcd149d860eac80d5b59e9c69c3df39f8c346ef5fc6d5f6aabe275b862392dd888ed5be6b31cf9a78248764546b5e53d7dd12c67b2b03123e204af7256dbc14d276ba7c470386c2940d2b5ead2c1375b7521261a7dfc004960b357298ec75ba32957f07d30e2c9802641bb6672619570dd8d8c6d989c38628e3400f49377a447676ffd66672edde5639b041f056ab77865378ef993c42cd206f42193275d6daecb264842c7219517c4571bd3b9c65f4b98b3992efe8769604a365fab39e85ac4768b942a3709a7c0953dd1658c3635fd57c7ff24bbd475af46d10c8a629b11a765513b5ad50cbc9c7501da967dea3566d7abbd14fe04dd9a9871b5cc56ffbe5d2ec9f124c992ee7fb3f95974c0ec5fc68516ae12dad625f7aff49837f505b4535eb458d69f57a745e7fb947eaa4fd195fd5506210681e3c04e85991b2c102c8107d6bb34173a607a450eddffbde356536654605988d5b95993827ac5413216c498de03bd38ada1af001ec4298f4905d4ec3a647c85fdbe7eca39ed3930958a863fb78b0a9358537cd76ed113ce994992c6ddc186e4332913214c842b99f72e0b3da45b51baa7dd87dbbbd725cca1466c2cbd1864d716b3a32719e6973a66d2299c38f762c25fee0ae20ac6d85c9b4245e0c57a144a92c6c609db032d2dfc2662694782d22f4e7edf5f6b279314253b3adb1d4ca79e20c25df5c9231e72f9ede57e102079b714c01c010f7c82536c0fddabb1f94340f812e4ab100c1939089e28d2db04099d63bdb1e3b5c5d4c32cee3706500fd2522bae644ee784197310c5a88e06906bb4e347cb80db0a12e71c8bd661f38ec88a26647e46b10d925d3c502d2d8059fcf341e56ead93d16d0fb1007494f87010273d47de1a4ab0a9dcf74670ecfea0aaf1b2e6ac92253260a0f8e0bb1e7a618380f43c05b9a8190e5d7d9ecc8e24dea1db5115835aa3738b580aa5c732e585d828aecde496c64a8e6e2e15c0f802f9ef100e7864aa02f2749b787c7c28b4900fe5467f8716867d6d2db06c2f5796db1d43eea3f2637fcc9b12f0a81d4e5f798144f15d57e954c5101be1fb5905ebfc0d60814333b2deb8ce312aca3b8674554010800da2b71711fad81ad0d86eabde75d0b5889005b5800c60360a5dc04252989e90770e589ca5ba726f18de41869ce98379ed6646b5c1913927b1361050b06caaed3ae09f5dd8c55faf691d4fe328e2674569802bcf71699675a919b67c76f02c8bc356f9e02e371e8053f41cf422429513cf1f93dad800b08acb6595649bdfa7540860a01360757745c568e5c533f125e5f56ed7cd57aa8c8463868177f29ea3e6dad3d7d1f8bfd5125deeb4919df7d1cc69a19199e2e56b2bfd60a0fd13d1403952df4f16eb10a4a50e212a387bf3c3979f699455c6fb96800ecf7e54862df29242d2cb8ec4d03ce8ffa1432f29ab6698c104672502a8f7eca75c00798f53b2fea8cde4e7aac18d9ea1feb3991778e7501215e7f0ee0b1559f17716a20ae4ec94e2e5a31349867ac7dfb19ae29bceff1b12d969806010cf2824e16a06544c0e491f56698c3e34382da44d78b3d55bcb1fa38d7d0644751ceb478c024fad0108e4f0e932d8bf035bd408c70772603370d8bc755ff998651a3c2597c0e6acbb7d17f2331a79890337b63e2c1d42832fee26764d0d8ba85dc89c3be699f08f769405e7926fbbe02fa81f88c5b0df4c2bbeef159f8d9cb63127d4ecc2dff933792c8ba9462b21adb4064bfcf4afd25d6e9613ab86141ebebe5c6af4b0f6881ba1ac8cdad17aa249dbbeb46cad6f05e73b714747b05783836d56cb753492d51ea89aa912344094b84ff2e228b516b0e6c57b2137195ebccfe4e86baa11790c25bfa28b10a4136493d838552057967fb905e380693c90ecf49c0eb3d77087223aeb5d0a4caf5f09814c9f4fba0f6790d30fd13272f6ebba9f56c6f2ca715884cb786d17d58aef706009154d1afcdf6efe6f0c31f28d2eb3e767dd23f03d3f9b3df4d3a5cbf48d7b4a72f105768f97477af3e5cbb94d78fae6ea871fb4f5c9d576180e3f13bf6d246926c6d5ce77d8c29fac3a70001e5eb3ac312c7cb6ec82bbc2816da36dd809bafae860ca7a600f5dd03c67c255ec8454ad40cf40913c4cd4169c7cb79f78b8d5a19a0eff2979cf0746d6549ba6b38330d6e578af533653656c6e48ae6db597277fed0af0b069b3161f5ab5a4ede3d5358a59c4e122ab0ff7f8d11dac0184702ff5c8338b289ddea59179a5b1c527311c4af2d985925022c18202cf01873fe2306b6c7eb26ba73618167f79b555e3b2b666f278f30a3e6c1e6640c2ba39a8668b3dc9f8898c0400922ab3ad0f3a62747534b1aecb92dd71f86a8595afbf59977ef847b5aa1786f0d977d5712d09ca10eb500feff7e03ad3d944fd634e932171b3e1f9f93a20a9fd14e8beb7d30237fcb2376e3dcfbedb902ad5b5109e8f1ac05c6f74551ffe8e665abed8968b07b27084875fe5f19f4e8e2b62f7b66ce531309061117f4cc522f384526fa4be758c7cd8686e6c47bc566424bd26a548479f16a1d368235b9c9bc2f5ca01590f8873f775e0c21b59188004c15ee9fae0e7128a202136d4a0ae0474c442a91567ee01f32c4aa1b1bacd6a0bf4babfbbd4e7c988a7b8c17d04fc39e86ae86e752948b64b12e47a1443ffcd6fefa60e90d7004a7b76552f70c38891e47c7cf2f73633353f1c92113d5398bb9fee7033199646a2f02da1ad23e3a3463e415f1a20834a0e287df076ddf703aa973da43c1864922c1f4948bbc3ab44b62a02ace6fab025b17f2e8af71bf7a0279b3c990bf6cc001ce3f58fad1dfbee9da844481e0d0a69422d7e6326f209503ad61670591c9aabecaf1731129e6cda38ea511e9fb063ffc59ee821b8726790c4a65cc313484c3d07b81880917f261e5ecade5bebdc8c856e8fa00cc21a0589765e34c9ee83ddf6c64221c778204a1665d5ab2e58870f0239df7c7f55680fe98d480b307575f27c516e87ba9df57cd2013ba10ef04b931db5adbb3847f3ee510aa8ab1c3a95152096b37b051967cd080f58f8d5f71959c2e0d7bd043dae0065077ab0e1c9d359bd077ff56f5cdbcf9c002f97dede5e5168c9f1fd1663448073c50c00e682c633d4aca8f1c81f8ac9234cb2ebd4d816a683584c8fe979f20cfd03bfbb34803661176852ce0f9f12a3568b5d61d40071ab85c829c49280dd118936551e26710216d10c8c794f82c4fbc4e2e0f7f4abb4aa420f53be89f80828b1cf15ca5a255db91365ab03237d03666277cd45e0aedae6c786f03589e1984a5979532c5fdd8430fa5991d48fe0419dfe44424d29f76de5addc2a08fa51c893eb6002f1550d2721bd75c079c08d72093dc245796c3520c826717452b86b994490f0a6e790772e8415f8404e4a66d1a13ade60bc18c3d37ad2d540d003011ec68e71d544fc3674d5d9f67e1995f35c0dd98e79161c63e938e9eb2e4341b690aba39fdb379e69e0d48951c0f2bdbb61a0004e376a3a336699d3ac4178d6eda1e62849b03dfcd7aee8f777bdf4043fab27fc5a991e4e374bc566dc5401655d212f39ded878a100bef5440405499d5b9b949c34630de5f84bb7bdb557cdbf0c3aa76263eccf1995dad49316d55a15d32dad488d64b6209e0fa4a55706792bd32aff6323b871014b19658abec93fe202c3c1dc72c2c7363a8023942298f93413a1019256e96286bf59ed65859e80fe021a80a0caf50cfeb4bb468bddc90b862afdb05550c78766c4f7c8e42c7a5f3ac65bb3a438ae9e7f15bad8bd8399d6ca57ab99a45cedd712d2251e3ec8bc6fc1d5669ba654c7b1934f19c87233f9fa5ccaaaa268097a4f066c4508519a2c76e2fa298ffaa0e607ae56a38777a5e0947784206e114d186feda5a040d533633ea8071ed156e3c70f4d5e4bf06f8ad4b3228e76c76b64c504cf925ad8e4252fbbf32b16f0712c7d80b708d3a36f15c4505f028e75ad9e235fc4c9468f81bc5971065e78262876a4e9a8b2ba39fb7869dcf5106b4ccf002269771ad1f20f48ec2e698c41f83772776fb45cbbababbb9bd7b9a1ca9e019f80eab3e9513b6eca43fd81c33ca76a6cf14a31e5379165be89f52375c253942838ad7a3da777bc68de313879074308e81e54fa2c88b816f509d71117206943c2a8aee3437d69a6229f43d1be2a14b6377dda6b7a9995fc64502af390d7bbebc2564a631e807caf9e8d204f19bc7fd557f50ddac9f19efe4644995fb7cc94362f98a7637b18622d0fdd455eecf3d40bec0866ff951304e81d4d8461b669a63be6ed8b7666cda168a3306c41ab023e1e24107d8502922bc0ca899ea949e0bc58429c45cca6d17224dea05c25459ecc323847d733c1592ed8f57ccd24133086fa4d2b202e4e02633a1e2370b51c0a04c97d852d64de4017b309616be93a5423c16f7ec42bbd2d873b73efdf905482dd7bab2f31bc5d848cb72b5789d9562275360579232545dbf031498b67b1d9225466ffbdeba5eae9304f49dda6fa030e26503c179b0779077d5e358a8d782c7a8ed1d05736f418be5d03fb4aa6a738d51460ea492404138878691f50ae30af9ffe186974bb3b6628fb3721f48c850c9fe23d6188dd59ab3f7c1b47d9bb01a13de886f88b59d202fa017c76270ba2415b919b5322d9afcc3cc00f1f765f8697b5fefad778b6576fdb2c882f25c0b292bf3681f46dbb1c0259ca48db5578658311c1d60f46d4c5740343071eba09bd8776072ca5f0aa9646be59d0e0a416b26e3ed3e0153312a5401feb13de6df27f6fd4b1f048d1f834ce3d27dbb08867f1bee8cee268a0b32b3c6b3c7f6308e6a7331f78c76d40bbc332930bec110f7d426de6abaad7d39ed30711b5b95dcdefceb6f48b0ecfa5a7a7191f217c0a6c8ae3b0bbc63e318cf08d5d554caac9932dac0d5939850d65c47275582384f044c1b556371a40485c807f428b58595e83c2b9e0fd179809ad5e25ffa4828178df51a9ec9ed96facb43a2ef87ce4d11059bfde3eb72eaa0d500ee042a0d4c11e6d7d7780d03681e001a8c1ef3a190140922680dd6057ad658596cf430ac7cec5133b67a6f5ce94570a95f37a6418fb7d154786b558171a5aad8f1524f1a47153f32699006decf823777a3fb6f3aecfbb39010b6f9bf0c5a57e5c5f3f67a664e27ec0cba00af0d9744187c2d0c18855052800ad2b3d99fde60ab471705b7ed58a8f75c14efc00599d83b1e4bc031b8731b3034f5945d0a0b2e170f66ba0a9b62a6f63de72ce79e0b7051e0f6dc2c6861732b379b7b5f0d9eed709426212fe6051b8227b881e681955eea33b691cba02ce6ef38373233f18379a23adeb36f47ec821494150158c3fc70604a19694260c6745ba771c09362769af0663b8537e31a1ce86f879747b1f44374589d8b3f0a57b8fc69108a07923839c582b41c23361f5e2543ebffbfd935ed2197a1221dd7e83fd51fa5a677562333bac0ebf3a98af8cf53f15a149c39b2d19f0d677b5cd25e42c5be431373a63ba037d5d1df363bcdf697a189b094d73826601686627870f5ec1d3f85166468af6ab9e99bbe60c890a9976a1a626bd0b76055491e2cd29e77634680dc4b85f47ea601a4b3f9c84d4f06c311bab579a2fddd774048c67822aa0934c642d9cbc9fe7d1f4345214a9254d43c2d32e7d5ed8283561336c856ac44f190f132e72a7cd7f103c173d92b39fa218649d73251622d8268659d5481d882719a547fc11a43a0fdc5e1ac10492bc4d449398d4d7e6eb1c037cbe44940eef65f2a52a42a54a8535b8dd005f2cea4ff55a7ea03adacdedea56cacb01efa89d806c3decca404ba1d73e71bc1c9aa242c4df2d1d7951de41943eaffe91a056474a2c264597160ac61dc46aba750e671c780e08c9283ae3d5bd6ce39e64ca7b460e98ede6f2bdf3d26dc26fbfcf71f221e54f00724abc39202f379fc3c6fe6685348e580c5ce51ecbc0983a974c73ad496f4ab74218d1c7e589ebb16c4ef25ff3b7f66264b4658b015feb13467ff803fb659f75e53896814871bba5de89f01f2d3aecd7d0f76659d1f5742a3a03e4477246b71aa5c0f7ca07f60d1793513bed0c98c3dc344ed0819726f5535b797e3746e3d58748508a5cf36b7d0b5418eecef730f723e6b2b3f65af01bb49d24a07fb8151fe14263a23ee535d11f3a6a2d6fb3ed4013a5adbec5802a00a4b7a264424a6fe6816cf7ca6b3e43fac4ca70179ca815a8b6e084d22700b241df0d765f19edd5f264ed10373fede240c8ab7049f2010952122bd5d02bbcb1354edd7158011932278e92787e1597f9cfe8ff30e62107731b6ad07233d32ccd1801f0496584c772beca7f1cf2c10877e3e72faecdbd0bd2b86e09a9eab9d6eb0132aa69084484601f19ea11789155e777743028eb24433c53c1dbcfd4cb5c05ad157e290d00898cc65807df07cc0ee0d2b055f411aea3a095f12e6b23920d606ad31ad02023be29479d5b42d3b36ec5a5da5e0cbc30c73d666d6e17c598a3c8dfa4f41ef20cb37d84f24eee777a67cdac9d13d89ea3418de7075ed561c88fef33f38afd6210b5ad7702b52f8c87c2a9dc39e04524e8944734152630016677d81bc10ded2b51b95e98abdc747cb971a8a7d0f5d8812b372086aace0ec056e4f8d0c4ac31072e327e3fd0a065140930c8142b3dafd2afbb50cd149ab5f7c1e4a51122f5447774365aeb4ba4f1674b7655c19881446c66f2dcc381d14b4b2d87cb1bedb94d401eef511886b29b11d74a3ca571d48cdee1fba52088ec69956dcbb8a744305c471a29d4130b2e77b959c57d7df3c5260b222aaae10b74b5858e64d3f2fdf1cee777a0ee1a439668c1c126e2d589808473377f9f7ca0ab6b9feeb9b07f9b1020303213b3122ca50124fa2206f74dced1884f069ce0a4a896906725e06e6150c7df53928ae815ceef823dfb418bd4a0e2ad530f3d037a5569264dada065b27b448c037935057c3cf06fb53ddf8ed979884237adc220126a249cd8dfc3613fab8b88b6d09b9759b345c08d61bf72d50fe8947565eb47dbe25f7e27083bcb9540e9d77c7ce0e32643fcd0983ce55a9276f5883c538d3ceca14a49f5d31892a80a02cc18705a01bf039a1adc201bc620072b3dcbae514e2052b4978197aa0059f1017f64a0990854e4e2b7e37dd3c8171a98fa566a43d8ecc264743da5e386a0b02bc53e3733438eb505a6b088c9a6225c1e4c6f3c7ff5f25180c0ac68591d920f8e0eda12d49a3ea9a41a4e6987f529c29106204514656276cc43bd4604b687ab13c3a23fd5436428827db11a7030cbb286604ac65b4bb65d5c6c696e17960d21d2b7da5efc74a755ba8043583e202624ba4aff093fafdd3fad03df804daa0832e380ad36c4d164a33efa599556935f6d9793e2ccbf604835dbc18070b27179a6286e60f23ed61e3fcc23d2bfda7ea7e3e15b36155ca31da568584d9f57dacff76cce1033948547ae7fe6304a99dbc498d5392cdaa0de3f40afebc7d731a5163a648859d8debbeab916068cb1a11c4823298fa1d6a95c698ff96ef374f2319d645ffbacb86c261bbeeee6c3b4c209bd6cab1f1cddc60231ca1800a448cd5ab559d7afed7969da2ba19c0a8740863567fb2f45e67e87c537e91790419de5cf57b900b03e0d9a023e4cb4995559eb26d626793bf2cbe0e34afbdf788955fb3d60e106ba6e476a4ec39d700ae411c8136b9f6e59e59c46133a5c84413376da37c9d6511cbcbaa67ec71722ee827c3345436cec9166cbf18853284af89cebc9342091a4888c385bdec96cbd42d87db8fae6ae64146ba87b7bf0ce76e64eb5f625c3679bf372df6d6a7156e36710bf2b6cc161f04093610ab426eee3278cdd3be7e813dfc4a3fa7e66f6062c06828032a44b9433c4208f0973e78896e287afcd5b34a04571f14b6a68489d47b93a1dfe3f5e0497e07376967246f940b3294a00c6180e20e3b31b362dda2ed69c0dc811a3133d6a6f7259f033c97f07f7c2f05b5b65902e42f9ca5a083dba24754b74ccb5fc37d1ebd04d135be4d2437814e60ca21ee6f10bec6445e0bb009e2f0a1dc61a212830c0f0ef340665b13c0c7e0d51267644f4baf9e7db78b32fd703c1c36547d1245069db371e52e6cc44c4ff8963f7d9de4cd3631e904f9860fcbc9a8c155476d459938b651c5e8ca5dbef52f698bc38026035c9537edbb3d66a602e643bfbb0470ba0a98a73e6e7708e28389c84e4395ad743da78c81adc89942de10483f66849eb3b4af9af14a73bbb06d8eebafe904e285aaf589ee3f832a20b04f910511fa2f01999bb99f779d59ea66f72db6642e7941f89814d04f5034694d33bec578edac27a397add52b0dc542999da455278fe2fe39be23eb23124cd95baa3ff6502ba1eb0391036329d597a3e5978da3fb5223fdc7443f7962f9c3a6c7a875e008f2dd044e46ca8b5c643647099fdc01e9bce48488a240cf7a5fa3cc655434df8afa7a2692a78439575373bea9d6b921233082a588e54fc4479609d6f203b087235e1221be69b974bb1f3dcd521bbdc0a850b6e654fde43025d17746405e19933265fd1bc22b965de5ee61635c5142af1251f36502ff69a1b396ecbfdf3dfef81878c11e5c9150e0397f1c6ef61ec709e93e5bb3039249de0a83aa65f1b77318f8310caecdc7f94ff0cc61be2fe6a84ff831073f9ec129454a226d084952abcec1414e721320f34f196a930acb1c15d43fd04396bf922271901bcfebbdab8df86e5443ad03190fc198202d2c5a515c15d04d37b4e352c4e6db6c47d41e578bf91cca3ac8caae81562749578a7b8d7cffe249e4de7cf30544e74c4bd47cf87b76f8997f56595455da89bbc1192a038a89e4b3baba3eb5a88847155992427c8f76ae9e7c8b9d96117fc6d07af1188217e6275e758044466db07be7645cf1139e5cddd41e1cdd6532746dd3a58a92763da880cf97c18a1a5b5df966e72ff3447dbde2f264de8ff55dbedf3146274a2fc8d17db111fada74a7b7afece82b1d595c0b5fe346d8f1ed5446b5a61c3995de53bda46b3a282f859be490e4b11664fe35a7fd8dda51c8d794ff6714fe63459b8baea7aa6574d168b4af0bef45872f3a1dbc49aab0e52af5737e59a71e958c9ae063676451c5b1ea6eaaafb53da2e86d3e5a3c2c57e4e5839b5d1eabc9123a1453dd3c0db68daa0727996293d91b3e063a51ea12758ff6051fc7912eb926d38101b3b514078c935001a5ba317650fa96e59f264b5ba650006ed01fd8398cb60967ce58e551c76438a5ae1f6d70bad1e54def2ea8c654035b2d7b3b7bb6431564433bd0364889e185ab1cf102894793d1ee28803449aa9241e94361ae10303c43b3dd0e25b79c9fec3c98e54e6c3046e39d80951b25ab1b41f9c976aa9b0b700c705ddc8be5f3f4f99d8674a535fb56a43acc2734a2dcb69c248034afab52842047cb2ef701efa880f6f1f9f572f8bb793b68ccb16bde4a295ab062bf583b77425a2299cb0f39671ffbd986691a933a74a7037eb044558d660dbdc77557c2bf1c6c9986fc229769e093d2cb06b3b39c1d374781d5e3b71505ee0d021bc80b94ac62fcee83a3944a5cb71c6d3ec68ba006dd9cc546bcb9ab906c0c0235f9e3351e9649c364457d2226be21f99b5694a8ee5fed8c461e87a026c1ec736fb260b9500df5d12d5a234a45624025086ebe15dafe0dd7710dbe100722fe61b96ad3a2e69038b85c9d6d2fae8f3daade0a577c1a9a2829983c72d992aeb024c713e9a0d5a90957013f77e42bf7860a8d5155726abde8d41363c4b14965c11c9bc2d26469302a0ea09272764acc147b66b0d31dd73b16b713586b3dc6ecc1d3cc3dec3cba2772693d2c2c605a9daccf5ccf37c31bd4ea0ee5ca432d3c4a9f673d0391243b9728e831ecb901dbb86166d3ac85660fc314780a60e849c653619d3a9e954cb170f73b58472ed6","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
