<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"3233b94599d0907fa502d98650d39deea10876b47b41c0f7db6a0622f52a196444fd402d866cec969115134d6d6f12bc1a6518ce075c6c711fb0d81d371f18946701dac94cfcc57dcd8a6ac8a1fbb99b8563a504c559b4ea9028d852ed7dec48c0ce7dae4b994e1c38c2f45dc1f622fb04d9aa6e4e51df54d3d06128a1d7faf61e5a2efcfff4743656be6828ed29a5f88f429eb26b04dc910baae4efb5b553875f033445d6cb369fbd239e983e20bd4047e11630eeef196229eb95f0a120a0caf9d6840eadffb899c2d7753859a46c0051769ab2ce9616c81893a223f5bf8f88afa4730a46681ad48cdec55521018f7b8e30b5ac455316234ffbfd81e17d4cf315944e4e01a09193e14e7c8b8d11fa7d9aa9b520342fc57d8f32801a087aa766000244534d3fdc8d53328f291f4d14a4e378aa866ca91af8411c6bf06d25961626357fbfd32937dc736c0c86f9837ecd8b2bd81888c7183214233b5b1bbcec667c4907d46982b78be040aa14bd5fde264333d1fc0d846ce875887e41179881f9a44c9ef3989d3690b268584f59614a1a8c1c5033a13fc91444876fa8e0bb5634d4bd2480a32506bd17129aa0874dbcfbbc0fbafcd5ee7d0c4e4855b112e793351991e21ab117b7eb4f11ffdefae88ed77dc9613dff797924c83a634492569789dc362ede713ea85e12fbdb36701841a63f0d94f1fa8a77220594c5e6ae8b97ec0c7bf43e574ad469658004a13468a6bcefc0e65b3711d61d099893f8db6388f93885ae23a0f4ced4165453f5fce4164b1e463f80f4c112b6b12f9b8583ed46deaedcacda1b57855475bbd51c36b8b1a27b26fc7481e50c57ccf01e9bc8f22e4b345e88edf0343b1672022074da0ebbc0e9a19d96d45dc7e45a8634cb9373563d34b23c7913decc1982a45a1adaa14bddd8563e0ad098b16d953537e98160c2bf1b25f32b09f7f0313d94e8499649bda66e6d5f48c61addc149a2b6441894537dba272156c7f86dc3b1980486099079519acb0ba63a8be7d9112538ba0f3b611015e3f91935cc2348898d03db682df2d0a80efb44896f9947d5c1dd092ccfa8a2eab0ce24a78bb2a3f571fc780500390cdbc83e79ebb419c87bdca39841c8ed8bbb62c342aab42d8bfa84d0cc7b29788f687a399dab695767d9f111af1db324ac0446ef5e04166b060f1f691df08d9717bfd773cf5bdc85f6d23b7a62d6d6e57053822d8ac43b56b7f05eff1e89303b5380cb61c5695771aad008423ed53d3045ebd275318078cfc8804d6a3039e559e129838567cd5a7908bafb5612dfc937b4cca415a1592bf2078846ce8c50115ac8eeb67406955dbb17ff810b3fdbb337e3624ca68f86c683e91d942c45d53e4f061e8ef62843fafb5848ff3e7f341d24ade7928f507c6a6e34a7b55a4a1d1ece8b7c9bd567c04e67a1c12b9f38263e481d269edc5a7086957a166488c80a06286f9bbb66bf85e96889b8b624b4d490a34a90603bd032cf68db85f05d3ef97492eaa7ea0f47156a8fa0360b6312cc539e9f1d6a921a4b69b805ae673a2d7b06ace4ca4ec665b2f040f7aac5362479c944d7c8b156691e5cd843cb3346e0d56939e66537b9da9f5b32cb98d3dff69b61605297b01f490f497b34c6f09ecfc2fdf3ae3e4e2005394987d6597835bb9b130bef6f3116a6efd2b531218f4725f0b4d3d5fedb026e822169855d8f2cfc39b9a118899789ba930e96b267822686d5f34758d044dc05e8684c6175bcb57b30e9e6678ea7030c414ae43bfae9f1d48a359b93ddd9da760d0aac7e1c1d3d654b43c13ee4c00d8fb64b73bd5f541272edd99f619a0670c34a9dc28737c67098a292a0640fef8c410f6954bd4307ad46ccecf713cfcadf23686e327201d7fb0964bc2862212c0641715e3c5c0c71922e9875355569ca8effc71fa16cfe7d3e53107b5c1831058cead383000abfd552e7693af3bdf29544b1c70294fec1f6fd14448cbc7fa595c7ac9ff8d6841ea0f105f22503ed401ae240533a78fcec1031b715da34c6e5eb113c8e68d0f8a0a97e965510d48912674f6854e300e99fd5a0f838b4a1f28f1867754e9b5e88fea51e84916e3587764793b3f0d6d18d46cd3dd5465ebb6f8a4b6b7d54ab760abf14714c34aceab53ff199ecc7734d75c060274d5c7c0bd355829bed8596e923968c1817408633a0b7cff194d7e9af7e886715250c9d7a4e1bd48157dcd25068af80f2f7b59c780917f287ba8a9eff03528589092e3c355b10abf731bb2892b4bec497ad3d292afb3222640c1f26e0ab23a835fd29374ca381f950995012bbc62b7b50122e2edd7f86f2c0839357de7f41b7530708f66f6253aaa411ffb1c2b6f986fe1141304f0b7602d58de0e78a543fc1d947e6cb4ca4c42615616c733c39b2066c08bfe043d65592b4b8bc4c79254eb1430f5f27a65d767e2c795158068782b7d3063211714c6c43850bd200203b5d655ec8bab496f4ca38a83f686477991642afae9da051278b7a06230c9496b94d111d9270a8bbe062a5cd0e758081b41896ead372be554e19828d71aa685e5242109050bea71a181f491cf4c2b26e5d2bb9d14d419cf27479c0cc8391a5df2112a429a70781d4bb6176a80c207216bc52534768b6637a391a7aebb857166c5ecf19f76fad656b6aadcda0625ae5610bdfd6d3b66fa75ba7e51156886a0aac8b4de792852179ab2ce2123e08f42adc45bd1a4fa0d7b7af2eeacce25d641dd76c1f15369d26ac7dbd464e82d1ed5958e71b752c99fe86b98b1a421ea185549906dfa6a08b09abe24ed296b8963b09e4d22271439c6b6612ce44d781549be03d7de1b8b0a5db8b784361cc0217db7f9d1075e5b0ef3db031b2eee3c1316897140071e02b8a4f02c742e0e9eb254d5a36a659e15f42b312ac9c5a2fa84bd31eb0605eada3fbcf28b6485363fd1eb5f19b2c39bc3dff79c84ab6ca3b4373805576d43a5fe732295d0b7888e40d39584b2f38062ba0cd111af44b9f5a3bb0964826db609d649c7afc7abc8bef9ea4bdc2bffd7427245d3430e53a9e2142b35acaf2a13345f1b184f13f77f22c0fbd321bb2a016cac94531bd0f2b832abfa74a38ccef9cbafcd96cbc9abe7402bf215561629c80efa47c953dc4918f5388088a64261d99d3988695cabcbd2e3c20f139da035c5f16dacda4618c51c54104f12fbb91e7c82cae3038380eabbe2b7f2bebef26d0bef1226a79d95d7037174dd6dd20a402a553ac54ea5443c2ad907a2a45c18c99e1fb9dc82a4b12335bd5c17b5058fa08facd99fb985ec3fbb116d2af9ebd6201355d1c5f7c3e8b2daa80b5c1eb8f8f494993cab17a47654f8ca6ade072d6b62a94dcf1cb2c1f02e4368d05a331c0996891e2b5074d9874006edc28c942fa652882b0225e9146b59e318a723c7f05a0d8a94a2581a8113bc2c19a514680f27032db6748b8036d26a18aedc204e33faa9eacf1118dd3541eb6a453df26481c926068f2a912d20c792ccbcd421f670d6bad899978f6b83218d29b6a99a5d1a341a3274613b13d81955f8883af5e734e4fab078434366c80a8cc5c6963ddd74b141cdf584c9da711a68677212812624e6cc64415cac766611e79a076de072e6e9a877caebeb209a7b0719280d9ad99127e7fb4f6392fd097a05055ebbbd7326ebe05df0e2b9c3ef16b2da9b15fe1fd2544f48e8c69c7508c05ec4e4aab60c026cbea63ba1d82115f137f8dc2dcc0f8af65f6d93cf293c5210757caa242aa5c7f05621d1f6fcc8bef01a0f3e316d17e96b76f115f1507be39a3a628fc0470096c75015af25c26029dab8a92c8fbb865556f27b9659f5c5962bed837112b97fd534792feee2cc9c1967bab7d8706689c071b5bd5ff6e4f157a2079f8bff971f7d65fd6c329440a206be888ab8e29b27d70529c1c7762eb665b32623b7a74bf70f79d35726303b9e16eb3cf69fec602cc78dd166bf99fdbd00e911dc24ea5ae423d0f9ccd1c49e470cbbe15c4ad4dccfa8d53877a11e0bb7a64f32189145fb561f898aefccd2583aff0e0247b0e6377257b641ab9dcea566c2e96d94988ec4fbc63484a721c20c6457db250380370bc02556809bbfeea031f4007fef58175d7d5ff22905b1e75b53a2143808568d31c702795e84f0c89040315a8f3793eab8dfb719c49361f58bdb1142f8ffe39bbcb53bb682d3c1e6b6c0b362cf366bb619320826b8bffda612411ad2e838bbe01beb84ab69b7fbc616acb902eb62f3278f69a73309a198c1a9a5cb45c6f30d521d2bf5b88f28718c84d3ee7e058ceebbfb6e455532724d56e3a1b2362ca94e3d79cfbdf2367772ddc32423f0b429b15446121c1829a0a2fbcd58e49182da8b3482dcf32b213693f5b5ae884683432865b6b628227a2ed89de77ea4631cf28893bce68dc1dc6e2179ad3b8988187779e69d3f05c0aa95911d88d35f0d58baaef2122bb4eccea04d49809dd25ecf2df2f7cc7433df7d5e96b5d424f808ca6dcb21d3442b445cafa8726127117ec0336134df4e5c2aa40cbde29d3c3653ba486090173560324bdc60ec611cd0efd3a426840d39005107c0a6461d11f18ad33e3006f63c4cb41570c1cb0e95ae25ad0a2c53a2d705befb09aa34eeddef3b4556cf90afa8e4e6e3058fe8ef0ca81e68e98ca856be80821535873fc1a8be5ab2944c3119e652373cd8d10c49379af35d1c755d2df4cac74cad6d5e12a4d65e96e66eb7d3eb813bd3302f97f7020818aee53f78b720714327a27798e5da8cb927da11d632f7e95971b9d8cc69b7a13d3378bc77de82e9fdf4030e9c28f5a81a05637a620ee95e24bf542a13ad20e674b68bf76f2ec0b759930da69f42eccb8a481db2550fd8189aee3af3c0a04c3ced8e39e911edd06de189015010ffcb6c0c5b4bae648325b3d14e7d3363c475f5c975fe8b4c6fcc988c481d82c004ba2245ebec7774293c6be49c304565d0ce0321728f0e2adf051c5b9599dc69bec89b0d680c920680cd575fea7c215e1c2af71bea368530aa41884a223ffdd8229339fa6e87cccd1d3e4622742edcca8d4a9810e83653de22ce300370b108c87a8362a4b26ea7caeb0d4dec31fcfad495fa793fb912b63aa78e1acd3501188dfdd78107c01a8e84ac2afbcfbf60ae2b3725764bbe66d740cd874aee3dc4c86544579bf587b8f73c4ee7cda569dae5019aea7b050fe74275b5f3e50f4030fd87db3b2f4572766c2aba866bd4d8ea331fa539fe97396f681d7a0821b42f4e3ff70ce005ac294a60857858e07ed78ae1afecdec69766679f88b8ac56e7f4df7bb6095e9a4e6ae137068fc0e54c29f300fc289eb62500ae8adc6622fa9c76894dc00b5d0efce8c11a310f60f623247b0b28bfa23b39c659782788f4481d8e6e6f80a21627ed6a3e27460f37303195c767d025ceb4990add30f41cc9de6813914ebf785ba26ac8d405470a52c46c065d219faad1a17052f5477f1928a74687f71cd92c3918455de669ad759d34306012a4268c1df18593183518a5a8b4a75ea130e3cb20ef930909bf1c0311f6a3de8dc23cb43af2609e65a0c0d56f6b35aa70f91eb35eb5efe0e600640ddc4224416a74393753a2e77edf53a92c5cf01ff9dea74da68b9e95acad06a51de5d9c487d217d2c520ac071f22365187d103459fb3b4742171ca02d5617e6b7ce917a96c19d850bce12641b4ef2294f48f61254791af040824e0357adc0ff84a7abda5eec1db9d5dc6944f694c50e8b6412e0cb0c221dde9c31804a34a0acb4d8af1032e143b51c8a94118c7a192fd50d32777df0b386a036c7d37356faf684805a82e7298c2834781ffa311216d59ef4a7b4c4f6cd24bab53fef75d5431bcfe27d55d4c9640b308792e51fc037467bf4977ce3c658895524229dea7a19db5fabe49884022447a8a584b8819789a9ed0f1d2d0743e99540ae30f7db28490c34acb0e9ea13f3cd25f7b427c07f00b09b7f76ed9320079e6692a4780130ea7cdbd7a340d19f8b852cc913cc2170cb6b0b1e8410a32da6fefe94e7cbaaea478ee9723800794e3d5ea3903f96751b3a360b20b8709a8443894f987669df9911cb6c734375942ec173d04106ba991d7967ca219064745b0011167735e8e80b0ab9a4c7aa04221569a762c618b8526e543ad5569e73d7e35f61348087fd276af641dac42bdd8b98bb52b33c09cf2b3bc300db8610c9fa2c2c5a9710210b359060c64a7084630fa3c71e4edd53b15fe98fd720f6e1f84ed248c5686c4a7ea09aca7cde603b8227d168d397589988b25ea0ca5e8cb1f12b446e4552a381c76e01e661c02197a5a167bf87137b73f87a6f07e5817750752e99c7cb50eff7648caf055a0b82b562d2be7b833850c5db34ae93cff12bdc696335de307cf1a39bb4f533b5901d8315bfe35705a4bebc9f1f201a90056161f22cb11d3d1ed734a416696ec0ee8ae819600468218f81932e31c516edde90c2482143f1f89be462357c73597ea9c810d5fdfa1a922e95f49449508dbeaf52d6945e9e42ea0a15ab589cafffb73d874f6a792709b6642766953e57010c81cf9ff55c5f0f858be6487335a7f0497a0dafc61b490e89de67ea08bbf9c2d9b3f8079a5b430154c1062d28d3ef628f366b7aa714d245aad40c01a575839c885ec667f98c24470a5b58b8fc0cdeb52e22a9e274cad64bc437e9f77bd6843ebb3c7ace58160991694b9ef5835413c01ec9e5a4aa252303c557829c7a95680ec06e87a4fb77608f2fed3ba9341c95c3ca8a7ffa009e320775ff58714dd8326963070b46fb0dfc15743b9be0ca2451794da0ec6b8b9fbaa4a6593d4cb7e4d52eb2aef25b59fc3dfbfe63edebea3bdf3c3f2ad3fe6edbb3d7c2aba4f0170350e70f26cb4ace32ebd286c7cfe9f74e5eda7756444894c7ae84e2621caa4487607d310f3ab7d39d970a948e54852d5ffdc7b59faf7136da223c1f0d629d6a6b7653147ff01e31a5ba984b01abe249331e11f637add1a214d19552c6e5e7d81b319e402a2a94d6232ca0c63953a4c15892cf709764f11fea24ad922a8197ee15ea95daf05f1cc2ff358ebd38235d58120cb7ceeb1e16cc43f95e6b1b82aa36e2af32f304ed245467175089ff8c1d4cafeab061d1b059579d71b2f74387ee4dfcecb28d98741d354eb9717ccd7ec44c72ba488a19dee9df5e65d98a1f2039754c48c9604dff2b9989946690379d5ca08ebf969e6595eec6ff2a7fbdb68b5160a0d606da085e3a4722db32acc23e88e3bc86598ece405914d603e9829d4bd9df411a8134ccd03164569f3c00cc31d2ea3e63930b83361fe317aaed795dc50f6d59405a9f69b33157198f6496bae60392914c79ed5c9ef239bc2bdac65230d98724345aab1467292246703d9cdbe5eedcbfee68403685ad95ea7d2c29fc3ccca85c31e26c399bc1d9ab6a44c62f5491ccfe8bc9134a841e24b4a180dc15a13ecdad230ab6969a45f28082e4a8c47cdf76a49cf8c4e7ea70b91ce85a11ff80cf436d7ca6f75c57efb1cba10879f8b117db508dcd59eff07e6d27c1787f71ceb2157c5e5f27d8a0d9cb9a384f700919d5bae3fabce0450d6f1fafe958812bb90767eff1766f9664f97e69d60efc57a21271e19a2123bd596b08413607cee803b8fc941b29b7b3633b833c7767f71c288f73222d462fb48723a0e6a80df997417cfd74499e7c30a8de70e0e2274bbf872766bed510879d1efc7c34ed23cf8b8b117f1dc76878eaecacd8e149114cca5d3e140a9f71e4a27f42efffa90d6898b222ea48a946ef67d160da92d673600b605273901978d022009ca903be971f324f94ef8d768a7a1726f737a690951671e358a964c2edabd04f6d450509fc2dfe79e762e286b92223067426dbbd7842164c5922928f7abdcb341bfee843bd0e8da461d3196ad9d5fc96e314d932f388e28d0bd23b51d908648260568f25384d5bff4af4f1172cf0400949c0e91c5571c74e68f5c4eac294003376f2b262653f4c8f65b148b6d2b91a837e4a419b63c6936b0659aefa74a0b0a9d2686dc4fc7069ba339305c4ede1449afc9e7bd173a20f3e0904b56e1f85aa726a20d91e4ef17c34097f406f58ab15ea336de57c52c30477a323ca97ce69cda161f99f40d02783ebc8c4777834169ca32d45b6e2290d1f5238106d232c828d2b306be858f83bf52dddbe1f58868565975f3a124c09022c66f4795a1e4ebd7928c07876df36395e97e0778f2863e556c6fc3b6828b7f82aa6abf33bca091b6eb48c2789281d33755bfd7b275562458a0eb290c75de0ffadcc8d389ee67ff5c24e145212a256ea9a944691fa18e5d55a1fbc96913e0e9d4550bdd00019863ca0caefffe31efc755945cf31b3e7d29e37eeea79abee71dd0713a0254d52de26c25cc101c73ce0151fbafe5423c2cfc56a86b8d2d7a463f6f658266eb33a542f066eefcd999b0b0ff3d6d3fdcbbb09a951058f43201211984727027d375078fe978e9db47b6461510b11933b0c9a64e82794c83730f3a1b9924292948299527d1efc617d9e8a8e20255f7b7a37e78634c33fbc66b923b0d277eaca83c0067c583c9d45d2fd09da447134cf6c6465e1b8c831e22071ab3ed66dda35852c34e28aafa0f728275c7273790b59533a66f3effb8c90a2dbf78a8913343577aa5c9318450a1cbc7844204f8cd15b3ff604f4da4942962867de8f6cc0ccb9b85571d36a54aff4c6eddbd88e57a9a2806016d0ed6778f2e59cd476809d32c6a5c925f2d766e5bcb032beb11030249f5b856cee4691e24a201a2c3cea994781226fa1cd9591c1cbc6be7eec6d08347bba937a1523458d191965d325a896f47e4b09672ae36ba05c5ecc895f75ba7e370a4608e105c44fb6b9e5d29bc1236e147e26a2646ec10cd0c2d4f97268a54397b2768d8db38ebdf3f64048c312cba70dfcf47488feaeed381b35d12521520917c7a91dcb19bd2e849a1102a373155a0b57e9acebb3e940c516062703444cda856e2863edb9a607a1dc60820809e3bde65c1d7e6fa3644be94e95fd6f393e35237d6932acad02447b9c18ae26a5b7d45205281d54bd2c697b82a402206b4efb79c74e91083242062ca16f26e752a04032c20d4a17393962afba829ca117b63e98c4b343c9406fbdcbbfbc6db822eeb70edd5643ec46b23fa5b182049f594e96ad775393818844ad0550f9beac2b25bb297b0b9af88e40e722d727c3eb48db4d5525e3ffa6c7ede7c1da2e3a4d7012d5ecab996e345424bb039505eba233c0185aa251b4a967a335b0920fcb54da4f61b1dbc3e39656eb5b43bf4120dda1ea9c85ef8d89035fca5afffb6eb8ea55a6a9cd650074f275a8a0ec0abc34a30a4f357210291864075120e2213dbd1015f77e63f85a381a2aaead885f01d98dc9987318186a8dc11bc7690ec48e00f50be42f236ace5e2a5ada7dd9a75cdad2168923ddd19d589e4d9f23fc3506eaca2e4feeeecf7a276b8d1fc90deedb611f937a873acae20d9952049d4b2bbb55a497b5367ebcfc76f313630d8d7bf11d74fa6451aeece7d35fbda090ffb760bd66cd4f8b021614596f25649408c8198633cf78098aae3116e9d78dac77550ec15dd452b7f763148e968041f60a7cda8833cbdbd0dea1970fa9b1cc62bab2efb1e20e33e019c90cd106f61742f775621669ce8c31d005791801f81414cecfca4091197351808deb8da652f1cd9f5f28bbd53f4728b07e487a2316278b242cdc8f4cadd4b0f4144e16d86c64c1a928aca0229719af38095747f0206a8df1c931278d6311c87f540db81064ffe32b18528dd04fa43ad599645fd055d063f1eec2e947ce3394148d21fa461582fc1d7cb6c4d3ae3316c6995fea27d1a69752ac0535bd65b5af8d8c65dd0a1a92783bc71f3045a9443bdb83a14b569c66c17b9140417d42806645a6b6a1e15b3d7cec132bc62cf914be8ee575f1035b1aecdffcf4d8be049545c80d40254d5f69595130491d09ff12ccd406ab87685328f77edbe558fd4c1d22970c96f72dfad072860636c319eaa74e8317e64703aa257381cb179c050b6e57b06c7659b644146b66a7fc7c33e6106dfca5adc8e89be8c31b3d72d2dd38d13a280064659529d244e8980ef043275f579c75be00f6950cc9b023697539f935cc7f5e56d697a2ff8adc90a0bd6fde1230a0c681e62b9fec2659548b5b9402d4cfb0e0263f1a6f99c3d2fc2d59a5b186b1cb22001f91356f05d5a04082d310014016d8d84da19877ac981e8cc0f86e2ba0a213e5fab83688bebaef6ab7635c3ec1a7ec5e0d2d6ff7e49e4c1a0e3d37a0f435a2a7369990f68ad2556b03b4712089a677533b2d119a5dfd17ee5ed7200f61750ce2edafea9a2624e7567c336722ba64b9182dc46eb9da4c82ff171e5c22fe77428ab58cab61b40fbf169f301679895805503be52df172784bb472a5636927fea8f9a691cecf794349dac7306d646c101d788f51c208fa2c4416e40f441dd14e41c86ad96dea67e87795b6ece44295f858270c8be9d3cbb25f064c04bc564aefc0c6c5039840e72ad455a85ee25471f10993b8d8e3faaa90f77b22d63062232f2ea79582f391f6cc443e6628f51e78bab5c67239afe1746a2dcbbfb9a74252e83fc9e6fbc46111487d2a786890f04f1ba8a18ab4f0c0b9173e27e7a0cfbc3ac3cb7c5a5723009a72ee0c200c4e22f5a91929752db94a59ae4014d8f8a0fc58144997777ebd0f490c3d201f1effe79e5f459fa7b20c15ae1374a25b27568a0d23e15bd6486cf151da5f9fd23a53b88b29b25d5d8393472e30db668d49b1043bcd5d069ff45ddd01b1787927b94a8bd80e874bfab06fb2d797284af1441e941ad08dade4a36d4e64550ced237eee16e98def2bc99da2da6e79881f4222bc561d32f7456928076f38cb62359c60ce96c773545c4b2d0d76297b7a8f8bc5ddc210733d493da6aee84f990d5dcbacca28d49aaa00baff648ce2afe7c985a98afa9bc1a3aca5f8344b20434e739e5ed9d3c6d7f2e7e98130ece97b0099bd5dae759dd905617dda8b1092c76e0f614ea3052d8d291f17be4d077a3672520a650ae3b62074f2f1957a46a651a4fd0ced35002404b99d37e4d9189723c1cc2029f38db54886650954d0769ca5ae67b188d73b6de03f6cb9d7978b051c856b1320c29d60b45e4a4d3a80d3f0f6a10b7e6bda67364bffcdfe94b9d73c092dba9ab40021e51cda8b18589a84d4de9e8ab7ad733c4fdd30f310541c7645fc330bc3f44de72fc7596320450f9232a957925405ac7ba163f7048dd18c756e7dbfce929f2adae189e2bf60e21171fd389131a829f041e82975d43af9226e46ef826ef6f7ebd90aea15af92dc4c024b56cbd108b9f2abd960680d83475e522d1d8d339c46f7e1d8a2a7576ec644eb3eeaea95609f1af2514cef1b108770e012733b12d4232989029c518c36939d0bfde2cd98240d5cc125ce1e2cc2814b1dde7dc97708d2fbd8597d840ca174265230317c3df7ddc51591423c9c7a0100af860a2e5c61b3ed98cd6d25f21dd38d0bed848f01940c71bc50a46b49a7f74b3187edf7a3a398d0ddfeac7910ecb4ee4cb42c59b66bd8330deb1a5353530b825ad43697931d99bf3341ccd49c6cdd30ddc891e674675c3ee0b75ae00a23a7fb86baef2c20da958966c8793851b4e4cac0bf81dc998a6bc99a3b6baa1e0f287e646a9397298dc224b159a81f7f93d41f9f6ac7de3771eebc5d81f2b15e87766b847c16fdaa3eae5b1c983d7b9bedadc789014bf43db5b6539c3e68da828b58723c7b88471cdd8a799800d84a0320cd7207c0f85a12ceb358cb7d2bf9f65f9c61da3cec5602d4eb593826946c5cc7d1c327353944ad094b7ee799f5e0e961eccd3d93226813bfdaab778000751b31f0ec7f5d0d3a8110ae5bfeb6c75c4c55bf2cac99985d6f0fd2f0352793cb19ea41fba0b15b2d8ed4c195269e9dffd52d8a824b3e9fa217e63ada241d6a5e83ea11d244abba6a2a7e2a756931891544c557d505f14ca8c400d26a8b4475c83c6d83b3b7c654c924ab4661eeefb837b2c3dbb26133b3926940487f26b490115e6c654dd7686d291ed81074e0a4bd821e8919559d3e9b14be7ae350da6c49a80ec321d191ac7adf1b97b5f96f01a1283ff5e27db15d31aae6fd9175b0f687b8126f0971f86683ec8817d6d8e0c4f42d673a143f0dea49fcc8529f106917af8f91f7b7900a903008c21b79d44d602a1b8583cea82bd31c38aaa24d6d78c1131b5bcc82f20a85cf15bc1bf437813bdf389e3067ce787507d0903e79bda95deaf498058f690d548eb14d35bed51ad2b232e6675d2883dd33f7d49b9a88ab0b8c531e0d34bf0767cd4e41a87dd108d13cca2249c7e99fa6b21d967564b60cd6344f6ba57f26a656437932dc2af0b3189de499cef67a01b44068a21b521d964064bd2bcb222d8edefc1ec0dc758c8366584f7912fdb15f15c4f9a5c708ea62a9d627ed73d994221b67cb25bc6b401a0204bd5550c1ec99c803c6d94098abccefbf15bcf4a24951b2af55a183bc0a82d32244f51a8e742c70e341cdb43b23208c7b9b61d924bb1061e9df9161562e1b947e299adb2b7bb80178168effb2e336156ce70e13b18abd7b2f0afb207fa77980d1e3dff3425015830e43ab3f87ec2ab45062a9bf77b228a8516b7a09f3e890d995f926ed53d445f382e0b9b8588e2c10c3ed66865f02ecc3f350e2de99d05304100d3ccc89b292352c77598259d2a2932a60848985b71fcc757bf5121c07e3780bc98a888bc094b69725af7427bbf0d91b435ec5a468e56a45884b92184e9086abcee0c1b9ca038d2ef736554189418effbd45b178a506d6467ff1d9568e599b6064537fe5cc5b873c57f4a59e73022f73606b34b7d173cbebd6c669c0e75a6e7e71541bd2539a61c79b7d58e1645a7f5e44520cedf456f61c7d04d5432fe122393a255ea85bb56bccd060120954cb23b8369dc541dd8e8f2c1416ed8f6cfeb85c15b00f0c93e9abafc65d0d8e29888a46d5eddaed5d58de91d241841d1d640c285ad5ec1a0435c81f0585dad069d1ba7897e0304ec8373f06f663d42bfdb7e86e6f75f39b93dc35f27964833fb4cda0bfdfe1d2de277179ce86733664faeb78e360fc9df0e8fab7e6309c4d85738bfd0f3506824e16229b1bf8cdf5c64a427d98f1249b42ff86ef84355515997623c62a42455d30e7567fc2f5b442e7c403dd68090a4708cf0798e4adf9a7535759e6a742b8b5f9c6684f5538cc8f4552142952dbda3778e6fd83d68247ceca6f8d063d9fb4001c13159c0046e915a82a25934c354db3a328bd2200e96aa5c70a1dbdb5d73ad14d7b988a1a7d1da155726e24af347b0ec9816e3b706c0f263b6056c31c28aa7a9146c36ad4f6b023f8be6de13c23b1321f53b25bb662baf97249930802f9715c8424c9eef23446df984bcf843d6e2e7c140dc225cd70eaf9ce31ee24a36736bd6b3ce9a169f74c2bc7da9ba81367bb0d89be3f04248bd1a3f5b302a2d465d6026f1629c2bcea2a62740f6016fc50bc06e74fe0b83e339132747eeb9b42a713a8d8908e627cf99086e434512b877950df28a2069e40301cf288b91a84b73cecbac6433d5de46797395e059c88ff645025873d5f49eb29bbf4c5f815756cae4d6a80a0836c1945e5fb075892c85532c438ce02fef9cb386a501f6edd23aa390564003ee234a18d114e471367df382e0e41d815ae326e8a89cb0a212ffa2f5fb5fd1d9a01de096111d1b602491a6e6e5818125b6c183f4e8bd6234c18c0bd016ddd69f2ce6e28c78ddee4ab63e609c9a181316f787efb54a56c8791772fb4cfbc5b7123c5d26a068efa225437bdb51a25946c77bfc82c8969a07a5ca6ed9302b3ddb12f72f9cc0e99b0abf8fc9ba83b1ef7ad8d6adaae2e71522d6ea13a5eb0ad02575039f679bfcecc73fa83dd32ebf5237d1d1306d862bf363dedd3ec7a62520ae3891553bce5dbd1d490a9353cfaf3a064793e01897360e45055245a1dddd01a4d866661ea0d839542d2077748aba3692239ddff7341afb5d20eb8d80d778e9e3f69456c0e2edc0f357dc3ef0e32258cfbbff498210681ebb92422f5d76b9754eaf5dc3bed490970afaef3765cc2c1ff4562fdaac560dfc50d72b59e2cb35380ef08b6efe6b3dd36b2d8fd1b5ab85d2a621c930f0a4721c688dbb2277ffef575a539c9d9942bd07bffc3431e99019952dfc1f05223c0966ed8493a55e4c7c4f88f0e53b610e1bddb89c930d84954f7a07e011c627faa6fd40ad518eed05a2b5169917ecdbc0128c5e0afbfb51818acd84b181cf61d20e95d4d84b2278f85c0a1f66db5f64965e41a0c7ee29222119df8768cade982f19d0b858090d93af15bb0a1ab35e5381e73a6af458d0e4146fd69724b93cb6b895dfbf836bfb9631a2b48d75f0029ea21f2af990d29288a77d3c40cf4fba1ae331adf82123312318c0e7f8ab798045cc2f8cca5ed8e918ed9f8195eefba0170d78d8e9c664b879048466b0d5be719d23faf224e390e7b58a035401f302142f366092b93476f83494d0dd401495728c3f5874cb04d28b9bc314d3083637733e60721bb0c4845bb478a6ee49b888b55679bb6260b4cd948d5f39ac8debf665d4f94bfcba9698fdb1bf1c68d59f8663f877de368b09d42543256f037528ee90e63e2f9b7d2de44bb595627b874b33f33e3d7d292fea967b450f7882c9f52377af7e2dbce46c493382fe8b829a5c67651cb498c7fc873443e660ab7eafa08beb5832d1ae4ad45dd65a1c979d8ccec2b7440ddd79cd8a9657e3357cd9694f441d87067897acd6eb9fb6951f42df11138252ab3f91d5b879b79ac2952217c0ef7e97a74b3561d1d50b4f62f0c7792832202295eaeeb1b5dc4d6dd04ae47186f4c1917a399765b09d50eb9eca17a320e8f384fc9ee0464c7fd5334ef3448bd5f98a4866053a42440a1d12244a4d80ff44080d37659bb3ed1908e85db7eeff84a35ee6af2f9adf94c058dc2fbe4de7babbf5ced81f95d1588f6c9c1e633f89861e0902f2dcead7f8e7f249d7992ddf444c273247e62ad029414f610b3bb32f4626d0bb1dd4af79cd71109bdb11978e82511e8ff6cbbfc66a6a5272b83c82d9f16a7d1a20c109cf88310f302f90b5931a380d922808699964bfe16e9f6fdc9572e1ca7c54f04c8096602f70cbd0679aab52b217affae96f1be4e1b72968deff844d16265ccbfd1761b5ef6b3ec0e5acb584d291a53d96477bb84e5c42fc4ff368c1e0adcedfe33be0eeecf3cbff2ffa6694d4a6585d8248b87dc619995f13aaefbce9dfdd91c6580040facb51af71f34dc4b86e92875604c8ed5d030ee83ba1fec0cd249dc2a5fb0a1db5672a62633ed32ca48c4baad85888f7d5a8340824c0007fd9440130005213665e823da0bc60e37702ddab1f58ab2d277fe7485fc314b5de6cb5f95cc8fd8e021567f4484800713639c9f27b9d790e46886e9b4b97bb16428287e4fde6c7fb22d68b23022000994808ecb0ce10bfc6eeb387004b9c8fc42ad10a2bdf56e342c8e7c68f151b83665c9dfeffbe17125309ecbc38e20b2c4709cbcb108785e50b79d4a0f846014a174c4122acd1e0b2dcb355711f17ef6e372ce8187ba20e6e8638e381fcee3ecf07c84798aa5125bebac2c7c9b3719cdc310e8ba08f31c421c797c6da62331c74634d0dada298f2e84ca4734262b718e90753f697a83dbd9def4e42a1df98f218ea4e346f3c37c511305d85e564962b4988fd49aff1604aefb933a4bdd8cba4e9c1a6581c46776d08ba63222e324866e1c69ef6d6b80b3ee2f3afb54cf7823407e5f6ec96cd9b75ee16d0c16084f8e67b601d82ea4e8631f70a687b15e75829995520f18cd8860f927126432d22ee296914934e122d5d4baa769757386f7ec3211892d62d308781a3cb0a2accb9e51fba2426f54ed359d52ed6d7990957890a0610cf18b5c325de12d05120acac7b34f3ef7b69188ce397d68db8cb4041a5a1d03b1ca4808fc27b23d4df7263d43d8123a5204114a72ceb6284a13934c557ed10a80734f883c99a70679b735682ac8d33023a75bab970957b18a593ee93200b01c995f21ddf2a465e89a487ae5c61eff2264f4debf93a16d86d220fbd03e1f8bd61fe875d9499245ec1a48301adb59ef256bda39fd7c3144fd395557f2f3ad7eb28faa88d46afdaf0ae5157dc1cf9268c24341436d4a3766b39ab8271103f6d06a6be9c52bb3e60985ebcc7900d6d9059575c2610ef7986e3a276f3be466efb7ee3399f8d0d4fa3c5b5c939c65c69b185901156c1628e81ec7d0cd9c55fbbe4c8251f85b119c3c11d68fa318f9c75ba161b7e56995999b5df696ffda2a41cb2bc63ca619c11e5573c0bc8d73a2c94d1f643c260568787d6e130ec00f8674e2b54cbd461330907fb56657d476e706e45a72eb3d905812c7ce7abdaa165f603eb1bf167a8eac106cd2236f01cdf5ae1e48d0b1f99f49ca004065b53c8f4d2ff079a2c4f38aac893b58051cc89ebc0678c963bebf8735a5bfc757b78830f655c25e7ae30fbc3b81853725eef4a4ced42b07649625ac2b7076dbc684c9c1bb6b73f11b755d78af62030340db7d96d23c69a49d798449d6bca357bae03e951fe1d0af9a8148668d81dd6844bdbf5ed3f3ed7facb17477a2cdd1b956a62cdf3eb502d10920ce6d23f37bf263491ed10d4c75c65119b12e49756907cc2a6aecff922f012bae65b130c01a4ec72dd678e884ecb7018feb5f558d36eaed0dc284437ce993f567f2cbac55672e715f4be841ab9b049fc45bf49739595e6dcc109cff5374a0ddf3110026e4dcb17d8d1376b55c807a46e0b014a825fdaa02db7c22377fc2873bc16c84c3cc20719876ab624df714c08976cba5e1c5b6162be806ac4f875ee72acf9587162d3f8c05664a96f1c5979d4c12825d3858f595e3c84f3e5fe76d2aec0ec43cdafcc0488ba87b210d2b2bc85e577852491e998a86b4bebbfe6c50efb51bead032692cde04c543ee07a11bc4405d779888d2e3c02cc2f81b8caf0d961cbe7a19ed630aeba4513d437d7804e9f41169c71c94a0c215cd796c554bf76dc7538a0f3e4b79995c6a2692e880d0d02342f841d1489be800fbee0152b26f2489ece7181f7c847b1269eccab5319b8b9f1f3c4f688a57351f0c6c75eeda06529ef42b47ef11d3c08e2102eb90b80c61fa91790d2386281c78fea53a2d2eb61615b8588ae72cdd6e4349b634256705f0c71d60a69a51d0f0b4754e7551031444233f6fd2196ee088215849d5f7db918e570c6834ab98963802fa49b2c626904250c6380ad260a7a7292db55a4e4f64e33a1fd739d7eaf1fe52aa8d466614775dd5537ad520e490ddcda674b653ede25f25beccf7ada9c7ea61476694c297b8a11992cfaab810289c07826ba9f317f8ae1a7ca8cbb569d51d347d4013b4a7470a1f5558bcd3a61ef988d7076d565b273a88c4e5a86d443cb12082ac82b47c053a3d80e87168d5a81936bad19e3c24927e5b29e2a4382868bb2d77d234ccbd043c49a8f331edff2e8567af2b3ee41069ca3be7a5d78efa4839b861b56a5ef8e708b1b9f7b957c1ebbc46d1cb3c1ba574df3de06cb289305c274638eb5383304bae9cbd4bf7100ff342228e2e4a0ae96abf941fbc7aa9ad356d11bc16445bb34b73ac205ac4a3e7e5248212655921caad49b3725a87c5187e03cad075a8db45cfc38717f33180ae6b13a71b7d02e0c8a5b0ef19428c546230faa0a7a4170e43213c70407a9514d7ad3b51b1719d669d3ec7ba8ce49018f1cc5a6b40975ffae935a9a3b989686bd07e18570537551db829fb519be6320eb4e1a85458fc9faa23d27a553f795ff4a8c1eeae134b12cec0b21f0fb59faf7a0c5b08fbbb9e9310f0fb301aade25d3152f12556ebd3c68ca4a7b412b435613ea82eaa7da756787cd28b1763e333543fce170ae2fe7f1930fb3167ef02e17e6ebfdef06405a9d907f1cf99","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
