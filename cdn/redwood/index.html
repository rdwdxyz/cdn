<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ee1fc68d722305f357770887ac326153a71970bcbdfda7ccc5c41677a03ec5981c89880799ef2e127faece42157de9c2f387aee950c927d2defdbe50b9617807ed826010bcccece84beeff734feb04a1652a82a7b6aff2342cbf4b8b3a8e912af748977b9137bd63cd511e93cccf1df468de62a91c39bb9f737d40a0663db8482f6f004ba30eb08e2491e53a39e530334824b3d26c1156d6b404cabf0a15e170d15fbd868e19fcca565ccfc451fa69c0bfca1723d4e6f9db4f7516ca998606bc55b333f63d49d56945a1f6daa95a01ca30da5cdf06656282c4f04ae6b9f141d12a15b1730ecfb87ad5874d74da0d63100b3b5743910f01a5404da0caf1e8cb7951b83997550146463dd819431a9fc92659df36fcd2a6cd6a3bc6daa27f0bf8991e43342a7d198f9a430ed690ba5d8061ed0bd05c8308cfff625dbf5158ce7fbbde569cc163732bead8787391835eaee11af36437367a11a684892e7998a5930f9dcc109081b491076b0fdf60f9538bed536ed12bc5a0e6961362a2d669199014564071867f2db3e214ca0e175ce6f5df7cec69a9b840f28309b416337824431baf7c774844d1cc86f7b4989ae51851d9f7ee1349c45f526a3f716d6a08ca6fdaa11fbd02cf3d53fffce06ecb1496abc0a4e7aa1efeee454627efc90fddd2f1f4feb1843999ac0ceea4eb5d6e9fda996e5a026b49ba27558c9a53aa7605c3d04fa4ab32799b23b2d2c3c918af0495a305783d481ec960edb0b5e8663d144b1e4cafe185b92fde5188837e8332dd14e3127fef999fa304f1df0599c141a4bcc3172857c16005d8bc91442eff386ed95e1d7bb5f18674ac80b9aac6072ea7c3d91fe8f71f7916ff88806d8f921b2f1233fafd9628757760a794cf134231cc592d72006ba0bf6a14687a09c719eb7d98d9415ea0d5549a8e8e72606cc221af1113a71e5c419f1f2a89ea2a9b5cb46bd5f1047c5aeb9eff33e74e3c4574e60bd8020ba5a6016e15560ef7f685053c4e219c7347b287b00cb0853000a2e5d7225b8d2816222a44fdc7aadef8a3966042c80faedbaa2809d03ca811acc8a7fca58051e0dc480f6f25909cb58566b6b60ba8d05fbcc5aecbedaffa0c777dd26dc115edda574a5ffe7f288f7b46d08fe8f31b3fcd2ebe6ec0dbfa07486af680ef127243ba7ab9b7d785574bf077913366a36a1c686d72729617b156e65983d1355349adc2d1d3243d8e333c7ece41827012f1c405c86f12a65483d322295398f932cfb69617f4c1785ce804cfed49100dd2ddf67abbe12d097a09a05883d70d040d22f71e4511363f4c2e4247396c252eeda675c609c84787f92ef1f532adc13363b565cc6a7f071e3ed4b3c511008a97b4e67a19b2d082ca987a51c6e935dee2a42a1895970eed91717155143fec824806b48f7d56935179e3c0e5497a974653b5b086772bb0a432889b7bb1825daa5a3ea6c43de2a79c4d97953d58702cb8acd0444345dfbb66035a46c052a44d37c3e020681869d7be0e247126b6289c916b9388ef410d4ad26829892a9dd2b73601007ba6535459738a1f61bfcf7ffd4c5d159548e3b8b6f4dcb10feef3740a80ccc1bf38391c610b62a555d44be00de661d01a2a980bd75d4c7d2e535ed79f8b00ef3b94bfe1a878fe12e9da0e3d7af93073ed210fcf15eaf5d0770208b22c9234a78664a4d31208441ebc8a00530ecd6f7c1b45d8584d42228cf713822ef24a5b72ffb3bd97eeddfe377968a885e880f2d38e465238514350e61d9967a134d8b9a9a9baafa4e8d82811c4dc48905c202fd305c54b13770bb9f69f6255eb8d1bf5c00fd909e1ea09d7427ab7743c39df1a997edb6eb56ebf64d69175959f113b4f14df173340f6a01cbbcbd0a8737fd92845f4921b5bfb3374fe3619d55bbb6996ee43a9011d7a9f94bc411e2ebc91d9e7393674ad69ab78580eb55f214ba409397b070b7f0c9cbea757a060dd4893dd49a45d77aa68b3c2b3ac92ffe2ac063cb0f005cfd567735229639cdce5c04e5a9b6f5168bd003b6299f5e9fea6c5c3e622c51b27d3083d51b34e0389af413545eefec003ef4004926a34f71657d41b0903aa3d0e064b5cfca95aaa8d39f704afd8fd3538505754da6cb9cc928675e150dbffca5abdfb2169cf46c660309e358f3175bccfb5a96064a6ab4375de5e3f9e45e024fea5f046b2cacda702e8d340cc113a6c700ee8e067f5c0514ecb6cb6c1d6ccf436116bd8893c29a7a574ac14701e312e2607729832acffef06d317af8bf5a2ac413eeac22e1bf17e03d268fc7c7f9e4985cb2ca331ef58baf5195e18779d72c6cc0fabc0c706ba50566859ae646c099e12dabbe7dc26d6478636ef3921206d4fe21d881cd85f0b6f153aed7f20109021832162001ff9bab30d489d41cede8d1463435a734db94397c7e4dcf4cf641261f4452629eb67940d1deed9cab76d52b9b47a1dc5f2c8d0fc7859387b276992c5b204009ec434a13968da1b9baf222903aafd2c88259fe7c84a51d5311f49defeed1b59d46064f2ba753cfe83b6eb6f878ae90692c212b297a78b5e402567bba3c96d5fa1d925eac767fdd68f31b0e94ab0d65e3591cb8243d5e8db9752628dd2a34999b980ab3a17f0b2b24ecbba34433dd60127187f61002bc9662f10501cc386748f81f11ddcbbb0b68c12daf204e4ecd0cf5a7208360bda2cf07528ca9743f48a1f088e64b08ec575d660ddabd201446817e675595821977507640f46539e53d2d2daf6e3a5639e82e5997c73f2d5b0b9a4e2b45da95e8474ec9adc3b9ae61cb032e0311fe06cf8655d63a67d83bc813c92b7e6c0393693dfb70a7ba389cdd5830bcd78fdd2cc1992d01001fb89e00b4b360696c406e5b2a1b2dd88867f58da648649318fa7cb52cceb7332cc03ace18c1951045aee54fcb66ce692420d7310b9c703ab060321987d45b5320313120c382ceba70708bfd8c0bd69b20f02750e255c9975653f81509b85fc3a873effc81500e2b460841ca947d43ce7833f50f15c0185e087dc181099630e26aa7a1b7f2310a55af080e8c443cf2666eb1aed2def9bf3721a35edf0b16670bfaacfa3cf015042045cf82947cea345599a92103a2b962425e41f29ee451721a450a24834a3535790f006841955a4ad2dc2f967ba3f6c5697c0351cd2d010c75b88f16785bbb74c48ccde4f101c8aee85cfb8f06413ae7088a616f2d6cb860563188a00dcbea7c0f09c563a48d6468e067fc9feb40649079748b3b0ce6841726331f92ba4c7152ac590d516c3c0f47793d2827a11652454a9788948b8593f94c68f3f9634844e5727d65fd76b0dd86d4784dc146db22562f7588eb29aa8a12c93c338be3ee63dd5144451eae31c45957bd4cc7dc41bfd0959aadfcc874694b1c15b6d7bf9fbe621234f72652e4888b30fe72ca472b42792064a7727c243a8206fab760cd5cefa76578762a089ad49d9bad93a08b8ecb7c2bacd6e9da85c63776cbcde62a59e548111d722acb93ed01a49ca65696ff46a0faf333f0e8c05fcda4eab329757fbc45130f917458753e62a193c3edb08662b9b7896debddefd1d9b9defb0c9b6f916a947e793d99e5e149a961264a07fe942d51da0546cb15fd3828ec8c5d1ece435323042c55c179381bbd15c1482ed14edfce1f0ed71628f01389c8cdfb491dd4d12983abec0ca2f469dd32c0d543e8d6718d5f553eedb036e600c0ec718e99e7b29dd25189e22eb15b7e121739c86102066233aa1a5c3e44da360ce79c801fe8cb40be6b9681ca5e91752f215b35e82c88724b89dc2b3d59360cf40163571185bc4557ef157b0354c53a3a70765042a6897e88570013e3528f914d04b3feb5e0b7391350fed185abc1255c776eef8bd46841d905a6528ac373e23b30ecba19f478533b7023bf0e623dd4fcc1405e124831beff11fde559b4ff05ca83808a18c489bc7e8d8822fca6b871929a9351ec32e962cc2c54adec3aec5b30aa7108b1bc555b8889fd5fdd157d95b147f2c6bc22be2b5a894db32d779d71849fb6b88ac3384f3dadee90072356c478447a97355ee23a282e89d78450539f5e2d5fdeca0fe16f3776c6807c075cbb76223d33678a0adab8ded79f3264a9fc0ddcaa1f3d90a83b4da1efa8b6705d9754dc90ee40d680a3b46439da4f684825ed82ddd8f0c5704da132f9be52de1ef049de4f9db3aadb692e9192db5edb7dbb514d2a83f8f8593125a469e54bfd13f1fcaf10940c817619eeaf2732d222749393e1f0342518501dc27493f4f22fe7489ae0008f857d95b97f642a938b95099754732bb670d3ebee2471cbe47b9c240051f8551166f91630cf3e8f45ad690ad28a1842704c51260a79c6b89168f675f2bafdd3d97edda339bd5df51230121b45a36280b28e5f56c090a9581157f55e7365f392fdc1c229c9c89025411a61fb7458d7851491bdd6cbbcec4b388b502402717e8a306364fa62ecc131768e21022d3619e5fbe63ac8fa8acbb8f58bb3ffa1fde911f2f3f347625c34eeeb646f4bb8e499a8291121591053b4f02bce790dc29b4baed9f6fb3369607ebddf8ccb4a365b85d86a54bebbf590ca8fceb8f32c61f7dd3808f9654aeed94a89fa607bbdfe6521add4e14463f38f577d41e738540ff8d4cf84666e217a8701b93e489aef0b53315f6168960695de9653f5843093df837b05a29260971a14addf9bb1ce8eda3ad027918ffcfa07b5efc39b1e065dbc6ae65d7c6a0ad0f810ca039d175fb83e3a41664c9df64f341c557b4adaf7e54719d1f7c5f0d5b101c778d92db02aeb276614f5479aabb05c951716be1825da5f28b677cdaf63f6c479bf18fd08865c706c186a4c8c834d1241507c99d278117bd2e216dbe425c5617c60b72ebd074b5328ca4489a81dac1371c09ce2b1acd9305bbab78c99def3c440a8caf872f31b46bf25e3792b1ad94e799d97861d015df4b223f9cfda19a469d5de41f83412c691970c95b9d67cb503294f7c8cf37cf378f588c61681efb5b0c1a56a82163a52fadc8b08f128bbc2bccb25ae54a6d2c4b54c63388571b065384286093325d448fafc7cd4f5bbeff8d218fb53ad3bcda7c85161001e089b58f76331733794682f840cd05e01e2eb95631bbfa0991af2daf98dbae3dc614a35f972b600eb8c2631622a858e5dfc04f71ea51799cc32f13d3fc9e897a22acba1ceb7d4469550f81345c4fb8019cfd73e78bd80bb159c65d72e0b9c47529159d53a233693afd8dbc7c33d08ffdc3f02924c12e7f414de93f103114820882ddb9de894fec241a4a69be8a7869caf0ca8b1516a99ade6d35595965ce7459f1593b4b7f780153b3b2fd9437f010d2cdab9a21a5cb2234dccdf7d822024848d069560f2f2af16f295a581566a5eabb6a286a088ade1983d95e6f3b3b3e1ff6300827efd56f5092aa7009860d3b0099dc63517d3b112308f9f2c00cc8fef4b81942e1b21bb37ccd2bb1d27f3441bc3509a3670b202979da1bc72bed7a28e3d44302412b6ff054e5e9bf81ca1aa8f8cd7aa409bcbab2389ba25c751561e4d84c4e74f7d2bef9ae906fbea61a187f74b6e1abea48e7a853b7005df4a33f804202b17f8f4e1bede161e1f682e36cb398bf46f87957145cf4977072e4a7375f3d5b693a2d4fac0fd970df82bcdfd0b7659a3e38cc6012b8b4611aa8c1439e4e83f3d0312f63d608a4224511a689cf80840a9810062ec1900c2cd40ed6fe7e904108632afcd92c3c3697eeee7c4f3cdee83f1dbf69d185c149a3ae2dd682a4c6d19795a355c06f9135db778aea7bae1ed8d0aec72124c50ab472a01f8a2ee4d4de1804db774084d4ee186b2982585d326c57881ba65ca5a769bfdd6755ab83bb7460c102172a1dfe879e41b85d65eb7da178efc909d862ff93ee7c9201e39481eb236de7f4f2b8ba268751834ce912086eac7ee0edbd16e5e4238d268ef7ab74b1e4825dc5245c60981ebcdae87ba052a7c32d27e25428ca7aacd4b55e09ced950fe556814cef831f448eaa0c6bde66e9cb7b2e15504499bd20fc2e75b92da3da48bf40c3be3d31ad220a2e54d99db73388fa6fd77e07e42a68a11c08d4a7d82b21df979dd49147f3c5f64a82e84c270091afe41bf249fbe279b08365b40c125295359c8253060185b614f319c500ef115770e9db76b46f9a2237f4616715137e2b15a831a2e45bf23018d13d9251b7204030308f4add0b596bf7d8ea1066ebe4ac5c736120b06e31f75cb52e664fd0708abd3ae32304fd3f51a9cba50f802d291df21febf97513e95c5b75fb3b86d9901b9c103bde43d82d3e76364d58efea4687ab0dca9fe97482c0060c2364ecfffe7669f15783e1b75d5038f2e4368ef7f6f79b5e126461dbfdb185b2b34df0c1942431fe235a914e112214cc490b489325be19afe47213abaff497c9cfdbe0a18445a79a837e0befc6a31becc9cca3b704423aa4141bd4debbdad56caf7288efde8a5ddec9f80ba4f651aeda7ea045f2fec933e98770a92e43d787b275859a8ea582cad4e86617e0128dc1c953e1af363dfa5f3cdffa752269a3cacae45edb7bd03ef542582c83e8f2bedef8f2e63c3afb8c3407aed599784effdf528ff4f9940f01b01f98ba6e5095af61b832810889e163be366759a3335c06c8497093434488afc6f5bba9b6cefd2b3f17349a9eb0b7b2e541474ca0a78f97b1345c8974d7c2924a41f7be392c3491e373b68741dad37300f09ead87e0151e36160030a5d8db739a681e30bae8275ac7f21ca4ef2ea681d012aeb2e861791b1d4f737d4350445e6a6b2953a6a71fc2a1e0ecc3edb063b53e5950123c028b78eb7024168526ee2000082b9977de146f079546f7b48f41b8608f1d04d5fbf2fd159d05b988be0d75439e6e4ede3f86c663a87990a36aba158c22aaf49d6e2cf3ef55a20a1c7920714e305bd1f77c7698f0cbb114ec48805dda987de797eecf44fd0088b3ced8944d7d349054af479ec9f2c2cee70e60c40e5f5a1fa9ca8dea4df9676e96171c714a6b260321c79ea5e3f4d197956432b059da3ddbcacc65aaf4a4575a1125b0151735a77549ab64b3531ad4ccbc73a938538c2fefa39aab9ed9640b770343a2dc819e76566a5be26baa077eafc675d4da0a4da3a2f8733d5c962f76ed9dc7ef8a4cfe8d55b542e5840c4b057277c2fe5db9020b990437fbe2e13e8c23d4dc7f7c79890109d7d7958aa46720f791d2067bf5cf236216097df02c182f8ffb387a18f89035b80ecff2199ce08b3dc935f5d0192cd13ece80a72e5025a4f003e3c34bf82b29f8de13af6b610162b4b83e730d034b2d56425c7b3368560167a7f713708af288f450b39368b9adccf656cf00e45e57436d92872119802d8f176de45e9343fe0c2758a7748d845381136345c4e615ac399ba7a9d485a8c07ae2e53a7493a960b7ffae481e52fd49842af3bd1a9a293a78d01255931b424f08966b773222df293904e988bea75f26685bf94d2585afd1a83fa07f8c5b9de509fd134e1e8bf1f278e864d532178b073f4601a1c862ddd0678244cdb2a59365ae101f02cf11b277bc1462d80f17c24c8e45931702d5026d5791fd6ed02f7aec11bfd65f26cf5640bfe5184badc3b0b0361ae14ca614bbf20b9c1e9c98d13d7c33ba60420ce9bdaee12f45c1ae30651f6a8e882466e6b3b8707a83b05909c45e852a936615f5f39e6254ed92f5d9f6384f31f69c0720cf4851768bf6797435191fbad327b0ea87aee7dc9493b44135044ead732a2eeef3d636d611674fe5efe69a0124c5f93bdcca3a595759c2034f97e80ac390fd7893c502084eb2bd9572e575f205f584e4971e0220370d1c781c0ee899d9f1f06c5e2d77403dbd08f6123f57dd3e4c624b7a0adae6eef5a4a389870dcd2be86aedf01efdb1b76c1e3e4ef1d2405d4613ac010b1045ae993251d3e24ec66196744e195ded6441c0bdae39ff58dc8d3979ed69853fd86cd5cedffd29d4dd102e415134ac0c2d70689a047b8ba7e27197d1b6f783f9786a3d8cc6b18fb7f6fe29ba6da5e1870944e87cb8eda3d225352a5c9b8b674641531a46ae24a1d5dce58e4ca214aaeacc874fbbd35c032c835072215821160fb5dd0b515daa630c9721263df7b99e8f7a2e27b25a0940427a9249631ebfa83f5e74e7c5585b26781b9015a2ea9b47751605b190e3cef3149fbe8ef806f7ee2c91732093d5ebba3141a8a992fb0d7da1a0c2c46a2a9871020b0d87e4f8c658bedb301c82bc55686e8eb422e5eb17f21f65ddd7d63513bd495122b0d04049b751545413c7ccc38ab7f2eebec4785fef4547f3266d7c66a6b6b63418b468ece4be471e00cb61a30ce19a4573c844a03a0e45d76a6063f2bda64029cf0d8f4f4eb24f70c12d703bea4a8ce860bc48e45d72b849b22cc356fbd609cd91558883c43a9a5eec88336036ac6bc392238f06a8ebf1b9d1f1d32863efe0e23888e1bac33ca71ed54d31b2472bb5b93359b86065caa62aed908d679c36008fa1d331c295cb6aadfc84e1f4c216ca473dcdb95800fcec735ffe385d4d18ad1de0f2630c4dd0e5d869164fbf4f2da70b8076365eb39250e77edbb566b90715bf391f4c547fb061de1f5bf06fb4d838635bca84c0dfedb9ab75839b8ce139f33c4c162d081e4fcb07941fb461740282c25b7cb0f9f5ab13098a258086f843da18241faab72d1d9880d8099b45920538955abf2d9c39a29402946f19f8b0babbbe9f9e3de0403caf034600a1659357c6446a5afffd66215477bde1980f832e77a23ffa9b707ddf872ba5babe7c6aa94f843936961f8dcd926156c120522ada866c6cf37fd8c516acad560f0b89a1276b83e308f7fcea286c758c6549a391d0c47b2cd2a3c7ca84cd7c21431bcc9a97fcc5e498a7c74605427884eeefd92e6f26767f8b83364dfa39db51fe86bd5ded6b23340b8a35824e698af0885098ba79fae05c64599ef5d69916c08d0320df59a4ec0a9e60ccc03dc5cf53e6b2c43e2321854218df187f9e36f24f008e13949c38ef70b85c3ad9e5c22fba583d9d37719fde6d1eb57182ebfdde13735d18c824ecfa00bd7b11fa4c6ad2509a8a9ca44efa60065729014c6a36ea4ff46b522278d196a9f52196c1db217e7494d2d22ec15b7bfdde85cda744dafe3bc0e35e9bdf198bbee779b61b3a0961803f7fe6c623ac48d5095173a613a527d97068f7317702267d669ee2113709ef582d165de5201057985f7807ecbe57948575ea3bb22463f529eda00d89b2fd0fe340ebad408fb224b03a046ceae2145fa01a44eee5a36f4eb9e699bf7f90c470a225b51c9998424411dc4f60f59e34e0d89f029b5935f362c7cfdda3320f20bd7db88e945cfea08277d8f071df3a22f2cb02c43a0e16510c3575c51146b6b0d475bb08425ee8759cc808db89b05dd2755cf0241cd943c324bc2e64e9415946e4043aa469d45effebd86e930d75d75b83ac5792b5b5a833c34c32133140afd54b789d4ea1cd83e201ea2d551e326406be388c5861fc2c6bbb2fc77a926583c5788d003461cb82ffc0c7cbcd708fbc31a3f93e104472c81e6260c75221ace7d99000fe840cc7be666f51345da9b0f104797271056ffb9f6de7703813d7370f935e4cf723acd814d86625a8048e643d053f224c268c2da97b11b1c1540b806ef4a7d7344eeacd72b9737078df1df7297828142ba4b305e309202b5a41bde94cbbefe3107439da8f7f0c8dde781328860e930d470c0e43baef66ec45bdcf8464f7bba63c3205e1fb47b06a46a252a621a76ccec240f0a545b7c4a4c79689f3794f825dcd9f476df23165988116368b684fba3b4d8620962ced4a0baeee03b4f776d9aa5a9add7576cb1818d8c5b10eff0241e9823ad5112b3b558c8691cb6324980f63ac58fa4861a154b3a7dd1a2b15201481c667a0916df010e7ca9c94d80c92d90841fd74ec6414f25dfaf2df4f3b9b2cba994225445b274e2d88100ab377e681f0e856dacaea8169bcebeeef289bfc454857101bfadf214c073ebb4e44c1d8ff6b0c8f01c3164078bcd83df66caf8ba8ac055fd6c0318d8798b980384f8c3862d32202358885ddf40390c17539a532d96cdeba3bfecacc8b4a07e4b5c0d905696d47e0563bcf5e5330643b3e1488cbb2085632fe097d043396b81a6e136e3f2abc39e22f19ebd791cd059bbb378a460a4881f654f349705edf05aa2fd7bae81013c312b5850a0cae612074b106c26d3bf404ea7e020817c7d09545e03085670476da4c7c41f5322de439be5ec8ac4e05b91a877d886d221c387b1f30376a020a0d6bf76ffe54b9e103c8363fef536bedfb24e5d1aba6aeb11dfb620081b266f638d78bc6ccac8366df54a3fce6b0c6c3d5f5307c4f3d4f746098fd2f30874262c37a4039ee919429104afd56d5223ab2accc8337b965c06476c28ea06fa86b316e16bf44adf454017e5b3cefd68b24b1abbc7b589ef23d28835d460603de82cbb908aaa657bb4d6570c595320b154a02495f3e21079d1fcbfc62657c187b9ab368327524aff466a96dd500ed857c71db1eff64f6118c0ead2417be7ead90f8f625609c63bc3769fab94e04dc33e7309f74160b52b80732468889045f670aec2287cb32d0f5f74663056f436153f1542edbd529dc8c9021e9262d06603c0241a35b65467e8078e07d79689b9eba65b9fca6167ec9565c78d09106398398f9adf140a781356e3d596a6ed70028504eb3dabfe34bbb248f5f0cb7e00bc69a6085b60473ced339403813c5a03d967c6b5de80f60e5773f0e953109ca9ab5a50496240e45c891157f68f67172e06b2b1bd5283626e31227a356820fbf880ab9724f5fba638553be1e2070ef435b2ed57ac8cbc9811755df730d8c172524dc57ee32c209f87784bd91f2f9357ee40c93a279b828ad51aaf384ac196d5fc5d8e6949ea583187296e575053fbe9cb32a5ae54ac95057359f9b874ee176b67b8cc40f2e1c634c2ac65718a56c0f1d617dae5234a6ca53154633f42a9dad5e295b377c0e778e398e7ca1b9a1406f9777fc789d80f5ad56206337edf9697e39cdf4c3a4459a9a07b742e43475095871d59fc9811cefcb357b916d2f05b0a3bb83f501c82c14d6ed30bddca871bf1160a9c1395177e08daa2cea5b77186b2053223ab3b8ac6dde3c21da1a6e8256528ae5c9e6892e2e1dd32b20186d728d6aa7886e21044ce7b25b8a8f192ab74bb3da2ad96f44bcfbd8d939ffd5c447f0319fade3d146890fd14aa181a8a586f697f1ebe17022a4174b0bf4ddb349b7e5c3434038080c9e9906ba3e9a3184d089033c349a3f688f01ae174d72be51021d7ee77e07fe02a66973734fc64e53bf39fa2e9b152fc2639ad80a8cee58544b60459e72ff763fa237b566bcebda7900713c3881703950bc4767e54e9eb3b8e45d97f0f1345e07a6f808ed6d0a737dbf50539048087db094a74da67a7bf6d7eb8cd9d065dd502b4ab544438920d3988cd1fffb0b3aa65c48f09b701d00567fccd626b5325a0bd200b7bab3dad71e13371d84a97becba07cdb0c0f11bca1f48817f1c047a1feaf8e6675a9d05f986c178bd9ebea9fef1811a6a1705f5861c1bb2e01ae022452546d508ecbf3a4722959aebac24f621676668f514952ea57093e0970fa3492d5ebc437b2763cea6cac9e9a3e948279a02d7322c350978c9ec982efea71e8bbfc500bd5dfb5ccda7bfe6a211af2621e4e3fd022fb7aee01a5265cea8d295bd3c370dd895f71db02c9c8b7935177e108abfa3b479a1cef57a7cad516a9a2e82ac42d2837f597e07bf67995163e0df45c2a63ae8cea8431630bd977c098ccb5d5e5599b59f11d4c03938cedb75319397ab430e35a2056d8907261a92af79600f3cff3b2fad6968787d7de97d2bdf29a74e7c42199c2cd19c56c443a5c449a1cdf7ddcc22d728e3a9807b2b95f17645e6c1862eeb9060472c4d71257fe06f94866920048c45ab5e8090bd1a36feaa184bb75ae7037d6a2e356cd7a4fdd8b7c646a454c95f82bc1c9e844a383d208999fd15d653112bcb34daf227ccc10163d1ccfa326ae4ad203349d51a1ff8df9c5d2fe88298ec54bcadcc8063ff48314b1618e01fabb8044c3ad37a6e6cdb5f63f35e2e071c1727cb71383d69e7b80962037f6d2b0b9ad036d44228b830f8964e2fcd5621cdc90e0170425f32bc1abcbaf89c7411d2723e8c6690c3ba747ebf2006b3ee44553c12c72fbe982ac2a633b5a276b1608f360ba54d6a20c8b9f6710de0e23d2bf64413f398e46f19e16657932426ec62876ee2f5b49ab50bdc18fd653e8bf015681a29bb97d04d29a2c6f747a37dd6f9ec35d94b76af3a5961754c92a6081066d9caae9be6cf5f5798fad473ad1d2be805c27012c4a1a26e2effc9bb738ad2230400a0d8c9de808a4dbf16beccfe5f29627c2aa54f632ab73e33ddfee358c47ee2b45c1d676c205f0adc7b632549b5b25ad171c07a903760bd56bf2b579c3bbc62f33dc60dc4e71dba77a81cc4e3a9da8f4dd5225adddffcb3fdfac5c899c3f057a525202c2ea734fe9594fd87f0e795d255b9a9a1d04b17fe530ff616a936bd872f1fb814d8bf7c96d1219b3142ca5978617073fb6dcca0742a56fc64a6e9b7101c19792e1fa189f89be73385648f7aa7dcae357fa983ce4b37dd4d714ddbffe52e1b3abec942e6e6ffed1e8abc424215955e310cb284c082de35d3da6df854ad224d7b4a233e885b9a850084b62e66e9f74903530247045d3c8124b355d6cc8e00ed1717b2c9e63086e29537b875e7f922e11a26c13ed35e93fb59feb3fecdfe306946bc7042717b26feff92486f64f11ce4732167198308c8de67e5e0b3e8bb29130f96f54687175f0ed00f0adedc40d46d202355c4397deb2617f040fdd379e316d4f29e3839258de67e48ec3c33f1edfa59d294fc519b77c446d8f4643a72ee4e7f3eb1f3a7c7b2cda6cbfc66078d8b372571649a21eeb2fe517d832b0f35938f56a4226fdb2bcac716a6286f9aa8b0e101dc55d73a2fb87fe6e85449bf47bf5add4631d8d421bfe9b96a6e8dfa84276d570250a5d35f500ef11e3bf9555cfaaee666c236cd8ff9d09763eb11b92895d832f9ceb76323e385c38055f9a0b13a80b9ae985d8debb901ee456e5ebed257b30602a3f31b073e65d6ea6d3b74c889990c5ba16a039d14c22ac20b2f503434f6ae21dd365f268c5d43f3cf2d23bc0d40bf77b6c96c117c4fe0127d1964eb7e7eeef814706a6b84e40358531641a5a20b3fad63ee66128adeac8b6527e74ea2c2f1bffa8eb5f6e64b1347e239f3020ceb0d2ee60c32d62c14c3333153e3c5a62f270639d11a2acca4a3ffabf759f189e5ff205d384ac88f3f4fd393b487363c5e14befb6c6306b22969a176720c7c64278340fd75b6481f4d534a61d711ec37ba82524beae475dbe2e3602295ec1fe278f3833a95c12054adc74b34eb3a4937b814d819afb2de15fb64e6318f209b013755b3f2e3357b8421ab57c227b56160dfc7c12d986d9b0e0d1e7b893996dd56c1cfa487261c6919d5975bad60a3aa8b55b944fc30d98243d1e95bbede9e58a60642136e37cb812089318a63a7586496b3e72799c68681164545fc6e559535aa36c74827fd44ffe0d516536f74256fd5047ff9633f0b51d1d69525a8bb34c6da038b0763958c6e256a7d6cc84d9052ef9a6ef26cabfbad679eb5803d1109c186297c3f87a9d0e346137d57bce05fb0bd676223b4a0f10bfbf0743206ff257f5f7787caba29421b83bb7be462148f83d20637207d038010d014bf3f66b15ac64a9e9be65f7c813be34e028882316b46a995b575aa83ae1bcfee98210280e812ac7ee2702b86d7751c628c510bf3a2d8ce053cbe8a71ab7b56e98a2e37f7cbe141ab37fb6a1465712cf47d49ea1e9f8ab6953c1e51d775f83be3ac4aac8f07d45e89bcfb4954f8cd1a2d713f4cbe0db86da0c43af044b303c005f05aba3858aa2db76ac6c1d6cc8d0f813d67257bf7694bb9c4ac9bb76d3ea56635c76dcd1276084c832e96a2a370911a80af30f0f1e45a7cfec3d8de8cb29fd3dfa0bfc41e3d71315194cf94a312633243727aafbf80eebfde78ec59a3a482f9abb04e9812002d5d5c6c4a4ac7cd00b896d3229cf28f8bfcc49875a9b5bc5c0588ec93b106133fabdf9354264394fb8cb0dcd59a40ef245e4bea7e11ba4b903c9650c5e2aacf7dc2902b49075e7c26a0093f706f9babb274fb85d2eca680cc290f61243ba83c55240ffdc261858bc9472013f3d5741064c696577582d7b0fd17051aa01ae0825fd7dea3ce2e0df8d790528264d07aff3d61660536fe38f7b39bda0d6f3230571bc2ea24fb5911a449e6dfa7a260e81b5e225c59573e4ea2187ee70d459d6b1fa396162ae1eaf09ac512b5d7d16f0ff089130e5f7401bcbaadfdf52ceeb46d818c381fb937c502e760864da6a11e2ec1efbac4ff0d84519dc5907fd348c1081efce034c69b32dfc8885068cb6c25c5ecc8583f9defc2a1db4b0dbab5636e546d620304cd245eaa151e9c53bd63c3dc745f13c5dfea5dc5d7ee7f0296b8c762e22d85a38ae07e6b74d9ed68fd219df114db00f4a75e22891a8a959dc46773dd34961b040663f6625bcb64082a4d5bed1fae0829bb573b874cc1aee82bf4164aac46e08192e9d1d1a2a32b91d2a320088d7a8caf96e0b76a1a1d52fe9c01fbe411bdf86c4814551a2652df64753c6e2c9e034de387a545cc0a18ea73f4784fd846ff7c9ef290ae5d4edafd06f99dce8546a7b89fa8ca71cf40d42a9cd588ac0387cd5c147723efb812f5960e63d7479af47a40ff05a8bb3231fc100cf68e2018015c1c5e0f2b46ca075d9d086578401e2a3fa69dc7abb2029210acb97cb8d5149fb6c3808f74b4d6985274d0c051a24ef0d8a5c29d879acf108012935f1bd08dee374101411c819c0b358e68bc5ad4f6d34be16586ef5020cdebe71131d849895f2db175c5e7fb6fe5e35242193816d5d49222b556676847c19ac422beb2a25b3407f3a7f7d857ae156b2c9d06cb4eb5e359a0a6bf2878ef66e37006d8c3f839ffd33ba1eccbe1243c11a3e0daaf5b6562cfb8b8f48e9e7f77169f784ce0881e5c3657898fd12946f61b992175e5a5d801b0721feae3fa86e3033b4cbb08c5b752c706d8aedd11253c23f9bdb78ad9e0e08ed0dcb38a48e5d5a26ba8d8d7a5d6acdcfc309bab5386cf2df097e089d173037c9e23b94619d6a681ffac359e427813d864720708e6ed8d5bc98ad670b3f997203ab8c7efd6ebbb06aa60f6653e86e940846ad70f1a76f5cf6d67ce007525891f817d7fc674b503871c34b1298008c4a5b758d15aaab470cc7607dbb24698df9ef06e53cfa2504d30053b00faacb1fa72ac473065692965dad8e673ba55e608abc887fa71b88ca21acdb63cd20db27f98ae370ff3ac378a3062f55ce5f0ee1d96b85e48e691e60e5ec2c3cdcef3668f63a8aa7ce680879218d2054c77ca74ed9dc41cdf3a864061650f6809eaee485a330cab6f629e34bd3b211991d77ba83cbeae46082d19165586fd358870cd41cb40fb2e40d80c33d263f11952913656ca78615b5a0f71e00a9eed254697762e42ade34a5361ad9f18b18ae3297ad3f52cac1fdfcd6b2b88bab93b9e72fa85d587ffca4534eeb9af3bf25771c9b54b20f4a1625e9c58ecec10d8d9858b0398e30f9d9c27f75f4efb6fd0c80bf8361e857a2534bb4225d4ca950f57e206df1e4ecf84a4814bbfdbf23c0d4bd6faa89d4bd572ccf5517538fd0f375fbf189c5b397fecce2d4e0f19e1226a262f8e0d0113b3de8f6f0854555d408c837d40f8f9132d6fa48277a26323977c810f5df5af0f96c96b832c69f7bcd1f451218ae312f01500490ae1115a60a44366212fc198741121d0a9178299425c004efe213379f6c38baeb7956ad5fb0e547bd4ce336d189577bc3e67633dc9137affc713b15288eaab54c7e46a1712f11323a6386e0ff72f3b06639d61602c7e83c98283d548ec11d9c7de8beae99e05e49fa9208f4dde716a435f414a52d8bc0988f3c90af0b4b194cc8c12834bfd2660f147a0a5ab9dde5f21cc44f78cd042a99643d28ba2ed65f553d698d4e4b8f13408efa3bbfbad9e9f79f86227cc544f9e06ff387c2c511c4e007fd2aed5110afc70ea22edf57de00505501b832cbcf168c660c37497e9a29e3c86733d11ea15e9cdfcdbe8f1110ac3ca57208083f584d2d63c793ec4e4a314e19cbd20facee29327d9b8f63840cce56d6258b55aeee7170ad1db8a3b3a588eed1950349f2e4dd504ff22fd6c044892fccdc4f0fa29ee810593cc0ce862b1c1ddae03ffab98ae128958caea3b821b683bde26058c153a251b2547c85596583550c7a6bdb416ae8ce8beb0fbcdb77c685e1d604543d26ebcf2cc62b183e9e0fc69e794d2b7e0574742dd39206ae192b495a60aa1b7eeded3273bf51070441e69fce35d489f92659682595a26e2a64355f9f035b5279625a68b1082935b727c9b0be9a4cf52285176b5ba708c120279b13764ae16d60c14c25e71e7a91e37e4a0ad8ab16f171d6a311693b99637d100ca4efa3cc390aedd3c921e1494f665098f43fa5b083e1d8243676ab4641000a1d10a6e7fdb1a075df1f860d846c6409b66e7c82fe7098db9285790cc563d553eb7d8503712911f3e6c3322b15460bbc939bbab4d2065336a32d119cd968aa218b71fd72a038b2058bbd0458f4330b1473d6c35cf638b3448074469ef2e0a0f5277057ea28199e65cae53c256af078fc1af4f66974206a88ff05f93d436f73d51ca4393c5a38f72c0ee78dbad7384d3e00dcc08f783565c40abf8012f2c5bb192924d886bed415df10c3681ccf3774638a9687b85daeb0b0ec8cdb40537758e01e68d6a9c82dfeaeff3501839abf6a4b5cd5d9509eeae4a4ea41d2f7c0c33527a5ee0eb6ef12b065a3931947ed0c8fcb7faa8e3ee4861f1ffb854a88cbb0281ac9304df33b4d3f41494b9c964a12da0f5169110edf26b2c4d0ae9f6653727564c4c0df7f3c21e5a660889ba67a55f7dbf2b9ae2c7a181682cdb7afb7f691d70a79eaab072f5a3a67499bb0017c6c9ad571e785a7d2958bfc4a7bd60141ff3ac078f37441c037a34ddfc50d95fb80bfc0d84989672b200ab866c632e5ac0b1577931009f602ea35dd621582856621263660cf48c1e4254c17c157c4b5028c85f1e6f3529a3086c7f88eb21e37dee5dc8d4ba4b0542044db7ac4fabf2ec6dc2af224250f494d6a3037c3be58f35745f7d52a608375be5d5f3465a7593bdb2119890ae61579d6399ef89aeb09e37149a385722d0e76c41c89975f3e869971f6e5246e7eccf093de363bbea4db24399ad55a5ae4a443c4959b6ad0c75143deadfab3e71219d3eea489564c5cc33763b0bf518e23a7f666ffd3011f651c5c669d53b96ba508ae78ae3ba5ac84b4cb3817cf9ecc0f0713969a15f277679ae18820491724dde792bb9ad46a9ca74225f42b0a5350b81e8f04044ac64a855cdd56f849080efc757f26e9e41c030e8f64868925fd6c06419cb59243cec177e610b0258cc89818644d4ab4c2c0dc73c18a72dbcc70b77892b0618675fa36cd80e438b3f35cfaeacb18b66d36b3c8fcb2da48983476be795b13abb9ae3d517b3fd2f77a3e800b1f22765e6fc728241dfdd6b20039c3a8930adae3a37ad53eee836a4e2f710244bc6f42ec9778f41e4615e4bbfe64a6468da9246ca7e2c4afd1aa5f4e0c7f6407e117330d2b6a5612c1a6c2b7f8789e2e85ae2180429c8c37a763bf33c08d3193e0cbd88b06611ce5febd59ab1ec2a7b10416ec3bfd7d641fc49bc8e71bfc278b3424f0538e340114aa558e9d7fe49cbe03f4eddc6f525dd064516ff9ccb8ec8f674c342863313c5d681543ac2f1acd45b8787ebea9231de6e2678dce25aac742987055b3255a7b176ff2c2775b725c79f006e65085bc04638909b830127d2fa0","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
