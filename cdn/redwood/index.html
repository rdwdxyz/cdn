<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"335b30b9c1ffd24fd281b2d6133f4409b50b65d0ae9195e830a2e903b3ef1191fe95b629bc6bb602faf4d074ef9300f9c362ca4ec4fca89c7f26993f830046052f3712f3d8109e7c6b8901a0f9bb4626f64bf7d1aaa55d506202338b4171aab186f1362cd75121cb68ae601185c2cf742b3af2cbaac94727ff26755fe12e1d070e3be7f8c28d8fe79ddfcd17cf157c18cfe636aa85184cfbf6d17144453d2d1c1803f7da4d86b7c83baf5069da6be0897470084c7c0be45117f5df85978c3cf3fe7966ca6f23d92441d6af583dc6ffc5020ff3021bd8aa61378adf463d17435546fe09277681ce4c67c2b574936aef2d93946d0613285426b35546817df7f34936c9c188f0a5b13556d1584c376bdaa64f974ba137f244c33696687116e403692682043f419de595fd96b78299678c7cc14887192443161149a98397fcdf79843b05b9aa761996046e902baf88c5f87256a2148e002d63d33a9ab8c89b43469694c0ff1b0a141af5b63eda866ed0dd09a9b87aa34ba8cc8d8e33109309896de6fda94b1726e1eba4aa09728e2dfb688c4068b5a97bbf6deb83bfcfc72207f425cb10826190b14c64f1da83f21d7e579ec107d7afd6c265ba72b0131bfd3e2bd3388360d1f45dc618c2efaf01c605139ab013e933964ae2b0df4426870ce9a37f19d49f990333f70cea070b99635c45863e359139e2d02aa5446d12d53dd3af3c2dd1be0e9e6d9264b55192afa9012b140df365d2b86d4bc3bd0088e245dd822f9fa620b93e8908cdec318d0daef5dde60692343e2f42edb08477fae3acb859076a17a9de4466adcbf56f3143b53306911cfdf4a09a9472375dd40507fdf7d15b5f85e60f91c530de2691150d790b82aa189359529551f816b0f8c6332b229c8394fc9c82e280e41581f90c633291eb37f3abafd0209efd799a7ae15a091c5f96ad2c31e16366efd66e42c4b3d0eb8022350dbc3eff0219bad2bd432e930df731a3f1277ace9479e5a606904b91f431144e6d3870243bb65a76c31d978cf4678650b8053a6f1b237612ab3d2443b889775008484e424ee91c1315627cba1c39152f45e6dd506687d2d0c41c7a04ecd728c7b6b1639867f952f99db40b4129ad9e0c7ecb94ecf024e9d91ec7140e71c0e65be433bb75b76d4fc908a68dfff4738fbf55105212943d1dd2fc56fc6fdc69b5b44f1af11a31bdf9c4a645654621bbfd231512449a7495331a4bac01cd94a3c39ffe3d9c1aa1115b76f7ead3d1400a44aaeeaa954b957c5183167ae24140f436cb38479e3e99c3cfd371e36f445a5ebfbcc4aeaebb654e96d64847d897ef90a0c61de8cfe93bc4f831a10bd6c7be170267c079c146dbc4adb2c16e1cbace664e70d2f5b46a5936806db55de66945239984bb1a1b43708339c9519638495a7a510d56cdb5f618dcd4e12b8892ca9ea6f40ba92633d825007f5b4bfb57e255f35be9c01b5bc10619192eb5d2aa8103f0217cacc2016f2d5d10508162e738e753addf7513f5a3ef46e71c4036ab398ce0a4c6715668aedbf186a892a9551af421c764a2e50036f5499d48553d76115d55435ce4b3aec00631ae5c062e1907ff3dab1c5231652714288c3cd35b2aa28f39147476220c4e8fb04adc6c7d0b1ca20b452bbe94d3a1c5108dab42104e605b4c557698b1b23216bfef3e88e9b7cb1a66322a66eb2bc3fe2bd116e63ab4e1e28b52cfa1c86b6f1e9bd032373961637579a38489dd1c356676eabc29aa50a22e48581bc7d8a3628f08ff005d3fbb623556bff6a7eac0b3302130423aa05500aa36cdc5cc74e3068f3d61c4ec669c24a9746d8198afdb22e36e2645fbbb53ff5f1c5d2a11921a522936c90c049e74f4635fcce2926e7357834a72c021811cff9d011b0960e75962415cfe8d4d7d649d862c1042daa7a4e2cc42e308803874c1a61e5a816baf531165493a86cb2e8786276b4d63ce4526fe7ce64a85f20b1dc9f222eba229738bf3162ce49a4e39b6915f713b98369023388e1f1299a693ba1351fa4b7ba5cfdfdf3cdfd841c100b77677bc0bf28cbe7d544688ea9d158fcbe36af521457a8048ae9b7c6d9dcec8ac51e5d88c26029a721c039747303c0bd831768baa092613e41b5205ef50d5f24f7a3b907f4a8e53b9a6652521550af800233507c0009dc2b32aac30d010a181a5fe6697a43acabd24a28a07996a975aefd4e52031b0f19cecde9c57440b221103ba181e6b80bba1e07cf8a9eda8400df557bb7dde2bcc84411ebe1ff6e30bc6bd0ab42319e09fa12bd28cf919b9021ac44e49dbea7aab5757c20d4be08dcc5a4a835a51ec6f8fba21026e31984b374fdd778fae1d5061fba13f3eade715d061b5486f8baece06c9427c44015b11e326cba6e28e30cca9ac0ff070ba4c28e28f0d2a48102411083f18963b1239a2cfa6850316f002c344855dece80ccad62b983f8e1d410065a763d2d65cdcfd564d69bad0f00bad012c199644355aef433bb0943f0a86bc0188bd0af7c6d537911ce993f8c93137d9018c771408e47f65b2d3b96d70133305c76ee84cac4b038dfc08c4a6502a997567b774ccfa0ef416fd398631f0244289a66f567934ddf55607a5102df835d550c83f74b90e947534d0753521ec868d33db34df4e66eab17d344a29030cfa2ab614d04c9c6f731c9423ff7d26835e7f93f4cc365bdb0a55d60b3c099e0ad9bda1e130daa525fc89f649145f75a338a03533c9fa2e8686e6e6283c4665f4a86971cc3ccad30ecc8e7012c34cbe0884f68884d97b91c9f3becaf7488687a3455303951fe7baa273f03eea0355e441182f719c738fc5b38927a321ed1bcbc957ab8c5de340fcc26dc70044ca1fd15f9bc1df95fd25957e50ad87354200e173e79ae1ecc0ab410fb4c09ce16ffb51bc93db23298f0da898f016889c02788f15cd5452f45e893c576ba7ce5234738e6900257c454494f63056c5a064e3f377c17cf7e3d746d6416055345732f2a50ce26e86032c5e2e0ea2c21e4d20f5a27280e2f5ed66b9d77710f402c4216504129d0fab43aa2e39ec80c2a76f34ee350c4f98756eec203fd5cc938cf345a92136972f6694bfe120674f0c7034afa8283ffccaa54c7fc44b5374297994cb18f6c0d8d0a2fd8cc9908c4796533bd9e905aca516613803bc147a9645a5b3fa83ea342f6297884a03a1c57d72d0a89611ff35c3799ea8889530e396b287204a03bc18d2708f48ed63e00a3a737cb4126f701b43a12a33ad76a01fe82fd0d41e4dfb063e9f974455d8d170a7f1f57dcab50de46d55445c9ee03fbffea4b4fc88afe95162f167fdb141965be7aa71c91dced3946cff70ef053003457e5e2788bf4c3c1444dd4a8be6b282ab6fc918dee0cddb2b577ac610763d6f16e6a1c8ff6ba2ea18095a1120e7f5193a1d621e0732d6aad8d05c72bc02e10aa8885e748ca93700f9d6ef765a3333d1b83d3d9fd0f9fba4a31d239dfa2d481b3208ce23c8973cc1bb8e0d9fdaa21b0f374dec4c0cc134c7ded06a243910e7109fd3aca45a7540f0e011f672d720bb181968035d75209918d2942ff14acb8d14857da443fc51692a81925afe5313cedf4223ad56409b85e8923c16dc2776ee593f0fb5dde5958f4f85a3d454a9a7f8060120d3d9e380859d406485f7ac1b5a797ca3740d1320673e71e989ee3c101aa99893e90ba704f0240a825bf38a249d940aca7a23fe31ab934f06524d32c18362c4f2110ab2c2e3503454a4a5040f85e78daa266eb2c2da65c2aac446c284a3290a9b645e34bf224eb27609ca33dac668e5701ef4ece5be4b18ef12645916e9fc2b9be3daceb778b381c8c49f127d055fe3616339fef8124e28b2592280d738813752999548847ef8cf4d82d64e6f0b490781d87ce0d0f32033f77cff88001ab09b6898fd4f05e7e325847886337ad743288033d9c96e3d3ad399deb407879c76ce283e5f541aa03b5b46ee738f0035c3b1ecf813ac816044d2ba54684d6ecbd60f4714562e92760d826910cfda2ea70c4e7825ce8890511b4812fa77a9ca9546ad2070c8cb6dd5edc065021a2ed67bc83f397d7541c4e719856e5ab44d18e0ef2f6bd638f577328410dae7ff61850e6e4ca300c4d2532489f0fdc0b98df0af26f5fca1eadde5dee9ad02ee5fd16c3f4247be0236f1ddc3bc3f83a6a2f55391d778fe653716779743d4177b09d22b38f5b65b01957cb527d8f3f8a779199b717e2c81ef9b6d28c2fa1289813512a5177cfdfcd067264c3c9e3019b9049be84bdbc08e52f20c453c425b65380c93bb8b316443aee0137be67b5027e859b175e66a86ea2c5ad9d62d1d537cbb12c553928a01fe4175fdec3d1dc77d30d8877a569ec286740dd64247b230612598f84db9557740d0a187468229ced1b9c23cf9a48b113df57bc1fbcc1ff58795171aaf30048b94bb00afff6dbc8a52498ac35368ba9ed1c0fb1a0d29307999d39576928980961ec19f2ca921a7029f840ec846c98f30de9049bb18f32630975de9661433ed41a4e10190623dc683626de06599e310498a133c9fe2be323e4727f740190f66d995f5a4c784ab608bc1ffbcdc01d31d5aa58fe6da6e2fdcb39c56505fab94fb3578fd3709bf253ababcf437c34325a153ad7425b914c8581b76239fb0a6eb6063aa87b33238a1984799496f554fc995da1c22dded0a28c2c26a3a42a0b88ae280d3aab3c064612c075a91d87ceb73a7b65ac8ed671f0ba2ed315016932a1f1d2f07b4f3d035928b7a060244a55a919aa084e9589fe6fe79a247771fe043a9b788c97b060ac062d97254ccb5fcd60d92845f408dffd2b65b4ecedaf50215ae2837cebee74acccfd2a74ba9110c39af76714d8047e1429ddfae7e235a92d299726f401c93f0e778f74992748ceba77870cc0758ee9136979e64c3363f0034179307bf0c80ee12ba662bf7af82d042920ec62d98636f319cf1479cf91a61ede4fb542ae797fdac0f1622c80ff633290626d56791da3371d331e25f4bd43c2c2209e295e741883298947db7d7b246c86997cdf0426abec218a33de66bc4c1ecb4a7e939c3eba6839cde9f054d4522aae48395666aaaf59d53f813e0dfd78a980d674cae7620b9dd386c27c672019ca128f97b168c6805151d7a4d6ae6b22f10bd3176e13583926320c535fbc739a4d91a6d4f7ba64f8cf63dc13719609c225d134ed92b4894f1b3d4ea49b11fcdf6bf3b82886d4469182307c3233ad95b2c3d084ba2890f4a8bf446a65e3522af976027d72ca3416d859879787afc28daad3b9208ba9bf1085a1d09a269596f009c26001f59b86636cbb77576bceacf5a357e63d92c0e14f40c5649a3479fc000ac2ca2192d9963292830c17cdb956a84bb50fa04d086f73803106d70f6808cf390383efa52979ee23121f61da74a0b77a9c5b8e92046d3abd45c16eee8be28726922e7c138eb6c28974195686b73dd78a69392987c0ec9c8a94d6411dea3048ec9004b0c1b8cf0cfb6185bf055f9b9f8a24f1ccbc150d8f94682327c4ecf95e42f4002717bbfdf896e99870719b91ef95c0f2eb402147f18d894b2261440746c96ad719ea4df2e86de0f80ab11f6f83dbca2289a53d2a6d7c58a1d79f9a2aaab638197da318b475963d58e13fc80bf60e21e7e46605b19feaff2b2e21e16cdec7546d40f86eda85a9d5e8893aba48ab8b0cbcbded511d65c4eb24fe61a88c59ea76685f93309436e4ee0566a1a2094c7e7c3526b3728d414c48a60424dd7d9dcb7891859c914dc4d651fec0045aa906e6313e38714aac1c400ce414c634a4a10eaf906677eef4c3b693ef1b7062eaed6dc7eb96c83feadf2c36d12b3d7525f8b3e0fedf06453e20f9b4d1284c4f76e4a08121b9566a63e0af10b66b031f42a9e2b7fad48e1f04e89d7c261a45931ddf5cdeef4d64e57769e267cd5829e2ded2fa595d6dd39acff2513bf91965b278f4df672c9596c1aa40bf15a64f6a007605fb885aecaa18e22089ffa098538caaca498e0a58c426d2e4fa478a831bcb6c754e065528032412ac4c78065a346adf0f72ec6de5619c36c12634b7203cd8bf9a6fdca2058844fe5655f8dc3d11add2dec9b48396a40cf316aed647f8a04b1086b367c3331f75bac18084ec37844211f63a55dabdc5a88c3bde6f13ffdfc512563fa5961d796e3716e1bf47cc2d250ad292857191f124523232627420d2b4b4429e45877875f2be6e324335f22ac53e53c40f39f1a0b202eb551d72929df2bcbb7dd0ff5e08cd5a4fd56f160ea787eed1ae2dff5bfdc8c2b6e62b337b659fb0d08570c38a5b93aaa7826799e24193251c0049fc31a58dc78b3d711cd888c229931b7e05ce62b8583f64030e3ca4abbce5fe59636c2d6fbd0431fc0111c491812d1e4c0137a8ee035154a1cab11e7a3dc6631a81f6bde0cda37b7bb99b5a615546fcd6533c4e1c3fe5332ecbe4c12f613e63261848426ca8a45c88cd2d976843893617154faa47f2bcd4df282866878d36688fe749d1462ba7e35f379e73d111a81a8a07e9238ca0e3609dbb39a4ace15fe1be7b01dffeb9abb2e6614f95077078ad795794b6a1bbe314ba45be0051b42df8595885770bfd8114abb12cf8365b9504d72fb4b0cc85c252a1849f75cd8e3fa92a09edda600bcd4941ba98c9051ec6e082d108830c37de36a8e00b40e3e76c4530b1e17b1dc1c8f8a04e85160e327530595aa1152f8b1f6f259b868d3f6ebe12179d0147213fb989b402f76c61ef744ada99b2cd3d45fb45554f40c015453e41bc6dc8c6ddc52c36d0cb037583432e83e957dc0ab9210f37d38f3e98ad6dacf9d8e374b8a5b6a61632aaba841864c7310f425b8fcf50dba28d20e23470b5a1f49ac987599264d1610347ef366a8750886fe113b6fb9eb66c8d035c8407a09f8e8255857d53da5a770b498de754d617624a7bac871724f8f989343165031e67ed21a3b059d1ba7e268c26a9d318677cdb9ae6ad6044e11fc364dc422648dacf3113c8448480b0baadcd6784a96068fd6128cd5cafdb5f6508d90282812c1d2e3823130bf4fc29952dc82537ea467ce2061836aadd043bea1a1710c8503ef9523ba42f2beee4aca3d5b69f555cac0f67554281790293fdb716ad9e7b9524f153918fa8876724868be75b59360f23200b93e9f7fe53ede482a40b83a2963860aef57fa22fa4b650b5ae9ff6be6135e0801011b99045ed2f8bfa6e310868995a72b17f7eed55cc49bc7a740566fdc9893b5bed722073eb082c0f3162d50bce6a81f4a45aa4f933ad0ee12b8c093a4d600173c632c9fe53e3512fed7ebbbdcfd088f7b1ea6f458638ad520b037ed8a98a1a8e0145ecca9cbc41b807ef33f1e04e375b309be609da651ac7212f549c4ba7b02e4fa4fb9b874e1a6be2624e3e5c739fed18c22c84dfa32ce571867caa20bb2e2a2d10d696ea3affb2922762ca78689ccbe9cc79fac5b394c58c94040b99a1f4d5432ce53ca8a6ca0e3f8dfe8930e25e92cc7a43542c4737cb88f70e31bada0f832455f65af3d9644cdb8a8e9beab82db3c5f5d86810f310e9c738819812552ae767e1056d13fb2586cad9c5e53ccebf8aa79dbc619ebf6d81e9220146b9d372ff3be2be0058e775d2fd23335407afc9fa134013f674a6bd0aa0a1867a5514d9f845d66bb67a91e174fc804b03046dd2c12ba48bf5562be07407215d4b73db4ae484a3f009c2fee169cb0c89ca1002884ad174f441f16a161c4ed3368616086a80906dca9b01d5c146bada8069ce5fe1875e305252cb94ad061aa86dce18a7ddb7e86bd591a182052fddac2479a7185262016066e1da6412a7b4adfec3bace030cf6f922f26c4bd8e26aa358f5c4574a042654d9971986ccc7e3a9b49cde10d8c92644f9fa1599b849774f18d2837c7a2859e932b10dce0bb75de6116eb95aeb7846fe09e488f2ef0e36c4327bc340e4d2dde75a5a8c84bc76084e1fb87c8558e10ad9d644121f5a7b60322c929aeb78e68d78fb76931a8f4ed3770a2ea1d30183526bf2dd5fc01dfa072aceb81d776d0a9b062665598a1a45a2b33f8a77537ef72b5c4d9fa39c5fd21af5d4631030610970408b2e0565c11a517e897216e06e373148d118dc59db11f8836c791a3b85c96c95cd4eeea9d65080a3ebb793811a27b96bda8707ad6d3ff1aeac465cdea4a03bec88ad30a6b8a17360cd502ed40689e8b0f518caf42011bfa823c85e686e2aee2c848c9ecc5e42be25060c9dca6ba10f51ae08e00a14079acc2dc952fe3558fa217c14e91288b969571c1867542d05868d59a7b3c43f3a2a64c99b17fa89b969cc19ab454c01d1f9ec5e27608f9f4f2882bd14b1e569bb5b2fefb2b48ae348ff2497674215a378de47a01fa5f6d0a0abe4979c65c88ddfb083d88de10cb1b7098782a3d1302945010391a3e9140c5e6831bd62df9e0663f60b0a3f201d09065ef589cd728b45d6051b47ac23fc9df2708976c3c1799a9245a82bc9e0efbb1ac8eb9da178218330eecc06d7a0a9885d42b68cdab9bf2339228804a030cbc86f869e46a6ce56e1df77e57240b1bb1b02a36b9817c947e37109a1b983f297df7f5973de63cae8f5417d199ed47b119bbbf8e41f148bb6381a106fce5d1024177a7bebb61d3786c9e6f36fda5b147ed1a7f80c2bc89e634d7d3d51631ed99541d5228bdeb5446598c142194600ddca4f94ae7879f645a77a1d096711c8e6a503dc4816d7379b4951398a1b43b360f25aaea83df843219eb067ce3147bac91769412de7ad44a0235cd48f36e4df57fd1317fc13dc6eecbbc0c07da4b5d21b5d81993ed24c6b8ec7e060f84f1a8464754bb638833f9b10843499ec10a783451fcf25321eb51c182c6433acf3b030b24aea94cefd7d6fb292a3de8a29c7670733af8e838fa8bd6161e535985da4ad88c4dd42789a311c57c6d568215921446f6e4804fccfe6bef10321e959275142c8886cdb0a0a24faf4ff17f0fbac70b6a0b28e52009ea22d433cc21de48c54cc70a09fc8915da806a33e7c4a3a4c164511b1976d6affc754ba4116624e998844d7f9fb50e00dee645b670f7b7484f297c4ff575f1f8c4fa3e66b972b807792f0e06338eb16aeccc6c143cb011d7e4102d8732e38be1b55963bbb44756ef81f4194feebdc980f380336663f8d2d1ad5c57c3ffc4dc3197869a53f9ea7dc5d8837cb1d141dade598c0292df19b788022886330e65558912a8bb6387994e8ffadf5782a5c02ae1a16f5f3d558d191d82a8450ee218c62d90d6644bc74bdde3ecb96c861000810c1eae99c81d1b8dbf48acdf1e8eebdf312f95c93119afc4dc0088fb54f4717098a59ec6c15f9ad2dbabbdb54e20d87d39eeb960a21ce24904421766b8ec097f49f6b39e189b1dd66b485dcb8b5e7bf0d7492de874fe7157fbba7b62a80a2d813ad0651c3acd0df51a6de2d6f21cd13cf3750e316af2aa9a87425fe93a45f3d0096cd2342f15afd27e57f194ba3c5425f63b19624daf8f87829f7cbb11023fd41bb46fc78ce478a4bdca6fc6463cb637aaa116a9d01fb47371d9e47284cf93dc17412ba1a56ed5673320f21f354f68cd25668f65ca8cddd72a61a4e992640eff38ddbdc537b017d744a5c4ed49bd45d3ded9da51f686ac4078f1ac4386e189b62877ed76b0f3d8313a6013ef5654e747952b002e6bd72ff8ca6a11170819d3b03f6fba437861901cd39d2e190025a7b1d6ef274fc0eaafe58c7e3950a0c3d91cbe006d626dfe69709c606ddec17082a834f217a9702db57015747faf841af484c0066ff68f7b1e26782873c80bbfc94cfbca80f52699ad5826e141a6e5520cd2e09bc7109881f10b5094e31819f07fb14369c9e4e410b016f47e3b8a762c92c5c02cc17a772fa785c89975f7cd24cf34bd17bbd940bafbcd53e91ca2c49726f85821a23ec66ade16bc288e161c12c24fa109ba9172bf79e17dd9f6907d51f70ca088f36d249ceac58baafa3a5c5d933c9da01de82fc4af1de5f3a0b08c8a6ffa15bb0fb9c2eb5a754541a9ac8f18db9012c14faa463f25e840955bdcaaf1bd6a3db6163984b631280f86ebdc719bb8b20f94a9d8dbff86efb9ab0b3214fdd9a945f51c31d5afc2feec93994280501eca6051dad22bb4b723d4f2a1d5c7b1a7481a418ee8b75947b5f249fc0773909309b0dff736a3298f924e6ee82d7272f1b2b4775591780d7c29d6550202352076edfd9e4f2ad3cd92bfb66ab48402138ff1dfad92bd834fee47eb10776369f934ad5073c4968dcef6aa3fe4afea5a09f68aed67d64c7c606fa8ef8a07618d682d8785b1763e72e1fcc4aa39d009d7fffdc1a7b2837b9caa4220665836c13ee6181eb733021bb4a0a9a13cbbb52046c61220dd98818145b29940319fd3ce893c41d2fbaa1eb6281404488eb693d1fc287d863ef312fc92c8ccde24d66b3226b9562a9bc2fa557bc1a9e7ea8839f0410217c951c84cd18e3778193e333513c30c9d133e920e4630cc34d5fb5320009faa43dc928c88860694e7eeff4280b0e2a9223d6dab2f6a338b0e66caefb732c17881f0a6468bc26161e34bb0402193bf131c7a69671821a85148c13ba154521f2d9e7488de31cbb404257ae496221cf5cd18d11551a89abe52abd7eb7f3aefb97ab78ab4180e429285264506270d870d7416062d988f79d9291bc7653df2843b9565b4a9f280dd3ef85758a0862ba0a695ef04070582e82d8d373c7c022bf25b6ff66c55495bdd6a14f16556218e2aabfad19db1626c4455f617be9f3d890206271f77ee5d1995b6826743975827bfa65af8baec46c890a61a0ca9264cd5b5aebe56bdce835161e8397c36f4b7bf60c20566e2669245642e08a03c8cac51de4317cecea8596e41d31a068a7fc6e2af9a771631bb90e93a576c17f9785f5c255ce805a2fca2e54d9aab5ee3817c1734f6fc0b429883b78663b6db1edb692eb071836225fda62b57b55043f6dbdef72c50809dc1e487d4b6943f6fcf9783e8bcda993667ddce926d14d94e0a2feb14f6153bef7a677826d34d9b119e056b06f7f34edb8a325d295703197d633d010e7ef53868d34abb928205b078ff6b121b6e83cd9d06b782c236bfeb15dc11667558a6234d89086945a505748657a844032427c5c4f2560943d71cf248469b4f392ed04c2aa162e42ed885041040d6ef943b15859b163e6dd953a863f522afe04c68be7f6630a738ec0fbf023e9adf0c1f34a2e7d93f6ae51c9a57b2cb67d9813b05987ef11f4ab4b1fc166118f3df2bf3d158aedeff0ba370c99c748a1becb50a682fbf552d7154d2ff547316ecb68a1c3aa536846956275e0d14d2c14d95ebfe2c41aac82c68f8188c9ee3511b47ab830343e1c6e0dc23f655b99f93d9a58f5220231e49a4d559194747b7f55046aa27e914859097f39f6c91a73aced2b89739d5c56425c15b04011ac040371a584e8f40cd5488fbf06ecc4c70040bfb958d3d66d328d47edbf226b15d3ca5cb8af7981cff6e9114edc0b3d23b8d409af68f08d819cf4cd369485e588f5c78053a1dab8fdc17c52d76dc6f40de56d365203d371d517ea488b269a600c4a103df001b06f5dbacefd82dc9a5f65e635f3f449720a1943214055e0629355dde0fb4fbd1bce79de3e20052968e4b7b8e546272fb143a723063e739a8ce1d4b6378bb394d4f45cca77dbe251c3a5233fda4b44031de8b67906a70e27abf1b9b7d4938554bc236670703fc31064cfbe4d2d1fd76c40304f8a68889c6bdeacb9bb3f6038fff6a5f39b953aa8f7cb239ea0ada14c344124f72022736bb673cd0e574c77cd6e07ed1eda90815cdbd13ed2397da09727e47b12f33e11799104ffb4b39987321e74671b5ef435cd89f212180bbfb4458cf702318b90dd05d9449f02c00d9874d7ab3e7aba1813620b681ee27d0ebbecb8b251822f404a750046309302bcbbb804a9053a240b3be3df7d525cd722339075cd025e499f50d43ccae66ad5d15d89641d7364a105c1bc59625700ec8e6f0187c28a115199dbe04b036051b99b6ddb29d02483691f50cb8e9ed7c7fbe5456957c19d0631c5ac3dcf7d58478a8c91979a3c301a3377e8d6a5d3b6c35b830dde5eeffd6bf988d4f7b8cac5b8e3e08e06b7d18973ec3eba11c2d6279cdd92e9cd900947a587889c9f803d0954ab8e1bcf6d13c0363377995d6e7b91e2c5e016bb03f41f506f08c8615e8a54a51a9efdd6b1989362e94082b8c929f8ece59032a5aaa45a667baa5aed79aeb220b36217042601d1b803266b3c6c5f06e6b3d11e9def886ea4b252a0f70e00335f30a686ff10e47a5344335c7483f3fdf9219a5e531b044342eb6455e28c41c2e46c962960006c585dc9ad195684cf194f548a3370fa37085000e774f271be8a777e9f7fa177ec483ac5343497c5a6618ccf28311cb078f229aa526a3691bfabe50575fb570000ee962fd58d2eb74dfdce880b3c49980bf46d7836fe90c71ee7d9b361e322c7998bf33982224f35cfbbecebd2e94b1955984fa2b55fdc607b69e937e308a437f9a3c5ce90fe0dcdde5bfcee39003345f8a57765e76bb375c36dc369c36fadac25f67f3944613e56fe02988fc5f42a815b4e883e9806744e9402515821c83865da44cf8a160f3c6e60ec72f564f5db416b6754996e6b84fc048010b74b3a1dbc4cbdf91f6773cba652c19090b0ff1e562e3d3bcd1d9d32c6366d02b2c720c5d986cfbe90843c55b043e6b372e21d674412a47a21efc50997d8457715a40159a988ce8a6343fdde042fb9c887f624cb30289b6f216d990344471a3ba86a00d18c219d1a3545c0a1c5a69ce03ccb56bd212941ef2d9f6f4ddf3dbf4f2d9c4492af381229a95bebe8302c2a78915e226b2d3b8b3e5e096e658659f111112131f67f613bc88f4d7ce59626c9fe10ad78f69bc845c24218fb591638a680d121d988a0133646bae2e8d4e8427b9ca1f549d7049a81f23ccd3bf410c89dd630c88d40a164f9eebd3c3b790ef7d7a92a5a2ad805eea40a57b61c30661ef379054ab2f8d1becd42d03f80e2336cf8aa152064e5a1131f739e5cf1f68430095700f6e5c36f3a0a5973c82914b84b444b232372370bbcb473ff25c3930b7d0beaf961a39bf9e770ee43bc52fd8dedc98e35c9b20a689e1a2acd488fda6466c1cd5e61015bdea6e0bc7f25571476ad50ddd0f774bfd0ac405b94b1910346ca1348e9a81ead18114f4d86ec5888a47eb49779e1faa782096631f36b2b2cef8e977b4bf246ce09314f09c377e7d3b2aadb13c2b78e5ad95c5181ba8f6bc6fd55a92434aff11a8e527f63802e78bff07d761bd1be3d67b2622366f55c77cc43e495b3e7288af6f8a11f8c6c87d12f26424fbde7f7d6e640d8636eae57e910380dddd8061569dceaf9b79195b5557b005762eae2dcc2c59f42a514da852e663f0446e27fe5c207a8827a394d102fe3388c1c2c40066f23e0288bfb06e74d1afff1da1540443938bbd4aec873e8e116cc5e39418f1943bb10ea6cb256855e88e2aa37f0ab4e4aa6ab611f90d183ae7327a85482d41ca9cd1b3084b430538067113224dd8ea416377d5ddd52ce1eae4f36fff1e927eb18b04853a658da141709547457c6f65881b606572421f9a6172dc344a312a7221ea4a288dd7298decccc63e99b4a1b033045ef46fe553364baabfa2c1305caa129b029cd7e6a404379fdb1f072213e687b81bf0f30a028b08e27d48d34dc926ad31ab1f22c2676f9c38725558c4aa285c1da3c4d86a18e3461e0f5bc45402fe1731b6ba8495fee7e56e597124ac837ee64f9783864baf555b11a6123a0fe9807459a4ca0dd473aa574c0443bffdd77aa4585ff1adb59ad871fbe696d6072b903a9e0be1d1d6b97dd97b506209c42ab9dd823c2a2d6c3d4bfbc40139726514878156592a7a632c38385808ef40c0662499eb558cb4bc77c0cfadbf0be18c85302b85a332e5510a797a387308abb5353aab6d15106bfb497af10d417575b240abf5e318ade73636c83dbab62637614eb3f317b02612195ca60321c1185eb2d4d850fcc48e6a22c1b78f0f6e9985d24375385c6f417dad4d225e5f04f19a7d3f99953b819f2817ff66fe10c5f0f9a7ea56809c308c441ebc677cf6e52b60d6e566f9b99b0d5fbfa92226f4abcd2f2d7c1d91513d13b7f7d633dbf29e4bab172926b52372f49bc97e3c7041c563988c415bbbadedab43cdc397476e0664cd99f57185b8e3d5229d97e04b856eb938bf5046a96276f115862d55a935b80ff1785e9d2cd42146478b475adc5455cd6fbf707ccfd6681c0a0b212ed3cfd1eac3cf264d6a14a231ae1bc5d334620b698bc965fe0628e841f78d668481c8534aac2b9a171c96b08ceecb27b9362b6b0091944e2012805218a4219dabe6b397fe87bda31dd85a865595c2b4ae6f2c1945e4ab435fc912b992fa125b5388efae41dd812cc981204d43d7cbc40f8bd12fb586f77d2d652942b5d712d194447786cbd7997ef0cf3906ad4df52b07c7db39611f21b8f2438bb946de6445f0bc52c050907f8e66845a94fad56b999df8142625357ac17d422e9c902205ea5aebff1b1fa89fe110d9992b25222059678133674980059ce90bf3b4eac4ed7e58387d6c38fb35d6e588122da2b6ed02450d62043a2159a9603e1b636655d5dda765fc0f2c66ddc2909a667f1ee2ec3ff23319d310e06ab6408d86a1a5c5f53aa912cc749ff48d7646aefc833c6bc1bb7e81855305300cac8b9b8799cad4dc30fbf7d7698a9db00a2c37f83fa0211ee51193c26830c92bee9d79b22def99b8b27d9147bff11b18cc87f3cae45b5137a58478d77af096a9ecd0015b817874dc205575c5a2c4cda282eac4bf3f95f6053df9738af78836e5e0988ee0693d2f56b1c2921e03161eae453beacffe4e3ddc087d2c3583b5359b57ee5442efc5f577650f69754dfd5a96833af6f56e791fe5fae82df4b82c7371a7399fa8a1d562f484af56a6f3c044d486892dfdf27e20c0e29285984a6921d04c3326caf12c610eb5375e5279eb9658f5a85ae91e04ab59f2a5a1cb6574f93e9ef117d9c668ad0633fb04859c39ba3312687a17743b7de6380dc89145f3e0b8f7def7336752f87c9f1baa423057134138dbd6ee5fd9314fd2f4ca3e393068293b54d86f93674b3312be76e63f9fc8e8c1395c8ae97b5ea7c670f2ff84d8e0e8a0c3e373b6e8f2e20fb65e012c144caaa539910b38c9dde082e2b16cf6355ea34e5e21c43b8cbe36fc34a8550798391ff2a6319a5310f1f28833fd56fa20000c7f72a0214b51a18a82021a514bc4793c6a5206df44566ef7dc07003c7e92fb57a7fbcb48d47e1214536f0e3b81e1da54baf2d712f824974634bbcc1cd6437cc49d26bbe820042d3895acb15986970ab336d2ff25154cfa892051f2b4d3d0cb0f6c3014e77eba0aa12c443d311d9c7c3a984f7dfcb1162a15e75ee2195ca8e9f359ed65ac692f6a96762a459375669bf72d0a26af8f47450827d76a8b9bef84f7ce9ce88cbd7dbe5f20cb99a0873c1acbc6cb3f87410bde819cabc8eb6d24cea461a39ddd11b5e866dcf2672a812034f95ae7965e30ced026bb7a6a34da3fe8d53b9c335c20a5f97762fa33a91adc37b46a353915cdff5661ebacaaab83ae91b01180b0bc804c99775e42ebe69409a855d51094e23946ee2a1f49011e30823d5e665e79e2e0806bfdf7e88ff67728f8f9de8047b7284af34112c81e91b991a40c4c57cdc644c7e63957c486e7567f1e13144b9f125d5082d743c5ffe4cda011acae639c58905cc192b70c196f7b8b6236719b5bb4a7d86d02a6a2b85905799f2e7991addfa93c6bf353e280cfe81c363ccbd692457dcb3baa22f274c52439b037025ed1f969147a4cbb8f4cdbbb8e54c67fce91361e8daea698d05f4956083d609738e3c545e80681f511cde4f490a1ee1c9fbc061a8b700b8604ecc360597ce6f167c102d881207ccb9c5d64e867f565193569168b473945f37840fd180432192b129814d80336be048586c6cc33e3a6b2ab82770d6caf3b0b4d09d2f5ffca8928bb9a74f81c11601b9e53f8470596315acca7335ad1f7ad3e6cf0e900d468eb461874fc486e9589374be2e1fb1d398f9153785d4a3c50f90245b3d6530fcf757ac5c7b10180de1e11dcf1856eab04d73c7b37fa819ab7c4014ac02398150c07953613a11e4da6b7f13961a358bea7364bae332fbaebe449a3da058eabc928fa78dc7c9d1a456eab89854ac718633b306db612f640d8e022f8a52561c0732981d5e650327999ecc29c8bdeee2726f63a2747ff0e240c45c825371f11148bb45bd1417827d07aa62b2c7a3e29742bdab8b3763140bd8fd4ed78b9ba5d6c567d275e29f0f3007841ada2e0ac8fd0defe72cf3d37cbb4e30c1a32be7d1782d3f8a75ea722dbf9dfe6ea0eac3e182067b2c29b3d63ee641b9de858bb3ceaf6e9bc53bf2ae9cf3829252c3c4014f5babcaa0a2f64701f3bf25f3494698071f8e1f76c9cb81c3ea3a84bf29ff0560c6a0b6b62a7ea0f1b075a1e78455e0ed610896d5094ad1d377609d5b3e84cf6ee0ffccc1e74800d4d323970fe333da059341fc4aa6b076f7b85cc3e3f90b8653a439e6191ff6a26de7cd095e98ccedd4349acf95fbf6d7a6979033525def78fbabb60def8259874809514627832d42f10202d980a474692aca366617269415b4956872bdb7831a73c31501a9896a84af0551d447b6cd218883287faa34667d297caff690059a1cc382404f4e6ef3e96fe96acc93ca6d9894dc7e1c6df05dd2eb82b05d6f6c1d8213159a379fdbd072da97e08edda3bcd8ee00b706ba0fc7ddafa154623e0ec9a250a58cfe4c70aa16dda7426f3b6968a52129b04e8543047e6ab415ff935f3c1e86618861725aa96da6db3a1cd16d84f3a5757c4507101ed73a176521bedf7581836caf0cf9e89a476f77c6ffcb849cb4cb6bcdba576132edb2294966369efba0b0d97225d1bf0b83a897a4f93844f4a740ddffd8dec7357e209f00c5383a94021dce0a1b8c08b2d1a340fce15b8b12af19267440964970b98e6d779dfc4e08f674921555bd46cc3d0ea1395f3a5a3c07207974ed59729fa4e1ac678b85040324fe9c6520d15a786fdec50e56c28ccf219cabfc2768571a938f168077b10a589c8074e4730f90010b5351d3aea79b1894310908e6ce5d6ae9f9f7d11ab6f3051e70b848d08b7db8a991ead9331a6e93097705f4979bc0212560c79d9f94042ce4581ccb4a8c279ac3f449853cbda08810ab6ebf3e999ed1f6a1142ed2cf7ef47a3003644b8d271f209b3ff67c463f5e48cdf5c048db5a9a099fa851b1220871ae648827f38a89aad6a4b4c9ef32c4785a9eed3e325739019e205be7264908c42957ef84a4f782f7a60e03885db74446179f59dfcaf1fc66992f208e8daaab0c27b65c781bf173cd197f369114030cf0363385c60a0c178cc60e8485e746c9ccd85e9982e315818aa6cc514afcc50e5d3b99c1c260b0572c21717bcaa431d60df326414988a5cf10c411854cdda379c1283ce324858c535924651b7ded7720e8bc480f9d75477a71dbb553ed0de18740d459070ac06734e1843f329dae3ab9aeb3e589d963fd396a4f690cf04bf0108c9ce0cbb06bbbd441e105d39648cb487774672349e96ef79bbcb36a728d8a13ac732d18affcd35890524c584dc325d2864bd962b45fb59b780f2ba74019ea6f8cc9d44f8ea6e1ed23bf005b9d806c79d7e3ca9f9f4ec3886796dd5ecffc8df5d9ea6a66d0fa916f4e3ef0773f90786f042a501d68680558f5e9b51803a6e3364e3e37f6db10800c161644e3e9391719a988bd8468ffdbd9ef931e3df171298a111f0a79600215c385ffd5c06e7db51aa86ef825a7a9729110300b3cd61522251ec4b97eefa7d8b8d683b2d557f109ce0fa0982ad3dbc705a7509d0ca3418b580d0183d81f7e6f75d848918a7e666d1d1ff48637d0e9b40efa60d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
