<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"8ec62f47d381c0102c6f7a8a693d7e298e603c71214fa896ea1e09fbd0e21bc1f139cc4f3b2ecdddf95715e6b2bff2d8c5886ce0757fd07bf57ae883a8bc04c37f69bd4f314ccedfab45347d8e3621f99aef348608226ebb4ca1bd2c2511f5c5bd9bcf1e45eafcde46f279242b63240a01e40e9aeeac5172c051363e12854d5f580e73f39476cd583f82b854ff649c39d7db6c5ba4f8e37323ae55f854291aa3774c05486e5cd279785b348767a8c9c7a02acc11d55f4180313ed3c76eda1748acb5168d2e4c0d3a84ac4a82ec4ca8167a0e72059d715a3f2e93e4e1370e202ebc3dc44bf6949258060e4dd8edccdd2edda0467658997e4aebad84acce0665c7e20a24c637ec315e71fb1bc862e45ba0d257ea75ca8f78de4e66a0be113feea860e2a03232e462f28602253ee0b4278e03b7048bdc85194ee86f211cea26ba25271b3bb775d6c723b767a2e67e7347caddda021a8ecaaea0ce851163328e93fcdadf9bb54c3f85061651937933be3eac4cd1395b452f0ea3179b6ca08d3518288a2e023039286da6fb6e6a6af637c0c1acafc25f76fc5bec8d2373ca720562a4e34c9a15b2322957bf8f3e03f38810d58aeb086cc0a1d5b59144659a8c5e5ce024ed428cc4f6932b98f7240ad2011acc2c80fbc0f29ec7365626ee0e34ac41b56fbdec7674bf73c807b6d2b33a954336be0e5238fec3b33c9da16c26ce0f7e194d44f87fd6d25f3b380430c1127f5738d44f84aa2b2db9be34e4678115ba109336ce89918623fb75d5ba4d744904bf9776e20f510f5789d8709411192fdb8e6ae1e1512ad196e8a7b18e64bd3915b61e79058497aed91de1ff4a4b5e875b314b47add6a15db9bfd1617b18632abe97ca5a3763386174459fbd66d77809e20cebc2d4ca969e99fd3b3538317418d931468c1afee5c52d82d071d1ad94398bfbf27a0e7293975a31da4e4bfb7de695eb96f7db53d125cd2238199ba816524d9817b6984d2c6d592a567ac8c771c98f86dd7032db99777237337a4b01563fbce670aba414588980145d8ebaa179e9b4b04ef7f8317f387e3d4e3773ea1795ade359c29e6f7dd8d5fd8b57bf08d0c615738f0ac4e74a6553d59f02b4a2d3e1a5e1622b5825e02dd4eaa57e405b6a57c812a6e3645e827e8194992e0fd7729d5d599fb2ce3ce114ba158c89a08204f93958598b14d541db3d2d018bd10295cdfd615a910d35904dca8d0e64ec8677c8476632a8d696ae0414795b6032541dbd8325900115ef32d91d4f3011b4c5ced0617252b2ca52e65eee8901902920655b2513651dccced33a5e22de29ea32098df53a64f3b15f27fbd173eeb566c6ff875a04fe66524f2b639899e268296480376bb516ef79c373b39a4b2b5a48374d42a1c8071cd9c2d3cb228436a4f28c035f5592ee5c6a5ccc7b7e88fb814a506f46940532c16fc01850802f9b864149a63ed56643d1bbffa2bdaa23699d8c0e9fe7937190d63cedac69c95dbdf6469f3e1efe0a3ca82a2bf7b6b5e30d879c0a7afe8bf1629c7a02b32271eabac830f0e8bac1e8414f43b986775be2b5e5c5f29ea769206e6b600dff2958e302e80f0c8395bc879f995e33a51ed67a3f497850c03119e04b13c472cf683de3c628cfadfc4e66cc62ac990f17f3b6cc37d49784fd59eea95641d1947fbed0d0191b3c8eec769ea0c5217b46bfc443111f9c1c94d6a90b58c71876d309e1faa4f4b4869ea21f555ea0717745ab0551e76e8304915198e771dd0e2d5b4bb9a0befc7f6940e9f327cc25043718b93463e7169725bab629b2fe7c44a1f2c7b556054cf277bd9678ff4c64a4581c2a20ce725272ab2c4bac7564e19edce8edcee6bd2600181b1d41ff68bc02e1961321a54eee46a6dfb9fd862ad8daecb9aedf68ed3572a053eb497bcbd32d8e31b1a679461b2e039a80093e6d6e6ed129eaeef2b4f687eb5a6a14210b43c5fc9caafe8690b71a40b685f33669042d719204d5ad87ca83833545d3e30079cb13791ed541dd26fb57a264b0323879b0764b69e7a6e8b73b61c8596a51647bb54163610c852dc55c35ebadf9498c563d5860121605910a3dd9bca4b17176167ce2ab4d8aa52775699223a6a3cfd756dde48282fefcd33b0f932de3331c2cc7ac238199b8b9787bb6eeb3f51b5da3fee6304518efbebb58a20381233300bfc5e922c1a4a609ac33fd523c3a35c80759ad2b9d2e93cce4c497bb173e0d953010974a4b5c864fce0b6783d4405df952827e8bec1e581f33913434da203cf736d31398584c581980ffc0d5d40e3e008ade2f4bfd50065ec557c1a490c8ae6aaefdce52a5464555bd58308af4d5db260ff539da76aabefce3303d9dc09e4d3c8e97ed144028ecb17657da8c93524fdecb53fe691b477d1a349b91b54995132cefadf2292f84d225a58f492e0a5e678530a2fe266c8862196d1b4f72407c4c6794c2ca59a339d36e980019fd0f63fde8876a86acdc66ec29f228d0b3b09fc2a7079d7c0a677b853a58840ee394675468dea990cb38d9aa12b10287219f18b1529058d904132664f863c043d3cd204d514a4a470fcd55f3c9f2a4831e45baae169e5ad97a917a6008569fb3741a7972d5724505cfd58a771e9247993136e1ec9e3d3428adfbfb5075c65716737479898f537c6dc4e6a1ece1982c8cd740919ba97eadd7f1bc3652c7b393d1976fd7daa90c2ba985b8ce297244cb6575761222ec9313c93fc1bae3f0232b3268e55fb821a92ce2b0206847db5b9a1806b29ca6635d86214deb1e073252a8649bdbe6ad54176c82fce38302715ea0704eb6200a0d8ff722f6ab1bcfaace71073a9bb713b041fa99a9fc9b42d24cc74b9bccad8241cea2668ae8bdadb1b417cd4d3cedc30765359047bc1c8971e297dc2008965e83e3276df6fff0d98f741dc8fbb795c9736bfd112b36d25128c4ca75b6cd2cb5a522cbe21a20972c13cb20d8ef28039143c8d71260157ef407a5cf8cd9ff27d5021f7b52fe145f88bf51625d7f0747c77a2265e73d0732bf329e3d26b2ad8d0f94df9884452d375a47380201f517d666e16ed2d3f85c2f876e15bb7026cf665a341af95104efb51f10fddf6622fdabf580a4f1e90472399794c1242f4caada3a21f90ab93685856b37e64e87833e08f98edd4d426d21f7d8dc6ac5d0730d1e97ee574ed6a29ab40ea86747042f2eed96ee395236b3239d77bddbab28d4b21c20b8b6744b58843b7307d224242528a9b5160801cd687f0042cdcc7f2a098fc6b131826932c567ce2aaa95e1a1dfd99f99aa52d9a4a7546aed5b7f58cee8dbcda0516ebef733eb5f15f897eadcec9dd2ce56dd067317cfc3b3ce1065ffac328687b2c4b213aded0b1658bc5a4071529d8ff2df4501977c3409835e65ceea01191ff4af2cd7c5b0d1ea3a88ebcc28db05bf6fe5344c1b7182e8add1599bbb7b93ad3f8aecd0e79e1a288817be9cd203189bfee93da9c64fc624fdd0f6b15e6ddc583394aaaa09b06285acb59d416d9ecaa54e4006ca682a413ee60f77303c6c7a5f34d2f8660051a4114125b6d65de9ac410e48edda6e23d3efd56d9f8a307aabb68da2b2408ca7a2e7181c3ebf8e0f20cd18cc84f5a886ced83a79a1b46370bda9121dbdf8960767f462e98883a05db72af2fcbc70d01fbb3c7aba9724dfe5b0d330d63127f436ee759893a22a5d182b3c46f59bd75bc8ccb285ff42924ad9d0cea287786a0e1a04272e48ec185fb445e86356c9537531dabb0a901bf6cc54db8031fdec029ad8394a01935bdcddbf529a8627cd5f721972c7b3ae57b6c28e4ac6506aee3542eb82162c6530d32b16bb9814808ec4b0f97bd53cee96e05133e56d9a4e5634caaf69f471910ac78131fd5a4180bc53807a49ace9c128a29c1250cc2de246818876de390c237a28d44545c8c16ed64043bc7223c390e2c45b73e550f064ab028251839fec469470345f6ddbb5787f663a5707a1091cb69dbe16505174cf951aba8ed043d9a0c8b1f8ea329b6bc08196d69e80b2248c87b0886cd2606fbe8b47aed937210cc86458f0070e26e3fc33dd51af5e5b09917aa1aa795e8e0c282f2d3a46f31756fa2dcae6c9d49ddb104b97586436e1c7de48de5c2782fb55fe8e6e7177c66dde47c5e889727aa34b9f93bf3c95f2f809c18e0e31d7831fc8dca6a472aa0196f9e4e7fd7a33a1cd51cdae55cf088a61b44b36041e4fbd5d8bb472ed8249e3acea61c6c6c39f6f0d3c85d61f4c16942e92c53e82a136d5535be61f6eec1203002a4d64a4a674520b5e8f48d9b7f4c96caed22cd8dc2a297e1e4027e7d85fe033093fcc40cd7bfba697331d11377ac065eb011d2edeef2a8716311a3f8d11bb6440848d8760904de85a5b1ec7a98c07bd5058e6b0bff02f08b95356255ee6d77428851c72a6eccb87e9ae6b35e9e3602b05a890113cdbbb0fd342cc0234bcea9c3baccfb6404dec7d7ebcc3ede4ed6d94e1f03423d157a46050917982821853de20f01972f54588942000833d520033bf3e4664c662b8e577e75fdd3d0d6e86be78d9e870316d872860b72a09421c6354d62acee06cc3e620a4dd78f46f1973800e594a563abb9ef9b103f36536263658495a59124519e05aadf45a57d5367afeefcebfbe16478eb59e7d663e4da18a10d117bd058122906d1e1568dd8ac90bca40b84c90a4999b561f832dec5db5c48802e10454ee7b64a8226f231e0222043923cd4fbbf25632e09400c5b26003bf8f95aaec19756ad4f95d525db3ca9237ff1763a54aef260dfb87e75af233dbf53369cf9a8378396537cfa505ce90d7ffbdafd47f89a81e3d9e89ce3e452873e02434f9485c40382d704540911725255f85e69470a8f885febe889f4b0b5026cf3d93c1454b6ee6493370ed27e6e08365d890845520c99482fd80dc691babf2f073bc8de1a42449b8012ab0b12f35f79b394d1a8d0e51a96680c6b84694cc070e96a5e639c05d413e592fd97166632264253491ee911180b891c0accfd76353217b06b7bdd5a29a5c2c1c620d7b70969d43b8890a4797b56a3f465c63a54fae178fd2090acc9971aa3de2bbe75cedf1cdc1074bd5a54f0390111bdb080106401da96d54c4e2333c291d48635831563114c81b03bb89b3e9dea0004a2c4aaba87ebbec5c0de5eec79086218afb5dfe5f152a68dc18ac7cac9e55b411a830779dccf6af9ffa1a1fabf870a6d2a04c0ac55e024407a9fc2dbdfeeb61772b9066698d67a6d1c158e0351018450c1bd4e75acd7e9d95fd03680ae7a1f085ca870641d4a38c21d50502815c19294c81ae218900a1603cfe1f89a4ae8e80c2fd97313fdded08a00d7398e8e2d34125e9b1d0b712006af51089a2889abdebb221fc633c66dd12693f49a85b9d24a49ba205e4bbbd6e441c3217faed64ca550a7940a86140fdd4f62c2bf895b89270dd2210a0edd949e50c71539a1a95caefaebdea68dc2d5b890ca47d5e69bbc7d735e1b1792e756a5c7b7297c7d9bc89968ff5f568fe8e0c5fc9050882b243ca8089dc95c43a358baaf907066cf47b684181c180372fa3efa990d0df00425f675950ce2d6d79187ff957c3c8a06fac57834c27214166bb946ac4ee0d9bca156f1fdcffcef41438eebf0f8786b1c836fd8b735a22f9e9ef08e1b0234db1d14e954be553b7ff9a1efe9e7d7564b015d66392c8f02e4f3ce1d3e643517c2da69565a755bbd4e96a52603cc5651fc46fbf075a2a42af875627fd7853f55b1cee993bea41b85922b9fdd323ed1bd85f8b04f72ef6066dea57b5c8d9927fac12feae2a476e2a5c8d55805e0e4fc24d7a8babd0e48c3889caf15da9ab6f2325c027805e25dc98fc7d652615c05af4f800026b7eb812f77d3b146944de8756f76333c37366cbfedc9c1d4a7d4699f3f6efa5188415f5e835a753af9861fb133c8782255f34714cdfcbfa551ebafdf9d47ddbb311f7392c78260e4d5db8576ca1979c1280ed859815aa5efe15ca460594c614d3edae7677a3d40a7dc3ee27c001c53d1e2f49e4b3c021ee1c38ace6627fadba142b79b0b7e246e1efe3a333d6f4655e84c63b74f9d525656d1de1bb63a483dfaeda829ee1f37050b5a9c7f1db0d860fb249ecce2ba2732afe56fbf90855e2469276993f2cd47258e44558a7c4c8fc9eb33e00abe7388971530401e48ab804656d11d58974b83b9803e9caf2be4698daaff6bdde2c78a645fe3673be1f54be50662732bd18b19c3c69372a1bc4ab2faaf51797fbcb65e129ecd66ab075bc3d6ed771f7269ff03ee4df59b21f429c2e9d9ecfd830fa83e0e0afb54dab5b2d2b9e03bbb2dc1713602e64404303367b65e5fc79bef0f0b9b79ba97db769567d7995c1a084c8812cadb9089f1a7b4ec2050b9bbb2171dbae3ba33c236f09510c05d92c1091e47218af9719d47b38f8ac4e85d634cfa281bb53981d86fae88a7ed7680e75f65b42e5e4cf479faef51c758ae5ac9a3bdd7ac4bda60ce8646b332df0dc8759de26cc1b08fff93f63f4a057b7f2c0d7352a855ebad7bcf3dec8c692c5d9c056b5084c5484b5f0ec0a98b87bc667706e482dbb8acbead2f4ee63c98cc5aa6dab31d98db4ad39afe3b550bd8746f7aff642ebac81506fa50afcde9942c6769fa1ad053a11daac7958dacc1e99a35781da4dfadd1d6cb50f16d17e02752ba1783fa9f0cdc0c708a526209dee098b7ff39e32b8c79b2f157d980705354359e5387299ddd68c7135638f48fd13a2d8306ec37534ea4d5b09319d41a37a94ab32b620712d8d131f92a2b74cae7ff35e753cb0b2ce1eebb12ce8041728d01858c8a9955443f91f4fca5407a7da60bed80e165b653bf63e87eea64f9ac247b50653013fe46da3dd6ef6840826fd6dbb97cb002aa61863ab88301221441d9615674551dabd183b2a5b182ff9e96320307e318311ed5139e98afaae6a5f86cbec901643ff79892074380f966fe3e8478f48a3c0890501f1fb6de162db3eec4153dbdb81f4166e7bdaab8be58b7c6298ea428a3583060f96c39a55922a54b3a30dbdb674ed7858ad69cfbb6d70622f6215a01fb9b2fe1389af6734f73af7a1801b3ac34ff381305311c14f5a71ab1b946d16192ac566d87e2c99f580ffc36083c03076a7aa74d07773f12012b6d9c99d20271d0619ae7445a32cc23bca4980df0ee8f1ffede3024f6c7a6348c4f7f16cbe55345a556950ec5dade9ce8a78863c4a5181e51c8de9139ad19e1e8b4810b0acf96c2712a2b701ff420fd8a331da4d84cff74b440ec2073df977a1b3eac689f6dac9ead3558e1d830113410fa5a8ecf2719d841aa8e19913a0ec01d224273a2789ddeba562afb025bba9a949bdde7f0550279113b84fbc539ebe630893b030859c0a91c7520c3608b71e6b70407218cbab06a646ee04567ebe5825f2cb1d0b5da41fe8b0b949ad6ece508e7263283bb8e2f69c60054771f329dd33caef158baac23c82ae24aa968c68131e2e972f2207544be082febf92450f810a73ac1a492137d76c3ccc5b6525e222d31a52dd07ccc4b98b9b7299e0552a2fc474d2e2e737d00903aa3ac8cac5adae0e9ff1ea91fa47ac1f916d3f361690e4937d99000a0b5d2bc9215f928ad37068542d62ef81f0dc370860df3c597f4af8f9af395a43f964caa46fd4124a58bed439f00b7c27b94d1e26c004fe6a55c03f28fc264f462d1bc803a66de4672ac391941954b8511b5ec6eac9b66628e4fa88ee7856fbfad90275f23ff16a67ad9d10e8f7e44845e126cc7e129b0e4d73fde4520976cb885fd5acae732c017351f752c600d446871272cab58ed6799857d15af5ec2d48ace703904ba23a8717b8e36e3fdb27cb1004df618d304abc4aafa15e074bba893b1a64095f7af74072a2eb3dc80aa61176f4463919921e1ab5fa00027de845d8446c3d1d4d3db675681a492a46d0fdf5271c16b2ea9e641f208a7f6c2afd14a71652378ea9b0889bb172e46feb00345d60b626f7fe53db751290a40c911df2242c67e43a2e837d83d9bc08eff72847057e337be89f89e405425fa10366b2e79cd69876c2e4c1e963291bd109593dcf4fd11f4263d5d0a75cf54fbea8154f55863ac6976f13a42ddaee5396c8717825ddacbff0f8a4b5298a894edcffa52b013056a8cab3e9fd1087e8c1398282b60c030ba9fad3fb3d275a55773b0d6e1e5b8dba74dea1a96ce04e245a0e754ee6c0d3a7ae21e5485977785f8746b86cc12daef3e444ff4e32026879419d6b8d64413e9f130dd264d05f2c12488e4abe1ad057981eeed45bdcb50a4cdd7f210278a78d5f9893e2d07faaf5a52cc9c34a478071b71b52164d2b7ffc2dac1596d9f95605fd493c2f737908052477d4df96752ecf9fc51ab0156d824f149a77f55b7d5d3e75c443c877b22bf26ff79d1477fa3e7676edf70d7c24b6b277f9ea142337531df0dab70f1d2dd84ed21ff652cbafa3d56f385bec84dc98185469af4337802fc9aa573af3f5c94c9c69b52415cb5fabb2e9f083b5726217528f1fd976dbc66bcfbf7c908917e75dc3e5d6eb9c3f45c25fc41b9272a62a76d1be024c771a174ed9c48875777d898c780b2477e31d8fcc43b06d91fe5589186efdcb66a3feaa409a941e8a8f10e76938566f93ba5fa9e357e40da8ebbabbd2738f67d6197b817db8c0d520996d02e464630bb0cf22354718082e698144e6e80b3ae74c28bf2250a26c5ac8e6859f72c893f940e3037e7ce69e727f60e7d1532c243008023915b7c289a026fbe6dd343574c9467859b8f4be33acb482b2c09527043063dc38bc4da36ea3797a1f036dfa2621a1b203fce2ef11870585593cd0921fca0525e8ab9e2af88e4efaed88f9f4b80d82804a0b57a5e262e20ab02dee5682f487a7dac5d2944a5f2399d2904e1390c699906ceee3e69e0fec467be1696ff400ede0bbe400392702bca6f5af5a4c1511510d79beea46f2d293b08018c71117400d403c51c639ede5cfd18b85023b382bfcd1ea0ed889d8a2ff23917d5c6e9debf807f6c2c624e78d045bac0b37c221c049ec10b0889b2583d4ffc55d127e2dd85ee8d9402ff3c4dff2d6ff8ae84ef0fd7c8ad81e90f8983c2028ece644bc864c076d67b631ee8cebb4c7d827bec4dacd2e4c5c117511898f4259fa427093b8f65bdc6c3a6f3ed73681f20d7af8813ae79a8fd8fffde2312d058a1e58d79e8c8b349b500c71e18fa4d4b774399a287b90d6018f9eaff6b8aadd549de5dbfde10d846f3d13364c5869ed1c05615cc3db694493eb944af4cc266f8d26f71ea4b086aca7052024179b1452e327678ebde1f48cd8564049f6e2f0ead02dbe2f86c655e91cb2987ed0ac96449bd4c22383ce9809ba03d60bc0ec60579ede78ab30866c263813659f9021732421554037fa73384ec0d6befefb3a806272f63f22bbf96ff48170e8fe9682901af692c474c8042ccb18250933f5ba8295001db9e3e0d5f892f26ade60b6f7d4c857c4a01c016b9061ec3ad6331ba37e1fd8a1fd14bcdb92f1f443ceba15a65ef2790c21aa040302c7a4015a70f0d520bfc6d5a6fa35b67137737c899d73a98ee1f1bf89ee9176e6b51ec2e836a9a904fe026156131a212edba985d51857a4fb51bc77a2ea4faef336af897786f1eccb870196632b0740c36ef49ca8125b9915a14375e2429af41a34e350ed2760a2c98486cca9dd47383341fd7ac0bc1765bcfe5ca46da40d39001b9fc7b5c5870bd77ea5058911dfd7ed2b2e9a82400ea0912be84c4392a1fae1ae9fbab62d472cb994f586e9258ae84cf6c14cd314d5d70fc34e408e791370781b74274b9eebfaad4e0a9befcf925b9c19f7119a3d8e5f23cde8a5ca2005d1104818204bf83f53cf021e9fb8ed0bd598847e14e6d5f09ba5143df48867e2975b5a1acc67bfc60de816a9bda1906b37190f8fb2c750c128adc89a0db297bea790f7b4e68e8a0584d25c8d9edd24da095cfd8cac5aba041f8113120ad6d46242b1fe3a8f8dad99de1720391683fceb16fe858ee4b59fe60cee0d36fefdd1959492b314c2fcd2ce84c5e82e226398d7c193870c2e02c6bff4daf0ad70f003701c096775f2f881b278207342795a54c8a0fc290fc330682d2a59966d5674e14e138bc18535b85dc866bc96bc38dd5cb6ac311dc1b4ea3eaa2db3e8b1d79e3e17d30fa1182365bb5e9ddd736f833ce5825253ae7ee66b46842ea17a8c4733484cb9f911c5a878340e0e53c499cb667907db36667aff73aaa1a4ff2314cb37e538cfe863b8f1f1fee1af05c62f6de6bc789a5974e7ac5c9bf872cd583c7215f16daf1186f384640f8526474d6abc1142dcac9eedc6c9c6cceebd75351cf9338cc37ea5dbdc28f639a7af7a939fc68a44f89f291a0cd0cdfc08ac230f145978762b1d162409c4ec1cf4939964123db1cbf59998a8929a58b8941b2c05932cbf8713e768383ef0246d8bf9f2c5eac48420990066d6134ff85159d683da7c6ee85eaf08124557df4ef659349988624f86b8fce63ac2dfed87c881a97f54fb54beb3a4658303605a8ad5514af840e30fe78bcbc41069041c9d8b9f8e653cb7bc15669af8d6801cf3cdca22ef2f32657d279e1f8d45557731a4d98bbcb0b218b3a17003fccdab72ba6eafefd2f229edd488548ad46960691690729368d27f270e57e346176d9324ea9d74bef1790d37ce27ed89a9aa95683c3f0c94ebdbae2649f1f9bd809def7e9df70db778fd164e72ec003573c7000894fbabc2b7d05014100fe566a1450464bc2b94806f75dc926c775657ba3866073dc5c250422004d94c881af9f75dcfeebc9bbe63e6ed9e82b4548d9f90c5dfd1199e5aab4852e63bd6a3971ab8f2be20b331da56cbec51955cfc83744262fbc774fd45c03d111f79988c4f35e682217d8b0712d539770852b8792db8f31cded96d5c6c999d1c6a00c2e15495b2d03c960ab83e897c7c6d19b1651a62b0bc2c0e2a1404f98b6111582250ad8d436a4f67777fcd156cd0e042cbdffc8e7f56b567670df236ee5c04e6fdbe197d78d5583dc95491b81d2c13d7168eb9a360dedad5507cd7342101e2bcaf8b481be594a5be88f34fe642292249bb56580a9d23a9c65bd7baa3976d82a5044753c0c52eb802e502bd3dcc4a3214832d7e3e7b2f576f3e83cb16874161960e5c30cc55aaf08c936cf42e0ea35ae57c77c6575f6c7193b8ace225b1e52aaa07d505e1fb666290166e12e70ac7d479c1d3655f2fbd1c918d4054a26bfe41cae92b51c3fa59a42b83be2d13f32ebbeeb898dbbc331414d84d7b14f4e278961e9424d327a3c7e88f000272c0ce04340a4894daa635f812ad866f1edde6b570b72ac3a8e7d0197efc9c92051ab5f637bb43165c391ba6b89add4268175129359b6aeef901f2628a57cc4171fe868990eb40d7be6d9009f4213a20ea94c89dc7951ab43bbcf5c9b0af30d0208fbf5bde7614592b2a037fd54a6663cb12e00c134b9f6cf69aa1430b3bde9c15413080e7248868df3a2d93bcb9e614c703493290a45ea0131a4b0629ae88f1ed00a50f5f50b7d3e0abde2272c5fd15985fa61f54028fbce0ab815e6052e61f5373c6a937759e366b52e030ca16be10f4110c4ea84a69f8e5837d6add7dd7c96a7f4dce9f89d07f47cbeffd9c4ac659602275d53e013b89c7bd635a56d8580cfcf868f53c04e770c295a6ca74e3f3b6375530b23f5eb26cdde9d89b7f78bb315165206cad51c8c37c28bd0ea0d1c50aa00d10a284bb6b713a8b80afc70580c3665b8c2ad8f3a265ade4097010c646b340b86df71f55cb22adf4ff4aeb12a31d0d7db4815afcaadac6372c7928821650acb1a7fe2861b74ccabd78931a4cd87d3a55d600dfcf3f9ff3495067ab8270ddaabb23b536599ec64c453771958c82ceed6ca6e4230f30ec215992e593939d37cd7144c61efc6a9e777b91e7bf852b49e415792c00f38fb23f6e74cf4a67f377c520af358c3c778eaba385ae7416a6be79bacb7c61cd8e6951fb3ed701480ebbe3dd03bbe67eaa6c400f92ae1cbc78b51a91b2554b6f436ee955629b325b71249c07912711943539c1914c14ac7cdf4e867432850bfe17c8b5da8e15ea92d0ef4dba9803d07be36f1389435ab19fd80197012ae82b4d2ebb167ab1c99a853657e8a958d799efe0a5cdbca30ca5119994ba925757e56d1d2423c32e3c7ef5cb90842c0f50c851dff0954e5240884f7cf97785b134d7f4d31cca35b215e164624ac58614ae29f522cd977c0464c5bbe8610643658aff1ec0c7dc393769bfb8e1a8c0dce8a39fed90999d672683245a5e0f64fc915cf320947228f497367324304825ca6a6d7fbf276e6234a548a16572b31d6b03b3c13741b958dc43f9b1a2453ed5640b287498614823553247faa34e26b0780ae8348240696a217b9eb79fc4cf0ac8950687f741b4ae01bfce197d1e8b7917537e9935b821426c69d368d245e4f23c8a558892c0e6790538b79c08633c04533fd99cd830eeb06f12ed7ca19f9b306535a218aca7dfa5277f00035310d4f8958290adc1b822c3ad8612158b55b30f72a795ca0696eeb31f65b4e11a8c9cd4e813fc22f0ba3efe52b87ad48d1962cc2e8a60f728039a3f2efe507494aa6c197e7fb3586dce1240e23e866fddef97e706cd12452b64060117ed3215762d94b33823e149689e73b5c3c6fbba831c330bb10afd51a188a03fe548ea7902d1c64066d20a026ce362c91ed4a2708296288dbb6035cb510b41f384b79e4458d2953782a45cf378efd818e0953c51bbea6ff3a63d50f7e269dac7eefd784e7c507fe4474f5c6f0e82127d6721ebd745e2024c84557be9089b8d780ec8dcc0d26a1b32ccac64b37345c66d0cb7fa025ac66bd2fe041ce83730172b88d29f8dcd376c86ea9d329c8c9925e0364bb5bc65d2b6e6004bf36899b0bb857e6f15ccddae08fecc8ee97cdb97cf367fd7afe41c78d1bc3db44f3563afb558cff265753c9840720792dcb7b4b641c3a2752345837059a18285d8d710ecbceea5d16a7b45d35a1e202ba4bae0c90b9a10ddf94ed8913ade1bf7b6a20c489ed16ece8dff72e72f67105538de6b83e4ec5b3da79117f724b0660d8a0a63e79efd0627cc6a5c4645a8147f959c8b10b515d9bd0fdf45b09247cf794d7f31a1f880d072668b1570fdce13e973d52a8c671e1dcb09cc46f3be48370944973fb9d5d07b53cdf397d5794fdda49b128705fba7409f24e43da55e41be243dabae5412e89330a9dc53a8d47c8de2a2bdc0ffa896c63f7635e541a4585a979334c5b267d9e40235d68d900cca42b6a71691af8651d9abc1cbadbff9953f2b4a221cf8bd2d6622b21a5f72e1b307f67cf29f75a76eb44c17e030cf10e99f97ee4e6a793ce82055bc3518bb70b573c84ff7bb749c2e86187344d9412b352ace685bba5834e80364f05471ada3a0858522f67871df66be63eb3c247dfddb7ab5f5d23f05515188fcb2ac09406cafa6a66c059688bb08969ed1a43499d58eaaeb03aa6c85e686a431849afa877cb7b70aedcded04ac4402f95c0b2df78a23705e7294528bb753ba77f411ee8dc8e4cbbd1dd194c668e781e4dd3e9c5cbbb04027679aabf4f13571d50c3d387f2527879e3da26a8103b66a5019389441341441b7c35eaf0c17a6c3167e2cc31b845064c99049ef890e4e266a3642cefe3fed3460f0c7979c8553be81e201d885d8a26bc836aa5ba7aeafd16afcbaf620fd6f1cbcb9200e0153285dc6732200f3a62cc15e1f8d9ef09185d67995d2650dea4a64c459d9f43db4e601dd4dc8327109503f9f7df525221392f63de89275eac069e4ceaf05b6beedf278cb172c604c04c644e53fc10511cbd4782ccec37fefb2ffcc7e65c43aaef0d8ca3d98602cc021ff8916ac09bc352b7fcc63bd58f1af7e5ac6394bb9534bda03eae1a70a762e6b112d50c86287ab45fbf98e9c833c319b30e303054e76cf185951dedb45517d39221fc80e5759839a43452eb497020da63712f9de2043d774bf993edba437ff99275731063b99316cff10bad51529447484062f876de91f91f6661d66205e5e8bca8be6348f9ff4ccb20ba07d92262129e3d4bfe24a11f4444782848acccb380bb92d0913dcabbaa39f108c4d7e584c97bedcfb18777d20d7e290572fd58ea15184f47adbcefb029c3de0edd4d1e244d46ef9061dfb981e8e9b9739277d5f2e87132aeaeeee3b59425ff876336e5d047b4832b7e93750403d2f41c20a638165a0fb67bcda02890a021c7198f7514a1ed41e34d890055de91e05fcef744be628f16c77a9a1b287ce98a9b6fe0783cf9ad65be16ed759dac0b39e033232c2992b7617f30b2a0b8e075decc7e7b30e31b8b069b23a00159a0c6fdb9909fc021568772d0f41a33c3c50bd1afb0dd2d8f1c972309ad7fb261ee7462575a5964818e237b543073c7695d98f14f57596c163ff4c43176319fb305e7d285d4bac2a0af7cf2844717c3eda5cf60b2d1b5a144d60ccda6fce1d989698fb21c82a45c3a9884ff7debbeb4876b53591ab9cf02bb09e9a669cafcbf67a6ecca99e8efb57baeb949133977f526f10a29471776aa7ddf074e3aef0f80dcb05a37d38760c7aaf0bfb48ae88bb0dd5026e442aeb08aa5402b915a0648b0399b36ff94069387c4ffa3e3a87351cee015adf2efef6a9bc0cd5c6667d7b3b35ae68f2353b6526d72f3eb8e15086d98337d9b5fcf12ff05886e3cfcff23017bfc889a68bfb6b9bab0ac29809f2bc5673ef897a0e2b4b7796c105b02bb032baeb726236537b1fea019f74e2e7c5e50f26fbc95258f16e02c25fbb790f81a242063331585321bd3c74f5024d82661f8226bc9aba232e0fb648a7c29c8109f6b1667687f0a58696ac58a49e52d4ff1f49d24dcc267801f15ba71e635f6653aef6086978c948be2f46bc3b6c9648060aef4bb3ac5768c3305949fe8730ff5a87a747b975fa15e47c2f40bdd8fc79106f86c91be79635b2a1d5a9b1f0841e28cea5cc9ac088ff41f2568912c5577dde3ad7f86dc56206390ef308df1601b5173bd8feadca349d86d8e85a668cb77435be9da6399f400cc92408a6098ca8d21e61475fc5d96fae4b2ac763a0b68d8878f0b3b6a76ffcdffe409a1f81624cf8ff3879aaef84314bd978fadd1a63bcefbd3e07a4f351070b125ea0d59094bf54364ac6cea0cf04cbb5f6c80e019722d769a0568cf8fecb192ca531404aa98713fb3c822728d5c947b36206c8c18567de989633d354461235b9e6222f4c8a3fa22251efad59da0a7edf1fc0ff4e0be1afcfdcb1e562eb832f08eaa7b05ee7501f811795683f2927b0d799c5d3e355411a8bcc5d21f54f0102112e976eef59df0c5de5777b48578de40d422a103946e29c1fbc671652582dc632f39b9f4c5756637f73eec41eead029302728847480d2f896f8e0f320d7d0d2c0d544df9510e8c61a90249b8bff32e6f30993ba1aa2d1237ec42f32bd70abd2821d42755fb89e32110854634467ea73690dd0f620b55def167440fa4d1860add567d96488b6bf54a354ac0c6bc4c64567cddcad81a5286a47eac51a1a9eba8c541969bb7aeb67ef9067b09567649c236d306ac9a12e112a2f1c5754d1811b1b6d2123e6e0c630a390788f087ac68f79daea1b4967d55e9eb5e273bda071f439122b29a7b62a950be2b55fb0ae1df4220d89d0bab435a8e468deccf5af5485def4f602d01fb3132b375525758fd6877382fefb9d0c23c84683af0f46725af28fbb71bfdc6dd96135c36a4b5ca0aaba3fc88d80ffe1f499d1656310334a8f09f73941818b17dbdbb74ec1cf0adb760a9fe9f69f751d1674c9ca827d69bc36dfc88ce399842ac53b16d50bf369ada2c0c4e4d52dc562cf5fe903a53d7a1f069ac5afee9ece2ac8d8be0d787267c2f1382c241cd06fc366755c4fca490362735a78373fda720566214d116d2ecdc110caef6ed03334d98a532ec60c3e8f6202107c00d4230f781d0178c9979ff1c350ba3a893e13c57719fa82250ef142baa42b3e52a36942d51dbeb5e6ee6712ef7253322e3f4a4aca3aa4a6ff154a421d434bc6dd13e92cca21ba1c77c2c5e1ed36cd7619ec23279b50119db64d0632bdadd0e5c99461e03de3f917f7a7f7966a1ba9472214d10055327e64b0fd139f35c5780cdf1d9dcee4d1e8f760ea4314e9ed16032cb8f8266cd2d40ee52af7f2ce366b6b726236f2298f4066aa5d8517bbce82a5730609e9c8fa1387304eb16d7ca38afc40017ca602675944f0f5acfbe5d27b1950236c4f16ccbe4e3c8957091d0080443c526b007a93cb37d2935e480b60ed1c081d50b07fc571e7c2139dec960da00d1889af83b99f85e4194d5cbcb67c8263dadf0f2ae90de511b7e79f63ed0cf062e142561001d97613c1f52b1454b14d7b7026a651558d290fbbd420c69c5a819912d57991a12274f1b4299470b08a5d8dbd800dc63a6bb45a640bb387672851148974a3b6ff634b82ce0d56f3a4e28f756b0066e5969be702918a1f77cc4f1d49011fc429397f88f929952ae353d0019a4a91c7a9227968e65a0bcdd7f749bfdf5b7e91cc23892557896d2725ac930a0a2070849f4cd14923a73b20a294d61049239d532e29b251ba209eb2e5c4abe0951e09b1637c486b2daebd9e558bc5dce58bde6f6645595985773491010defd25fc87ffb8b6330ae76f156d0d242b728483de2aa0c6070a7aeb96a8a5776ae1e1c85f287fce780565e5afeb45214818d3fa4641c01ffc3dc7f457cbb904d43c6d5a924afef782721ff5021bc05d9664f3efed4fe5c3e41afdea8ffe5b3daacabfbbb52bac7065ddb05a0f0bfe51acf179c5bd2b298b0f276405a4cd9ce867e555f0a857aef810bf4acc6aa2fae9ab3e6959dfe796f5c29e1d5e37581468d67d296642620bc307f236d2e8a739c5c56cacca704044d8b9a663981502998d07d60876799835be183b8dc7ae98b2bf120001b6223926564468cbdbd6dee7c3553ee616a8bc210a07c42f39cfd4a5aa715e784446d04a26de15f5e3667acb088567bd9d41a3d53d785b6c700641d10746314317bf65090b0d17b2a913b95a940df016007037ec334975df39a90796763b313e31ee013bc42d7cea64b5d3ea693b59a4d3cd1727ae6d269a577fcfac64c3ccab88fb280fce2a144064d76eca0a42a4da83c57a17c4a32a0d7d7c635018ec6816e4fe82691535c3dfbe897bd23aec88f27d614ae0cc90911455de901697736f4e73315361b154ee4e20fcb2e983247ebae7408767264b24e1d09d7153f24e96b6fd1a9872a3ce64153b92b3589cb8605db311cf8884fc806387e8f15f4f511ae0dae1b8229824c8d75970d00ff6ac0f529b0d65ce54f242d5fe662596a0861a2c035b2c9537c5a75e9852f7bef766d6a8789142bdc1744dd99d421b3dac30e347faf8c70d9b949796e7e196c3ce3b0a0f231f947b8c117db0a7234eae622ff5d7bfffe940f3c0e1bda1680dc9a3402b62200a130738dfd8ea921d0193680a0ab58e30d8845650627b50ca0578516d17f5f91508bbf8bf06ad45b4b267ac0de1b9b12f1f55a57b74e443b5b2879bb781ab70153ad598f97bf917f5df86d781307a396dd71a5b87790a6336f4834f86eb153c3c39ed101f1366c2bb27ad8da5feb2f03fe68a3cd1911d499f5459516d752af075b37478be3de877ff6b35e3611e7f9de92e6f8f00cc490087dc4bfb3cad533166291a2b1976842ee7b00f999e280650aac6351cc0ddcabba5c9468acfeeae4b689fd1567fac7ef32ee16f44c86bd2569f23b427229318e5873941c9bf9634c9f69637d7384787e4b486133b74709a2c101b95ac0c6c7852744cf5e7667af0f54fa5cdba8afc4a33934ebb850835abb7b27acff0486ffc43e217dae61d4c537a587a5409e0d4dd1dd9d83f138fb7dab0af64b008284fa80446153f3f05c2c76465643f5f903d3c152caca0271541e85f9f62cc1cc10075228e542acb2ba315133e4","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
