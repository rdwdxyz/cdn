<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ace49128c1cad8c881fe1dbb7fc40973c42b9fd9fa9efb0e09f8bf17c80bd91927ebcf122e1d024695a24bda0cb3bf889923af99e5dbf3bbe81e02f9e731c854582a78a95ecf9ea3cfcaeecfd0bdbda25f062ebbca2271473eb6a251216689d1fbd22af8a20ffefeb6307790a3a96c368aee88ca766a29cb0312501922dd2b709dd6eafe94ef6ab221f78ec54282cd90b1a6ba4f399809263bd2b86fa699ee457b3338ed9f1627826d1f6b86aa2bcee67ab439090ee54adb8fde193110a103b6678f9ee7c0d650c9e9e590622e72de4d923ef48207c55861c3d56b07affc292ab0467caa87616f9c2cda30942c1cebaa0b3624062d011daadbaf21f616bd6bea1727b2b413479e1e67a9a9c7dfd84d8cda9a3e3e01456d5b5b6b40d8248036e5d106d6fc5910872d42f0b7f3ffc6e80bd23f00ab79ddacc1e4af65b4571166beebc9dc5f72e52c63c5d8396f17bfc19b7f3d3bc055e833d512ef7aeab500bed55beb8cd1f2ce0c5fd7aeccf53014860e44b98f8be8b074e340d7e4fbe877e8e38d7b6f1334ef8a92eadff39350e31be197d7cdf55c30c0b59ba737dc24bf1a06b90eba4d3deed9ea0358dcc8116685b445dde8d53ed53531196c8a85a8653b2008fa71ad27ef56e49d1538dd37865f9f9b8b3fb1fd7bf60a18de97aa9729dc88246673db263d89efe492626efe3f74174d242112c65b8aefcdcfe88c1b1b868bc996f1ae306878ec65547a5f2ad7c1e1533541c008b2f7e0a1cb346d2bd4268118f35b0cc723d30c588813307697094d6d8d8267acaec12bd5846534fb37c1d97d0fbbc1de4b2e03de1d75a10f0a99ba7f9e548157f68d44d11e2bf399a63eae1677171c5f7ffadfc1528d0da87bf3f90672e0d63eba6b71c4a851b86f16502b25cfcb023b4a22bcbef6895d49346721d674ac623fb2c103b6e421ea97073e1bc3d85c5fde74b141b61c456e243e63942d52267ab7474529f081977a72d762c45fb1d7c045ef031be9962e91d91b74849c7e51868c625f5d8117092710abae8f92c6a082b81fa6bf36b9298f8829ee1be0444a4395fff17223ae041e31341e5fcae8f654f0e43a098c85955fb0acef21d50e7a98d7f7f7cb5dbf70e1a2eadaf382178219dc2f597829a0d43e62c9f00abb7fa7c9fadde7903a6625fde0be748c27412b11ff846abce34c5b5472b8e7d78c5381394d9bc12684667fbed553383f83a1927f13d0fd4970e2628ad0626c87fe5d411ec8690b9850c46131bf70f6ea74f264ddf4ba7b018b730530d6df4582daa363c8c4e6c2d11420a13841e62bb97b13ba679def7cad7c23a73aaf58038a6b4a35e479ab86f766a8ba4d29a78a55b56f52240bd1323db2902a338dd050e949b9aae2ec24c596ec95cdbcc960df166b56f1e6a9e662913ab596b194a4935471f7156b6a6d211fe65766e81c44f8dd372a0ea6df38145431603d44b5aed7355f9fa3927d2435546aa609840a81c25dc14d6af87d22286d7b6af9bc390a49c071ea9df4ab9e27ee9ee0fa9738d5af738c5636c4e7632d8c8176054a92e11609d542b779aa61a5b27595d71ef4988a3111ef53dced7a411611190937c153d5c8cd501473c46c39ad520bdc3ade73621de17e3c433f8701943b1941a12a8f4be653ccf2a03194cca23c997fd6a47232c3640a15f654a706d129c5f20ab67aba3f23e3f5b57207e4d385a24a0e0a71ab6ec561cfa0ad88b083a8da43894210493ce2c3fc5ebc5e75fc1182b0680fbacd4c31b522398e23412ec864f6b377ca92c9341364fb59b54d9cc3e5f040f58227112a102c7662a47f3a071dc9faff1123daba933f2b6adf8abbae0393b2fe874de4ada816bbeccb7ebd342f7eca4ccc75f4f173e7a5cd432fb3f9c8f240cb796a3c06f1f70adf66b75a47d303ca3eeb86c11ccc6d504fa6fae54a712c6ef310c8a04b9cc5f13dad40b9c717904b0b9be99b4168dd34a29dac07995fe34377c075fdffd2c65446bcb7756445b0dfd2bd7f31e60e525495ae808911b9d2515ff877af3f51ec4ccaa82df0a3d7b479fd85bf402d147e7f5935ed05078829ee659192bb3d17fd12f37834aa61aa577dee1e6995b3f11894d41ece96e9cf81ea80ece1eb88659d7b7102a557f45825546516242b4c79a415e0049438fb517d8383925608793142a99d09247db6da68095f96bc3e5617a8e0d746b1b43eab37cc044e27762b5d55938be7a1d0b0af75a3aa3a8dbc79d4a0de058d2848f3e60cff43e6ab3d04a7aaf73e922f202095aec27b795be29d1013d3c6ac7e5956d6ece4f88f9ec0f73ee91a932f3e890df67d0be8b305f5b00d1076af5d8d862245d1192af137ef7efe82335d543956485f6851374f6a36a66571a9b37a4b4be5628651ca79530ffad6385b97667c267ba9ebea0043060a18d1d3453259e1b5f586ef04ede53b91ea5566106c420f56d29d64b2bc9bd3b1eb6000e11a8ebb9880daf34f0d18a03803e8206a089a109c0af5177e2565d8acab7dbc6b4698b26f1f3d87249e6f70402c710da446c1592d2177d067a9bb8fb5f1a4e936e2753808b93184ff807956ff0ded03e4cde7ea3603edcbc3a8b71ed4a7841abedb0553fdf9287ecd41413abb5ba8b1c3ae73cfd51873364a31b7833fac35602b88c61eb54ccb4da89b4f9db14d4dc7833ff7f8673ab08cd8a187301eef24bc102dc80d21e6d06aceb782b361ede5137c36e24d7c05fd5f4e555e97c116c2f0a4e851372be7ed22048eed1d7939226cc8caa0a4833be53ba045c05be49cd4271a4ce3d7110a046c87bd23b9a66c4233ab2c7dc8beac0bff05f43c9b58e539bb26e899a9416daaf214ba84d6288daf77fb5d781fda54a5729afc1a2d24e220b4172cba98fbddc63005309ff6163ddb3854f792481658eba5611a0322d8e4adffb4b9eae5b6360a5959c566365f65091459a28979f11696ba05c983cd5fad2dab00cb7403d80f903b4398c0b213cf33eec80ff995cbb8e2a20b9b3d70ed44649530accbdb4eca65662731d6df2ff7c688a5d6342c8d40a8149ef68afdd7885f504fb830e0d613db81d557b8e04b8616d99a18957e2f92ccd6236883c9eff53e6d2da70129f1b30556fe32e89157cb2fe84aac1bc0ea1b2778df800e16b364eab9136ed7872e15e1c890303f971cf83e3c5bfa11ec73cb1e5eebd3196810f891111ca039c8d035ed26b6b6ccf6f7c3a36fc75ea8c609ecca44d2300812de48979bdf07dee22c6b45c20b8a86fbefffe9ff0e07946c0b4cbdbb432ac6916ce9613066483237a4fe3cb094474226a5a569f3292e673385b5f1ba761fc3530e1d8c4bf644db78596d6fb4115bd3c32522d348382be5635b7f2f2212a8c47ec247adcaca12b1baf608faea307c3269e2a63fae1f82f23a73bc1aaef3f105e53dfad3c15421fe48ef69f872296c574fe16415f2f663af307bf6a1f6858e7d4327c4e651202066e191cf8ebfcce71ca3eea994791cd0dab0e6e0f88468bb738470a646fad4b22086eac4a967281cd8defa86345129985132c04da8b20a286efaa80a3d49b031a10681daf600989608616160b6395270ecd7cb2fb2bb1984e81cff669e3ee7d44cf2860f622f7e5e864ed443a14df27074d96ecc0e9d326b9d86aaa08eb58da789b82d8a0f092552fe4222af9e1acf51a0bfbcec376adc151bcf13b89c4137c948381ef37d876f0f780b852675906e6a54ffb1527f86553e4948793259c528de4f9c2292dfe81644867b158a440009747dc66d84a06d34a6a233649ee8a8c27b08f7351764d69bca560b05abb9706151681d9751708dd48df887ff40548497f13a7819738ab85dc9896e63a1a0d5179bddb428751363a4db248368a8e76e28f53e27182846dca66c1be9eefc29babc37a2120986d5cf78e6d03f3fead325ca906567cc9a392d12f9fa2750b4a21647a137a96e44a0bd95ac9f5f0c350641a8f02a5ce3461518afb4e9ad67b3922fc2d911e3a32ff65c08000159ab902cdf8d4c788048ef67a0eae79505e8b60fe0db9401780f99179ee387fd73de699b9b0d6c470ea5d5fdc8196e6d5cffbe9cc97ff090da4610dd16b0984fc14d9bf1405fc12cc4d0aa65158849ac4a28e48a41c1703c0a1e18d332b084bda463b91346eeb0ee9ecaf4ee7d7ee8cc2c8500f2ce769f00142920d6bd2846ee44bc9d6c987c30a7d5d3574c4731aaca291522c0b8738ddedf09e3f1ec7d57a996e89cf47271727025e2ac057a16a153025a732e35326d889b0dc6cf0fd7a83356f613f31680d19d8c661882ab6a8fc4ad593f529f0acbed728669837fe5bf12464ee673aa5abe415a3e8bd2ae84cc08dacca778ca7b979103a5c3f742c576c6b8d98ab8f319c00b20794bf40641f544845c6207cb5473922c9697f0b43791a1ae1044ad2d1bf81c881390fea9451f2d9233f28594ab18edf44289fc90d88ee62d3ebe6b928987a64c70fa77954b1ec5593081e7141e62663286a7bf1ceb5adf1a389d33fa0553f3a7bf0f103cb0bbf7ab386586e0629106a47240870f503088359018b94be906794db3cf0e4df2b5ef1cf3773ebc2c471572d809f251d32975802a218ad88c643014b1ddd551c8330eb2ff6f726e1699044e6b27dcef9c67551e35a616170da9ff5068b3c625936f1f6f4b493abf9b882a5b72374053398454ce721e13049429bd6778c212a2758fc215f7f8049fe8f619531a4427459c5148efea3088a13f3e1e9dbb4970c0eca29fbd25ee3004d4dc342957faf8cd60a2cdc994fb3ac7322b66d1ecdc1fc33ddc8cb1f03294a0d153ed589114525ccb3eadfe881e2757ec8a2eb01856c07bc0d9565f7b5c71168806056f6533b203bd0da9884591bbb0007f6f23f82f5d4d2a590367bfc9b72259ccb186cb238eca324901edaf851ac2a5d4eec14766cc75edd47f185e2750e0326a92d4d15bd77ef9fe573a00699a8345654a74911f9515cdc6a7ddd0acf7ef2deec5839295c4fe2b7c56a63d8645c0ddcece7b28c92106d26e5bde4944d89fdd093a3db59358505a68855ca8f8acee9837f7c01ce039dc08fa6e93ffef53b3d7641018be3de3eff87a9b8395b5a1a1b5e2e0ba8806b9f02d9e8777934ed64eacf14599ac0eb12545bb700eb6f37e7f71d8c63499bf67b1ea03ebfc250592e5dd4d730ba6ae4103e98e75f38c7413e566decfca62e9d094c1348830fa87fa9f655226142bff1c94c10e65da0cb5d0882283ca4a237749726ece9e420768096e083f147762cc00c6824b1c3069d077c7a9447104ef6b6d638c2fd28b89925d8f2d4501bb5b946362fa835c14db41206dcf6317f2820f7c07e125c9e6483cc1c895cca29a1ce25f7937a2e6388631e40e9e3018ca7f6027a1f7212f2bef3574d8efbd628152e576c02608aa61da322a23a9a58be7879d772199cb81e3a903e428f63cfe836bfbba31269d4e1c39dee449073d294e7c049d53033b04cafe81e377f73f89466b505c6a0fac83a2f7182627d9a22627444eba071a86b7e186b4aa3245c34ab347ac8e21ee645a0e39ffe504e826d636004a29fac1896a6dc349f81cb20c970d89927737fdf35d9dd8af7c246feefa6f5d5287160e15012f7c7a92afb153cf84be23fea314a73d52fa1b0009f0d8850ab7c311df7c8ad2b84556f8c8fa550533bc9aa8d2149c90fe8120525027da0a435e231b79b7eda7351d3b1de247d3bb06cdc9cf0f82382b5b94cb501a007f1e7e57bef99d299096d11c55184b259aa9e679bbdd821532673934e4c170e909e98d182a12512ea5eb9d4353fc22c58cad25fff718253af3743420a0444458941ea977aeebcc70bc80a769ce55eb3a016d9cf5595fa9d099cf3fb8a1e9a1eaf68f4953fbbbf2ffa29cf5dc9bc656ce18f697173807f9252352569519263bec08a9a46c71e5cab7c9ba31e4eccb0eba462f52883337c02368fa15d2185386abb26890aead03d4232abc961caf5d3329489e9cd2e1efb5c84bf199eca82b7770519a1842e5ffd3ee3ca0f2a066ebf1752f11ab0fe4c7c3da5b6a1fb9ca66ce28f87b94b5bf55b5d4f94e5ef1cf677733faa826d12b1529e85d7d5bd4e8ee2895eb9666687160edb6b64b5f2196683c69924d9b6607032f62080c37608f037605ba13c15ee0c9b12d004cbe88a1085498fd14a38cd072a1c9eb0cbe199cacef6e9a5ec30a4a9d07e83a4217c6d0ea9ce6430b375e75b7fc5ede293e63f3f55edd2c0d56eca81fd1396e6b54cbcf46ca91890738f4f45301d91b812e48e7d3272dfa3f7ec200ea922e53fe25558a53d7afd5e952da1178d1e5be795185736a65c34930c71f074f1b3c07a98b140f8c3d6abbc2d8804f0421bd48b4e8d78468f3379e4e6171baaa1d0e0a6859172da7eceb0b6cc36f55ced13ecc0eb731ad01e6a40497cc9252856e1f97187a7fb2580d404b7b861f50e8d89076c2ac7d083367bdde69973fdefac5450bc05f6e6e96ebc14776f322b2b794f54aab1f611e0a05ba39d2b64676ef551e27487117d01451ebab30f7df82e464fc6cbf55b02f37d1fb30014938a70f20e8e18f55ad5bcd26f69f4a2ba2b37df6573de78bb5d8ce7c1e2de470d65deb61630dfe085525ec7a265421c8226e1d43ca0727378d4ffca12d2c70921b2f6c7d2061ebd931c347b3e07d84ce7afae58380da3385e5d6e455d0a70b6bf7984ecbc8f180ad724e31184b9877a822a1178158d32f28060985b12d3e71f6415b678b5a8224c32b4956daddbfaffaa718b4cabf293b78781b44c5bb7cc5fe417c51aa4fc8bc173ea62a60a711460c0497254648176b7805f81a3fe6238ebec1a3cbe30ac80e648416a783a55ad77051004c761e3e0331bc99060a1016223b61ac9492ab351a0a1d27d49ac74f948c84dcdd418168ed24ba1e2292095c141a19e8e738dfeb0486eb5567ccf97324695604697887175287d77c9b9233cce0da34ac18b35964f8fbd590bae993c784e9689cd78df20ced69cdc31c5c745c7aea1cc17b32d3503deacb5393d26bb0d5092e0825074a6361ad17aefbb1ce26ddabb034eb439a3b14b3967a90846deab3c97e3d4b0f966bdc201d6006833d6fa594c732bdaa153cb4f34dd3f6077b5049ed5fd45b5f76ae6eb3271fde7582a80d0277ca6559beddf0b0539be217fc048dee06d2244b2e443facacad06afe17ffc20952ae979aad051f251eca410013f15f4786708709856563e173c66bbf85343ed6ed0594c8527374cef4e232a5bd9ce7601cbd62d831af34f52f6b7e15f4c0a50c2c4f7b142b4624e589f7edafc86e15d6b556eb7bca1c4529c125f2e966739cecae1b0df5ab18f2a4a61b36078704940d1ed1ef98e1888bcd4957f3ff757dc760ffaa982d268d7ac829081455dabd2aca33e54e067adbcdc46e4f53e4f9a84024df12765c3424293bd43b918e4e7c2477885f93619958f303f53fbdf3b65d0d2538ec9a3ede947d1c320d8975b394e4a9b94c9d7b420d28b3752b84e4e547386a386d4d13fcbbcf7e8da21161fd3e1699042903750c2d9024a9ccd2a07f20b156ba707068e99dcc78521efbfdd2e9a056ac8e6eed9c23ca981e68811605fa91a052ec89e63e2ca535bea885712159c8c0186fe00311d3782489c328c3ee55560775fbacc58f5cd4497c442eddf2481fef711b5b948ffa56e085f71bc5e56a79d205f2a0c594d72e0be278e58f660a45cc9402b2f6e5d691ca82c8d29105223e415d6629437fe7fe5789f5d798e495d42720a3bb60c6454d736f7647e2bc1a9e4f82cde8485d9f8147ae5e4cb35c8fb50d31d876f305f7200cfd976839865b438f69d983607938d1122f83ddb4bd086968a5d050bf4be9ea947dc8cbd91f5845324a29a8f5e90044efd64aa3db62b544b180ae4b509bf5f4d1f486318c6ee84449b1c6b2b8f420d9dec90297b1cbff2b178eeadd1e213c12644b0128c6b73c0086a5231bdb0b10371a3d0e219c68740f8e52f09b7d64e625fd2f2c1bffc64427cece07946c0df0acffb3717ee32e7885f1753ea381324cf3e0eb22532acc7cc7e41ad85a335fd95086b84fa253fb9fa84fbcb4d009f7fa12badf01995f47f5a51009f867e80542a73da4b582bdd8fb0e6cb0b8884b394a6bb10500c839ade0992dc1b45d2d79b8ecc15153d7f173aaec016cd1e158f49c65473bc73738e443f3e95af08acdc11007752f0cce48bf6bd8f8e60e6fa3830d44e24d4295fa7ad57dcf5b5028f676e19cd879b02e30247f4c7f6c72fb355ddaeeb5372266077ffc9b6187fa1ef287366fda0161a3e1e4b732f3c8215a635dbc947caf6322016eb397d3e4642d93179f2c56ef47fd02ae393933beafc5d62454ead524992188470b59936aae59a3f863596165238365a6655338af15ad51ccfce744419ebe66376bf8e51b41cc52d2188f55c0551e3c627fb5356ce016e6eb4f6543afac12ee1904fb387a27f5bcab06da202b232048e33c0c85d27c154fa4af4a7c93e9524a0308ecea16cecb3ee6ad57f822c03c179ac56e3d0796cfc871fa63ceaf006ebed248d6fd72616a0ae264969f26c6088cea9fcf7b29280cb2d4a9299eeeef158f324d0726a505297b36e039b8042e39da101cba6ff30aacc013ffb0d347c8b76696ba9a3c2fccf4e134088d35b086dc08c6be9a9fedae381f5efe499868d2c4ef79635a637595e6f16bc131d831c0e256ed786cbdd0021863aa1839700dc2ca1ec051b6c06e0bb7314ff132a9ad90060a41eb0bcbdb1c02a3029edf6886c92ef162ee34df154857d147cbcc9c5f0bde8f7d1afb05f7268ed387f1ef581d7a6d03516a0fc2ca00eb2d0aa92c6dde8d5116c13be1c15152f37f1341edb17b59a1b4da1847b1fe9fac79e7cae31ee2bde0a5fd9fa09643dd533ef62555c6bd496aa19ee308ad9e5ad1135608b06dbdddc8c2fb70dadd5f7c0b8a20a04ee89ad8a36829edc2b86e820d271b770033f4a2cca27a704641ddc507d4c9ca770703b8285549fc20b658a5d03265f2dc197e9b51bea0c12062ceb7b0f9532b6e6c5436472e0a1dcc7d14e0da42b41233e6e4952563c788084b33a1572e0b65dee54b0a688294c25130f1e3ff68dd2c64a45c3a1d4026aeebcb17068bd91a680be14cb8d108ed0d6a334ae8b0c55c592880cc37fdb58ba55355ae1f12eea2ab0c8a57cbc09cf7fa4d77c97310d7809f8cc9f147a3d69603a7116f3206e70e325575ce0a1e31134721413e31602bdf192c45ad76c6eb2c38a329e543d7af2c55ee6cc050b259bb551a2bc5e4ac1ba534d1761e10a66989997d68fbd54163e6f4632b3a70291a0ccb564fb364f6a2e01b8e7f4487ff73f9a5428c4f4e0b8ec9f2ff192b53c513ae553acebb5f61d7033fab1045114fcf8664155db8013d6d477e815fa0c7d087e0f3bef310a5413207c3b4e3d5f834d02dacc812069db374405579ef5dc05f55e2cb0402320b428cdcd907c6c8e4b6c14cee66bff65a5461f6f5c1a38437aaf5dab6623e282095ce0eae0fe37c2bea5dbbbd8a15bd6d298c00abb7ffd430a402a7bdb82e6baeaa0809ee5b5980ffa406f5ea432f34a2774c8996d5a8502d7d9d002a8c1d87ab7e858fad1d7f54bba9a3d8bc4560e6f2c45089adfde2781ac9a957db224868ed9891e5c154f21a11792aac1cd5587557cccd4cbf639eaaee3413b3298aec46d3f6d5b14a26ab03894d80be246b6e90bb12db55ad0ec0f8737713e904cc512be634ce75e50bd701eb077793a10d28417b838fa64f9aca17d59b60db6c18506eaeefb02247027c8fa2baf5cbab99fa5b9868ac0372357c14fcf3427b5bbc45ff83d398bc19c67c2642462b5dbaaea3176e7cc5394affb14a7adc328206ac9d3fa9bcc8922903fe64f350c75958a1f4459b18fbdf0fceaf3c87d11a6f80ba0e04ceb79eaacb328189c57c2efd6d43fc0ae3b1fbed79169649f1df76d2e6a21f11f85009371331d64a3fe4b504095c0028a79cccf6c80961e3f8739e91fde7e2a0e5ae902badd81cabb9f64276e72a85b1c6b5b0c4213159bbadeb99d9746991c29d5a148356a88870560fca3bc5bde6317efa3fcdd7ffbda3f68db6d78966d2ccfb5c11d4ad186b377bd03a160338376d0c36309eb62ce7eb819cec097a546af6aabd5dde4e1016eced103fde51c4f76e5e3fe972a53a40fb5473798cc8e23e498e9d0c2c644976226e521a4a1e0c3541e74534c709aae19c4861356900cadd48d078bb9359c777545465d4b208d53333b61758f14f96bfb308de1548a65ba41517ae42902a046715cd45b318f9c593f1d8ef82c30a2e31c1440747f7258a8c9760d1e7f01104ee6bd6d3bb3a799a98c479d26dd9f9e28b71641a560f2092e7d03b2e6a1775a20478701c2e003b672dc689386fe70ada98746bd881795eb1757f9f636c50b58e57a68138be582308ef977c288e831dcba96c0fbf0a6eaafaf0ead290a0fc52cc334c749edc49780faec6e985dae6b9691801c332d1292ed0d08172999edaf81c1de10d19f276925a0bd23a5adf09f8e795449c894d8c155ee03868486d3d6ef7f6b286ab2bef6f12a4d6febd8b6b0d51373960bfd173ae0bac7f21bdee1b6b56218cf2039b3a182c156ba0995239a46398377c3e068cef4498cacfec5f1ffec03187289e936332dca8db3962d07471886e2c4b5904d7fce6d44597a14a25a0b4b0558aad949201886801fd1e9e28824cbe2fab0df36a4e58e787335a854336a8e45dca7df716cffcbf50b17b3dbd6cfe173259c66c61335cd70f8b78ad817e73cdc32cfbece7794e4a9b4b6152b7ecbee758e2a651b6cfd16831379b749fe15d56dd2f40e1bbdcbbe1e38b881e68b09aebe4d38e83582c19f913208a1596d107bdf117d9923457726310ecd657e337a9cb49742453688b18e91e49ec70b036439d917d45c877a6cee03c65d9cefac37de2efffd96a755dbac37f253d67487a5c0e94c3fcb701cade8f1981474df771a1ba86dd7f2f2824a0bb87ccc77c99d7b2e539d5b65d0f655c9efffafc92ee72a11d4b5ff6605e4430e49443b03eb6d6dd090c59c9d2a974fa3f9719560f495e4e5369e1db555b365b9f240146902bdb108566543e64d560a8862bb02ce5b3908c575ff5e5ab02844f83a17664c73eb02fe7e1b436ab9dedc5479892c662ba39509ef4e0940cdf036640cf8dc5046f4a924bdec0cc60eaeca169bc50cd5e93f80d6d6d0b71ee8735aa1f7b56275cc4fc4f819c5bdb1ad0c3f56e5196e540a6d1fed0ed8b9fae043ce384ebd465739f74e3fa397fb759150c531725c2321df12548adad8dd6507e5b1209df2a56bc89e45927e445c946b9ec74bb026c6fd883a57a29ee64d85fdeafc21e67b18974ee5ce49a685def92a12c5b2d0baf5fbf3385893261af4fe104f4d1f5c0cc74057d8108fbf2ef7c25b2e16273ce154194af09f4185a316da90f474d0af85a6d284eb6714211da23eeeb897b5f229d3d960457af559ae9409b56e85b383a276bf20c5165571da7b0d2c558956802a69c1a89ffb6ddae438a29331e8cba7fd9e3909b59cf5e03d2bfa4228374161b86ecc9419b76045207b2350d40c3992d9b6158ee19a2339c19243c4a8e0db1bfc2205a819d0d18edd79f587189c7d38eaea8fff442a4e047bd2a84626a61f99e2c4176d799e2902c61c6d32c301f739fd9f331cfd502235f58168ad3b86a7690ea6b4c4964646e7cdfe5141ed473829ede9d73ca21994783e5403c72f2c5f546d8332daf1850d7707076a8c1f30071196291939fa81aedf6d6d45a0aee4c7e2481b33bd39448447e4511fa365f921163595b6f7904d23216434d50ed124469cc1b77fb2f3a28fe37d83ae7628c872383c05ea94b4ef7e4d7e7785a93778b324447707a30a4466b81ccce478c936236bf011d02389d3291c742804c7aafddfa19e1d78e0ac25f62a49fee87251a37d8c7d523ac3ae89bcaeffd2ef87e5a0685de62a63fc9cccb7f4b23c792bda06d28bd18e8dce99116ddd6ece0c49bdd3e83b1ebf3949dc21e1e343f724550c272375fa8ea59ebe0cdd00dc071ddf8942e950ddbcb7b1c3b0644e4145daebc27a0e21f5b8c6f612832b7e81460b995f23306081c657264083d0fe1355d35066a9e8af5ad6bef571e3d415a8a75e9093a87510f34811eeaaca3f7c1efd1af6014b7a2811c87a2d4c9a3386a03208f47d28eb2808b77816ee7e6018b4202bfac59b896e43395623b4254799550466450ee84b30f526230adcee832e1f071ffb0a5e2ff96d14b46ad4596b6c219f6ac7f505e78ca809dfe660d20a8a520aed433848247f32136eb33941c99bb77c06a21c8aa81e0bb923c8b9d5a2bab05fa936d030314ba128276aea39b00dc9accaa7ea8375019266f3fcee80da88674f3fc3965402fe2f995946ada128ae46bec77bbf80bd31fb85485e469b8ae94f2f4eaafb754d380e8dd2fefed42e37deb03191a1ff7c29489ea9e052480f6c510386e22c39d6f14d829104f03efe64b438798a702c62e37e9d337169565aed78193e262bbfb551d5ee5df7c22b561640acb7b7086656ae766286fb8582feae0667a8d648ffd0481e5d06afa7ec3939674c5799b0987842b3072d2adaf96f219dda605c1b95826fc6f712aaa83c5dc160e31c273652b0e1ba412703d14c52bcf59e3fe882f27554f29559b7aab1117c065c7694c09834ee94b7a5b06fd949fac4959da248761665adcb65af6ee8f3e37c9038ae0c76c792d10e4778f647048437e88c73a827d99ccc184b0fbae9329abfa5805b8caa8ec90f2c59fe7c742ee5f2a6f122db0a413abb67e082eececee00fe48627ff26fc5d8b279d13eec6a1ff39c9b11636d8be8c469027550e907b683a36df11332d22e2d1be1fd678994c19698b1ce4e68473b7768658e21e2316c8f08aa47796cdb7837dfee3b802b8a888ba44ff239be995bb48c37de059700155cf7bdd7f4b2cd616051c6364cf649e2db1c04aa33900ee1875afb24aa8bf70499722cdfaa55b1f3f3ee72ea4739c2f8c93038c18cdef1809462c06b84159cab7efdea2e132860eaa631a5dca5b4d260712ac7078b452ec4910642b759326de5309e24fe815d3ca052a20aae554677496222311eedff68ae0e27700679fd3eb73c39a86da9e54fe479be4d570381575860b04bdf7d282337c8de6e834b227d366aea70b5bc729a53c198e5db98f2ac46941775d474d9c51e89bfa85ce06b2f73f7bddee2a0d6ddf3ba948338728d8e0e573eaa05ef4a778f1edb93c7b28ae316fc92762733a9251f94ea2abc8ad5639578ded485e67cb4c4bcb01ad905a2bc893e724efdfc14c03aa1c763827f75f851b2dcc89b07a6cbf37515fd5bae7c8e38b7db8b8687cd7bdc39ff79c7857fdb49fa34bb94f58f357cc9f229cbfad57d6ae1e139a59d561850451ea5e7ed248656e00db8533041883deb29702ed2afd432c9c923781065ae7ca86948fd2224297784cdf9b259bdc96c0ac87f9e8cef6424681a971d096a29fd6820ec257f443e6a17f928eb13590dd37688af917f5c27cebd4fbe7b1d139f2f14d0d8447414e9f953519972d06b0e7cdf33b389727625e95e09982289434855a7cbf1e9adc25d1a4fbc33228c666904aa85ba17bcdea14c739ba7dce0fa0ead87f5661cec93837e1b6b94537bb7296995f13e3a4a39246106a8971e4caea1750159d92f0d66f431729201cbd5d90ab88b9664487eab2fe7f1ea19eadc3d66599bb4d0982f9cf18f482f2a431d183226c46bddf660420ba0085a042914292099d969e7a1afda325d32d55dbf76b3aedc30c9f31616164200300e11007724502a8b5d9f6d141cefd3f3f3c090bef0b3492f66df0e31871250bddd82740343d6939e813f7b4a6f09009af38cc64dfc8f80a4227d214ad1a9d53c301ef5af2688a191efc08b311cc23c115b6c6ec30a025e96bd0c270c1f01f46fa14195ceec272a706e042eda50a3bee78214ccc69149ddee6a00065142e036648e8feaa42e26a61b953cb7946ae4ca1ce3b287e6818c791f9df809941bed2258fd8d1087afe0947cffd2c03dcb8f30b173aa28bcd84a3cb8c9e64cdd5b48f9ba105428ca2cdb658e72bd5caeb4496f13c05a9798f7f868958d95fe8d948f69426d33b9f89d1e539a4ed7fadfad94115c07fc6f500ca02eefdd8fe7fd00004ac23b91cd12307903d3e35f591ad77840def410b414abbb27332521af6cccff98e13f9ac9796a185051b1f0b849a110445839c50fa390e93e33f522068c1b3f0d7698f8825a13ce5c86d1641baff05f990ff06b033b1dd7ef670a2a4e39f9f02e7040f4a3d6010db46de7633889ac4e5d8eb1083ce24f2a82ab2f96721e07eb75c5a977cc791c5fe7d68393b70598983c9861b68a84fe541e88e8e31215487a9c77e655c05c867b1e998deb2393a5c93886b1df52ec61bf11a2b766956db012c546fb0d5a3580dcbddc548dba7c0ae040125b6c7ce4f12e23e9d73783dbdace16cbc7c16402fd5bd1c00f30eb9727f1a516dd86029dc35b5500a191816badc021fcf0199c5cfaac66627e7114c881c6874ee95bd518c7aaae5ad8335b46c5c3f17ec60bb356686c0fec2dc6331fc4691ca08407d963bcbdc0b0187859f58eb719e43905cf2baa8d5ffa9eb9d9c19909e29d0dcf700f4fe42b3479aae8c56aee655a9502e6cd82bb58bf43b99fde8c56abbca3c3b875ae229d6d7b99dce89feb5cc218b77d4dfd05ba39c796caa75f9a3f782ec94efcdfb205080aa394a361c9005d8494a74e7e9b6c2d5479e42b293f3312aa08df07eb77534edb05afb5885a8c114c4c022b6391495cb5276d511aa24d31995e7dcbf8b0d87eaf6cc7931dc9ab5ce1ac5cd5349933725d6bf26a101ceb962d4aa7c166a691d32ad7ab96e4d6ea3d7b4f97b40cd5aad1df9a119e19e53265a2535362892c947eff9368fb324438bc0f5275f8be84e272775ac8424f923a58d2f73335838f9d48e78c71e3a58ba53ba1de17103bec511653d68041cb5a89d01cd0933f689ad9976f718aaa57e027d8d3e082aa81d74b050c35af86f95efe8197088a5b0b0c729ba46a365186a64de0d766c61c22b673332d08bbb3fc8a9d1a98d5fdc175c0bc968f37ea67356e3cf1b3f4b0f35243bebe81d5944a673b838c6e0d928a0d707cddf87bf6074c0981e3d0c20f08b7daa89f10b507eab2d862879046cb95820e9a8262cbc69dda91ef5750a2edda221e834b0c7b74bf20b22f6785b4ae9bcf55ffd16b3d44ab32f68f9993be15c61d1a940ba71451d0f7c1bc0afed722c593816bc17f867c9d532c389296d30dc959e87329f12a0be7159089e138082f33515f24c15a0a28568c12fe185ba6a6a6cdeb40ee4da563242f10677c36e3da8d3178a41382283fc707fb6b17bb011acd27b6ace6384a77f02737aa529b311dceecf5ad619833180c447c722d80a1340385e891f424d926ee46fe59f07dbe68f794617c8a2497868913f75dff5b4f27ee4030b2935f40a408bf8fed5d54e0c24186667ffff47789e13d24ad3f9b022386d17433aad7833f986267be47f5d31d72808494dfb80b9934cd8d05de81d67b08cb301aec0fb19d7d0ded9740ba353737e4d4cb01104a9ea51710e2593198f8e25df5d05f0bc3672d0eab2842cf099710908b2d01ee2273f7a3795dcbb31e1e5e21ea4b6806b774acae664eb50c40fcc887a1cce168fbcdfeb403ef6fbab609ee9e043cf4b55889fe75432feb64c192b4f52d5d2fe5a39eb2f33f1bb30f55a81ca9862e0b36ea136659d92dec56b882abc2a170f4afc57d885ecc18b96795d67d8660e2b55ee3ddcb2eb424f767d59ce219e17ba48b0812eca034adb9520e305d482c31890cb37704ad3cf70cbd529fd507f097bb5ad9cd24b6041540ca46e4bcd25e7dce36e011892b3c5def9cce536ba016380e4345cce27207851f3a2aa987088cf5e4363b421150336e14171b2f3e004f7642e73e1d842f30f4d0c9b8dfb455e6e0e42759eef07927cd4c442f7fbe4bc28715d87e8666f4fd6eb6ab63ed1b5fbd35b6d102b3d64b7baf9b10358a4c63c1c6a8910e12f2ff2876c55b515aa18ce64816e678d1c325d1fb4ea4e92a074dc42eb4d0d4a18a29c7ab6d03850e57add176793724c72722cb0fac74c1e695977efddd7f78542acf5351683fcbaad183f8f57a237517e6101e5b89567f9701dcbc730fc8245a295cff35eb23453fcb0ed47353b70f21a9a16de0db5f61bd1b914dc05f55fe2c912b8ff2d104fcf1ee795f36b92fe8424920f627f2ecee08208e82ff266752bb47a576a7798311319ecbcb41f2fc7b5bd14c8739104bab5788447a1afb367511049816a550ebf9e2e4afee6e693b8edc585971e2aaaf2cb4122e3f54b7b0be2a589bb58d0c6b99393be504e859df36892e2cc3c657711d79ecf78db7ce2f4da6353f816b4831cab3938c21b7e1a30973ca4e8f7639d88d80c576b3333e3f2a5b47293a41ec7440a38fdb1c1c3f07df584c8e3b4bdf4d09d3add33eb39f08cc04c05305e7d4786bea298a56e3cbc4545a280a82f75ff6dd3bc693cd8b9e6cd3fd2de1b35b2fc1b4dcdaa4fb35b727bc223239d3595b46e7280a6bd8977a9d1c1a0596b6549d0a8e68388e7d4d2b81237718988267773cae8d1f4169c0e4ff25a1e422eade7c090e9c2d9e0ec82aa6cac2e3b4552a2de5e3771912de4f49b9e5e29029991af0418f17244cdde88d79e50c0dc3091b64348c6dc6a777e327fda8373baccbb66f8971c6381f44badfbab82e2b373506b5b02ded30a936e8b61a06f18016da066536c9de9d5da546790d91c00bde19890de5ddeb52d5003ab8766360b1f244780ff795f804a4912e52c30a9cf1465efb777ae3e6c36644b98f4bf841c1de74b6de12aca19b1d7a2e7fe662fc857b37da6370f57fd8b33cff7e44fa9037f85572e21a6ae4f16ed01b4eef9e5aa37006a8fc43b75e60d2b51e79131213b536b99982e4cd547860c8cf7a67732d9c61c11f00528ee848a1cc60d23c58264a705c1db0938fa644a5daef3b0244a1bd65173b04b75da1be87f538534ccc4937f54331f0fb1b5b7c946a778a12f71397b2662828cf73af974bd252d4f9f3d8bdeb68b246ef3dd46ef1573ee87c08955831dc6c8c20c7cd83571e87e765383ae274a984fc13a37a70048681cb50acf4ebed53465b0da7fe553c4520a82637bb2d56d705b54c9484792fab1e48fbfb5a03979b0f5e8176283e77c97676dda2f18aedc2157c2f9c6197778348ec981a9d0ee0b409eabe9356137d41955f9f61410d9f7ea471f9ed4fb0bd4d0cc8e3429bb5097e71c7ae3d7d4779dd324c712dd53cf0ed00967735fbd45fd481b4b3914829242f295481e8b51be0db7aae7f6a94a74f5956d3053a9aeea944ada1f31b765f22423e17ba501cac4321997422e57e394d8dd6faa737d2d393782ed8216a62369dcd5ff6a3f58f0dc36dda2cf9b209c6c0dab7ec8f9f0e63bfb19c20132fb8b265065f3926dd62492ca73e68eaf1bc217a31d082248b8d85d5bb9dab82c512e848f194c5afd14218a7a9d7523ec5a0745c79d9a311903718906d0167eafb9db521c1f5f3dad143a9a61cbfc5408affff7ea7ca6f0504466d50d5193df66bdea14d8bef9312e8b09be3004d227c54223871141df28d05242389bc3a0d25ff7dff0f950b9ee0f9d6137881a575ba313a4ef0ab9dd0b3375ca547aa8a04be2c7adda8d7cefea746bfbbd0fd1a683d99cee96c3cd573b78f4df51d0f65346804e37b0288dc0b63cab304707d97a2c80d718dc4f970feda03655e72dcef34269d26b0fe543981344e8186aa7fc28ae367f90cdbdef6653a8253d30451fbcbc6176f1e0ee156d27f3c9a9cad6709a075a6866158822b96db8561ed3756e869d31f35f3cd2b562a2a937e42bb3337ad4e89bc860580222742e80078fd67e4565f9c5c8b29ff178c2d88f6048875584d1d96d7c72745bf75ace24f5fa68da0f8285ecb99ec22c4389add071a302f6d7096c2e1960f7cf1a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
