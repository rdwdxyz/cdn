<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1432f4af6506c78e2a93c5a58536eb48d50d8ee213b0837404dd646e1c3fb4fe59ebe900a417ca09b9b40cedc0ff4747b05af24f929bf44ad5c41308fbf720c9470553b730e2ecba3f41b56a118bdb00779f699421f57a6ecf540c89e07f87b2ac25b7b3d73d61bf9a6569e5c5d8d83575ab9a8da1a2cba1215a3138d3e9a4d5834742eaee6e19de89da8e57fce4db91af3e2dc8ab3899978a607e9f23ce340273f8aee0c72221526fe04ac863bc0c3d5ff36cb11380a3e820645a1c968373c4ff678c871cc1640caa59f98f2e8f2b64415f0aa3b2fcb1092abad26425fde5ecd08895215ed5ef91d6d5d780b59cbed8787565304966a61a5d5b38615f174703a15c63729d0b41396a4f6b07d2582ed419c70081ce9346873213ff5ea86f73f8bd389471db9bc36fd635a954ae9fed6e63b07f2ab048cb773bb8c4f9bbe51b915dee44fc2a360442e64527e40722c236ec05df80b03871512bb64ec5a557e00b16afa8dcc8b82ba395697444439cff64e6e7ecfd49beac789e208aebf38817f32ef81efd75cd417b9df0ada1b6d4beee65a352ab820ba9aca6ea6e4955bb3b3cb9447a9a154cc1cf9c692ce4eb4c99e670746b77c6353b624d77946ab2a9bf93879e0b77793b9c4e62e66e8670959318929b133dc38230ba0bf0fed85aace375482132e818282516d8288eff2bfd1e6b12ec6fdd146cbeac70b2e91fde4a21544f6bcdac041d13fc2ccdf7d3521f539ba6b3e1969c324776bfeb62e465f2b10f84b63214a7d1cf28b0be8c52185084465302253d31c2023f974e5180da23b79633bd7d9f687a660c4b6ac6495066ea74b0d1cff1d180576fd5e1ba2b3dbd2d17423f3be687ce81ff49d15f67f3878e0d2c21ee48b67583ef4e683c17d43aec2cecb4ee833f6864b0dc183eec9893f4cb120087a97af8de53166905f87652a88c99a19405984d8aa91f1ab5b81389ceb42187e7bba9a7eb19ba771e6b90feb4617ba6416986fc76adceafc523775cc89e21262df05d74e8ed41068143d8c09a372aa9188f659fbe1178c908622811c92be94cbc62a2b8ef71b7efef98347b657a7c5e421c9a34a3fe1e6e6d8a0ca2f0a05ad6425d4902b9aa2553a4f5776b4bc59984c3b3d65e89ce81de811bcfbb0ee2d54967f371a69adf1f71cfefb3593f5ce121f2839ad43eb5ae318752181ffd3e8bb3ee5c856c09252da97f32425892255e8e7514834e5fcacc63b90e921532dbc3d53f8ce692002b3b8aa6a20ef4bdaf67ac3734177c5d35d71234a3f3fb204867fda35a3ae9d9c9ccacb35195cbd4615186b45cc81ad087491d4a18e8d532c9d7ae814976ce8f03fc1cc50e50c7016f1124a9e87cb1fcaa6de61f5e21be18c40a70d40346ebcb073461664099e2b6c13c3b914c6c4cdb0b3ab2279e456f6815621969a3babb3ed3ee0fbb83a144391a36305fd0158be21c5812723406ab9f228b7bea062be7f3d0159dab07d2c8f282517702812dc45efa8f04e4a40f70c577eb53a04e96b3f45625e14fc940d4e4b12834cb5557e2518beaba0614b8d9781366665cf86e472a90ee2a60dafba46f0dd3f5f501a38e80bd781a2c5d4daa17f143bc82b536f343311e82497c25c157df57feadeb48067b58b4afcd6191122e4baaf42791b8fdf6bf657ef5926be955aec18cf66b456ac22b28fed17af5da803493a7d81e0330520d0189a0aa42835daee10522219803f6b2d220191053f11ebb02bab981f557d920ceb7892ef1e0ed740696c5eb8a349824923b3643965020df187a747e54a377976f1de836403c8ae025a84d207bc90b4430a419b005302daf4b82dc3083d6b6f18618d8e8c783d11bcb6b40b90f5eeb4bb0ce82e998eecf0c146ec2b49bdedddbb274c5e61d2dd8b762dc0f812cde7c17c9035d95d565773abba894ca99f7e785c0c2953754ecc6b86324b1452f68d0eed8db9da16cd693ef9b9b403eeb680a6522727b42b7fff9c82e5e95b6d14451a1dfc96ce69b62d825e575cda90ce90b733e8c56246cfde2e0551bb8021f94ddebd88afeeb0937d6ba834d8acef1dbbeeafcdd7a936f5d891dc2f4507f2330da9e1871807a998b57e75bb7707811d3e4db2b164e7c57364c527d6d477ac78e1b85668a538b88fe91722b9f5b1eef58a1277796948b1288e4bbd0808ae63f12d2e18440a6a514a1bc93d70afb7f7c300dad2cc6ba0a9c36b54f0f648ece1ecb7c992625e749ebe8f07dab9ee4477a8c787f3a1e715a048527a4bb3a976e68a6d44d994be679948ce6fa3e87ea238b6368702fe3132d83f359c14e7f14bd013f68f6e8a4135f51068c328d490791795e79af2cc4211f93b79ab8909693d7b19119e3e60f9cf96a36bd6e2d7979556b1f0d31928e68f6f89081cfc996d7ca1f5e0a1d97cf3795c36022b6bdc115b096674972cc0df5d865d9cb7029fc36c5e9312529a8387b93a7d4e33236a563db455ce0b1bf1ac70185f8c63eac18b018aa19f8ac4a7b8f2e1b52a98d28baf93edd37d06711d802f3db91f3d9f033ddf45d5854cfa9358ab5cddfab477eb30da6980c057725e396417706de73596d1b88de2ef69bdfa71563dd5a6787425cde91c4a1493abccba66a8aec860fcf23c079d5798cfd764bf78cb4f24ab71dbbfa2c310bbe3d245ef0b427603d32c231826ad5ec0cebe338e3cacbf44fd69504a8f49b42a0b6bb801604c049253558e06fb8b8ee15e08f5125a89c9da85b474ea7280e4781f4452d36d14b64b6249d695e2c865e24aa1d91be24d333a1ee78e6ab8274b9ae407ab2595720ce6915208a04da36d752a422ae4174466cd0a68977c09e9794b04a8cbf2381081be4c3f927c09ad42298cccf7d690cdc10fad867108c7326c4a1a4fe2bc6bbf884e6ef84e859487a7d8b480c9d9abf82397141e3280f8eed8bd7886397b9925af0d6b6adeb94adcc0fca9f1f0d8cb30b149f9c3d320a8a2749e5cf905bcadd012ff99cdad14045ad8a371b72be0807de477cf27b3bd6966bd6d17abac5471d5088a516a2b06a6e87dc69b35f51995edf9488fd14d8433a2c4f5af8ff1a949b049a93c97ee6f8b917625b8b8138d7ce6ae38f542801d9e53d7001f9f46c231565bc21afbfa787996a079cd27cb235fba87baa2db8054c7ec9ce5833f420e57eae40934af0dd7fbea39b97a0b60ee31191b04952473d2780bcfce1faba5b01a9cf7ef0b75fdd7c6f2af774d04ca808c739b0e797defc1bc5ef44ddef505b0fa677e71a29a995fd701e9799bfcc0226b5324bfe16bb07275f616731f9207d79a24201ce1c4e1d5bc32dbbc56c06fc42c2a682be8ae879100d38588e140f949df127f42f37b0a5a9aced97e6af9de55019fdf13db124781e0cb2a95167317a1d49ed22c4a1f6bc21c741f9596a06e951bee6f8ec9da800a94b3bda6071482f954bef8053a5a3479ec4e3b91a77ac616d884477926833ac156d5ec5bbfa221ba9b2c58ed53fd8a9c9485ee790d011ce64b38d2da70d5d5142fb7bc2264e6ca26161876b9ef2b0ac4eb89752b726b7134eab7b43eccb5822c408041e4a2f1db5469c5e3416cf4d56e34d5899ee15ada0148908886fb17c4c15c80504c92080db9883824144a8e58a0b1fa487c018c40ad573dab527347d327b70f30335a6640c805f35e829d536e215f926607b0f12834a52497a3305e7463de06439cadfe747202fa5f2a8d3eb9f13fe6faa3939856b6fe7444df9f99b180cc98786211e0423bb502882fc355b6a86318e1539faa616585d6ce7e31a48c9af2e6cfc4ecb3452765b68d3987e00b5245289e4e0ac96ec1eacf09bca9bba88399531476b5994cbd2789988cbebaff3b199c917c1262777b348b377b3d4f9b12957b816582a2ce7be0d55cc64df63badc2edb5c04e05ea444194e003c0e722c0d764446c57065abaa5c5cbe0ac65d83b282be3a31c526250b8d60b1f96507bfb5c646f142100e7298848dbda5196eb3b562a1d250b2517fbeddf1b381e3069a058d4a9a2ec1f89c8f5fd70fd255809544da3779810aa533911c169dfc6bb3c6a11e0b5f85b43759bee1d4c8ec18303c74bfb9928663cb41e3645bcabe9b17a601ee75b6e2761be01b1d96107b594cc16393034468680f2d7f071a2f90743ffeff747f88bdde5f1c442007bc0658bf4c3b5c21515130eafb9c52ec19074eee5f5c5ca01bc70b8a213213a9738f480920417ca2a63a8157941e4a8499a8721034f28a2de2dac4ba988873d565220b0037ff1ecb86ec39ef809ea12ba3e35800ced98bbbf4d30022eb2786d24a3dc8d599fbdf481799fb25696321f1e28f50cc3522ee2f7939a4d423a91f8c4881e79276e48e9893fda4aa84c67777ce01a56c1a46bb4e5ba6c1174e81685048e98f97f3bf32b36da393fd1d7a92e7ba455533ab7ba1991daee9a9781f383bb1501709596cdc85aef0c19eded942feb27666615914d15cb17d9cb4892d4ac1bf9ea4a4be45ed575095bcd70f2bae4ccb9a5e897322602225d84ac7e1a502a836f5a8b53024d64ddf9e8c80ff0c8433bb9d3c6257794d0c86fdc6b092fd5dbc0b040c2a5d2f204832218afd18418ae4655ba35cec3ac546557228ae8de7af6cb69327491efc093af81f9a0de7acc9bc83cb68f96a57a65c36cf4db6b0cde4df9466838c3ae867a7f76d937abcdfe51173d5671962c04f519067ce677e5cf6ff24a0405269704e34e7052fd80647ef81603e42669603850ee4486bad7526387236a19233e7a9da058d0baf343637b6dab2b1284c5c08fa060531b1f9aff62dcd241056c1d42fdae6fc82966a75ecac89e255e6b98841780e5ca4b59c95cda452cd46ef1a1ce1cd7de72cea5c9ecf4ea136b97b36e815d9b4dadb91cafc197a1693d2d87ff832772f4b61785ca2bf667d591817bc28786a88bdaf0617275239892d2bf30feb01ebb715ab91d4f70d5b8b404af756551a3ed48fff1ea07e2c9fdc3d64657f55347bc986b33b4238213604974b60bf455da662f3760bf53b140ee805004dddae3d92023262d8663a48ea1f6cb93918a9c6fe4d4e15bb579e93c62e5056d0f68e7a9fb60dad89d865c5a3a233c0a8c4cf39af891edf2f269cd66f32afacf414c1b104af545460f80944596cc4d83f69742b2edca38069fce1bdd4c678d2af813d5200ae96ca3a305e5692c5e78ff2cbaed39154f771a2256cbc721695f731a4d44213902743d574cf8527698e1fe69fe5a6bbc63ab02c3d601341d1862d8fc7a410b417290ae385999f60bb71b00cc88070f846511964ce49e6296d15ce2332a13eb29d6e3b41dab9c08f14811bd0eed3470f60f4c1e253b2b6f8b5dd1dc47d8f85eb485f6dce6aa75f3ae2fc4ed7ec561cb93d8dbdd77b5b90d5faa97c3b751c35ef193ef5602356704191ac5c734cb025fe8ca4871af2e12a51f1d5a4e8206e61280e4403012bf94ee30e8d573af43080da24fcc544386fcd17bf4891a113936f46f6af760455f7c8ccdc93fa63a29e548573327dfb8ee433579e7b360f5e4d2f08fd4f20f9182223646a21acb64870594e9feb8686d407045cf799b3b8c7692a88366fa2d7eb8fb76dccac31f49ad0e0613c962e323d8079f9474467ced9c8952a3b662f08d03969eb5835ca2c39ec80876aebc54cb44107586998cd160fa6f6988f4da784419d198356772692da258ea1af51ccfe5d09068fcf188c37c3ae873bced30e4e14361c10f1d30661746580740f414d0da14823f603b5b0d76570441cef6b5fc1bf185a5c7fa2e7f382345b66258614f9b36df988730196bc9e260a8eb9e5dcb1c21793696bdd4aca9b266ef36cd4fcd2c1c267e2eb90522b258a0ba4cc04695e89f008e449d94fa03e07f8aaaeae937abf1c99ed914cb8327d0744d419545820bd890b889411d5b12a0712680428683d1c12cea206753f196a1b07e75259279503d03592f882ad0eb7d6fba45d591a517ad276c97e8f99fd029f2ca39e09e861226d92b3bed4672c30e6e4259414de9d8cd15d1de566f77d08ffbd54ff3873d3dbe7a677de99ffe2a69f296ffb0d9e2bfee95797c492708d3ca4084300aa0197dbf723768ac516ce67de7fe2adc849068ce58a9bf0bd4f2ca340bd5395be300f1a989b459a499563d75fc9b000dbbcdb285f6d1ba1cec3589f7257d59de845c82b58ab21855cfc2a7aa719228e17d4fae0c5337590fe9a2cfce644f443d3e7997ad4639e04002c1aa2c34510cfa7002caa37e4e6f2f9d23b299977bde6ca53a5c916bde0b41e4422ad051d9cc2c90943efba61831ee55226f0588a33517ae1265e145318e3947b1b9e00c60e78962e320e8513433aabd07da4be671638814d02d2aeda9771a087739f435167491ac60ad87c70d7306ac04ac9f89c8fb32281679cc912169619c56d0dcf509d0470abe558f891cd52fad4c4d32de0fe6740048db749b94b763a09a38565afdcf558b2548e0e125e8cca4885bf0a32e6f9d0c1419b34194a88cd65113f2b1bdd72de4029cfd2189683364a2df9d9e505a0e4febb166495552cd96ed8b5dbedc9cd5574590cca4191fecf1d559f8e2247d292336fb8d338a8b3f887e826c53a4a0a2c10a84c22274eae49f831c9ce63345e2999dc095a992af408fcd85b5ac27b89fb5948d08ab8315ac4998eacf48dce37160dd5eeced6be4920f4e844adc038e49bfeb6ae221036b1e73b520af9b23b20f8988a22e3af62509c9ec93ae732c0ce149462912473e721f897e46c5db27b7d21d3e49b378c4b1aa110644aa1917589d8a68c954ebcc494943fc32886676ded2d95ed8cd837ea15449abf0415b90cded159448e4de101c5f030ab8a07731866b22a50574394a7a6e3c602c527549c0b28da377ccaf35d3dd039d3cc482bad3b1726048785e00342a8ceb901bbf34b3664bd66af6bca48650154c22fe7579758554c5b2f2f0e4cb7e9178fb9bc98d242418ea4d36f3050abb01191a053d48274d4291c52e6ef58abea2ade9d7ce646de2c5f7096e2b708e8356c7a620a68be86f93f5857101fec37ba701ec203aeddd1b2c1054bc56fb770cb8279ae03deb91cb2b09ac7b0d9f937a1ba572cb8a15fdd1408901ba09de5022cc2128ddb942434adb8113820bc1273d4960d087a0b73d6d9b7950b0d0a6b473aaed85c94f8e00244fabf907bee494457db814fdf745e034238b4a401f98d7e7d0ac7a3265248ca280978775344c64947195334fe1f4c41d92ffbdd3178ce395aa01368b1fda633a09716ac012543d4982a3bb9da9ed22f59118cd774ca5a676c8b92d6b44874958f31fd36924184449cc7d9cd17fc0c098bc9a9ca85b982a786b1fea755c2b37e677655109d8a9b9a2660289dc0de70ceb139ea259c346325914ef28fb97c7650141e8003aabf2c233ce87860a5d513cb73def739da01253461a32c975af1d6f378e37c674f6a02b8c0935812edc213162ecf2fe42384165d58ebbe2b7e311158e99f45e892e397377d8c96d2f6563a0cd3541f7dfd77cae2692fe0f22a22ebe606d3f6fe0fb475987c776b4ff115499d278645c8e9ef12ffc016db800018873b90bc9e19cc291b3427ceb00f26de1b70673c91b6814eea1d424eb7e70eb6c15698acaacef6e4ade221c8e4e7d905a1d240d8f77519df66e778d124cef63e68b5ec0852e916dbd14a8b7bec7e4e1cc48663c9af76e853ad4edd81b66a75498dffdcb90ce7b3f2eb92118391346198f4f4be959a971f41e9f9b4f0e9991b3d0c1da1c350a1622aa89bd9c52adf08e6a1667969830e8fe963908357ca5debc054836c5e167b249a656164a3cc8bb47415581165ef870a3093b3d2900934ecaaa9dbd4074c903035efbf38fd745ae955b96c9692961bff0f1672eeb2338b2f39a4fe0c27ab8c3135f3c26e4469a37e251f56b42aa6d72e40e535f48a5e08f5526c6688412b8cf7b19c93976b1d952e16c00de665afedb08c5c86b6f03ca5a920b6288f0c724c0194a99181e75af33afcadcb6102eda1c381a9d423beb604ae62247054d8d4fcd010f34d6bf03adc052401d6534b6b4bb08af0f3c7dd6255ec2174cb775e338cf062ad9011966c30e6b70a24adbb1985b5d7d15356be363bb2e4d8100aa307f7101281fe8d157bb966fb6c00d369babec99861d03acf05fe17802ab33412ee87e2e1b9364e04239c5f8ada79a79c9f8c1fbc6144358c79795479857a16f49d7086b90935911f56c532e7b80cce7bc191a126adab9b4a47ebe11950f2f4a5200396e23bb8ef73c313affbd556cc4d377b33474924305c995bd806f73b43305cbde1ae47dbb3c883588645737802c2fd55d9b7be79c7191a2380e9ea62f570ed09cf2655c243e3ce9da790d0d680be9edba3f44b2576d7999a4675051c441e9ed8388a72bdcab28fce04fddc5ea806db434628be00d9ef4a65dc0365e46a237448ddc32d5ad7a475017722107a9fa32a0960d2083bdd6ee096a3e17c1f0c2a703dfeca1aeb286508a3a17dfd0f0beac9bcd26f373fdada1e22f25d6e8b2014e2b5180892aee4858a404dcc49b8316645190e264a4820d5bdd674d1f3c12c44ab778153296f46146d18bb4f36bcdfedc6cd8e2f03fc15cbec2e54e9f33c415ecd0f95a38b58ebc61fcdaac6ffac81c3c2d7aae29fc635d39a0ff5ec5d888629f3d3eb92d4503968fbb8face9f68b76343c9fd363b58a174d6754c47ed3cb6a8181be869d8f8765747dccc66afaebbccb8c314e0513444981e762fce9ce399e8b7f38de13638841e8c06ebc44c97322f89d55e7addc25e98bba4102c50123c1803765b5b80a333406cbb3fc9406c4f854c7b15ae5d15269a710a3d0d92b1248c456980815640cf87e1ea52b616dbe9c693a441274e9f66277f2cbf27f9f8b4d1e7ea2a165af01d480b2ad2654492030492724f5c2d8614416daa72cdd2fbe7e2eb820e547d857e87f2627e81804ba6fea472f5db2ecfdd1025c2a563196f68636fee26793d1945745dcf316dd569151c82d24afd1656103a24d1dabcab99a350665a0c52df46a669599ded62448a9c140bb266648a6b235e3fcb7b76d334fae6389948346e1f6244a3b02859e1eea86f4edd28e87f919b9e716eeba74a4715d581f36051158e324c89f3e2bd6e24511f88f62b2f5c14913d8444b621b1f8bddb1c374327f7a89abcdbf821c6302d8d2cf2a55d9a6b2234d411cec79740120557d18dfaf49d49e3dac35fd6c6045f688194dd8e8de81c4a37159e6e30de2b7211ec93a3d1d145c479fd73ae81fe60c7c09664d10c4849dd4c185a7ce0eaddbd5abd688951733bc70f9e77fb118ee9d98856e9c0a1993dc0237e9012eb74025afb16bd74d03af53e2489410cfbfaa780410adeac11ae726eb1dd66d20414ea6e6313a93b383455faea62219037b1f31b59e4b374ad143ef9b03ed67fdf98c01da233ab2f748ec19560cf3e1199f43dc65c3d96a68b1645c4f33b40b6addf2dce0fa8620707ba07458fb655190437f45b28e0a2973c540399436a20aaaf90a508137bfa902ebe0e2a704d57a2b0027ff958e3c32306d5a975cec9cdc4daf401761a306b102df17e4da03492ae7dda5088e4edef3de9a7e2b1ae9c21c34975619c68679a555327ed9a049670fcbfcb79ccebeb7944fc4c24b151c21b2c99e16ac17ae9a488c4a57c0127dc87961d5d5831addb8eb988cd40a8ac7e7dcd8c25ec3fbacda4c3f355838c6310404e1a78457e7bf2f10ff47087420724d62b2d394e107d6f1807e8e2c217c01ed25844eb589d9040fd788e91bbdd17e9b9f67e7ae1f7be09921a0accac6fecca18ab026c6cdb80e8eb265ed6d1cdb587978782bd673005bab1807deb5ed0228a73dc45d8230b75b200af580f882b68d6825a1b507abcf92515708cb32ead7363eafe172cd4b12b6dcfb49591b8677094a903692ca4086376ba3e38641e8515c88f3ad8a308d989952e7e9d4f766a68aeea30a7f7868cf32b7cc83d6620450b5be5c794967fc78bd5454d663c3ec74c7a32dfd55d3b3d5e3371492677f05bcf786722af12009c408d8a0d17289f6c8f06077aae2e44bdc107ab8cb9e39ad9556c33c5e586997784780785d7e7da386e758171eb9aacfdc75f910aa18f6044bbdb09c2eb70bc6015b76160f54eefe00a571c18638fbac434473911eedaa61260be088e0ec595d9208902b77b908d7d214e19456a8c239e4ed70736dab8de2dac304b728a4c27de3918f03d35c6fb87df78eb2fdf753701447a00181a7d68cf22970a2cd4950b91b8626fdefbffcec5724f15e957a3ca6c69c359d805a2e0b92203624ca6e95b5ef5226adfb968cb3daefb91851ab5bd4fd69f73955ca83862aba9679c6b160aa43d361bad243bde7667d146cc1865fab60cca6fe90f7cb77addb54e32ddf7fbb068c6db43c6f5faecfd281790eb34b429612f242042bb9b6350681529502a8bc1090ad7c0905e7d14e82eda47d5e22e4af20e01e7086095211ddb5515f8d12ead561286bf0a8b1fa48b77c047f879ff3e9fa3d29686e5e8037b41b83d6f34db02e820c6e2e24cb3ce391113a4c8e4981805997cffd9d7c0d7a2dcd90490b40026ba85b958c34a1b1f320220ec458757250a4157405e73e779c3ac092c5d721648da272668bf330a78207b94359e809d90f8f018b596d1840f04fd5715b79a0f03735802b730ff83a360631fb4d6fea888d2b1f42b84f7eb266edb3c5871d13c3d1b645722b0242156811b8f49a74cebf2172ffcdf6f11269a3671984d1fbdaa982d5ec95e39ac8b28eb2fdd465ade6c8def484ce71578aaaf3a5b294e67dd6810748fb643267947d5bb7896d3096be8b1e632bf63f89ec7bbb3007aeefa0b44b9d64d65a24d3d3e6411a675f42dc686868c4dea72fd0b454527d58c29ed3b4d15912db9af925e7c71827d38d7494e42d7c2ae9ebb872a75fdeb444fcf5b3f51235883b2b066d29ed6e8ff1be4bfea03568779c3b83ec1590b01b16647f0773dc58eaff0f508d6eac0543349afa6b7fb6366bb8fcb93079b44edb796c268fb2c79774c49150cc82ad0478ff320f06e8b3d204131f66fcf6d9d415945f3da31d2968fce82914d4a391402eca4b938b0a794f15daeda6344964ec29640e1a94a799e2440e0b20e11deae7d53a4c86feaf734df3b9b730ff87d2fee851c4529be15250d49ad6c543df3533ef5cf81d67c05a12438a1e0cfbae623aebffb262d8a4f56071288dc39d1d0fc86b81745b8ba651047b4719ed77632ad5e1e712e700783e7f8f4b77d9e841d71e0f4768cc7859b8b76c069dd7e6ff814d5291dfa53ce6c25c994be66a3ca7df719fb47eaaf09cee2477b427ab710301b0ab9e0654766b30a030742c87cd907681f997999d58bc742e65e60fd3a76dbdf93acb2832a8904b0bd4e0cde01a74c37358520bc20107d44a6c5910540a14218614d23fc397c974420b65dd5b3f5a3f126aa464eb8c64827b0157fcaa1381d22cdecafe8c62208b6000964d862d83916695db82cdf64ad1266d155dfae9809e6f511f41ae53a064647295e447bb0cf97b063385080fc7226543369b4e6ec36f8a9c14c500fad73b86794c6a4958ac252e46622a02516f9f98010dbde9847944e3bb90b288940a46258509794970af7afd13445051398e71acacab8c4f88b474318d490479f6b54a860533256181caf474f270927c4b9f8e83dfd8a3dc51a1f9c03761605cc1e9da8e5236e4eaa25c28d004ba33835d3906a5c718b7ecd2717891bf57eb8e031ca153d49e0c8def9db7fe3c886e2b9ddf9019074a597aba7740baab5eeb610e92d5fc485bc929e56f7bba5b4b517dee3b3032fe6a295b685742c4625a0cd209575879ae841fff28796e596a975f546b1e025b444555f4db187b85405f05cbc983752a8f6f50915f492a0aadb87d7631460a0f5bff4c99ff547f14d3bd58b3dff71bb0daf3f6b2bb83d16d9fdd16445f907ec4e235504dbd1d28b45aeab7d7f33ae077c8db3e724bdfc368788f69e96d44e3cd6f5b6a8d33a6b0521879371616448bdf1db110f16d6d8eace044670db44ea210d6b4ac92a4f3e7fe68de0abe7fe108a16f4eeadff1d81355760a3848583b99e2c8fca4a3b1012efb195f1450547fb20a685b404145ebfbaa5e92f7f6f801387ce63beab396fdf43f4587542fa3433cc959860ff9212d91044e15625fda1e01b703b323786522b3fdf2b6597fdac7420be14700953ebd2a49a89624eedfb789ea72ef501472bb925092cfb5ce2e5a1cada1a2f8476500cf517fe91c3d661dd40e1d1548ec021628c3f0d68db11e758a37ff0544e806dc92002cc7921f3b82e5c191a7369917b074d9f6f1314ea86c4b3fd4ce36f35f4b8f893dfff491e2ce64d15be09ebb93f44407ae9f26de3c8b88cedb44ead6d60c4a558ebbbd39cfd743705598d56336e0493b6862af9c2b7a48de5c73ec6ff5ddfdbb51b84ea20655887090328904f3be20ce208254a8f707b41a7a995728825d09e7082d480e358a6d737d7b0149c4bd309911e2861d969df2b3a9eee75892748747d9532944f7f4fff67b6ec23c6926bd1f896a4f2436bda61448bb1df23c63e6f1c984aef8414963d10835cc65a0aeb13ecdae9c2bca57c0f0bd30521c6d40dac1ebae0058c8be7d143ce4bc8de2949728f10a54676fda3752e8c4d0710c07d29a6f2a2d06f473422486bb759585dcbc6ad69359895435f66e8f19746c06aad61880339c2c7704e889d1f7551517d873652754565453c09fa51f933d7b5729dcbdd5c433d2eefbfb2c8f9b122829d963a51dc28f739e5c4a913672525b8992df8c90e47090ada082627d4964139a78d4b7f39e466d9dc79dfae429acf20005ccf007de5b8854e13aae12adccbeca949e946470b5112e6bc7a2326b2ec7f8b9fd7f4f2771249e9079627e7ef5d8aeb6dffe3e09c9a2922983fb1977d0988d7bd635fe02c4a4ce66d7523479fa152b7ebf18f7b851fbf32e827cb16096bc36ec78d3a10442a1574d596bc4355dc7c3d7d28bb75ace50f31358f27ae983d0f630cecf0373f036e79cf94834d1d16db0340725df02b852ce97d2758b936bb5b027082a351cbb8514653b589f9bcb36cef8d07041e5aed841b788e5c995692490f58958ef6dea462680b2f2a3b5b25a560faa0cca99d2152cae6f1f576bd13db0c384496d997696c0fd209c2476e3ea149ae8c3f26c630bd3a6598fc3aa4842cffd51a4cc57613a8fc2df98ed40b5889a17de70c3193991589ae4fc15df7943dd77c4c23b01d7ff7359290ac6f9c05695cd42d97a7e78472ee7934b47b23b0a72f1917062ca5a4abf70e2203e91b07821f35c23022cab9e5b98454c145c070b200f13c7bf87ca21cdaafb925534b4627f4df3579fc94c8eb57215f9a5a9d0cea5bcb199bd66061fd7a0263cb4d68ad5fc65bf5e24b5285a9b23f869af756128c04e2e193fde0ddc2caa1fd05854f970528d2265fddde4fe727442140703e105e74f1974bfd90e1421fba7d013ba0888404c566e7f12adff8ab5b898263aaaeaa6427ea70baaf5f63abf30c1dd131b9a50693ca0064670e922f096ed536e867f1ef1c18dafa320a59672198abf83e1a23a24a9347d7453bd334a6c1d26e2d80138f2094cdad8329d192c6343db3efae1de456a7816f68754e48ac5fa5b628f7756c3ac78154e4e5e4163e8d593d74ba82180fc406c18c7af259113f14d0ec13c903bab0a5e386217d75d8b5ff7d603f6006b9860ca4446c44a45ccabc6a9a494136eebcdc13fabfa0cd212b61020bea032cbcb03b0f35347ef3cec631a2b793b049b2479d7f9a80ca599f5fe90c1d4c80e0faa3a17d95a3f1a32960998c0c6be4068b739af50484e20f3c60e6df9a32e78dc9aadf3d89f96ad27f530de1604951c213c9772a8f29cf99f7b26c1e860bcb8430cad1955efc4f6c611ea58810864679e9876ef9c8029a46d3e8ddcfb0b11e20986a9f4715ffbc71115f9fadb199f721757ea22e5efb4cbdb933f5e9609df34dd99152efbe2248c917dbd2c530853b7f9ae827e0d8bed727afe2a3ad57d249a25813748f9e96afb95a45a9d797d56975684400671f58ed3769ad62a5b519a00677cc66842d5a63566b0e1e9530a803592bdc16b6a2151e3deb16e6cabfa4147e2e462dc3b9ba0e304432f6f1ea168f9454a3239ae39ca30ddae4812457c9e6a874f495306f97ab1a0e133a0dc1166665fc12f17d5e14353390a256db1d7ff34a45ba2c6077468608537f1d0c04a1437e5f042378a6aa2b01c882f83de675ba693048bb8f145de8b4d5d3ce185d61de497bcd4b1f06a296ca3506411d980333651c05bb8e72921cf6ded8041234599c9174a9249726517c5c53852129a0b0a8d87d43972db7867eb755905419584f7f3a1a6f95a07a4be2908d3f46dcb9260c4f6fe35b35762c254d9874fa3fa641f88e2399675a78a9f00daea7f1e60eb431dfad3a40df93c8ad550f21e19e05494e287a07dddc70731f0b790b69eb9703af760c7eeca9fc6e18d01becc0b00ff6b7934afd1ebfb5253ea57d168644606135dc6db26ef2b6b8127e92d1dea11c2560dc1c67b5222ddf542482f44e325bf910625800a40d8dd74722b725bc1799c7c5e9c3dbcf7bee3865691b904ebd139c33d46202c901dd645f5e331db26167c05c2671c93245a8159123a1bee266e9342327e545ac6ae112a0ccad0fd49a93a3a970ab9defee38df21e41199943fc1b7bdc25eba379c63619b8981e80afdbcad11e194a64aedc1999d007fb203e180cba434f670d7413d6eb21349736036b48b72df2d5a9c7f2e6fa133a83024575dc0cc21132888435ad21379455f6b689b84d066d3390ba101c36a1743da24358ac38120fc18f64c753ae2fd4aac9f69adb1b31655a77e7d7ce6a79778012482420f5d03003157307953b3458aae906eff628f9c0c51887f020d2ebd0781e32bf31a5ce05578960eb4591312138bc5c939c130a566098bfe00363c120fe486663597588ad43b0e44b3fc01f505fa5d7087a8b3d7f71c215b32f0426e98f6dd416c649f7344562f63cdf4ceec632107fae5bca72e94f96b55505433d8b5a30b9a487c32095857d26e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
