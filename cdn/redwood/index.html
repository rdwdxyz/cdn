<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"49f0f4c3541c0dd4f96473df4a4ef05dc5175ca0e60754b51fe668528f5253d49e3e8461ab7addbdf5b1fa8f6375fd8041e13c32646181333a6428e785cb7049b2ede45e17f8bc06b265b39bbe2888529d38f985c1abd350c640605bf535411c056b3e1fec6e6582ca6b64ce6c606ebf5a0e1c20bf3ca18e743c7619398acfd99b295ccd2997fd8279ed254868d539f5bff91dfa2f852e7ec0edf2790a1dc09198ea5e3dfaa9451cf54fc486631db3010cf0cbaf96d419af3755d5f9050b029a8cfef181626f02773775f65b468d51b817e25d1c5c0b2aa7c90c8725aec21a83c15d8f43871a1f09f116a9581b735664303182f1cc3e63e0ffe8496b1ab134a07ea20176978cdfce9221f1d25193bddf2852d7b01f016571c16e3c7b99df4c669b04c5206cba2a0de4a2d8f3ab67bd670f7b67fee07da054b43b3c866b19ebc4ce17eea9a67647f4ae6cbe218eb1f8ff4b386ff4f5a135e348961fc6cc030697f17d27c91bb9cbaaace000a8be9227b575d5d5287f74b4f237267ecd667dd62c4824ef53ba1680459ce32003ddab1e90a73b28725952f17dae205c2bc7fee704d472521a015d0ceacf5c362b2458e2761bae79f9b4bdcb6f3043079def11cda41f36d3478074c918233d77d4260689555b0423e5190cb771108eeee4a3e02bc8acf1d5838314c0cc5cc2263a3dc126d178bf167541458538e8efeec6b075e5db0fa2e063d8c81ab9dfdb786baea09d92ec42f1d368ea457df3f6c5d00006b71d1861f7bab8c328d4a97849ed2f2442af9b2b6aa4aa5413b0ce07c1b915f9657313b25f942f1dd107a11cf7eba44335fff83db553dc658a6eda77da9aff3e72f52ad063b52a024fa425268301d353428cba9833aea55de1a91b6186693f2569d3467349bc445e375d5138fab1f6d8582a124cfcc14cf65c6c01738b3d2b79378cc026c0179fd7b09401b2748e6051fe999a860e6dc1e1c50edcdcc961438b4a80d8dbae6b60a024810f9ff028cf2937720269ad53bdf8a9360863963e172eb1eb9f699de0a9c3a7ab69158c3b3a7979363028fc154a82ca876d313a97cf729443d69567ca4c919c334eb096d2a461733a4a00261bb1f371399caea755067922d08266a8b6466c2882a995218d384f4616cbd6f1e5d312154108f830b5346c15df9a7d072cc7056bf18d2e2a6ddee2649dd9d7610c99078654d9d1867ed735ee2cabea70107ea63d2faa91e9f1ee52a0b209eac46367287586d810489cd438e1c9df9000a0f9f0624d7d10988c03f90b1cfebd6330128faf9175cc09ec6ab552c059973a043b50de168720a61863da54e37ce79f2023966d6927da4c398f6614d5c5d947930de2d6d37fa1eb99c5dd9554f4399f43d8d55e9c22010f7e381e330cd4051b881641de07c4437bee55e10b4e411acec4f08b1aff39e571323a8fd4cbbba2902e95f105ddcabecdc553827a6cb9ce86d1dad8a3dcd9abc4d1ca2189b5b11b7a4c7ef284e31ed5574e7713f779993473d401f625f9a432ca6fbaa90675b34f8800ff6568de7ee8c79dc4711d28c1af04f6c230879bc0b88ecc822b09b2325c97f3c2eae6127ea80748c78df1d78fea4f6d3f1d0637da3dc0c3a0694e284567c2ed5e673b21ff630555fac048b877b111fc8ed4d64a0ac1fb820f0e3dc3a99eff99bb78358e54c23f2ed5e3926f10d8838360b5a77a265e4623c1dbfff3c03f3043c95337aab1037657b81465122b5a87cecf4301c6090f742a9fa671f0c5bb9aa5ef08536728b035a784a6d1151bfd97bae4a3d1ead5b435c6f8e26315e9d1d7fa216bbd72ea96cfa6c020eb051a55f857e1e6fa1aa9359a3728a73bf158e021cc334fbb55cf0e2f83f9d6ce6fb888a45eaeeb0142805f72c800d8f2c6b5611cd45dd45ba6374da9e25d70b0e16b5f3cdfaffc72f9d6abd72b7f60df9f8ad1180290f323239e4861f718e8aa93bf662a8bcc11c656f482737d1d34e79f2f12ddced7b0739d75bb537524d230a39bfc6c5baa191e7fbd13be6aa7505790614bfcffee1f00179947e14ceae526d251fc55078866351fb9490928bbecef3316af38e868e0c8a3a7b9136d25e9e15c19a5219c7ee401ab32431a22b30d05eeb7a5fa6c194087754b7854d3fa10ea27bb94e3a92b44422f92ffc882be551e5bd0556648301b834dad4dc5e5c0eee74600869b61d079c37104189e76ac738508e2892d2f741ec5c54fc62aaf4d293eb6acc5822bedd0dc456a4b02b9955901fd8f6fce483befc43aa4cb5003b230f1d918f7f5b2ac586ebf7aee76fd29fc2ce57ae09dd1f6dc0825baf0decd45f7b4b8b122a3765d536991e916247bc5519cc579d2589cd7e3fdc89b03cf5b58e3e183739f0dc3747e99ab02a60fc4dcd5d23a1083bd94514e7f2dc20484a392d46ce6a949cd162fcab572743d7586553b020fb82f6eadfdf450a234bd1ebd9f3174a72709fbef0a04538d25cfa737af5687f05c324e8e66e69d2b486d1f8665e6ef26149a0a7cf2d040fe56a56d069b4fcf014f84b22867fbab25f3399ec4d0940ef2c6e34681fb349dc573ee27d2b95150d6e2aac1b5023025e5c7e2a669a945b812934a99c67df2157fba3cb2cd1e52cbc9ac1ef004f011b7f96a998a1b887d9168e4680af354325be47cd624c4b14c52863822e43af38ef75b857e6af1fc87c258777bfc358ca7bf4272bc3d31e82beb4e3b281de0dcb4ea5367b598250f8b44b07725a42f7cbf519fb0062c3c3c15fb7602a8e34acc2d18a6bcbe6ae9a97d76bd3852f0568796889576cd67a0b46157242e0fd94395ca239b095f6f665a0a3685cd2eabef5ef98e916c8d5ad267c6172341f88e0248a60907e15cbdb84845b76e996ae3eee749396a4439544c1b0efaf9870fa0857fd9a6c23e1422cae7297d7b39ea0f87c7dc3728b0c7e9dee3c8fc9211e8777e796c2b506fffd72771cbb80e67b5b4892cea17c3191cd679e1816c454304cb8271a92a80effb15db31f1f753fdd144cea7cc56d87c81cbc77565dc7123b09d6bc36e2e270991c10459bad2c2a04a1fae928bf88ceda547dce4af2e9534f0c49376738b869e84165de49409a13e55692ccf33e78673c5496e11396bef66574587156047d10f83ac37ebf9de5d024be26adf4c81ade430ffa741ae7db2e5fc93762a4203e8a33d02683cd62fa7336d08547c49eb7d04e6cd48f725a239e9f9737fed7b22cb96019d08bf9c7495d308b43f8dee3fa6d68b052b23f0863aed721f0d054929416c5c8250c88893449386865025d481ca92ea3e773bc0e6bb406f0c270711a8e64f8d1bb0e9589f21792b20d294a9ec840b5819bc48d103dd295947b19f8ae6b802779cdb48f470cd7d5a11f91c8de512eaa190f24510e59ef8be0bf6902e0823c893bec5edb4f5e0152a5baa3ea8eeac3da5df87f96c8c08975ca65bd65d603fd1339857114c611f1fec4933918915124510199c7003ee5e1b31f20c2111da6b00db35d0db6b3f3719c4de3b80f29f25cda92e531fada7273b8611cb5ac27ae3a581f12a7ce7238df340540f5d3a6240fb8bad1b1d763852c6bbd040083864ebf120772e0f2c4a1a48c443f5fbf92e1463c6976fdcb5a16945e4c7c1fbbabbec21935a49aebc6b8368a09c0744e900dc6f13e0836d9f133913f9c25e9a332589f8eaa5ce2e5bf4edfa3b558025372fc8f445211380fbec3c5019ca912a1f7707cefcbda2a689ed4d6eaa37e760f9b1d390d6e44eb8a80f0ba8e889118fdddcf311931453e63f19f847b304a97700628f8cd0ec275ee8d5acf0f2b1da7ac048012571aa1d396169d7c84216d9c25a3a3e3bfe0d98231f31df1438f8f14d32ded9b49b868b5959eb3322e83f0888b253ff2063d5e785a68a98cfac697bdcb36c89d0589888cdeeb45f94081aa9d22b165275cb82a776fd18473ccc85bc6d3e72ac52747aae11e995b61e8fbae0c21e523ad22b8b1155c528fbc618c6acd48ee605e74512ee724a78f611586980d039c43b27f8f216c9af3b307c6c8a64b6fde275b69001b363728f200d840e59a0e9c29643d8fcb514c33e17c5a4cb68e441134b5db94345f38ddf3715c248a9d403ff51eca5f5fb4223c1d9f4de9040e030f9a236f6a7800c18b9437a790ee8bb86110de0995815e23aa796139d9d7b6030137130869a2847d513cf41900fab68f0e9cb11f1058bb45bbb1796899854adfb0ea9a9a7cff3371d1a3ebf5545dc1d154c44ebc5152010c2603b07c6b9e7d018e4f44d7eea3d547586504fcf1b83c419e74b50f4cc07f4aff93a445c8a61a779e99bea8b5b246992cb974bbfc438ee8dc204ab246cb3f95e09c97ad2eba9358c916807c722dfe6a079e776faca8c647d409b2136aa80c516ee33a1ab581478fc351cd0db2bc614d6b7febdfb7136999ea2dcdf9d3251b2662b35de827d8c39694559e0238b5fd7fd4abaa2087a5c3c0f9bf4b2d53f0e960b18056d4ed3f98581cace321ef8ade7c1a41dc4e6508f215d081b4ee70e36cd7705b66eab5d3b582f3b8e9cc15a30f23a151e21c557e04f45c56c3a2823fd6e44e0e6ae8dc6b0351e3751d5ee0fe80bf6c5edebd6493c4d2cec34ca4cbbc8f334652200cada31b166056cb6ea2106877aa03a2a87cbed7c87d297dd11b2594ff974e75fa0a76f9ebac4737479b37a6e7fd4aa84dc8ef25c51d69a982570005f81c26ec5f9d1110bd739deb3af2a6040a52a27bdc11c91496095bcecc27fd377c335af27de6ec62f58f7f8b0105500cb1274a039cba730510a1d2951f28f7c6af24467b46ced9c86b1309df199065b1eb51199ab9beee383eea02bd4e9465586e0fd642396146225e9c2b472db79e84ef90638a50a19a4c81fe6432bea86e8257476a65d93b8d1302b15a898ba3ab2fd4a783c48f9651445b31b17d6a97c2d2abede25d476d20f2a94fba4aa364d6acc0d9b5c540cb0983f294dc1d2c58d2ae3a63ca948a3d715d24b6f565eb9dfd481a29a544c954ffd9d34e61664ac0dc7132c1f29a3336ef0b201f287a55ed87e6a043def7972b8e40baaeef6000b777b3c2b0e27589ab4b34adacd906455f57fd909d0e3e08fa5663a20c29a31dd94079564a5dd6ecfaaa335f0235cee3a2fd7fea79883db0f1604646d12deaec0d6d385c68e0004c7ef6afd5f6a842fb5a1a114aac229212255ca1776350059ce24795d29ce5df4ca6b7696b081e0ff638c188b0836e36bd3c513cadccc73a99d7f7e395c776685bd8d4a3513f5846c32afdc831b19a36db988ec55978ae9f2a715946482fc69bcdf686babac6435c17723de2ca472b0dee12d11859296b553b293e0f282b6d5bd7407c4f89ec0356f53a28b0547c791ba3962e71e7b7edb5b1fda58b874c2619435ee2e668d40076eee902dab3ace511e5c5395f4b323e8ca55fa6c150a9b44d9d5840d7ae7977a3b0d528054dfd50e2dbe766befa5e3a0484e81620dd67091a606f9218e478ba238fb0f1de0cb307b2cf374d40573bbe9f29fc40a0142d39ccdae7f7427b3b05c20dfe762607ebc5893d170095d4a10ccd1d918d302f15dba592fcd23f3957b16644b4304f244cd71d80f5bf4b36bab7835247758d291b96cb4f1d1c02bf3136e7ea075f481620f9da96a356982722bdbaeedf0ad63ac85678d0214c46e21c245e5f7d5121f3e89b7006143ebb821d4c91c1e592ccf3ae3cc323ead6d8b5cd14ea8356b8d40e1ea22781a1254810d3dff7bab150cc6790c9b2c2625c69151ebd100824c8eb00298413083bff3d18eb05f8c1a5308f231cc15e60495943c5c0662d527baaa09031ee6997b43352468a4b8e71da66d19ab30cc2d1a26d3ed38d5916a5336fef1b8f8ed323aceab7ef81cb6ff71c2ef8ff03a0edb7e8b48b699f5befde2c6efe77eb6746f7e5ca9d0ba1d01a45c48c4704c6482381bf55cf1149e1e191cb3697d86f2240402f0e43dd8adae51c2ff960a686dacce3265434a35ea0931c6cfec2277661812eb12dbbe63bfc82ee8113a6c5aefdfa09f8ba4c0f3cd1d274ab76b933dc8fb1c04ca914360c56e6d481032e6667a45be3560222979b8c9842c838955ba73ba8c3c26101c0acb4e0cf52615cb3145e818eadd31f9e4c66e689b904451965a05e883ed00484c148059542c84d9547fae4a810b7cbd7531b5f32b8f7098b63df4673b94d27548cd944db09836b9c490d3d6b8947e470173d712c24bfe8f676b41f08c3e9fa7cea7e5dd1a295a8dfb0574ca04b14e5185bf8e7928d9deecea3a4855b0f1e0b9b43890e50e612f5d102efc5689d04cb6151ccff22df8eb079958399296fa531c5fa26afdba4e381d81796db509dfc1618642e75e3720be000c8d79c76dcda310010ef941051a1698420ebd2a5bf45563c24773d046be30fd9cda8c5dbb9cd31d5f1444e9647a81148ae2c094c2e4eaa4282f1df653c2f8da81365f3152bc08b71c5b7776eb10147659237cc886cf5af7ee1a4ad73a0ab66fad0b1c80699edc4d364f8ea0bbee111ace6a156721db2bcfa356c2cd595f10736d6047ec585eb0104c8d82868f7f6dab0f6532576b3e28b75a6f59062e5a321bf2847b5d3fc2dcea4f488cfa1edc66ab23cc875821ad5b9558451d43f1c175c3b5737a382efe7fdcfa8fb1eb73eb876a55ac716af62a20b8baf0de63f08a198c6b196c13c65bbd330e3e1106d783af781b60f156b126e952587192e2fe84b906cee6d0cc28db5d719c004bdc8bc1e46ebed78190f8961084f58074b7b29ba14e57379b3d5cc41e974bcdbb68eab49ac8d4134ba712628c7a0f8bedc5b3da3061c380064d1d70485a65cac3c5276d89a876f6ac9e5be4659e2ab44200b6876c9a5b47141b6dd4d5280dd3cf68c2143436d9cce3cbf791e477f70d66a8c1d76b14f47bba22dab4d31c4cf6b85b0cc86305477d5da51fc4647a78e5d47610eba5826c5b538aef3ccbae3e70810703bb380f67e259e873e2694464d91695c093c534d16042f2855cb95be75a45e9219b87f25342e10b53b26e357f57cb5066047845765328670e0c269e7244ee5be3f3113ea565b825d941dcb5a2ff0be1b2489ef15996d693748e532e88e9a9798b1a32d71d1954d69a87f481347a672a725960c90aa3305290a6b4802fc6288f3c273233d8224f5bc114971780633e171b6e61652917f0c154fb3608360ecdaafdd685641289a1832d7ba8c8c721ea77f63dd6206d34d5241660448eb12c1c1638f9832940ef950e7c6453cb71b67bfec6fe8f5c3b49ad04fb59449222bde3ed74dd0c7aaed1fe7886db3f7c9ff9fc68f38dfdb016a9897cb3492e7e41016df7d173fe1459d5e8296fe01b48650e6217d3085c30f59cb24205321e87d9f3d14e17b801e47520d7662567e74bb5271d30616d5d034fb07656dab527003f5819a636328c78450749f179e8f30bf699b3d6ba779a3b54c4b66dc51e6047de5b5aa547418528ea69750d33bbf925351ea412bf051ddcb68a6182c5898f7a3de5d65907514bdb1f184891ef4e0f202bce504895036f86d86f5ef95b25036e820827806f1f2b1f43c345e22ce797e3c911ddd18a67261fd68617b48e37d3acbc62d1bcb1dac83abd75123a2fe271f8bc715763449c95e20a29c8232dbd0ef7809e68c96a9e08ef30f980f35672327fc5621263c2bad566d051c0b0a9ffa6ed34e863a162b6d8ff1b369ea47511f3db5777415e4a0826088a389f1bbfb7d7a616fcac87fe955fde16876da8accdbb636fe3af388e649f770cc6b15d86e97fc4859ec5f8b60c428912c3b56fa60bc48d790b91bb43892930b0c4bb4ed803077d2dd8208ae766622b33460e7ae5ae6f78f55b2a59e55eb02a93e64b4ec29e9e6608ee649033aa6032f2a16f26d6b91f1549cd218338e82195ae431b14c6983a14ae347f8c0a9099173fe9a9e831ea749a0315ec273a07c1467eca7c24e75a9f0cd3cad60df37236a6847566aa3e9dc01f71fa3f88166ea213b60473554b2478929cd956dc68cc54588597c0fd8ccb6d4dd1974881af9fe7c6dcf19ab5a8b68389ec78884fc8686b7b11c4e61eb0bdffa773a30737f06510d8bf0e1f29f3561d8f9a306c20e65d16572d8ea2309b022cfa67d59b102fcfd1ec6de093075acaa556e704908de8b5b6513291ef217edd903a3dfbfafe25302860660ea2b7b792e1252928bb47405ed1d54612b32da0456ec41323f43235d28600a5d363def4950c8bd4f357f02e8dedca3aa2fd89164c6b009a2c5839d3209231586c7a8a0a9fa73ead89290f8ed6f3d83074fa6710d4e6e713c8389918b7c1add053c82e46d13ae72fac47dfb99898cb7352a11be4e5c959f4c657a5e1d3558e6bcbda59004d21f24301db921b73f4982b7f939a98c4ab000dc06494ed76dc742d7c00b8d15da06575013de6ad16b1a5089d90cafb34da0e0c386b5a165f5a525193452534d9633441d735ea25dfc311a789877b79a1742ecdb2251fa5740f6951bb30ae2e04007687c2cb0c456188102ead4657857a1b5be9c34713f2803fe4bd235ee80da6b6dd69431dd71cb1c8573c4e717d164ac70e43b1185e60145d881091e1eb2aadd60f902685efe9a5eea5cabb40fdd5abcd672aac2af3c00386a49aebbea4ddadd5f43b654b04d27aa26526a4ed95edcd3378df5b8230ebb6daab8e46240f18e18bbb1050509f51627420c1c1e7d938b990dd460586f09efaade46b42e4056ff0fb9aba7ffa93beb223c50af93e38deda3b5b069f6720d80c0280e6834b0407e8b596dc197e34df810af273177d8c5aaccdf14360a3f4cff76d51ea3c7289efbddd9ff528036cdc09b1ed56bb841bbaa4dcd6994be9b75bebbf0d2f005e80322815fa3eaae07e55ece160b9743254b0df2e14048004de42ce62634f6daa4fb39a7b8d02e89b093abb5de4cdd6df7bdee1c7989173080f94ee9edbabee8cea709ac2612f13581b566a6a0b60e415b6a87dd90db309ea2d0111c64f5e34491379784a7f89c4207a312913ef9dbbd6042037be37e7df470dc9e892173a17f101bf302979adb5a7cfe6836a43bc26fd6fb2045ed3753893fa5f23492715d711e85ca1660cbb1b402c56108b3b28c0bb854c6d7f00f7eb8047966e267c7597f72a0943cc54f72329f105da499bfb5272b02c1f7faeddd65978eacc98c5553222310dc2c9cc65d434eb630eb60870dfe2272733b48364d325fcc34f4123f1e65c9368a8c61c81841408670661b1e4688ff369f36325e8ee8f967f8dab53015a154bf53c805b1f4bfb60c1c3fe6b314b8f78dcfff50fe34afda815901ec0d4208a5a4e0b8b7a85a06d1a03e8a5873f76dc8e5dfc90be63a145f6482a4218986bad68ff72d419470a2344bd8a6dd7c0f8fa0e82b0d7db8b93fd39e151fc2ba2a3b40af864e67c7f5f4783a3c3d2b7f8937b1142db9f638e0743447609b8afc739a9782f34de296c1d55ddf4857971d15ffb3a8cb1f5a655c8a361a930ec06b5a18db06e52eba6b6ac4fdf2b016b7198c79744829c0e371b31095868bceb072b47dff70b2bc51e4c5927319e1093d8995182421df4cb7b8e1f7f6dd22943eb6c0e50e50721ff03ea227e187351521632c455e50f773ee109ce325896f8ee30dc7a3a86da3889d5b7a312c245dc234fe552f6448727919b201a050eb25dfd5792440a804394675f0e98d24ff6fef5ccef4c85ec5713bde602ac8069e6744bbbce00f91f54e944d6c88d8ebd8aba39b83d6cdbc3cc2e2166d17baff80e2653626e72017c0a59c9ade7361da8c1a9d4436655a8a768a2e07fff905e3350fde90aba17392dc7931c621d56d829fe2fd4c77be294f8950169767d6715c3a8c9824d4e5fec4f114dac687c60c411d2d65506892b636d5f236f554bb03b173b6717159159215d358f35b08a663b11c96e59e6662e9a6d78312d6448470550cc5d186975d78a4282ffdbc6d120f47a666c10d88badd83e7ba00ea4d5ed502d01a89cdb80aa51ff483e36b69809d0c1b1a4c783477ff1b5591486017e7398ae3ebe0e5ca94239f1b63e9c016784cd8f911c74534e1daac3e7df40da8508135dc98c970a4616f805c56138ddaa3bf6593b7088906f7f4ce9f3228ec00f817307ba2f9da4597fa43ed79fc9f109de0ee7f2409fae7d6e63e2c2e27c57d280da79e900823c862f0a0bc94e16a44f31ddb5940fc2b1d435d08311c9e3d24296af0cf6bb9aa8b0f2ab78bf4ca8f861ee5cb9b6c5b65e531d1a47dfe6ce8b23b975e8f9c4a3fe32b2e4eb8bf6c1e07d72a8ba47a77adb90127fe28cc479fc8248c09e1338b4afaae1b6fcbfa98c464ffd2dbecab00ffa2d08d3c9c280b6b56b74392236126f189e0f0f54ccb1cd0b8577e7d28473215debb86fb1167de028dc6c27c1f821d9e53da6c282d483a971eb0f0a1ae7de86d27b5ff297fbb99f3a83eb56f13bacc4211fa06d04d9e0f3a6bf38eedd57c10f383800a2044468504ef29dcbebc16cd71e90f2e13e87c78cfa21dea7d535791c5cffd1c51bce5f94d01b77ecc04bbb81c32ae94139024cfa4235dd057651d59cf57ff5dcf314c7aa9e176bf953becfa74974248f8bc27a0d4086e6a5d3dc1d3c68b7991b8c00f7d2dfd3526979c157248f0ed419fe7fd95a3d01ea8a5753a39b3f8b991e2eb2f2f5f49f132a083059aa360189ef9e6f502c70e056b1ec50789d867b56c6fc4cb95c6856ea7d960ed7fe73796011e2a13713dbf040b0d8cb106e85d3b46f520554575e791039487b848a0c7cc2ae18610fe30905f65ad13927cb34958f7fa6694aba49081064483cae8c8dede7d3b59e8e1811c639f416498eb8346069f070630ca5f1a3239c52ef11599cdaf609eef7648526578f8cb87ae4e15cb3ffbd21aaf3ffc52e39b9416d72c6ceb6713ee3f449c752e4243c53da745f892b52178b0204846cd02257a8c5856b80660a50b3682975b3e693d8e2424703ab41a78edc99589a2c3dfaaf47307367392ff01e452d9efe0e0abdf8a8372bfd3d8ac870fbeaec8f9d2ba57052622a1cdeec6a8d790cb344fc592028dc0fb9eae170e95eeb1122cbeb94ae11edef5bdf951c751505a1a0bdf314dc916634114c45fed8909e5d24a6684a93e506587942a5709382b8e2e265f9736413a44fcfe75e6d7b202b9b8a234dfe655ae8e0ff9467a7ff0cc2a4f065ec7fa4354139a71c8caf77b85cf87bd512619b5f36f1cf8669d59d9c13b8c9dab46a9a032d03b18c5ab942923863743cc0556529960c6a9be501d8c90204b695beb16d388e6f3219b0686f838aec03ac94fcf26a6d6f366f5c7076009e3ac35f7e5fd98499e8e5c5517ae8345e5ca276f4c80d13d3f97a9953b50268fea131e32e6441a9a1c2f72fcb1e73a563fc04e289b6e8488455ec30b10f1bdcb12351b7f35a523f19dbaf5a56f955998bb3e653668d9bffb2e378e30ec00d0682e5032355ba69f4c754bbe54c868b286561a5cec07a1a636e4cfafb8d50b17cff7fa78cc08fdc9d5a71845b24935dd11f29543acf1e329446670cc60d5c1aa10635ad9a2aa5e7186bbb57eaea791a375da1bd944f7d0ad2fe0d840f7808c61a43dd279f536d33fb17ed9605a61733c8cce696fadae373285a1c1a031def396d426f57bc201144409557209841bb5bde4479aba1df61b57eba2de7f561720a53748cb917ab02f264576f7b988a9a136240b7e57b7bda982ab31137b475a9f0e0fe89e2cbf58f5935c1bd895f18acf4c46268a8dcfaf125b1b93cf458c6b843401452396f62eca9900366055ea208c9c1bfb8186092802f466a2eb249171ecc1612ffd4cd73f9cf9699bf3f8cf66f93a3b4dfc89b16f5a6940f51e071b62cbdf3d540b029c8193bb9c48ae99f486ee2256e3ff0757c15a865b1af4ef2ff0f7f84531425b561c3bd0de1d13fb2612f87f67e9046068d0680681a403eec70eb1f8f2e0c8dd199c9ffb67d5515a15f471a203ed52fdb23ad7672de7a6c95305b39e1cccee55cbfe4cd6f4bcf2650c95100b181fd7e8d2caeba9036f0efabddc3179182eb87525d0ef4a8990092f46172e3df369bfad62d075f170c249ad41f300714148b497ac99e62691fd8c6b57bd0c223c32aaf6a79bf96653eb79470195346af4d12c2e371ef1470e1d878a629a822f0d66d1d4f6c86272445966e76e7c88ce3191e394de2e177583a286b62febbe7febd4da9f3f85d74fdb4f051375e913784deb0461fee9e14a9cb178bceb947eafb195e894d536846ddc66123df310e8e6f1873ba65931791cfd387f14c3132a90625e89af5782338bb11db0eeb7848fabbef1ea3ce0471e20e4e97d7a2617bed1258c20df7b29207112fa85bb376768347c25890c3d213b23fd8fdd6ecb742efa9d2adee55dc9dee38a7e32c29220d67a9ea21c80335c5057dd4d311e9d029697febed4250b6897eaffa86e8c4c66802103bb782245785729a6993f90425335b1452160a61b978c074dc7c16b3160913d6d11b2c0276bdb6cda13c163b233a1a115320198055421f80d774484fab86136e09c925b1994d51b59f096b9839cfd6675cf84d1a7eca90f4db96b7707dbcc1f7fbb708de511c9d567ef63a3a38e94f40abefb0d1f0bcd1e2bba4a849ba63c2b0438077a1d38bedb8a357fb82da65c43bd3856c625345318ca0c6a3ce9f9be903482863e4d7996cc77fc6c0efe4d7975dcfab1edf10a6acfb0903b771e57d9ffb0b310355ecc682f61b132c80364930ea9aceedf9600f222b11671948a81529f97fa7131b16960fc3764446f468f4addd3ea74334b8ca4959479f08da2b69c056ec0ba3a1e9bfb2924eebbb3d5d9cfae4905e2f53d741fbb311f4a8a090bc83db247d544e2cd4d0395ea0166b76c96a06b62fe595f7d47fc183e6c5277e8172bc92d52a2e845fdfbcf1600c702a20a9e27d1d619090880b53f6134bbea5ab36001f04e31e046ae0c510e9ff46eb20dcfa1593165a6b4eaf81401292ef1172bb5c790d2c462987edc921f58b6e6a57487e84f4a782955273a9454ba9744673a62b726f5a5cdfa1b99a5e43553a0172ac8ef8425c0c88ca96ea8b51c527c1e98013a012b387558ab2b52565816f1dd80b47eb5d44ef43378b8d28cf12b31fda555613b01078dd5486674f7bbc01b20edb96a088b17685b61389dccc6a368dfdbac997df4729759e0b063f1aad2206065f6ef7f1cfa703513ef5788dc5c556110e653b758277c78afd2f75ac4079d5402e4c7c768cda9a1da97cd91e7094adcb329955e1ac24e65886db46e45fc41d93c4a115e94dd4572c6d5299993aad2b3e30f347181dc366885623d24a1e7154e85ed421b1cb52098edba916bd0b0445847f74ca90c6d439dadfcd1d14a4e75f4359574ae1ca59b036e6be37d86dd6bb5261b33994641c840fb2332ea044b7ca928ab4f97769cf70d8d6789683aac40a7a8d00dc6d7a2cf258c8bed5d7d6f600c8ff8a1433a8085c91e087b3862ea22a3b3a3fb6542ae8370c1991c39a63e3b87d731d0523c41563c7b8a3d75c78a8d51d5b8663ddc50f623238bbfb83a2bd059809906dd3f68993cea2ad846824801964cf30926fc5094292ceb18622ed1e09aee95f8a976020dea37424ad091d5127db70f1b4d508d8c2a8b3ba9c4525ef0255045a523684cc6a3a15a3f58e8271c31f596d4e6f75dc3873e691b3aa0a586085c67de62cc39904e8e86b6a5dd57f8c3f5b4fb610335d07ebc8fe2c92e5d52a426428ee648935ae4a0891e69dcf810eab046eed934f3dc02d4d4f0a9262f166ee82d50f6123b06f029ac26e6e2a299888998c181f860c13d41adfb5c8417b2bdd51fd6367c324e46d8aa3f6049503c1b8209894277b797c0a78e95e21d5891bef3a5b9e1827fc5f33546d816fbfe977847a00bac7ecade4c01ea5cc27dd88f437801f035dc9143e785813c09dcadf84013771c691ecac7e55ca929267a0daa8d16a56a88e38094bcfdd95facdce30cc565efacd2cae582f29e74c248ff37a17e7855c8337901b31eb07e52626385fda40287929f23a8e67bb01f0b0646314ed248e2cdbc1a09c73f1f7861986e9ff5f25d9523077cbc6a31de9336c611c055c6bd65bf0f3b4a125cb528a2f3190e3b1f8e93f03385dc0a0dd0d1793210803fcf069750d0da4bc8b769351d29616d48ea1c69a7e53a076448b57971930a8953d8420c981aa67222930415ba44ed629f5ee4cdfd88c07592c8b0bc4efe4d971357c619182a8b62cc6743410493835c5ccdaefe0a04b34191bf7852e7587dcf0b5bb18419fcb4930a0e9c1d52ed33ba5b32aca1325884c6a44ce2b0bedded4eac2d4fcdff75f631922be2741bfd16a786546684b04cec23f2160f99e9881abcbd0e9535d54828a3511a6a7ed1c969b213f369fdc40f7566549572ba8fa7f5d6f104499123a97dda98d0acc678be250e7f07e9395df06b3ab877bdf496df780c1050456c5a08bc83c02d67eafbd294fdd20980139cd32cc1b058da423e218a4905cedab32c0a4fc222a6046574c3be92c38840c4407494e157765d38860e696cbb50299af9ea34576fa50ab5bb34c89632ca88361f8e5861b44c372bf771bb27ed9c0b7546c27cf2a6b797a47da07aefa25eac780acf4fe40a68d6523975011ac19b1221bde00ec9860e5ad73fd9ea1e2e320c974224c3ecc76235f5deafea28db96b9c61437c51a3f103fbc803e05a5fa6bc2a464e1a36d72f7579847aad4e98985f59605594583b62eb94190d5dd0a2857f687a698a3767a53ff8e829ec15237bfe663075ad76f7c4165b096767464f269b41614e2a9f69357b391b6cc37942c969d947a0614653168fa298529a30f24ca7cd32505eae3c4529a502f3d477617039f4b144e85fa7e63709bd02c93d9918d26044279ee92a09cb00261cedd409e462f2bc7938b7d13d8ebc97f82bbaff3f354b9557b9f7855b911de9a1e71be29eedd277cd3b6c551cd8f025375eeeab8c2430dfc799b1aaeecd9c00b92da86acc5524fa467a343c8569e7efbad13402b2f2de95b6d1bd653b7ef1df8a9b90258defd36f3d1db6773639232b3546b2dc9b2376f5871cb941f1792000177310f18ae77f570d665c70f723f863cd448cbbedf5f9db5ac4cc8c27889abd40fe6616a3e43af3e54a783fa738321b68c90007576fd33e3a6b6134d8ea1c3b48ff17432e77d33f78aca0722b4c402ee75dafa73c3d134425f6fe915ca9d987c804403ef7b30404fd6a9a6e6a554639c022698196ec82d5d93248be42d35138735f9c945fdfacb6510a0e58f71c955d64eb6a3ebbd97dd39b89edc82de7d4fa0d7fb79e87702f4b17122c20576e9ea8cf1e9557a147a09875ab852a0c4059d9296cae8d143cf3ecacfed5c310223f0541cbefda898d72d5e0aeeb68ed0d85c28d52e30c1895e253b4f9622c206ca560c3da62221a0798611394c6e80deeddd05bcca73b2698b3ee267e66c133b74afda41b27329c2383c4ed1664200cfcaf9589feaeb35d41f2379dd32f125270ddb6595df56c61816b282c2a36c6956b0ce83afd6fd0f5b1849982d2b5f92d1c984b25a66d9ac3e7bcbce57fb5b5f93f119194739e221ad81c67bd3184f2de6d6b2482913f213bd42f5562f6d04d9e21761e3be16d703307c07b9d48ef274a87397cb50e5da8ed282973924d556d96a57c86f9471c027ee47fc63d2828afee8f4609d682b960722aa2391034c6c1e954759519b7d5fe490899daee1d02551d948a0342d2b6be637e07a92493f80c1285d08faf658603df7c9a2cf825cb760d33417e37322351b0579af8fdde66241172dc30c9989c251de443ae3b5940ebdb67fac26319159ac5d48e4df3fac923d91ab5e1173e83513c5f373e96b880a4c64cf5a1482e614dc6e2ca40ced1d8213f2b8d3ec6c08e6d76ed47f71cd97397dad2e9f21cfbb0fb0eed5354c00591233ed8c9e0e7d48f83dfc6426ad70b577a0606fed219f8cff4a5c1b2f63935b57ad440a542a163167d270c8e35b70d80dcbc6fb87bb6675da1a2f02a1b4da49bb22924db7b41f337ff9fc573f18d92dc202b7585d1b876e9ea708cdc7e479dda769713ca12f14d8f6888c3f603f75d2dac3a3da7947c9416a1c2be7ad31e1dc5e66a88f51be6489284ef81bab0d75e36431de2013e259bdd22fa8834dc20f139b3cf623958dd7efa21fa52864f154c98bc0ba1754e695807649ad4c0cbfb5670eb80f2536293aacff2631d36fd31827fc2f7beb5a0592d159e45e9d95af47dc65c7c9d935067928d2d067dc68d7176261eee21b364ffbf25199bff662570b98db36791056e2cb40d2450e296451533ddaf4acf7437ceb8bc33ff19c0d7870b8b6aabe46f89363f0e1dcea2d9427ec7588a27f378d718a8c2d72592f53d9b56e9606d5ebaee9b6062ad39cc8e62be50656b48b15078d84a53f6e716a5e7878b37ec0a71483b053855b99dfeab7e0096db1b43f00a6520b0d80cb3113f9937da89fdd615d08eb57a5a7bbc6742040120da3875915bad314eb0fa58aaaf722ad2b769964638ef36545dc2a9c186f70a488cf255dda7ad3700c42abbbf1819d441d99eb3560ba8b7bf71a347a0c0b4fa667fdb32fa64487420a0228a2834ffb7a7cffe7d75fe7a8803277628eb4bfb82b2b71a9667a13725430de0c1574aeaa10edfd8fe91d0e4d1645e0c46eaf1eaa139f852aaad3781e13dc7ca00cf237d9efb611ef618ab29c49f7bae51b80e57170dd8d424abc55d2cf6c17dd59afa208c81e3ee7ccaef442c96a8a991b64961f63209640aa6f35e5f46ccd3d7d19be76faffb0c0f8010c4105a1a6341d9f3c5450b41ac6c1d295ef4267e1c829c3970b302e82257357e1104b31b87b4df18970be9cd2dfa95e1ce81c8936d82cd340d3cb0d51a1fac50cd37aa4d62babbc741ddad8cfcbcf61bbda330f4c3f896175fa7c26841f6f09486b7e3f79bca7047fdf90114acee82dff7212bd2a0b4554383a47f996b7030054fea79f05af347e4588fbc1e5abb33dacc2947f2d3e3766025cf65d3db5266b35d5f1811081ff7f594f549a41b42293a12ebbd128c6756818dfa9e24a734c9fa534f09f252bbc52943a797593948da2619b2235f139c27b12cf134a85c4e9d9b68fe4640ab7be46084152d981e53bb6ab20e1a5e991c37b6a62b024afd01087453d90966fbb7c60b4e432fdc37f6dc59e1106ab12310d28b71674f84d29322399a3465ce329f099f169c86bbd23969650d8eebf3dc5368999c9f6885d5ee1c3af557a0003aeb6169859753e48febf79a98284c359ed0553c4d27a2b07bf64eb071317a84d8f9ddd074394413f30c52d54bd6ae8222bc180451a8a3096156e3b73ab11ce4ca82bb9680b7df8378c8f742899aab3a6d801155a8d7a9877477f706ccc864dd03ae3fc4252728eaab0c78ea815b856b020876f5874a85b0076e293c30e33bd2bc8bf6c2351423170c79bbc097fa29cdfca47c1654269617a4779f0e90fda74c6158692a7993ac0ec861ce9ddcef46fc2ee37f99e89837a6312342123ae782d25478799b1e69f2b60c65a741c0a599864a28401aeb963d6531b77d93fd3843605daaeab9ac918d01d61a331ccd0f94529eb380c2bc168a01afa162428ae391a1fa4164bd2896e74a0143f49eda03902dd2aa8366d00e2bb89760ddeb107206b9b3f4fb00caa2a6d6bbc58e8d18d3258d9f23c3debb201da9393a45a197381e6fe989d594e1b2f0f54f7977273bbc36cc7d407cb1a64e70de586a2e3623be7e4edbe4068b0797f29b90182252a798832d4d8d336bfb9e2eb847ed33c0ea755e3c3effa0b97b39b4b178c64cd2e2e9397bdc2d73aa983bc68ec7e3b4c148d798ce6aa6f59df651e2637894fd6a02ff1c4164ab1836c8daecd3be00f1eb53150e10bc06bf0a31ca39cdc574926db6efe2882e29194e2640c04f1e318c834472295b40e9b189a052000eb45ab98034bd5bb3a8a00d03fa3bb36ae66f698053b49e459231cb38d224e5f77cd03921b0beb8d7bd97485853849d99e56eff3ce4c0ec3203940a33ca","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
