<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"8bc6cb95286bfc8f61b9e7664b60b91b2d27cc6f08ac12324ec014878d22f6e3ae81b69fd062101c5a8f84bd0ea8dd00c8f8fa87f2ab55fa77693d29d580b544fec34eb2dfdafd641122ce9e80d37e9cd4d45d86318251f6c799a8b99f0700fa16f426bf92b81d6570ca30aae0652401034053a07f02772dd9b8345d4c02f5d9ecc58818f9e3dc4c66a7252452b4f5e281d4cb5cbf35d8804406dd16d77ea3cedd248b55364bd618f2cb5517920eaaedbefcae37a25f0e3487ce5aa83e1b22f023a9568969857771d49504518bb7573a8429a967a662cedad2f2eba23dd2531f8bf5b31f3381c20d20324ce57d6d4ad2879850a3a7a97139f302f0e6456cad80bb7713c6f7faefba1b55576578140b098f2528381ff9d39ab8801449c0ef261e11a350568ef1159c11cc8a2c86d904d3a807438699a2d7a6f08373fd9822700442b7811fe6b81536f95908d9e0f6afb0fcfd6c81686791f1ea5cace656424dca5c8bb08d170a69863d44a68fbcb110d2f6579bc7f066aabf134e6832327c6f2e2459184ff74bcbf466375100e17ab8c3a9e0e21f554456e2af5ee5784f15060507a315415b182b672eeec10cbdb8a3bb1d2b76f7897185c48f8a4c55ceb8876fbc1592bf0cdd174a835ee801e09e39b8a204fd1e6c00dcf7e349325b7b4bcfad3fdb0457b1d70a51a63aa3f72bd52206aed30580d19b4f0cf7cabbdbd13b5ee7b11f204008ef90881ee2bf68a1e43dcc459d1f2541990bde785c13a504c8a38feeffec966c1e7c863ffb3a813cb06fe36c25cbb42f2c8ed47ac5fe8c67d21af78874420ae4431d5081ade8d436916bdc339906db4dfa702b17867dc49f97eb80fc6c3be89db15b8c434ce6f109e3a5c9e6f7c85638151859b73388fd8953a4850a91749c61b6bb1f4db8922ad555bbc702c2f4a477b6035844be0657b1f448ad8238778f43f8fac99667d20e7ae4c157946e940205fce9a123681887ee142cd0e191b4231b5b60464bd275855ce4064e639e7a1e25b300e73bedae8770a8d25c68813f1cc761dd0b9b60cee24927d488c132b83ee92953aaa9707debc73fac358ede4a198ce07e6f34de3d99a08dbaa2d88825627d7c74b27dbbd2417ee0eee4d8a4ad73bfce49420b28c9933cd2815b1604c1e82a43e3a866f6eb056a48e5ef81cfb75e7441deb2699d13f3c6f41a7eab3c023d399eff4eb339611231661ad7d022f56c52869f736b704a601be9d6e93347fa079e6d6dae52bae07e10613d163d74ebae83e0da486393ab326e0c21f9303c4386b5e271e213306b515fb9e194de3a3628da99916d71e9249568193fe8cca51ff86b1d2e70dd5e8ecede2948778bde79b6161ffa73b1897c2c9adb5f615f24095eb41fa87ed29fcfd94ad9a03d8bd76618b612d9d39e0ffa29a0467af842197077d25f56af2739a3cf5d1f33540ca08032a7f2e5fad3758598679bdb70a7a5fbce917fadc5f8dfbe8bb35e8c2d543da38c22e8352c1774f5be443ebcaf577a55fb71e9c605a910a99fb4e921a0b909709c678203a8caafba57f9bbb7f614fce762c12efbc275926fd5661d86c2bc7e25ad6891210f6d943c019fc2c0e33975cb71fd2f5fe79005c88cc430b7e4808fbbe2c8193823b19e55ee2dde492d67f77de825ce89e966aa1015b0832e25f1c41632b63da9adb4ae4f42dbeec520a45dd2c1e260ca4c001fc3ff373a50eaa6d77b116c8a0a44fe7c7cca3756dbfb28b36339ad62df62e6efda0688fd78579a25c2625632f2202b03e294966280c874b0d1489dfebd8bff98d7fea9e32a875dbe8cb704300b401fe23481ae40ed497dc5897597968b15b39940080943950547bc8b93e362946f8466ba2cb3c4c819bbcdaf0d2918fdf063ddb94054f910f582dbbcd626aa69b138f9218916e836db8a92f3a9dcbc2cf63cd387cf46ef5c2ee9dde818b3f579a19ac40429226ad8729e2618131dfbfa9d0a1e8c15452f29c3c8725d9aa0b35dd046da3756fa58c104bcffdaa4b313948c0b35794d604d8de661d52594d174e5e58b66b5b535c5777d6371835bf340fe69f7602066598313fc7ec6685a13ade58403e920f870ed8d4ef01bb3036a86739c174407d68bfbbe105751e919eea226f42de3826d1387498d9e66d719fcffe661d499907c6f767b2dea5a2b58e2d1ad9dd1693cfe0edf95a23c95ae088020e4d94d4647aa16f866e0baadff8ab20307078ef51f97ccdb95622d21ab3c44bf2634848f9705d9b716c881bb48d46e56aee6fb80f148ae3edfcc60b54806357ec7f9744667f6dce7dd2bed0e71ff397cfd2166ebb7edf357b40ff19daee0163f7d0189db2112ab1612df81de623c76582c19dc0535f408b58eca6b8f397cebc5f91ab738287d5021d675d404664c40f38ff3c6888a0fccc85321d527352499996b8fd44f8b451d08721069e96766d1b0e094530f7e94a62cc39adceedadb612759879a36dd347809868ab41bad92bcb9a33bb04cc8d8e4599e8724e22c1c61579375c4efd46debb9b8b78a0b9393d2c9aeb48e53162a8353d7ca99e4e8a31e7f1efeda80a1b1e0676eaf752cd1f3a35e36eced7393cc6077b56d93cae8337d36071220c44b085431162754d3446f5c59ad8f17ae461a12332a0b71af99ee187eae4bcc9d48dffe6e2d8f5a2c5a299a9091b83e73a7dc63250ce03414278d3144c9e967bf049d91f56b5187d2a3b7f2d8f233673f351b1cf8c0cb4790d99f8d180f978fafaffbffe42c8b7fe15e31e5b1678db9ec6abb239b51e405c15031b057f15b93b847374048f5f0b74feb1cab7d1f7780429482cc4ed058252ea3d7bc0f2c18db2056043ed4d5334acef13e042830bfdb4f21630f647b51881a91d9f749cc0ff06ad2ce6ec89aa5e7f944f7e9dba50d203f1e8e16dffee702784c911c35436ab51f4ad298db7c13e52fa655086f3c2ebbf3939f2d705b8d93e323523b506789730860e01ac7802bfcb77fd23646206df00c2552197eee38954f0edcf1b00b9c374099215ae6b5bcaacc44edb4ae47776a1ab525ff0d5b01d9386069b750fb59d30ffe5fac7a9836be47f8b68921e87fe178b828394a25804620c7c343a77643ef49a108ba74df5adc082140e618ac2d31b3597f4bbb87d1127c55a03f8b7241ab5027cd01d75d872b6491361254cdba8791e63f3ff950441045a94e45e2bfb999c3303e65d40c2e1dc6edffe48068bb94afc79b5cc75a6a95e4d60528268257612e40720e94a9be80d368bb857d55c3cabdce83eed2f231fe2f2a11fd247ec845c91f51bb20bfcf7f44e13ca0aebb9a80769dca315e5089b6bc35c2c22860e676d2a455dd0d318c6af86c5cf251c16c2d94440398065fd1d2ef426b58e10537449e4f37ecad065b12ebe6865c0f5465080fe6a1b416b5c59e324b55b6b1274cdbf4490d7ac316d3bf1977242d5e583bec5c166131896cd19eaa54eda25d9e13d2a6971d524c63466a9295fa2dedc05c835fe26c9d6d431f4ff7f9551d88f2c0f3409c728b1cccc7274299f089b19dc981547683cbd901abdcef98525232c83c5df31087a4a78823b8c6a67490889d43e8dffcddfc8d30cd257781b595cc124e9640aa5a58822e13e673eb8fcaa2fb69d9ef4770c6a4d971148702722c910ab1bea1f7d02cf10a8e08a60311d025f19470c65d7100810c42e195603a964b3864b4cc4f67a67e8b959fd8bd9653a40404327b86135a2c93f2651ac85b20ab8b39f0d89769af49403dc2ac42b2bdf4187611154afebd344a9dec3ea174d2bee60a8be21b8930ac1cad5e5ad461ab8eec4ec28a951146b3dfa8e668fd4ba543663d3d1b4dd183bf2f8212ba3e589492561f441d247c2358ca6b1c7023e40c5cf6368a20b83252bcd4c1547fcfe0e153a67336281a3c12c229c9feba98ae274e7e31c3051949720ed1b75840343ef594fd950d6b8942ec537ace51a9e011a5f35b9330d3b756a1598a1a2e4e5b00ef8773221371a337a8e534acbc166cb8ea700eec3d5b7e5448431847bf026351859f99b2e7a095741e39801d62b55f154dee97f072b59d842a6348877fdda426f7e6aba9f4cf9d7f60a0cae8aee3c484ae98a5a4a84ec45d289c77687ad3b99f299259753ec71b233e9fa6e30e7a480f2fed5f20c74fed2e69e1ee2ec403c43e585a7f2fc3708c5d70a9513eeb8e3b49a223eefe6879f785e3dda452494d4c33a80e38552e0ecbff356e3e33b3b7a398860d947b2959fb6709e6a5c03a527e028cafcdf27288d1cf2d81b6c189624510c39fa70a19e206d2d8a58007d044ea2f2487a4c118773b87217d7e6ee3c0d1b84e8baf0dffd03020d3e68ea8d8fc8088716b2948355e8853b79dbbecffbc313626ff62fb2b980e7f231327963aa05c307667bdcaedd7c350e323310e78c6df744c7703a358ce075617c111c9c1016e0ecfe208f5f4104c8d20fe0dfee552e353012603a551bf0012b80e0202eb4931ec821fae05800c99302507f542bde9abddd0f641420190fd19f14e028af2c813eaf220c0a0daf300de55704d2f7dca33bec4115e5a76d3f5b4a09c604eddbcd07d9270c936eff62782eaa5bf63b76a703f8a034e9dcc5eff7221c32f36aea6b6c812042985d1496ad1f1770b754b6b1f7f4b2d37bd13dbe3a026aa7d23796e3ad2f3c5db6a875a82ed3455b819154fcd408d18a6c8278857b0ab05dfc20fcaad6d7ead42d8d041ce5601885b51a2280029d371a17b6d80afce09f347a44b33dec5691d33f63de26086137ce569084829694a29689e1c8c96cab2e7c790f40c330069a6fa544e5eba56ce6493bfe9ef4f11b7bdd66a93dae0e6ae971fc6ff768fd878e46b300db5afec5e06cccae6170a4191e7031a4a053a16d0a9347a73fbfa0187c9250f329d4887c03667807e484f5b73ab3df85ea5df4c2e1bc008546d7ab0dc514ea7f6c64fe24aa3d4e401d6fd3fd4c363711081f3474d86525d405545a54dac50161e422832df86e22999d2f848a8ebe31d85326386d66cefb9695a8f1cf478f7d0dd2b400dc8534015c62d76e6aee1f024433546c3901f8cc3a137be5defbbe180068d84f2d63ce39d9d08ff5013e8feaea37aa99b623dd17d0d34dbced79414f9d01013b99c445f6e8ef44206da0bdc37c035bd9a7c4b52f0f3b7a80326f1cec79cec14d768e5abee62de0ef80ed551e8a2d8d581ad40a18be98a5ab0d3d70e7c1efd94d5bf9553493c5263f5937796c8088042809d484fdb269092a5cdcfda5c5bdec80f6b0c0752d74f8ba83aae2684ebf0c558b83ae83b40901bbd61d18633692ac44249e9356310d11c92dc2684df945e22eb531957fb02d5e57a8c7caed8871ae807d63c1f48ae815c66f798031619725f66fc196e633eb1e93edd27e9b05350ad9d1af34f8c7fd7a9fb65d7f4062fd91833d45125fb0ee5eaeb5578953b3c94fc3c10299c55870d1ad9617350761c300441b054b017ca4838afe7ac778221ac78dcf98db97c8d4d75c36ef4cf5b6659c2f4456429ef6e33d774bd1749f5cfb19f1bac399cfa75d710870a5c3fdc1e4875cf811765076053f6cca96d90884e57a82743467b1bdbe91e5da46c5b3570416740b19098653b9b6a7d3e654a152020070ce55ac9e5df0a8e05c12183ac000a4d7d992fd50ef6f70121bb7450bd0d601c003c1f88efbbb31dd61172beec04e3eceef90fa4431d4cdf4592556c06c589cd60f3c25c8d015c2a87884ad3be2e58ed17b3392c53c412e9eb7e466ff5596bda91cb1249d0eb18c57572258e969e5f2167019dafe25b267b4db5c8e37b1935e4cd560ce540fc562033edefac4f37caeb9f2cad26a1fd07c40809f7f796332019064f94619bff305c95ffe38852f6654ce14b0cef6b580de5d17d02552aa3d50554d1364091aaa146f54e2ecfe6f261692ead93efcfe854a5ac69d8be1ff88cbfc07a28546ef1595be4285df7e3c6ec5ade31ef2346d0eec736db3437df0bcc51bf0488ba472b1bd5c8ffd436084659cc07bd4a2d3a0bd78c72e9dec9066d074022ce5045c0b332560f5daef18ff59ed48790aa958b50f57649e46367f305d25fdeb0577c07ec7a395f9ec0693dfa7be07b86195250c303d8b430420129c2e39b210ad948de943d9574fc730630aead07f73fa6375ab27b3112c3fd0840fe87366ab0943e5aee896629174b18c6afa1c35f7960c372187401de2089be977f247c7432c47d0b2e26f1e559d07795f951088f0363bfe6694e4023cff0864098b32ed90e8e912cce5ed6866173a6bd4a5ea2745aa700b1d68b3dc8abb84791f986d29b5d8de89f712a3525b87d58ee674d8f4bd3cd3a44dadfb9dbe162be2d47e04fffe0bc866c134d2c4fec9b4edfd9e60fbcb4f669eb77c39abef9d6568735e0083f7def56027cb12eddd728e7344d54e9556f943b22f426a5f7e2dd145841b0e994736baa80656a285a900b4494883d60b92369e0d7f00da988369483612db21b9f5abc920167f8e850e021e00b2063e075d532499178d7621e25d7da56b9ef12440168f5cb6de1edb84eb74b6972626fd1172220e1d908227ecbed1b94edd7ba29f6e2e5969e5e1c5fe85ee86a02b0b506ea989f9b1630072e69a3efe3eed7027f00b29e7016168b01df9e8da08bb9863bb86244f2e683c27fa35b83f3875edf6f68a1676a6aaeb4659d81bec937760cea229d2000c1e97045c31d2358a53e3dbba61e413ad0d535dfc9bede57f307039b057f36038e689d3d8e575ed3394a174878f0245f49fc5659c0d23ca53d2003e8b54850faf2469263d9b20742ec483786477dc85274cd93d6aa69045a02b715e547c41d979e7db5232db77e599bf82d92cd9570663dc946267c688fb024cb69001f0bda7ca9e1c4b57033d6f698a61841cb4cebd1b614ff458954e1bf6279e056e0051dd7071ed5974b786744264f5aa5b6a902fcd15a76dc745a7be8d98d4a3a32a32d4eab945ef05ed72cbb70a6441e47c80f311ada4ea316b4822171bb1aff995ad55d19af53894bd9f079439c22dbbb2a1b7420a9910aa8bc75b976576a35079cb2392c140411b967af5eb366b81a60c6d7840ea20036a527e367d5ddaefca47e211a20cd281ec926eddb27bc4ad62ab097d5b3acddaf803bfd5249587f4a74b7b8fda99616c699cf381ab36964ae38f06578661a84abc04ec26d1ac44aa08986829c3196b9804df2ba30f3833f073a386347edb9101d4a71508a25d2fa6f8ee6590be099efd7a81dfb5c213d1abe77e271a145780500efb2b77ee804acf786ac90e28ea0213a1c8f5b098df47c723db6b910aa0935f22dea72f26d748c3c4be33e5ebe68e57d5b1458aaa978b9a3935a135ce90e1ffa5ffc36baa68632ff381d264ce77ac554856f421e5fd466f496f3407f57d7fe0a40e4397a692c5f2faf5981413b5beae66c1740bf8e54cf0c057f0e6fee7cfc4afb5140a0ac9f9280e4a0c7276f6b57ffed3129cae2b48b22c02657a672f5dfd538c6e2727f1181348037b75f9f4726b1c0b0003fbd817d899ab1507b77338f338b9cc976096e81882acfd7e48ed1b719cb6f623936b352e94dbc602cecfaadc6f2ea4a4f870293e4d39450324f30bd9b72891f1e7e81ba7be9df20b63870709dc0ff5128a1297496fd5c70cd43601daa10a5fc01952654d241554df09e7435a216248b4be68bed491b2bd200b632e13f68fd0acd447ccff3ba152a55896ac85c938f150745bf7a8f6838c7bf30c3831d376ffefe5c025ac9cbedba7c71b1162e787658622c387d30d3c4d6ff1955ecb4ef2687d9abcd60329a1b2d526d5aa334594e6f226069451e3fd5d658086ed15e146155336e70da5da74aa8e5efdd1e837d15990eb39cc258e53251fee1ca40e83c8184f542ad68b4a33a4423d676c7f1d556a264456735c60833e05a9b480556b43e3dd78454fc2f0c971006aff0cfb9d3c492ae9327fe5505091319fe6ba6b2752cb42855ecb1335d75e3f0e90424ce7e7824ecf92ce9856997737077de5ce5872d265693ca829d9dd1d085c4d2e017118642a5b8106a589309fc063737781c4968a71508bd84a2325fdf3e2b9e441b61d8178c6e2f063be704eb99288a9fd18a6cd0dc853d2a8c42419e0b87804fce6d9664d0303acec3c21b4cec129d287663947e59c48d0e78ce8b7df714c4d1ba708c4170c55d87bd1001cdc3ec1531857e3b33c178bdff103b7f66789decc0d8d995552c765f2663170e9e2b0a7e1a5fda679dba52122b205ba1265ad65022c291dd0476993dd0d1e83fa240e60e8c786b771746e69113108ece860de00da636764e31a1009c386009c3abe4dd4943661c38faa756d72455268e2057096da81d5048b0547727da40f9c14f91e0d723f36d546a97f659149dca1f37a337a0c27011d592bffb9a0444c1197e6c70876a8c4c4c1a79b3b2bbce432fe02972766d074f59fcb9262519ea786301025522d25d288fca601c7ba5bbce4296413e0af70212434219158c50a142d877e3abe3ac56b5288a8de0c32e20556df145c056a2227ff53ad958e9a26031d0ea66951d2f27ef3377c9882b655b05b2e16fecba078e76b411e68e31ff3c1b75b469a635e8107b03af2366e575f1ceb150124c7deb81efc7be3c6b783c68887823fe8da4956c6f32b8fa9e6380af2da719280becdd952e4a74468961c74790849f14ccca7ebdb781d6a8476d776f55e9a2ffb35e216022eef7245af689710aabb1777ec445794b763e1b07bef251b502598664f33c75c867b02e46a31addd44a71ac7b8a354b87fd75b7813510c2cf0bb07fd1b63812c82dc758a1a819b0e2df45b7d236d522bf6a830361b8a35f309a57821b9d5cbe5eac10d5149aa44115e9e97bc9d96dd941cf8c0b27e6bcbb7a8e675f4f165788e748792a915f9236a423a06a225d9be151c786fb15882c33ccadd98333ebe6833fecc89e2a865a403b4db6e21184a26c226dce503b4f3a233dedd651945dd5c0a47b42cc73b11c0eba7a0a46d02fe955c484d70c35fb1e58e45f02843cf65efe73520cec5052cb2ee4da3212cf94b21d68f10b3cc756e19cb8c1d2b0259706e88ae44296d3ffbbe488902b606c1bbbe3d3fc2d746a69c8568b8ad1adedda820b4da8da9217139b85b3d8c9ca782fa04e02ccf495b7d5a18ef2d014faa859603063f8c33d7c4cf1ce012f4125fdecbf99a2e0cf348bafc96bab4ab6b6dbb93fffd0ba9dd350aa411ccfadb24a80a8f1180e2c76016a453928c2de0b7178c4afd4378e6bb1133641c528351b8b27263029497afd16cbb811911d5e140a0154115fba3be4dd73acf0c96b6236b9d6bf1427cf9776c8e7318c64258440aefa3177178f265f5635ec71a30efd359d7638f4f0ee8191361852b8b57e91a942d02247753245c0927b8a4f7f65cb6ab974ced6f00db7fe33dfbc9e0396491ed46a8c0877cb5edca85bb6c93ad8df3110bed731b9788641e5a4e3893364e07e63c5996c76ed47194ab8345c1e4258e40528d7305340185fbfff209d230f2be6c4980cb621ff958b29598e517023e0cef23cf86155451876921ac8510b786886a94f92a7a419dfe60700efc046ef8d4d494ab8e4fa48279922d64210536bd4920c1e3b232ee676011fe6f7b1c08d1a12a24ef8e2208670a8ef907cf22c00e1a8444161141a1dca639018fa415a4a555d67966c6dde65dc864c79ebce4540bccee66cf71fb958035fc34efd72da98bb1b23a4e82e0beda304e1bc263eec5783dfa8c40ab4255c9dc1ca06e402608afe94220e69688cb0b029d9911ebcd75d0375b5d55070a8b5f2e4b6e0ecb22e0a078fab70197a2e546326729a27e3980af64958938094103e512bc01db590c428685902d8062dd7f527aef1e827ffa599389c23000f196be71c8a9c7a09c0a183dc6327ceae553be4037aebe533960b3c950479a0c1646137d6af422241d7a13ae8ba5dc467b4f9b648ab01abc0910d1476de98a0a79c619522b5a35e0470330766ac364587379ad780a98174c4a95c60b66aaeb53b51d855ab5fb006a903a3bb7a06693e183adfb8676d2c9b4787944c2cee39e97b59e06477c7fcf3e6890472633436ac2d0e5bc84fc04d82968810d9b39a64d4b51114dd0d4e4da930cf056f1b0af1be4964ace19a3196f2607ea29e1a43c771ecdaefa8d0cb688865d50df1e48e8782689bc8d87d8b3b72cc7b31b7ef97b349f6f6810fd194c47adaae2c1c255a1a61933849a3172129453d70a733c29868142e51e274b0b039d21fb5b53a657019fc28b2c6e6989b0a670bdee84bdb1e7f4aae05dc71ea108199aba19ed96ada157a56284f7236474bd4d489846133ae6129f1e86d0fab91d3d449b211499229212bba5956f90c1284a5791b9a4df5583be6a69ebc7c46f44d166cae744c00b12cc054633fbfc937fcfa4fc10c923f427e032a3c7d68acbd12769cccc76f2d593190749c82d97220951da4c121322ccbd915f79d7cb1c59c8be27af078a5c4fe0959eb220b2690abb981929b4785a67208143354d5b697634b063a597302edfc9939c8945ba21ece9b4b18d4392d5cc51e50630373c028e8a4285fb89e1a245f10b76f4cbcdba472c1888b45164496b34374bbe9505eace9bbf94ee218f6550fdeb2f9bc436352b4e5737fa524b2299255a674ded61785fd59689f01f8b40370fb4d2aeb4453b32d760ab3be097dbbecf808627879be53b010722ee990f81865abea38e9055f5659bef483df6e51a8c6806cd3cf33a5ea88e01379fdb86a18d6d5026c0372eed54c28370b9a5bd54cabb23dc54aa75d34536cf4e27f323f0b987c1fdcda1668b402196fc4935e984f382cf19ffd74fa2b3ecc8dda326f9010cc734489da1bc86377874e9488b696098d10de3fcaad6a64073e71d0c966c6f36cc7d5ad88427b5b7c16e74332ce30506cb4a0468efbafd333d904144106ff8e3c8c6ffab2736b9ee0fc683c8d02957c3473e6fa7e60b11104d9b5fe939bd34d05c57138ae5b9675b0da657098a2a5a9d6d58a35648ee13fee98d097fcce100a2ce1fdcacb6dfd9fcad5780fa6f2d181df56b8d1c87923baba29eb41b1add91859ba16940b1d0e80d086b3845bcc3fe1f8bc227c66fe76ca8b8761ce54b2f2a8f7255829204f4ebd0d675e2855b5136f8340446a207fec12c36351ca82a8c64d868467035f66fffb0c11ec42b597f5f4075a352e27a938babf8fe73cb325e0b0f7aab4c893973a5c8da22a2e99622210ed7911501afdb33dda8d5c85f89a2be151130084e57102680c44345e93c5dec929a60d7fde2b08d8457994a637322d5c32c42a7996f1d7d6bbd550ff8e2c55b485bd56e78b6048d36927262cad72493cdb3682d4516bdab04fd218b6a03f3d1b0cc1b247a844a78b638d1d1e37e5af920f4213a4797146d33967fabba7e7c528aaf182907c8a3b310b4c34d624af853183543f43c62e24995ca36291f8d1ec970d83bceee9e6d0a86eb4389fec9cb201ecec3fade967f327cfe3d746fae03d4a35779f1272aac9a381ddad82ef0888e3d6f114822620615dd6567b25af369789adf757ed0f12340a351c58ea5555727e1023dc02ff086f1046546ad141ee121e357af5d4e613ec3f62629c9746c3c95df4a16668355e601f7ac91a89f5ad1683614b9b815360db9c2125dd7817b5b6a01f70a09357a9ff2becd264d6aeafb45dd7626f3c2f1356b3dc5110cb1b6545587b17810946c1a4da030d4ddd33c8cc75b011ebee4b5663ce785fcb3f6595f604620e78b2d7cc37bba170b298372291e7f4ee778e1feab047c7301f1ea7f94b9184d65cd6a5af6f7d8f215921e756b1ab6e4e8364b86ed1d1cd501c931a11538c8ba3f4b7133935e51f22bdc2245f8290bf0e4423cc41fa24cd23d9f22f0ed54262acb1992e10e92bef5b6397a44aae667b5b72058327e0448b7416879898fce035494b618137939177c5a96bb836716aa124bc8c65131c2ad9c5a020ed899651a1cfc2ba74d91f91138e8f1437ec135f5d344e66b8f751763f49f0ab82449493f7bf5f5e1919d192a299f5c479db87c815a1d930d45ad7f3f6882bd7a524e56fc2d901581f407498b020e5a62c2b9087464ce1675e38a00a5d11195e9368ab4a85de2e3acadfc946bcf9baffb064a30e0b57a395176995ac65100dd60a134bca841b089824385064ab9ab23e75c49f7b8af97838cc5f6b4ef3de631572f536e10a54f8f41ca19592c712f9e6dc5677b0e6d6e68004c58565e59512e973f8e565ff6ebf735077bd0f088a36f633ae7c31fd3001cbbd2a53909a1bcaedae67cb69ec1a6fac75c9783bdd442cab8238f03c5e85fa81bdffd2fa1949e97065a108cb5784e00f6e25bb37b546af16e9d3b3a5755d5956abf41226c1e68f021615553c13c2000b366cf16f623c89abcd5318bee24bdda1532a2808b814f37dbb52da3e8087d277fe4cea05d228d6e942362a75f3dde751aade98038bb177b30520cebebaf5d31daf15742574e18ddb257da6daef371c6021aef89d5030a9572a056cbd06e14bbf4fa5598489a1a6fa18339e66a4530457d5abb40b0bcaa6026874fb75dbfc3de17e6ff2e324fd2896c467dbdd54a29b9761caf269a2e23d5f3aba806a1850367711f7371f79b3730685fbe56b2b34d5046176e3148c76bc9cf9b7f6764a2c2ac543931683350fad6523adf48114326404c74b9d8152200cc65e33c56b719e0372f07862fd4f7ce57960b016c6a0d16b0e3031dce3beb45bf56162d8db9683a20eab9a44f7bff915d133874b48e5ee11b4cb06b9a74a4c4ee5ddf2bccd5b7dad37d97dee4e62c027cd9506b6132376717ee58477529f2ac66046ff073a5e624a3f7ad7ceb1f43fa61a242de69e7ad3d8941ae2ac1a5f910d15d97cafb5868615471dc60c020e4526d93df2747e39c658dc1dcfb404c959746d2d84c09f52111eff3c363c73b5d9a019eb5aa1828e6f07bdf7f13807d1cc74b00093dff9d9c6f69535821627eb70eaddbd5de63239aaae5e3909bd3aea8f46cc45a2de2b2cd3e58411e43c21a0acd8e0509ea43875524126c9b9afbbe477486d214dec0f18ba89a885f4d99bd7e9f0290f27b42e86415a515bd2a6cbdca093368a7fd8af8e7d7b4dc90a927d8f15397ccec62ea9101b689b1d499325aca102a662eafb3acc90cdaabff443d2e1e9b321208413e5f377cd73457a423cf048c574f8ae3d81a6f60c31facf4c019a9c3b6a52caf238028a6042f12be15433ae85722b4274796563b945c9113e13fe558c520a0955934f567e92760a7b6db849fd7c903d94af91b2fd1edced960ee1ff93524b20e286469a84aa8b0aa7dc3f06bd7829c4b350ddd086fe794217052b2cf9b55c76a77a8b8310635d0700b56299955992f6fe0a602c094f4e9ff6d6534071bd9ac241753374734e6ff181e5f618a2417c6d8d3334aee63a420afe485299500ec2c7993751cf59765a45cd320776dad35d8b3ee9e7b1dae5ca060476a82c3207e9bb519ef08aa5cbdc49c5a2471e74320dd4c14a89302df3fca16777b7a844d2c7cbd4add835d05a3cf2413f435dd944fb4aedcb53bf3743f3c31ee8b6cb3e52ddbc88ed86759038b62bf71559bc37050f47ba44f53f1c7458c24b0cf891f8ccb6b1e959aacd5cd1d0375e21d070061e53934af23383dfa4054b973b3f0ac2a053a1ed1c6045c7819eaec111c440bd3d1b2270723a8bd7641e9fe8c60f10549a9af26f316e55ddb9687d79590c0b649bed0c7f838afc5c1e7286479bb89bdd60c9496e8c8c48bd1b7ae1bf79acab5a2733e0724c98327d287621213810aae5151bdff93dae3158499448df457df9d5903d46b86dfd6e83a084ee046f722fb1903f86828efb2b3feb2b34050183e907a608f0cdf304854f62b7d3fcecb737b3f92528ed92671b022ab457efa0c5456cf22ef1ac4ff604ac558b03feb422ed1b40c8f1482045f1e964a19339b39d63cec8e85f209af0583429fa2d0a1b86be00ddbbcca9a6f1e254a1ffcee976bf6a621a465b776263e726752dff82b335b0dca315f484e6ac930e9b2e7d394f45890da5150cd21e17a65142647c4d0105bf3f2d830df6d3dca8cd46bfd495c65c411eae502ad98a74fde7590789555842bd85c76f6fa76999f91fa22c99dae31f7d634c694436f3fb6c95f7595d7babccd64f09b3842685584250c2b70a237ba2405235805fba5b5931c2c3f650578a2814d24863eb6816d772c28182a1fc67de1d78d3324aea7434429bf025fa1380cd63a8e7cf4bb477b141d9b31defaea353519d881daf9a64ca7ef613749c40a5f464320610fe691cd9e26cbcc0b4b65561b4121b5a57a2577cfe4280915fa9b24e7b7916ecc165bb7dd08e77a8363db73cec58fbda65ea8fcd8a30f05eb368479f99df7709ae20bb3c372a029188a30abdaf22dc01abaa21a8595313d12df83adbaf4dd4cb4786b683c927895dbf87e084bec391738675507d552ca25c2b55a0fed88ae372d14dbbad7d81591ad88b76d5272d7b634a5ce641942d63bc15ff0b74a3916246bb529340777027411893f8fed815f05c8831e7091a5568a24283ebb7071a8ae2741731b4b373cf8583d2eb45fa22ddecc7c5ce5fccd155b0b87c766d9f2b60f5f9a376948bfb79ec035584fd0157d7e215347aecd31cb765b1b323b699ea60781ce7913ac4d7dc322960cf0863227b7d903a91433ec5c51aa32b4b7b257f51753a118088685e09ab1b33919e5eabf5b7a2e3b3002c404a061bcbd99701402aab05345dbec33828bf615cc86ff1f3e21bc91d49957e0e194b49c4e82b6e8d7a62540c4d8a1c89c1ad8bca7aa23a1e7eb8f7c610b867e00d9de8f5c13bf913cdd7e8bcc3b1e1b616b2d6612bce27f0e549401ec18b7739a5b3a522542f94d0ad93dfd7d9fb8c2909c993739012f91de33527647caaef03c7520b1421c6b2057f50bde2873e29f0fab2256803b3e719cf9b0ae6c2719a7a8f4a5035e0203c886211093ecf521429765e1e4d62b9e9242245556d9535daef3fdb765faf85bc431903ec091b7a81122ef09a551aee73a4ce1b9402e417be61a701b42d5193a3684b6c8278bc9ccfc9752da3e08002ff02764a8fb48c3e3b23c55068c61fc6428ed907ce4d386c563733ad5b7fc246b20f2e71e13e0c01eb5f24c9c69821104fea64fa890f205cd1a4e6ce0e95e09fe81eb026a525b57d6eab921c8f30e836b7e56497309411ea8f133a9ad5c9aa7a113aa46a902a11b6cfb36db0c2c868cc0944c8adc94b6290a0d632b3d73d037d58546cace6671c4ccb8283c460479a7b96a559910a2c7c5ee4d6eac7554afd8442adc861637dac085620e73923f639045d63925c38e0952f0c30357c38d8ecee9cdbebf9a49723d47c4b4dee2f504dc17dd63e4a3d291a8232768b515e89dd43672b5b9e84cf0818c8133215203c466d5760553ca6513d5321987ede28e23874428c37ab66eeb0f9d593e0dfc0ea13c635aae2dd4d180d51aebd931a4d39d0030be388fe0fd4a04a61dda1c1ed253fce6895ff35e0ab4897d7185efc0e1bac8e49834ad2d160e667c335c236753688c439c8aedd8dd69ddedf4f96da50c797bfeca37322e464fab068d6b7866dda5ec75cfaef218ddb5e92e6d774bbde79feb0b1e1e0c9190d1fbc8cd4569c93bd5af2bdeacfe2859d995b8ca71d5efbf1654a4fca860eea25b4607b153354e3d41b97c6afb92ac8a23df548f0115471436bf7752e29b805e88c6466006532b1e760e0119da102a8f64bf7f862a4cee93c8a2b20bc8c5c966ca6100975d4dc14890dbd009ecab4c682ebbacc35bcda210e4275d046fd540a03a2736eaa9a918678ac1007f400ef7872d3447d20616558ab775589025dcee567b37a65e32a4042ec4d4fdedb2a63e6ed4b6dfa3c4805eef404d9527c1596cdea378136f2e779aa2ff41b64fedac65f45393a253cb33fb38eb70cdefd7e0e8e35f5e7d3c7460a75ce7d8c865c90378645ab6025763d3f3d4d6760eb7c2ed4aa7e5783225dc22ce3422a29e718f4983bb8b1a5ab0dc294433ebe85240ecfc557764641edc24b72af7c03e33b35f4b168667e82a5d991a224b134bffbb59e024af81b7daa8521bd798f07e699e0a734d8944f880e65a89ba5af35d9405f5c9cf26c47d17ddfd5b595abbd251f8fe2dae29490452b445f9b5d2fe9f3e1ffce51c158a002e91497f04b4647b9d368adf67905f699788fe4c2f59302cbc1d4296bbba8c2bf9bc5116d1c358439d71071036d3efcb1f6303e5e8fc68f15ca38c0d09f61450f3d9e770d44688073a71ed4d7d3c2506fa130dea4d2e7c1042b7c57c35c6419294b594c696e8abe7fe99ce5df9359cc0c532d4a419147b042de315c652424cfcce494769b8f3cee9979613ad03cc32d6e4525c25af92d7bfb5639a401739b7d1de5881ae120d4008db511e516fb7f65fe020bd9f02f3d941660b3114380f1aa0cbf9bdfbda2a067cdd6bf02d14d7f8b7db151864339c5aaa720092623e06fdfb20009029b684742c939ea67073ae331fe818113e17986d8c99ce6de6bb9921ba181b045af13e4ab044a83da6b72139c6d80f76035aff5cccb9dd93b026059958adb30cd3da9c81547b025107edd6d282ab39a1ffbf51b1159f294473043d5da9f891e98897e8508751c3573b6f9fb3f0d9977cba3cb875333aa3df495e72630fe79c4f34e7c3fd2779bad5367a650a5e3b22fedfddc0b18b39ecdef64dc65ff51ab4192fbe0e937a188dbf00e78f02f2f4dd168fc448ad9a5c307bd9a88e7a24369fbdd074785b52651844bf522a353eafbdda2e8113fd784cd16a34d19b34b93adb61842611ecb1b71f7e7708002f9526fc866f44b78d1f0162dcf88e1edab62b2dd874c14949dcce8376af74282d59f2172ac9febf7d8b2489bdbf1e33f22c34c72ae28e93a534e5760bf87e88fd512c2991cb975a02d2d87f11e760fb8d69fbfa82e6320a1e946f078da69232b7f74f613d8d342e48049dfd32929a7291e0fe34e88aeea9045b5e7d847a0b534c4a43c3882cfa908a180ac2c6b7ef3bc4272aff5c16bfb75a76e78c299c525ec247df0b0b205262a88eded4c8e68de76990c64e4314288115648b7c9a6c2218179974d8ba30900c63c5a4d3a67c5be4d6081186c8294c068398dc0ef075ac748713094de8d79b3647ee5a147046340c2dee36bcb8b2b5a0b0bcf4d900b8fa8546295df9bb43e2dbab6bd5e7f25d3cdedcd2990cb4e41d6991e243b69a5a451ea643617e734c4439ef1b56e72ff0e0ba9539e4b22b5cc49f78aaaaca8cb7b6a530f98e49a8537e36c1df61a74ecb1cc5d4fddb3189f56ae248ab2714524f6a9117cef871b9e2823ff0f33e949efb3018b8cea09c0a7945017cbb4e8b343bbfd35a6489ddfb6c7534231f46740bd79f56f3e4d5767a777d8fea73fa922258dc4d926f5339a1b4a05566c308e1a00b58cd2eb5eedebcb2c58f711da0a009572f89e2e74a26f3ce2721bbf551a022949def53be3b149d338e5741b0210f86d84442938e5ad4d5c7196719fcd075c584f7b7869c908d31ea1d8cd1cddfd6cf42e834892a6a92990878e81b0881aeb9e45bf0327ef3c4add3de8a0a4caac29d722289fa7cd53e5ec5877083c317a58714da93a21068bca1c23676860dee5ec240398e715ed5a93e1eaa4d288c665fd0e9c8ae3c6d7606a88bfbcd4adc75046460a8083f31af2743a47321181a0dbf48ce22a933c8929ad5facc21803ccfa6e64789a59125fda874d551bdedcfc4886e243ff020af9a076b0fed2202858ff7f68283fbca9c0b8fae9ec02b6a0148e174b4a7ba3c6125bec85d538659657e38d5b054c186863c0748fec6f56fd4e5bf9c4e3a8ab83a4a0bc17d97c0230ce9c0f897f9a6758af8204c62ba80c2a2e22976185a022c7c9560c0b505e2248d13c1db2a10b887f65601504ae2554ca668eb971e08da8b9835be12ff1533f8c70066033ce17090f2e48cc956e0fae1570a35a44a0a7196fcd3c","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
