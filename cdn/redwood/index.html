<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2cc94128a2a6f85c0912ab4113e38fc60003b59bf2c8e20e5f7584c07bf7c89be4b9f35bcf0c43bd371a1a67fb14615a8c30edbd4b298b704b374cccaabf879c4ac814f85fe3cb581240750eee4795ea81bc4318c37af2b75763ef9d56f3a48a54767f23568cea509b31f5dd7f0a7b1ce9ca21f165e770c39ac486c3fb59a6443a88cc3e413bcb7b15d569b45b595c93c42645154acbdc0ec2b84744456cac7a64f025ac32b5e64c2a586fb5cffc27d0ed740e4c258bbbb333ee6d698504f80dac1651711f3754dcd703e741063a1af2960e73135309a4d17fa7dc7a6f9f7d3bd1b47d88bd80ca6fd64a7958cc2bcb380620ec4b6312172bbc05f55e61102b211d795617fee1f1a799443d4ac1c2f9989bb3176508aa333480a08dda70e8297d5e8e32bfe1e38031e4d628d004b044c85776012b2167e7fbfab1260f85816c2a7278e7a1d4d70b8fc8c64162087b3398120eb7b3fbdb9183f4ce17b991ceb34bc880cf0874149461bb24d94e350d934cbf18bdcdf367326a8431aaf77be0ab1ce9ebfee6fbae248fc90e89fe53f1c002f5cac454334fd6f52a14057749d87d69cc1d6aa7990b52ab297d1afd35aaf43ec67bca6247a11e986a1183a11c3d6498a32197878a6489c6df43b3d6b25f3c3cd6ba2c18b2c12ab42c01c9c5f491a9432a97df8937a676cc2ab6140c0cca80d5c3b4db007eaab7e825a7cbdaad526a84ebf88cdaf122d59823452b504be7930de559a674ec8f37866caf44bfaa2614f82f235591658fbd9a77fc536a523d30be32aeaf5e22c16dfed0481e61c22ba1d139a798d9a33fb5f3d622e2e47296a832647ced6c9d4d228d820f2ebf53fb5e380744f83fbb56c0f04d7fcbd4d11d9da637c8009da8884629c15c8b1149b001f2179bc428bb134464364640e80ad60d2cb276c546dfe7859f5e5536564b50d321745551dec3e3d343c943bb1eaa83c9827202145f05cbd052aa7625cacd27ad537517fe35214802644b933197064535acd95c367bcc2cb17379fa85b9d37d0740dad6c9e6f70e4da0eb992142e8d5c708874efe26919c282092b7815dc5845954f5954bc4ff1781406c78c99acd94a916241068a0c9d6c645b1d9bfe023e4319726250fd94781287731f6c51aee74280ff0c5fd1b4b69739bf7a81e69adcbd763035e5721689e9526ca703bbabea028f41d87c4bf99430749983d4c4d3e12f4e44def1c36b8abf25da2923eae0fe134a13bdd2247b6c02133c9ec7719ac3ab905f1c7ba8b2057faef2857102a07bcbaea1a834b2af31cb62d95cc6b89db3c41f447a3515ce149fb60c0b0043a45d991a16c9739a7b438994f62541f80e943b04d71ea7da52da7d92d7d92051c9b1aa2236752393bdeaca37f5344c5aa3bfdfb0d4529eb13ddb3e4d2354b3c1436e734d04d5177d262ca8ca2b2cd7e067e2ad62bd474a46d6dea2d2ec67c58239716b8997422a08b63bb310cfc3cc5f5b6682a775fd4421b8333ce86f6f776fdad0141d567238a3b49d3f61d1743b2b1e4c36b4e4abd10c479ca35da52ae8afeab97b9ea0ff43e075597f2cfd1f2700ec34511131de0d7e05f15d5a920bf3a02f0b660798e768d893343106898f0480a4b4ffcc9d56025ed20a41d7e0d811c01bd7ba779143bbb7112e4626242b698e141912f1f52496b876e15f3ecf49a81c02b67404a5e3dc0988975e88068c7b2af531afe308ac04d0806fb65d28f8d25fde037c126e6c5270bbfdbac25a811b73616197916d0989e48dd5a63d6d5ee4a73de3ff99d92ecf0f121b215d46d1ccf9c98f43253b93e3bdc9f9be63be1849bb87304e41a6da1aaa8af80798f799f0363c6e9bf68eb1c441df6d6b839e1ce70c74b6878c17c2951244983f43176a918f9cebc8dc5ca8af4efc0c02b31e0cfa3e2f66dbd90f3402f018cdf0949cb9689f7216e1d0cd45eb4a8b6c7048a874384970d450aeba73858b0b036e19c6f760b859618b6c62c6d3642b54dfcb3c91b2dacf0070623db78ea4149b1466679259239f61474367cbc7de2cd1bdefa0b0b2c767b578a9a70a843cdc1f8a1e2d9e9ec4d45d8e322fe461109c73fe72c77874854269551bdff6b360dd7be37744382e289f12424f605f58bc082f950b2b83b0453cf5962cbd97f1ec1789afa4cc432935577c9e6b1f212b8167eb459e10e9e916ad4a80c692ff94fad1b9095c46f34e3fd969aa0098ea12410597d0b39a1bebf2ec3f47d876f4945b43cfa4afd0dee4fbb56d4e5a6a113abb845d97f961ec29bd3359a7652aff38a60d5b363c0de027756aa2da7a468d0e579426d486655b7c631ff7b139f52aa829c6a45d8471fa4a59d2df14d8b523e054e273592d2a388337ddfec46c162190222a9145c3379b9f2f9c1f81a731c37ed13fa9793009fc6ea84e4b057064c6d87d41550948476cf905005892c0cd40b508e1671de052a275b9650e229c1eef853e77543eb63ec8cdcf57244bfb29b8daaaac863b99b4a6a755a8e4281b9468088bfd07882b6e220090ec2b18d2be76532d71f6c128a5e5334c52e9007a1ce67018bd3325e036e338539844a6973fc8e880bd512cfb98029b5a6d98b1ea0eb2e40c07bf7d843749155ac393527a1dcdb842b3884b53e606bc233f7ab0a2a4722c82d359d0eec37ef66a591b1b682cce8d3aa0e361d4f011526ee0059461dad5c02b765ed4201caba9a35ddafa6f7102337b8b954ef620b4960b5f76776bd392f22a0ce928bd0f6949881cc3cefc9169d5c5c2b847915a657cbe21b1aaca4d07f25e7b3d0c5570c8a3645f9fd8e5c436c02311cd922871222130807ca8e51409c9e1edbc02962582e67b382cd35d225739617a43ef3b43cd9444afc7c0df7250e35d647c2365d620cd0a2e89c278d0cc58f5c2ab212a57d6cb9bfd8d5b8c77d4e781fc6355c9f8ce5f27f97ddb62eb3b6c46c96074546a2cbbb3dc406a030e682ed5c06a984e492e24c0b0dc1a4541770f7df91ef7a0088d354bb3f5b54c68f8e6cf9f0abf2eb1852ed8607e2d4ea72072bcf1d44ba6a7921a8100658bfdd9022e49801058882205a98d1afc63488bd4438e771e77160a3ae92c995ddfe4a437fde68ace92a5016f777470ed0acda6d9a2ae9837cbab86578d2d82921f0ede921cdd0797ab91f387d7df1bf943d90617551d110d9cfe148bb83008599b9100e02ab8a5eeb7abe1637f9638fe37213310f7c4781c8fbc927c22c4285d695a48783f320b9b47016ce49663b9a01ca8e6d283f5248288e80b24b6b4b53a8492ee4e43eb4f7a52f47cc050d4046a703c75e43ade142b94ed3fb45b7041df38222e650768e5986fea006054c8c690c1192eb8204036eb1a399f87ee9d915830c4c69a428c57f6d12f7203138480b5a32e610841a2002df0adc0cfefc9ffef9ca4b5766fb0a5fbddbe7f510770b4a173f397b75d67a2a863406d9a4ffa0aeb47b1545864aa86f5a14fda512da8f45ab7e6f1ca7a8f6a751c710d97cf9ccec8967f89bbbaec11512d246dc418518e5765ebcd29ba82eab63a96e733d8355ccf2725687aeecfe9c43278254c21d1b016d145772ffbd0cb18e20bc8b396a5d64249e152c0d08ca77aa60835e4bb1cbb90b8b6c7698bcb98774884d1b5605d6171834c73de293819e9e93846a2bd3222f956e486ec9c7c96e6239d4867ce92b7d25ed88ba6cd496c1797da2ac2ff6802299d034029d235fb2056bbb04310b7e36600fa737d1c9e902ed3f7ebf18c17e841b46a693778e3061029dbbd781fc187dfb43115d442dfb2f81de485fd18ca666fe2e87dc7d3c2637a6622f1e561c648f6f5e96b6a0494a082923a441c0ec8e82bb026013c04dab40339632f366cff3533aa113b819e031d76addf6b6834aeea00708b87268ccfd3d0452ad5510243c8785fb5338a9dcc455e23d90023f09e16313eef5a7e2771b44ffc1740a21697494d030d03f0659d3d587fbf8552b50596f64981b8bd84d7db934887092cdd31b759bd5c3cf23a48f077012e6347b353216a904fa035910a3d5f0f12d63c5362356d99a12673bec925446439e52fb606363788472d14132c3e58473a09c4f57dbe936288da5db00b16ea986656470066cf81367f6953e3d1e69e59f3706fe177f3e98167516d49f301883adb6e80e0d52d2a704afbb5d063f48a8ac7937644eccb51f237939834aa4efc52949b3d9edc7cc383a7b1331ad8d3ebc0a3e63d9e18af691f3c69c61974b84d2ab8a37fe2e3cbf3afdafaa7bd96e4219352c7949acf0ff52b1f285956ed92e1f678562106ccfbcbb9111c5ad56d79c13ce0f43eb8919d90b0f86865cb8d3dbe55f45d85c0d8cfa65167728430bad81f2d6207fabe82c1bcc03d800ba2c3ba0db20577cc045b4894682cf06fcf8b05ca72b9a680c7f9dbab70c23c96a35cbecefe49b4c693fee6bad930279744507a827613325a6de76674c2a85f31f8015b9211bdf364f17ae7e23832f3edab19890c019a53d8ab236637b9391bbda34631f0f5d251853d9891d1e8e1180a57744aa783a2d1355d0edecd2b5622fa5d8ab879096788f87abf5f50e099eb389f082b98ad42e42a28fd76c417258b0b202e0aa294877c5198d0bd2fb84bc41d59ed0952ff326e955832af6ff94a5e47380a22933f834cb5f091fdde03d2543e0b42760e2fe6c76dcccc3e810a0af768524a966822f724b568ff76b64919728aaf0686caebeb85616175e312473e9f211fd00592ed94c0859ddb986f6e18e05501d40a99891cd2a54e193bc5f1dd8b3629b6e9366ab7212e54268b1dcd4f8306a18d2fa45de4cef2e71f84ec1dcc54abf1274d58293357f98343c61c83d6c5572a71119d3a73ea5e0a6bebc709bef0b5ab12d705f0e321295755db6f276382c34107f316cdc698aa6c1cdc43bd455ecd22fda0fff488058fb43128dde7111793851aad903cfd76cba0081f92508a1fd430b31af73f55442ee04d0c4cbdd9770c396ec0b18d36d9f239e780272be653168e8721f68bd1248582a2ffbb92c014c4e1caf5571b669ec8fd0d8a9434d08428626dc48b0b2729154162dd82f94f34c3388e7f92f2490aa8183ab33a740d718f4bfe33736b9f029eb51bdddd48e63f47a680666df13f274bd0abededb3fce500e23028b7a0aca1208dae14428f7689c07b7d0584a7f0343cc6fa993498d3249937d6568c3918ab19746798b96954a5fa2be4770915c790e80835aac77b65b19a80a5a00219c9d15a00cf6d62d59b3a8613f47ea553d41cff5fcad002b9084648e0cc9a0ce717a654d945c9fbdf02838648ada104c8161d7db4326ad2ccc7cda726669025b49de6919d38af107350dcf53355664fb0a7d5294469cda679899b95b03cba0da4401fbf15c8847a5166ba6259a5476018a367d68131972546390df1268ced2973df53f6b3c6630d3fddf6b9114fbc3c6178d0d92aae047c8d7dece1a2870d05c6f5639e96033a9512d81eef98a6dc216f03476e2a2f67a43e5dd14efbbe038687e7c1f73aceb3637dadf9305cf497bef29d4f828d9e3b25ce89d8f58b531ac91dcf73a36eb5e0adf31186abf2bcea7f737318e3fe9f0c177bf3dac2f67628d383df203d403064528bc365fa8bd697a0b60155dd6f48725a2b4ed0c2a91c7b6675a4245209426e65d746428b65f4fba9307429b837722c327f02489616b161636ae8656137c217da85191af578cb30870c383b0c17c45b57b8c516db89e22d56eefb4d51502999f5b95d583883e7ced576d932b25aa539a120e1fdf4a32fc680e0c6728d744ca4a96d567f63d8242702091a6ba869a9235d828939a31ec4a5054ad1ef05dc52ad02dee265af7429f95c266c1e1f567c8da057f2512cf9752db1f7eb8eaa24091af106710560352e7ff5dc1a7c953e307bf2a878d4b733a161033a8ff137eed80155f9d9d40a5c7072b17f65ec22c91998b059b34e0e472740f27945bd24076713810f622e8ea0679315c570d7d1a2100d983ec4e606faadda2637f520bce222d35260f5a7edcaa71ebe3aa87c9dfe9eca0f266177c676feb9a48dbe0d327f6be00f6edd07db023156dfe36fab6d3168a3a4b3207ea514b2a2b3367e1dd03246382cb8e3904ef9f15495dab2e3cbe212aa17b379fee3cf5e3dad1777118a7de6410bd6a7c8ad4e73e6bea7c0ece6a367834d96ea7876005c5a2517d2e29cd9e3dffeb9d3fb05c7ce6fa5239e054513d4f44a8ff66e3157b36db0678ac1337ce5d35db35f2f30a14231e5de21e05d94a639dc86a86f0a24b85f7a780a0807efdff118a7aae4f473906cc94d8ebef0f1134cfe9ae76fbe922d7413254849c185cbf0c24088d628e106c72a94a4eed5fa5bcfb26c9b69fedf4ef87f21ae524822303b6acb2b82d77fe3407f10f426200991f813003edefa2084adc6eb0742c3b28a275b5978a1223dd4b09489f262c1f4eecdd4b00ffa430c93f4e7b9adc629153dff22be775bec93768985b150a6e8f99ac7ac7e4bde750cea26c555e82e2ef7dc7b15e137f88721be1a424bbb597132f2ed2ab6f9795cec5ce6f5d27d48647eb6ee47975ec8e6325b6503f8fc5c83d599b0afb24b9e5482fc652ec25a0d34d7509bad492738aae1c5638bf9d0298e403f524df3ed8c788c5d9683cac5130793916187408e009ba54da3e1d56d45303efcd38eedc60f293adcb57e0742b75f464c381e34d631301e197abec0a47420314f8cee011ba4e76c96f0c30492003f06f6e107dbe4065d46c3f46b1da3db4d111f9da584c977d95527b24a65db2af586d604c58c7a042936e070bacac04a273622d79cba8b9fba0c897e32ed4c3a8881797e0b02bb22869722aee2913154cf290ed031d22c0822517d0b783c6e4672712aa3d98240b12ccbf0653b5826ac286c0bb5b838212ffb3e6b61b77f13660a04c36058c4356a08a47167bc0ce088446b704081d5282eb2b2d716b0c0aa632893e4632e1c7ff9e6a9a480e20803a87e4d5c225d87240df505bb6467a1b3492a84665f58bef192202c2319a97b324e2b049382605b3888e00bef1d1cff02eb1bb5ba77cd151b468504738875912c6e979bc3744b313e3e785449b19201234bda479f297584d8d052f12b69ad05764d29d1655e30936985fe96bec22e8eef29d09ade8693ccc2d835f5197a565151c27afddc57ad517cd73bfc497e85cff24ea52c0041433b251df8a4b1b12cc3e0365e3afcc7a43cc0ad441fa63e301da30db3ae09f22b079efcbaf1bcfc4ffeecbd4c67032d926fe53bb4dad5436c15a39984d7ac60f3b7f1cbcba287f6e60d6e22a3afd8824203ea3935ad80fa25fbde95c1f5c5c255a4a7e52aed14fc89074e1829d783355cb81c491c0fee73da26498a9423a808e9038ab59ae3e5278609cd8d4dee025f3a4045904b5a4b39bd135b57e05e581fa6b50b3a2383c1e5a8faea659164f9764ef7a23e51f26701f958b1db593dbd4dc8898cd26834c73390253b16db81287546c475a938331f4587b6ec754d1d911371fc00a7445110c9c547ea5bcc18011741b4e5ca6951e88b0068bdd42412b82cfbdc2993a844ab411dccbac94d6b62fe51451854c56cd3f6b62b9db3f31aeb8fed10e9d97bde8f732997d5124b6db8ee5b3e508c22fa84fa6f2d74469a2055720a88461e7cfee385d84a24870a15f510e1e12851e159d1e794a9fb38e96223e7cfdd31842b92b84756616022432022c317ddd03d17b5fc64f1b16ad774e73ba42e1faa7e541a6f8c2c2340ab052903124de9598cfd62eb3de32776c29265693cab5e586d21867f53b0bb6178c599a880bf412c371842d58d45f9e42c231c4c0f7e2c9422b6aa6c11fed53c4af7ead80db0f5f414f113acccfbff1be44fdb967aecb505b02e664aff09f7ac0b16ef07fa71abeb229db3d796c894b6c5952bf9d32a313654f992e9f341e20facc8883e4552bc964b5d97d4aaa2b8949380e8a5f6e03b3ab6e68b88d99d16495cc1d83e6feeebc56ed7a156f236e6981c02b2bd863fa2f98e5cdd6cceb0c3241fd401be355147bd50cd4c16d0ea47291a6162a91c7bc6af905d9371ce839b6fb223486ffda3ddd180c02e0092003e596f1bd9dcdccf05c388ed0b061161700db1c4f8928e586e671398e248173346fb9558fc2593745e3938c8c0d6de1f283b539d91503ed622f1c2fa13042a6d91f1e3d61e8eb74ed68945a070c2d94aafe51055849085df506c95ecae65aea0f096834f3f8d4a1ad9b7d83c472057c3ff5ded955e5031ba0941ec933db35e371dc471beff0f203ee77c9df9127ed4b59bbb6317ae972c8bac5017c00c4c80442c841693757bdfb9befa4420be2a17056f96dd58c585a57761c3f429d347d6c8ca37428e03a8bc6f0009c7f78100b52decd72a76ad3ef11e4275c860103edbc6557f35d313eda082d0c45fb457aa1be45f9a00ec07cf165e60b0ce23e3f49458b17dab77bf6a3665198e940257cd964faf77f62c7f2602849911498584ae167bc9a23ac1a4f4eadeb28d071cf6505e7ee8bf08446e198a498f0eb07c48c20bb58686d4f595cea875e1014dede368d8d8a379d71fbed1c0a69d2bc92632a044d10f0280a456dc69f4f993fcdb3d97d2085010c917fe64461ceaca4d92477307fb1a300d5446ed90afa625c4cb0f008f1579080557f7ee8173b52af07aff6c517ad14be062f0eb686ab862cc297bdc0d84a6757e9dfa71d2269b8881d7560b699447e273791237a1ff48aa2ccd446b2bdb22ed7e630f64b6fde18263b16237b7998d01b1c068c0905c95d8bcedfc3cccb03b158da412a670e3c7c537cdfdd0926365161d28b586903bdfb2a35689f7328dbddfe67f1d952982af44740b6e0a189ef2f104b27e437edf609f8373565f3fb2dfefc040888b0e84c4c621aeafae9925584383fde06d17983cef5c1e35fdcef7f57211ad6648cfd377a009688e60dfd3e13005f13f34bd18df0a66e04cac95b14951b464d99ac0f9a0f719cedcdac1b02038f2462baca4f91dbf28a0b3dc066935908d92948e4b03699ddf6911a552a44a97b9bf74a7bb30cc6f6ae6a34db65b1b650efffea06fbe3afa662a5d9a038277e7c42f2919b43bff908c63ba0624d78d5ea6d393d803684ed162d53462e38674bc15ca81df2929a9934a254fbcb49ee73fbb98cccfda1f96eb54793f87f78aab51a9d22ece72ad0ac21fe535985ec02d56b1200aa91fdd396aeffb2f09d2c27946a331e1d0a6f1b641cbc3623e04c55fa16efc6270c1ab738e4353267336751831fe25293b8f682e608a235a275a422c5c7d7eaa2e681f88dd41107f65daf3b419714e9950d94e79a6b30d8e152eea19020c87c965bdecd02ffde60f8f0f34c89adf0a2a53d496adfe17c4eb8bc0b35445e9e7e9d621e5f0f95ea2dcd60aa9a08ca9830b8ffc7598dc997dcfb7d67414648221bafe12bec8ba6f89b94a2835ac775e782b34bb5045097ffe383a0f2d033a7952a3bfa4d2f75fe1313e041de661671572509a1c2ae177ad3b7d2088df143900e2d414d5e6ad2f75e60987ab8b80f2fd1f2edfb113eb7929b8cdac26137142822198fea7b204a0b93c419f9fe49fd0922c659fafcf12d4b5482de858a6eb27fe38ddfbaa539dc648bfc9e0f38eaca41efce43900e9777d2342594ed4a302c42b8b52a5e914ec6e3a7a58793942e0a66ccc13440993ab1dbba9b4b6a5f25f1eea3a60c2ab340347d8e2c2c86bec0a828a355342eecc59e6deb63f48554b88c6cb5cf6ae51609a7d749e901f7062387c1aeacb94c5c7a4c7f79f67542adeeb8aedf82fe366f213e2d4666a91479c3b8daa8759e5f1474b60b4f5d055eacf98f250419f42eb00942a026c9ca2ceb738966541ae5d111515d7e61eb3d66d39217f6eda157f729a4a8672ab208ba55e273f0631c2f1da39c322f894b2ffbc3be3737f008972784435d4ab4bf79087967537040890ff525f5168fe50f5dd1cc7a1c0352f42af9ffd7688f245d66e64c9af0038b6b364318b33e2397b4cfe618cdeb55b0ef884c511c7eeebdaea891fbcb7872bbce033481a3acd530466501c6d18aa7f3942e6312271419887b37bedae020a84b1825a422a36fef2e70277b406f7e49f6437482937740249c977ac6e8d918f19d1ad732aaee1ca547412b8ce44529be2f9e1e57a36d3072e8858be8e27e3640beb07a5ac782eabc86d0bc2d6edb7ac02708d778a21eaa8b01a5748f98e67f0ae66bbc22498f0430fa4d37e0daba2b33116276795bf31317b20e90631101df674e84e0edf9e7c27ae9fbbdae132a50c32db1d7ab032fb6425c2c9b3bfb831eaee34454a5e8fe1ab24b3d172bbb78d669b79bf5f336fb73dbf06fa4b93aa8f1014db00e6600694d1b075aa039eb2261add65ecf4079ee6a53eeb8f5b48f8b61175c989a17c6fd276d15037636884ea04b507b34e95cfc2b32ed6e9c36910ac396ebed93c9257d5f2ee64f40732fd8a88b2c3ad4e9cabead398c170c6e5c6a938d03e18f05e944e4779fc9c5c8ad853f9f0687d05d80882e2fe4d50400f4858a27da04482ee9a386048994c32eb7d2ded694502331a9194c609f63090d9873191cedae9d782b55e72d5078e44b8307475dc1f4f5476be15acb8e90f093594ac98670da050f4d4514982149e7b6939597087e0a69a09429ca5399069927f0ae6f17efa60ed5d1f1d7eeabbb9a4368836abba7a19be79d736c487f158a94f8b1d57269620250db458ead3472f87d150924610c302b7c0851481d1d594485ac3d5b24ccfe513e7524d43f2d918cfa23a0963ecbf5ac8f86b0101cf1054796bc75d92a335cc190e3e71a450ddf3859d0236beee2748bc404d90c751172cd9a6bdd3fdbb26c44bf90cb58eaa18b14cb9e52f3be111c7515d433f8a5ec166090750db2d676a8932fe45d8c529bab6e1af42ecd8515be40a2be2b474ed7c7bf18f2c415eb8140f4b7633bd3a5740516e4ecf28c8c9d0d500f8b4ed290406dde2db0b36ce9f05d0c6a46512cd2275cbd1cc17b1f2ff5e32dd39057a14c4dae3b1920e7c1c33e9194eacba0bc3138206b966826f025e151ce26eb9769a9229ab879d7dedeb553bc4c556634e260a519342eadb1953fdfaadf227c6f6db7ceaf1fabff2fd9eefc6f2ac33be0c6f801b01b82f98f3f599ce57991056e0b80130679b61cc3d02853752852e4e99b87bc0cd142e62a0ff89a3c2481f1e574e27b1884b0b5c0f50433bb1f203efdb27917a0bd4773bcaec99592f02e931e64e31ee29f87862f6009f4329802408a099f9a425c980a085c7fa1f9de596095fc4c4dad7408a6b9997dbe4938533a36ae51552041fd94f8cd82dad09412ce35440a5fcf06fcabfbd86254f4146454069bb7cc7e2d9e66e783fe4d6ded4d5c45ecc4f67a84bb5115ec5f966a99d106e9bddf6c9611c0ea4634d35b1452bd342260309c43f5913b588df05b21b555cf90504dceec4ebeb470a337542b165ecccb6178f222b627c996068acf7dd578c521b6167bde2e4a56c100a03eb7144b8138ee6e2506894209be99a7876ed227fd4fd4404de7ab3104cdde90936c4f3f6944d8e6ce26909e940f1dd8b35ac102be891fe3460ac7723be38d8f46e70f834d0efa02635d0d2a5411c60539bd480d02e3d0e66918fe16a90c11eac1f7c903887c5a1a955f7437e14c70ccc80a80e85bc5dc40d1356972b243b468131e5a19fcaf99e644148845dff3c55bc5b7fce3f4b1773118f731b22ac0a8eb7f5358ca34474575ccaf63e5c2475691203710bb7406eba644337efc42954be8cfdb9d1b4561a890e97e88e0afdb22b8b70a1a1aab23d2a1eb73cc27c1361b8b20a94ca6238b1e91640ff0689c9159d67b305101fa2ca8d0b57521710eb62a07dee37232c4200e33f5d1610e4a5d51514edb836265610fd7cb4ddd201c360eb3b0a6a7370470cfec4b5e79f2a2d99557fe71f393a9f9e97a5035b9a8fb9be06bc2b3833f805ab349aac138e31639038b62f4c211154f3f4b06157a7d154207ec129728e7347cfe64436ad282c0a17b9d2f991567742f969b484838ffa543c09a4cf68773b0417e437c812e81233666b2035b10999d4704103157832d18a78d46efec6082bffcfec454a6bf7c37a7883808c157f215db8d8465ede28af183f15d9f62e5ad30c786c5a2bd6316a4dcef975d5829c14d71c9caccec012861bc3e607b029ae1a4160a04826280db33d62355389099c17074561dbf63d2413f40b636b72981611e7ae38a598e6cdd9f966187fe33cedd66ed50110d97bfd8ad95703f48f765b355db3bcfa34fb5e993097632e1ff040b0530f1584de4c848fef5c4a1434e1f67a58fab7562f819bce3496a9561af786126a2956b414e9cd5106f7674b9bb64e61a2d14c9f3bca583396e65b3449e5d9cae28ed26f696da01c7594ba0f2209a97cc0fe6b3803bb677e297fa28064afe56a1ff09cc85d0ff3c9d386e2d1d2041b033d815fa3c2e9bdabe1f138083a4eab84f2c27a0d522ce9969d8199718e3829a585bc59c67c60438e3d4292c3467d146eb4663146befe32d461af4d082cfc1728f53ece0248f9bd35d1a9746a215630e158c4923f1b0e2c62fad18d925c9b5e25946b13fdeab722e9e5ec61cbecb2fc10ff4dc3ece95e18d3308894a566da987be0a61befae932081685dd1f954a8588ac6bff27d6cb9683c1f8c65f3686c4b1cc1c9c8300356d09e7c73ed4b090c438ff812a9f11c3e76b1b9d49d5912a29ac60eb74d5c478836467d2c80cd5a5a1038016010421160821b9e3c844c7a315c84eb826e38965daafa9e7d7bcdb91de34c9057d0c1e79a96472f6f42ec1335a20e37dd36da2bdaa85a13e1e3cff6635f3b4cb3af53a140af6b8f092e065079c8b4c7e666010e644a077ced12fddc1a983bbf2c16036a8e705999aceff4fe986367d2a32a69c1325bca70c7aebb95441bb36e3d2d789e12061583a0312857d733c93a35504e32e253ff8463d0446a46631d7032c5d636cdf9ca1b27c0b4dd38ac8abeef97c43612e75fa3ea0d74c8b8131b6c4dc188d7c65955d897a25b07437d5d9106f5d5d58bd38d1fcc4529fb0ce2399208eb2e5ddbfffe574a7a9eb9b83caeccf8b13f0510821c9a02ffb4ee3607711ca7bb4b65258822481b5b459f2a25af5780de69d5d2e39363aef81aa141f560b4870d7ee12797cc6613ea1a681f59a72060be968dfba51ee4c6e7aa2089402569e9c3a64e769cc34dceb2be88edf8e34dd559bdfb3a75ee350c5035c62008f350fbf0168cf4c78f46ef8985e1ea232de5707b4d32056d15e70f9b3bd313255855d5d552d74a34e69d426e1d02adfc2ef11c21ce590cae43cb0b391ca80dfa88aaea9d2ef9977420b0e3872fb951b98c995c2e58d6b2bd8c0306737d072104564243de80ce43da885ad8aabf89d798d907b67760045265a06d2330da6f1b7ec0e31fa20d865370a1f0d0b851c3c37ab17964cc48c5434146f2070d4d0dbff2ac9b7beb694645321d49e6f390f7a2e8402ba6285623625e0e0bd811b8df823f85b2d54ce047c2089a199cc270c607122961408c7df7d2bd71175d5df5bd5b4ad91eed2a60b9ad353da6d72894339f96aa584898e7183884df515a75fe22843b02a92d8aebcb7a197ed96a571d5acb9af97725f89ea5107f47df4b68e90d70e8994906d97af7739347eceaa3bc07a9b240b2dd9b452e95fcb7f3aa9b5a5b211a27bc190e8c62dc64599428a0d3e84659e2a807b07f85a1adfea0034dbd3623ff4248dec4ca0a2855bc646185a0929ed09845d0ae45f6485eac2abbf54f9513670bad109005e4be0e5dea4b1c8ae6641dabb39f989153fd5d51fa1e3181edfcd9fac5ee646e90a4afa37301c5430b9b31466f6f5b0756243bdc993c1e71d245cc1038ca268ecd1ea78d14ecd9234d8ae36e409e46a46576e80a6246f512b2ae79726c963d20dec8b7d2bcfc5883cb18c516df928c8619526e7637d5729afa3205baa2fb1fbcd246f3dad856277d8ffb1ef65dac89c0c80fa19a33ed5b918100038bb7df927e59c15b25f6947de5a7356ee3be922515b740ccb54f9b62355ac5402674b4772bfe1d6c6840073fe976e24060b12b0c15934fd27820590029df524fa766eb9de45450322430ba68078c6cb022ea68d1258161bf620a20750f9631a051d84945df39e8c3f9e36962693dc35c940ee96bb104f5964e1e7f8dcec0d5825596958484ec0d6f700a5f54f2839eecb87835f8166c8d0b57d3aa5d323191213ecee105dcc7a6c7b5a3ed965cbb117a07ca72eede6851244b1ee2a014088b4e0ca5d30c00e0e2ed34ba098a719bd5d754263bcc798bf7f0d1ec2211d70bdda5db01af793daabf2ff2b3355717b71317f012f6a53fcf3f5321bfd1acbe621b6a4051710d61a7b963453307f5cb729f6dd6f5a2ec18d74792ce5b7afed5892651eec11d3f16386be2b0d93f6f74a6747dee96fee3b8bc37f1d40320cd75a842a0dce3865462bf1730a3ce6c24c91fda81543f30696bf5978c86010ef1b269cba2d75d15869600c52da36b002b70ad5a0202a00c416469127ce686b0f3f65d8d632c3dad035581c2bcbb09115b808032b6f2fd0367f5fdd2fa5238e3c116e2a52f3f620507574b8b07c20c2d99bedf66d7e77ba9f6e1d0c2b7d46bd05bab1de3748d71696b6fa3f9016281919d3c28b605efd380e913a94e4887a4a01dae2d401a78c60c16e222d8770fdf6c674eb635a82f96b711f8268ae459f22b1579dae35f4a37739468d464536627959dfd2a02d8b476f888054b706b4d24f7cd0cb06520208c3b384e090e9e36b6527487baa589dfed5fcf51246e7065a6a55ea7ed7dfeb32b473fc544f61b5f4935ca4255b9fa5d53f07db68362cdbaec83ac6ed3587d57d36ab1b603966782ce811554c4f6690973579b32b01ddc77ca4a4af758ef8b8648defbdba9b8a7211f6cc2de865a07a36013e92914149306fadd859a708839a1ba335806b263fc82d0fa63abc739c831051af582deff09dac522e365e5c7283dd59bf411f2d66a1e04cde8bb960b3105caf3cd12b060d981ee9c06559522683b99c0485e9c171c272bfe05d1fe6a897bfc3890d2973e563ae6881e13c299a90d5a3f0abd9b0f6b62cf98c567e25c6d3872375467f65dcf38f5d11086b5e5d81f1cbd12663abcdcd59527b67cf65f5348b7b76a1d93bd29e600cf307f19c88b83502547a514d92f6a5728d9cf870b9a192f89dbf7387ce5634567f94dba54b958c48b04f98887235d105d99c3cd441204d532eabe724670294f27f40706d11869cafb5f7df155aafc4301ba08e8f8f4bc64144f726e006ec7a2d7f67e1106f7308a448de81547dae3f8c4f0fd6cc3f418ebedb4408dc22f9e83992f2a823b052a4ede5c449d9e8dbcb054cba43d11bdb4a0838f0340bd7490552723c6e3838621582878a1f0522181598be8732c7918e806f9276a7634f7708f951ad6926b55104d7824c017b8cfa4f423a4dbcc6950c200d8964661819cb7a8a74e34f3f20fd58898283d0c7f59fe3b18a27f4eb71493a0b74a67591d0b55731681fddc319ca6c3e74047d94a4bef3fd3f36c1bf6bec0bde308b91441f1a23b7caa1577b08d95c4e7409b03beb8ae993c304271feae669af7d082ab0a3e3afe5c3652adaee4fe64727dbd4a11dfce87302fe3c3a6092901903f80e5b64e0cf3079c86a8d6e5675029f73c51e6bb277123d68d4404654d3073876a7956e96381adb2396c17746e14d70aa216deaa4b4df2f024ab604e994e93053389d6f899e3c8c852610ebe614dd5682eb7c083a21e5fa9edf2d93fcae868803623f915f5fb854e1823fefaf9372474fa1ae1b5e5d1be261eb4aa1faa010c15bb3e249fefbf1e837844eaa3790d20d766142f42a567ba142c00e875a24e2ca36388b432f5c524dc8a06f05a1b40f730081870a0cd506f463f289c7b353b2b4da2253cbb2068beec7046b22a9037f5a03fdca74b173225b6c31aba057e055b3cf7ec8847bf7ee0f3f757c8f85ffb7e55d1f6154857fbfff6d241a7bbb4b26312ca595eb2e9652d167cb1c3fa77471fbb66e649e84e3ed15be598006bf870f7e684d1b1dc21fe21e6c58d24fc999b156b191adee34983729ecb43c2725c4435100ecfd7c6ce5fe765ef4166b60260b37a0fe796c1c7224794910e13809e7aca7a265a2fe5cf0dbed575954c40370274762a4e57857d4d656fece02628bd7caf1bbff41a4eb112080f519c48c6528d2bcddc51f7a69819e80683c688364485521934d17b8ebebda1b01457f6347a2bb94735ba12d1ce557ea74a260bfa52a43534e7034e543259e3fc13f88987268962bf9ecf79257d763d98da8a82c603071322d9e84d126910e935058ebfdeda2f804cbbfaa8da94fb4d4650ce30eea3ecaa5d59fd4f7629df42d042968eee19757e3cabec44f09de53af257651b42cdaa6fe2dc1cc12c75b1e1d7f9f9bd18144379e557940302cab38ab950f6f955e1caadaea9f214e5a9e331d1697b92d355da59d19cd78e463324d66da39879ac237e15c02c7157dd1d57e2409c7e35ca9287b457dcf5e9b6f58a90de00f216b0d456cc30ddfa7dd903205115de2a0365ada5866d9ae0da83a61e60b70a575d4b286f8706233f3e89a192a4506ce4c5f50b4455ca3b37da153dafe4ac80633b7853b19802062eb0bb332cca8f0f027042854da1c29a29562c78d5f2f6cf2257063287460782ccb484d88b2f44ef31c610644eddbf25843c7a7d9d028dad7e4fc7c4a75dcb5883f92290b5f2e86773f280cc1271cb818e42d6d9dbebc635e1a6e941b4023cf8a816f8067d73f3f4bfd8810a59706db79eb600e60e0df7d50015c06d41bbf3544e00fe0bdc35ea10e44f69b1ab54af58ec796f0f729efa74a4a93b1fa73872326ce402031007c72ac78a56778cec292d3dfec0d46ead034398f4b35f28a3c6a805d49b2138f4d34ffaff87df32e5f0b54a4eaef32117277ab7f329280a8cc4899f73fffe5a9f9c17392e2cd18b5004e94ca8ad266feba7d057ae4c5b89a765dba7385b5c86cd83356eee72e22c6bbfbd21f11d1fa01bebae9ebfd6ea3e2d4c489366708d9a82693157d09248830e58e56923503a040f02482c74daf0801f0cf76118ebe7efc68f31a72bc5b4d8b50d9357cc634adf13e6bc77bf600a872ce1b69f500551d8cc61b8ccb8720d1a18f603f1d106098ff23fc88209ae78e7937f1bd32e81d3fec1305ef958b61159bd12fff85b727cfadf7d3900037fcb3c1a53223de63ddb1bee1089aba64f4ee3c5737d7c0f9da03af52ccbe030a48a27413d7e1f6738e60d984eefbbc996e2524eac812f1ae5abbe2ba371871a9d8c7bf590c4498b7bdc497fe5897cae09728d4719ed48f09973207e5e89f7bb643ceedbcdb6054992073326a38d6bda3acbdd56412afe95c09c0b03ee81dc3dc41052dc98f39cd964556b43f09b9644f60f69c8fc6c16a4191e0f8b6257f220d809b1f19f4ddd8720ae6466c68d8be35fe0f79b88e7a034cd1032840303c8f8f4e5eab8aa6fae603d5c1e9e14009eb37eb229aabc5405e7b1f5d3bb5e06c15c5080914bf0f7edde1328908b7ab70d5e46b3082d4c8248ec623bb40f8edc4acb93928acf623e00b02b1f9da54076f991683662dc41d4d26f0dd49b12d84abe81379f6c175b856fb989724c3eaf1e317eeaf61791e403210f2aa423d669efa9447d1f3a61696565ea41dc0b5479b7bab5ccd1a87d55f3864eccffbfc48585737a0c01f70530e0689e11198120dbe67a9ee80c10af3b210d68c9095440b3940788909652e2fd398d151b4360a1e27ea0796974272973d03966c2fb740885498535cd2402da8892ace585cc5180f056d0627e5edf2f2f8a022b8aa921d67508fe3ca3683f9eabbd5385732f22d9da23581f821ff4364734f9d5aa8e455732ee8264a44ec064094b6b3526c4c05769cad1c0d7b604695d7d1d96412232e12e0f01c6c5fb696b0efb1308dd8798b0ed9f69e8242c6239dda","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
