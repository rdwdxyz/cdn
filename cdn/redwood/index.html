<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2aa825bb35ba77f781b9de82b82834d879006e3302f653b42f30cc8a7677bc141e8d3ba421d0069ebb1ba7dcda36587ada5be024c09182e38777fc142dcb5a02d84cba4439eee5a103d086a5443cd5232ff27dc31a7c47bb5b88a1fc20ccd7475439fb716e78d220161a134ed4321defa18c1680d00babbb0359dc14d2e745e94ef45490e6086afd820687c0bfb498f8944848053b54b8dfd18197de509e97bffaa788fb6bfa4dfcbac1bf752e081f0b970ce475bc0de8fdddf3d079a8243930f42e1b1a9b2ec27a265a1e43fafe79a4d6003b456a9c91bc5470023bf96a65a3c3b71c6b22a394b34475906884ca65c8a6e415cbf555426152d2fb7c7d902658a4f9b8da1efa6030f3e0c2ceac5c149a397dcff783baf4827be5bc169fd51078b3e6bb051bf50eb5d9654f86195eade4a22a8d9a11e8635dcacffde1420c25b1cf9794a9d364445a2449a0b20362f7dafb8af668854618741001ce69726504d3309f151ad36819ae37c8bb12a08e8253db7d96426219d04ba6c2aa58a8ee7a19ae3a52eed4beb637e2223a709a0f50465af42bfc4507dfcb864eb3a7f8b3ccc805ad849a538958ff95f3b0fd028c138e748386e01a786296af307cc85cd5021a0304f4e9937a0c43074516988b9c07eee82e15653b49e63ff4e5e86930155e4d00d648a41199a3b23b603c4182d7010cfc148d29cb29e48f782cc635dd5481ac5d767bb56f0a3a32395eb4c1ee0d89064f4690c4c6cd0902deeabfb3aec98d4175431da469202e74fbcb6477bd394d24f1f818394f687c10068d3805bb6296bfdbf77e5c0b78a4deb8ab93684206a106496a70da4d7ac5f618219acafcce5f49af0a6f4d7c85e66020411faeabc2133986a9db2e494fbe05cf6f440a1fc73e1f0be3e344b53aabe9eef62dea983f97f7812f81b4d37323aa73f4262c8e702d37f7db515388a5581cd0b28c158dab5e1c55503afb1dbd8294e867f9c026371968af1d9712993b3b6b8da75161f5a5d529b199b717f657ea0d0d9b856403b492ab74731f7d9898e7e81c989fa942b73a073b8c24332ca6ddd6709c35fed5e03f0dc927daa7ecd58b1b1c47d8cd0ae0ab4a6996c96540b10c262c2d8ddb6b6502ecfaa4df0df1d574ecdf46d7410ecdd2c90b86a986f33f802d1a225530f2276d93c1bc976a834030c50dbcc7ca3974dd13f0f18871e9748c7ab8a4cced1a55c9ad314b0febe1087bc2f56dd5b5a781289e260319bd1c50eced9e0b703a78901b4900b7e92bfeed4c03d46701d6cc723d0a24639086dfdb967fc9f22b84e1e1d8e263a25eb062373cb27d7e29ca586f2cc025d271ddda4e13441844f3a2547469367b82f20fc5b380bfc841c6cfcc7529719fd63e78af960ef99f1894a812f413135fc9e59e685d53985a1d9f13418c28cb1d27e919e79bf23e4b63b9287dda01d3db47f8040653dd9cbf0160edba01723ebe0022bb64ec3e00819d549212cd47c431e095887dcf6bfa301bfd38c597e48f4f69e0c750bc66b55d132858f7eb54ab6542fb19e329e2cf05de27d54314f5df1857686a7dfce785ee464027a945392abe240bf739aae79a1035f68a71805eadec7b7352e23eff7636f62e3cdf91a12e372e2c87f6e6e58ec0d8689522324868b1dc5112331137b4c7a06465a788e7c5186495f52f5013ba501eae681cf9f5abc31b5a861fa928202c97adcd7acec582518b285a45bdff66eda4642d75c4e3275bd62630b97565332ab7b47daa6a03ab3443e967b195fdb3adc23c1b2dbdaaaa8feea33ee50f6379d4e81701fcdebffb81b5773a753aaa203011fb8173f78885bbadc583e2fb98e1a5edf018e2ee0662f231e535760b88e344ac8adf1194b6e5c1dbe7d96e3680d101c8fc8ad85cfc19021ad3cec9f191ebc0686ff3b7230c9cd4f92dc22295ec80d3fd8f0d7b74b1b1c52309ae4f1b759fbc2cb3dbb28f34f693ba9732671f5a93f3d918264ba16a684e6c3bf43ec81a74de9df738e2fba92c560c0fa59701cee1605f0d93859516b5cbefc2e248935e60322c9e99216ff4406b5ffc5e2a68e843163dd165d80e1666a71f17de8e9c2bd1a88801796976e6dc4bd152de253c1f5404ec9c9c1d094fdd852faf8e9529db141bd89d1814566ee9c2c32f2f8567a44773dfb0e94ca2717c60bd6710327b76d1061412d4fcdd4063b994d73112b5d662874d31a3618642d06fe76b6604c57587b783ef70c45e4b1165761a4327b46a3b4f8c861888968bf8a0d44094b3e00bbfdba7cbf0abc8441fe0ab5c365935ac87d27d7e179e77148d37d4203ad8d1194bbf9dd2d429ece8f2826a072ab44ff342aceddd79db4788c0a019120a20a6214e965abc182bc96dc82354d7ce1badaa8504ef582a0bb54f2743aa2b2bf1a8b7ceec87ca9c63f7e2d8a0f2f7a19b7412ed7522e60624dd6827a5104584f71f75cd4fdd152634a17826c286bd9530c99b0010af0be99ecdc6c25d70144031710bddbec8e8cdb369365821e4e6c0428791ff40ddf38588f36fe8f7d312f343ab171a4f7c2bb8c2901aad1b58de957a5dc441d31cc46736d550c150555a694b08e1f6fc73d26aed8fd26aedcc1579e57e2917a42669872090e5181d27ac8785bc6e2931aa5b060a56a2a8d2ce91fa69a61b0e6f833afc559e5b96e6b62701721087890510b4042c9e3a086deb11d886a303487ae9ed3c8c0177221bac36ba6cbfd5fd87e0add469d180e3b94be5ac762cbc6b28b9e330c8bc4d5b68d4a811dad2dad42403490c3bb4d451c96e8ab50701617bbfdf001d6323e63f6839b3c06cb03a7ac943d605f464d8d4281fc524b60618ba6925d483c21be9f357f2e3ee44aab69affdd4ffc94649e8c287885a9419062d7cb85bb62483aabfa8c064e97f704a6ac5f354d350eb8a5992dbe411faf3c3907b42892515bcfcf68a85c0bca795eb43235aa961612f33f3a8daf0efe66846b7fa272c19d0409b3e26ab612db1e96332f9f8302a2b3225cba7a8cbc5502c0e6c603f16960e3c8498401c16fe0fa34bc177eb8b36b37fd825424fcbf2351c6192c43a3e75e3a82a1f0dbd35db8c5de7d0623123ef4262514624643b90e976e63067b7cb31be3786e7ac49b8888377b9de02674cc34fd7383ac4d5d77b29903633c0742b03a23a7b941458a491b32706f9f4d43b18c2a7ba44d6bdac845bcc3455d4c3369aa787744f1f7f3a9d1dbd60ad859a82e91194861dabccabaf655f5fe1d7adc0c3e57c23eed131f5d437e080a02334b6c3eb3ebfdaeb167ccc936e2b4d9276e00bee99537cee5e514c212a04a1f2726fafca1a45963a0febf107a7039f7fd74e1953a492704f507531e24028100fc2718cc209b60e36a60f43596fc4473b4951025d6306b1eb96995e54a45dadbed6f13298ab3888e6c262b44d71408a3d79498212a15cf8480df003c0a39617d45f21fc69acc03bf430c8ff07e1b120cf475caaf90815dd7e8d11bbec651dedabd1a566f991cea6fc0512c3fce170ace309ee2b3b5ce2ea6226b2e85119857a923091b371b1af2c916fe195875db528685d34cafd6444b9740c29ca2b28ccd61a7a91247b918b3cce22af805855b48f0ea9d62cd2aad2d291adb8f82470f7185f9c32a8af22592ac1d224b435d0bc3e97579c06e30dcaddbc0dcd359b1c13b273d35afb6b2aa5f6d243690f079615d132bc2aa48d15081a33856f34e6ca6e9fe363ef3c0984d8c488927ceedaae9e07512afbe6fd7f4b597dc8704ad695c3607de8269d85f947a580889cef7c4484f6288f5c45d4b48ce3770716d960487ddc4a25f09576869193bf5fb02214eebcb1bac5e3c1e68f912c5bc5843d62c87e36a046087d2cdd02e2f7b6870f115e1a308720ee00e1896b10c8ed9ff31bc257796f3f6b47d39a17bf4cd090c565a3a8d8e578ae49ac89a250845456ec08d698fd0de3bbc85eef97dbc8b9acff8545943a15ccf9a27a848571025d7ea51fde54e8013fc9efef353c58eaef8cb288bd1ffa1805a32c6defe367b63195399cae9192f61f8e86204c5d1e53606921b47994da7514ec713db017c273acd6eee003d1e3633a85862266b3d714980f851d981082c4248f50d1a76ec01360f4d0e905c6e43c7b3e2973d974e006f1dbfc688c88c575713c78d5725a0472530048d4aa04ffc41592fb7002e183cd62781e22d45448ad2b08bb5fac975656ac95a843852fbbd9327dc399f0c106a6120bb4819800b14ff12813859dad548092b34a3616ba0344a56ade82d7c0333935521835ddb06fda5de3c2f04f9810c1d2898717e1bed1e0b83c3a2caaa6f47d55359addab199dfba94ce92ea2bded68a84e10156639c9d457e46b4214376f939dfff67f4023b2e4ba633cf22b0c85434152c22926a97365a92dfcb7fdff19bc2eaa148afbec2c22868ab0746e2b2da7a9cfb09fa7796d31cbebf559f43a5a47eda3e1ca8a841cef0a2ed947deec6bcfe777f926842549bc7523afd1fb44ea82cbe2c5f1cd8fc96e6682d63fc3447af89dd42feddadc2d16bd902293c39b38163a02314a5c6f635cce4173731062005edfc62cc60fc0f3312badb893b1ffec0e0f5188f39086bed1424c2785965decf30c102b2b812c3d1248ea9db2f0968abc1cd858efed3c237db81610826752d2086d321218e6953f7921509673b76b9b35fd5a64919bcbc2e934d4f074e4b006419af29de4838e4107adc7d344492e2489b8d373a5f8d0bf90331658c68b18cf5da662be267f567de387abdc22a787d216ae2f0cf039c2ada736fdcd9493df141c481d0ae44121122f3f6b9134d6db8c9b5e4e48071e3a54a49dec668562de4b60b0d2f242e63491c0489b442ac8f0e8a64327348404e8c911c44cd03bce1f35943e08d89977d88c9574afe302591be36d7c0ec6ff9e1b2df1c014816815da762a2f76d6534bf51879f22a8c1b59e142799cd2ca54cf1003dda328b21a9b147e70dbc21a494c0566db6b28d82f59edb205e785e351b5c959e651ca6cedf6e187c0e0000f16cdd39954693dcc35ab6c70f6dc0373b048ab958c54258ca454742a32f0ed6ae240ce6cd5e62ae7345e4af167894bf36c2a3b0e9a615b656830944d034380a18a76c4822933192174bef3a25d735d71c73ed41741fd2ea8d1234c2ad5e5ac6fa852357cd794b28d7c6afc5bf5a42261dd4f34ef557cbe8e17c6e4235081167d6e671a3c6a9df4ab1954c57258e378623f732ed5455450a72947ad5099d9538a704ee937c8ab0854ebdb76624ed51cdb35047ba758e92141ac758461a445413dba005c4bb76c2e665a5174eef2aa12951d87a4d587e44032fc6c94f1b36b1ebc63ad92d71d6493536c2efee5bcdeca26a1d8a22d8018812fb6d646e584ef6e51451eb87f2375f7c171ab12bf78824e2abe6c91144b1b80d3e5f06d075d053ccc016dc85441ec5136178924f850ebe2c59399c3377282325e83dbcb5a190a7bc3600e0efda9f2df7f6f1b4629963c62bff5ff8e4f8865df6689f1f839f32f8e0aaba737bc2565a06979567046bda4d5afeb01c21341f24666024fefec0fd47d5d7faa4605efaf0956b75e179af7ebfe7a1250d6ba65dab538f39883d99cd8e8957397b8d53c00867c872266fd5ccf05b65872706ae5468e86db69d80892354d55edf9a68018324392670a32715537e7b0beeb90ec7df3dda9ce354501fa0e02a65c8a7df51442f618dcee1cce29ce78963ffb60887d971369d768131e0497d98296a4457ce24680fcaab61548a370bbfa5f598a693dad0775b9780cc496b3b1333f1b2595bdd59abb997df6ec9eb1a9cd909c87f9a8736907db6713a3e0e7b9c3f52c694728e0efa24fc7e7d1c4b0c4fee1aaf7940d6e4db4c46527bac6684be6361322932d191aca321ff6e65574496b65f517076380b48d579bb65b20ea1ff69d498dec56aed1147994f53670a4d72fb7ead83862a1b9bd10b8ec96286e6e20e59948b2bdc398feadab8ecd13f261938f857f4fc52152afb9426267b0a4ff5b42e020301a8f63f7bfe44a2656a1fc577450b8e41bfe48ebd43a9623c061fd81a890862e7c081bd3a2e799dc6bf4bf716eb84572a6fb3937722804196e47d45c5b0ac10087fe356aa460df9311b6f009d7eaf107b082f436e72a445a6c8bf1b8d9e6e2ffb43cfacebff25b86621b83826d7b25f648c7b196c2da0774f3ae689d0ad7a5ecd9669c6fbf57e083b035d69e5edb568cc2079228057928602dba0da400f8bf7529179b4f65396be74361e04a3fff050a54c7a3edf607b660e4302f284cb33f7b618cea687462122248e08a8112ce765c77ae33e9bbc3818ca7b515a7620bb077e54122d447c894da7755a23522f7d22953de6f9c3ee64bc28c8583116a8fe2ff0b40eba8d2dc7437ea6ea77eea17745e9b27064c35ec67bc00d1a78aadb5497665bcd5d9b8688a3acd8cb79cbe1c7bf7f1b210ac5381119947b9235392820f9cd0135dc6bb9740cc7491bb5e90c6369d0b5d8a6c5d4a0c982eff553eeadc7c04b67d4b85ad3b62a263c5cfadaf7de23d1fce0562d2165298c0359e7edb7b20f7cf48c1e2e2540bf59c2785fe2be56faeecc8039fcfb2b073be5fa8c7f802a8fae8153823df3952f6c2759c63b7875eda54966d116dd7a49d44bfc23a7a94961f525f123ac93e8a86d4169a89dcaa746ddc010970bf9c56decddac3cb01d33499bc19e0968a0a858aa78dd2c1b4ca2d5166ace528a34aed46156a143f65b680bd36cc2f8ff05f3333a464e9111ed956e369fbfd56d9656d030c0f3087c2ef56968a1c11def723117e96ab3f27f853bda5e9c13869b102b4f0fb7e05b267c0331d9aadd1668ad1fc86c2a674ead9ebc1fd5a67845296356add663ae76ee57426f10596c4554383a73cc1e948330931d5d8283873919e4d7d3e2d3f38f304f3e4be2c39e944d8d3303523c3ec0fe716e5e3f47dcc3a7fbcca10b2f2a833412e683b9bc6fbc4cdea7df14d32fb573f8d2f21337d9a78030a0aa590ebb19025b7bbbab3bff682dd3cbf14c6e3e6873d6f2e1b0335d04c28a7ef499de51b7a962657f9d4240aadc6fff860f783a8fd3e5974d1cbe777a45cd592e475449520b1e91d82e75e4717d6e678ffb8ab54ecee8dcedef13c7bd91e51e98bb10d73eed630bb2eaa799deb752742c6e1ce217a04f7611c59b502b4efdd91a73a94e9f17e80401363f1e550bb90407af991339b51a207c37d85cd936182a0d0e7a83877c35c54afab7fd4c9869fdba5d9cd848f6148c6cfc28505e18f93098639adbefa3fc08c09bf48614b7afe626bf3d045e01a09bca106e16a76a98f2974b8c255a856100123b63eb332b58615dbb3682ca7458ee5ec97a55c3f8a7f9ce94601c6be875385f6e8507f53256f8fb913757a4dc6138c6eb1c8a211f61df0401d60318f66e85ce18e8fea8eafb0637e5f724e75b76fd7d66b44068eac5becde04c013d015f9f0575d6acd4095578ac4b7337788fc3f894c1f035099a2c2e7ec7c100c28dfce6277e34969f8cf94542b65035d9e7e9bff5205def05d88c5b845b14fa037e1a372256f157ed700e4aa02c272c0a1aa5ae0dec740e748d42f7ea85fd2abbcbd87dbb1c6c89a86c1cba4edf823e5591d9d50aa6e7bdedd8f915f35b78423e29aa4284f7f4c996adc1b55125d6c7ff91b26bf30afe628eab41319ae0ab6b341c4f755044a510d7e7fef509d7a39f35f125a4b106f6641c825bc7660514fbef672f90b39f89994fc63cbe9d59a250d1075fd17bf5382aeefc75ea3cedbb7e76b72682c9fdd99775a627fbe5d74030772bcb152a3abc01486713486c5ac53d9a2004dbd211f9b426d9a318580be117d0f5026d0fff1a9e1237489fd129bfb0fcc07cf0aad8d9828b0aadab7368eb5947b908832a591fb3084404a5451fe6c7f512edc55be03151a01501697475dfc2419d2b77f8a7df3eee1aa5d4486c19c196cf94357d05ede13c80791b846f65a2e6a3e86df59ca3f5e750c650b2a551fa376cb000c02a15ddd055f1b160f6d69729152854b69c92760c08fdc1d30cad43dd181146e668d52bb64509d02f6d1f4f92e843cb36a5efb0ec584d08c8b3600873050a4786639514735c68762e7831313eb46156f688feefb27acf639d9ed59ff4a6ba247316d0ec37b420695e36b62171f1e2f4380212c82d2682b99661d914e426e6404d193098ac408026a56765ec6b11d8820b83e7c858b1fea926d2e394aa51e7ede8f8e243c7e6fc6e183278ebf682e3dd31824a6c1f430eb955d8521b368c0b3db5ded3fb5732e487703b81721562b40b4887d2f039c34b2a89ed13b5b0fefae899eb4eb04e0a7bbad6cef36d7918144ccd8d6fa08d13448bb766135fac4dd192b0f47c191033fdd72fd383b6847cc9e1071539cfb8c051743f00e97707c5aadc1ea13373e91dc34066bf29b23689d169e9129c11efd6f1854a1da873662d8e2e271be92d80c1519604e91dea63a267af0af96f4ddc0b8949332865493d566dd6046ef455d32032b62075e63b8b8ef3b47000032ae25b93ec918b3263effaba878c31d3dfae0321818b4074ed1be2fea10138047cc5c74b3a0c980cc07e245da24efcff27d2639b9e8019d62990317ea5f407e97e92d8d7985a5ababfe1624d4a525df53d3c6e5266053de61cc9b7bb07c3ab5cd7cc98b4176d4dedd8e7b34cdefd87a32031804ed84c0a559eb0b48824f2813c30e85138cfaea26bbf83f025f6944f6e7d19234341e9d9972a4f0f21607229caa9b0065c64161c0a2214a99d558037a8b66544a1957e5ddad83a38233ff067fe2068afc28e8f57f950ce1ccbd24c7f852f85186bdb85eb13adeb25f3cb76049cfb37f75819bf73f3f2c674b714e013981e671ada93c0035a14fc43827a489b9eadff2234b7f2ac4ade8c4319b9af03caf61eb8820958b86f55603e27114f8d45aac3bd32c4248b1807935aabf73e5bcbdb6513f43b225adce63fd7743a84d3002f64c3079dcdaa4d5a22264894b4a1d19ed1fbc5f32eb372f608eae442c9509538d2a5c41d5185bb05f6d443763abe723f7f3cdf1920bca7bcb7b5fc6b4e1a15e917c86014809ba5507b31bd5e88b9791c70a92d60f1e610f7c1631bfdee5361525cb5f258acdbf084ce442ef0976e76223744cc6a2a24378fd1759a4919def8688e45e2beb12b14660030fd396774557184305085e227b5a479809ba4feefd24ed16d4453f6048b6407c4e76fd02583d285ddec2034cf7b0c9803295b868a6bf77317826cbe46d77e254bfedb0933152650f8c7a2db065d0f5bf7e16dfbd1115dff530295a436c724648af8a1e50813a827f2dff92dd541c248c0f3044ae7c9285aa1b3693d2ee5a365fabd706cec0fdf6e03eb00c001d4bf036acb2a0082f51b05bac5188e52e15d11e4b6999525eae2c64ffc6c18d202f47623eea623fa89b87d84d15c03c5525746634d8484eb98bb68a28ce18ea6f5a1ce4acf9851b8cc0f757b46f9f35ff0da8fa946ecf8e3e80ad640677dd53e46ad2f39f89a7f780d2ad66128f912293f8d436af8d8711e000407cd45eadc0bf9aea16c1b172da9d54954f7bdeb86231b4e033ef345f21e127fe88d2368a0d9c57b7e4141c9fa1ca1918603f06a5ce545138c02262d13d4c6f171505ad4a4346beb714b63d9b4e80f49c5d19b63602268c5ebde71684bd6071d4fb7e92b52c8989c0c911e9ddeb35836f71c0b9505b661be7a060b615bcbc86e3ccde51b1d1960dca2ed0237529c9a590cdd229b43ad3e9771d54bcf3c28001102007d2b758765d0f0dc2b2ecee8484d2044ff810e40ab4c60a12af418f905c0f72174fc33acdf452b94dea5a3a9340609c17cebbc3b4eaf0f1ce924fb15966e7413bc86878fccd791f5601a70c888e36a66484e2c4338743ebd5c3e616a7383c34ba1c38e1eceaa85a31b506adee7966228e219be5175eb9c43322f662a5dedc5b4d9992c56d731f598f5e7bec4332658f7287a5852dbeaf7a3ff3660d02bac30d3f6c56092d977cc701dd6c9bc101da07d959e05d84ba2ab012697518cbf8e948cc00878c298105aafd7eabeff681b57ae7cc1100eda14475726b32a80a4f6acdec3d113b1ecaee4d71dd408f2d8c2b36f1815734af93a70b1ee14d8061c659aebe6a897b7e52ae5cf9a046367b175a26b4b5af7bb39f19353f0122f391515046b6a8acf57d046ee035252161dc5dcef160aa30d71d976c368e3aa5eb9d950b82b13eb81a6266a4f520087f6810fd500043389bc7d62501387808994ea95bc1f999ef10d388f728830cdb5a2a160c5f122b4ec6d33b475c232c764fdf4248fa47d491e8c64289ab3fe15f9de57d77e79762ae8d499fb9203884f56aeba97a5567f633a0fd8f76d9ec694553b6b14cfb30fdd4698f88c531014f649b26f94700dc43cb1c529f24f9fce5bd60bf4ca00f5201cb240001114aba27bea86632ac60b78d71b43413c0b8adc0a809ef8ff2777b0cf5bd4d22958e24fed576a7396eaf033824805cd2d8c8b432d02dc1859d794db9e9fa0d381669774fd92df0f1b6274a329561e7d11195738a6e77e47d8492e29f80a08b1811f8c13550f1c20f8e58c2d3fa40650bc07f75043280da0a60247d602c16641ff88623f8efd16fedcae05edfffc0d620991c4c29114b6fa62c6941e15b2260f4fb1beaec524138dabb7b0bd305e8cc91400c7048b41c900bc455661c3331e85b8b808a5e175310979b26478409ebad82b205e991a854153b3a8015b725a742a3051e4b4ca4f67710a9e2fdb84cf7486cc42a44d76b0bc84d442036876b9e2f18fb4ed371e88ac271c17760f1a898ec1ef6ef98631ac2e05627574d4aeaf27431c0a59885caad907aceaf0848aca972af612cbf1dc8d022cc3e31da34edc8675dd983797290cfe8439a48ee4e2b6d7e621d7b7801a6b2e8b5e460134e3a688a4963196c264b487b356e5604c1ff9fc9038512bc9b79c3d95f878a338299cc508218620366f220cc903edff1be3deec4f1e23b551a3924e25fce541984975634f6fd082e566e48a0a778467a6b04afc77b5416c8f943b9f7ed336681b2712eb5cadf44bc1e9cc8bed0a00adb8df7a3c02be4e51a4f2e46fb2afc4f6a710f6ef7e1480592a5cf0c1befc7bdc5a72357e7234b50078546c358246b9622fb570504ceeec86020161ac9ee81d6292d8c8c95edda5f794cbd697778c9eb9036f7a464b375dd6afa450861f89e2ecc8fabd11d97ded11adb4661fd650c3a40bf6d0fb2c44a262d26892d3a5afc181f84af5b81ddcbde31c5aa054d1c3385e816c5e106f18bfa207b52cda8e1cb9670c323fb9c0800f48ad6e4d4d511857d00026194bcb1de8b52334104c67fd217a6bc5b9588f9b9a7b6bcd3bb3f9a1046f6e02b6d1b5eaec786c8dfe7abd90e9880a5ea3280d47de1882db5761af1cb0402eed3be4bfc48bafa4a5d4b0ccf61d75da688e9b428933aa631b560df2278e6dcf8dc4ea07fef178f05d572249a75b61e93f39a2b407fb705357fd0373f37c2af938f48d14b3e1e4aee7e805c1ad4ba086e1ea7cf842d2195b1ea69cf5be589c042fb27ea7f51e6e3964089089e9956ed13ec1db88b5b156ca6c9c097644fd6c4434bbbb0d4a9867053b9bac36ad19852cab07e4a86ed635681c3272c20dae345de0706fc2bb0978f42780ca4dbbeeeffefac6c71497863076b395d4fefbe8f6d096b458322c0c131ef8b613e27afe6434d2225b0bc95fddbae99204df0bf434f78cc895125c7aa42a5ca9481ab135f5cb1221e13a2b08692bb5ec3e62d95b3483820ecb2b857045703e99c0a5a37b0dc872d6ca6872b15daafcfd99675e06beefc361430b60f9e2b9fac48ae113383a9da2cb55b5e50b2b1f688e4b2ef15b20512588dda3151e1c726ca0844c0d9390f871470168cbcf71437d33d2480a8243b718c6953e21509f129906ad1d3c0768a5cc9fbc57c3f4153bafd574457695004d0a7b650bc5cca00b2d17d85e468ffdbbecebd4d74fdb9010608fbc7daac3ae10a3f3dbb0bc3055f01780c9ae618ef1d098c5f7b6df9ba85ff3d0591f09a82af363033b53d4b6eed00df3b8dd7a429eac67fba01220413f7d640ff33dcf5e13308bd7f23ef55aa0a29b6209be431703c003d463bca762c844b26380fcba3165aaee17b4688e641bdc7d576b401419aed29caeb672ca6c576d401269d54e9c9ce87efcb100a6ab4fcc4cb8a9b8b525a604caac90920e716766893bbab18fba7b22c5969c36b9f4b19e013d1a5afd7d7b8ba1b8034a7298611477ebc2d9d8b1eaa63d51cd53415067bc10a285ce4702d325ec00611e940230cccad3041986e1ce209f20245f932db591b96bdeebbd9fad218e7dc907dafad936b081dc52dd691e44191daad71b8c03100a26b90c417dedc4f00ae4d2fdf8c381b90d041f7f6286233aad408652f8b80ab93141634d2e9c86a61d3f6bab8993bfa4c36ec11495e65649089af39fa4fb4653ae1a90bd4051a320f46ce79478e691b53a2f097ec067ac8058f98d2054b47afcfe4c7a15a06f5170238c350932640e0ca3c4d96aeca7330a4c261222a0828dd42dde8cfd410035380cfc87ee5bf8dd67052dbb1a22e4d32c230f32e3aec60d865c32d2417e647ddbb14ca18eb1c9ffa29fc5f7a4b15980c24322cb03b13cd9b314f5d5e1cef172b6a8418aa2ff5effd628780c60a969c0af31634b4157f6df33ffd87dc87b677257610da036d4215751a23a7202e4121d327f08a5c57e22e9208e03c294d68aa7d14667b21e30e0ec551c287d61e4f6672fedcc6ebd35e98d8c46957ed5de9c9ddb4083af5a8a2e3faeb8a1142a85d8f6ababc85eafb7dd9a6e4c0dfd73938adc061d2261a812952f312846cfd5d0928b1970d514951142b85c8922bd3df403df087d8d2897942a771208b6efc3682c59fed2d4887041b3ecf47c02a893cf83159bef6ba7657341cf0e82f94cc2cd3f229d4184c7940e39660f8ccbd9462c80ee899217fb8a9d4426c2030ff93f58d8d7203901ce1cabd54f8f44053225c0e851f8f067eceb557b19fb20622362bbab4aeef72f278c32018f77fb4cd4fe0884c984772da18834e19410272397884334ec1abeaeec7b46a1a6b19bbddb809f7656eba98e4301e431316c0708c9198b2e733dcfad95329187620c4cee9ee354008d8b241caa3f791239707a0c990617381d1741be8796d8562430730d34e15aff5dcf565ef5c93480e3d4b0571a4274e4d8793cbf1dc36c6b27e5b0737eb4758d3ca89d7b79d4bf8ff0658509bd5ad37276db21aa53ab941af2fef528b18ac576b55c85e282bf845e19924b2129e2285a22383cbcd23a0a8e90a4cecb069d9e341ce77f3668308e8aac3c62604a7222b8b4ebea2e5a956b370a69b919de5fe80244644e778ecd509dd5576485becca3a09b972f1df3a8ee0801ecd21dc258321051a0ed88d5c9062d43ead56383b9fafa504601e2407de59b2b822ed9da0b0ec35a6d7ca6f74e5304a0d5b35dbf3fb63617868053425c207d7a95bb17c8bba14bb7d5fd67dc626f87dc9abec8e258bf8c01269e3292be38a3c655de66d6e96be6b83aea22f131e765b9681b84b9b0ab026d49048d064d7f2596fc9ec71fe02557932636397bfedb8464afb8c4a0849b4c75dd10226d61b9b0d7ae12d8005abedf5199149e6ffbadc1e7690e0a6eeccc906870017248d498f0420fea547da1571030e2f65a77154ae0dcb4f6a5ce7c3e4c7050b556eaa7d0715eea0800b51b79949c81dca37c57ec1303f761460c4b319feee0e812a004a8e08dbaa57f70edc42b131b9ccd0f312c506e6810bfe43f0727beabdb1801d20594119b3bc29fd4776d845b9935b85713a27ac7da91099a276ec66a8bbc2730472582cb068995e9d104b1c14528e9c0799153ca4ac08325277d10e897c6d075738901240f4a9a6e9cc7b02fcf3fe3164b32366ff098239c7b655c8e2088418acbbe6114b03373bcbf3eb579a87f7f41bff28bfa90a0853fb2d5c1dc0812255b094ba35e6de87e49b93ecf28df22abd9c6641c6875f915cafbd2ea6bb5412a205cdcd5ac9861986b53b15b04290e36b578fa9b5f81ee3c60d8565779a2ef2764a58eb678d9ffab59c91dd15738208bda3de1145e179275891826d8492041bde19478c5831b1629f9ba01522217722cf12957075c697399ee8a492a20206490767b1305b2d3f62fd5fbe2898fec651b85482915eba1b6acafb72de4d8f670ba5c96988bf55f70c95e630811d8f8053618ad389621e18e76beb2c9f7641d5111b95b2363b933422fac455b43616f6809599a4621385d594be4251003063326d21607c10adf9f5ca8695c2d0d66915a226bded2bce47c34022228086dc2b0833e14cec103f38e9dfcd0d265da4c1decf57dbfc30e9c1c15c10b16926e0f2e1e1740ec17c88f347a8cda86fc06ad4455c97727f491fc64128cc7fd0dd621d57893108c4dd3ad8cb59c0f4ac7b14176ddefda69bbfd39b0e36ef63d18cb3eec9fe15f2f121135f9dfdaa642da633dbb93ba96bcf9d6c8cfc875fd3187e65ad1daa116d38f718a828be8b6c1603d47d86094896b0b988336872858b7e34d758d1f155fee1df478824dd5ddb12651fa12727995db843d1f53ec95ca45838efc515c7af0080081635bbc6f6a08f8d8645235fb55b752ca1dd5ac4e354f2347d497fcf2c950e4b1d0f3bb7341fa99fd48fa1c47ab998fdf718bc2e932c57d6f9efe44267e16e6d9c2c1f13a833d6a8ba995f8676a5ab0c2778da3909bb492b0cc88247ef45d2bce988d5dd626844554e8f63ba2afb8eda68d34e669ccb04ab797de67335d954c73dc1f6b2b35daab148558fab24a019559de46668f2f9eda52bccbfd56f22601f216a87515e2c1eb013beaeff1e2000869ab56ac93f2ae2acf4925cae13289218cc7eb948016693418e55c032f3bd3619269fe392bd6d92df4e2578dcf247860c970dad0e5562cd0ff740d2c62d93af97e30b836473b5b0e33587a14ec4c70299d0e2fd1b93330a5bd190f5f17c69ae8f825444ec85b8055499eff0c1c1dbab52f38285f15a66fe4f45986624c4d4786f6f2c11656545acde6db405c4c009fcd70895a4dd8f2e006e99424520cbc2a6a45511b84d39c6edc2f80acf50b314824f3ab982bf475225cdf25adbc4d6ec6a720f982c4367f2dca1f71f290c4002bf2cfaf8204e704b972d8bbc29e348f87bb7679968b0fe7ed8603a664110015cf16e18b7effefcacdeb85bc552b55fd694214681872a87893268925146df101e4a7e44e02cb9c1356b2a3f6919a39d1c57a1f0ed7124d0efd58fec2044271c6850bdde0f79eeaa00d089a02e87da91befb1d06f858aff47e0552fc09f3b8384dc0389a2b357eb37d7383a6aaee1ba9a727b4c02c55162c865ea302f54b576a2be19c1e17fddaa4dc7896da7f22a5b47eab9ebb44413b1b12c6f8409d88733560215a0b8f326ca235e0593b4559fe61650403e728070c3d6ab2366b3d5a5af3e35ea9862de5ad40d867d13d1111d234fa7a260ce3f27ac2e463646deddfc81b09e2690c252209499643e03019d68e48840ba09cbc36e7a542a405f89be5fddafc187943e062c0d7ca38fc5bfee0dd855e9e063786402484e3c0e1c2fb1cf42d9ad191db8529c15aa28184e0a7b11da197457a06c3b3bd54c9f5062ea2d722a20aa5bafbd3b15efd0e3b770776aee8636f39fbd4dcf39fd41ca226e5187bc6bf3c0c6e0054e45ece6d0e74ff8d20d4e331bb171c4a99dba76155756ba5135a63c0a8607c2d4d45cd394aa4ed00fdf3c47e858ebf2cd954fab22fd00905cad398b9d15d3ea511176e1ce70fa244f8241f7f760fdccf526e7703484a596aec19a49c86f5eb761060b523638143fa50356323b67e73cd3bbe6af33a03960838bcd27207298afa1ffaaa7da47708c29d96a898027219aba42f9974415d1c5ad5b986f1912577d124bcc75502f60006fae7850ecb418eed4017d2f9b742d335e99d75e7f6b2a58fae596d81e85cb86e24afd66a66d691154c35d0ae6075bc313f446d1586562922d536915f1ea977b3befae177fa095e27459731a78ae14758f4430814a9721623231abb1ad046c3a99657c5c7ff2131875466a61ee4c41c350f552a02c1e88e9ca21629986718ce8cd67f7f4fe862a7a9915263197bcbd930a456a895bb291b43822c7cc7f3171fff618eebabef73f29f0988c8587ca64413bf4080234359b9b66e2974d7184106f0b100aa2e26f3c44b29fdb5a2fd6e93f1ef1b50f68cfd3d4b253e4bb875e4993769096a117bfe81f81743fe6efa76abbaebc335fb7f4c67a86c1f169333835e842167321737840e11f935fdc744acd306ad0e074d0fe897f3b7cd0514add0e9881999730cacf754c332f4c42401f9d07ecccc5526ba634583acee1d6a5844ec832d24553b4a8955ee857414b496d38ad9c7da604692f40f6e3668a288769f57ce56d11a14410f5620749e6163a2f8e665b9bdcc34cf8fc13e78da43975f9698fe70d3af1e1aeeba2ae6340ebc918a48870fd0f61f8855e2f1c309281761e8e3e8f75a6dddb5169235d828b26ea8205abb792c655bbc73431c5acd0acd53f7037b4d48473f7ad415ac6298480f5eaebe98277c070e73e561aa088c740b3ff7482b22ae6b33b4ccca621ba354f5a7a2fa2650693cd265d0c4895c6b3f39c3f04eb213cf294abd6d9d57d70be492ee0581512e3d3414ea4ac7595c8c2c929ac79a0d088c111e12c347edf6af465a86d3cfa3013c48bff4150601f684d6ab58f34725bbd68f76e22c9088b7acb692a9bf1349528d4dedd5de25a745c56b493e7659081bbaf5919cbe7dcb3aa5c5e09354b823d94fc5bef0a14902ae4a1648feffcbaa8278c4c1a2ff4db0dc99e22b7b87f74fff1c0044b28629d549194dedecf8146ae79fb9b63405b4d7072f56adf9e73f672da2050dd827d3f3db3b26ce4a6acc482247624ea7dc36cdd29c34e291fea6ffddc98efa17e8fc65f748e06b5b19a703f9bf1a3ee4b7db71b398a9c01731ea3431f211bd199b49aff0b81cc027d5964a5b65c34fe9278b6dfaa3c663cf411295440952b4e9e713f0fee60aaa9d8916e9ee56fe8a47c08ee1c0d30118597eae54b31e258cd1e07453f64d4cd449690ae7d3ea399532ddcfb1f6bab80ca11321ac1370642ad0df899f2c8a8a226bb8896b8b75fe308d9946400ea44798ae674fbcad780d42cc2c2af93e663564dc6303ee2e84476187c1f4ed2eb70ea371b7f517cc9412b630a9e3ee82b6abf16a4ce92f48869a3681ba7ad07cd4b3f2c66b613bdfd501ca2bb1109be19bdedaf4214963eb3cf4c870c7fd31807fe2c9d312f6ac4564261f9f79c99bed749de7b9682981a7e8deab7699825f39e6d25db99228521a381e37f25e8905c147adc983772ba085c62de0a5834f338d4df3122907206756b084946d8f337969f2254dce8d6588cea8da358d151d48b18262693b264bd35c85b38c7a5ffd81a9cd5034e86f2e9408b4e1c4b5fda42209b847faabeae924f107fe700da29a3fe81a38c6903d675db33038d4f2201e9ffc10b458fd0eec370fc1d5b0dd0af75665c9ff8b2a5436c59d4cdfadeb0a94d366dcedcbb5953939b91920725b00360ca5bf9d75ee11169928ec5b533aa22d27896d0d80c956ac3d1bde1c07f7a863ecda2b5e26b36b60bbe5d68390d42df359df7ef13e513b2854a80abf9d16cd273b7194874a4b5f25618cc94c02f904049377edcfa484c4253b58797d5d6aea3eae84ed539460fac9fa8aac901d8f8e8f469d2732db39b3f630ec9bf45f67ab09e60664cf601f48bf45c75d396c0fac7258133162fb54cc29a3ce929e2f4879685b539fd21ccc9190928ae65df53c28cb2ee9f49510f02cb394fb24ecd57398909c3da9a96394836cb5ecd9193d302055f839233e2c54829a5902601b93919cfcc49ef4ce45134d411dfaeb8909ea1b647887c61c086f2a9cd664f35","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
