<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"13640f0b003b5fe5d5dde76d08da9a33d3d5c44e1135fd0cd61e0b616cda8290224d35ecd4661f1a78e6017624ac3f8e6882363cd871eedf9f3dd7b25728b4aca0f76457d9ff71ccedb73471ce27a3ea087fe0b0bf1904d0e56cf95781244e9695242a6e37877e4af0d6e1e33abcef841716b112833416e60e8edc8ba44e8bdc1365dc3dc44dce4a51bc9c5d3aa7c74f9cb0c3ea35bfa8263b1938cc9f82005b1ff13ece0f06d54f72f7cdd6647ba519dbbb481c8efaa17954e91f047608906eae1eb635b2fbd6f8db74c7c2b9d3e758438c8d96b083c5e22af1b6e79a2f2bd6362463aee86cb70debf3aa6ebd0fe839fb85cb1d195ce46fe55aba62a675b3c91074d981173c95fccfb23dc2e845f31aef2dcbd827a12467ea272347fe44e0dbfac67281fcaaf35133895d721ccf03b5d322206be2f860bca060c0011d9482a567e1fa367feacb081cb4c41008ba36114414b1099be67bf3d41a1d089b51b008cb4851a52708f1244035a95ca5df1560891c47685b9a5c9fc78163d142aa10d3edce96cfbcb439b2d11bd876d888545679f43f5ffe5bc6c5b6deb4c71a30e03b18fd2e088b7073037df9a96fd4fda4c707149ab1a74ea767d96875d828ed9249a147912168d31ef1c6b7bb2310d02308b976415b5909b3706c2473169665dceb3268bb64d688b1625d78e928d27a53b7fd69615ebd2528aefe0b85bd21352c01ac03ac5e07e5f82092a9f30e6f6ce1f067136f61ae560f7265395c72b59978975dfeedc79d3d761d72fce0aa54d3aedb388125e87903d026e328ef4acc8e3beeb9c0782923174b8e0feb9cf408e586905e1f27b590bb7c98442f16f96c80569b063a451825547fbff8f8fc50b19ecea37681deba5b872ec31236f3b22092c299645626d68d0607cedf8138be2c525646c41506336dd88b1e11131e497427c540de4442893eb387e8fcaab4e355dc84c759926f24f077e9cd5cf73bd9c791f6cf2e7770cb1a8ac29ef507de83631cbf8df433259a38a4f239062b5a81f6220838a52a837db2940c246ce5d650ea2a0e0be77edec7db47612d0834c5c5ee0bef9eff2e5a51d08fdad1c34248450a7617773e2401fc3d48a72bc19b7ce265f6bd1d81f7ebe67ef56bab60f929f3d2849d38829cb24adf21ebca1462fce6bd42fee92940bcf3dfc26901df4d6c9ef85badac72148178c1bcf5775eaa3c0768ba802b52f8ea5472b13f4f1c0eebb083a1c82c93ed4e6d9486b519da119ebed8b03ae56e1bdaa7c5cd35684b75cf802849c4f86094f42284bb9bd65338b03e57f26fc2ebcef499d2de477ce89f6eb31abff0e72346f5dab1e491d76eb713d9370429dd87c9ab3902b72d33f61d65bc743ed31d40b82c983770dfcdc3384265cfb765787218572a28fd33554ebcaf791b2961039df7bb8b9451b66fa8e9ee651dc7bbad6fba639302b5d17f910c3f43b731da3cc0c09cb0e8e3b9b3a1d196a9097f694f3cf4f90a41941c98db89b0f42c1c60d4f1145c644d6ba92c53a85d4af6fd4cb0ba83df08baa4c325c8b8d40bbceb6566f4a3d84bd08849e6f0ff44b2bab6cdc0dadc8c41368c3f908ec975a72e875c50b6288b737c4e167a7717c6059bee8479582987b818927aaf544abc99bac77e6e19ecd9c971df1a6c724195f57724ff9728ea88e3945c86ad800b5746e1fea31f0dad489f8dfb906e539e5da4d5a058f107c80050691fa7946c4885e36cb4e8ceac3684cd06398e2819c78b8f6b8203fc2679dd16373c8da75139ac8a2a249af0207b68ca18ef24dc9c4edae296bf1c58f8b7120789ce71b5003bab784ec9f93b9afee2642d5578c8849b9a7febb6b36679afd356f0d8cc690f4c493ec2e4c5f040852cc7e462383816a11f0cc64327bfcbaa1cee210b8d6646a1357846a157c528802f18e55b4c465802771711b957210418360b055807682e6f2be10c6c1b5e94290521b538a85ed69aa07d25756525ef806768f84e4b81e3a2858d19c83af3f7d534981fef6ff479f6a1a4aa71723c8950b4578d740a7b09718cbb42da01a2b2a068a16fc76b6085719e6e8fee78c0a4d017b60242c7d1b2cd90a310a194449020d92686a1df79fd92be29a8d28497e03d3e85c32076784588af7c4ec5449fd4dceec2df8ea49eac02a410bb5147c1b0a6487c57f56ba37c4469f577492020c6ead433e010061b13fb7d86a741314a9aade91d5adfab7aef5cdf5b72fba71c05503bb76129d01142f8d9bfeecd7bd0a56409c8ca83ee8ea578d5333da22205e6b963537b88099d0fc761ba65324e66e31a585d0aa53ba43b98615627aca360d5376f5dd8a7dabca2c823ea8fd0a0233d131bed5e00e42b695e4a770fd6d0c8bac602f4f06131a67d3b10a9533454773373829f8d8fc07b3f246cfc2df3f4c06696aee197b253c436afe1bf89b865cee258d39f47654a4eed8753cb405a3ec80981b2ba17518992893c46f06118fafe84895f30db7f4401cdd3f150e28b50f9f022089cf87cbdeefd5aaf543da86e184c0f19316ed6b16feadd627a95d7641275a3f6be4625c42f5744886d210bf62800da53b7b2c3e17535b4dd798cd5c7229f055361c99398d7b67812a49d03ff807906402907bd5afeccc2f8153f19bf164948e650eaa48d49e24e5b02bb7730f4b6bed56cb00076e25b69aa9678f21116aced48a665c742de7b0b96916a4a8c1d708472c0c4086ad9b9751a2c1badd6bbbfa6d31d037fb869420e51632177a8d68292bd47b4c55e91c984b21a867c2211db37afb6a60927d991bf7eb2e759ea95735a963ee829056496661f777268f8c84b7c440f940d9d4a6283df9251294d485683068014b13c3e73209ea1c0c78ca4c09494515c827f0b989a72c3aa6ab6b134e14257b110d371fc0c428162ab0e6473c084a80ce60d8d8218293cd818f531db7bed75a0413cfcb5c798d8049326495faaff1621e3d5a46b366a08c467dbf957360c9f76217bafbda2d70c4f9d365d025e02a5200f43bab4c232676839364f8bd86f9d4de9fb1e5b0712bf9a0bf3704a9413b010a463dc7993b9405d6b317026192f600a52a53ba2b636f68bd6b2ccc16144aaeb729777e196a81cea126dbe68f311b2c141db27f2d53203b4c031210dd9a4efc014394d64a5ecd2f93bef3fe01cc442c45339e6cab5d00cb34d485f171fca56d7d5a609b2e7f7af6219c00ec60450930941dea30f7489c7a0571c508ebb15e983e12bb949eedd9aa1f2beb2175fb420cc95580407f3334fda38e21e76014896bae6aed0bc3266a503a73a9a41060b4d1eb6b2640cd71ebe2d12e68396094ede9b228ec2029f8e7ba2150ba001aab19509e0930f4faab6b78121bcdf62770b404cfd4aa77fa4fdab871fd4a1bba1859872e14311724a6df74f8e1646158ec774c3a9cf6909b3e2be58f553ee1e2c311cbbb419f022967d9326c8c1b244797899376a7b5e94a2acf78c94b1feb1dc3b77f3e809afbc4f159c23a1e0fd81385ee1552e38cc1385cf56655b69f7123e95bf75d3e365e88b13fdbe3d0836c05a554633f6271e78733c633f5ddc9777ba3906165b9f3332f3d2cb32fa3d3c87832997640ce197ec848c7e6d066c618bd3bf482e3793fabaa3d30187297ebd8040368f72bc43a878fa69901c5214ffde4d7669fa19ca10f7adf4178c82a1937218030b452dd6da1120c1f94b2cb5fb19cfc2ac10b91b4c469718fba43851520f25641777f21b45fa19fb23cb226ae5aaf454dad9adfdfb1ed9511d77712fd1ee60262391b3df1bf33245b88bc0197502a20111dedc25951947abcc2014b5027cf42c771923da9af21d50d01a0df05d23fa58ee7e7d3461292f8a1cc71b383cbb43341b3f9111e5ca0c797e62e2f3032e39c06b7af6257f12c92b9c54d5483a0e52012558a35ccf9a15538b3f6700dd4204505e9125381299032c9a3f0035a16b215ff484cc451ab0aee80349052e5df2c85449b53105f289745bb6c826adcba2d2ed845ecb605b198aa9d78cb87a5ec4feac68671f12b3f3cc31c967ba32dc0c27283b36cef599c3eab5947a5d7c38e4567b79c6f49994974b451480deb44ebdf52f95e45d0a0337e00b1e1925722e296b60f0d0acfd8f0788e3bbbc14de76395731533068ee8d5518665bfabb62ecdd0bda03d240f892829448d1df0ac3fd9bfb2b415e7cb91b84e68443f88b4502f4f835993e35656abfcee1b1381d79648e24dca10ea0ec8775ef947ff48412b2af5da83b7e76ce8e79873149c6b9ce8e21d75114b17b13fcb41f0ba17c7b2c25a96d3f851e53c89deb489747974bf47850b76a2e71d4ef4eea9382a9970caf99c7871ec65c35eaee1d72b18c05a10200f4b5e1e12a95f1cf2921a34b8f21c2de3fb58d1ebedf7e055b2fcf61ed344abaf0e873288e5f973b1602eefa94334280b541f92284fdbbb4e86eb55c0754079b453be7f9e06a7301d021ebdd26f3420d9cf4ba36bc532503adf331941e749d3d78ad8a85b10f64387563ff97f46e671175d019e76179b2fb26dded09f2cbb830a36489819277b4d2ef89fc59b77543e5b3681139aac5359e774b0465ae246fa1a514faff99230a042ff430b0cb7f3ab8a61d02096fab5ea3c7650ead8299b5e75470c302a5b526dab5f739caf79ac1bc875f55a9d102ecbfc3957063e5d093fe9c1f42dff4cbe06edf6cf965e5c5511850606cc8846be1d22350e45fd0816c0f0af2b18aba7ba2ea0852e26fc945fab153069ed40f26637bf54cb27acd4c6c8e929c59cf475e660905a5dff34532fb342437b7be6bd56e3b66d38b512a9264c5af1b651a3b44e0d9f31027de16c41e721218845176b602afbffd75a1c3b6d64921a3203a08fc737358249160ad14c35cbd068fa1ca6026fd6b781a9667012dcfa9cea7f41c6975942772717caedd9c57682231c99f38324405c84cdb1d6a3a296a50aa6394f80a5e862976013d3e80a7af3bb8b2a2d78313232df09f3b061069dfa7523aa61ab4cd65138fd7e727601c1c0ca9b92d43b332b8abd06b52bc8b83404d9c8c3d18edff063631c7d6d543f8ff4d18a4c1e86bfa1f58b2855831ac49c7da0a26698548899fddcee9c5678fbe21ae156f8ecd2eb3d5cf3a4c8f80e8c0b7fa1f17bfaf11b58e9ac893ae379641ce5efad978cab7019507664cd648cc9f98335d4bbf9f8be962127f0c338e4377fdbb384f7a74138a5b15930fd1bfff00965ada9f6429971220c5f845c32e3658e152d615e8f13ead667d44207680c1b3915a0604dc8d2f1b8da7858df2f7391c587cfd7db5db39dd991ffd660fa392a0e032df7a8a77bd57840d2e0d3b1776201f80714aadb089cc87c27cb51fb5c6b6cdf5966b67e69018d16c7276aca9588230c3050961dc52272ff69b4094153e7e7909da6743aba8a061e25a3b764329e4b0d70d4137e793e1010daffed953f37ec12130fbc6c95f63cfcfe5f792ebdf2e4f69d683cb67c32aa84b8cbed21908c8186b138df892a593608c0f1d11f66aeb5333655bedfdee3f3bfe3ffbb7a39ad80f90090da976c43fbedd6a3155a2736266ec00b9f691463e2e9aa545703f3a10f466c53a8a1eb6d3d592cc7b4032f190c1ab34fc454586a1843d2f8555c8c5dff2c640d5197e17b9f80ccd855a3b289dd6992fedcd3a1e4787c3065a3e1e26d56487cb1fe03124d34ae8faea3ff643b6db630d94ca07c49f20e0f6276352c38699d6a0f07be0ea5821f3d396e936e650ef2ff852f602d350c405f875a210f09beec42baa06a1af8ae4ddc3dccd1c5307222e3aea24e2fbebf4405e8ca6380a6783178c88542c9068819c41211832996e4e1fc3fdb27a4a96485970973104054e496e176d5ed75a6483ccca8e49f8345a5baaa69b3a6a8ee992f03222cb3350867e81e3ef3d5ff9b1c3a70e0b2f07b62fb4e877e17794b51926f1ed99ce3ed4614d820df7ac7e84056229e1044912dc3d47bc74fb7a98791fef5edf49411c9d3688aefaead2b8647b0b666a36e5ef4fa0cd0c4dd242c757c985c9724e58bfdd2e3c4e9eedb9e60e524dd99afb38e6da5852814f5801e45cf7c1655d5b6e0049b5b76818512240cc279d3eb5464536816662ff5c3acc3b27f3630c9178c4bbd20085ae713d120acec70e535fcc84796bc50759e992ad1cecc7039d60083fcb41dd273369e20d402bd725159c5208f0acba4933b279746c97ce5b06de348051365e048bf7d1749030b725a0763c0c2f736da499d3cf7157d7e0d04a5fa93a436b106679a1991dc0e12c9322243c26af7f2abba4b8fe5c10d9d49c16c733b18c17d202ea65ef21c2bed00c6547ba3b07c0bbc19f58846d5aad8c6d6ba02c9a9ab87755b7b45136bf68f4e509625fd6dc257a44c4350d8ebb87d62cb638c1e583863637f254b8a9537e3750b93615122c8628864cfb4da43b6caa4ee0c2d99dfda397e8cc9685016faeb5e9eca87423c63faa4d3fb9df4f8a13419c4c825880c1e4675dc7551f26945a940fa2cb9edbf63b5bdfd7cea7327cf2813001480b8f675a17984d738107ad6feb524aa8223b2d6330445c1d2d62df2d5d70cc05ac89656f7c001135cdb8661ab90423d464d4e4b4393c09660794f74f41d3690adda4003a3206a017f3db7880b38dc9e8b5685df4a1f85a1c5c8c9a9d6b1210f3d41892db2c544d98b7dd84adbf31f7560a13049afea4c1b36b13dfda3427796e98b033b73db8dfe3f09c1df7849f07ad9363f8e0536bd54e5eeec46a43da43de09f48b672cf82536328e87bb4f115dc46cf94a79520e664ededa1f0bf20c080004c2a5205bee3e0edc6e5fdb59a2db38c8f45975e3c273c798e59847d6b8c253ab1a0a49b345896ed6e3f6e4e4b43bb0c9ce4eb51fe382490dada517a6d7e0626264e9b5646ebd64f76ba82bc7455ebee59806554cc6ed54fbe9b7e23bf998a9cdae24861ed32b829a60a3c76038a51ed135e3dba0b01fcf7d146093a72c305b5ca505f86b8f060f6e05e532c43ae5d12465982882f76d34c706f21299f42bd0f6a89850bd82d2f7fdf4008c5aecc4d07a0d19a732cf631a9cbc952c35d024ee5cb222fd012975a61c03e97f6f0c5e691c74aee84eec9147d33b755269b2f2b8b839fb75a823334ea154a4a8e22ee5331cdfba616cf402b96844cf41aaac0d0197cf562978f16f982dd6493a3f93fed43a3db89587d5ac52cd0744b25350a51c27db033c1b36e690dcd7e3884d70b531061ef1499c30d3ac88fc8710fa7ab6c481bc3216f4f1ede9544870a992a94780b79fd7cce1d6abc422d8df1d125dc98f294c1ecb35ac8a03d1edfc3ce4c534177dd6a6b429d7fb8023c3184c90eb303b5a3b5f04bace634a2e0a2b158c50271a208e04fc6c6e5ef41ba0fa80e656fb32b01df610c20610317fbd49a372ede8544526a6b6f981015e334cf0a4cc86da3ed037039069c73c675ee9970db37b626450b209c172a82c7abfc2dc5d33ef21a1ae43b1881dfc99ae3e2bff656483eb879688d1a6270a880e4249315bd68fddaa6055c9eb2f7e3ac647158bbfe6fc4dfe9678e9b5862cac651e5f555ffd0d09266326cbc5f399231beeb062e911a21acef85be08a3473dbbebc8a78872d5745f3321312859f2f27897e085cec3010893d45a65fb07378bbd37c0761defeea8d5abcef862b7daba907524e81f7be37fcfee536ceb77cfa8636c9450e53ca00d255184d35d71601e70255a63287af3bb4ef509113d8744abce6dc6243253adc033c7f71ced38773462192b57df32357bc77fd347f97ed2c1eab9506279433c6cdbaef837c7f1f3514709378fa157350ace9f78074885916de3671c22090b73912245e53f08308190e4c33e022217a77330029a526a6423ed00307a0b44425c4bd789c6e92d37aec40ac4627f0b18829c9e3031d2f49ab0ef560054c1cc2e50cc4a90bedcd5c8f3ead759d05d98f5875f18a0a1aceb8423043c5c06c0dc8c34fb8c6256890704114653c587f2de73d6600c1f764c073da472990de5deb0444f7b4d6130bb529d01ef64115ae72fcd45cebec0554bd6169c3a0ec7381c4053ad41e9e79290a8b113b3dd661831b9b041cc36edae3cf806a12f12ef67b7c1777e2462097c781970ec5840450c122546e61a864b4e0673769270c97f28b4e6574685c01247a0ecc8f139b828546e45075d0e0fa537d84ddbc5597478bb9fb798a04c857d281de63593006999ff449846833178d9e4af2bc8c87f261037ec347282ef54b3939c1ae0c57b53be078a66779ee0234d32b4e9f500138a161b3a3d74a46d8a458fd75dcbc3d7d74d561068531464b1bb555b84d229d5e42c051d6532ad156ae96453f2b1fdad8d8e5f71508f634c727230c8b92df4712dc9e3be1d78813480bd220acf79424fa28b244e4c35df42e44140c270441a4bc8f450c90ecd4152daaf5211a1f08c20174b642dc1cef620f02c8a61a336ff2761cc5259e2e42d41986e923e66c979b1b90e8ed1c563b8f1639a08940602c83a45289d53d2950b2396d969334afe14e83423cd72660e1c3ffc6cbdd5fa0099ef178b58713b50d8cc16248428aeedd36ec8ede98d98004e53ff3df962a26c77d145f4c7954bf479a605a1070fdf4565e7a351f8e08e9d99a97d70956db0ab01066775199af839b5d935af57ccfe691e87498dff919a18631d71b9c276ec83ed976d84b3fc35c480fda41e60e440818412782d279be42165d4a83a78600079650c1956351357a17da5dc296c6682d733599fddb25b29a29566e899818811e6bee53736931083eb735bff90166117777ff3f93cdf8bab6f1b6674a4e397a4821052e8c8bc92008fcb7c31145bd1db576bcfea953f5e68225e326be6c7d068735062b26b4164b925012555b6e3b7d06d34ec6c3f33194aa5a8412af22cb68c6b1902e54f8a5632e6d38d3baa9902fdf7066dde2dffc74c14234569e5d56a9722be01f80992274b0471bbca34fc63f820395331689b0f2a62f601e4626e72440830bf84fe04704d7c04f420315270822e48bf9e8025e51511ba9de675cc2bc77295e8a84f365eb6d84cd546d5450b7554069fddd7b04c0068a42961d62976065910bd0d94c387380f54084e380c2f122ca961b36fca3401f2fe6efa1261b769942cad06e7dafdd28e436f5120d2d01fa918a57a3cc76033f6db48245dad658a2382eb2b0c99e6b7ffc8b5bc650d6d7a58ed897704fb42457daa2bff240d02bf24f4af8336a5affa0c546934a093e6bf13d181f09b1ac1491b051766727be46b48ee3523de77d0ea4306d07612b8d5de284a0151a95484a183180d77e6b622ba5f80f3f5673396c196784b9e2da067bcbbf315ba2a04f0aa7aefe6c907df98993a05c109aa4730240e4837db0bd2445dd225d5c0127dcdb8ac340c8982c74772315dcda197fe66ae2c5dc480764a4ddb5419e11a1d87465ec3cd1df5a26c18b81bd9c9dd8ac72005a41127201aa960b5d5cc09d04efcd8f192e878acfe06207f574dd5d6ae73b88180689a75ef56b12452533e82bdc2c1eb52b423d52f5d15c1e4299f09ffe70158fb246d52ab2ad4e05a265883538524bcedff409ab42749a0dfba3983ce7beeb178b221515e5efc3bf857d19101080224d86e7e86cf54dae90e2d14866320aed82d00a47a700bdb293c82c88444500b982d885a524565052afb0e7e479d758b1323e0ff198c04d8fa5ac877e4131594646c7e060332ef1ddf9f0721c9af4254abf883bf92c3e77c8d2c71bb4b584c2eaeeb6eb8c2cb2409cc95542d73816713d8974938471ae0ab7e446f723fb56a22dd9327a60e848123681584a5bb3d19e536441ac690b72e8e5cf75460ddb60afd15a349832ab7da99d420379f7ab4d14af74e2953601c71bcb70602a6617af3a7339034d7a2417308dc223613eabd20f22ef5889c289f47046759bafd29ee4e1b9a8973a3bfa8231cd8cc7e60bab92915df3b7995b0b02453984d62920ad1304b29f7d465a2c63abce8f510465fcc5d1857840123dfcdadfc8dd45e52b6bc3bd41a20c683f6a39d21ed84a85a7e0dc7808890f9a45d5f54e7f555736a10ffdac615d0537306b37d94360479dec6016e49561805fd197bd30474ac41655a792d03ce851e19794240964986fa20410be937cf57768c0c95db844868338d06d26b920b4cc6f9ec76c1012768923de19830f53d02e64a9797e570bfc79fbb8be83f272da1f0b6acb678bcb7f1aeb25ea3f30adc3edd050866e4bd654665ad25b066458825f78f807c913f7ea621a73d1cedb70876656b5d58d7f1d08d6c1ae899dd93818247c4f4cfea1f10c90825d6ccf1054e24153cf00de6894cdaece853f47eb1e24a11f0e075998037af474d2fb7c8d18f67c5694fb466037b37a7232f4a0f39b95dd2b1d345c5526da5fecfa28be0d9fd2a0dbb77607cb9640d52f3bc0493ae7a7e045b5b536a2ecdcc39c2e5abef89bd9256b2fb32bb70277b0e7df0f3dc855a4a5e08bed5f71ba0f7c2d2631bf9a792bb43fab8ed1616758b2b920e93de6ad7963f87fa0ab72523392f46f8cf3839be129d3e2d1b82ecc17182162cc65f5f677b614255136b2b1f9fdd8785a908a2987fccd10cd0686f90445d02492fa56a223be9a57a93435f920660db2a1001daf030777dfe063772a598b9d3d12520d5ed0f5b85c3463c038c6e87df9b817dbbfd1245e3fea19d71358ac572523154629afa667f01910b440659c77bde281673eeec33b4b2ee2431596609fd1a171212710ab85fe4b58c39d3005495bba595441e64deddfcfe1bf852ad2cc01db75e183ba75e0412c8801d0fe6dc62bb33f78a3bd199b68c8d5215fae2a04b32524db31d1a23b617634295faa497611d83aceb87b058a6d6213dc9f924e23124a4fd7ad5d0b9bee43cebb7c6b70950d246f17896262324dd28d2c8578debb8ba016b6501da62cc330ffef61cf9bc92f079c030b33870c124fc4a9be2b14da2c624c2ae0e580998b823c634b592abd22cde2e850e0cd1f402451f72da2294690085788d835a314eff7bb698a265e464bf7fc5e0037ec3bc4cbcee2b1ea20083bceed145f2f3c0de05558def641bafa3828c88d71762b751918bc44fced5e91b84d6ba86e02bfa3bd3075fae0c8b5a7548dcc12ed96aaa9147e4bed12ae37d4fd75dbf72fa885eecbb619b10d21a24a4f3a6b52edd1d21d73c47cb118b3aaf20eebdd85c7e99f2b5a06e51b31e5c2a4035f6f9ae826d209accbb8cb80863a2e40272e0a693a03939c9b5b7f305d9d2f1dfd57bc1933c80eed8a575a38d31ec5778648e12db6372a189b07ae8ea6ce955310a30efcc4224a5859521d7a620571cd542878f18f398ef7072e42000388a023dbfadf33f10d22c26862b7f9310f4215b3a62b576adca707dc2cdb28ce1628fa30c9038edcf50be9cb7ff93786205fa228d0892c5796508bf73ee632712c98287f6279654ecd48f53ab0ad667b085d31f9ac0e2ef1768531bb2e91a19f4621c20e8b1ac10ff55bfe25bb528c1651fbd812711aa7e3beed4e82577851433ba87f60e39ae4a84025de455f0592900b974ad9759c2d90cc28d9953cd28f3fa0c0cc18dc5b2333902e92ae676af1c6e49201bbea5228df0c9a9fda9c0b07974ff7fb7b60f6135c57e7ef393dffab23f76e08c7d3d5c8d6c6c001257359b36f301a3b4fb64ff876766ec96e6ec914c762fd5b2d1c09aca10939ea245440ce5a1671ed668d691c6b238b44f30c64c05864827b23afd78529b5030fa1ad63a0623ff0282f180de29a62b506ca24040a69d3cc292b366e3a38ce5c63d1695b439de96cc154124df1a99c52892402ce58744ba599ffe2c1dd734401226b64f8365e25c47f3649084b948203166e3aad54dd81a9694c6c8c45e5bf9b58001707da09704071c87f79bbcf71ae341f910a54cb22927a4131eea0e2910fa9ddabf31117489e8c8abe1b633d7122210a7c1eb0bf5012e5e3d07ce81e1a4d4cf5565722f84331d6848ffbd1c3a869a7fec51bb0a74a0d1d90a3994a4d384bb5b2ab70a0c1b4b8c91f1239ea7d8271cc0ad48e96ce03a338b275e6b7f58b23d8cd03f7d87a2b512a2912ae73da98d533c086657119540af0d4669aae94249150b5d6eef32eb1f56137f3c446166c91940b5d53b67d963af611a9d7ec7a0f68ad3f00ac27aaf8f27e2d4059500b359d4d11bd0c7663246fb91eaccecf5e774c8c053f3b7adb898b528f122ade2966f6ea5900a30c3deda3b6fe9d68a9c922f8435327084dff06805924dee0c4eab2f5c4e0f2ee51038ff8c8ac4bf614820789c3969a1cbc89169ffe41356550cb9a06d3dbe53814f7a10018416375036e91dfa230793e9bdb17f0573bc13658862405820991037f91fc54a91f3cde8fc1299787e05b91ecd7c2c456a44aa09e240cc94b5f9723b86c10529f46b5ed4f4d5acea3c421f2689a603a14ae9137282e2f30fb854edf516ffb5f04669930018ed2fb056c527388e3c985ca8508961c5600b20f3eb4b02579f9afbb353d247b71b8175db0c32a55a10fd13b2ed1398d9c3aa141c24833fddbcffcbbd99e604c8bb4bd280ef5c3d8b91045c848cbe94b0781183fb921ca30bf2716abe37e9643d071436fc5fbe2f414ad5f8e4132fc7b84d50ab6cf7a1df3f57393ad7a5a6123011205e9a722c24a8a282aad00ea5690ef889f53db00db576a3bbf6c579b2a024bfee8668e9e8c386100d3e85ee6ef7824d79a4a48376298ed2458d728b1f7e785ff1cc7893ab9da0a35823542543c2d1c27b1032ef9086eb8e3d9b2e64dc546e8351ee933a8d96c6a207144aa882651778f7be651bcc9a21c40d548b06b9a453169380cc788f117ebafeacac28fa202999b4a5b1f0d6b5d4bd48465497b84fe622e7bd821f13f777c0295a61e4d61e77a1f2b59db2e03cd5df04a062d3da70f4cad3fde5309ef623372a8ecdaa3ada9ecf854169c55b56d83e3592d91998b26947f1822e42333f9d36b44fe36cffa30faf21a1b1c5c39800f6f55abb99c1369b32936db70e4f9d846aab06a52a07d562904e7a6cd262527bc805c0bf6040241b9b6744f746e829fac2e4ac3cffe4eb45f9f3dd948c12f3f91328e176d096d02e3f48db779b0ac74e843ee2c53fd14e7fa27437d7f5d19a957a81a9425f4be10815274f3e9463298d5bfe4408cb197f32b2c308b7644c2b0de62e14f3460bb413b8cf0633b898f1d041b40c9fbcfc8fb9a9e35b85ac019a480d070fdd9a9ebb1a0560c5858a267f37a48c020fda903d82ef06480029ad37305959ff6200d229aeee08b2a6b92b23c5e22b98c1b54beb1818a66c32f316eaa7ce661ab42a1b3533213c8e2719fb2cd224d2831cc5ee57e14d469df862e45fbda16c64857d2a09d7139f27e05a151443b10a8097155e78796fdb5f603f77f7586f5c29b73486cc843ce295a550c21a6ebc821ee76e05958f50b4877e5d670b64b7979c3d44c1fc0326396f5c264feb50a82ec4e1087ad6173513d644b03a0131c237da2be2b0d3aa096bf98124317efb937636617850094bf9dcec571129d094b08adb47f6e1e5bd68b9007168d7c7b794d9c96a596f36561a5c23e9e8b1cf50feaec3b9485b8244ccef8cd854afd96d9ada36775e5f6120441a2ade079500722cb8ebab6d2f12eb4a581e11dd01b10581bb71ae1db09a946feebccb73ce166037e486b91452e06257db3eb1ebb5f375d2dce7d173d95c91930e95a6d9aa16fe06212692f5b9ebdc74ae8093f7be756c6fc1b6fd509c04beb0ac5a2e2006600384060fbf37629108d333ce4e843f1e67b54d8f556d6d904670c4411d667271f910ab9db18f0bf9b1c08e9dae3f54dd6f8c4f289c33c8bcd48768746b1a21ba24676ead3cfc7195207622374a0ab14ead38c9bf8bb3582222010ca4894de113bb21dc7408241494796ed08784f82854d4ba17e31140edc2d6ed0624b9bcae0f5f75c49de14231e5edbf07dde8b10a16cd5c2ba61017c5dc4b697f33ff5f4db8a4050b4850fd6fef72717676a9938ec3f5f09daa993c46ee58543a0f80b3be9d478efce7a09f4e79f5eebc51dc158994f80d6395a3c177d67c0080801f4a0ec6b5186d6ee9a79997b1e8292393974b32c5087a49c196fa134110606d2df047c76e879b16e5fba02d48957cc988cbe91c1fc8a9f5d64fc527f8a65e4b6df0b2c70af150dfcf91a79a86bdbc6a6dd771e67541784a2500cb524457ba58490cfb3280fd0c572048b4071caa5078cf96726ba3c38841cc783373d7aae5913322322c8de7385f46aab1818fbeeca48cf734be3896d4ef5618397857ca4698c8f82ddd41a2052bfe98bf549fc44fe30d3b4736c9b886fb71be3bbd2242deedc344a6c25ecb8d0e8c847d0ed8f3838732cdd92bb955c8780f1063698f88d1444cfd4362d83687db07975db076083d392441e661a26e825d9acd1ef224ec075a9c517ed96886242d7c89d969847ff890f8511f5eaf2a2a412810d19f8b3d93a46a60a9a7f35a7d6fa10db8b7a35000bea66657848a5680a56ec4a0eebef9875b724273d0a70cee19ba4a5c121ea6bfd3e836d9c28ee976f0a8ac7649957875aa1b1706649c9262bde510ea50cdb1881554fca3b1c0abd6a5f999b5db164db28fc826bb9b615b627ce399c81deceaf9d6e62602f935e194e7e60ff66b25c832b19d2ffc251bdde3f23ba43ebc0fa7e29f958bf0d10dca0fd1104dd097126b41fba9dff6fa76c3c5e65ba9831dcc530280b40c55e12bd00d05592439664a866a57203fb6c9c79f67b57fb40ea1f67435f0c068b5dc7162d909b638649f2cc393cc212ed001d28a32df2be31f334b00f541e6948676f80014de35d1f7195f324c622273ee6eaf8b016e1e088cd2810ac146939aff64c2205ea00e921fe337cf15e8e9ba7ab1be9c5d4751bfaca2d666a31c39e2a12db37dcc7c2f4687f736665abbed565e4b9236dee92d7e8dcc0965facb8c64e36b7defb4a4c059875315693d8a5316388de0e80782001ba416c48c6b698c6851c281b21ad52523f1fd406986990d4b31a89d98ca9d3c89182bd6208e090640fc7352ddb0e5ee3d75b12938f7e33c5d665361072","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
