<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e962ed7f6d55ce969056b508a443cce611082429655675b43d24dca4fc8fc29605432c42d8d60b546e526f146b46e4d4b6e19a4d434ea5ec8fc8f1105521a10ba7559a07af6cb2e8ed04a90f4c7f52629b88e7be586d26cb67b56b6cf7042d466b14fa0561550639fe52831c61db4edcc56f303eaa16144a102b038e7776eb1de9456487877729f2d779b764e07886f28c4f8e85e5c9d306caab635bc4b1cee658aa40f1caa2be2fde038832c1868a286fa5390e090ac0dfbb29267f7b4a9b618b70c2c1503ca5c66168e3c49b36b490ddcb816ff6fc728085c50311826c2847f8c5bc067ba6d8894a8a7e8211092bb942ea324ead0e64a931666588debb6035cbd891377db7f2759cef745ccd9ebfbcfa079ce505627dfd7c55552603545fd102793e7499ef45b5e31203ce8db69f67ccf5001bbea9641fa48a31fa3b0e0bffa1d6a02f4622a7bb681e330687899be25653e5843ecf74ebd45f83f346c5d7c27306582a676dfda1b9f90480035f4cf770ec2bc39bcc24b9a4039a87abc982b0f8f104e1b6fdd6e31b007d4bd17d53a4889d0227160edf38ecb178d89c0d377f44871003750e3e649567dd01c41cec30ff754a3190ab49c506bd805f71ec3ec316f3ddc3e40684b23cad0127ac9d33503bb4c4157642a8a977aae70a9c798e49008e9588ede3e30b3729e4e90e9a089a5f5314e1ec1be82bbd7a7644741d2ab827927924fb5536997c6f8e3459236db19326f850188322c5c239c89c7658c444dd6baa80cf05d3ee7c1caef0292021bdba1cf0400b1257be8f29a5e6da9e873bb549d3cf109abc1fe3822cf2dddf534954eba143635b7555c6aff7ae6961d29f6ae8cd36261bf9c007b01aabf7c14cff89ee2ec3edef6d47a284a76d46c00922856402c894bd04e4c30dbd95911b71a678ba23056e6a5d8bcab1fa730193f78eb1b6cb2c238b4c2a759c0431868e89b5d87580aded232191d26be117dc6d202884bba85ef99aff960e6b926bb99a1ef43ca4a9f80089a3b4f75f4726467620e3fd1b89782eb2b94d50df2c4de0462bdfcccd5c968fcf3912235262f06c7e347f9036eb1eab51aa8ae451ff33976c72868261b1187208b959e35f3914d184cce679b0c2fb31808180b45832a47ec648009b21675b8520d97b3ff0ccb4d8a36b1e88ea4bb0a440adab7d326599882a45317c5848428ee50cb7181e2751467e4dfd7bc359619366fa61139c39eac53effc0e6a80ea5027aa78f18fc13a54272881ba8451c3d3aa0c6a1fdbe2eaec1051212fd1e0d0c0099cdc04fbe333aaaea90adabeb56fbd6e5935c1e28c0ae89183acf81cef71502c984ebebcc7a56784fe238c5c5e40a270a3e8f131ba7d2a746b45fe7747c35223f810fe440b1a6976de842ed464d007dd7deea347f060e51474508bd2d05a7f8c5c2d26ae478cc3b62388138784331d1f9e4bfdec508132a12e680e43537a78cbd2bb0f27128f49b3ddb6d68ca8d204ea142c1a6f8f26f5b1dab29d257de7cdf39e449416be527e8f18eb231f83f6988b14fa6280170f698000e0b06ba2c527e3f0f1a3f96d0bca58dafbfd2c9d21df0510a0125c694012081140b36366ddabf457544796d1714028c4e263524d7a87cdf3ec28147a3c6fb87b1b7a7147e2dda6094f38fa1e2c970136e73ef4acb671678da38c691b2e0c6710d3014ea9ef6699689a6bf2673901650e2c3fb896ab3f30180f7d3cae4999a6d1698dd2113c9c8e796da76e8ad8f5c950a20778e98ac149252451b238b5180de8408293ff7bb1b7e274e5a3e969ffb596ee1620bd6ff3737e7d7c64ee96d9c876732c43e540428ca8711ca842809c5f450b652891f63da68a7a39536214f415aeb9af08b859ec5efea4f30858c9750049602f8918d804207e4d208fc762ace9b38114d4d45ba1ab9c0b66182c152cc2cd3b46cc611d238589715a057af8ff1ce543645fffe5a6b53c8aac3b49bf1080df92b7754cef20343658b67caff273b304f9d11001a6b35797d904e4110eceda0fb1836fed2febf1193c6791db738012974d3a954af3ac09ed89896f2b9756052c9e4c3ed9edf4afa7b8bdfc647fbb8f15840be83a29e25f6b75212f43eb0aeb2f53f5e6e6f8e52415c123f0356a74e6490fd0c7f32fc735bc5af4d19ddae824137a90f9b7b88b8050d9f919616db89bd631591db30143026d6bda85ce68289b1c6171b97340e8bf87790f42b4e0657620fb2eecdc5a430939cadf2162e74c6e2e297c88dfbd553ce7833fe08132426ba420f56076645cd07003f0f6675412fa1b098d847d1e759c1bdd77f0276737b41fe19afcb746935a7d92324f3114c312b0add20aa670494129512be3da52a63fbd4a69e2d99b81df6ab050fda4cc6a64ca991dc0092c7663ff0a892c5e93898feb701ff167879fac5b92ccc5ab610fbca810bca1f9e6e8ef868e5ed7bbedb501abcc144fa8a99a44fd4cb40627a4fdb2d5f1f9aedb238bfa292742e79af0f14fb17136f33925a62a695f5222ddfcb47186da08c5af9cb3b8a5022f080b6678c4b8f6e3bb3b1c77cd3a65065e5d8c3b8fef1c475e856f83cf1901975309087b6935bc00e19014f6f7f01bf426307c49fa7dd81058ed46824170dfd0a1276e0e63bb13a7c48d693bac801fe379fa1f614a1825f6937d04019e51b2b3c83824c8f356bbdd20abedbdebb4f7cdb9cbf2e283a156e4d6a287948079b834d202536d5a32f037bbc06ca592a0b2df31efe7703629d2e34fe12be7eabed16d5a230500334f7b12968ab5b7f953db864ec9725965539a1fe7fd5a578b5de10dec617fa8271bb09182f9f707c66c875496d965a2de27ec1adf1d0acd40d80ded961ecfce5cbbc37f9623639552aeb5e551ca38efed6dcf54c2bb2fdea1b21215d85239973dc9e81eddc7d37ee7d936a7d0e2b0de9f2258640ec85f2929dc8cde4263120108e0b315433626c6850e1de71e6a67342c256ac9dcb3f335eb7495caebaf358e9806e0d09624ec1522ff477dc30609e712ad556a291347e05b913bd5e53134c5afbe120a563d7d2c6b893becf44bab75b74133be6d663a2f626539a10d6be80d2ff7df9439481100787b6f516833bafddc9822e28a11c055dc6c9ec710471b1cb9e87b170ff2c886f1c1919ce3b8bdb80f75afb0b1e043aa01b04576271408a3faf8cf1a81476d93ad5f4f40cd19e36e7f0d03735033100cba3fe8277bf57a9ac70cba8598821ea2ccbf4ccc888ba32b71a0a3ac5e1a20e13b9a3f399bd1f50859821b173c332530f5dda19d91a2821eef88db33c4e3455e94429d1862c4d166aa557d2d94f983023fa006845a24264de9d87b2f6723e8bd452c704c3cfee04ef1d68cd033413e80f4f8ff424cc9ce5677b57fd0ec7ce24679805cb7e9e507cc3c68bc48b0ea708ac953c4dc2ecdbb09cc8785770d35168cfe9e9c01bb593723028bb2c6733a14fc6462713e0ee00cc390a84c79c941903fa2a1f9dc105e7243b30e79e215d7518d723fc7bbf4682bb97d47f9bc83b5f79b02c5818de7a0ccebc0ae5defece93572703ec6c009eb5a8eb74002a364ea3d5b57b0d24cba1cced0d1845a7368f65bc625b63c4cd97a14476b52c4c5e60992f61036acd79a452a6057c5c893be20ae849e493a1da17d8288cec6c10cb07f8d89f34de7dcc54f9cc6e917b7f5fcffb6f0da4501cecdcfc3e3fbeb0a0a75b2a22a550a98ef19cda6cc32c584d300042388e4aee30ed3b18ac2ccac0713f0fa8f144866c461872cf83f22a285ae03e2eef532b779b829adc4a78340ad1ea5791a65706a8ebfbd35ff46efed953cdc92e1cfba1868358638970b301cdf9eb136d48690ffa89642ed3b86fc1c97a668714a40645d1cf058491a6ab4d182642cbede3f982d59e12996e9c74f5816fbc5f021cb82ccb25c1b9aa2f34db5bef24e4cb6fcbaab39875cee0b131588dad3c470af2b294d53341d075b8682836e169a44d47df6cf1845f817b3a2f5e66b205e9faf654e9e748a3c36e0b241d9b5c95e643efe9f55f6e50adbe07d3639c8c625ab268de3b2ca6ad8321f3fa3d46873069e6507784249a44fc4d7e4de835575ba2a04f2bdaff4f5c11bade0dd4709ae4f822b9baea389d0e15d3d15f34cb5e5490bc4a08885edc570d95d80073027772774d673cb6abce7c7e6a56239bd429abdc045d1e08a7f24bfb206797b031b5d55effa19585f0cc6310015aa8d7705a66c2deeaf5fb08c32d795649c2d9da95500f568cb8159ae7f246dc05384fe9071b78b50fcca14581eb7eaaf4d4d7d1f6b47a323b2535bc296cf212f37233d952a7e6d4bc6161c60f96d674ec76c15c0278936d0c8dbfab14e35570aec4bc6c790a9db7d1a46d39864b1ce4f8406dba9c17deeaf1a60ebe6801cbd70c89f12e40cb914e863e7ae7c6cd179fb46bb43cc2dba567fd9493abfa0c66a9db07b2e7b4a5f813c356cccf0aa81ad642863b9a6a73204c992790d50ab09bf67ec5659ddfe8b42d802403c0b7cae65ca790fdec10dd3195f95393c9204565aa4a8169423b5a2c36e968b0ee702482b48d0da614a08abc681b01c777293fe46b0470a0ebfa07a302e7804e203e7a694bf3e658cd1e64db8e9d75d8a3df1748b965d3d908a70318b2b9f7c3eaaad8c03025e6120afc90902f2614ad31bed42810adebe2bceab211246fcf1ef013dd76d9d0fc35b6b8f1a2acb7b23cb1a6c0c90abba6c23552d96fb5aa7bbc2cae7dc9f70d7022209b0c7f5e9efff7484bad0f75dd212477edc9b824d206f7d4f04a86f0040f8fa2f29b0970dd0e783668a200934f8f1cb7930c328716737925e03ddb309eb9eca45223320ea08ebf1d0e0c4c4fa02ba846d22ea4877ac4660f1e98cc7f4197dd25b49fbf720d6c42f0970f5f82aedf4502cd0dbfa5f7707fbd21cb4fbf9daf9759b5a88c6e4ed39ba439b77fa86820987ac642886b4d7a138abc672fefab28d2811d1ee7d8231b37bd740bbbd4a04401c2233a74e27dd09ba8f503ed2f4a07b2d5553a48f3e6231a5c4b3a683b77010faaaebc030810aabce314cd6564e4b2de335bfaab084045f1e42cb7a5a17ff87c88db70c6efbb2aacc442ed9a5cef308a8791e44a39483ad2c690ca79f27a0fb611ce8723a53237607c07f82ea19911b93045432aaaf9f6618349a9197523ee83ea5fcc5739bc13b4183f8bdaea4d57d0d27eeddf29a34eb92557f9608537f5abee3be0a914aadd358c73a252d3d6a8c7e559c3e6c471eeea5a2b8b2679edfd6a34ad975e62c83bffed2f60596912d6c29eeb7678b38622a0eeceb11590bee7e46643cc96ba1179363dbaad182eb77044448c29b0fa3a8163b8cc13fd87b4dc79a10dac9e7c1119810252ffdecb80f6e9050361b369996214e3ad6398aeedbcb645813ce41070cfb83639928c409e81edd0c400ba3a7371b46896b037b057e525143eb534558bf2a9a31e4c1ea9b31e5e0006110d990d0caee3a3c17b8bd20221460df02422609023edb04612fb8fc0340a99d48e6d3aca8277d77ff6ce0de18329d0755bb152cd357a299d0068ff457130968365b8b13b9933c3adf3daf1d14c224b9d5e654929af606e14c3fc024385634698a6c3cb0a6aff2c25c5a39ece801138df9b86c41b1be7f3971176fc09bb64b0e13fa4d183a4b2429bbf772a0b496a4de7ed554af57f7dde7e1936277ba13d7c44676412eb38d8247ca38f3b2c6a4b7f1c7892ea3f8cb0476e7af59c75823ffbfd8a0a7ddfdf180e3ea9c8bbe2a7d46412c463108be9a604b6ef42c6209a34932fb012b6ab7536abe51ed705e8fa2e127af9dce079f13e086e84035f8105374dc1e821ca23212a0b0d61ce8b01567237598d2c1c30f4ab76da240968ff68aa766bed5e09b2f5ba41a64e04c4aeee0a19a00d3e3e2ca4b264599fed9b1d750897dc2cc6da391401be8fedff7078bd0b6b5f1784a94fbd27153f8b34d67dd251a554b92e1196de9f5382889eaf34f9705c4a729341b7487ae6bc1e89cd34923f4283df378fecfd21393f806b3e04f15c9cf17fcad62c99f07fe82ffc69a43fb6df8a9fa2ab10b918584d5a4b131b384480d04b58d7bbb7ae91811b41ad176483e0d231fb687c5fbe29e6bd78960e2baa62e4b9aea08dc05ca3cae779cc19e0e322eb83f4661ae952442336e950dda88740134f51fcd7a8002725c7d0cb416709fed61f3be7dd9be2a6c74f412fc07d7085aa9e33138860b07ffda488b1270d0b8fc666b8fa002ef36e69e2b5a5190441ba11375819b20cf481378848a1a683bab8dceca25f9890b4e29eaf8947f02f2654eaf4d0b1e0bc0a05f32a739b7a0c7112f0e1e50b2c0a13342145f2f58a6b4b8031060b172b0cbfbb027ce731f912b806b153abf4453663d3ecf2fffec556a0a71f3547c88cbb459256a729cc0ea5e9cb654d85d377158c06349d6a567446544777c2ff3bf8fadbef413e1a563a0908a0326432deb103514dd115ec47a22acdeb86b453da92e9921e0827e86197ea820c82d77bbf5d838c42d7362d46bedf2cc9a09270e5e8e4ca55a832093a99e282ed1529b0d79f19a16bb8f78d777d745b71776e660cb967ad00eab908cf78d80bc435bcc03533fd29835ebdbe11a4c27a2ed60024c5cfa6cde92936193ca236e9c4ad05627294e7852193a38874a38e9dc49ba39a854998706768b649564ed9f5126f0f1c9376cae3219495ae431110b0b484c8e0bc5dc4bb94a60168b1c6649f63249f4fb0053f0108b00f6e9ed7ba8dd3c122e9db20a33c3dbf80b2fadea9e6667e7e2d6568ff467cba6f8373c171ec1f6a3764c9115e4121712dbc83c0be5d49ac323b91e9182ee2ae20431ee16d502a12b17a89f85c70a91cdba75d2fde58515bf1c7b9bc071bb8b43d0da8e1665f1df60f7ae0908944fe24643305b7f1e85f34e01552a0394f0a16fd805defa06d27bc8d9a6040eff67ac0960b8a19098b398f5fc302a538164f13aba940ffe509bb31e55f587753729331588cf7beb8b5b3d7ff16e576ba82401b048fede5793c3e0ab2ff7e95b192c3f9d175649c759f12c2fb01742ad723b3070e6bc663211e7fbb2f3d3642233a7c68434e212256d2bb068ded15a70ffe6870ac86b51d288abfdadc9622ac760875e6c85d520f15fc9ac9d0896131200cd2aee06bc25ffedb9a40303a0bb582ab86cedd83bb113f65d83e1c5b9b11b9f8faaded449ddd46530d726f9319be26f784cce7f01986764952a38851039e681b1548d820b241cc6a3d218bcde44c94f51891617a85cb4f9a9ac6b35d3b2a619c3462fd8989f38235d294407ae28eb075d14e04f644d8677ad9b64d730473249c09bec0176f7a93ad8f6207796c1adc426c4cb62bcd2be9ed315609487b6ab4edd87c088049021a290ae97900925e06f52cd53e793a46dfc623768539fe8418010abd40ebfc78d3b12f1696595d46218c938f0969d026da77569855a5727144ba0974b49e5b285c924aa34310c0d79b308de56bdb86706a5395c34e72c8a3a7a812c55d2a7639c2bf78e64daeb2728d8c90834b20982e2c32648b918abc68a4b7419808bb8e063d55c03793b96f562eca80dd94d0423287889704615f9b29428eff619add7e7d7277ec53fc348e828644ffb81e66cc252756c46e0443bee7d2408bf0e6f6a924f5f6e7e774dbc58a997b7e159a64bc8af9cdb722caeb49fc0367fab4f6364b8782c291a6b7b388125bfce11a52fa67a4bf6102a0eb10f9048d950a9e505ebf1f871391e56a0db493bf327fdc6eb73151c4d214e2f6d7fc3c14c592658229fcc387bf9e47d5e9e5f5cc8751757b9f5c58595b51f5c957ba2a6085882a339f4b577c1061429fafc4b881216f443d669e789ce60ca4cf1d4e34a46f502e85644f6b89a6d573f4df7ab7367675a8cc098df72e547a9ecea3c8be05520e93d6690987f8031c67c581601112892345df22563c53057a8bea1eae0ff5aed2c4dd7bd5f0cba94bc4769dc46c6583ba727d94aa0df4cc09af494fa1e79f176dfe130675c161bceb3d59979af8614f16ed81f1f16b99c499466bd28094d03b5fefd9b0e40058c2ab775d840e24d5e1a9d5bd014040b97f2f1462c3f2f0b10dba4487a86ceea7cf2d3ec09fc0bcaea62b21d92d6a97d6206b1354f2e1799e7d39d01ef1192641846c2c8d10f3d1cb0b1bac317f2587b0a8dbe82268bae2d8b961897d4db560d517a1d2bb732d5abd51e1ee12a8916fe92ea42e3784beb728e38095d3ff98eca20f0d4415a7284a4eb82880a886b4c49e2161e6fa03756bd8aa69ed7003a7da00e383f3c23b457ffbc9a066cb1f9b25446d48d10d28d90b95eecdb062631d1a98a15f1554726d9150f4a9965cf379f0ed626f094fa1b10f824124629b8f320ff20830573473172b50b4e796639b0444d0af8c0acd933780e653dd32efa8b4f1f7a52353a8bbbbdc4e89a9fd3b20b1196e709cb00a7eaa78f738fd9b6b8ecc156482020321e4fa288f76f3eb2947d7d457880d91d6d869b98ab75b523266bfab19067a3a41c3b1414fc53772f470f9719ccfbb1620dff69b8a00d3694fc17552bfdb75e9a8424c78e1cd61dff40f9b54e5c095246b53c56a2e38dbf75ef19c3de7947420aa4b225423f3003ba6a600b18717e6805042ba98819a168c3665e88aab6575169d3f9d31449e9cce2781a1857ff99e0290c3d1e9a4f54cd6038b94bf8238f08b71a88cf8f9733ba00b968eac337394deec663838cf4ccac02da99b52af39ccf0732cee50f3bdc937ddda08a24707ea5a505ae8f8b6afb939a2ee8d79792c6e499ccc6fbcd627f1a58882bf0d548e1b918e11e9713e093857f7ff9bfed1f118421d66db57f7454fa84ed8b7580259728165c87634e4c5e7de76bc5915b96b27e695c57c3928dc697d908bf03b1da74c44955223a043ffe75ca9c87767e92fb1a951facb7c77f4c188491ee7e3e03d9f87f159dac5a3b3d0045f77bb4f2fb6750f14182b16422182a4c98cfd2aa6e2362e4019ceaa90521ec5b1cdebf59ae13f2db105b14881d8cfae16d5868365e9b5fd98cca59e01e49bf1f0845c31540b29000f9b61e2a08d5b5d01c0ba48373c81b4362c5ad55085da376bbb88634a153b2e392668b336a30a9031a4336d25b9c5b5102035ae134aaae012d97fcea938f300607c67cb04e985bf316c7649980ea2b50c6d107a3b6f7915e0f12143885881d1acd0ba583bf3edd5fd588a332e0d0f1397edfaa12d2b7c9efd1cf71b71404ddf44a8d1db96c3b54eaab4ab65bcedd6e9c31df478edd8398b3df20e22073cafae43d64b33c75c5a5f6d68a238159d8394e9a56ebac10e03818ba112ecd7472fff09e45932d11ab11c2c9ef12f037c44386ca60b60955dd468fa75cd5c6f3b2bccce5e9dcf8c628d14dde40d9223848c98cfaac5be3e020bcb88c6b3d4b02ec56f79f5b680d750e9b3e5e5e318b6a29e74b83a069ec423f685505ddcc07b4bcb3dc4cadc17a6767821da07781178a2510ed175dcd7c500801eb361f0cd126395dc4a77daec1b942bfbe2862677157e4c2363fa9d202224479270eebd9823feccd6da5e887972cd57601cbb5f2f1e50362b57f891babe4ec5c400ce94d652ddb1aa8d17f24a2831be1db3d43255e56936b7885a5ceade6bbd6e5d1139bc5bc0c88531192d254733f8a0361662ac46c82d73deb947bf734f29d0cd65958114e4c1611bf0c10f361fb41afca351b42ae2da608e54f11e096c2b8123a945f84dfac999d349e4628a86d7b1a9d5ce4223d2e21a748cc9e7b1a6e0b1e7f8c7188196c26405a300291505652092820aea3bcf66e5857ac7d0ab8a40d80738355c04c90b24d4b66dfa00122644402b9f114fe225cce30123f563ae721df724fddb3358a8a91093d220c30593e449df3ca42b6bf97738e41a47f14e915a004388f1996963b4ead22a7bb60ff67b4c52bce2f071edebf08689b19d2d078187cff6db32f524bf9a9efd83f868ad577272b7f50f6dda26229bb48d750c565b29a3777d09d50c9dea436a1cc44478450d53bde741293b3aa667e61bf396729320a549dba6692d2734df2154c20aa39870d2069fdcd04fe3c16aa3528ab502b9714b2856492fd58b5543c9914237c80d99b55f6e0674ce07b9a6b65116934d73ea88499d5ab17f2bdfefbe2f4e1c1e634852ee95b90ae17359e7afbf601193ce2f41f5c557d41d9c6d289176694ffde27fd69cac7cdfee38de1d9a81897c83d6ce94386b4675da03e89c496ae4f82d311b7b57033b45465b21715523415f2f4579fe80f3301914def52ee936bce47eef28a165899629b4ebdc93e6ec9572d290de3047b2a2f65852ef4e4b739661957e12127f24a6a618b15772afed49604c8e95c69a6742594d65127fef65f7f71f03d0296808fb69752010732a6ab0042d51c301beca7a4b0c6e09a4c25d0bfbfe58aebcd5b39be6f5c28985819415606deb3361c0f6b5106cd2fc844887bba28c406fd6f53d0b885794ab44bdf0f1eb703236a99577f244ddb97a52ba456d14bcf4c2240450efe45cbaf961faa505025f9773fedb5ea323302c26a218d81853f0984f7c3398e56f1390bea2ffdae9eec966e22a875948fd4226342c576f860a25af2bcd40147cea6f6f0254cec6f19acb93a96cd33b575d3b03b552b9c885a010e2529b8115b530ebdc4ec314b1b4713827f1550f97298029880018a8291119d54387d2e3d9d525d27ea4dc29f2c677396ffee4196ed34731c4c7fabf40e7e04e43c2b628fef3d0a47d044fd65277bfec9fdfff4306380f5bfbafa6a67511f7de200600e650c7fc03b9bd2c04fc0f72c4fce212d9a175a0a67b16d7fb346b01dd75f4b5c27e060b71484c9938d081af60e9dde36cfade94c95affb964bb675b7c2e4605887addfe056e8e8dc7ba8427d12e2c856c5715b682d1a3d7083cc5e6d5420bdb5d31becf725eeb1c4072f695ad78b961e6abc7d19dfe597577a454926192dd8dc48abfdf5d47e7183b4c76b1447b532e97cf15289a200a337ff653bf65fa72024eeca5711e5443b5a3c68e362948290222cd51f97342d1755bbb49aab696e5414d47a0de1524441c55a8ecf8731f57a9e09571194b97b940a9db703e1d50ad477893115af809a68d1a9c461dc0c850cd182fed938c8ba7e0f3c2c0062468aa534a87c5352d50b7d0211b77b502d2b8e868a2a4d8cc2c5d8abc8560150025340bf3237fcb9104bc318e2fcbf5723dea6043f81f54786e814bf5d6d7f37a04ce7bf9ab1459954cf0060a73b81b2777542a645ac56ce689f234f4b1a6c9f8586ba6cb9357e29a0a1342e0cbf78a6927ba56e7b9b6c302831b41ff755053a6c585e2af5d108b601b041ef2b6b2f292e977665a986c56011ba45e0febb7656a9f26a260bc779b0846c8f7b277227ba58708a50443291ae60d47eef95828c9826b5c3a9713cdbd13408f9afb56f4982410087aa06055b3fc209e19c74155c69a01df8c11faf9b9ee98cc8403104d52a8449b6549ab8b0dbb47d21b89906929386e47ee9f380d2fc4b4445194ffb383dd7fd8b8cc5334a5c354d24568299956ccbde32a3fb2309c989277504eb2f7bf28ee0c2bbcc4440b348b9b60ef3a9ee30b1c60f81e570b4e69dc81e3e5b3acc8010b909731246666ef1dc63a1a89914f6c14004bd4f809cc347546f8e5d3bd3e3da06c73d9bd91947bf7bca681e40f2cf401fec497acef8ca963b166da6957286d36f5e5451ac275a3616cd400aa57c0779589347b0994076c3c79e0f18945f7a838c8dae78380a65b042fd536fcf07de8cf41ffcaf16a1eb9102b83c187afff60e90a9679df24a0ac0df24035e3d49bd176d7cd25245a14319a27c23a1b98fd0393cbe2c54c3e5d34a1ef23fc5edda113a97e14c8e1fdf0ab7b18147f214598d95ec7e6eac1672e2f73fb06c329fb7fdd51397bd4df4be3b660a9491eefbea095a9c6e521a81d33d6e0f2a5febfcd2cb3298c54dfa7444111694493850cbe89c541dc8189f7678736240df069f3f317014014125b3f5c334bb7ce5a51569736dcd4780d6922f24ac434338d8b1c9ba4318ef464e91b59dc1b6dca9b26c9a088a5be35433f6fff22cca14aba000e8b232339bff9d19b183495fbacf29cfdc4fd86e80e0bd70c211499944d0f337e57e69376284134bf652e393325c6db37bb2dc732269ea0d9c54ae83b022aa7905fb4dfa903a52798043e9810f5b487361469a16760d6c6947623bfe421a2a2f334460ed68513bf29ee5f6d8d842af7989cb83bc17f93f09427b0f11c68136b84b20f371dd125f032835af8ea856c0e3c740e59ed93ad4af13c282cf699c74034162c987bd34c60c1ffe9d2f85c1fe5202c415fe7b3a24e32d0b31845a170a1e8a14852b36e30b4b6e3eae36af624070928cfb649041fc49c2a484e6f946e4e7f84efa12920c0481b11265e0593b803614a8a9c8c8dea25e2d87f113699ed75a991d3b1981651486e7b114e896e6ee63466b9a00a69a2b9b810d29bc7f05b5f58946bda6134679753d4520308bff33e280e02d15fea0bc645098c3ab1f81c480de9ab8518f991b405d74df9816598f42e13f29c11a87abed70f7cd1ca39744ac809961a86cc91e84e4bacaba65256fe427fb059b6a4066ef6538fbb9caa4c601694f593cbf8659de694d342160e6cd3d6d1b50b3b0b6ef87ab423628d06dc762589a050ccf35f35ae1010ce29af2fadc81c88cda7e28fa69e44583b3c91f779ada87d1f2148ad98802132fc507c293d0fb78c75d3368b5ff0478a5b22569bc946d0c55323eb3ba8f100bd754b3fa29fcfbb2b2b6872cc04761224d92ada11d58af4fcbc254377966a63fafbad6ba2e873d61616ea84ad7f8d9fe3ceacbffe009c789f082a6b3ff892af4874e86c22320cd95713a588966f89a01e5ccf2dc2742d32c40e524b43ef2a6be273d538ce2680524e0ff41b8dcedab10d40649b741fde30e98445b14cf9e7a9e3840d85a42768883d0d08b468b998588f3bc1ffc3a55009b4555066aa640891d722b4da7d70089f21b852f8e31516e687c24e6e1bf4500d946babee19e63fed4693fc1b3bfaf180f6a7a9e25bd1f4123b175e5627c06c8913df305255c21df0eb9f4a72d39cfd2a720e888d9b9923a4b466fce793f37f63b57fa7528013e37b498a41ebbc1bacd58a7e6d1e46998d9d7f1adf06b914dcf4b7bdb3b32cadf001ebaa82c6d18c1d53040852a0f3aba2797b56ed32eebd6afbd225df39e2d9f7bf6fc92ea54935078a1a6ba1a5097f36d6a4ed4ac0325bb427706cd94f2c89e73f9ff4453e30b75b611c4c18445cb31445546c5499302fc30f9aad3969901fa6d9ec57c83880f8ed99812e5b02de6b25dce2e758d82022fd40e6b212338ec32a64fa4f4251af951d55047385de27050b71050f23053a3d5940e48cc629ce6982dc41afec40d58854639e1facfcd9851300ae6220322731a6ab4bbc2d840fe1d3e31d25a12546124f41a3af30177475ae161c29fcd286fd23279804fe53a2d71c5f02170c7b9b0d144212f1c294e32c2a140355cb03ed647085608b34c795d43a09e08f5d282a469a7966e84c1607aeaa6f676fee5a2b0949ea7736575822682ad99fe8f0553ce4a94c082ce6ed09a49c1af53703eded87a685267b7f0fad1b190318037ef3cdcac34a33e0fccfe858a8448b26b721aaeb7918a74005ffc17a13d00efa07b54401dd731ea1c03cbf92433e189e00651446fe3f324e6f9c48f2da5f0122b6c6b0bf4fb8c4f59f71633cc7e85dbc0edf730960dfd94f149da6e08e56feb9b23382abd44669a0e96c73ef6be8efd6912598e4d4ab66bc8f113f515d35053c7ba920db49451a1c4d7828fabae90e30488ec9f507ecf410e752ac8b9b802d40d8aebf03410c9075b2f246785d6a7233eeeb3b61b1f4ac8e1c880fbaec8edb6d2a1ccea611e03838474fe4f92878b109ed349bdd771e731cad6befcc81e7219f1c814bef3d0f47e4ad734ac3a85edb71e040b1a16ed0db8b2c9b7f8ed2c818ccec3eec80e462520f6411cfa112cdd367719f2629b18d9172d34aeeaa8e6b884d19afc8cf1839571f28de67027e1a0cbaae3a20ac7238d3f7939dde74b4c8c52172c698a34bddc04989a7bd2bc61630963f9a1f096a67c87eafea7f4a087d49c47595980b29727378e61dd8004d34ab00bee5c0f675e92f5252c04debd02defa94fbf0afa7db4543a1b777433e1e53162b2a34668f52fdd0fde3537ae73bba1787e4d824e2ccbfcd71bf91bafabcd128a8dc393f6a29bcfb907236d77467172642258fd6020dc7f5472495e9b3355d6aca544c68f7233335d11281544d9c6b207ba68f005ed783948723fc3aa934af8b9a8ccb763ddc33c55bca24ba6b9a71d71c86ea1a780dfc5ce39d61099bfe6e1522728b43946f019946138dadaa5183c49e0f758c6cd4a1e13ecf75ac2a3b1222a4c73938f496f7281187f91e678d918cde4965532e08a122d03b796f9146f16bc830984fefd7ce1bf9fd56104db14479fb5ec94910d5fcf4bed598ecbffd930f3cfa448b9dc1bfefe35d2c5409c31e02fd403f16413bcbab5b726993ecbb9e93435e8740224dc4d859745396e984b6366cb51f06ff82363cc786ce933d8612af4b9375d2c8bdeec1280a6b5f9f45eabc3ac0b0fb2f7661f40aae3ad6a003ca529eac193b1162af9fd2b7c2eecb7642565169c2898d9095c30c6965fb19297cdcccaf2b0e68fa8255fd5b0f996969b2f49bea1b47ccd9d1e92de5ec3f7f2de872f2d4f8b7d4260f918391273d76811960938166e4c2614366fec51bb987bb28f92731f229470ccabdbe58dfb70bd4d597aa95b4efaef326d3ea56fc9815f94179e15424dfc1d2ca17e8824129823a358ee8900b285345fb5cbdb72dc1ee110a057b4f30cef1306ea89d203fee4bd9101b43205cbb486f83e9206b3785a75374cb911e0cefdfb797fb74b0584f2c6f9c5d7081e65a78a4555677e144a6e93636fd97ced79015d01bfdbc3ab7deb5dbcee51518a9bdc31e123b8bf4177966367a3586409c162daf69171303bbb0bbf16ea02e79440655e1e62f753a82814e6ad2c7aa25ae65d3c45cb728784a06e353eb4106f21ad9522fa0b169a363137f1b8fc6c2f1b784ad71c08edcbd33dc506c67281013d412dc4c88a62fc2d11f82b2ea4701d1eff19ce9b6f9177aef09251a32b2e21e691b47794a89d8bba3a3252c09751eee7e9f59d81c23ba46fe2d7068395c30cc09c41d1f293b7324b8083ab8e94bcdbbcf98774e93c7492d0d5502798517bae31140f1b8e6473f5f85b9c66219d2cf4e289969c66caac3859ca9af451db48bbf432236b100e9f80dea935e452168718380216a45c09ba817c7d7e0c868f703ef4048b472ffd02215adf2c939f99255c96054907f3b1ba5dc688529364a0f0cc6318fa2f8bb40a5bdc813e3075a16524f50c05f562124aa827e01e4e192ec173cf83ae1fde3b1c3656b0be3ace364f22605ae43cadcbf2e9a6a413af6f6c786d2f491d3101054c245c450544837d7479347f2c4443031f6d25d13f216a0fc03ca4d9f0e40cd9fcb1f960be271d2a421bdfed20e81a324e88817016568e2196c5542f21c5388b92b79ba3d175f2dd53777c8f51a6dd21925c3085123d9b7d6b8be568cb1d9c30c032e1059c0a939278b7ecd762e1beb4fb7fbf9f3925f2071f1b9449c22f5f00e2fd689d5ccad8269d5249c8d1ebca7e9372d5d34e84a2e2aa84fe6c7388f5a2d367e0efc1b9d3825b063e36ba5d1496a5640a52e5058156ae22f235482194f31aa3fa9f025e4d7509ef3f43ff09aba0b74405dee18bb7fde8534ebfdfec6facdf4aadededda71c4a42f352e33bc7768829a0929db51ce480015214fa9ac1c9c04ceae1feb9e8744f07ef1ccff0ee708dbd8531f675f07b33d91b417cdcc6b64fbb89514d9fb5cf68b6379f99db09a7f12a664d1ae34ac457a50b1126d2f740ceeea3651e00304c083d95921c016ab9adfef1f6fdc048edc36b25212db27ffa0b95fab8885264f867600b4253758241deee84c961d3cd5ec0daed1ec4efd59976eb8bf01e798ab1adf7907c655435ff8e6e6b3f2132aab201c2691c60c312dc304f361909b32ca1440fe63ebdc5a8ba242445189053cfbead0e8f86e2fee1f7383353533ece870d65436dcc2fa9e80ae5226626e47c274ea5786dcdf1a74a84a300872d09c97ea0a458f654ccd154a623bedc7443760a739f662c763d9eeec98623c7ee1799f2c14f8796e69e3ec202f653c9651c344e7aeb09b07e4806b6f4613c4e1b5749e3fd7484ab4fdad7b5df4f5ab922b73826832d3225282db095a9063302fca89b59fa203214a0b5e12b7ba4955538c991fe28bff0bc1bc20959efba29b1875160956e651eab64d52afe0b72f85c99d1a3d11fef767b5867854391279399ba29e4621edf6a900b63c32b65a4efae3caacf308f051cd22cedef4c01e18d2c73ff24262f4f406b47afd7e2398d1f5f71516de7681cc4e77bf518adbf7093af4392d0a4a931b7f26d6c2c2c2c64710c1b25f3268768fffcfd9051cef6ce778fc5636fcf94f67238951f47de84fe85856cddfea4da3228653a74f1cd0cd528d9e1fe7c5bee5f3ecdc54b80769cbe67c7ad1cf765edc3f6e282fd49e845546ad803394cd1299da78c0736f3d1a36f1ef9b36946a0babb67b9442fbae84d704c97e21ffa60513f71e3c5ac503a0419fba32fb1183c4100a4cfceae1d4f27094ea79e56b361c1b3518073afe38f40e8fe4b55b417a9435e2415502adcc36496004700c163d93c0b7af949f6067d3723ef0b765f10e14f914a24421b8e0f660c53e8c2d24940d6085027e14556c175a2ed2f98c78c015d1b49a142cbfbf903d427a7e2f42117f738bdc70481ef6e0cf30288b2ad29fc4a31209aceca130465a7b6278a16047a7c44049ee015e9ad181eac200bda6c5ffbed462ff57efedec4c34b4dd214dc0544589e83eb4830c2d81a5a2bcaafbb445aa2339d2d507c8f8ba041561c7ce68efd50814af98f1210ed2a26b5b48bdb979e94e6da6b688cad3fe3399a4967d5818d24656a39d7fdd1f769171671bfc2f0deea18f929a2a71a645959b4f5fd60e866614582d3739fe42d5ad5877206c5b01ee6725a2684d076da9de7ed1d9d2920e46fcf53de928c91ca229f372ef524c9f8d93e738d4c8d303e4c3a0e6c1d1e55287b8c3170f1ae7714bcc16043076453310a2bf1ec60260218f16754903d0071195a8ff118dcd57fa0691fa5537721ba0804a95fcc01e716f9b92ff8c0d5a19b8a9fdadb53c4d16cbf1470e83310d26d615927ce24e5da0b3b83e923f4b64a79386ae8119939cb085891a7ee3304e36d3eb4a9f72252c1604da8bf1eaabbc60e55eb57b9c43c876674fb3d082d1c4f66c0a827a407fe5270acc4c7552050e3dee88561493080f86e099ad6f525187b8a34de21374213180795b30de298a28cfd386fb4c1bce0a036d5fefd9abb87223897bef575a7b6c57df5be305684abad4aa4d0c3a411d64492fd37d5031bf98898a72b0ddd1121767a437a8ce634e5b02f1bf3ae6eba2edb056f12aba9027ac45e593ca2ceaa9035a57f764e67eb45b4610ec8d2e916bc8057f43066d7b1a65512f26db7cb67829195902d38055ffeff793e1d36fe021e8931e6d617a5b689f3859cd82932548f53d01f51c68f329ae60a7f02f8d5b710717556d167cb9c9676545489d9f211df06c9cfcd1e65b2155f364d574a5a9288d5aedc48f702fe2c26d24ecf3a0752e5cc87cd20b810ebe7e6ddbf7d7f2f0ec3d0ac4a8652952583326fbc8d20b5c1adbdaadabada65dc4a27b617d061f3eb56bd91c052b7dbb1a81d60f4cedabbc826bb73ced1ebf389d8f41d23035298a2f38a5491e300623c124e9b14f160a3f08ef7757e41188ee86717b016ddd7a75574c2376b9e8a192ec338c3ba2b05f31dc96c66e5d36e42b32c30315fd8da62f491f69e11f73773a8b2febf3debb","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
