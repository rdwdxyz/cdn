<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"00ba9daa3659d5615f5c61f31c2516f2d401dd2801fe3fde6dcdca6cc6ce823508baa77433f282ada400615704ffdc9a7242695605224de4735bcf6bb7a0e28fd16005c38f94fa8f0e09d2cb229fcbd2994bf570abfef5758b5c88f5a72ba4847b99f8e254e1621b5541f820c4571067241b83c7101d7f4edd3801a76ba16a44e46496a3d6bc860322116ea3825065c1cf4ff0d55f1549f5338cbf6e5e2ed3a5577f9881fe601cbeeac29609a0e979b73bf1484045cb85e940b8d34485e066dd97ef19c0c53417427485371a3b1f70a916750f291fd462838ea95428ccf5b3e92073d6bb3ddfdbea705bf73fb1dffc1100c68b9ce9ce13f3a26c5a3557e221a16245755468036ee1dd14c71e2765441fae9a7c948593a54ae4d7cc057cd3c14a1ddccbc29e72f36c1ac380748971acb8028f350f92cb263d12fa163adde8a173b53130e093f94a4e1780f569cc79a34b69d34644428cf6f9b5dc3c937e864066e7a03ddc5ba3ee375cd25bc64c5529730229193cac9573af036b5aba9babbdbbc4de5d61b36688f2a18b638d2b4e23186394dfefbb8feedf90e3c9de456a6e6ce509fcedabf8926070db121eb063cfe670dd4cfc47216f911b2e0b1f912b477d55bb0b01c5020f3b694f7dc8e8402c8c2e1c9be983491f791f4cc90ea90c64898e3cefb6d033952c5a1cc42473950e864d4851a9b346967ac6dcc7484664a71e54a4cbf43a6db62a42a26d7894863dbfda172d5ae3978b0b3312caed13fbe27541c2f40f3ee1b57daee3d11a6b68f2d755826a00bd69231d9a9fa1c96206fb97a7c50ef977af4cfd34d5897fb9e2b55ba8c7073df2b1cca5a1fb8661484c630bbfddf275432a3c2c704af3080d9b756202af4cd7dc74ae1499cbf30823808679e60e7ff4ce65eb5883b60252d337a9053341b8cbb44f157125a16bd94b53ec8153d7b2da6e0216a1b543bba17955e78d9f6bda19606e0b5ebce3edb6b42e3b0689b584794053ff67123d46d26f3705052ddf3ff0e0c603629568bb6aacb5e364d368fa4418d14390eab357a498c7d607bad2742ac885b355afc8000e5aedc9cf82a2178800ff334f7d1b815c327c13c01766a5061fc65bccd56c15b7e409db9f910cc12fc1fd1b9b9ffa987d472018ffb2302d143df43d3a42dc18bd55ae025b03a50c9ff2db498529ee9b7d6b04497eaa3c1b3a92a72306713162dbb93228536d6f0bc8cbd81a1387adc01f5f91e3d1a804f10f48002512a5c27eee2c9e256d3f76c401d69cc5b105515ee19683570f85281d1785b80900da9046f13389bbbe34eb6f16b9fb1f326f165374fda372484f6685f2f47fa33f16ce8e4bc7da91c331ccdfd9de66f3886a55566b60bd4b82e69de13d3d180a20b687ecbd93a2752828159bc20c0a00679245d5b0b725e4b2bc228d04a2375fbc4a9988d19aca4107dfaa7dd059c5c267ff8ee95e2a53d608433f40d2ab43d623707248da40e9176aae042819932b63642a6e3b828f698b473cdc1469f19844d8cc6bcf9656208b2c4d10e7f4c0199d62405eb9e23b04ddd4b9f312fb84cf78ac439973f956710fa8f5d4dfb0c280b025e8ddee37cb5de7b92f67c9bfb0b64fe12fd0ea709978e8ec0230e9b08603d08b5545e192e59ee95d178c7b3420f95312118214fb96d4175c924229211651287a96bfd7bfa8b302553505ebb46b1e5910f1cac8d619bf5833ee55acd00a9ca3869dbed170c617072c325eb36b18fb5576984247a23a5307dec9910b31c3b07979e6fcf878caf0b0eb80d75c231ba36f441658ac1a075dce631b589a3db442050f8806ca9380754f626228e55c4271bb6a14417ee7dda79b302626c9b5541ecc159e19701a271e6d36fba2d76d36d2fc237f899ccbd0c8891e2dad596aa7e62984d03f01c3e7eb663b93f4afd74163dea7897ae6429de0314346f3e3907c628625bec80b653334d805dd1db26eeacd7f8c40679e63e973db5a7efc73781f0a84a1ef9d1d24b7b165e8ec754d37ba0dbd7d4302175d1e105b4663c9174e10c833dd346ff2d6cd7afaf35aed7b2894729cae241725100218d7ac994e81d58155d37dd382ae6c0a8e9473b4b1f9206c4d6fadad64b04bdede12ee068626e85df2f489c01747fc3fcc77b85d14f056922dd219b391d05bac45f989bb7a6c97aada5ea854e7843fb8cbe8eeea95e0ed7515cf60676a3800d4627a589a8a5ad65d6cf55ba999590276edcddce1432fdc4d3261ac41a6e4e141f7a3333eb0ea8ceb437d32b202a069b2c79a25a5c5091d76cecbc18de7234209816d363d4fba560ad16a04c0055bb008a0800c936c3ce1a1f70d17c12f5f83d7c9e57bbc3716fa7f8c15c9091c40f2eea4f9ae18a37eb89e1bff0c52aba3d7465eb6a8a35d556cd6e05e9e95e4daaa06f47543ace05d0ae25f874b2a80ed74d0b519f65b0c43bf53d91402594855f2d7dfd36a2fe0b8c9ed30e8714e1372856c939860c6480e6801ab0f2addb4ac3b75c6a9494f8691d30362dc0e936034e2dc1c45ca138667f3a0eeb1cf40ebeb8aa241d47d5e3ca37f6aeeb65c8d35fcba4421d3b94cd0b73def39d7dcfe21f6d052583980ae7005b6a0ed82c7f36c87365b7e753b7f562819aa25956fbf29a451924f9a97e2e27cb173696860c39153794651886ea477a0083829426c9070b4ada9ca88f89a72cdfd76e4f338deba8dfe1ab21881b8982864e05bbae6ceff6471370fad0dd255e75ddd2e0cd2a288bcfbce17959e078fb079dcf2b29c40b7f80293eb739eda6c1cdc1cbe00b42c8c2598a55f83280d2cfaa4e3ac4ce9346755797d8e5e71032818ffdf280159764edaf0671c450d435199f3ada5488acf128ba6503ac7b2cef956fb1573505c49480d98b3ddd2e2f858c081125631678919fc81e6537b4643c663fb25e78806333408e5306331fb84c5821f23c95b5dfacdd01c0b4d9ec9339b90f5b9d3db20f6cc408acde9bd9a228bafda04e2beb412f8cc3a6733625b65139c2678433e56a2845c82a4cfd4fd460f5cf1af0a8b277f1b6ada34aed3263a45a00a0c958c1513beb5ace362a6a2e659e73f1e806c7a53b343b74cf892a742b433da24940a609accc1096eb2043b24dbf43bc04297ab6a8cf4079e98cec009748e416655d8b2064310c6eedc44cbd51f911c98efd0cf401319befa67d15fc38726a3920e62848af1ac12493457e49c516950b1a0979ce17913a23fb6875090aee717ed85d3241a2d7d516b7e4ddd52aa8497ddbbe0642276a99fd29306805fca3e3cf7780fff85603ae6ff8cc53d9d48d23b969e7d44b3951e15aa718c8c38ad901836241262b23b6d3ab05a7aa85724b6f96520bf7fd1c394ea82f53df32602ba160dc6adb55c0d675c4ca114cdfd56227e3c52b7c5416e29d621a9b618c3544c9a08638cd1fbb73df7627cb0eb6caba361e1d8156d9fbd357897f49f8b05574f22dd381cd205d4fef04f46f2313a20867f1ca8c11a9d9d3313f8f0682b7bddba1689d8349ab2066b60ecee216c3e2a670fcd12543ea8ffa484a81d1da1000ae03ee642c708beb88e40864966ffde92498b877fc7eb7deb074144896bf6e82d57487a7b27e42d8e5018f6e548a718246f2560919cdac37ec148ae5466ca1b4760639c9e59ec319029222eab23f44b77d4fe3d0c6a30359635a9f47d1eb70b5ebae2c826a313b504efea7a1c9ebca04bf7c1cab8cb3a341c5d69112260c5232bc97989b117f930612d620296287d7635ac730af4d74e97787a0f765cd3dd3b6aabd69a3fc88281e043184d4e6d81e69fbb5a3c978b6441ed64872f136c8d54134a3931a97050edffc3dde97575a9db22b91e5df643c3d2aa35060d88fcca1f82482efa811b9971709f3b2a1ceb4ae763ba536fc2a72cb8cf7a864185b2443bf9a845dcb551f0a8af38461910a8f3a885720217e7f7ddfbabf0f7e59ae2ee102cd89d8536c3ce9766dfc8e64d099d9c132b73c5206421e0a8b83da105cccf99ae0f25b31dc25fb636a524584bcfc41e177bac82d452a019f978d41b3166fedbb276c680c540a9c7c44231639639fae7108ff482679dec0cb4e750372efd4cee4c46e88b9844ad8a2b0074fad0780fe4694194254c8307d071c171d933fdfdc40ca723d0331df4067ee48472341435e71016beecd1ddb2e0e9be668ed4368bfd7b507dab7e6a9b8067d3c340f62fb949aab9d8a1dccaf0924bff1a86a68075c6211b022cc13fd093b6e73c39b80fe3b35775f9a9258527b62f311c4b1a94cbf574a27bfd567aea9dcefe93437d296a8231385feb48f9f911af36fb345b60ee7b6fa8eed09a18884f8e85ead6e705aeaeaf45ad64f4e5b90ecbe8d029fbeae1f030016c7114b0d9a844b912cbce4671202a33e267132732055e3a890ea0d96c4335c7093cd029e1f5a4d00e033786e7b0c2e91818f1026bc55d1c71825cee238b804c9f4596af4b06dbbcb8ec3cfb60bc5a845354c137f314a2a880aaa005e5079a842864c21ca562d1561c12ab17214db666387466d50321a0042f7ec7241326c963f20e5aa2fcbc394098f75128ea65756a21bf365beea43f12e9bd3fd4711aa37d0f20fe34e9ba81dd1f07b366f99e3489f748bd8207016fb35b89790a4ad45b86c048e259135eca6158656822869f7987713994f954ed747605fba44a61faacabc6aea544aef5df693ce8acd9632aca43cd1aabafe5e287d6559c476bbf27ece26cf0455169f1570eba3acdd6060c8da714c6aa1016394bafec2f3122479166fd4cfb2348298f943e13db258b401bc33084449c8a2e79c1841c2758a783b1f45378ac586befc9c9b47aff6771304f9748cdb1e7ba8a170f55d1b5ef38ef60a98958d37cd2c9d6cf7b16e666bd08b53bf30303b31617f2f9b39937e10d4f2d8b8b8ad62f88f8905753ef1d22aa90be7bed308f19de9da3ab183d7643dfbf892eeaa4b8182e238ba0bd1e201f31c93b28302d5c9de5f7a29562f0e8cdb056c35c38f08592d265d3995bd4259f307ac3af7bb88250967741b0b80e22662f589f24ab035a200dc8a92595a939694d50ac97fb25da39f41a058ca0bdec02b528baf9ff250913786ac0b41ca95164623e1147b2bc0605b0eb8088ed3fecd0dce52f1505edcae7c22aa144af83f79eef2cef6585fc59d4f07fccbccc962d3c7e89085b4ea1fcd02d536f9525f29e19ba312320d98936f78a93a11f3158725526db0f48b7e23eb08aa912bc5a6e0244d02bcea1996556505f2a32e610bc1bd5d177b733bab76f55179188e0f1729f30e6ac126d59260eb1072e2128487f3117a9f44c447d629a6b3d5b1d14aaba5f05e8b2d43c31227c4873d17b81a35739442229bb2035f38a5fb0377983a9f764eb3187ee35c9633fcd64c4b745de85b04a8c9e5a3f81068fbcb195e249716c459770ff8000a39015a5888c183e9b3950265b616e5005e7a37545a9c45303792053a6ac02ff060ff30453c2e1318754a93a331e28009d373b623f5304fe1497e04c9b8a2feb091cdf5a14eedd1a97ad68071f6afdcee21d28ffc5eff8b63f3987e0f950a93b36ac5f4cc05c189e4e845251cdbc00222b9874c9b9744e1361cd2c4da194ba6032e04bfc9122ce3a223f086bd404a320529e83f5db6debfa7b497e00a46979fcec086aaec1030d5e8116166f24cb6786ea26fce320b3668f1325bcdfbf36d7c0cf171116cda768e5eb60592dc608fa7478b37bf3432c2371a407110b23dadcf11352b698fb273fbb98f2b71872612e4516cf83194f39b2e57d2a8c483f2fb7962d4af1c62eb56a4759126fd3dc420cc99c9496ef2ce19426b1088270f6733ff57cfc0bdf945e1b2f4fd04c817fada2b38e0c7284d7bb1aa9bafc96205b00940154642408710009016d09f952a06d7e318a9fb4e236320f86af2972bbea3c32d5762a6de1a16d2bfd0018ae16f613f07044c7ac7ec81a60bb1bb9f6443b67752e9ead8d945a16e3019aa8a13c46508710504acc828b2106049aa9e0802823480d8bd6982831d1204b5fc5c420187fc0888575ced8e1ac0b06b484ccd0625957d6c3fb35976d461b796bb85863644cb706e494b78be7c766921208e7947db1168e3391148f7d941c63e082aa7107bd77a5c7cdd7fa361b755b2d9a47bd34f9bd3daab4d8388bfc02d84ffa1ebc06c24a04f1b62b20510ae0973e66489a8f141c312f2bb2276756da3dded7ec559a3003b4c383e195e987cd4041e2a24c02d3f659660d1e820ef68e2cffe3d8f849a473a3e88b6a6d29d5f7f31665044f8936cd0141fc17f3e5eef7f1c9324b96b1f089a46acf4618aa15e7be24c5f2d4c95b05f1d2ad9b68ab05e05bec4bc535eab0cce9d081769a87c70c1c3d14def5933dad7bb8c21475c92243405115c970cf10c8465a7af6120df676d22716f1ca7202ccac3d34b6aecdf3e621984d156dc4c75c056819788fcf9834a28e87dafab8ec967c49b035993d1d56205f43f6adbca7d98db244f462e21b750899a32ef5f41d29aa47964426fcbf05e198e961e0cc152b4b13a6382f3462971fea60363e976e2ad62a1678f9612a91f4ff670c39092c49a62b9ad77fb1eb956bd5883a2d7701fbb9a7a91088ad16d8b21325ba8437ae9eb3b4050297e502d4a96ac5d5b0b057827e8adde76149f4d4efd239563ac10cb2de648485e1999a65154687f5e0ce00a95fdb63148dcfe460c3e47d5299db2c71c701b5b434c73e066a12a5eb271c26c198c6ed2d3c4b16b5a42c9b803b5553aa19ac6efa9eba868d27df8902d5939dd9ca37c238d56330eb74b0fc18af28a0311bff22258ada087e82b00eac97966fec1b7fa56e9807c58bf904e75b3399af55087cbf7293eca3aa72cbe847f986f4c493c1aa67cfdf9c11cb3b055469aca7fafeee7471f7724d2a4185c0854a43c9122e67bb5a83105eb822020a947f2aaf0c5e7d02f4e2cd59cfd06d3cf9f12cfc1990ac5a665f8c6e29d0bd0bbf84aa73830b1ba012f5608895c375f8a45ce3046ce89adbc122d84e985cb948543376edf2d52213c9d714e0a97fb941fcba8d747e8d7c660d1940da73e6d2b68891ff28022dd16ffe54aba0af23b84bd2c9d1c2508a0e71abfd324b186549c72e4bcfd3ed19f6d9428b9e6e77340fe45f572862d95dba7b83b8f2cf048bfe69f8d43a3a2a0b94a6606ac89d98c7a8da09d61d1d0a41272aa21c8227eaac92ba007a6aeb752909d6254292759574f4194fc68d66320a71d93f40957c8254af6435716065fe250387b8a2038119ae2e693d095f70c8d9da99a461538d9f34d8b83025ea80570e9efe5deebf24de309da07872ca13cca3d771d150f37718ee8188e06b868c24e837f317fce7f12db50dbe54b10f33c427099cf552656082f470d35dfda337e1cc4bf47dc80d4732493eaa63ddd4c94e2ed40028866f3bad5157d3bd972b62c0c82819b80775171f5661dd8c17fa882fdd1c79dc0ea84346bb36b4135e9e41106e03c3da97ff38cf6f2ea3472a0467c71368d71073786f78ff0db611038e2f4d6da27698f3c1e5a89465bc592406e6cd9c76e90afdc3d0fba936fa6de3fee3f3bec467bd4a03db9b6a5fe5fea435e98322cd566aa481c4672f1be76508025c7c5ba0b2ba081122724bbd2affc4c392b3eb63600d62ef0c8e97a9c52abdb60b241b8200b55ed509fa4da73c0f9ad9b9cb3156a7c45ab118f2ee79a4e7422f93a5f73486d124cfbbd5c39a0e0be952ad9bafcd22916f0b98bb84823d7fecbb8e5a5920f34c0c5a0ea3345d6832b65e5b84af3981b83b1adec5bbeb6e139c36b0c774753defba552974e4f14c6e1f1f4e60c1bbc353347524cedf2a82daab2d605a96cd4ab99a8a16fb8fecda4fa362d1e866481bbc513b3d93c00c4bb52c8b7c4083d698cf45929745bba1713632a33c07d39584919352d19c6454ee4134a9dd181ed57f1fde59e9fa6cc9127a1c9d9d65357d04c2c61de6280ab1a91b01e3cf33710607fc7daf11718ad3f10c6d44dcfae1055d5934fa056e33b65d287a2b9d2b06f78c2eb7415674b60c4d39e39f48f2b78f19b64cb997e90aaf9b8ffdf9f11af482bd9f3ec96ecacb5699bf72f00458b4512a6b8a9b5eccdab39a8e8efa862b8236b7e65a3480194b47a02710d64be9aa539d4c9013cdeb568532160f6ab7104a562a3aa00592695ab42f48e286e1c9d2910fa491f783a5cfb6b5c57febf52d6d1f0517f48025052b2f03ef77bef391e11e41da2e640ed439113005138a88c9c965c765ba9ad1f3829f740c1336292c3e29864fda79661f77c2186414d5275680a50ad3c605d735bf0df1ca8b056a990055972128228e76858a2f4f4a0a09edbedd72ac9f08787f6549cb39e6f34772ba651a277915432d150994c178388c65c657b99f8f56b9773df44b054cbc480445187d13bb44399f0edc8e32eae48565e61344468c053243dce70a213b31a26ad5f064f9baf806d9beb272debd4acf92feba048b150226223dd4cf8652fca02427ba4f5226d07d5c6dad7271dd83c055da7f4d5f2d121ab7c749fba8b9bfa2ba9d72bf5fe48c2e5b00785415bac6fbed01c6da876c3345fe4fa28853733c5378a66243d187ddba9d81d6c0ec6153ef51ccb3374e127fbb75a771edaa4a5ee9abb2bd20db88a47807c82f27ac66883721b5a60c72ab82be7dd926187bb943771009891794fa7337d5251ff1e7fd7cd579faa2d27d706847d89b66680281cb06eaa5374a306eba76938e1a798457fcb4abd81ada6ec4f5c87abebf0316b088fea4129777af51f7e9d650b384792f843671c32004228f484153882980eaef6c05e211e5649865fe7d0b7774d141e01afd1020ddedc1f24ca6b0341f0ce1610670636c9e0c064e20e8ab07dbd2bd96913b0c38f1135e157e9600dcb6a5cdbfea6c20eae81b6e58946c2e4838cf8122875e4e0024c3a22e74ec33dc9db81927eac65cb73e796bdb5c21fde6d4994d56e78ca78c2ce3fe9642a72f75118703f4a8ccc770ae985eae123288c3276092317b9d982204cdf5e62e381f258742b31155281188186569001b7e7f27bebce498a46617586a5507286f7179bb24fec37853c795109ce0155cc0dcec28d6e94947ef007159b1176cd191125c9a7513fae34509cc32b987313e7e1ab67105ea44734ec5e606843c913cccc774f798a55893ddb49ae8193caf0b93f8d2881050fe964980827345fc744221dc89262c8d52a6e9f768c9fda15233ba91b002a4b30b1872378437090261f2bf3e1e8ae2680f998eb1cf19483946c9e420c89719ed2f19bc9d11058ce7fb46795f97e897e091206a85c5ead457e0d2e7c6b349b1f34fcfc6dda47614bcf1e3c27bd8343595f7309a2130c2f98131cf5c89fe937ed13c925ef7677da21dba8caa9b4b51b615ee3f73bb625e7c2e6e0b4866c9e5aaee7af6c6e07183bef7c65275123a9518dcc1031f2dcebd46d240b422bf549e4706208b0785288e3eede9d62bcf80aac73afad182bac5ba70ccbfc59a91174f7ae3a7a378a884bc003c76d976cbe80d16ebbacafcbcad37ccda6ef44501d156a1858080d7723a65087cf3d4f882590c3c63c620ef9ba7ff33392a6efc244fe414db578a8ab839ec8fc3ddf2a25b1f0ee28423ade3dcdb1c3bf7190fe21c1e238e3c2883467c404e3bab060d560e22300e7be2f364598011df974e4931382da4731e79bdbe6b4942a5e180e02c72301a36a62e314822291615da9db3b3b98ceb4f4772d284ff7b8a368af195a456bf1a7e8d41dadd4f03609cd8e3ce70673425566ab2faf0a81b08536fee8479a1fa73560b6b657e5f189e8f7b20dc1d45fce4c2130ef6d6c35cd0a3b9579720365801984dc2ec846aeac7c3685b10b854806560ee282e5cc84ab7366aa17324b292dfeaedc225e0a3d6622b0daf933e357104425f00830300ec478f2ee90d753e21f2eeb2e6054167e8ff5c4fc1e7937802355daea94865dde5a4b261e52ca0de08baee3720790dc8e5b7892ad58dfc6f1d072d9e167bfa2c919c57bc13523a66401c7d7401b54a588a21838a057572767d36c8df07c2eac6eceae83193935eb7650ec350e4c67a7c543767af4d5acba4819aadc85642439545c07cfaa0c786814cf9d47102ea41bf8c19cb9a249f5397d12e28940b824618d9f0297a40b6d5116880a7fb6866cd86a8d7ea6d379937128f90e9f0ed5557da11ba348c0a678f9c3bff7c8fe10867c0b167942a9300430ee66ec3d54416b9a26779d400660751a3b718a988a7255737cd2101193fca39b0ba3627e0d021f3d2f1a8c17e5b0deacb8c889e9b8dea0b91dcfc8aa7161f3765ab08520a40d7e440a494f99bda023541ed00efd1e49fab93f4c6d93dba0a14973a21f7625a0619cf659b5a004bfd0d0df8d73027387a7c4a6e19ada59342cbf703159ad7b3d2a3d95a91405bb8b44ccb0d3607a2abe523c65e8e977b5f16913b25b833b16887937bb9e8da60d5c97714883041ddabb08cabd7a83de7ac298d9515965e22e19b6127065550339b9212fc9c07509901f1b92da2dde064f9b1af7ce167782c3163b291ed01f262b0885739571866a596b466bf9121288ee09ad07b8d823cc9ed465483656cf55b09b724f72895dc6f957429f8f6e3bcd42b806928202f8e822b16e97db84c5ddc13482594184565045ddb91a8ff2b2cdb11e9816a20e170fb7cccbab768194eb641ba59b2967d10c8f800ac3fca3eff86ceff49b1342f3f5658beb00a89c52ee5c78bed54b87e8ae0fc9b84e6cbd6a68ae4bfcba2623bcd0cb0334cec28452ec0600ea86a1170a6778afbf1f44977a828398d3419e87325c886efa1c70f90a0d4aa7225308cd2ed9e88c84b39bf0843658fa77b19b4188dc51d186de00df7a79ed94d07b239d3a9ca6709757a1183426e27cc460b0a5abf381d9dd7fdfbe567ff8d59d6ee734bf2ba07deb7b4a197294cdbaba9da1b1dfe9993f60d6552c1c68c66518a43a657715a760fd358384c3c1c2c6f5f7eeaf41cc14bea31c7f0fa93ef6c9ed0b33a720423a8e8f111e1314fd9387615eff64eda77743332431f196f712c4e15798d91226d19b953ef54ddbd0f4ca5dc093952598741f8542b38ff8ccba18a02e914cc1d2d11046e5378ff89491e98c6a75716b4271417cc19e9674afc3480a17e287b79b18a5efaf413da90f347c1eca25022e78b0cc78ed6222cafddcc4be044730d22c0c03f97d9e45d98ed0e1be4f3288f5415cc5921a372d5c5bfe2f639065b2d3c7ce7e00e68f926b368c03cf6823d61f36771f34ea0774fc0bf90ab2d426765983fe31846253552a3eff6876e68ec2341e4c55b74c37019d6e8a6c0bf8235744e1590422b1455fe07ad1035237ee5f37b7c3bd3edb051c289c29abd893c574123252db2be5e53352cfd313e29f89fe26c7707e2bdfa99a75cb362a15bff9c1855cb40d0eedaecd49d44d93dba330f148c04583b351649879294999e97a2a82de5ed3e4d76e2dcc6dc621ab23c94b6cf2b60aa864d8e0f821d4f700ac12fb06e8d69bb42c1661b532a229478d1af5407c3191339c69d52b36f690f239fd0f9a28e9b5ecc18636352ac156a26eadf83264bc171a272b92cff0ec7baaf25484d4cb1733ba6ad48b9b9cedc3a4d0d78cbc8168b0bb7a77a6cc67720082e0ab5604a1eaff99ed333150a0b1272b27846cd9386e7ec5260ee9e006c1281aa78a4a8e84c7df05196f6090d81bfc30ad5cd61b0ef680bca1e329f5a54e827500acbda87a62d83f28e33da11a9b1c366da3d0a7ea54aeb26046fd328be7cec61c79f1ff7666838a76d65335053e5f60692b7727a5c497aa4a9e3133ac4f214eb3ecbdcd5d347b33a0611a3e0ea2caaba5a92cadd38d0e7987fc2afd980e047c505500798330af39c0d7204a920932536879ccb967eb8280d2631e9e9c1b2d3b4f0e2601b4ab91ae7f36e626f17b19e698a321f3b1ec503b762a884e460abad416ef0cd981dbde4b93f7233e6ebe7c9e3969c532895320747b79e39d6c38d4f9dd398ca827436b40927ddd3ae73de5a00a8fda3802483eefba7fc43dd123d5f65e22c34a2ef461cbcd36599d0d87d809085dca74ab3517fe560ada07b5fd3efcd682e81af6801d18f91a912a68d02a6e13dd5c5dc46376959694bc5cd0b9737c3ff5ce3088b57dc712293af98f37576da6ef7e0550b51acb274fe7e7399c0e935f64df9792ac5e981b6023c04ebb26a2376784422ac8e693f51f6417e5bf57a498c0f8fbf7b6cd9dd7e3b0ccaaa838f8d0000e807c63894950fc0f9c42f825c2af01d85a0933a6ca98c367e438305f56fa39f41f4591c22e3ce8c59364cdecd246e67217267596f3245a59bca170ade1019be756507eab982791bd990362786b929a7b548b443a3161e7d660508e3d487276bdd478d015f0d53e4a72fab90ce442dd48b48c0d83376736089f5e234ef031048a90b4013d82c7cf3c4407aea6fbf5d7529efa85f3792a71d53be6a9f5001cd3a48d6d8b8fe1c00d983aeb263c336e1181b5a144c3cf5fbb014312742b9b166a163bbb5c102d412c1a3910ddbf3a9fa5c0c77991f9d1927d9d3204e56e9f3a261e8fc4851afc2cfd52184dfe7278ea7de653972259637afc161c67c5711fa0e9cff0b2d66f2e9409607ef26b6865970c80aa8fbc24abe41e4dcd9b4f088cef8010969a3546310d49f5a4078d7ab87217a68cd65e192f46e107a960e049a4342412863f5bfd9c89915a01ab044db5346a952178d23308495cd9ca9debc1a6dc1adbf2f4bad730650e3fb82105c13a643e4246970a4609a51ce8975bd61b9795daec1207610a9acb19913689c3a85da7284e70ecb5f01cd49eb4a1347ae354db3c212585ad017962c7304689e66d4330e8fb6fd2da06a77e56f347e34b97bdb38c0ddf30b5b5949d84b66d0fcae1dce1155fb3019701070f9f2697015c76f5a6e5b8fccab56d8f0a3ae1d1347f8d59ab008ff39266640d25a5077bdb23de77c3e794ba880cc49726949e75ed91e11f79f9d9f8066b55562237aec4d8b7e35dedc064a855623a3424bd99b16c66b92fbe4318e783e491b46dcf9530724b5dc17e3e9356bcb1fa41908aa83bf09eab50719c41fc2d4089d9edd371a7e19d98912f0124442efca470d62180e65b890722e8a9b61f6c0c5abaf0f91e3c3e9e4e1238ac303fd821c5a623625ba1b6aa9e00e48addae5a43e95207b6bb0d988b3c5b387485b3128abfec1d6a30b6c035208212888e27eaa360b1057a38a3a87d070a18789a30f9a0ab2a3038f870d0feadf2472ffe7d29bfbd610fd5b4dfd5d0d60a4b148331fbdf70bce77baabb465297e143f12deadd9864d29d1e126df39341ded3c5f8b62c8aebf41fab3a30f7e3d6051cd375e9b7a5aa60875c44cb0c9a8ad703dab34e55bc2582203b3c5f1663cc1c620d500e06bd28712892ecd82ec373e1aee88af05223edbb7ecfb3a7453d60ef7ceb8222e248463189523967f72a9ead99abcf06dc5181c7122e90cd7ad63b98f030bcd4759a3b24db9b0b87da23c793dde70edce9821fcd00f4e89950eee745f6204c43e026f00e917027349094adcfaeddb3c597680ea0a6d391d4ba9f21fb3167c7087a0277bc57fac27a3b115a0575dafa7d6b167eaef962e9363f6882cd3e4bd300a0f530aa8b962123ad500efde9ea3c940c02cda4bc07dcdb210ff785f3e3e69722811f8403165701247308577200cba16cb62764bc0b0ebb3648e0466a811db33ad6d8058eb5a8e4fc088678fb1573f67a0995fc7c47fa5c17ea173de251a4868459b33e54e37c4397b2c848d066a5957c4cb43de126d5d1d3c9e762c5a47d348f29bf07b499ef07721cd6a37328cef0b9177776b948061e69898243ae65cf0ac7118bdc9cef779108523a37d25b1e14c3f51a4aad1ceb0e66539546971b35be205aa714f402b8a4d09728306ef51d842c462013b722644eeba22611d6accac18363049a79df4da0c79f78698cf0d6d076448847cfae6c091607fbf08d80123b06879044d43ab3faab25bf8b876ff91f3bfa6c575d9dc9e961fc655f59ec11038930c307af56eec5e75a69cbf89e64654fa8b28290264bb1eceb82ccbb0eaee850418f63fa8f1682f926b23f1aa107b35b3dde58edfb2da075c51f4394f4b312511405ab7fe518e8f1df752da8944dc8e0b00cbf7f8f9b15aee9947702609d9a57afdb75dad1720dfbb6d091453b15b160c921b618f1fda47990d5bf51cced4e4489d6cedd6fbe40f5f0196570354f7a60f73634303d9304f5a728ab4e78bae7617f97b381df2c1b1eaf39cf7de2359a2d547d951c08c26280f40a17447acc60c54ec2b244a11e756e353768364de1ce21512cb8582d449d5b5d05d5026f80ee42f0be928f81f4b60eafe2d2eb0df5cc8dd701a2b7152864ced838d89bde4304fe5264e7fc8d14346173a38d2f59e3b4ce69778b403080772f0b9352d9bf48b5d703f249d1cb89926c1b54b6d1f0964ffdc94f449b10081e0ddf8d19b6273512ce2f55daf8425a14b157e7d09f8260edc6701b72d0ff31aa6cd8557994c287013b8c9947f6e100a18b078629e7ff16b89401cdf69846de3fc479f23b23c325eaa398f1551c350ef51c2ae787611363b5e856708cc538c8b55ef89f3361f3de0c16c53ddbc925cf3307584125c9af7c3d3df592edadd402f947f418b66a5985ed3a4e10fac94477da05100c85228856480cc59e6a7ca304c90abc82c3860aff9e7db6f1e9cdb191deb157f37627930ec003f613a245d745bb9610b7be2a07bf8ab365882e7d6895a4c6d1f2d18de21a7f49aa07ba57562ab9c5274f156d723c5f1d5e3b1459709b92f83e5c3eefc7484b8c43d172c1bccd883940695752d571322e9b8b41914a2add4620cfaa228b19ac0a8f7007fc01bfb9d141b76ef5c8d21b3b2c1d2377d8786be03b5c89373d2185e4a66f9ac87ae5e9b95b52a1782d38ff0a139a36ddd900327988057a1bfb55495d319787af8202e172d6c1c0ef48c3e5c43767748ede69c134800afd23db0f1e1f452c8ad3d9acef715a2bd4c1c77a3b3591482f720472b7a0656b277d3f492bbbae006f490eb7c38f024e92ad64df6aa8e823ab74807875dc41f9b1861139ae94448265008a274b9de2826cedb29b42734878e527a42969fb71557914668088920bc85f859415d9eb23c6eff8d85150967c3b72ab94d8d6fbdc05402db322a349afe6e1d2364ae72babc8123b0b56979fb320290e0ff01b546b1ab433fa96eedce941b2eacd3dbd206b412c80e994003256394d7b9c32caf769658c70bf46cd14cae59b696f760391b3a51ba23283635e6c2bbc1ce722e158b50c94aae2717682f475567428ca87e4fc32a6684c01c20905f7f119e9a284bfd16b726f269bb1e98ae2eb5c28ea15a620945917d22e7a1096e075f9d462f3dc9c56760e7ad7a5795a12d62a6f20c3103e84cd93185f042d1ae4b4401333e58d1fee1f51872002e3312cc667c96864d72a08077c6af0a691fa979455b83d13fd1ff85178f94cf69ac94d124abe868c41183a6038c57cb5d86fcb50bd62446dea31d2b010900d7787112e573bc5bfa8e94f8ffe1137e8b8825149e27abb02988474416ff0f7a8e36c502c2d1e1fe3d7e563dd4245c1fb77b8d79d7a53a522edd374ba929f520b229185668041605142c5b35723327cebc919854dad997ba05ae3a82dbf2d8cf4cbc6cf3c784d51ff9b863059495c94a77f197484820b9443a71bedccced1901204b0e24c963e78043b6f7e62133844f3302e5294515aa4a579aab946a9dffe4b5f5796f4046a275e9e7852002bfdd27228c2797b49a0972c321d8c62f9c16c87ad0bf7fa4bcab548103c98a99e79de1f812db99bd9c37ddd4bd94261bcbfd26999429b156df0cfa58e683e197d80ddf26796b154bd6dbbc2bc53cbdb03e842cc0b73d87e690a203fb8c87901ca8cefbca3e4e9169bf82bc63a4773baac45acfa046f34c2b4932c4b16c7c63dcfbddbb4978dd629051df61e4df36c4cdd8fe6add7018d7d3ee31ff0d7f849540a6076fb0558d664d024c33c7a52cd616dbd871ad7c4c22a86e8aada1760f31bc0ec12aef2cd15c54fcc3db10577cb079f9d34b33eb51536fbfeff61561b890a80c9bbc1b9f6989a97dfef77a833b92c5cc6114d148147a4a45aeb5dbeae50b7fc79341dc374380d6dad021289843e13f82953afe50511a947404d8f42e28d5f5703e8ca1379a32c4637f9d8829a24f5acfe589d241ad5aa80beeeebda6aa67f0565c179ad3ba2f60ab10795d4aa75eb7f3640ca580f484bcdb499ee0bfe586d9830095cc58e899111b88363e86618f328ce62a23319d38726fc168f3d7c385290ca204b02410c5942af2ba61b2d686ec5db0e9f173c68021d9de3dba715d66029fa697d6a0684c1b0293167c6be7739ed72db58366033efb107377c63e2e27ca625509d9b5f7a06b2ceb2a932ec8d7edef2959b5e7750ec30afb0bb6b89fc125d281d32a0c7b103aead6a68cc52c0069ff93dd80e82ecf0b5f57309c52f22b6ffde88ad9421d33b9d8725686818600e22e0a7e11393a8a6e92e94e04d68419c7e9da3532294979eec23d70991e8a113a65ddbf3b5770b9559930236f18546f1fd458f175706e5a13501004eef600fdec1e36dd4ba06a0d3d85e3fa4d54c8c6b2347a9a62676d8d9bb525a4766a114fd2daa0339952072b3c36fa3bb8ec043543c545477503ee4f3d1a9243a68507ebdfeef71abbccc32acdbe77395e9c811f1bab4cadf191939724f8191767fa827f5e3b269cc1bdd6845c13d66965cf529316fec9e9b528a13b66a6ad32bdd50609d9a1e76d81af0bcd333bc9dddbed70eeda1834bee7a91d866423061f0ca17cb86292ea1e44d5e9bb88ed036d94b6774935a893a1ae335e9021ce139638e368839b06f356d34bcdbc9100950d9f03394365bac334d7a2a11a9f444f5d6535da20b7dd78c0b4054f31e0fa43d156faf5011567d3bd1fcf4322f42656650359a538f5acadf8611316b8c3ef7be025d253f18c87bc21a0ca83b2261d0d72b0d9d36c682f9fea7348843e00b5cc46db061a9a3a9188ebd9b6246d0e764dec93d818486dc7097577cbdd353cbafd16d76e2a2cc116d355255d744e4d62df5d1d781dbf6e255d4ae1e82f170dd491c3c5dc5099e27546e20dd512640b0133284b78a7a12f378036d3660b1032c6849f2ef32de011937cdcbae83769cd9cf3b94aa6c954cbdc2db3ab3dcf94ea51c46be68518ec6ceb6e03465bb9bae35e3dbd2c3673b00174cbea54b3379d0d145acc65f29ffcc8298de7e997866ab4626b9912ae1570e9658edf700fc785145153d5a8696494b6c2e59f93df059377d811846053355676a88996fdcf646e85c5514ade5f37cc096cbc88ffeb86410989cffc06e5ca1a76ffc39363b0f6f3467cff7540303d9858ea2688a238556f189522d78f1ffea631d5258b5ae30936e842e6e09d3b35df3247979dd548a96e34bae6ebbbdeb0cd16ae8e95e34c19a607c121389a8a0599f56c44d98816894ebfb9aebafd8646e78d843bb4cf9789ed6b4335e5296d9a1beb86dffa5e4c088ac05ace855d5b1ec36245320b45e709b09614c6b6f72d7291bfbeb1ae8405c98be1712e2b90d316c8246dca91adf72d9df34e25ed552c676c1052487520b6c531a4a5e58277bb0372f7190ebca8228885d30445ee2459b5c8b23a3b61398906ad8913a204b3c3521af2412d9b071816d00264d4f5262e1e7543d0c47814d133b1435a8719eb461c69f8ab1f4bf4e0ec51a20236cf7ace27e04d0a576897f89964c937d123610202f022aeb2c05210138272258803698c2a251252970746a269627694885c24cec789fcda49777e58d7bb353c404d13f056e6116e33a81cdf5949ff181811934859e1196c571deb9d37727a91a42bf627b9f7586485899471d7f84fb7a451b470c7225bf317fb9ad20ee4c2a04199136caab31717f7478a320070ef1e0ca1","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
