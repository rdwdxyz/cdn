<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2462f8a5a426b1ad510c473408e017ffbc8acf367ad747a04229005c80190e0882c331d9b35c48dee67dd4e3f2ba5b1d6110ba12e8c70ce9dbafdf79ff4d397ff4fb96b0a949495691ca0564a258dde2953af72f1ddc67d50928bc52c582de28406d1e57922721760c15df20effb7f11983a690048746f77ae84b0954c86efc9263a5ed29207eb4391b31e1a5298cf27d8c909b5b6adf12b9468dac9b979ff4562a6359048bd0024cad81d4a7f13fefa873477bc45b7ef9184488196a6ba6a054b60c3b44a8ad782eb7f6d18756f889a5c7e63971ade419021af9f6ef572a5c6cc34b2bb06bae76623f4d549edebb1929f1030efb85bd31544f4d9611ff8288d673f0376b38a6dc274435288174348321164f4e4c2ac09f1b9257d1f369009ec609e9cb5c9b288703b74115f6af10f95150873053cc7f29c5d4e1d1a7af0cf8c5536af33638acc5eaa374a70d19fab1e564fe0de6321bec65ef448d320aa70c6789eec9668eebc542a5489e438fc3b20af6c2568f2714d8493d3005acd159728681f141e4fbc4cef9d1c761356f76f253dfc18cc675182d4d3ef0f71d90548af3e5cc0ce974330f899d45f683721f490f293831b7313de9d3e36ac782581e57f06d9f4f65929e2d116a5b8968934bf3f1d10c7b53b3162131abeeb4cc28d03143cf431b34c2de2dca011f8843028eff9451b8bedd1880680f691b581023057b034f3da06c44781bc09236733d3dc672a127ee8bcff92d57d696e3a503c1bfcab0c4e1b809547513f2fe05c916db31287171826eacc84ad5500d883c489131f004e1744e1687025587512181c2720a3f4dac891a1c158569beacc36f507378fec331b821ad8ba58dc12a868a5e9e8180ad2177242c72a7ef907da2a0a40c25e50628bd6366e8abe834b4584eddca3f1e52790a566b74ab9e2b03332c82610e938905f964a09c184b0a6cb0b7ea436250bf6aaabd54a9683d166190d2591e47c0135f3e1ae21403222416a66d5601f8d23a2f044362e0a254543b035c9b1a15169ac30dcba2b17eecbacfcb77617a47b9fc2a426b7bb1c290dd6d1a61b550950c3acc5788a9dd9405cedd0511351dc02c3f9e20f83056e474155084e003fccb0accb08fb84dabc6d6f721ede28fdbb13581a4a0aa6fd50813bb195dd42dea0a5017a5246fca019623699047e4333a942447c8f05448bed2179f0ae49d067de19e74cda34705be36e2ccc2ecde45365a8530fbce6db35337d33b2a826917343e737ae8c159c4f3827bdedcf1bdf9d826463506fb69399abc24501ffbd90fbcec75c1418dbc2edeb7edd42f30dc7ce5b28ea560813ca4cd990ca93c11aef7a29add64f6a8a3ced28ba941598dec2f1a8d43a762218b9e51bfb54ce52cb53498ad16e05d162f3f970b6f94ba1f7bfc3aa78f33bfaacad75adea540e446aa37dfec59792278268ed85ea8633384ede418fa2aa15fbfe2dc73918329aa3703f3624763be7627a5303ecb22efd926f12b69732b4b5335d617477f6890dfa91f2899aa4fbf0a4e2d932c9b03cbe054fea2126a039aac08eb6408526138846d2bd10d5c20c01eacbe4c12d04acab429251cd74f58bdf025aadaeef4432849e3dd2f37a53745a62277e1b947afa1e354c7652428246432d4825ed3b661362fe49ca4ee8368675fc646ef47c86dcad9afa5ae701efed2cef1fd1fd902925c0e186d8d5958a112196e3b1a3045794b6bc750d52bd8866a5d4c6e51cba7680d2f19297ac090ea89056f2e4a50238d2ec5a5a496de90be9c41080df2ff332cf29bcd126ea64dc73abc8d3a365a0ced892c2a9d62bb02f7e69a85cb09407bf2a56b44f63aced11172729788695a8a008078ce41370512cb35c4a9fc43428bb8e354a6f2799ac9d3f4a52cb2f82f2b90eeedb6ff2a26b2649a4b6c278b6e78033d91cccbd8bc39f83ebaca454342ba70c6a2348378e03c1ec0bd9291d590e29d8913e7746755f6e242cf03a906f5676b43e3646780554308624a1c5a560b9db93e6d721d1d2943207884bbf85ecd7bfde81c40b510fe7b2e34dc8fc78fa85c3fca326b67d7421cd22eeb9b351b5397863336c06ccc55001c9e8ff5bc5ff197016f0316679b3cb1af88c32e731d1ecdebba09b17c5b48bbcd5ddfdae1e300582195784d8f02b300fe2f6f6c29f38fff282948bf047c6c23c57188a39e06c2250a9a1f2b56cceea4a84a0b01c5043b502c2220dd2dd2f3623b9e5c627be16850360042043f7a693a09448413015a1d645969ccccbca7e56b8ad974d7ec046bc8e60c1ad5687c5dac6cee8d58bf9977b40b55899e1121fe60605cf6665c2dcd0bcb77e2713d3ea63221cb184261d28fcaeb8e99b4353acf5a1ff9d8ba2b014b1011a9f8e0d62b4d015a8ef300515e8965b7bf886e45bd3db69988e8ee76c382f23157b68ac5d16d279873e28512a8945b29556a58043458bf39234bd7840e9281db545c5bb9a26c37fe9f37c770f679ca7d52f5bfbcd5fe9c7b1d9b7423dc0837ca1d33967edb03f7ac6d958ce16b6dfb2b35cdf95b6ae3e6a8c3d03b51f0fcaaeccc2d4e88d5c38bf7ff2f1e4985e37a4e912e6fe28a0b852b81de12df6adea1745ad548a16b2106a1c872dbbffc748b73e5d469c6c6a96f304f17e1ff684eb8c74a410a8f24c110d7aba2d9904c6efdc1a5e677b4baf0db94e018472de2ab889ef725b445e4aa736eac5e200f55c96290efa6d903fbcf11ebedb608d156311dda5300fed063441ad87fcaa07241dd7c955e42fda7125d9de246626e1731cc1ff393320688f68038278eef9e5a6a8bc48cd8d697948f512d10a5ea19bd400d8fb12d7793327aad032c2086a64a0db0de61d80797c19daa8123c9769dad7afdec03cfab76e0a7ae9b072204ba57375d259f6f50c0645183833ece41596f2d0c63d4e5530caafd5dffb0b0a29ffe2ade12327ec92107fd64b493c3fd39eb5b8c31d5a1166fa14e9f6c918bb25b78737e81b70e95bb06fea9f6a59e2b321b2268c5dcd2c566703631438d4df2a33abb7a4af2bbbde0b9b0ade7cbf4253d0ce9f79837ce925d92fb7f4ea697aebb7f44a3d8eb388f86e161913d14e460ec6ccabe591f5305eabcf0ce9831ff1b47f090bb6ed14234a8607d4a45106b17e421c04f25a1828044ec11c9ebb8f2f559068b8f1cfb0b43b080cd626bd312732324f6b676a2c0c22b7543b940068a8cf6458841558960206b59d824e875bf4758da042100d044276a1531b469ecc80bfa88d6725e4bce2d5d723d75bbfa215a220d46e4ffa70db7090c3140cd9e33b4d11c7c256d2f3b5daeac2fc781848a988fe1c1ef31ef9bbbf63fe97e3fff5056bf41272dd82dea15e6a7579b8709251f4fe361b042d61af5f886fabdb60739e1b4fb8b742ea4147a2a51f5a1d794cc15d7d64283e4a48b673c46c12723bb57d828d139ed42ac64bb3d1c96b454087b5a08ae894681df7daed010593c568284e80f17e6504969cde451330486c89a4b887ad1a772ef23eccb6e2fb3d06b64509858549857bd3e353135619091a378bc1fe6e41e2bcd340869414b17d59e40dd5c2ca55b5c78328dc4188d2fcc0764bca78aeb861ed79c0769b84dc2911b26ee965a8500cad09a4219a0537cf1a6e2872d76be285c23ad27878a0689f127bed9ffd17b6d682c41e8f86e9896760e51269f0e9ebeb20c133e5f997dcffa20229b5c24bcf956d7853252c33ac80c02f4469b57b42531bac15954832e2d269b86a97fcbdaaf6234f748580a662b9e2ed238798c585d97965e458884bbfd31be099be6067d0ebd03a06e6b24f35207ed98b5abc2437b354d867314ce09f67f1f87e9edf3e65d3a706cd68bcbe246bc9cb49bd223e1640097376f77bb02f4dd986d825bc1dad9eaea46dc18d5f3fe07d3efd294893780f38b48b61413ffc535d8d4188ebb3a81ffc9ffe5fec92249c9a3f232ab0900d30fab6a7dffac6d7459d92b536a0073c614c8ca73e8094c78dd3d52a57e07910eb5baf80fad544b69fac1c09c978af110d25830737620c7e092ba66cb3a5f6ea43b97c1ed91cd5bf2481fc39d72987f6cf6fe1e2c69abf9fe9697235ff66a5f17bd23d2a31ca07b66e600f95735a19565921647047fdbf23c5f243327906c3648600db62fb6a46f6a6f55c3ac8bce8f823f5187b7b0dd42e2ecd324695f94b766845ff007bd50ece04840cda5915193669d00968f0fc238fac936deeae61a2f94e3963fa256f2d54350fc1e037a4c31b5e202d81eb796b3bcfc5cde0a6f1c9e025e27fbf83dc22b9fcaffad7822b4d1b531789ae1e3ea7dba7d7e82e7f2795af23b2ee467f110f563895ab1a99bc89768e773d6e7c94d636168a6797d9d33ba830508a4c90038bcece48db98bd15d2d0750bfed7c47d0a3eac5111dec17c05fe995f3821eec0963c7dd8f8eae3406824b25075c783328b42cb78d2491101becdfb0132e4aa8b54ade19d6046bff73ba32d8b869ea35c9824f90bddd98cf8dc00d536ce9b6a25fa41963e513a29c0f5cab7eab00b619690535e24e0dc22cc0469ed428cbac2ec52d92ccae494bd2fa9840f728383648094363b05e3b344588e59c8bfca49b1d44cac6cb887c3bd40768eecc56691191389511ec2e9ce2c781d554e3ea3fc2a68c5a694cdc37ea2ce05d069adde620e9ac75fa608cfaa3a34caf5287a2696d4ae2de06866eec0222b53b5946b22b35b43a959f796f035886ffc9c5d85fe30306f0f4c3484635f52cb66fd2b57a644134a3b3521a1393dc1207e3f9d637b146a87036177078bb6ca7e93843489a9c53245f30ecd445c4c70ab87c96691744c9e23ec4867d7a6680f9ebf1876dbb4530427247dc8ea6df90507e277c7a949165162fcd7c2a947b465bd8378d030b6da36667e31870b37b6941ee909fc0bad50d5d35f3b40da7cf3b701d631270d736f9c7b1ca744f9e0901a082c7b5fe115a5b0d32f4a96fc6bada2c17f5c56fe10667e97e373df19445de7164699c387cd83874b4f4938a8d27c17aa2794a0ad14dd11ab3e0c0de4b68ca997d48e383d9a084a00c3108d095ed508a6fb17ae9961900c3a983058bfb76b63afe48dda918e38eeea539b9572cbfc5eb89c269fdb2c1192e8adf7aa805501b5bbf4538a9392efd2496e7203ab0455b0f9ebd77d0e60c7f63f30af2356b26c88bf77287bdc0365c6fbd8eebaf998ef7dd93723dcbf4a30ada467f93bbb6c6764a0fc2e183b46c8dd93f4e9beb9464e09cf2a000d79c5207c9f4c394319736fd2f2f111a92446472a4b7e4541ba1c66ea7441b30e21f6a475c20c3ed50479ae1c73413ff6fb74c6a8e3b3dee72dede2248aa433599bee4417eddd211139a858d29c312297296633de58482a26f79be830bc2b46fb175ed53a052b24916a82277e37e6c13e1c6bc9b0c373515c7fa738ef20a53dc96a01f8e914082b0385f735883a2da3ee9da83914de66ff0c7ea3a7a9fdce06317ed6b7162291a21048c0ecaba713f763a07ceb852e99c955ade0c9fded8f679d6cc055a03217dd16b9e641291fbc2998c627abd4fd1f8a0c3163367168ddc5704263b75e4ae7da37064f73d39770ea3809f425b4457a127c29ab4cf784af81d41326c9fe6065d15a41db3b4d037b8e8e8b804d04c01055a04a2fe25ff972cbb129af9bbe78d5cdddaf5239c25dd2eead230a8d8dfc73c6d6be3e6de422e40ca4ae7b3937736b5120f85d2d205a91d8796f757494b8f0d146fd8533c3e090b62818aaa013606b10d9e630df2f71a349ae3b27540b3d54f354ac70d3741da11a06fa3d1f5181284e12d12cd3db5491a7c0ddd5d0b7d89e3186b32b607f2b6a7f37f275280a21a65e3c1ea67ac861edaf359c81235e56b49f5252727a8e3e542bef025b8a10ccc37486ccd2a5d1c3dab1aa715b18b1e00c70f3ec7952db827be5b64cd72040471d5fd747b7b8f86709f9c11fde3c77b4e7814e323bec454a7c5038064253ecd274173d01f55a6a12ade0801889fcf1923679bc398b25348a2f7815df12e592756e00d74e68016bb25f00c67e663180ca67522e83b1a239599b3f9c152134ac01d387b18cf35eec4dea5cc9afff3d20974dfb5aaa3e046b8ad098376ebd9d01e7ed315e15dc9c00184bd056541d6fc427882d114fa8fc7ac5eb53e9cff30e2264c770472c54fd20f97398907149e86a9fb55e15be6701613ab365b6bbbab48669e40a17d065d911e7b8127b58964c4513818ad34c21548300e356462183e5bbff77f475e52977f8efbcd48f5f346d0c4537845e6dfb6371c2599b20ac8c3fbd61df04ab6d0e99e9e5b7c6123c6b7b2e842b6b9dfa100908a1432c804211c8861ee827116de6233fe2024a768d4f23c9e9266e6e3fdbe3dbb982d55b8669b9e63130fe69cd63c85fb57c4e69e7311db5dcc5ccacc4d2316fd5b4d4471ad7b15bede1b4bd56b1dfac02819f9308ebb142726f3bbe3ade5681ae06736116b9709285518ae45865f21b4a634fd43cca988b02ce8005b84a2480745846b924f22ba9fa89b405df1d63a9c89e001c45ba52c805aed0619fc12b5bd57800adccff32ecd34d72edc62a80fc4fc993101bfdea521f2e445251d665b56c25ed74a94e8b5de3ba437d8a436d144800bd22e1f274ed6e23dbadffa864a14cf634f20a92a2783c122c855f578870e92c82bf84298293190e5b0ffc38c57c54d6cd7e870dc391ff24458a6d2ac58b9ac6a4eec453080c9dee02526b44466ff69554ee6e1295382bdbd687e7d976d24e96aae4d2be818451b89658179518ba116b711aacfca0550f68e02381f9d6f3f8845b8b4403192e3e994c006142c84b15881e7ce9172074323ae9cfa137dbbd9586c349afe9f506ccde065960bb9309b34fd9c27e5590fecc59ef16ee376979d418d970a1e67ef50d896908c972bc53c3aa0d4016489804b77bf217792ccb8b4da5737441f8621769a84b331fe3626c89b8f0e24cfc3598a08ff8a4c5f8e05d7eb99daaa60330352fd452b7e5799ae78761ed33fd432491b76247da429d5ce8de1e7139c3c14878189590494fbe892ab62a9ce70746f37cdd17e004cac7896aa34809f04fa1f993bbd2e0d29eff49bab168a1dd1293df18c7fa0397dc8181de15cd2d46fbacd1705611bae7f680d7b872e773b3bdc309879f9bcc7b3e059722100302a272daf2bf8f061891be3bb6d2cdb87028866d8941cdf0b7036b72fe3a7758306266a5fd5d8656a47fa0814afc34429efa5ece93c7f1757e4af5e00b6649c946381c977bb3fb3508853ed8e6b7967e066a70acbaa1ae966ceb3b82f63311d79b81b0a9c667cd84daa6e60ae5c80958578176a5f8a7c97deeac74ada7939e947445547208241968eaef74ef11bea13896a90985e226a94237686931b0fadf0840dfd77c32ae6b6624e494cf6aa8092abedd114246098078240eb7113dafec293fadcb6295ec2978b2a725eea5fc1aa8816b86ceba1d565755a6520a6f6b2eb1a43ac03f2aa172d4283c61f4aefffa60c3449284892de3dad11e2f23afe033b0e3b45d0e14235124de3ff8513ce8f932dcce6d00a3d66f343983afe9815d05e9af21f4d992a492d520aa6b33ec9e65298e72522c5648195185b4cbcbdfd98006074445567bdec90f3f8ef69d2829936e3a328c4e93287bece28e638ebd175987aba26b2a24c91da19a389910156968a06698817392ab1ad323fd873b1b54a6d6a44bd9f3ceea1efb4051ad5ce803777d3c22adadc53adae5150062dc8d6db775552d6754ac07aaea77799a26628fea1e9847273bf05dbc1a68dfd6581f5eb6966e168684071afaa5123700aeae03346eca3295ac2b6defc1fe26f9889ea3f51a24e41d6b627c4e15ab884aaeeafb0ff7025dec7eba9c1efa581ff74ca270dc16ee13ec61896536695de0d4cf0ee1d12df6931144acb72aa8a8c658d73b013b6389cd3818d591e2c94b267cca9e4f1e614bfc006ebe879811b03b4d2eac8de642859e7c5d4b7ba7faf03e28af188fe423b2b75139da9dc27fbe0d76b65915b0021dd61312156bdbafe5dcade7ae0f79bfd840fd6e4fdf9a99d40f010d6070193a7432fca2aef7769c2a6b1dd5ce0b97e204d7881b0cfe295e8c0bf8f1eb41f10c30bbab1edc55dd59e9015614feac5c0acd02d1c7cfdd03d10495da79801307bceb2cc868f14e2e6835be3ff9f2540d26e36cda6da56ccbf8a8ef5cc02b61014e2e7cfdc6f5ae6abfb9137d805e94ba926cbea6c564438074138b60fa4c8c6fa90119f299c56a6bca9e0e3cb5dab5293ef6dd9e7deb29bbcd5e69fba278e833343656fdd78e86d158f05661ca458eaf4248efdbeb9555efac21cad8da030e07d22fd0fd68bfe20310680a78bc4d02488523ab7107f9b366c0d2acfd8677f9cf8eb1df13cd9b094e497b7cbf527fa73b57b96d57aa6eda2f5af05887f2076a3c69e9ffdc7972acf8769b77d29aa36ba37e769486a126fe6e82ddac54c2cce5e73cb79e4e6be59b5483d9827d9e1bf7cdeedcb838651a1798a0b0665c3ee6369bff2994cfbd3e173f6faf0aa902ed2cd1f23632d63c4e94023bb4d69389229d65ebfb31b527465ce98253e85c3e2ce8fdd913a09d72b94aed1eb54030c7eda0ca7e62cfcd1a38e98474f7b6790ceb39353f6f45ac5c6077acf57d9c8bfa25f279998fe8994a8d85498d5818085c176a4751cd1cfe3e3e38969ab0d94359273319e487529ae25747e680ef4530cdd54ab092eb93db8dfd45e784b65b0282d2d51907ac8c5d89b16f018d1409ee7ee691acc8ad943f10938feef76c372101b046f5c47c30f14614b4e502a0e4550d629515ef72be7a09efbe5141a02b23bed4a5b30a3f6290c50772efc823a776bec75a5e49d7678a5627e62723ae71c57fd9e11dfddc6eb036a3b3fb222fdd8f1b883a51f26c710c6160da84bdf21f43e929a5d1f50dfc3282974c29a60da46afab24c3a1c3f2d509b8eacd6868f66c7600ca1b6a48a841a09928b35ffa76352102356971cd6c377eef9303cfa004e23076a37a81b202f4c1141134c331316de103640dfdeaceb117d4b10136fd7b082bf1506eeb37afce9015ce1369ece6b2dc7a7bfe388ca0ed97b6c66be062246f0fbb8aaf2daf9bbead3291e7673debd5683524c43d0d19a1da9ca1cdda6c915d3a7763ba0cf4da93202d90ab1e82eb1924b2c7928eeda89da9c0db3f4a63d6669dd63635fa1650340f39befd272014b46b08fc25400c15b19cd2fc1cee1ca00cf3c4d9ee591e540ebe93dbb945fa212162b96f4d65929b00440cd55734b2e6bbbb102dd173dfce23a473125e9ee4cbff56bd6c90ed3f37ffb2a14a9612a310013dcc0f204e39c1309da29b834f19328191a69168ad9e32e8c4d93ede10dcbc0d0d4e33c51bf56c9badbaccdad4c25897b0c25c55a5d939cedbf1a7ad8c5935e4e92cc646677aab0935b6981e739252ea253e44cdd509f481733ed2a9f3814c5469c5104bf76293a9d6b9752bc10b89bfd8f4f3cd9d9a523e183a89014cf17f05eb85b66f3012baed5f6b6a2db1a52eaacd085007cee235cf05dd5f8d1e023bc55f5491bed2d6a8b7c4ad0845f7f56c3414f867748b5ee28f6bcb34eb8e220874bfda89a1a94fc744bae11854480c6eef148fc269d3258ef4e57c8b9a20b69d27732e5b9e23f0cdd656c322ffc7bc5c9c29e13944426fac2e6b4a3f0524da2d9201e6b97c75aa936cd0032143db950f28674def2b08ada0969f812c29a4a43b93d80359aebc231a6955bec2da3eb35e839668f98ab95f22a391f7f5ce049e1d97dd8403fd634402e52c6b705f7f85ba08a490d4746da103a654be3b9d603c004143ee4ef143ea6b8ea2a00a6f709b6b6c4ecaa1f04741642324e8c95f4b0f26bc5a449fc1c32823e42750223677a6b53b81c35dac719e3f0dfd5de1de7cb10e74d16771af626caaa4d88a881695cf93b4dc9b1f99972ebf1cded18f6cbf1db7803a72ed653c0c93131180ac0e8f5c622d6ed308d907f98a56cbf3abef8fc9d746b14c28247cd197ca413253121c71117ea54c24721d556bfa16203b249aa1a872bbb1d3079337e921e53e7562c05964493a48b747bb17d6d8d1140ca68ed28ad380a8103365418e00b821af59a16f379b56942556ead4bea80a136a9b98c956f83a9f732db22b18f122411394607053c074749c72c90067f57c5b2acb4e6cfa2e6377901decb920954a4ed21c34d8b178d955fbde858d57ffd14f93d50feaa676f64954ad5545089e0e1c40eaa3527d07d0691f3fddb77ac0d30faa73d42a55b5827fb110bfb51bc3c79059ad14b5057ffed6d474cf37aa254b4caccdff4afcb61dc6284a66be3c6fab2cd7f3fd10a183cd1339dedd5fd055d350850aa99af18510d175a98848d69b0f7a4475e148327c2cc0a541fc198874ca14ffa0050fcca5f17a6e086425db2755f1cf2eb14cc074a63bd8f7e85a22873eaff30cc4a487ee7a476e0d358b1f3a8b0ce4cd3c5c8e768a7e4f16776e9ef126bb75cf6033fdf9ad97561797196422a585d46d868b1a4c1dd8d8b65cedc7d3c3b8b3e02d408153e98d0a50e0e32c307fd5a577034ea250874645091c3d964288645523f7f6236b66823ecc3b20a85527b07acf0fe81e4f843ca1db4c47149ecc3ca63ec619ff912bd60439524d4f416258fee6270d86dc6dcd5fbcb88077b2717d0e845917dc93db8f7e134d65905e88a8dda58534ffe13bf682746a99dc310362d802d216ca5e10fb5f6c7ac594c4a5a55490b2e1ba02d9124d828ca9d5b0c7252b2977748fc10bfa5109d7dadf9ee0713902fe0848f6824e25e63975c5d80812e604dee78c73572401be2cd4a5ce5f7d5a9a58047bb98722ced21389f7363ae17374f5d66bd5580c844e39d825bbe5fea0d8b9ed65a1e4524c4156c77b1961e11592241b5815e2f8ba619d7fd17bd2a3cc9298d4adcf1e7315f998418b5e8a95c68113ff45caac67a5dd238a12a75efc2556c5bfd9e28f7c65cad668b198bfc2566b3f0573efd8804f2b9567825c561d11072c6b2cf2e4950af434c639a55af89a6cf44dc54c783f508300e13b268b047679ddddc8d1733b229f484fcb1b5035bfcecefcc198ed1e28fb68715e9d2b513f0081a72e42484b184cc7753ab7e1758011bfd32c1f9c9024fe5eff912351954a06a65c05940f6758eb1e135bab98590e905e4d1aea57c225a920320a55ee703df0ab55a9e71bd8db49641da4504ed8d1a7f607755f4e42b32c6c09fda701999b5f55afc099b5d2e1204a5d380533abe64932b6f4ebbcdd61e2c51f4c590973e0a7518a896e3bec77c003b44d2ecfe279dad415b0e08f7ada4226b217654c61f656012ec74b1bcbb1ad9601d4331dfa6262197e088d0bf9e61e0ab7c518daaebd8a3da548e82be60e16308427e1f51e67f65910f7a2ca3e2406c822a21a9a8a77ff1530976f5a36b8ca296d93eb11213131e2e12b111af60cbb20989edc8f96fb4798fa6727686eea3bc538e2651de3b3d8a449f6589d0ace1b00b662999a3d649b3048732f0f8b5792ad9120115fafdc264c1d9cd77e103469f12e90346c5391427fd788fa83566ba8d37f62c3c48fe0db83d090b736b153bbdfdebe44de9bd7427657e1d8945fcbd174c353fcc3ae8f8833f1f0049dfa3a8397ec96d893c4d618ba785f04e5a5cc865b88cdb345855167987529da1df3db1f45d731190be7a4da9f97bab913e3c6f015e68ce635120821222f08e83d2baa1edadd463f60927f4b235af83083b600cc13ea5ff68b9ba6c981284f2fe85ddb777e0ceac8ee6b98f57489230bb98555374e9e325f91e0316227b3fb84a870ccdf2cfc23146bc61aadb76845b4647e77f66a9ae5f9964d1108d7b86311ece03b7bd5b3bf07ae48bb1e0a8cc6e6a2ccb65cc0ed8d49331a1e86262ab26374a0d86a3f71a8ccf8f42d57db90184497ac9d15bfee793fdd7b46327c69e2cd99c0dac1fea535bfd433f155f8e1ca4cee915e45240813f162df7445c27237ce8137c1ada5925be51d1e41bd69127c5a147c55983b5c0dd6ba6035ae525249ecd7bb746c73360af09011ff797bc03fd4e0b231899295d5be4deaa84d712d2429abd8c34287f4344271eafb540333550bce4bfdfab249dd5e6ae989f715e673903ba505a37aeb33f0aedf0c666b09e1d0a8ded4c8c18feb37d6b77869829569ccb791682d5e50d19d50f57182a3037ec303faceb890fd56d71b5ed6d57d7cba579a9767f74515c2ca7f290e2bd36f729e1424ff8e34fa0208e45248df82142f269df54d467034749f8c6805afd294f847322dc8fca810f48c2be6d029f81cede1cf37ff1f610e1136153bed3e326d1ec3cca30c2ac0de5d8cf2ad54273c6c4d6eab23b16ccb449573c35beff6e68613f7a01c79e80701aa0dd69b5d975eae5b98d9c9c733cf1ac277736717966e706ff6f876053f12c27d37b099791c070c34ae9342bc50794ec82750a3cdcf02c4de8e09fcdfe8125b418b810aca6de8d8084ba4111f26c6b4a01babb6e1f6208c1332a235ab3249bf2cce9fb4ac4e7b3d7b3de6a148a90d6875e8cfc78d20a1a456c2790412898a561fbb714e31957da86d5228cebf5fcb222ca1429275265056df4709f1bb951bdefdfcc4585b6711191557ffb5aa7c2daa8eb4ad6ff05ed86f41682f4bbb038e459fc6fe733e906b577b83447c07d486fcf162473d7a1348b3a902faf175390d8d67c2438389398c3584f604e5c86b1fc5e8c3f99ac155d7c177e86617736e0c4eba3e7d8950b10d815a2d0ddced5f1eeed5541ef61ea78a9fddee3fe44e5470e12d7eda0fb00b91e53d9d47f2095c1a83fd1e2d0f0bcc7c5921fdd833ec4a1c0369eae9708ac6e2d927cd2e6b071e07d72a71f5ea31482495d81597736cebff896339573e8ac51d4de84fe7f00b07823e5f6bd732f13c16abdf9adecc79e4f0a84b428b159e663556915df014a1cdfc98d6a00aed924736361ca5a18595f89ae808b74657e39fd3ec591e898b7c974d25e63ca98afb8004ab770d4a31a9a440f8f6329ca43e68e1166561031b81425ae7af9b38fcbc39082386530448339f981c2242e8702d89d89d6c85af9ffed34c5cc2eb9a0eff605f1be1164bc95fc60925208e785f90465e1de21ce11ebbaabb0b62ff94902c3aface9693b985a5779198092dde6320ec84d0b6b6537b02e13bd9c7e2a8bb6e7a1e79109cec50fbde50ff4b06c03c0cd7044c2992dc09aa8d04a9240894be7a4986a3155dc70ced7dcf8a666d1c9ca5ba6cb8c692f89837e62c8ce7ba87d48c474d62cc454d4fb1241d22aac51c7a0e77844e5534cddf18b4ddc211ec3628d76b55d79da82c647ce4a28353d5942f2683c529108ba7440e330698ef60b73b687541cc3ebe918722b63f8a84a0b792114aaefd48383a8479fc65c470985ff340261f30d5f2e9dbb8ecb574bdac5a137bb114b85e9e4d25602468f091a7f01ad01e5c7f18f943b9ecea8ffdf5c567155eff3300c8c8d571dd68e3346ba7d5bdd44fed075f628d6d83e7de410871f7ccaba9eca8c571d61bb0f9d5e86d38d8b4fb8bdf8ef4769a09580062e0bee21dec48e51e60866f3500aae46febb14420d48e98ce69fc3f61aa6ee9e07e809e939a81c731fd85f1dfe5f73714c04b595f574388cee0811b2a1abbda0b476eb74c28d8ec32dc8a3b6bba5dddb96cae70e3064a1b7d7bd80b27e9175c22828ee9d7dce4595e68aac7879c2b119f1239b72c63713b0b18e35c9e6eccabc836de741013569699f283a9ad8a0ea541e941eea88661801d86fc28e837e31a173192c130c6871019e537f12438181730775c5b1fc80b3b121cfe6254f730fa0b3b5578b46643c7f107b20a00e5904c3abc2c3680806edd0cdac44813037ccf50d45ae44688acbae0a605e1c173e984b4edef338d559e05b3e6ae3f7734f1618654047b7f024d7306f0e8536c7c08d923926e600600bef8506a5f8a4028d603c105a9b71fc50b31ad805957ec84d46f02b9a84108c39a65a96b9683013a54a390a283c258ed388663b8137b7ed54cad552bfdb2f075bbdbcac5cb661c5964154270c5c6b30a2a452009afaf0fd6b7bb4d22272f3ab95180b418e046ab58104b82de11ee51a7199c0039000bdbbe23a71cb2fc24a87848a048b70bb829ecef5319ab71be52b710f8cb122ab91575e754e5af2d20c07ac2ca445a450bfc6d713091b48a77260e18fd4810ad1277b74c65c7312c4a8b9dafcceac0b7a321ffbc1978b9eedb5acf92ceb73bce832246e70ea7b7978505feeed74efd74ae7e2fcd01e444ee47d48635143e808853be473f5e45eddccff63c549ed56fba7228e38de10866b21f2dbaa7803b0157ead329ce80d59552edc5f573c57506f46be226bff11da67172376ce5951f4a6782fdc6f7037c24bebc85df0276d68764f4ef2486ce00cde92a9e3b723990429dd9cee131f84422ca8837628f97844124f584d9bc364ba9726647dc97a8cad577a9e3f08d35160ad5290d10f29c4fe8f73b4727c194ae0cd70d74a4d0a7e9d9ae00c0b4b5578fdd61f3e4a43bb8e3b5f8a2bc9a4d0e51b921aa8896e6644dd0004c95f1dd4880ced1e88c31844eb966b3912cff09ac83d3e272903b92ea5d639d8610d172e981df4817230ee36c2527f461f56fc1279c5f11d441936c8218737a88b62bef3ec339fb2e862e4a1a288e86ea6b0b5ee0cf10b3671f5db5d287a7efb1d7d5095edc9ea2734143452c782d8d2b238a6f0e384f018cecb4df42d91a67314e8fa237104728a554561aceef33cad77982681cfcfb67b1a963ea152b3ec45afae441d62c4c11aa5878dcf9a3734b900d2903aaeace692e04ce612bd5503377c52e3dad33b9e33c3cff6e5539b945482c856ffe57f0e687f7b559e538a777eec3cb71a63998585b24a2b087f894c888c65924f1232859405226e57a4e463a9db3791c8182e4e08b5e76278ae6512ae6a152a6de4ba3255d68ba3e2c30091a103c1834f0c96dc6d8e2f0224a7cff98e87a001d5500fb3f724d0c2ed9bf3486b1b96b4bb6acaad50c27890d49850a67bbdad6387de0438f08d7d3a4c2285444c1e530add864a747be9a9b7df2eb53c00865348525c062eaee3cf4919b54fbd6e03dee70f143984fc287d4915508e4e3dbe3ebaa5802db8e549d6287b23bdfedcdc5d2eeaf7fd0427807bac658d94fa88c18bf863d06b0fd7075c7654600c116f4d25de5a37237ff23afa8f0f5498ee66b8bb62ade6b7744e8dd3d0bb07e8f2e52a537404063ee522e87bfbaa2884c4adeffe111a36af5bdaf6cfe7fc3d6d444b35d4acafc97717f4f4b99bdbb8377758d41bd5abade822b082a63dd1e271e0b123255a13342af5fe34de283943838677debef588a62c5db3bcd35db65b4f8c39fbd4a383f9d3a6e202c4edd54a0d3b03dd8bfb423157d620b3e916fa4f9139843bac2cc5b837afa6d877027fc4ce0e5f5cda22e16d6b2c4387daddc17e440a8dcdd4a54409f056a0d50cf2751981e83becab8e88138d7126ed343ead64a550be073c6d39b868663eac0ef2945597694810195f5988df5198cceddf8e20ac6cbc4762a37d383a93447b5d17d827caed8f0649753f4e7e7436357b05f5308b5d5e13ca381cfb7f5115f26bba0fea9018c6f2a9f1a3509d45a8ce570e6dc35c1c48bb2f2a913dfaed3b5120e1d0a6277cb16bc94bcb243153730d92a2c798c762c3fc150abe20e22e54a9bef836e841719be1d1566ee19da2bdcee2cf249275443b605c50b899286ddeb03f78d23f6cd3be2c0de822c69424ab6dea93d132e43630cb289cccd3854a1ceeaaf8f159d6a8cc120d09e3b7dcb838d7cf279e8f763539bafff0d6951acf2d8292f6514bc654714940a4ede266f5f6d6378b68b18e6de3e7707b18739f5e3a5d2c0b0e9c258967f3d9aee2c25b551846422ec3ed1bb549b36b457bc38c0e6c342890701c41fbef18d1dff2c5af7c45b1e8ae98016b74d8f56246ee3531840ffe3549e30f8098bf292b4c41aeddd83713f5e53c6f37fe85fbca59b4cb0ee64e958e078e9ae5d5375f5202962371cd7a9bfbbbf2b5568356cd9e795fafdd6dd7655a02cd1bea650d03c52674f7118a2b30117ac746df9ce11f810c5dd94069cf7bade9ef7d274fcb2fd65ec2ffcd437e0a7c9b6bcff96be884e3e2683f61c713c476cd18fb140c5a95a6511b009ed33542910676aff56e3f79e11b88a00eaeb34f4df285ff744f5e5eddb92a23dd345b8325207f959b8f37d08b0c3a96d1faf7c28deafd0467f6ce18cf0653bbcb09cf7dbc93728a7c6789e3301baeee1bc774e832a21f6b64675ce8f280e9780a42e3376a07648363bf03d29693bc71adbb827b9778625870d038f8bf5224e85961e6190c2ce6d856669554ac9a7e99cc66d65807406bdddd4daea5a87170e7572e51b3504d53895e4ea5c3ba8cfb9c788dbde77133c0027a3956bc82f759591641a0a9be69b60662a5257f13c7d93fa6aec19ffbbba0ff37e1493967c3e5e367e52df61af362536626b51b223a4ceb5de61497c10fd7e8ad2d24a26098078392154087ef98741d35a0a1665bf11d35f48e0ad99720e55057ff70db7b3fa08dc3925db009922140e683176c1d635819bdb73e95152956b9dda415e51b13a63ed9800caaec46a592353d7f4182cd5f865cc6240d292351df64c915662a12e9f0aaff7951015b7851cc8ac71c607487c655d204f294356201055cbff6d6ae229eb7b9de268e00d89cbd9f08a9800efe9f8522aec1dc46850e80a3a600e588adfad29cc7f24346042c8f256b4f0a25e327876786de019f95bc71dedb28305964b668ca08963538eb5e9284b14fbb78c4555ca6f965d6b68f2e6658128fa7b04f3ed232f6348c32c01c325b8a319c7c15c6dadc14fc023aecbd40d12e2547e1eccc72f40ece9ab277dc209e33e3694e817b85e1285e8f93cd1c337218b11f52042e9906471d09c68c659068c2d5cbe35534ecbcde7cf4e7892393782a01ffa1d37e0880f750cd8407d42c0c0600e9b6d9adb1d006085503a7fecfaf5d5b5f2e0ee3118f539dc9bbce233d1feef36758134a61aa512dd3f48464c0b1d0c2a6508f478cec9b18b750807d118ae54b3c84ce619050dcc74b6df1150e13d797dbb1536618ec656595e7ee67884f8a432704dbe213a5cf0c9abde55967eabbda65924c3d63586f5fa4ab096103b3fd93b851c54d06c40dc89c5f145e6d73983ed7c9641418e03bcd4ac562ecbb114a4fdb35d6af567fd62d6e8c7baa99a722d79b7d1b10be4a94008f2109efbd19a7f533c810b2f57ed7d52dc0a7e3ab0b203f85371877f6a5509e41cc3a035d8da53d783fc2565d35c48374357ae876adc3c6c29a24aa920fd20104cf7d1450d21f26a1f00ebaafcb50114951318208e315e2d2c0bd3121b6c0d39b537173871e6cee3e5f2681e59a05194df4e0196b259e650b949f035491614375ed5c7c7c5f8c4ef05965c8ed8bd932a14673116d4ef0628515dce606e738ac436366921881532b144313c26ebb68f33489b173af6f5b8e64d9cd332ebfab4b96455843ef071464cd3e8f62795d1a056f71eb6d105d9081371182a573288c137ab16880628aff5c90dd986623d59e33ba9cc8e1655cecd7a0e8149f86b8c5aee88d4124e46dedbf36f4c6f958dfaafdab5f9d802983ebfd7e5832c30600577eaf0a4abac499c5ddb59429e3c11ac2cd4f0ad9c0e0c996b1ec63baf39c75a72d4cdd6e5e4c875e20aec752adeffd73a498ce3524693ef88d50f58045c8b675e8c343035140e2d2e83f2dcac8c50bd1d180af1eead008c39355aaf71c7b19150e68cfafc1b514231c71f3f0d71973d68fb215fb604147d2f09d3164771843af326d78115a06a13f37eec027c73e8690cdd3b067ab1d9a6c5cd7063fb5b3561c4a46dfb90fcf346c1c7a377fc744223e6069c9b9dc0d95792ac30e6326faa9f21e6d1c11faf2dc355e23cb5b051ae486289cde69584593e4eeefe3","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
