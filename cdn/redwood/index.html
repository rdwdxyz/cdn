<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"25588f789926de0c6ddc02516f9e86140122a8dbd81502a497fea683c94d6410517d0ec8ca62eb17c5d8afe0ec26130a88f87b2d45d976e5bb24fd8aa852e25efc64ad7af34b660f057e03ac143dbfa795ef0adbf0376fc768faa365b64e9852e14c545349a87b66067e19a1ec79c21c60e3b74102647be60f57c7a1cfcf999cbf42419ff1afa775e96d2135f246a8a74f323e0b6f9114a66ab3f3d7839e461ffe124b7148949b33a10d67a777934b823d2e48a5ed87bbd5350891d4bd7e022b9747cbb72e03e862df4d55b8849413395ac27f65d5f2c60d3d47ed9972f687a054f6992fbb6a1980a63eae3f133a08bc979406d3e18f903ebb8080bc03c236a402fd575b9503330b83503b66d095ec3e6921c14cfa8451e27fc994874b3fd3d4cbcabafb4dacf11c8e49d76661943e5f10817f6cd9cf713261726521eebb60632154d19b0c820a5f66060d8abc00df6262f47931e69fe0c6782b6a1705c4c4385344147e735eaff91129f9d2939e4d612d1f57cf34d7d78849cc83a95be24394fc583cba4281388d7bfe7044d46ed625d61822c3976dbdc6d28568490ffeae134173669368fcef1163fd25f59514bd9da826d714ae0b663ce6a44a3d120e0ead9146a18dda4fd3d9e4a5b18a5288e62bdefde59a1c367f13e4f03f6a916498a8ad78be7a607fe200e77cc15b7ab4bcac0136abf2454066fd3f6fa226c5ca9e08bb20aae2108ae15a82499fc20a9def7c6b62459e01caacf60a8afc67f06dfeed51024ce34b4287d75e403931267f25de01f1ab6b03975c6c6f4a3074cbb78050ac5308c0a373f0cf046a4e1fb845fb78e1ef3578b702a68866f3be9f83566fe0be15d2de8d8ed59615528a6fac4a3f7cdd7e7a2b7ceece0cb010eb5b04a3644bb5ae9d11c069efd9b934252bf73aeada4d47f29ac7284f914c38bda2fbac31320b80323049e49dcdd941892ad37f5a232c0fd7aa7870d63fb29265802adc27219131dcb447fe00b4141400a4e44827f5e81354f11338d067a5a8790c3c4fd458f515f5e8c7fd70410919c2fc16d0221ab2652f7f58b8def61050c7fb01ca648a9a4c39434922f7e02795888df609e15a2713fdad0759ea32af62ff9a86b7c1bdfbe512ba2d7bd61bb45cb3f287b7fe603ebd0f18a72d23bdbdd9186f1d81e015b62d0db003a3d3913ad345c49b81eae2ef437bdc910625e40b6bebcdd63524d370639737627958d028334917e2c5b1bf2f9401f68a7a81898efaa03d7f01b06be7cdc7c3e091c90672e594a1c565f1e0cc5271104bf90b2b0439407aa100503b7db48bb937d3cb53f69e4ba267f2cf40e8f747d88085a532b3bfcb8a16a01898685ded4ed0b3a6614cd6d3a3dfe05dd471171fa0dc88bbb481f8d90db093165636328d44bf9c24758e040c5e50e79eb2de0c20cc0c37486c675aec4c1f5e4028329dd67edee45cb1baf26f6b9bf6d5ff69d42fc2abc2f16138de70deb6a1793928d99c5084569df492a149ef73a05bec8d06e148db727a8d86d8a47ad82bb4d08f10d285ffe8069e50c5b0fe6a25009fe2b72aeffcd0cee3f35f20bedc661d178db5b7a7ed213d63c2c983f95e20009d44e3e74d292f1395af61618280b06bc94719268785f662f968d6991a15e7b94fd3be31ac166269eaac869049dd16af2fb327bcb2573b5d85cdffcd2f7204e10380afab5e97b782eafc3a993dcfb8d9002c2214161b66534f8f61d2a0c5a0e864ce66f43f4845372964805b97903618853228b3e6c49b3ac800024d8d4d3df0b675b1439a8d5cb824a5470e30a04ee57c3730748e0f54d5f1f8a2523c36bb13f5390bdf8640f2fb8a5f78bf2c1137de42bd37fad250b6f03ded0e5b121d300bc1d7d094ac00a5131f5535e3fb0642869013c10e6714968c8508427cddb48ce732d18cceb99413b2a0fa7beb1f1cac97b630c36d78ae5cdf16af2ee2e7789a2ddc075bf67886f402edaa573d6095af1eecb3fa4b1781646f691414150ae63c875560baac522148c5dec79f3c40db5e12cceddd7b3f344798373cf7ac595f8af4d32c0d7deaede28cff40ea84e5620f60a590e1617862c396f9af96ae5026f45d6ecf85fffcc833cf59f440354670f9af8f7b1efcf70357c6e24a0bb64b078608cabdb2ef23c33fb1076311a729d768e8fe766ed75dec0a400cbe5bdbff6e5e17adeeeb2b01cfba186c78324377b51ac10402b049ffea4f202b36223712d59fe6bc6aabae11554fbfc5974108b54f66dd43b4584da09063fad134a2aac8c040591e2615e9853296cac197f1d5c6f829dc7e65c132a71c78aa5e4a97eeeec085065fdbc082f38a41ffe5de3b81c3809b3cff4ddd2af77ceabf22ad6f96f593346aca27de830b54ebdc7224f7b94ed7580324af1cfd46c8198c96e98612b5b11144c6620593ce451ba0c19240ba612b2576f9d9c4c7805884b779fac8aa9112300e0351691a6ac4da4cbaf08a9ad2600326061ebdcf704d226d69e3b88f20f85990d09438c0a3253a06c854c0e32d021746ca7c0fd379fe8ac26475b89cbdea920be1729ae1514c8a91c8344dc73eebc1fee92040be2a5614f5ae2cc970fac64fc1d69081ad7e697e1d4f0f51cf0699f42eec9d7c086f8957de78ecf919a232ef1d06c322974eeafe63907c8fb1373cc9253d5cf404d1ae6b8a14f12247d50f79d2ea08cece2d4f325c30ee8256ea7b53c6a39b8c512cb1b8b90bd44c646b31023781150a9a5d5b113f378c7e355f026f04f6d54cb951ab64f375d8ad4d0a0610e03343decf0120b1a18e1e8fc971a938b42a778e8714766fde123210f4f7c87c666202bd510d188f098d05d82ae87358ed56a7862da2c4f45ddb88cdcf3642a6344816ce84873885e8781e07e3aaf68b27b809f7708406ea825485bd3e87a5b3fa7e7c701d69d2c59fa889d12d002e7997de1057d820c3c1f1cd7095207aaee7a08182fa3c386d88d58ce60d8c82ce1d6cf023255fd90680517033817cc338a20aaaeac73aff815c5de98d9b9857697873ca9a944ebc891ecabf70367aea3f7b3042e1ce4eb066fb04142aaa9d5c6082cc07c2bb568a3c58c1542450591f5c6701a5f512f6455515214275f48ea0d9de7f4a6569e5bbe65a5a820295b4dbe9713ba26050daadb0a07214bfa7ffcb261682b6c57531304b3586188180dca76e03d864cb5a17314a0aa021187d65bf8e00279d12670031095809d2d7f727ad2c5a7a89fa1436f211f3fb710615868eaac2b764493f7e454f5e489c4a7d9497703a1f340c0a4c212fc3e53cf8662d879b323ca6b6f54bd5653b257d79902480aa5d8379b7b668116475dff7bae373e55ad6f66071dd7db00ea2c4e47dc27768a20d5fdb14bcb7e9a357e80baf6c93f2a8ebf64bc3dcf7879f5672d2a14dd468fe9561a13dd306236dd47db88995a5ccd1a3453d61bbeeb140ccf4f297302d59faa9edc7064916cc966738f69b0cddbef878d14187bbce0cee9981cb4f799263993cbf0061724d28d35c713b5dc8bca77c752c180e4147cad37ae2099fe22a401564e9ff0cace442fe5022f7e3ba3216ba5934abb9a24d9cec966c96e23cb4400a3caf37e8fccb73213d071c038b82646704f8521e5df839bd8e8ed562c4f7939ce7a90675ac547c76f7bafc0674e6cbe2103ff8d977c388e4469b36c14f677544ffe44254e3d7f13c1dc3ba5e39e228642dffd39456102e49f43a9902a86f292a8de5fac80e0a61f214b24981236ce3515bef90c5896b181b4793e590300bdd4074954d76f2afc171623d1343bab1d6bb607995efd067fea1e0e7d100ad047fb354a4218d701100d4fe7084f2757533871379c984180dc824b25361050a53dfddd0218f28b7f7623e910513bd4d27cdc04ced51213f6b04544afaea69f3e826938c3c449e172d05fd983fdcfc8d970dd3db94f309e7e304f574ebde41040e752fa3792f7e30a53678c80728a80a4b7e8089bb5ba5394b37d3b9d6a4e414cb1c61e06af7be776140a9d2246b2d5d8529fd864bedf82c6bdd6ddea56c070676f336b65fb6e104711e9b65ca24e12782432b33245929ddc865d0c68647d4f5c7ba63691e9f99063cd7f2d5fd6798102322756e6cd4e44d95b05c3e088658a9659045de039363f43ff60d26d05d798f82bc6758dcb6f3bc2616ef70634fa2a3a479445d8df1bcb724093fd6e148c3e47b201fb20f404e4b706063b11e999a5d7442072eb0e19f3cabd7b3a06789c5582c02382e75d23562c111c8a7b7ddd97ba6b7a8631f2d3ec6a4a5c3b2fd6f74919690388bfce71d7f6e83b6536cbb70dfa63ea707e1c2619a928aae79ff8ea9b7a7463c3dff06d477eea1f34bc7135230f68c508c1edd82df7254028164ab8000afb462fb35a1ae85244e5b30d1e781792373e357cfe7b583914d70413c7291ffb663e5cea33828443f25679be540d53ba471338f1f86476392f7bb01481b6450a4caf1f7b570518d96568b4f3bca85cbd906051a3e5e8f617ae5beb9cabfc11be0200bd33e3673d4ce68d3092e7c73c8f1e51012df11afcdf72c62067aa89e27fe17cf48ed23f26cc06478529843e5c05bf1bf841669e37f2fcaf9e5de8294eb9e8bd05ac502c4b8fe8b27c12ea47428f3b86e09ffc126115d4229d1635d21a7c02aa32031fd02522635d6185cf8187f5c1149f590ae6a4f964e2989b78ef7182193eb04ac7d5051e946f8e9a1ff38ab1770de0929510ede85c468bff7ebee2eff9f35454478b6c4c0204741b872d313c43b0d680ec61e51417556fc737c5e74af004df9077fb7096874101d96260b25581680ed0247d7ad0cddab57d28f380839fbaf459bc3817d73ca4fbd707fc202f93eaf4ea5186385fac14dd630e201a95b136a2479a54b6cd8fe23ed2223a868e9041bb3ec5328fb2ce3a98355b65a5a7ecc1ae6b14bcddae04e73a77c1cba84b9384aba07ab6bfac5d3529fdaa1f4019619f502425960c067b714d71f8019d3f834f86cb5864f4e8b02bd36a656ee22a69f9bb7623032dca8ff985e41919770594260636f218df479fdd619ff7d810de7ecacfb01c5f0d96d9bd2f5cd50ad8b7057729512e14a495426b424b98e4e19d57cdc3ed8496c6478f4260fd1c16b223aeb9b765546642711b47f1f3b07513e1135fc64a609b8f0e6c342357ca5f299b6dfa4711c1d30625335c762de1aec93baa6d158612d6fc54fd5278fa7012f7c822774383d5f20e4e952f729d68963b000dbdb27fca39e3c41ccfa0b2f915bd4c3cfa8a35a4990ce85cade157cd55bf80599a13f610ccd46e6c1169b28a901b945ae7b2bfa55d509dd7c6a4f60b2b4d569cb21db578b5bde0ccb64d1928a76ec321ae9d0413aa5fd138972b24e723c7330495665c85fcbea3618161b280f409c3347667442e8450101e036b20432a5977aed916ccdf3abb1632d9c1a04572cc242f320386faeece4f8c8e5fe2f388c64c3cc93c4452896e9d2bf00b2033eaa832efb598ef8dc26a32eedd97361693a986a3871314369de53716b5ac6fbad9ace6adf346a6a1687c62bc02445e5361864be8c1469b07faa1e856d55e2fb91180bce3de641c4f6fada616fffed886b4df41d278e88a78d7644f70883c88a47c6923f2e8f906fea98230117196fbc854f517a9f9cd2a095ba815b69c8577e968a978682c449ecc70af1104c85cbc7e7115a088c8faccb465805e622c5649509e4c721ce9aa726af60c0b7546dac511538979cc0894cf5980dd81efca49226c94a1dd3577dcd579335996706febb58f6bb1d0446f8fde0fc82b2ec8ecbc73902d72774f97965e7b59a4379202f6891245bd84d51e73ed675014efc7ae745f08af0418ee64a9b0767f4d536a238db429d93a75f7df819a64eee799b93907f69bba5f99e0615319a7a1f7b21be171869c59cbfc94d5139e3f581416b8a15adf83ec5e1a08dccc2277bfef14fb2e031fd52d8f4993982c919c19f117b6b5a4fd57e8fd16a5376b71de616c0e81761f372edb75515b648352fe2035abddddde5d4bb4b3551998f4d93e70245aa7058999d597b5d8e6615cc4defe895ab0689a52443d05d09c75917885aa606f33ee79e84c572a89ea685687e7e2a19fa70226b10777fa7b149e9d3f10ea06bd1e5c5e78dfe12e9d1681ef7d70671db8e54b19b07f5447823b470c43ec5dfd5f3003247a9d16b20d8b57d82d06d2b075661c4a0f8cdb362c799690e389a5ef5fcfb97a24c4b095577bc1125cd16ed371f5071724d41ba9b7dd755fcf6ce82f9fc582d522200aaabf0b321a8e3a1e445d6ee88d741c53571eb02a310dee03345fb8d22d12787f3ecf1faa1f86d12bfd4432b2ccf97324bbd1a36c80366a90bfc48b18c167f65604af47445c7a802704fee708dfeda9a2fc0d992530ef8963b42ed28062b8eb4d59c0273b830f97f7510886d83b6099b557d9e084ab511314d18b2b4930454fe5e23813ee8d9c95a76f9a54ce31bedf4e27a4ffb960784cedefd5369e1d276ff34398b1fb3cc911ba09a080a79bd48ed3084c13d99169ed185f0382935e03dc52f082ce8716f6b319f858f09f9b68c07dd3b425013fdb28170e2c3d7263711889bf130a5eb0dbde8a1873b02d4b207b6bb6b3091454a3a2884262806017e0941dbb430d0d2e00d1eb7bb14f062d6332b9a48ec4142d4983567250d0dfa7482bbbb3a87400ee6446b7a156b67263d922bb7e0ddc72152b255803af222035095262bad1c20cfd8ec214751a0308f84df5e2b42e7ec100da3ed3371b738beacc76df18c7a7382c3221d42492dcbbed2b7725ee2fe4ac2defaa9f8ace87adba7458f092d15ff49d118307d71a8f8d8f5f3b1c2f85a869c38a99dab8e60d16a2d1a9d07e3837950551e6530ca2bd2c188e7071feafea8ad13fa6b5b776d662a6f7435985bc66c43e3d11015048a3128a820966f928b08091815448f912e8c3e8ea5e4ec9e7a39771fbd4defb9ecdd98cda6a37b8586d09eb338b5baff1a5a40b8d875cb7f8aed60bb3284f7acea5874a47ee32a960506a654eb57f5a94ad01571aa3341fdbf40f8c7899b145a41182d189ad999f8470afe0555389ad3bacc336a1f43d9b53637bfa2ed43bead904c422dc1d5e6012d072ed4ca8461e4122099cd743325c0d03acc94105d9c43a6322c5281bad23d2bceefd641e65e62a6b52d2769aa4d63df00db58c121de5b86aa542cf03d29517378df00b175c184584e48c9302e45e01085a85d5c4057e87bc566f62a7aa5860c3f0eefc24ca8faa16bdbd35b22526b790eef22162f5fe3df2cbe6b705984e6876eb334dd27b5ce35563a8ef2f9fadca2aca1647956ef1440a770cd8684ca1bdd608ab23a8039e75483ef53810b56ac75051d4032206faf2e49e495dc1b1d4c628f71043677ac360d4f9db8ac3c6324da5e7a2868758568f3fe25df7741bcacb233970e617f73caea7158388abb5be755d78db0ab716473beb0ff34bf2ce0df346149eda44668c27fa605079af0c3464d6a60197786aadefb4bcad1acc5c1de6373296c935a90614d6da838dc2b3bcd775751a859132b996a4f9daa78033703b9b978f38b2be9aa670311560d960bb6474a3d3573bebba52db2a9e4bae306945f8672b91e12ff9f01fa3ffc4af7cf8dcb24df77ddd5c5a311b39301fc1772b61601823de91bf51a9599d8c48e9cbcdcec29e18c68979334f54ae7a1e38248034d8d6185fb29107987577d9f567320e7a907fe4ea70f0aa2d4ac962cc827cc7d3deaf464ada32c46f467f88cb3fda46bbefd3b56bf453ada3cd7966ff09ab8376b90426ecb4e7cff61673def83d901bf486518376bf41133a1226815b429d34384064684fe01743c2cdec2948ebb8f58bbdc3262888d2384cadeb6109072308b3244455a8c58fde6d831c54693666d139fd849af03dfe65bf1cd5ed049f8eb44099c8cc96e3f22566ee8400b68bf5f8afcca0c66d917c678073c21b7808d4a13040398585639a6c668b2cd5d53f2db4ee258c6be134cbbc7105dba40a279a31dab091abf22fdbb61190cc9d2ff14be6948a7c124e3256aec921e29b678b55f66717b800a2a775b9eac9985204f2908db98ab4a3ede7cfad0f6907e188c7c84927c7879c321773af7d68395e667dd1da15d2ad64e4b1bc7f4a5949c5feb8adab1356f52a90a0df235264fbe29ac4d8187f120c451c7f0dacaff052ba4f12987b9ec0221691482bfee00c6553b4866fb35fa27ee149ab75ace6561981caa1d9cc548a6354766eaf5e794dee1b143d654707869c70042d5e3bcb9bc3726c150a32a1ccdc2e82935dfdef4cc1e2ce9171ec700e870f30068237770d5712b942ebc3b81207739ab659ad9e8a9c8eed44bfe870fd7fdc091a11f4ad513aee45cf2d4f2224a1ace44a2a33ca3c6077f5172a0fbbc93c08711977cc073ea7df53cf55b1af33d0d1cb964be68bd1547c99ba9e39440a2ed3fe2aab6b8db3121f1cba2241e19bec69693e8050ebfeef05ffb3b19974e27d0f59e7ccc646c427a86d644cb3579416cb9294df6d6e21fc9ed63366f1fc81b3b12c0802d8165ebf73c36d31f222f7c7858cb23b8c1d1102edd5eb1ea7c6dbc7f308bdcd1d3feb5198b4a3372f78ded102e1e09ab6cd1be73f4aba81c45120d1300efa208c5e322fd79f6b58411d64f0abe518029d1cd7c322980dc86d01a0c1bbecd65553b55a9959826700ed9c0cd3f0482a06a2630c7fa110e51121fedbd05af401ef581a47426ff3e770f97d16f0070af73a98c5286247fcc3663b1c9780bd79735700be8fbe683d978aec746c1c136c90b06da96ee678cd63fb0b18e61337b547712dae3f46984dede7c7c9fb6d5f9f10e5205ec8a2cd6341d867d12444ce8183fdf2d3d4799dc807399a9f145cf5f1b34c036d0d4644a9643079cb91a533660a79a25002008f20a1a80e994fb6f83d0b7f91a88a49ffc7f61c9debf40504c70ae9e76462c29b6553b767d30b9e3f956d51ab8ae42586aaeb1c0b278915199c5fb4f213c4fa38b83672d9e84cebe1b7a9f9951982476b574d54f3441cd43609c24ef1a0efa091ddfc078f753fe0abb3004bd6e195bf254ba001563ebcda2d89eaf5c04e0d8f3fe0681ced2d7bcb8e1a542673ebec674e14fe36ac6f598cfb67e0096e03a473d0d00130f7ecb9a5aeb6a0c471ba02714eddcf040d196c80385a40a127698544b1860c334fb3f245fb392c7e3182c6e62eb0d79a7e913c183d0b31735b6caf61d98a7863b92be39bda1d0f514b652275863e1bc41d8252d30197ee2e1e069056e2ce1589d7d609a351f573908829105a2f7d046d7abae9659d72d02a96b101eb963bb644225a023a763811873abce8b7419a826f06a4e978bb5a375978b4b49afccef1814f2b0eda94bb584aee7a06b81058ef04cbc15085101ebc92f75fb1e22caf2d40fe31779d01e5d203dc328802b00c8dff012b5dbe3c83ec4d246bbce256ccd81bb7819ec561fa6e2513da2ac518425d3800c0f1454bce8661d39251d1daa23e83034873dcdabca54ae62099b91b19f55cfa3f1c1ecf94c1f4616814e26f8474d3362fe1051c8eefc1e6a315c46513e4f9ea68d1e2be232c5887513db30527b6cc8c969ebbb44eb0862d9a37735416bdfde02820f5a2ec83c26fb9a6e78f0ec62e4c354b85d040a845b2a99cdf2078a26124b4cc888107dbfeaba1560b03ac281dcd1c83cbe93dd7b0c3aa8f5e40b0de1419d54bcfed892fc37f2ab7a50fc7a8b345e36cc92d23c4bfe3e3cf3d2b8ed19655c2bbf3b67183562858b6b58bc1570e024bb198cbd01b20d6b3b19427229d4581833e657e99cf59bd0ab93ba32d6900cfe5f40b278ab15686d57f95d978604edd4bbc247121b14741ede7e36489f8ae160d123bc846f8fe139b7ed8d232b39a9aa30617b43f3cbd5361b01ce5f347571634af99ae8ce3e64f15fd0512993dbee09ff7cdaf5b02481f240ad58e31e43c042ce11021229f3218c7176fc2504c53ffebd4a7f184da818034714f57776b00b2e8ff4381f9865b87742506ecf6afd75031d2ddf7ad1e418e4bbe66a3e261192950e797cf45dbb5469de8f92a2a28a11eecae0c5538bf22e01f0db50a05d37dc905c7ac95446a86d235cbdae31fcce07876ab4053eb627605725271bf6e49f6b1ba8690951b8048b5c74c827140c0229951ea01b70900e103b10f7f0a4ac2b26588ec3ba9640470001b01dfb496035eb5846a901428e923c17b3426ec58e3bb9387029fd31c149f2e3c666124087881d0df531b660149f447b260d2a155445d605ac10e39439b975c7523fff67596d2f34b6376af95df5c385089f38e4bff4897341d96c22102d0cb3a4f21886b166ff1e49780f63641efd3516958206cfdfdb92ab0f3f6533ac7d4e9e8aa2635b45eb031a287c8c05f23d980741d02bb814e757a7c45638cbe0efce1b517c8210ad22e83725e15987b951dad5d95ab1b3c89d4fba2eb3cfd978c5f87cde73066840c0f2f37fe96b783ffe71b3ba2394db67420913a2eb5503a8b983a66c0549b87b75d35cbb425bacde8403329ef5c0c9efa99fd07efa4a4ebdcf6a27e166485d95cf906a080321f8d8d3af010b0c7dc457deb917848bc6b18015e24ccf4e4269e60c01c9ebf7f5c2dd5a7726f311133292d9f9f90535b6340733bb2cfc411700a5bbed62f853158607aeb604031d292ec95e6a0f62a2d1951b35b4d5e9daf0ad54f13a619309bd86194a0bd9c900fae7d08533cd95ad81831ab120bffffad4a037c50d2793a3666dc1ceff7d7b10bfa41ddf0d222edf7a04a1ab3c8bc9831e367432d6c19c8dd40d6cf859ca3a26179a283f909637d8f5817cd7dab2b97d248c70c9d274029bfe438d72828464a6d704243854722dd9185e4564e1fb01fb4f6cc52aea883128096dbd0bf9889a6175ab003431626c1188fd6290ca74440a3aefa5d5a1f5db95f960dda2f007cad024f53b0db1997cc1758d2a92587076c463b7d41a162688a1ab903430456319a7e7946dc9cbe7be3c6d5193d922516584359bbd5d5cc17b0aa5494cd7c6d9de818b4a8af9ab712db788d4d323b6ec78aedfeaf5e19c8b6d8637a3e0aa811d34d4dcb27cde65babfd1b0e07b895f578c7429ce2a22b0259387c8cbf1e5705e54a48706fa9c1737ceeee9c8100771b09e0f23bd9959543a518e4493266ebdf805b099f10c5915b69116e9a0a1daf2a39fb9d52fc0dbaae853aa2321ca2219a5b1cb037b589371471ee273575df8a0b3767ab95e234959e4f3562842b83357ad9fd7a3956000924d4b35906e66e53bf51e566b4ac289e037a422909eb70fea2131144e3c105d43621715f7ea9c40525d9e366897ccc84fb955c682939a4f0a239640a8f0e5be4ef9d5063d714f396ec1e48ee56bdd32ac384d9fbf741e106e730d98574e36ad4d372e08e74f679f1d8a337d45778b44d2a3660b5ae44cf7fb7aa4559728c92d8155311ca1d9ad298de437000b23ce0aa7c1108f090fe26e940550b3587a0450bc0790896173004719c8fa35b489abcfde741682586d30a976789dbece838cd25b9ed880a81fea0ed9e63d6ca1982ee7fcffed5f1554ccc65b4895c8625fd3ba19d54a222afd7a5d47c0a5a85894a53349e63080d0ae2927a15d119f3542d82f4a29a1da7f4db89bde2bf621f4a309f8bb9292564336dafb24bab715fa874fd166c0588e364ee3962947b81e2db3d7e06be18470003772122ba865615b81f27106b37a135dcb797e4b3e5cd977858e7ac4523b2d76c1a16e1ee325fd6e86a3f3ea02abd14eda6999b361c7f137a4cb3e6c1d11e6c5545ed4371897ec6c69861b758416bdf155b5528b0fdae169f6a4cc9101fc7e9e6501a9beadccd8f93fc745ff9400468f538dacc3e563ef7a9bcbffdf5b870b03371081977ce84fc083743663c861004f6941bd8cfa05bde337f1031990c8144cacac669fe4d418193c8b1e372ecff290067942c82b9ff795b67c4264083b73905efa1f031b6fd03a002c94045863b096f0b215cdd4cd65466646ee655bee31a7d8f1f5602cec93926b493915e93769b0fc6f17013e816f1c703676cb36ba07dbfadc3f6d9dd61feb4ca912b43b3ab027035dbf9d4f11e73b5b7956dba51a870de2d48a2a21e77ea1551c51279f5379a4a5abfa34d2e7d7ad6ea5aef17468b7e204c6acf5051091a22d60730838cca4f621a5cb9078b6a1ad3e94dd03fa5b0d78383c1258847d3d3d241bfb1c4dd6bd7247adcb4d322a654e05727025cd38d71a87aa68203e74a08b14f1c7e45aec2fdd04d833fd834411e21fc0b9114b1d308f65d10edddef7e5e415a3c3c1fb62bd0b83a20838eb7065e9967dabb78e9b4bc3d93afd40047bada7c5dea600da320aebbaaa1f05349d2a15e68153a26e63e60445598155a1268226cb699d1328154cd310361a656f444103a1ecf0ea2f6c621373aacb96a8e6db7d672caac39e6ee48cbaf4c46a69a3de42126e6813a4e27e9a984f2a837e153e562cfd98a840451f1b1a71a44aed57c339cd97da06d13b026d0136eaf72e81c4d10c9c7ace865ba6931f0406db1ec228c2412c52c005e9f36540fbce4242cbdd76efa42c1b3ca88692e466463b1d64de9884c330310e8c1547816ca3af6843aa67536f718ca7f939f63d78ad8a776a172e7dd8a234e86ba6c15d8b7a33fca7328b94ebe4fca892237eb733c9c002c435a8ba25a23027734cb959be2ddb772565a3433d25b345aea1b8340fe95c994a41a29680859837d76c89d2ea522d4d7399e8b0e0043950017cda86290b39c2e5fdca7301f4bf795ed223c564fec8336fb5ec01728112654f5293c587eeae74529aadc223897e2c5a9a3597c322e91a3a5e13849c68f547ce53aa069fd895df76bee506fe28c9d8f286aec5ebbcd65effdb7c6ea85e23499b5e36b0e810b1fa097007afed04b0dc64fce94a386b9fb424f5fec5b22b217d8a9e49b5928ac3f4544e9c38ce8c8be23d26f66753093ed409f26120f02309b5e03a307e791a19631c68b27954dfb8801fce8b873d0a354ed6bd6d8203526ba094e1b109456944506963e449efaae4493ee204e40e9107584b07deb3a942311954992e386d3d995356547e23973e13ead5ac56fdb625493c5ed534ebaefedfbeaa5cd321b5e160d20abc9bbadda8c163d8c6998e4ff8a65b508db3f5205eb3ade4e4af6326bfa65f0945a9a3927dec27cc6ca778c3122dec9ada2f6412d05511fe09af1f5ac6be4526aa8b70452cce355fd9105ab75c8bc1c1abe870a96c279b4176b5923c8a1d7b48f9053dcbb6f5e22933407f1947e7a5ea6cbf4e55a6b2bf7c7e4cf5a98b8868e2460a269c995c6e0ba6592d2434f5193e98d531ca00720f1912896ead8368963ffc88c0cecc8bb40629db55278986d7fb768241cbbe2238ed0edf6b5f768bce0231b023dd78913821bdecd2f4f073a41128aab3ab785e3fc570a1f6c8c8ff7156a8a4d37be2202aec239a7bfb7aaa154483f15dc7b08d89429b1ec26e86617b6e67df3927735ff598b3a0ae835b79b060dd17028fcdb1bb4a521186c31f226880182ba3eadb509f1bb62221771f89238cec7b7349794efa5d03a89f5b6370502e5a40c9802b01ff4c9e8e262787b5f0b7b672a2c02f5bf3064fcc668355ad19a00ac1d4e6ed7f14316a62b8154df37342ffe4884c080ee875e1b6a2d4e7e29d02cc823bb5bd6a3d2be9bc476b87ed8b9c844f417eea9be42de12be2547413ce04bebd55a71c05f9a54757fdd65ed8ff297965284fe73987dda81b0892d76b44f44f170f7e0191f49ccdb98174ab96e071df5620c0a11fff49a1ffb3e20afb6b4ac08e700b16b07a48f9a49bd0d97e1afd860f49ab753ec91759c1efe6c7f249ce2cdff23e344bc78e583519f7d84bcc898791405346118bda2ee10ec73eef6cede01cad9ef4433695f840cf54786d44c5c5201c4bff07f33e51bb01dc117567930a1585ff7b2e8e55efa681bc73604811964a83b24a45d000f3e3c0612d836fa6ecfc107d231716912e9f339c810f89be5fd0ba4b5e91bb3b88b6a7d72786640e823a10921c336d8aaca024cf6f78d59e3c91122c1764b1fc925e725b4e78ace9bbbfb482be517576bda25578a5ea2cce9a4cddc06d52d904385a710ef7cc55513929cd3024b1dd9fb44e1abc113a2ae3b62ad698abf5c94b171c005e0b1bbef5b3e3b4fc3a25e34e7ddc6197233d97cb3bc6e90918a21c66139d7a76c6a10e2cdd2ba2f0ec0acbe4d2e384c9ece4682b127f42ac6516d2a7ec4c795a935638da4a12e5109cf6e54f1a0226fc99ebc32858303ed7373e53ed9cad4d2f8e3342a6069003264e0e8bb3b631cc30fb6ebd9499aef1868c6944c3e2bfde994cd6c547e14e34adecddf1c27d9777f45cfe447d57d4339205e5dbb5ba0f2b323333bdd4f87f6d94ba8b82a9b1bab3fa0a016fc7c3c89138d4f54ee571a533709918d4e63641afd3d6ae0658f8cc3b3a87e65cec0db20eb32a8f244b7d88db1285ce9c0f9e918752245b98cb64bb0b8193bd1ae78d07efd29f5e7d4daf277433cc9bb306417e8bcdc75651fed971b48d61e4696ef388bf5a7cead6892b9984dfeeb47a0d5f603deb33834dca1184a13d876dc197a26e21a72297ed51a3f127f9f8b41107cdf2f296bfa23379cc63ab81358860949f5f953de8b1f983a7e0def6b742ea8a410c4d7520b1e8c47fd8ed24d5a41e9c4974c5076b4fa1ceaa9a7518ce58f2e1046ebb84994b5bb89883fb7cf56a67e3056804f3f6193ab28afc1b3cd052b670c1c945bab583c4e0cb9f41baf2d3fde3669be1139bf7196c2c598fa7b3a2ac26d448f5be0815b23c766428ef1fd9560a88e3237a29ecf41a3161e3ccdeecc25392d9ce88dc11494c3eb7ea0e95330f43162aca213cacb8f7f603f6d818c9ca1e52b21bd5305151c3e1a1f4ca26699acfcad6facd02158de1424552e5e3a927d2ae1e18d872513d084caf2f803f1bcc1f7a374790eb35034049246a62340df78ec95047c1ea0065324f2af970ac53c444a55ec01cc03e39e3fe13b1c3a576c4a7d5913e92ff399a400c81681beb5b2ca51a24bcf79014e576d78b6b30d6c217b9f4a8f6a42d34b57fce613a01e79040957ce174cb817c52c94053d2cd1906ae57eb00c88bea47460aac6f000cd8aeccdcd998670d709792cb62b73e862ccb39bfafa31d54b91fd0f5705b7eddb86a7b249d960d4586b74410243b653ac0b764aaa46971c99a2a16084a3fbb6532bd51296f22000a7185359b554df20ef953b2bf70854d4a393c494a4547c4f748ad60664917e3120271f693910803ac437432d23bb6f64a37b2b7239d92c8a4fcbee2e98aadb28ede67daf59d10a99b329d0d4b670860d9028d34749b9ac1686f9cb7d95f4d25be9d2d7ef29c9883013236618d7668b0feeeddd702b4da518a395f29bac28e7ddb742807218350630bffc6ce9edb8d6762bae34cb9b28c7b1b5a14d517420d54920395220786cd1abb334dfddaf4712c49d97f05e3fc9faff56adc29c5095ae8832984abf5020af0c8b16b958e0b739cebd9ab5552c5aabf38983ade446928558fed312865103936182144c29cc2f38dac1dc86f05c3686bb471d0ee5ef5fc5da6719d29642ea020b2dc7fa1213cf27616ffe34f795757ec20d816070d4479af2f7e8d20274d3bb054bbc60db185fb761ca7971933d71ce38f07f2236d89ebd713cb9c8a99df0579096c96ce56aa83bc2e5bc26485f0fa05f0197673160ba7e57640e1c34b92d1ae69bb0a49e92f095f30c3ef954714b222ebcaf31a9d73ee52df57536a64e7d84f731120b1b848adafb0ffab42d86aa2fe260da15abaf8098468266cc98e2c5ff3b2554e22e8fb1d591b04fc493fb36edea69fce55501d5e6f6a5385a015a6260fc739212697bd397dc7c5bcdc19af6a48a03a679b28a82871ca366b53faa58eed558f22a37256f15172f1b995f87394cb3e4bb6e19873403dd2303c26f03a958d97fcc5bf49152c5b826637f340501ee8176d68d6adebc756fe54a7420b989f1008133071d5206118a8300d6c9291f475ac3c9779c43a7d9c422468d8b62ff01873964c529ca73a2162a2ec4f745bb16199689ef4e8d73370235114309939f01bcfa427e0c037ad102cfb8cb1f085de3779f2c5e30587aa77f5a77433f3d9c725cd4405eb1d6126469b62be5f53ffc1d5250907fc3a2c56a2acc37cd9918c3c8ced8139d13c682a96b93463a3edd1faef36238077bb7e6315c1fb8e62365f59340a57d3b7c422cbcfbd846f08ce3c33ae15803380b517275e1ee45b22354a51ff562a8fa2a28d5bf9e1dbb6f30a4638b889138306f6ad6f43e56d5b199571ea1ea00cd2ded619f720889c0ff2ab761a9a7eb2a4a8015fefc2aef6b70511177c1aa9ae802f0b2690bf5ba6ab77016bc18ab043417c07fbf011113299db63370a1cf3d382e1cdda4bd0ff2c4fecbe1d0f7892b9ac3a308b4e993e210e450690d285e62ba9367c572c2d3b7ecf649aa7238ad35d53f7df8213a57c75e298ddfae9a603ace8efc15429d0ddcf996e1b55371fee299c2a78fb5490f95b1e4d536e4de508f24cd8c51986220ee99b8dd5a64bd0529370ef37530e84577fff3ce7bbe2e81d253359380712cdf00442105f2504aed5b30c287448e2885059aece9b11c16137f7997c2042ef5724c37d1fec19a02a8413478a93ced965cecad062189283efed4f5df082518aa9db1619e55f7c0897cdc19189c520c793283d871af240a777600052f09c138f5f29b6906bbe5b9aa7f045f2052f1aa172053f688c1289a4dc76aa1a8c8b4fc4594f4a967fa19bbe104e0765487fe6538a02204c1637a366ba189d1a2e67e5be7013b54222bf89e02c809a6f499631d07c32eea91c1e30f616df91fc8282f51c2c306b2588daabdee59a44a943d0cc53bba5b27593219afa6d41d4ecd3115fb00e013c8a37768a3b9a00dea0ff682d80928b6d409c540df21432dfd550070143ea4a2adad71e19499fd0af0a779856a44ab84a7dce9c7a20a92a2b87f6ebb1aa375d57bcf8fcb0afd994181c2c705d0c90bd61b067c671689390da1f79aa5a38610193201a8e3504dbe44697d7b438662f99f5d7023f2e9a8e912ddbb6752830e2437eb1c90003a9f9ce0d05254bc17d488aa0caf3e27026af61499a34b9a05ec2cc39c9be2aa6e5e008683980a056e6f4fe403f741c9a7553d02659a1ddb17a92c432f1cf6cfcff30686f3068a5e134e4c8957e19a9bfaed7a4e63bc639557ab1bd3cab5d4df4ad1542f00e1a738953002dcffdb8f51607263c9c0b1bb701eb5be854bdb0a6e01b1ac4002ea66a5d6c238a78bc9ed2bfada11456bb1cf93c81100edbe2dd621ad28bdd03f28cb6f1624911d412dd61ffd4c2e470929cc83038e683f0403facc04aaa2842bd7e3a68b028d9ee3a355ce32ecf2e75cfd171de537f67191762740695e37fbf6081e4cc5d76f7e9f521c5a197e81c99b87ce3ca0a1c1203d55377cb32d41e2c26fd5d8aee852b3909ad2f934e42ca8d849e771325021cc6c85b97ff5f7592eee032f98df627af2825683ed7784643fe3f51d1174c7f480047507b366e5a7fc0744bba2e7596f0e7195b788e2e2b8bafa7279b3e649d36f087987d9dd84a842f4ddc41a05a58ba5d96ca8079aa708f83e00078fb95486803ff3393ea37cbf7724525bc989f8f16e7ec4f9ddc495dd5fa3e5cc062ecf7724b37d86d3674e76e1deb17b6d44275c0bfbe2250c6f110c138af9c4366d8ef4a41918efd2df83c026c4ac601e873a0626ff25db79b02af641b0e364d2602b607944d396ce0257db812f88a6d5953846013f7cf717e654dd894a09f69a62bf6c50ec54451497ee22801df784a9bc5577ab5baa83a205cbd6c6f537f5d0f5a9e087dfc1c67c1204eb97f7fb0c00d85bd6365a532601d49cb8ac5c4d0c3ac3131675e9e380b14b879aebcc7d8d03f172ad03f72590e9476299488219eaa6f3bbf43c29ad98d546d2c88","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
