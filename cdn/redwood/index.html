<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"27e3765a7dd80e1a25417e8861d3a516c8f0e70e351d0dcc77e5572011234233a000c556e2f7b6acdd515ebcd4b76d57fbbadfe129910720e7ee8a6e328417e625453883850bdea099dde4ce3d77a7f567d28ff128c7fa99669cebdd40ac1b0917622b3f7eaaee3a8872fa23b1ed838d970913f9d98741dc9be3c743849800175164cb94c464f2f5095c713936b16ee19aab9ea95fb292803d074628f8e1787f1555f1ecbd3fe53de979ede9dc12db8c66738d909ee5cde24c48284cbfcde6727e1dd228f5c85141b1d8778232d2f63fc88b42a9f42e7c3eb153b6b696028b8b1ff6eab33d3ee5de096bbb1d578e7cfec6b883d6d0eb27b5449980db84d1fa4937fe1c0ead912a700b179ccbcef9c38e4be65eeb22cd2d3cd1acef8e1f5ba52eb819c5501ba1ad27b499e9f44f8427aaea3936a91a99cee8bd5ce60616fe0e9919e02f62914efe0cefca2e3294a7b84b0e3ece89199559562d25ee53f8706317a65d86e4d3931109b6ee802b9aba117caa8b872341afc5edd30f096b9ed370a717689effd9193881369e4275c95f9cc7adb420825ddfdcff6c15be916a3456b8a6c198b810c9d9f5e81cfa02c5644d98377db58aec532de8503ad8d5988ba04e9e47f05f32dfde23b5a60090dffaf299494b89450f6241adb5e7ee1cc1fd50f1bdeaafdb78aaa07ff960944afff8c9f7bef246929ba70d96c42ab7b28c4acf868cfa12fd8ef2fb9caf7f376b3ab97798b1bde9888665c8105baacb72a84c281ff39f23e39a2ff1ac4a20dd68bf407969b216782dc658a8fbd29cf4479bdb21ad943987f954cad521e23b761df14a1ab6756bdbb38a9c37c383ebea9c845a35487937846735e5fd7c653d9a930a89f591210390d5fcb6dc84d1597985740cf54c273e1c3decb797c1a72f6abfb5c1406805327cf1b531f6b45d0064f4453a5bedd9bbe96c0b9a0b35b98082e2a6e8aca7659784fd05bdc05d68f4a5e9a5bbb0a2d55d3eb65ddd0877ddf98ba53f59bfb1b25b7c3607fcae094289bf805cd21612eabefad4e4843c5222cd9ae93587936e15431171de70be15b8a11ec333fce35ef330a437dd2d49ab6f13b34ef59f75105a20e9afe1fcb2832de8f8de496534df05ffc5d0c3e0520a1e3500c06b79327532a6486aa30e7acdc8208e6310f87230022f2fc90254267a09360ece5bdd1a588c61e1cefc7fd3eeb3637032cdb208815b44abd9fcde3ef3c8a56e1b4a7ae6c038f7187a4f5cd783ed275255910f1197db3491bf20e824fd9030bcaf5852188a661ba222279323a3e496ec59835b860489cdfa5293e46d9feccc0c5a8e965d6eafedfa9a792509fde6738efdc31fe786f269097eba9431fa1ddc5ae6460c841dd9f054bdb956966756dde1067d1aad9e6293a5932c4567d52492969dd81dff49b84d468c30bbb51fe37f98ff6993b6e37300cdb16a180889c66b479972a57b16784709cc7e01588360c01716864b2ceacb4071462d5944f0d21f7749a6807b063872634444b52b8b968cd2427682f16e07f52533affab416ad70154a1c7e8cd1c180a9c9b35fe7344888ea489d87249e6f6e09604d855ffefb0fadd97285e04c5f8f2265b1f46bbaf6547682f50905c85551f917c02f9f28659b9497bdfd95c7c51b0211f831c7c1eda03cfdf9029320a53511c0a566a6a673fb4bd0a48f667b8dbaf912d527b571d2f354531fa13e93b95ac870a886684f894df807027f17c60c5766e132427b6f9e6f2cadaf70079d63f8be49ce53b205e6998f7a13e82c932806e9718697ad653363de17ce89c006016c44c3dc8a0f4fc60c66f2590fc34f6caac71b5d659bfeb039b750ed56c30007fbcec5b2539e36e8da43ccfed2d1516bedefb795edff201e026a796e429998d0863aaef5c901a3b86bb3d255727bf1eebed5dc4f31f7caa3ecfe0af33f028bc84092f2c5ea0d976e1d2ac05baa282337027a0d7fef5031c8945637de47e5fbf9d9716775eec8d96639dc27fbc18897e6396bc427cb1637a40f9fef6711adc508e861c52f55809f581d57b30382930c96fd2c6dd0653f1e7e555fe55edd126ba114b13890163a4dbb18957abd040bfbf963dc4cf53c0378630c357f8f8cce469c3e0ffcac669093531cd168f996afb19ddc0ca9e0b8165cec8bd1e9b2183d89ccab5f0af56534cd7907796061f8f77233ac7392750ddcd7e11835e5b2fb0091aa94dd479b1daa26f6fe6f8ad2e65de6782e29b855b1670a4cdc3480a5d5a52e20a4dacf7f2e89c8c1661e35e5a6a6425df8790a030973b1946979af3ce0705caabb3892062d94f3213a0d931026a49f751c658b3f39a7605076a8f9506cd9cfd631997a352d850ed04bb6644d17bd314eb8f08afbe1456b1dfdf8af5a816f9f157e5d1ba8a495d37db11a3b8f60464474cd68541096a445f64e4e404b6713540904fa4b6fdc1f3909e50ddd7a6097827e75ed81f62b243d0a69febb7df1a6bb0659c34ac9fdc10e96ab6a698d5d9cc3188d87ff9ed05ff5403f45e1f462e94ee16e0828ea0ea4038c0af67ab7680fd2da5ca5ce8090d7786060b71e21a7365038153a9b146697e875a3bddfd699282c88d89a085d253e3c15673bb4dcc90b946b7d418cf55787a6d272328f9dd95bcb3c897675e10449751bbe105dba675d4d255247f502f6960ab2a32378afb26fa59d383138090bc95aaffdde401ed69d3b28750a715027732599ee742c9513d553bafbde21425e3a84f5a626eb32d6e90ab6b787e0de6ef8efb995feb065916fd8f9647937d73c56985817db0c2be00a302c0beb9c43a02b28b5c1567df90f487448c9271898ae8798baa6d4862f90370fd0de8cb001faad930715ad24c875baa6ddb78a0bac05ac5865156bb07e9a7a41870c3ed515d5edfbbfa6b0a585ef553c81c8f66622f7d53e82647646f349956b45d3d2ece0a76d56da69f4fc951d5bf053def7791e9dab9f5ccf8d4d70f201507cf8f0d7364e4a53942992153c235624a406127300f632f9ff5ad2f0f57604493065f70a2f3c06b8b833aaaab6935f396a249f66082443c31bbffffccf5b30c1355b5cb857e2cf077af7ae3d212e7be97988ea1317a6461125398fddd8b0bf39afa627152dbf175b159929c988058ed8dcf425aaac694ada643b34d9703be05132461fa81cbdf1d368743242fe229952558b97b244a9e1aefcaa7352ce7c0ab4f3f09e0de718ef304004a50e7a0b52972c858e75cf2e00f27e94047d51a46eab85c9022443b5e41d30e2152c0e0a616ffacfa80b572b70335059b3fc991c145ba540b6c29fd190cee24a9f50ac9a6485f828383dc60111e0f41abd226adb82d0f98a0271c580a8c4cf79748090edd2d6998ccf5334abdc627964229b9de3d6664c67430b398dcf055edd4dfebbef8dc293fb455c9d0c8b020163a3094832b65edaf43418ebdc13deaff29506ee90b06841367ecbf5bb1c4e68a7d3781ca4ac281b8f6a8539faf113ca1332e2c8825904942007d459d153e93d0d710a9933b286f8458f0d064463913f3d4bc270d418f005f46d80248a0753a6fd5bce4553dc813a4d480a3630d67e934667419d304b7ffb5bbe21392e96393e5d1cd12ca2a27e01a1da75c8b7ddb826fdae9e3dc1514dac4924c7b322b7274adf180c170ef0f1f820d7cec5db4e04120b1ce236851470c197d8395b4ba0bf3997d376be0d06dad1f048ffdb4b46c17cd7eb1d6270ea552348e6a010c178c156d283e9c7542d4c6f9a69cc57efef06cd43b5bd63ba024a57ecd91893a49da5ea484d4a6174d88b489d80bbd4430122d3344972969031d9bc12fd3531e74d95147cf73aea2475ee6efb799b1d4d46d89779a505b2db1775664fd9a66a8888a6673db2cd42e47f8f2685c1d2553dd732b6729b50f00aa75dd07b094727c99b30ac8690b4d41f7929a0ba552fe81e797c3c321442fed9cd722e5fe762fcb764b72680424ea7b210f4b77b50e5f9c032c04005622856c86cd341593ed6b94f28a5cf6cc3b2caa96929751b670db9b9e3289101061a5dce7eb848f19e9c5e77c7098ba094f438fc7f0606ed007f2ead31000a150e606aa4911ce043cee1b46b962e53f3c9541a029feef3e7f48b24c6f3b54b9c51781602696bedd072ac5eb52fdb4b7d6d2f901f4a367ed6a6b500c436c7b396978ff7a5d4be44b9c746d44de157d144dd836fd063237aeabd16a61fb161a05d1a53e88d85c6bdbb00a2bae0d0c33dcb7972f7c8bf490ac2eba461ce78a568e1686a079600c499bcf24e40530ca3bfaefdc511c6d93392b0cebde8cfb6a0716bfdb304e6ec0780bba4c8883ba290090ebd9d7864fbabcad92d481abd232f57675cb0cbff1d41a19642584bcdea32f0347f4812f90f48309573fffebb047c9c312c984e62c89512430fa955a277243084f81d5aa75f9f730f6e764885971ff1c6b7b49ba3bc41817945bd48f9ba57bc82fc8d13eb7b917b072ebf3c6062a768b9ffee4de8b68fea809601acad8a45ebe824fd5f6c5d9da19e74c1c6afc11351905953b4e8874e9021fa3984ed8beba67fafcfa37f5b89f9d8ae94010148984837f5c2111a43950681f3999725bc28c6e315cced944e889421e500d116e43e36c367f24b451e560ba782556e488c10407f19267dc9274e41e3953e3651bc5c8a6e8ec19e0c4e7090e748a6e3d4acba57ec046806765f8e5a156cc8fc606d30e2374647794eb2e65d30030947f99aba3bc965b373902966ab1a9705bef982fb86b5ad58ad5b30164a70e070465a2b2cae3b896aff28fef4abee0deaa8c617b763977a362cf082e06adef3339211936a5d5e2b993cab461470e3f420370ae7e39748c063212d72d20f4271c2068bea0eec967f1dfe9a428e0e31d0e6837608e05a5bc35690bfdda268e490a42120000189193c67e6082535b9d855cd6062750967bcc19b8b8c04c070e3800ee0127dfe203e9eb25037233e84ec431dcbd95cbc9c903dc3c9d015fd48689703c38561fdce06ef74af7b6fe667ab423bc3abab3a02736560c8f84f51e0e6f73d4c120299e018daa1e921b81dd8abe5cf9172df13396fe9fd7b40b58e46e5109be03cd17f0779dbc4aeb282666d7e075dd9e0cbe02d8cc1288319f6bb48ba838b8f7e84fdc146274ed118d887929c782f0116e6f6b4e4bda3927180e7fd2f78f351ee63005343d19ed81035e9488d8a19cd46fc9083e48c3d8bd46ee3b2e2911161112b7d5f94d81178c1fd6813e7d7c9f360c0e72729409bebd5b0566787be73bcfcaa52f08aa1e10b8eef6aaa764bdc2aca2b27808e7270d7986f54e622bf938319d1f4a757dc7e368ad82139f124ce193b6d94874a87c6758d5bd77f1ef8770879ab4f05f42bbccd9eceaa9da72aaad85c958b483b0bebb7c44a54a2f8912cadb9f66e2b2dea2073f40ffc49a93e39ab30adce81de804faeed06edcfcfda6b24c6cba2c0423dbcee43ca410c3379b250b4e265d43f050763965888d77cc0f6645ce1a1f150f8f431f7cab62c75212511eec687f5e50046492bd491daaece7919911d97a19fb8114d118953bbef6f11b8ae5bb9c1aa761e051b70fff2a901e11bd1d49ad35cf010c94b3ce3c9a3c13957f64364ffc33e46f739ce4768b0805c183179a203238d5bb7c24869f7f533534dbb021d9b904a7e8fb963a00537a281300c4ca80525e1964da980c168e980b4439a8e5128c0659bdbb6b16698c41da3ee3fe1590947fd07b6cd92287a2f83874bd72415dc7c0683f1f1c7ca6e1975233191d4eb9b1e7e9b95021d47c1d6aa8979d46cfd95c66e0f8545285f9f6b2b23b38405a7076a706aac9f119a3ee8c21612cbbbe9cf75407ab91479871d18eb2f973c1eeb8a712bba5dff79751d92251df74c76e3f9f002de6e8be305212a5e1fd5eca63f226f70a017a4b57fd7e9f0cffa622442769cedd923b918cc28c148ae7700aef9393e3a8232e473c76a7fb3c0e3165672b5c6eac3e1609b57fea64d0a28896f3763644a68cdf772be26c8ae205fccb731337f43d6730d5036413c0ddc8002748a9869e12fad32140e6c575a76d3edc5209c80d08eae95a6faf0c6684b325013dfb1f8b809bc727df66c9d591d5a7f588f0045a94ce3c3c71940418e25cfa9b83b5988107e5eddb13a7f2043d18ac01f1e7dd692889ac058b570199adafe5c2c9cf32f67e01c105b6b09285fda51990518d2d89176ffe8df3ff9d10d5055871356be51eb578fd798e332f153f59e1ef88375652b300fd832419614bcddc028a614c58a9b24295fa133fc9f04490851e93f7c28fb0bc85bd9d9b607822d03ebe2d7b977b201781e010de5e5b53c9ff8196c1b6f4d8aee82673405d875c936d8d2c1ab1f1611a5bc8bcb2af4c74bd48de574b71e2fbb3b6b403c8aca1fc9bc916520f2edca53c5ac81f2f669dabb72398b01f0aa97ece57606be792a16dd935d3aa826f97e5fb978ae971db3173599e80e2b9126752554c86dbe55ce6940371844f029718d3ef543652437d60e67e3955877b4068e72bd6c6ab1cd6eec5312f4a46b0fe5a2d802c544bfb8ba6c078109bdba4ae3230590631854b86141525e2c0b94cb7c98b69ba9e2a77de63e19372f9cb71e3d324962a8b05c65df9256cd2191def89c515e599b8f2724e2465b66ec26a41aef6589c09055a1f5b857ffb64ec86068af2a9e165e8a2c9ce0850416082767effcaece04cc6124d41cb54970de97e02b74a6f71f5ebb059b8be194e4de37a72d27b0a2a9ebb382f1e2ccbb415ce7fad8db7b44aba9012ef9f1db9afcb09a6286be37bd266a0f767e8963201d9b3629b44a429c737610c859298cf2b354fdc111ffd8acfe20d9f58f4a70a397c390b63118ea51a50e240c26191cee425009373e593a57d59ece0ac11ba0d383721abe9b23c613dc5af92f75434455744eff45963746448cdf5ff444b41f31ebc4b69167651dc86c1c3d435ae8a44bd99849a2244a47ec9a937e3064a753a578223c2cd231a6b4b811b717cf78d115c50eba2171fdf3f45b904e186447f064d3cbe40a3f9bfc84b6d013cf27f728024c883fa3fd81f5b337ea9568e01351c7108a6a92ab5475bf686501f4a584826ff99efa45500645a02d5e780043b64a65e33cc3e3f35c9fe6ae4e8599a952587551ca840b6fe69d8753add52f66a2b627bd646e435c9182ebed39f43794e04aff7eb797351965d8c40ad9f573436bff1df08a6ed2b298c408f12f96b23bec21b899ec48a8c5616c0ad04ffbc49626540d5cd1c82091031c192f0a7c60c45e44bdd9f3e2d21c2ad022cb49f6ad8d8c9e0393d947a851c66c922de9ca7252b8368571f5421807e30e5454ada7ccd6b64d1b185d2c74f6716d3690b661a9da8c33b99466253a728ebc5dc191b6896e863e0891870e52e63764c2a7206572f07d540dec8387dc602047c18e2747a261af4d55fc20f690fd5cc536d0625f64da0f6f14c63b8dbd32659d5fdcff5ebfdc0422b917f52d74b04eb2c99a3a060f832e1c380f9c8d322ee810f00549fe5c37a4fe0d6abd45e489ed99228c9aa4884a04befb9af34399c315561d77136c04f745dda739782625ce27751dd3dc5986a2adadfa847e106b9385e67541b9abdfa99258e7d4ff9e8664c3e61030a862f2ce81b0f69d5e760109d229ab5de2e9114af1a23eebdb67ccc217363c544df03857e03f2aff7898524ce819129004380ec676e371947f07d78ddf30fc04439bb664ad5d9cfa359dd5c7cfdf9cf6e75a98751fe5c1f8244bde4007ef653c26d7ca5b9891ac6e9091125e58fb4e0ea6030dd815de0cab345ce78784d464c1422f50916c695cbd8ce75c1db4773794e53df0d81cd7bbd2287ab609117692798064ce953bf3bebd3384973529298fab246fbbc336c5c3feb69e1b0136ea58d08d1f796f12fff2de7a67b25d2d295a148fa2dbbbfd0bcd27cf32b61955c73e379404ff71a5699afb2d0347a55e80a7802875b46b5e9287933b5e16d869f57791808069fa70fd0487c07c162aa33c0dc4879597eda90ab1c15e53d61e6b702f925db5b0ebcef5bb773f6b213a38b41f23db67c525c6782453733ae9efa4f2c448a2258ae214005ec4253d8a4141f0e5b74b6ea83673d608c7dafc2b597fd5ccc814c5f9a08f35ffc42346ab18a13adf51c97e10185acca26bb53003b0e2ff8897ba9aaf03fbeb813147e63d8fb15ffe30c5745e40806190a9b46e49083f5ff47bcda4799b2d8da8a30501045335bbb9f2ff07f427727a2a24ecdeba6859ce9d0ca080a70a732e0a32c4eb7819b0b27dcf41bd7a119adfd2152dac3c90928bc703ce41899255cce020cddf6fedfb73a745a5a50ca5dd90cb779715b404b572f245a5b63d26d88fa8e188408527f10b333b9437106ad65426ff8b4a0c95761202c96ea20bbe8f0fdb9832ad87d7163c2ff856190bca9bbc135f6eb7471b212450f11d4dd039829c1fc68fb660639d77b83b9e5c0dce7aaca23001ea9a73c38bd8a63a1995d8748be45246db8b45b65b6e75d8870aa9aef3d5b6359c91eb55dfcf20f75f7a83e0829b539542732d322aaaebe7d51039a8b57b7b0790b2a31f14957fe4b47e70da02f2fb040967305e41cd91085c675428e0df393f0ad3cb57988a06ac36854ee56f7537c7fee75700b69d11de0a143ab33a22f0d47c7779267dfa39b54c7ec652510714104184dcec5abfec17597bd383c117cd463fa4fa15532af5e42a3d2e822021485bb5c1c3342297aec551604de3a0cd52dddde0cab22f4fb57d8171a4084fd4f5bed62dc0ebaf69654757e34b4605864c46883323efefd9fba1016dedb18bf91df66b10323253b83b58c6ecb91d3fad3c46c5edb3f59a6c8ece21431bc03cf741f59db5f4a7bbffd38c569a11f8acd12c7a31be39bf2d562be6f66783853796d9b3c25e3e4e8cfc22f1d078aa27970e4f97e21c1bcb076b228d0d61005eaf74dc2288cc4bd1e92497dff6dd68e3a147e96fb6227f0be6348215e846d16bf0875c77b3496cbcde3d642a51dbc7b2a8c42e61e045ec005b98a286a90f78f5cd037f8d072b77fd6345ade93e60a1371e91f365003d4519002442c3490ee9693e830a3c51c3096ba5f993993384616c54553822665fe9534c369b70857e0d5c33990dd2fc7807696820981ff2ed5856477ec877a0937fe3b139ab7309d5bd2a4c002a6912c2aa429d5a8b735e399e6c6dc4579072d415ec2ef0603d0067e0622ce147593f4e5ba81951a30f52ea4b4c8dbc7d8c9b8e44d07cc7956f56264b48c7a66b4fd1e1920500f70529167927a2c8964ccb30a9875b28e5778a05d1584aa9ea14452a2d45169195ebf3043a7548f4a10beb003f758a192a334f612cdb84615b170929826a25aae2be5c26a3cc96ce639864fe316c8bef574e55a26dfebdbafe10ad581159ccde4c0a7adb3cdb1953057a230027fb55de34c4ed66bce65e70a6a0cd29177f3d83e22ec30084ef885b40b8562e60e7d8d78c702bfc1a137e9855584265b8ec8ffae45d8af60b97cbdd93d8fe034dded696a11712084cd0a26bc8fdd0e11b2d6bfe2b087f1157b9ebcd815e1a644273de3c2f71deab6e4e3585b3527285753319b7301fdc133a76e579ed739979021283b9a2c29ae975529d480b09f04b019d254b52a595f61a6ff073bb7d01b9497e33771d24100917b406a25dbf27f70c3c307c04b12c70201bb2c3498f329c2afc93e63aad3fe11a6b56ea8a31d64f41e2f188b980bc0db8189b2d2bb6cfd1b28d4044db2196c322bd7b08d97bfaf04cd760731c3c1dac104bc58e440d980f2f6677b5c70aa825aba939580f9046db3aa9c4326a20b3f59ddad46898327c22015a7e53e21746f9cff7ef2ede8ac1557446423c723fed08246d21b175462f62919b8b155d11b06039b1b82796750fa022f7273de216fc734e964b1bcc40b68fb725bc55d1efeff65ce0f80ed4aef36ad8ef8197e83f2b1f55ef3c2b70f6d31c785c5aa467220dac1182c52e9430df2a261abe4621bd8055f3755294b7be3f2b05a6f902197744d4b4c695bc12e95e4df9ac6071211a81c6ae5fcaf756a7332485bde3d5eec700fead1afc24ef9ec34bdb71bd181d8871cc2ef2ad892170aa9c8fca4796fb79c0e8fcfdd5fadcc73e4a76abf344888a30f0cb3f0113adfa96d322e09480ca9243d98e60e02643b76fb2219def462834465649acb32b85bef589ce92a33a5818aa6b90bdc2df0ff7c57bd9aef187e2a93c9db625af77007ae61410f344dc2ea4417186060860d61a71f3866cd9c40ed50c9f3f8ddc4da528c86dc766e4b5dee38ed60811a3056aae78cf9823bd16d6e754ca79fc811fa2b57eda610f4152c4a4aac4ef34922076c060ae22003d08069a22dd40ad7cdbba66a08dd41ecbc3dc1e6451c1b630f6cc98a8954b9904e45ff68caddb1e3c2eccdc276c29b777964af1b484068c17ddf5635b52a52a045551c0c16bd3d60d7f4bf85edc9c382ed4c5f4ed3f949814a9364cfbcf16f0124eba5d8ed380ce5058e2b95f5e764f68bfbdf48db3ac2ba85aacdc32b1d5deba8461ce52b077b805d17f7ebc3edc66b31d6bff234df0e909d576f2b3e6b254ca886e7ba3d37c05e0c72dc21bda4adffa6b926db03bf3012c4913f90b62e65a9d82b4ef178df0aead5a9be35cdef30021240eb777f699f1ef75812a977a046d4a797e49a46cb572df477f4c64ac661fa9091f1ae9aec0b145132404b1eb8fe3bcc13d8b02fb624a6e0548be6cf3e48c074c2ba5d65ce134ebb3e9b1935630ce2571662c9440c47566a26ea7f87ca17186b4dc5c0d11552c09e1786abdc623ca08d4605e2cfc16b09b4250afbafc5762693e7afb9fd73765d303d127143db2692880070dd75de4b4c4d6bf3910812079f5ec150a83d6b42c1faa0126e75b5934a09e2cdfc68e8dd7f4e2cfbd02c19e3797992532f5310e0dfd4c87e39b4d15ec1817e130c7b807a8de8428539e9cefee2e52c939808f9031d1dd97640d07659cacc9a19d0c1b67a3dc29057ca63919bd30ed30e94542e0c83c626f556ad7b9d00118cc8152270f6cb12ef9c0f9a0944a35940f6b391295bd8a6095c155fd8e067252c637617ae2c50c7214a1d9a5f577beb300533b19ae69594b90102a15b425edaba0eb1de614e372df60e661d0d33f59a8b432be3e5d0bfff38f2a65c6c84fcdc808cde9a8210386b0c03ce8927adaa7c83923b2455af7166bec8fc2026f18736088ef0663b80afc855906393e7a60475e296637e8037827e0ad1354a788ef3ebd72b8c6ab4fb5750b2c628bcb10c18abdca09a99445eb10826caf6d55acc5d65930cbebfd85395d71bfceb8cba6bf56108ab703945721cf0a35e1566e9de1a8d6cae8ad8c55766b24a8d50cf237b5c9c86495185340e4506c9450c53af2aaed0086703947557330817b13b38be11126d27ea1a124dfafa81941e29ccc01b993e42af8c8a0215915189d100e2f1498b719893bfc4b67b7af8d8e8b8e5869c8ae513faf71adf0caa18aa0642bae6a0deace25cd57acfb16953f21a82905bea420671622253526c96961a4c2fdc7d09f37454224013c29ac889c65741a694051dea190643389740677ad51004a9fb3c6383de555ec9b5f98fb4471db61a5b3e363929e35375ab63e336677f75bf88f3ce870cbd3d2a7c3fe6d889230fc10d399f9cfa3c49e7fe248250b9628c11cb37c025cb3504387c2fd02bc6763d25ad00935c1bde21dd568cafbd84091c8502952a439dcc222e1da5fb1523bd3bd44f67e4dab8ba27dadce0f9ec84b1fdf718228c9eca413b8e57d6951fc7a12ecef7bce917e83764a8ec872a3767f1b7dd639e14432ae59a3a47fe898f0138c6c19ae6665717daeba7c01d96a99575936f8c6c3d47d9684f0b6e890290a28d1e803cea56deb6c873d09729fd5eb76948c557911e89d9da1272fdd7d44f6d41103a8f527f70928186be19d43d9245c75bad82492cf8b9a916ebdb28ee9565d956ef19447bf47235e85871e7b8ee7dc2fb292a6af073f0885c10aaaf4e20b4fe2a17eb9ee05f6f729f2bceecaac187123de46b313302610c3f51a7bc208e20f8f53d1e6cce07395e6cb5590e16673f47c6594d12645cf8404889cc09bc0b33740bcfcd5606066e11d4c24a84d2f4af3728d6045c42349e86d67e85b7f3cf0199eca5f16cebab17972f0ea10890c87ecc31b7625a0397f2d2681e8d49c1d918553c1c0113c34446eb6d739b870952fc9c723e626f2f142ac48f818c611c644dd195020aa604c2cb3732917f4ff22a3c055d7af79496f18856492352c8466f3269bb0d4f51269cadede02913578710356cb44e6296a3035f4743af20686bcb943ef9a55e2ca4e78f6cd8c34171b7b3210f53bcd6f9c9ed19a5cd37ed83549d7476f98b57805e45c192b089c7e3ccd6f27cc3038cfbd81544e9c4c1a8b56ffce5b0c13d330224017b0eaf05442ae47ca428b8780eb32f84029239b696ae8225c7259878db2b71b6a43f422acf3e63d7b25c96958fa926fa04c22c08a919f15b4d69ad7b708506d2b0c31d3629dd8015d4a294a0d5dacc9531708136d5fc8ffb389b88ee65ce2b56e0f04e422ed58c3672efe33cb6bf55aabf275c8602536143ff604e0841d9fbf5df6292d01c98664803f31731098378ed11b9a6e837b81d734bfff336c3bd4b4df65831076dd334ad74c4caca90440d740b5e46df40eff9dfd552a1514d00fb5652ae4701aae292d72562e3fc8c37195bf1f73b5a813afa1224420681acea7cea1f6791b3a60027a9b4075a2c7115f68fbbac2bc5b2a0c1cd5cd0835c164d8ff875f239599eacd9fa831bc40074ff5478ad0aad89bdadf2b26e20344c985bfc8513d5cce8c9f978621ed2ea2c1bae16aa3545f994701240c18c7ad7e6828efc50f74cf5acff603aebcd2374e0b4972844f3a6255cbc667a60e74c17fdb682a4b0e2d8cf1b5adebf06f6c2c2efc9e9f1d66747bb8de488c14354ec029dcf9e966a700197dac4019aa5f94a970b33451d8fb9c161c40d7c8526dcfedd1c786ffd4ac2d1496981fdd4dd9b38188f98383e9795053cf00587dc94dbeece9c91a098c67f2ddabb7069da0b28e1ca4ae3c7af8e9d7e54894e7bb8ef481ce1d7192848f3abcab00da5d82c6d8776f76493b66c18978f32df7c159fb2f6ec2f8baf7c28f2b469bebf5d2c0419eaf4c5c2f3a78d6f3dd669337b858db1d606cc182a269e5978f98984fc0406dab95e834a207addfbb286a0da5dc9b75d9cf84f1b8301c2417e88832487849a72c5617206298b5b23af3aa25fb3925558903477326d1274c35a01c6ded8ee72c92edb8b4c39ccb56b048cbf0ea393f5d0575211315dcc391950380ddcdbb6292160d3f27530cb17d5bdb6f3673d4d687fa42910a0c724eefaf57764ba46c1f52f46f2a752f659a2ce8f2eaba8caa4790babab9b01d322ff73cd81a03ecf03973fcb9ee0a7c999ba353205bd0eeaf1bf27fdf17d248261e53bcb64d6cd8ba7a8dd69fbe5200bf46d75026a84b0e3918257943e7efcd4640909e7681076916c3916c9c1eb5094cd378570d178f564796a607ea2d9de2030cd41989456ad2531f98beaeed46de4e3c5b845bc2f5b755963ea7eb19194dce64ee9b07824cf6ad2f3c8b227c4306a3917b8e52b9546a4da68d629d617026e92ae1e92fd86a46f00a9ea94dfb93a1437dfd0ad21fbc1440e2fbbe647097e973dab9aac5b06cd22f387a91d3b8a6a2ef6375ddde8607f3f129ac8cc18180cc9bf110f3002edcadc8d7558bd3e02060e3d93eb8a39cb2343fcb3b498fca574f7456ec94f12fa8602976a5ffcaef08d17807b905a3dc04e93269b89db50185d54c02ae4741c2881e9df008ede3eed0b920a2d7c36cbfe264be5ef1aaef0ad8e12fac4006ca321b291de2bb5af2b4425dd04cfcc784de47bea29173cf7cd3acffecb97b591f2ae7b71bc31289e76c8503f804315984d6b4623fa68aa7f594f409faf1285b96eae176864ab6f1881135e6fae20e0f6bef780412c2858bf5b99f9ec37354afcb764e683c2dcca38e7815ddee8b6daaaf7c2a5cd1456b4affec466365fd37ec0174f36b022c09e9fa9fc1e271077866d176b03f7d83b10c183ebd12b5fea5e4b0f9d34df2690da14f60478469386badaed6f197bb3756e5acae1b8f959a5617e1a1744545ef9758e28fc022588e4e389f14684299c8f1522fb9865d15dc9385c09907912c6b1656e68e3a9fb5d85c230d265258a76db0e9c9dd287150b596e5f0c8aca363ca9924c705a29eec952ec23ac44ccd8958033dc96820d1de50973ca5850c9a8a4049c9fb8f2c9b545ec6018762a866f0d96d0aca9077ac3395cd0aea713bacf42a881ff61ca122e80041bd8b2ec62a3973957a1b408c78d51e767e1decd24a1d8ac9d3066931d42db52b8b6f3aa2472b7f9b9e6be389d8d70df0b33c1ec592b08fa2a629efe560e0a95aeae7baebe7c4649ea3bd3f1f39e77d620fbf365c30ace032fe680c0588b5bd419c383ab10bc55113c287876dc04d3061357584afece98c858988b18896c3630a908499accbd87b68367ec89bbd95e93e9c2b58225f2a7238a5c64c9425dd548d1633e6e1d89c17fee481d6edfdfb130086e76b082af3dab63dc404ce571170ba2874050cb1cdab952abc84dbd05884a8222f5fbb9e67d29f283236cb05dc4087c6e07b13b19fadfd720b08d7d1494b9d4cf4a3d1640fa0d822e4daf4e4d321c3690b723f4078e9dd590380730ad847348d1f4231a9d794dc25ce3d2b8ac3f28c892a08c69dbb4c9d6b00a1b537538d4543ca573ec8add803ccdb052ca12e5d5b6c17e9e09fe2994a8332c5c3cca523b408cb4f892e160566b7e38ca0f1aa3282b9a771a1a7cdba042fb0c7f1df55bf4e0df15282421eae701a08ae43bbb7d3b7f6995cde36ef9d4fdc362ad372bfeadd01ee4e11e4451bdcbadacf34a29b8c93ac48c3a06e2d68a60cdd7382d480191a4351b3dbc3827008321f9f8d8e2555dcad3ab8e1e20c2af25cba5aec22ba7be5d131c9d61b44496c3956b970dfc5e2457fc79ab2d94a5ef6177a84d71eeebce70c3ecad0a6a7761faf133cb45f7c251ea6cdbcdd6eb1a643ce0bf389a6af5c3049e1034c8c13baa783d85a84639985646bb505a40d73bd88e8dcc9ca83cb7c20cab598b62d941656fba381793b8a00e5c2fb6738529c77aa1a16623dfb49d81d61803aa2ddb630643a42b71b131f2f5ddbbebaaeb9b6d18b175bde63f48d34a04a75adbf9b0424138ac1890bfba99508d3a4e1442fd5b9a045b65a6c6cee167ad357a8dd5e2cc3a19876d56b3ab0cb312a073bbdd8dddb037340f9a3f93aaf174c0700bfe29931cd5b816a8db7aae65ef1d7cc4ede74a9163cc9c1aae0018469901ef576bf31a0c5802dc6166347d7ef08995e49570ba8389680cbef19f8d7d7c64ef6d96d39aa00de7970275b187b7173b3b8c78f48c14cdee9a1686eec4d6b0aada13561eacd89d85fad8027ec0d7cace3517e2f5ce416823a1c52dcad5bb09d0f668335e7a3860f0ec2bbca9ccc11fa22f55c52ecb7402d69870884f21048a25542231449ded5342e81e7a49cec13425e5a968832f2173e08ff120f630605614660d592433ca041b1d9b093b448103ab5e959fa6c272cd71c47d494fdfbad6805ef63a76a337b7de2498e3d717bc0fd10d5e633faf3318068306d064594a8a23c570f7d5a066de9eb8dd2dadaa55c81f952d59c391de77b43af626f69a309e34abc217b5f31eeb03dc1ec9f9083beacebab2f4be5e874f62f0fab9a21d33615b623248e5eb98536b924df562e98d5b2b610ce8e03e3d89e87f530e8be11e188e052bb6531df2021da7dc4a95e643f736611239cbfa78ab385837ff059accecab8d15a4daf2a3192752bc40ed4b05772da79ad38fa6d8e9ed448589ce22e7a348b03c6352b86b60ec01e797e0cc6f878c2f526fdfbb970e86ccb9472c323018689a74a7ac087f58029c9e5ea26faebb3738b56010190e20781b3dc14eea10f7b5f1ff81dfce80c6069d9d230a21d36de593ad7c5a22a2d73c00f663d13d52ea92e04e0360c3e7923dbeed644561ef8309d7cc36c74b872ec7120e5c78d281ee14cea563f0ebe7a2f31068e22d4db1cecbbb7e400caaa25d3ed43f6ac4af1e29a762174d5bfea0b90db3c3928c494c492a2989a8d2d0dc238daad77762cd7ac6811a81828596053403d498c0ec143ab830594ec913a254134bc90bdab25316df21a5463e8e0d94666375aac847c0008069e727aab536f22120ed8a77c373a23d6230bf03b68fcc0cacdedbd3296bd3230beb340906d9146fe0cc4836b92091cdab5096f977dc5c95cb451cc64f84d1220fa3292dde3fc3e85b0dcb5e000634033a62541b5471fafadf96877555f0a99cae929b644f1fb7cad76eb3f1f5e0fb79c213bdc2b3d27f1ab1f79472a9372768f6cd882a73264b69250dadcf59551f02cedcf977158fca23bfd33b66535f116996d46ac39e92db3cc3d9614ff8a1aad34cdf0a77216dcef91ae0088ebcf435168ce5ac69a159c0e3def944c20bbf3a34311a46e4bb70fe66d4127324fcd43aa59f092b1a39cf8abde6cf47062a32bc09c4cddb5876667440a237f0ab8d2a9d89c695a178212964cce61eee4d8dec3427e81f3105560711e6eb2031b25f6482088e60c3978cf4174e31c26bf5be3e3e4d35159f3a7b0ad9f53fe8b115f349b95e7975cde473b3cbc60e8506f7cdc23fdb235c1a78e3177ad10b8a3afbb6b01dfb7afb2d19ad557f87cf26c93d8330bc28cd7732a0356a546e95084dc7bfead7d7955faa5682b5d2935d6ba4e09312d98ed6dfdcbbddaa0a22fce0ee3ed2a279d058c58f4e6ae3002667899539094fb49eca503a1500d44b38d328fb8ef54a01e34ed52e03c2eaa68b21d792415b57ce63f0e74dfbb90360821b14db819dd30edf8b9eb7d16a56c67fb5395f91bcfa8d2ad33c4b9fce751fdc7f1c2ba28c2f59f88396655d3b5469e334bf5cf3d4a230f40fe94fc4ade61fe6d8cbe54fbaa816df332601aac5dcb338384e8f25f4383096f379cd0f49554efc5a60418049e244fc8ea5ec09a329c9fd3505af713ff6018362ab7e41aa5e33df704d856ec37de32259cc2c89cfc174abc3b5b559c88396e8133d0e22e05d4e95c5802a7ccd4a1621a8dfca8c16a3d6401864b375587bd349c6902043f8ba23e451539a01c35b9d5875fa82002d1949510ccb0d6432f27f7d84a1165d47db2c13b8f337404bbeebfbfb65389d7ae72a828875289ed3e1e8cfbf70e29ddad931f5b9ead3c25d1c71a8c6259a815a02a18751bd2cc69b4b3e2e13eec1b24445eb283890ed3274b131697feb4358e0b228b529114cd19929e4987ba347c555e858e3a50b7ea48611f192a5599836bfc0d9c3391344fa96c4635a5173ad52b32ac0ce3a81471eae83d094b2d17f14fe54c97e13c5f87910a7cf0b3dc990797bdc1bace37058ed83f974b1a8fa4f4c6182f0189011853176e0c08012689b1a149fe8e2ec239eb5f4f57357af55600d526c366cc30fe82288af81d43ca87fe104cab7b8db672e962f7f80b38d3a6bb58f8494ed3ecfbae0f86400d8a4dbdbab419863ebf7655e0fdcea52fa59ea708ac6c01046dd9b660f24a8a0743ae4bb55eb24da10a07ad339d637e3bcfd78934145351c9aa970e00c729d211da9ca71bd60a9826fb49faab9ccdd566ae2f2d0df52e5922e1a479844456e5ffd32f3617dd5056973c815e45aa268a15d65f112687c46ae1926ea2cc5c6291c754f50b92094f3513619568a6de929efa79f00fe085a2b81d2c8e1a814f7eebfaaa66070be51cefc833ee931998635f08118387fab20e92ca5f240d15c86c62e568f96e5c56db21a643a23a1fc3d6f6f23afdd0beb5760869ad14a643aae31cb0de14e4925423ca6d57a6aec5501b4d2372140206b72c1aa8c3f47c1ee732fde36573dde816b3e10cc5cda14faa338e3a5f1651ebdfe0","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
