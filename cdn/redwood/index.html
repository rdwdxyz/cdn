<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"93f6754bf1efaaa13c511a835918471d4d1e8aeac6556a1447ccfdc3af662007c50ccc3a63dd1fae3ace93d0411428552872f3d266f74fab7e0b9222d81c5b0a058e13143e31e08ffa6ea720fce6995bef37ed6d9e3aeed3243c136bc8f907bb55795ebdeaf4bfec903010452af39174247a17186057f7a690cfc6c8ea85c87943b712e1e5728c2fdf95ea7dd7e2c35e4e428b0f9e55b9fed2056c006395f179eac6d332bd628bbfde06a91a96f7d7e64ee844af0149ca25430dcd8b80b28dafffee745c6bf9e53a87f20d49316a9c270b00b8980a4c09b543d26373b7150472aaa4147899d130d7c0b25508b9bee88d7688e67bcea3a070fa96d2d2f2418fa88ce1ef8263fcebe4a3835813368c05930a9bf44406f8b24c1d7e8ae90748260c6575854f79df88cd99aafa1abda0d2a39803090f1810ecea1c204bec7a3091cf3d4f2dc5f4b45e74e18fc239324e631a967d705fb6778d3d2c730d7e2e6bd5c0a83eee1ba7b4c46396d4d345917958a471300297e5dc386c1bc508f4f4c4c0ce41708222b749638ef1788722b3737ca3b416714e9f1b72114983032ce760d8a35b4e0627d4911bcb02de8f762147fc5904ea19a3bf5a99be67372c6b63613e15caab9a7c4835d9cb45e0e8802f389b8563e5895a25a568b847a6f85d6cf252741ad550986479b1b2caf734e7dd043fc092bcec6c1208559f8dd0576bbfc90cf23dcf1a54462131e22c775e3854f83929a99666824c3008070e0e5302769bc4cf908d90bf8f0a562f406446f21705b6354260753b50ace35089652103d032246fe036b0f18bbf98fc5dc07f538137a850950358693e1d7b3c6b8f813daf88f6914be8429aaa8bf9ec6ef486658b4cf4b4bc111733bdec51753965191c71352d39a5382e5d0c6695296799cdf5af15b8791d40b4a363c8ab58fed0c78fb7441364bd72b34ac3ed84db057d1adeff68c7adbdcf5ebc0b372dc2f278813d31e3ec935565641a6375d43923696aa74e9756b507b5940df736533240273560929ffdd8f32887a6c4c61d0fdc4df28e4c56017df9ac86750c2a27a6a56e4ebfee92bb0967a15cb7e1507519880c207498c12c874a8737030f893f3992352e69d3109acc549f71247cdac455623af4ae96c3aeee2a5eb516d8dd87fa53c4212918d820144af63327fbad7cc9672bb9b8f419ab71fdd82e23e0ec8d8d37c02c4fa9a730a0b59c04619a01c2b0a7e8c63fb66dd72b66854853ecd2d46b56723e34f085e420e2e49a71f71ff7958519819a5b9387d3ee62f85f1256ed85a21d529dce77d8baf547f93dde6b27d1a3439d8ef2a142894d177a526a5048929cf4ea4f2c18aa519d60650f623e5802fe2bc62a06f1afeb1a2a797e992381b92425ba23b89b68962baa77fb38abfc4c42e8bf5450d7334e50351a657964b30c24c950239b32b4d15a315eb65c7f83bb347781306e51bd49ac6f20b249f4bcf4796ee3b5e62352f9cea9509b248fc88361d488cc84a18d13b8ff6a70214d24783198127e118b4100acaac770bfbc5b6b237dd9adb1d2478d31375a81fc6f3fd5695eac58407816fea0895400e4ce1fa4f72e4602bf711b9ccdad020537fae9854b619a644ad39b855a3fa9e8102253cabfd80eae64f566b2a27a51b4767c00aeb7e9b0d6aa8e090e30e5dcfdcf34db697b8f560fe38fa0653fd351920c7ed0eb67a9c176faf3b6d34cdedeaa17a3f2bf1c756e525714580e9a1c2043fc3d3373f82e90668866cfa09a870f22b62177bc4731490ce57a707ca7044201632d1947f7f57969e4ad433a90cc2f0e8481ed5a285a3f66b8c072eeed96f435d6a39dd048f7b97a271ae05bcc4ee0783be5720884f51fc02ed07bc8b7a1e65e52cd62bcd3c18029ee8d9727adfa864427be606ce8902a20f4ab15149b7eaacc99987959ed18fe99524e82fb5ac3dc3aa1ed234bdd6f1daec75d1863baa75860dba78e1ea7f3aaef18e6e2284e6b0056bcf6862fdccdf8c088c0f9121881dd6305eead2a268eccedb7f02ec348337aec04186fa437f38ac4732c31063973f0393fc9a7dee366bceeecee7bd82138b4f90a6a3059088c4ea4452ccd0c4363bf56f73f1dc5490c0c4b9d1a86d9c6f972b62e14b6c6d7d4b9dd91ddb6ca4445f05a11badd7fc840370da79005733c1b1c126c518bc41b5e7f245babea091338142c0e9f9233321f85df878ac5640483796ca627d16fcc1bea2f34f2738cf2cc862b2d0795f53cd66e0cd46387a78f55bad9cb6c42c91cb30c543ac777f6263f9de0611265dfb0daa3626eff2b109872d1f35f11299f3dc151489b4e327e443815606b6e053779b0116a34777366504498296c18d4f8e848c4cf08213063c54f6dc93b4898f53b43bd426ef6e84c24846c5eedcb0317d25348b07880f5cfc88cc3e99aaba31bd46d2ac5630135225eb9cca54050490dee210df55b3104e9cec6db172aadaade0b66bddc545a36a7ef841ed2a3bfd4f19c9c620980873f558f5ac0509c23874783d390a8bed88ee9b4b9b7ee4fb930ee4efb4017394c248880220668572cdfd856fbf2f2274de2e470b74d75f494806ac12f98ded4ae413fc5aed19899b184ff6e22d9f92360a514cbde0e8ad2428d52f21a74df4412b2e4377f65dd4f71e4667097a970e935b37c6276c3b4ee275fda3f5d7c654e138822fb654c220274049e3be6bcbcc3c3332a61a1b409f8f391c58355a6e6c46748a997f698b3869187d6215df23f9a17baa38c4d239da3c496c41db4353f2ea91ad58f9763bb060a2858d921dc27f072661eb38bf29ec9d2d2a0699d9545a7e9f13870c661cbd620b71b906d03718e35392b3baca6611324b2a13ea889351041a5ee4316e36c0c7d46fc1c5b9f445b29f1c9a223158aeccfd4d68ece4a4476855e61165dd2023038ea9067816f9d03403825e1f510eb2682b770328be99f3e679bf2ef641b319b034efd25221f795daa47612f82a39ca746130d9a939c97cbc6fcfaad45b8a0fcf5cc8b8b363dd7801e7a547bc6c1ba6f1afa806b2a78aae498b46db480ef554adf2f83588623e26ff6cb58983dbadaf158cd0662b67a0ceb4a50245316e2b6e7b08fe0e6fcbdb1408fb25ebe92e153976da29917d95f3fa6a6b8a977a3c4e22a3184667ed361fd457b47dbb0282dd6499bd2dd307d9fa32a8983668fa7466255228fd1b6e3beb37c7fad28ae2830521d1449c3188b16c6605c36afc2ccb29e00e38916ea0e44da1fa264098cd8b0cb81dc3bd1f90a4469c6299338a6520c6d5f7bed33f597bbceaf31a8817a30170bf1c639b2c503465957c276ba9b54064682957af60cf66d059bf0aab6d4cbef74c45b266dc11f97f7c262554242506048c3eb945bc35b2c7202263f308c7caf7f7cb0741112aefd4efc2f4bc6ecf894463015748503683afc224c8797ee19abd36588a97ce516bbc84938dbfd1b211c3f9407e0b835027076dac3223ecd96ba0294a4511a316d816deb5bc7db245f18240e895d76a7d8f64dc942afbc9c2b2d730c9a6d963f91b26347b499e769f85a65090c8b8e0ecf7ae7296c7bf39c3ab8a59553eeae5929793a44905e326ea600b1caec0c33f720aff6d92f42dde7f4783d0ea4d0d7eeabf9a82ceadb436cc5869e894d7084f906a01ffb357c64463f8ceddbcf3d67281c45c0a2c1a8e7e690061a8bfca78ef30c4f76130e7b8f5892a2f64fa3caddde92a31b4d578ce077eb253517b0bdde2d5a7d5832141f07d584d86c5f5414259a725871c592e18278f8f6c3f1efb2d96ddc6519412a8734a0a8b7bfc64656bc4cfae0d0d09e8e73efe7b476264619809c5d5d554f4e962c35996815cc831d55182231f8a2a9028ae3dc80cd643ac64e05b96331d8912b13c0225de007617c025bf016ab79b873864bf27b184bf17d6a3176cd060124e774cb1a8c34ea6d1905d744fae18c0acc06832c925d35b1f8bd210bfb33b47f8b30dc90a1362636ef4225f33eed2bbec3aff2cb60a0f810344e0b2b06085b715c9c197f4a6774eec0510c139fc23b019bc5417927d2b6787a26a00731ef223f6112550166480faa967b5dbfab9c72f2d9dad7c6ba29f94a7c5546c6e472cdc7cb9d87611876f491937b4961070b55c9b28e15b6a0cc4f211df66a2b90558673c23f927608033e255d5d7d164398356ed1d9ca58e80c2184124f65af78ab29c0f910b42379fdcd1bad20d745c95f4579ae01ca9eddf2426d16451a430db1f995e6195ad23f6890cdedf7ec5690b2bfa306fc21efb764de9f242e07efddffac8b65b238a667a842f1d8917095980cefde8ac7a98d9341cc7dd550e2c3d89ef756261091c87c29849f9fd83f25e36a007d8de86ecf059c1fa495c1e92fff8f64be05bc1f8e079724fd2571341356daaa15b5f7afee2345b22290d17f80b98abdd12f9008096913c3ed71a4521b08975c0535d5db8ac190db9b73050c4e7a2f625ef2a6ea50d0f31f61a235cec7462e202d429e60a19c50b659cc1089605eddbfba8e8434e141f1c02f0004d74f97ddff9cd62822aeda71bd9f253cce1d75751963d75c4b853da6caf70332579b4569b70ab6866dbd1a76a2704e6beb901a07cd228e564bd653c59521b2b8f37a2557cc706fe73d33bc63092a228c9021ffc9e390c4bd715bc399bbc547038c35a9beeea90d9df26c5f8be9fea4b24d71684d3d753d0ae631c8a228ad90b012b20e2d52bb2dbbe744d75ce727cd01e6f21b33224773006d83ecf4575aa85035dfe811109ab45153bd6398f7c8502fcdbd3933b068417922a510c33db49c763d4a5a3f9b11cb187abb492fab56b69ebcb1a22455fb7a99e926f467d196486e3afcd9875204bbc58b224e9ba271d2a6038f2bdd1e9e0c2a01c8a01f712c9ea66c208541ed2a191fd119079b144ce5965d45c241cbbeee4d190d56658023bca38a9d6dd9e79bc310878a1cdf25e98df1c9ab4541b6d4e7953512fde9c5231a7d8fbe24a89132a85e2856092a8916a22caf4c9711fa999510546fc7db10b6e1bf699c86e20ecfbdc2ed175a8b1391b7fee928b87e2d432d3e3b046bc567193ae12f102c196590a9b4a1015d7141374db32cb081b71ee80a873536024256beb19b752ddc30ab695030d81361cff3b14207a1a9a31e25837c6b4034be3cc1f8140f0e70e0c63394be2a6c4fc0da53899e4c6dd8742c74421f21a1d764b74a9495b34296c0caabf07e2907eee3758f830de871adab6729baf2a2868a0720f36ebddb17da60aa8fa7980870e1404c9336e343e33b825c7adb1c9ffcc1108d6015fa9b771d0488a3fe137dc2569bef5622573fa8850c4dad35fa26f632a5457c99df6b326be13e112560a5ed484d5b6bc20ac38e20c0675a6e8d9c473680912b6b0b910927e294d35377c47da1d963387c1bb537df95aaa26f0320e2bd0ded761254055b7400e814d65e76287c4aa408e6cc52357bbaf82a1c600997ee76534aa03f38c6f05d7d6542f32aed9d33dcf3d0bdf22b09cc93cd9ea8f74c858801762843e047344d2855b30ff656315cc498144b1878dafb21a5293150eeac977cd96c00a1dee49cff64b5eac0eff9fa73254f85a84cc5ef2e468f98d4e766ea55fa608e6db454fe6c2d84c1874e88968c08e25e99075141ed1062a0210ba2e0a897e1c22ec4b52f280818cfdb3ab5a9db08b1b0f3686d342cc7b3a5030593042525959409783cebb1afb3a169dc97d3589f76b83a0c38a41bbc05cfc62ff131c9f10645e91d3e4df6492fdb2368e98d140dbb75b0ef3bf45996d2a53fb81deeccd4f23a474068a6cf7f3aae99c07d5c45fdb07194d641b0ff8176249b119c465e0a8271da3851f8a8f5c986fa7a631e6dcb185d2435e275cbe9a4775e599429cdc16bfd5269e10cae02840bd06b76c6551f54787cac85d60dd404c14e355de3f82f631c25a887d24dc454433ff4e9df7f17323f0887f127f4e918f645a69b80226a57514c4d41b4cfaf547c47344a4fa67917a10c390cbb6c30fc27ecfbc4177e203065dda182120992150ffa333fc36719ecf0bbe422bbfa1976cd6e7aa11c822eb1164faec1bc6f9263f50589983f63804da63ed8e371e60650de15b3beb435213f1e5ca70bbe8d7561c3a2bc8b39094e5c90d55435f01ac2df599bbfc7aba5485241ff6993230d3a6f8753cf56d2d61d92c820f3e98bdb521a7f6608b04ab9806de49783d34c888aaedf3697084faa08ee8f5dfc96c601b3b06251560c76098af61e8833b2a6ab08e63f5f1c163a6e3e6bd46f6f8d2f4936b0077c9436c03fbd8b83ba75941c53f27a8c3119dd0baadbbbd55bf3c6c87dd73c5a0a75864828583579dbdeddf59ec919bac5fd15fa1a70e834b5ecd9dd2f1c5c4fb8f1ae6b0bcee2248d5789f024be6cd98053cd35192b11b4b69593f35b2782005103ca7ec1ae562360d6e5b817a23ff025cbbf11d3cc6cf1829d9afeb3f2faade05f77dd089a5246ec4c42f8f2a926541eea751a4bdb22a9c4948a62bab2c15042206c3a0518bd6c6a86dd6b11eeb8e1d1b892d0d0640b205fbab80f4a6560992f6e3ba993a0185b2d34352e74dd417d7ca1edaff4e4362e1b021e1ef49e9f8faa49c3339e78f241d7e516c319478eb286e2bb637b7cf4d640f856c06d0f9f73ee754b995c26b439b59294533fd3c7c93fa1c776acc601928a366934dcf095719d61d7a75384370e06ce37beac14311ffa9ff0fe1b8db8f9534c6c87687b4b73c32cc77ea0cab7492211c5ec41edcf9522be09ee8263158c5f4e21d8e409770532bf69ef003c14a45279d7e8e22221749e45fbbbdceb2e968ee13691ae2d174c9421c36383a07f0ce8e56dd471a5f92f72707d499f901e6c00e9046ba896e65d4768b403d329f4167a69fbe1bab2f6596c4b056af635f52d9cc411c1df77cf06059534a57a2acb59a689519931823845af3a49c4ddcee2e88d8867deccc4ee2cd49229f39f219318bf0a5dd5980af313d510229bc08d62351981b70946065e507777d6010afc5f027df1be7cec86319ad9ee0da386643272ab6cf519bd5ad281bf4c0d55db0b3f6571204784b109fe11a0cc12f5d22ab29a1047229cbb04ca0e499aa1beb7d1fab8bdb5bb27353109854104985fa348be89bea8fecb0a737408587a93f67f69e7f43b4cbe42d98dd9782f93e00f72869dbddbbf34235ca3dfcbed43921a8ab437c37b83b0d7f32a39876e44939afb18ba19bf029bcc45c59d4c060594d1d34a5e8dffaa1abb75458661f4d5547aedcc5fc5d3efa6a2f326891e9bc11bd8e7c3f1b15f30f89a8b3997a95c884f094c652da000dbcd3508a29923bcc15c029980b701c177ef75548ca49fccd5bfefb58dbd7142ca7467263d7a074f18cdef63176eb77b5fbdf62995c080bfb54c3fbae0d07f9c29f520d4922f79b22c05a69e3f0d5c82950ef18578cbc0ab70fce28c91f72eb4e0e81cdab7a6ddbb0f3800c45042f8c706e2556d5e52985ec2a81c1995b1d9f9c9409a7d75d1403a7d6d02eb87b7809b67b02c78f149bae777543ee2cb2f4b9a92284af895e163f0264f42b17b66610b70d3c96b91895ab1a28b6f2b8bf0040446687f5d9a405f51f5f91f54ea0b8fda974bf4f30afb478f1d6e2c80b067f83b8595939f1ea7d329affba69f67b774b7d31d44e7583854d83e4e53708adca141a66ea7d241d890a1f0eb6b84b9007756b1b31d1acbf3f6a6480db8beb967a477c729bd6fb93ee9d64abf4b57572f69172a814cef277bff2b68f32ad3047057cfdf14d6aac131ecab88a033d209774a807fa3d2bde395800c6bec19bfa806176a9ab7d7b6ed780887e805cd930dcb842321aaaa70ebc2b77188ad7dd12338eb48833c029763d1b84c47909e99f8700fe44149e0ca98d58ee0cd3d10fb4a7e49cb1f35d6416731517f7b9380e86c628ae22c00b17ed3ebd87821c25e60615272ca1e42760aef0b5a28f51bfbd4aace6a3a7c808f1faf4b4b54540be03ecc7812d6b778fd5c65b4b37ea10491d7599e5b3bb0500760a140ad8ae36fe91e23ee605e164e3415e3cfa26763c0601e7bf1a69b3c5b89fe15234ee500de1d35f5dec26e6b92cf9f811211d768d4786458f497ab4a3c67048a2c93c223398657d1bacaa265f3b31ac8aab4181457204b85addd02c72371183e21b79d162ed4bd2c4e3f41666f9657f804f6f93d6b401ca6487f47f79df88d1b1353905c67c886e5efde880c0ae2a15e1bbe38dd9750b0d0e7cb24bb8f32cbdb6c24533da597f7f2abf785ba020cab965957f357fd90b852ac4d8ca159e352ba04cae5c21756e786ba112ff510be41ebf7f454860a76dd8fe54f1ac2561014e8838f29b11297864a0265c28cf3b6ea288a37555f83aca937f96abfe47396098888e46db8b77418b9952575b1099a0fd3bca2cc4f7ff71568bb0f16b06125efa81eb7a76cecd79c10973547a17ec65545353ac3922d9804ec95de02ce29752277c969a9f8a07616c783c39672349f367696f3ba351dd85ce362a05d6721e1aa9613d22ba8161498dd6aa46ab850d1844a1d21bbc3569c9963ea3ecdb90acb0249d7e7929d9de676eeade54ef0b42d2b9b691d684eeecab14a2afaf0a207d2735fd31f47de3e43da597bb941a5eaaa0b46337f13480210e59883a9b4ba619c13eda747e3083c588c69348928884462c4640f8bf0cf9ca8613cf92f8279aa9d1c7456b5bd281d0bd4299e380c725bafbb097544685634bbd04f708b5272afbacd0e930f96fa56863f605b373afa441119b9858d4ef368024da5bdde1926a966e987a102ab36bceba99b15b13613312d945d24cfa917acaaffb320e9c36d3672ac94d80e5d63cfe4e02ae838d05362eeaa008551dec43574b74cf769cb5cd12f852621e25b17e3165755237512fe47d95e7ec7b525d20902d3f57fc982e8fee91b3e0ecd5a06759b883aa49de720dbf495e7e1634e063d58604c8d7b88eecb525c2107387f9fd58fef07420ea816d1cf67ad82ec8273d3dae0a3b255b9b1f9831c2a950215f0d0f34795d1016df536de9e5cbcba7fab4826e944e7166cd983c81d6154bfc01aaede23708badfb982f991c72ce90d18c8ec51355ffd80f7995141210e1ca95aabd27a005d3d4f8b40fb73b9d96164600eff427c75e66b9abd41e3bd8bb70d47d5f1fe43287829cfbbaf7c34f75bf6e3109157016cc1be7b214850979ccea21962920e49aaae3d2dd7fcac441ebe17fb31bcbff64dce442460b95fceac1915a86b9de7133a48672184cfaafa9f5cee00df6e83d20c0879adb8ea1051683d809c10b2349fd2c184b83ecb616b19b16589613daa1c1ac84ee9302ffc3f82a6e48a09bc64917a9cd02467a52f1170eb5a7ec0f7338c75d8b8c46d5d3a4100f94d375746e65d090c71d640dc5cda20b50da96f27a4f4a8cfc3b550330ca36074b798d80a5951610a09e777bd41c4364f34873d4532d90c7a3f53825652bfb710029d094fa5432a37f33251ee36c5fa5d7c13428f0c2e27049c409822e0755e78ed676a5e952dff4f7580ca99e620689a9c7173ed149028522db0cf0f00dceb88be3aa768a598254b4d54c33b3eb289ed7e2826bdab29f0d009bad982ca9af229003cc8d23e00bfbe7fe8a45729c4102cdbdcb4098f8ff310eb0aa886154de0d8fe87b1611a91276e77a59714ba4c147ecb6d6a78c2e75ae644f66784e960b75fa8c0a819503d22e3ffda0fe63342bfbca4cfb4f2eab972dab00d7c836803ddb307960c2f5b9e2bb9f37ededfb81480dabfa69fa045a3eb75010630de95da8ddf00496513b87c28a8b00a99c66789feb67be181a20983130c4a789044ff0c9d8b31b541e897b7197906a5a6713a460d71f025aab429bd499750a96331327d4836c511275aae685bb8bfa71fff576cfee3d6cacbb60adc86d3861bdde9eef6914d0f7d32259a95aa50a9c014164f9c717688155add0e9e728232b37d1b78af0977ee53a4db48163dd3a4ca4f3916f9f65f03cc00b9a6e87ee721080c2f7fa4cd68ddd13ec40a4f7766e2ef0145fabeb428cb69d120dc89dfd9ac42816f5b22cac04a640c428437245381a1321e9ed8676fdf478764743554109ef3a3ab3452863fcce02c47d52cf9142ee59017c474d9e4c8db4eeacc1024b00f609eb159a5caa232ff0f6962f8a649d7b88708cfacf3509b72d544ac30cc02addc0e0db8fee33b9c3ab2a1f4c67d32827c53863977a9d126144cf118a344642777f0e9fa3a054e4061934d035340021e32722e60f42b51604eef56992048232f62cc554278d763f580a687565ed2af546035b522aefb52a3f5f7a216688a421470b28c00307b5604753b163f24f674301c4377f64f70c01f1721e9d15563292d4b3c2ba3406b6b8ba895aa8011b9e3c0f28390c194d774093dbea0fa92750286d6778ef6b7f0fd2109c384d0a041d5182b88802f411b7b41c536e00178ec65f3619305b19a79de94c48f7db1621e34ff3e0c71d7e686657a754f49937b72ea6dd4727eab392e6f641bbcd9f7916b79beee1e949be2b1f734923fdff43f24b665c08934e0c47106fd61594e55e94d815a1f2011b9a2f61b9f8f5204fe52fe71bd7400e6b7e7d6646e1fc143bcdca377f2deff703931e8f320255beeed74b18f47054835db66a58c2439eb55771302e6affa763626275ee1eafa561a304c41a7447d0409672f968339aec00e54161af1298266934184bd1b8686c7574b97e034b54bc1e6e4f21598c2ba06768761f1496f00388dd270177aa71cb594fc3f7c10ec7cb40f1755098fbc845cf093083dc9098713eccbe3592ee5fd3236938fcee0889a7fa81a4cd892c119f9ffd850da220494faa0aec493a1adc71067c84180736baeaf78e3c7823caf7a6f7933f1be467871d5dcb3a8917cd7edec2e524f2a2f6c487182575cdc7fba655aa8c32e68dd2698167e6a6e3432cead795a85775135a93ae4c8d9ea519ac756624c09747a8e047962f355c4eb22d54884f8fac8af8a9ef050749b894aca6c2203f47f04dd3c51ba085b23617a4d71d94577af4141b3bec614794fdf36d3bc59b9bdf322dc4c8acb9160f2525c57f2521dbf7be0ff8acec7c1f25197864291a01ff3bf3bc6e4f2e074189eeabd263ba4642f682939dd08f28a560e2e9ade620b4dcd7e53916b93574cc837e8109ea633376f7f862a80bea642ef14ca023b27ec95e006a69e02a9b772ef2b6049859b9cf7f72b7a4cea7be95389ff5eb0439964823cb827f0c7082938e5b9d50abe60f9c4404dc7deb50927b1603bc3b72e21be3dfcf5965afbcb1cd95422dc9a062126a7286787ede89c87883e1aee05b4e7f450e090bfbfe5dd4f2dff192debaec4226b06bcf80d90d450115619ac11587d4f64f1472bdc56937a7b33e41b6fe02cb580aa06579a1eed97adb162545967465afc3555e4585338cef58c4333d305ba203f68cea3aa613434241f484b36a3db54f674d274f37eca11f7cc0338ce5926700e1cd1358ed22102163cc1410044ffa276b334adae7a5418ac2df526c7b62f5bedcb6d307e437f9231d5dd0369e9659f026db5c3170906c5f7e1292a0b6f45e0b68b5fc133c9ae9b81999f8ae78391e38244c70cef2e016e81065e42ef3225501dee7310be72752b7cf884c2542d99a47c0297685a80a534936ac2e30bea18a9d646ff719176f04b134afd88997929ff8abf82c7c50f6d7e5fa05bf447228893a993939c8c166e604dedff3128f6b836957a2206f3cebb9df80e99acaddb0dd154cb2ada2a533547776422604ee6f4aa68f1fd9f4039900760fb9a8cc2649d00fa6dcecd1d464aae8b2b241b5996ad460959726d13cb6b4ea46c05784bf6f366335179cc85d4ec81c3d74893329f9d0ae2e951e4cf5c40ff0b6134b286245118cc0bad3892f75010c80f55204189d0099b81d177e616686b193ac4e25742fdca194037f81aea57ee488a9f243d7b868e12c32825a486780c4714e4f62ff6f3f3ff3200090c4793f67ca6601d6a268337adb2924d627c228e3d8b61b79ca02e2a06bf2150a144b71c2179cb235c108eeda37ed36d8388460393c8c73baba855af06684a3a61cb57fda4813ec8004cf83da7e4c37b974e967b451bdf0128353f9460260f2ee4e92f3dd2a9e2a1d5d7d590f15e75cd3cf17b92d1796c8354d8853e1302cb251f7fd9c120b3c44544f6aeacf48c78698e6ffed5fa65bbd8b0a2b49e7a56aff92b27ecb4dfc745dd2da3da53d2e78073638682833155c8cc7a3e2bd28bd9712a81b6f4872c4385fdf8155af033e082a2255fbf95c67e27e0e0b3e6a47960f8182175be9d41ed415b7800bcda676600a925a46e3e5dc65293fbb2d55abea18fe50d84d736b9e9f951f8c9a4b75baa0d34cfadc8ef2738e83e659a6d4e54dea60507d46d4ff8a7c9c444166809bea7277049f6820eed8f826ad251117be40417f1eabec089e1bbe1cda56285f54b7093c8c5802bb9fe24c7ae28d3f6f0ae68b4274c3b7cf6ff0a4837ab339e3cafaa68a338b008bb74bd7fda576fe01afaced5b173aa5575e31cac9aed3be9d71551a5b169c6443261f3b565b5a3030f1fa32471472bea1ff6af70b242eb6c79ab103643282ebe4ae00837aae9d0800491fcacced0f94e7415f5c3eec8e45e723984b7f25bad7f360f13480c8b1e2bbce16f9e0ec57ab9cdc5c4c2316214373484abfc42316333f19c203182ed649b9eac6782e92e4a99b44febd586d46cea58e668ec141eff8fcbf9111d2f13fd8e1c80f096bf1b46c3eb36b31f689e7924fa1ae4c802a081b824b703f09b8e5b1d767bbe25a94eb4c05ff01b869272dc7647d3a9e0df708bb66f2fe8c38fe0373275c2b1d5dc252b358c55b2ae1bff3bc2430077c7d194cf2771a21b6cc71c63c39af15c7a2c7295b300931a6237393edcbfa99859a26153bca75d01f2b368fc1b1b9c4636fd9072ddeaa78af78aad7cddec2e9de436ffe70b7889752d2cdef621a54b4ea6987c267cd2c3a0a1a4a98a1c4ffbad721f4e2976e5139c773da3b5686771db8806ebeab30aca1e0a76dff5d4467245ef56b3c6db43ec12541eded76ae2edcc43fbb1f8b595816014dca470cd073da52e02edb98634b8c1b4b68c0242a00f19cd9418b68882c2c70b273bb2e2de1e10ac5da8a2ff1a81d9563317bf8c0c622a7e9592fd3f12f6fd53805576fb192f6e8f55e2f109fc2ea92eda394de466a0eef4a469db5724a51082b1febd23692e60c36125b735e976081f6de80507d20502e4ebc0851588171390765239a0489ebff6286e851409ad92230a99eb39245c422735b961a9b5eea4ae2305a683f71be99259618c276f14fa8a016a85a4609c3628ab73d504252e3cd80a2237e554e02e92ba652a65947a0ae560a5d539e12ac495cc172f5d537a083a69165ff732051a1755e1763d48d99b112499eb7ef47e2c43b1af7349a0dd3e89a9b3bd67ee389dc5a3bd5ec6e21f24be21485ab4150d906d26648e2f0b1e3c8969ec60848adaa0b68f39bf7a5d54a54a9ac3c60f93a92060adf259ee86e9350052235520774cff2a70ae8a0d9a0daa1dc326caadd703199dc69684b2b62b9a87f2bea29ab5be10a58d82c07d768772f4fcd65008993c64ff1c35f69ffd96a36b151adc160bf0958342965b8bb4088c88a1c49caf539b9a45e684e591fe186d78981be48a0c0f3a83c140288abb77d06a3e3e199b5a9862713502b0b900ec3e8412d76373e7f40980594d80cc7f4412bd01188798cbf7de76e51330d7e0e568be10f02907eaa09d710cdd62a35ad0670c2c7956c9fc2e99be89baabd86de624b6f9854acd7f490c956e8327d13ffec0698fb6595be65335fb2ce8a6a7812a9f75942b153b4ec17a491a13168dba7848f294c0eb054bc9fe7c78694a6e9ed0cf80cffbf01635e9494a431f8ab9ec375a9fbc6b3d357f0d5592169f6e4b1464256963f246814ef0bcc09b74061fcbc610a698e6f0ffc0695c3d64c23c424441f7bc2a09e8699c86ff2f4ffc42d0aa41b52ec1991355c6bcd83e21d3932c28e1b88c484f2d7b93244f3c0c88e88b8ccba4a83c11f3278661d76a2dcbd780394660153642893bafe451142fe5d40a7a52dfc70200df2cb2bdcd2a46c0c68749925dd3ca61d95eda3ce5c490a5a956328c866d93a28c60e95c95c94c5fab51070b2cde4f27cc3c85475526c65aa2b5cbdf6b301324c8848f9b243c348788cb1ce3aae2deb23fb1aed1794528bd7a2090d2b2e3fd9ef7abd6da399e08b4ee43d6f973666ebabef655e732175de76236b0d5a9e2c9a296f8d44e47f4fa11e6247f56ee1b03ea4661769dc9053f68180b7603f8383e21f1377773d54c99ac0d14c01f6cbea3687fbb58cac52f207d74671eec1d6680674bcfde218a7fe789e23cc5c29f8c4244ea0cf4857589a1164141e46f954fceb4129d1d6b17ebc12568ddd799104acd6684cb5e02b8b047cc6705eda6c3c245e5752fecd0f42b80142ba2bb67446feee8ecaa6c952acaf3d13dca3a4df3f977f20470a94c97eadb157f16324985138ec2aae8f053e104d819b23006167b7b1555824af65a7fccf35b97a2f1b89f480afe03de4a94dcab00c5d9378db9859488eb31306cdac3c5178b17c8de3280c7a7af39b9c4e0b59f5f1ec334139e114fea69f14154374459d5fed7c3bd8dde128296df91d4780e5698daff547507757fe657c8bf790da2b425fd690587074725b8ae92d9babb438846c6bb753ed27f9d390fda4001ea1425da7c65714b8a62bceba337b3c433af60612f43393bae26ba30e1d08d64d91a95119205a54e73fd130f5c633c5e0021c733105dd6ba41f4dce57ddc6e7e8210568bb4f5c2acf91fef536992066055c2c5aebb96e994f74a6ca44e8936612d0aa170df66b8d17498f62faf2dff099511940c1018e135e0d9559adfb662e789aee79edaf0dd4ef002a109ec9fde93d886e6d85784dbbd96111e597b53b01f2d4924bb3cba8f9e657c3be0ba63bf021ab7072a726f24b9a3b117405ccd93c7bbb9a1c64996cb1588a50cef89da73e1587e1311500d32675616c0d7decc98c506e2a707494f4c25524f848eee5d14d6cc402bee8e5d3e956789a0e9ff3fb87442f9c6daed4ceab615f6fcb2441466d11b051bbd028dbdefbc65a33e2f81f3ed6f4a3e1875da213f96b0494d1211eff67b3c097a91d007d646a9c44168e06c1f1c28b44d45517f8e4ebe59157d7eb500c2748607556fb71c2c696bf5d32208c954e3573a6fa2b6343ef8c6bf567036d2091872d6415768e49b2358999393739161d489284aa73f42424ab584f73ce982722c76fa5544d879d9193e69a1737376c1a7c3ca81bbabb2f41751c40261a9afcecfe576a874de4a7ada602ca9b55b0cfa8eec480c38def1b12bef09b84fae2df7137ce4f5e2f5e91ac47507b26d335fa556ee3e505febb5e1f7e6f51e88c5b49c6c13e841a76b5c7ed5ca4dbd242d5c0f6938ce966f63bc476660d37d1c79511f79bded74e902484f2d711d03d121c5dacdcdf4df5baa2b56499d4a7ec1dd0f708bc3a5520d88b3227c8c974d348ce9a57f9d0fddddc1ff86bdcf4d93d7bcf1acdfa58b642c98943adfeaa27a732114d25de505780f929a51d858563c43cca3afb0c51ffcd4b421ffbd8fb0e9f812eadd82ad197e544b3d997c0df3b29c47ef9b7e6889eb316753d00e76c8be54fd77c2e63aa08eb402a52386580838d194f9bd9f6c14f71b60b2bd25dcc8ed10e0769f20421994954a906d01fbd46168e788462356d747790634aeab449ce3bc7b4c0d37f422aa4748641e6ba6e25d6c62bb3b40335b5a98b9b17d7e4182f49f4ce677a47b4cd69e51fae72cdd5fc433bf2f34bde6dab0439c932cc8d262b4ce99cdd91437fa66b4f64b7f43ae43f876e7031f94f34f6fbc641b05d6b0f36022742ca4f3448a5a0cf421198d22807746f0e844a75b625da369b453fea29f48b04d9a3196dee9b4c150b59c42bda0b4c923a79e394f550a544240645271a258ff3f23ba17703163a1f8fb2aec30fde7ad6a0cd4435145ce40d667cb30b21b555222f9c0fbf411d1c2f7c4eb8f4b3264a591cfe959a8302e63ea848e3e9d77160525f2017ce3a07cbc7feac64aafb2471a794aadc36eb6d53bdc3f93d59e9e08dc17f05c10f0b5d27b7b2931983513d43639f464f685eff9138f5915e749ec4d32c28d8920b990850926f9ec58a1b63d0d8ef337b133711934d430ee91e257aa35c0c26e6f1ecc6f5b0d440d232e31332785a169515047e5e09e74694af0c3dd80994404801dd1009bb978bc09d8856b0ff454026bf0e4e6a609a03026a1666d639cb9cc6edce89b3cbc3b48ffd252dd4476f9adea1786a452a0a27294621852598cbc968650dbcb964fd308b0c5f797cd9aba97d656e7bd4133bd58f03644822714d0c633d2f86225986d279a50c99ad9d25aa08d9f3aca319668f240577ae94707f1df4d3a8aa18c47c5018bc4d86426e5f05408a9551a7ab82222c0baa182b8e3aa2857a14cb50105ab86d57d05fdeb89e50065dec1aab8ad703baa7c917964babefb5fe19bd1ee39b13af191e463304c83b0047518473d0a5f874b0cc5dbeb32a897205d3103d7f3cd6d6c89adb939efa13fedbdaa085e3775e0ab67f3b456105ffd7eb08b501da1e06f8e16473a21ef93ea8028e2dff02a486afe0a77992018b90cfbe876050a7390df3f4ac189ebb85657d9da4a9a05b973518b2713eda6bafad5cb743eec99c991f4d1a34f8f4c762b25e01ff0e9be44f1bf22c5711133fc5e1d3faf0629fd7520b8555c8e8c33508581f641d668d03dba2696981d99edd2e4e870316edd8903dee40fd495acfb1c98f5044e2145d86a7a8714a0f3373ee278990dcc7f18dc019d9c0510c364be55d4a47a6b51007f3f03b5b36092202a3c53c099137d37b4aaff21a0dd3a08c00b376ea15b5fa98c54ac9354cc1feab1345bff88f970db09ddbb1288f994f427d159663b89771745eef5257e8906644daced0375e0ce1f1058d15a310607e5bb61647e4fe72c2027d1155d7cde4437358547e055aa51f06e57bf58e354ecd21284c700389e5b589c7c052f9dd678070db70656d2b792233e2f74418eeac13e3e4a44ecea9c017a852682181803fdaa7efc4d24dd42428c26c5eda2acbd8c246a3ac9cb4ce34eb9d97341aa0fea8691583acf558a4f23af583c60d0b93854d503d50c33354a18c0a739e2d553ff27f48efff6d3bae2e0a95c7c43038235cadb4d49c8e7aa52309db23b9c334b167363a9cd7af47d37ab6a7cf71599206b190fa25a4306ac6ad1c28cb5c91279648794b4e66a99f86ea44ba9d9d861b24596c93372af4a88baed067ef086d42669d677201799f3f5e13122ce93c3d078358525046ca6c63f506365d02a33ea7d6c6e1ee4e402c6573062ee39a6fcfad2002f610b1ec1549e46bd0d5bc47dd26aab2bd7a9ca00fe7fb2dad334814092e8fc5ff56fe906788a8aab7c6d57e3cfe3789795d022fba6e72b51108cd94795db81185d18361cfdacce1fe92e4e9304fba849f21aa4a1433ce890424d5dcf9575d21047e2a12de6a22411a8ef3a1e1d8f53fef77ea370a797ecb69a6c8fae2003a6fae32ee2174605378bc47d715b3e477d000e5dc3d965f0ced75f2608f83f966143632af56b36ab30f12ee6d390d9f53edf602cb3591c2c0e3a51e38be502846421c40625bb3bfb5b02306a9c328c993088c2417f50cab2caed6bb11dc30c20d1de58a13e29a3575c8559638353568707c0bccf30bc978c507111df2b54518b54b0daa73c54bfd4d56d8c3d367012018a480ec90aba86b8bda473fd10cab35bf6c2b0ef1e6d9610c267e278a22f1b3fe2aed4212b2d8404a1e1d72aeae0ffef6b4a1e9f58bf07d602c491ecf8877500f7a5e2871613a5db81bdf3c342a7904bd08bc32530d00351054cc42a2c70701cac93f6bcb9f004078c7c25dd55a2211d65946c444cc4486bf2b5f68904bbfc96cdf4c5bf543","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
