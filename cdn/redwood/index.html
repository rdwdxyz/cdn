<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"57988a833fbf6294a6a53ce2016a0dc27f20b09b26e8f8aceb5aa13422a58f0d9b73eab21d2030f5ef1374ac75c9c90761bf7637fce350603d3da38b4e1b2ebae461360d402056a88cbfa8c7fd17887d60cb619e697b3933d2616c6bfab14fb430baed6206830b79b3039b4fe6e2c58de45f38fb713cd535e5e02c3255c5f608ab0b93990298c29a9e86563bd484d13dec5d0f248be4c65503ccb2d41322efb16fc3e632295bc35df632260ea5b7b2a7f4c43b94058351ff6729aaeb4089203498d70a795b0f65dda684a40b77688fbb3b3bbdc47c0a9a39fd419ca9409a6b669c25c18c6b74228cd27572604b93869d41658ce2c218bc13be2d1e34dffcc23cb6dc04380b64a38cb9dd685c2a05bd5ed537c4d042002a03530c45ff0d46c30a72ff991fb25a4b4229247b57f6c3cab044147dcf0f95439c1bed41a5ae36888ad93413f02bcd56c6e0615bb9bc310bd18da72eaac1ba288d462a057dd6df877928f566273880b22e406425fa53008dc820365e56301fac041d38fedb808fc23141f467e19e9bfa6eae883662b25110d555308323f56df07b441c755dd7059f923eda652782ad41283a887e3ca1eded42a701a004798c7966bf606f851726f4b0b88e6ea5beb0acc98598a28071406e891d638084817f03f46d3829c46c7dd54e228b786ba0090e69b37d5947ac15e678e8d30b1fe5e4c87c31a0561eed79a4d8aaa1c934d82f2272f48d3327d0b55860135e8a7dac9632b07e70a8ea9bd7950d615f0cd843b80a5a1f587555e7f5509f73c566aaa289e0a0e9b39dbd7f2256b498943eaceecc7066ee97a618a6d3fa471897df7601438b5bba4d83fce994c3d4dec4f92a784de08b13169de40611088fd5d6273e6e30cc812fe8d03971d7921c14a334abce159bc51312a8c168750e36ef1586545d9954d650808c7f6cccbe8dd482fc928f423a180f8a365ebc9fb75be7e2fce888461b00e38932c3b3596ce84e37d33755f5901bb51f7c80d6584f98ab4f1d1927d68285218841208eafbbeff1134c290f8cd8abb38cf913983d994bbbd22b53d0739c082fb919083df9fe2f9952d78859876d62d9cc6d3632ce213035faf022aaee2cf5328308f7808cea9f77aa12296aadf3e782b152a5002c9bfed3633e985297475b219d0eaec26c3923334dd38b379f05311e4f1be385ffb261354fc9c234db3a6516edcf3dd7aa567ff519a88f0966a0fdf4a0309949f17106e9e143aee45bf221158956fa7b16d2d7dfd5b6397f4456c7cfb170d5554f8cd340bd3ceec7dc3afe536f71212c0388e9edc4ee76541aa0b02c5d5621d64cfe887b52af94b855d8f5009d3aedabbf9e48eb847c4a8f78803a8eab4438d1c242cb6a5067341b3c018812a7b30ecb2922c9e457359693811e062e63877fa2a57e227efd820ad758f53b903f490546acfc626377dbad9040c72fa38e3d11ec098248e1c5e6c530d2bdfa337d0e4041b977973f716d7579b8888cb535e0b196a72c8570fd55c6098ad68fee9ae8d093020485ea2af9941bf0f713303c00a388f8442901ffaf6b8b37046ba3bc553260f0c0b4208d401a35aa8404e465d7788c9cf0ecc2c901c05198bc63a3378819f91434060d50700f45efb6cac09e5af798de9bdaaf8940f5ed0b79638a8597e708e89d6894f0f114f3a46edb5650fb9f5a69e075b3c06a8e692420db4916ed570521eab87ac4e2c9ba09654d3eaf9087b04cf39f8dbadf6beb8020dc26adf75edd73163c640ac81157abfb38bf9dcabe7fffdc354530fce5093abe87df5c3c7e6325debabcd449b5383471e2fee84c612a4a4f9fa1caa7641690d2ba111b0c39b184dcfe170d94547d6c6fb8e8d8d56b0ffcc1ef3af0bea4e96777f0d3ad986c96cf7b14ec0f5e36babed6421c5a74fd63e3ca73717e0c2ac14f2447cab02f4eb891d6552a1270ad041bf16ba3074c7cc69a0a157f81c378098c1161545fd5782473dbecac115a73f35c2d05ff428a203306ceff9f35fe1deb06d9535fafe3ae12931cf1368f21d6347baf2a99c9e56bf0911939f3f31db645ef5241969f8d685cf8d9b60118d3175b5e3fb8748266df4658990764fa43f5435a87e54d6541f5d17cd5b4b30644b819ad7c24b73892183541ddd95fa24bd23f36f14ea5205cc7cf2d30397a004fac391f0cd2c52d327de62dd1c13addfde8e44a8388aa9d689c2aed9f7185139111fcedac2217f5afced4f0de6ae217793a9d60e5b753b760865da3afe2d64f8b81935b3bc7a74e97c6714b23cc743226b3ca7efd7472ca21d993f39d8188883fd39654b6f4db5bdc36dd4d2a5d2bc47ea96782916f9c4b7dba98949acba2920513d5e85b0ebc0634049b333a770614bacdb46b6544f52255bc2e61034b600d7d1e642a35c94e6078934d25c76fbe1055354c7babf7fa13d61951571cf49248e042c9b33fb295221eef021fb2903b0ca703ed796600074dd3f1ea78615cbf47b5e6d0167d291b702ffe5f39fa72d56097d73dd3e7d7b4cfeadd6bad7ea33ef7770eb5a27cbc709b793c7d5a79a526f91353cedbce66dee974cdf25fa57a6c84b6ec8eec7a7bac58cd1a17c1c097b0938dc091831b1676bf0e9d7a144e0cb893bbe46dc4f619f647a720d6a7e0126f96e3602c9c711deef5c08d70338c7c27aeaab527ea742057fe4e3ed29159c44d81d1ce036a405532018cddcd90866fac5ec0ab5ffb3948d057eb7f339064449703c3dbaaa79391027833c530301088ac6462b398de3e92ef31908424e9ebbefd9be850f1eea5ce946b9fcbce832429d2487ebe753e4f010d5d62c6091941e28cb246ff5bf690937f476b1582f746be3fe1e1bd11355fbc7f3599a2836c11b4bac01183799dd819384545d3cde1cca4fef7f4e098cc51d304e98fbfea2a6ed7b4ba390bf24bb78a4afb532244b45327779f0c2331c258f899e04a71221a1e11c4fc9721e63b4eb64074ad837bdb9dd1b8a0c58a3b21fc54449e20d30426d06af6e9296ed0023c5aa31eb1d36b1e2b7a6d10e5b0170166feb7a48289c29cf079702e631653a33780297593b076271694a78b0526bc338d39e1586a2aa2faf28b0de60eaae65e9d604089e6e66b7be9da133ecef57addf76d3878f5fdb9b2608cf653ed59df177ddcf6dd0c6934ed2bc843ae5b7e396a466fdd7792e79374c340bc632e5396df04401ac47e8be002d6bcd498cb9e4b790202e066322ab22aeed66d16ba8aea5709af771219f0fb451139b329818d035f52eb42d34060101d992a74217fa5a3d77bc46ded41e7a1a6ac76e3fab6e14dd7df3f2a52c154af754d672e9d23fd21cb037b4477018ec60ac2b8bf07d799ad33f141ec9719029305076801ed1eb687c9db6a449265f547fc1034c0709865f763d6ff9d4201b2c2dadcace6b48590761d410996a9ff7e73b46a96ca115a2deeb25914009f80d47566f14f22c493ed039c775e26b83862875231b43de126d9b9e9344d487f4d1b1a804e34f57be8060894057ec023ccefaafb305c6c892911a58204f5a8cfdb7b4eb3aa6f76f8675a5a21a26a1a86fdfeee47924bedd70a277bec70783734a1a950b042c352f3d7ff3304ede454d8237e07a84f823a2b42c69f847bbf227e1d4683a31427c9e6142cfb9bf5d9591e851d89e48ca8d730e4bc6ccb8938238592edb2b6ad8546f3621968eeb5728d6f39f3ced84395ffcad96fdc5df50cf001633e7bd1e0f1b6e563bbab8f0b44b442081c221530574b4356e72a72939aaf3558016032f47b901c63f72b4bd2a6e9672fd6bb4cbfa12d3b27518be291c6896fcfc3d7a6eeb5db0fe991fb634f150d3f0d58d3d81437389d80365b2336924e8c802116b806ad3c9cdb1801a3930797826b7431773a029f766af56a47b73e7a657c9f896f73b1b86181aa6de2754d0f25351548625bc3b71a8467a2eb0bdde8c7a7eb665128d2264a030951e73786c442418e1c2be79d058e22fcb27ac16bde727bc3c7c4daf23d0ca42ab796b91ebe37c8c2f97e22dddbc17b7979d3868b4fd8d8f867327706c04d85f8f90a57d5b7040fc95b87bfcb080a60400dd9db18425f3e239fbced0e58d8820d0d4da1d7e379765943807dc0fc4ef2cbff4691fbe545c5e1d5417fd9353f6bc645c094e3957724991d25f9ab096526c603e23e3388366954133595fbe9a80f8804e34021edef0dd67de24b4b3c2342d0bb067e3ebdc31df7682de13bec164462d3c39fda77951668e011ba10524020bd6f01cd402bb049be8c9f10da0d9737c61ab96bd3c563abd6c3489b6089890cb19073c4965b7e9f8d3d6e05677e981fad6d8ddade86360ed2398a5a3fbdcf0f046a27a733aab6f547436edbb52811ab8ad7143eddb9d186c0091caca7fa00cd0a83a5b442d7a5e9c1f31ab1efe2cfe1bef5e44fcb1399d99f4502129b84fced3e9aa0d3087c546a3335ab861835618be04901d8228dc809b65055f218a1ded774ab7e061a2ae05201737e6d25bd52065eb6ba4b153b9ca5daf5acb297ecaf8748d00dfbc2116ad661f5f4bc8dbd84f39ae03898899a9a1a89a3f83a3c7ef908e4573fef823313f948eb3194da90004ae3108290f148282f3783ea8bfd78902a6a8862d215b254da5f8e5cda60ac8b36e9c493afd9cd92956d060db520301447b4a3395a31efc6b7daedbabd0163af22a03711e1ae1962a18e8842180667a6a9031ca09a57c456649b58d16867acbb5ce5c9ba37bd3cf3382ba604dc4795b0cb06ee9fbd32ed4a3d05230bde7e0dc9f48edccb86292b974de420600c96327964eddc31b41bf5a2d308d9a90acf0759934da7748c7bcdb7d955f2a0bc69920c7f7047736fef22c85cda1b0b3e73ac0104ff30d4b4ee2a35423118080747b063f1848dbe576dde17698e6c95ad9eefdb21e76d3ce83912121231fe8e61524f3bda8fc724493c14790eebb71685b80a16551deda8fc2baa4f72eb48e043052b3e8fffaa36040c70d09c102e0d68c2b93dd2cdce8b27fe9ae353dfd842b256fab8395dfc711e64ee21544d55be1dbc747746d7f23614839464303479d5c35bea411ae8746ce481769aafefc4f94bd0112a7d700c6b14e3de7516f7328b2013867878294dc969088eba38ba9e3cd213c58d2bf211ff9827382326b78b74dbfae62456644b82408ce83561ff542a49be55c8b235dbeab930277acfb3031d8e36985c9fd7d1a4b331887c6a1a4495586184ccfa8043fa756d2031ccc95d26d1e2699fd806d7cfaf6bac9f1f27c03d220bcfbbd1cacd3a0d2f071457773cf87a55a678ba2bccd24e5b5e078c11b8eaa0815dcf3407b6538021fffd211a2fb543ee5bbe09558fb0f443f47138d669e8e67e1f41b2249e05eb78581fcdb4f1e3c84d03cba016ed62dac65b765fccf8a5651c39ebca9e13fe0e8e148e2d5ad4cde2afa4ec99751841c53c8ead0ed23e55ef1c93403fb5357b643fa2ad54f56421b4a347bca08915a5b9a9d5e616f57e3addb5913b443b5c2d5ad75822d4d958455dc3be723bb396986a5f216364857f35ccd08c009992a0003a8e42c2d025da730767dd897ab59c430fd43b717c45f7949576a62aef3a98554ae816dde7dd3b6f1729117a5c214a5cf4b223363ba7109a9fc0d15d9a5e1d6693e5940a5b359b45d8be3ce0c4f8e58abc4a44d47213892e414313db1acbb90507c5a25d3538b5680937a79923b621ea6442aba7cb51c88973336b6b9cb6117900d0cfac9345f5a740e84b87defefd44369f050458050adf03a634393e6a890f294affac1b2c5988ac8103a26e11ae75eaf042f5b0e2f1f645c9527fbdd3c0e29110617601319c74f5d2242649144a13bcd97e864ca0d77a167f11dcf333db037a0e7eec35399f71af0ca2b8db409d0af06dbfebb2058ab1276cb5f0a8851e6c5c59fd54d99d8af42ed9f99dc3defc815f2aaa63cdba62b32ffcd74439f0578711cf955fe8157d3f995a8491012e4576ac2e536cf2ccbc797cb6109822aea75a4067cf93da506017ea0dc48fdb1c8ecd8999104a969b730aaa798144e14bba806503cfd556ef73e0e75aaef48d8abac3e36a76331f9f3f5ed7238fdf7ad857ce9670a3be693560dc15e0628320c6ffb41e6501fcec08123f13dcc9ac12308b3d005bee78f9ebb7be77bf0c06facf3cb11a14ae1fda0cdc01c95c3f3bb46ad542a22f962f3ed0b745a506ef7898e429bf4f83958ff82c7b93aed82e3dd72de20d14480b6b66132e1adbfbce5cfbb53c9b5e734991838ff4ffeb9ae80bdea98aea693910f1439e4080858c7b6ea11d0338ef9ad638076fde06ea036af1fff24d274e789b75877535f122c2419a620a3033094a06927f96410518d881c8e3298a251dea3564d4a86f507e6b6c92f918c6cae6c0033bf84c97fd573315c872724b9cda6da73ea7d393b8f3d2bd89b08acce8431dbc2b35cd76a83df619b2330fdc7633fe78da8a00dc80b303561c04342878a0df166ab3e0cb1f1637ac89e3c8a8847ac0c212a6bed6d684bdbc1df321cb8d2d227e134235522d3ad3a80fc7b1b080a5544b0470c0c5b6526292c71180dba7ca264f79676fc54a2415a7f198a7d5cf1d38d4edc2505dbf561ae15addd2926fffef205c1d106ff6a13b50ae55449924b819157d63c191a30e86d1baa495f3fb8b0ae63ae3186c929fb2f617c4bd5dcad4b29493be405f5267a89b42c3252d796190ee8db744ff3b8804cff21807fb8e51037ae7d444562dd9ff1f2a025af2b66a619bb687ca5832fdb0b56c5fe5ccc4fd4ca1e59bbded8a5b411d59143c3bef77e1266452fdae091c8e5a9a2acf007f45c41b9f0d1e4df6eaf7ddf78f1faa2ab569186f92ec03b1c42d6b6545545cb153576873ccac4dcbdd98b9b897590edfb352d96021e5bfb37ec187da384b2ce19a5c1d4c833a412a28444c5e6bdb56571bef71a4c671ad15ef7300365a6cba99c663b2df2b5154df86bd14168c104fb8785145c40ab74d14b057716493a750ed7ecf1eaeb4d3f5a28a7e22a25afebce8aa60ad7741ae8494cba0e949181d4145a646aa583418b03765ba2cc18adfe04c1f3094992c15614c66190ef5bf177ed07ff30bdecaf42b479b0e5f3ed4fbc02ababfd455f2c2011994d6f8f140dda396401dab2109887542d36a8cb6da10084c337979ff931d32967124926d4814ae8004fbda08bc30d0ee76b9d825296fc68deeee26718aa608def50b65d0ce0a8e450fa8a9d84ebf9a16fc62ca511cd14d657abddd4a9f35c82bad635bd7309092ad1aaa162c59eb47c87c69a444ff6d641d4a1f95e97874ec72571cd5f6ff375e90747d8960bead34c92d062f4b862feb18cf53065ffe7204bff03d7803eb36a2f0cf7ade8488f4066fd138bdae0bfbfee1538c0c39a3286a977ad941ef1d0fb49dfdaec9bf7ff0c29feaa1af1c77c72d4a8df6307914e90a137c7f144cda5c168428d5634b8380e6895d05aa3e4d503322d387e075585668a3c9d8d6425261f1d06f2296f8058217c678bceae366b664bd182d129e7646df7caed28df72aca89c612590979748ddc4d429831670fe7de2ae614e4ae6abf1d5dbb0fe8ecb03743a57c206e7c5d0cedf65632c1383096a8e20cf0fa21de746bcbbcb8d7397483bd03f0e8344e434de2b768f099bea3374b2b03320f2cd6047e3b1a81eb80195e1f74a4752c52ab8e7961b88c3d3fa179fc1c3625a8b4736d2176d0eafbcc460a8ede271978329d4b41b37b2541103d1fbdeaaa03369a24844f42c4a5654c83ad56893705536db60122fa07547ac8a68eb2893e37f380ac9e5d33e15e8b371b6f8fdd5a71ee0317d76c515143211e4f414aeeb6b0a9a697c8fb9602e29ba382aff529369ec53fa64273049d49bd25befd54b9a441db1ff09c1a03c6036a4f4606af594d0ac8361069d4a841a84d6a6531363591852abd7510496c782f4d72f272ee1f495771f56ad656a9e1fbac725ce67b2f451b42fc5a2fd991c80cc874fb2793bf0759843247fdffe5ed1366b69500291bad3c5f0ce42e05bfbecc98453f82409998511a85398dc75c278d9a91599e0de88ffc901bb6369225c0c87964ffb5d6a0bf6bde7ca2351610071d9861214f6120ab25e7fffcb331fcb8f79215db5cc015baece4311277e2a1d4a68fde26fa63a47b3040899e72ee968dcd3cb16220a73079ac50a0dde655838942589ace0a782f0224c8175e844ac253e2410b2d639e901987be2f042a10a890a1c3f5885a8fe86d48aeb51beff0bece73fefb2a272af86a6183e62e160da97e1653af8c3897c7ac4732721507bb9020e29f94706d7f3f4f2fa504a52e28b635fbbf6721df08520ce9e4cfda8ec10fa8c2935994d0087866d7121fb6e095bdc7fe7349bc03e51c9dd7173fe03ed8d64eaf2c4baf85b8e00f2cbf565f22012e9325e140fd8f10fc1933684e2763c059c5f319dc2366cd523d3985eac3929591fed34df3703dd3c8456ae673c1f4a64f7a0e295808a1049aabc446fcc40ba95b97f618135961e9515b44ed3ab4aa83cb2170b47eeae0771ac6df368eceffa1bdd51b3163ebfc75f2d456b5d06651791f1e9b8fbab2e6d8f3776688699f8f1a57fa64191749068236da081a4f1a22019bc2c7c8589c5ed7002799e5dbfc06571803bec0e76aeaf8dc4721d75f017f6b4eb5d48dff5651dd2e224e893cbef51c0b7ed0ed27587632b45b9a6a2c1532ceafe62a180a3b3df2b64d006c6d75b7c5a09d6ef4b6f75e6000a87f168b6ceaf4fd9619620a52b894c0f15e78121fb6bbb565b06db92f0637cb455d4529b9ea310ff21ae7826ea302496b855e07836a08875333e0501731988d4b7e7233eaf0dc8da01302a9dcc25970481406920e444cb2163e7a9ff541e7f994689a403c6f2455372835d6c35ec4e6cb5b31d1be49976deec46dfa8b4e94aa9bd617495a303c55c552b29e1c5cb0c7ab8d87d2aadb6534dd005d077d4a357682ec06bf5654fad1bf5a95b443936df39cc11d03dc4d00da41106b4ab8ced0908df1f75400672fd5ff695f35953abd5e4b654aea6bc8f93ccb4a6573f1fbd71b36617ecc5c5277e33d59c25ea1c053bb8faebf31c7cc1dbcdeb07b7e70e09d444c71984fad6a710fa6f71192dd6b05c3a510d4d2ebe0e760432e385024869f9f2ee9a66a1cc969ad8f2a7811b24c624bd3d0cf78160dcc4af7da6be971f9ac5e1af47e228cd8eb3f6d7253e73b236743e607d1b1b510f7a109feb392f464d2aec2381d124531f497e0cf7a419a6df971828db143d6caeb60bc8be851ca7b4b840dbaec7aad536f1a0b8270e70a7c584bca0e25bc4202dd83c94f7558725c8a76e715728b0318659b1d272bc60483350746b32eee1dc3cd01b084f15fa282f7f91898e396d92a34a5756016f90f7ba5570934b5cbef58f2e2cc447e2fc53dec0acb7dc3ba99951bd191a9bdf4dcd2be5e7a1fc66f5c1f640fdda34788f9e241a7f2fa62cf3d8786754a3b82d1d9e92f3aea1c53b0bfba51a96728c7ef38397d9550199c48c3ed9f9cba407973bc0f4932cb6fe500704b0340e0fa362b42fa6f1f0625099d26d60ff736140a6b9508a2d52c7381c12e767dea29d3f3ff426ea5624d161586404561231056c10015e89aa27c83c2842ef6e9198f9d51f590a1126dc576a3c29d084fdbc061a2bd35457966a67ef54d468ed04487c5766e8a0bc98595ecbe0010ed92e7abfa7cce3e273813738d05b482f78ee953218adf86b3b77579ecb85d05bbca173ae4cd327a6d0ed5e437e7a867555c267b7fb1e99994d54d97250d3ffcae4bfae6d593f0c79c5545a62791ff8596a8f963dde7d88cddf48ee71d017e471e35c82fb6af9c659d79d7359711076ea62f72d68ce786e8e7d41d9d6e346f35ebb681d94f8e4328c58ea4d327643c80ee0e17c926f9e05fd4c6283379011b8dd8d5eabb96e6eeea7925945f034fe959b20706abbd421f2960b414a16a03073547627d725cc5c1f3591d3ad739fc320de728468792862206819e79f19b9b4009e1d0fafb34a4a48642c304c8759d86b545d425c6b79315c8972df7eecf56a968eb69d66083a6ca71455e54cbc189a080a26e393dea58c48288882147af57e3bcb1aad931133eac2c04bf065624fe10832b33ef374493a10eaafa2e82dd134be73c6ca78e74c6f97fcb787d59423582920e65bdb831ce21a05e916f2753e509b5df4880e0badb5f8eab98ca63cbbd3c9afc1ee4f7ee9ec8b98dba21d7912d772edee8a7ef947ede25dc77cc6790d69060fb3092fa8b0f81159aee9b753ba9a9489a99774529704b5005aaa3ff1763fb40677661fabb4e7ee2c4c4c2912e8f907d056703ecd71f1f610537580da58ead83684070f8ac876f4056769738949fb67588ff72473cf73197068e903a525f340cf240d1e628121a4c07ce31b5c904fe6ccd7bcda838cdca60a4c88b390e2130cc026dcd848d0fe31bb4d41ee85f7884d1c59bb099dc1bc69626b069d9317bc822bacd5a776302df19805a9e16e25a0585e8e49738ff229c8ef24f3ec7f2454aee5a14aabe11dd4a0efab357cfda6fdbad187f30a7645d5bc7c0ad0bea9e99baa87e8fa182987f723104e9a3b2d77fa741d4d46e2aca96865b61c459c492e3770ae15e4301bb448cf022986a7f74ca38f50fbecac8b33dbe487d29804234235b14a24a058af0c5cde9da6e967eb215cc1b51cfe15e9972981ae582a93846ff9669e2fcdda0071365bda1a1b930fc81be4b8cc1d0610e1a9d62743c2945bb052fd5df58b409ff40f66dae6df3cf1bf032482be78b17857c0ad86c22b0a5e5d2172862132b23b1b299a237d5c167e9275ff68caba14aeac1a26c42aea01a5464e3c15809da9d3089f4db5f6d5c2783d76bf393493b0022a8df747f0e8c594b5f15dc03bc25c5c7bcaea09aa70b18be439a696ff54990b0703dcbb65e5b9ede01110f18a27cea6521753c3cc008078d5a2755a7e115651a259df5df85a9edc7ac0e79aa0ec70c86cd8efe01eef1f928e3d62230c14363f6fdaf2718f5564237675d2d89b0dd439f60d98bc8342fd32b9b3a08282b63e880ef63b3de97b2343ef2c07b1444032dad5c525048bf151685b12bb55ffbd6019e84656ab8b4e04977dc0dffb9db9955e63edd6ce746f012fae11c314ffc4456cdf668d53bbd04d428e08da0b842485a8abbd912fede1ffded7401881b56cc5ab1178fcf0f1d31e5308436b14c7b881396d2d768da06deec4d76b84b2daa9b70c83664d4d78a6a22dca3f95dca949349b9a731fc99416c5530cd0941a14b5cadb8d697ffae1bb5364ee3b5d417812c661de01969dc772f2a2ab1887bdd6f60261001cd09f08e118dd008d1a51670d4ba4c6b2d61d59bbcc71e58e94de42775ce225da04232798f2bd985cbf2bc755d7452d5716f90870fde8d258988258d5e2af783a2e85492e23b6e3602a49762d8ef0c3d61bd7627121058e3493ac4537744b047cb243afe07c8969274a90654005422c521081c0cbe0ef65cd79d1d54eaf627cecbda097aef491e65cc4ffdd4a817d735233dda2f6e5a4f9cd8a31294c5ae206d810040631fd523d33e4924dce85482e9e9eb6d78b2f8fb3f0ff9f0bc16d014db4cae524b3a49269f22651d3467810609070070f1e33f0a0e57e0fb8aa8e3a80d9bbed991c84a64c9eb76deaf1a1c60039fe16a4f346f044b399327a1afc14687943d036870506dea6e658b970f3c9e8e02cfa80c825818b82c3007ad64399d716db54561d04487de6e7c3d18e97a8860a88d47be54d0184a98e141f707130beadd1be4c5244a68295067258282377efb36a83fee0e97b4ed43e2288240b0c4b66c7ffc21543cb8b059ece97ec131ccaf7467587627d64be58cce5a3473f1e65c05b153f304e63bd32006142459ff3bf9565f3e5e98507dba014a0dee4e9dc4742abd28df61d1c6c416b562cd2cf6aaddc63117f2637b450c999bec6864879384a21b909453015fc704fe83b6278d4da76b5f12e29eeab34260bd195119c3b1fbcefffbe17ad9a5c3a74496ea3bd619869581ca68d1aa39ea817ae89490de6f93dc9db0290fc1b1d8c6ca383f9307a55e15998375febab854baac8f738da57d51481f6f6c46f16b8de8016c10befd6c6ab72b744f4db7c7f82dcfb8011fa1c671549d9dbfe8745d0e4c278904d88b31722219566dff93c5eea5512677a24cdb3c06cccbfe835f395231da3dda7c142a1764fd58cb9a59c1c78ebc6b425762fd046b95038c57fd4893c6777e841745d9cd9e42cf6c22ab598f05e0ed0c55c779fbab1fb14f6548a52a0cd4e6c90d6afae037af30c30c049a4d081eb1f21dbd7bac725fc611151d19d5b2e2c356e6634ab678a07e578eb8a5e7db836517aac5a1a046a6e80aa7a8d95a4c795474d94db1e9f3e724b4f19f4275509690adaa969070b623621b1e9831754e06db2d4e8ede0d497d14e1d0b535cb98b87f91251940be86622eb6205c476fc87df6017d4a5335d68a4ec43f4ce363e132197b271f742f72e2904029845b625f361081bb8ef3f39860b7323d56fb99fe7f4cc49c893914eb34eb24257ebf01d1633d3fddf9c786a17b652be899b2a909573f63e1c97ea5bb6c28ef815b071650f11174496a8baf1f85ca8667dac38e56ee852d9290ec8b23678fa7d4ce224778c448433a1093026bf88c8c1a178dcada8aec72f58aef7f7ed75b91ae653f33d1ab72e2be29777c17e184f5b8439a71cc76f5d03e7c54b85e98d2cf59e25c9413f61567a3ee076575c048ddd86109ab347f9f4a5c0f4fff0ca97a3d3c3f08f0c4d82f1f73c3fa2c3cd5b6d8aa2acb89d95578b27f16bb93b1b84d04ea06539ca0314ec214041c22c9e48e6b2646e038d78a659e0e97e872a84767f33903a942e9162524435613735843f957e114510d449be01dd996ea8dd38203255196ad9b5c9cee5e5bddbc2f69d2218885023f1a6df64f9d44a618eaa9652ea42b594b41d39648b7a7680113d98c225cc35f34e27d2930c25bf0c5a89f071b4ecfbee51f09ee7418f6c8799c9a483c33bf735d2d15a23595f153e8bbc8314348b4058046a6a1fe39f42cede5329c836594fc80b39d21ac7c30b2d1b9191cccb9627785ea8385a173e15125a8197d729ebb74bcfe1f2e6f51f13e27798e1f2a7d53e16cf757bb57652e2306d88b257c65945cfdac87b83cbdd497075b4cd32eee1f28e1479257a9f8404237ac73d94f7b616d74e24010c235740b0f385831c6265f2a3b7bdacf5c71d7cc747cb8681971b1fb4c127ecbeab7e37ea714d121a3c9d8b82d80b306a2f7774961e7f968ff6a1221b1a31cfeab5fe59ca71a9bcd2737d32a657cb65249cc34f94414559022e53871c0ba8cfffc5644367d19445ba58ca6241f4b3c4e3308d135cfe36f6d7f7eb411a0e9596231d5f936668d183106e621b6c4479ee529430d7bcfd3e37f72bcbe37d2c0ff6cd191e00a40f63506ea09156c2196d7f97351a443b239346f292d15d8d9d0ddf0f96a56068dae7729d51bb1788cb7dc825f7d65773a780090eaede83ee17739584f2c0fec5eef513e5937a285a5f11c90a76b05749edb605e6130ee1c41163e68fa7065b37659e0f5f50d48c50ab88f718c19e01612643e662fbe4cfe3014fcfe1086696708b713363c5e39ff7e6dec1c2141d7b7aa64efb80f5dc0acd3203a5fea771e1e1ddde48a80307ebe637bfab1a6651fdae6dd5b5ce6d8e6b95f4c277b53c65500d414fa136f1ff1214c90f6dbb67a105ea12f318ae1654317b71470133c5c5ef50b828cfa1cffb110da20049682edd82acfa4ee51b49f2f6a28bcce2ffb2d9acd5cd0813521c4b067d43a7b9387392039afd88048ab778df9648981607fea6f8bbb244baa2a3f08a8e315a5ce32def32ad64ae33bae7d9658875ffd76e9f73ee44da4edd505270cc53931c51d7e3ce2c1f598f101d1da65894f4175ad7e7f5fe57edc862c1b7c29d309f07c693387b8d6774573ea2f84cba2f810e8dc788dfb55d8fa4b067677eebbf795291454506acc4d55d92feaa4110b099a78df88216356cfb75e88b646f6ca456a9f756dd464b6f183b5b3891bbd7f1d5e27f8109d51132f86d7631091e428cd697c88b3f0613de57a93397c1b0465e0b4970008c910b9a1d8a1aadfb07dbda5d564b5fc6a2912b786e411c90aad375b0d1e3ce32ea3fd053d3be3b1c71d39ce915ed861fdd41737639a202c37817e93b31ac049b36b1a859326e6f6ab41bdc0e6ed492a81228e112e6d9273e395b62564ab489a0307cf44d567b1882ad9776b73f4633b25ebd255a617b74fa93276e2f720fc60d40aed5982a24b48206493145c84b640f947f78be3f4b92779cb76ebf047829ee1314c934548fcb1d4132b841ea65e9d3e50573ef0f0ac882d95cc5437fad36c830dbf12a270e5e0066d1de97682118df8b1851bc1b25494e1717a04c28ff35b0c830d5e111d39a9246bacf2fd250394b366f7c636b5a352c74f89264db4ead552afa52dcee2272b2d34a8d81bc2facf5f4b4e7fa305f1105844c467b05ae06159ac14b769399b65ecb4a88c8ee98a4156a9a2fdc35064c3b5ca7cc2e92b9e369e02f2b664ab83fae88e3ca87cd2ce0088b7082c3ecff8e507eabf0d650bbb5b052f211225c76aadaed246b9ca1bd7a08dc46fe2516fb413fef341c1a38ac84361eb5cdb9d0e7f800a1c5a6fea03b6a4286d954a1e78e49c3f6fbbfe0b10ddb8a29a836d462bd784020c95af3e100e2ab2c6bb4a9b17828bd28897735c4b3cd8f67c9ae8b52d009d318f7c2d7e95b9dd8cc2874f3406acf123a5f25319e2bf642810eeccf529ef6e5925d4aab4b75037403ef3f4a6da0108d5529ae8fc2d04a5bd29483255cb8077498506017af6c71e263f3c1f27a4e20a4938273beaf328f0d1c9a8d1262ab9171b04549b7a2fe369949c776a924cc1dee422e7ad7e35ba1163ac3f960c037eb2ef74c68f665a20302a2ac7edfb49f79dc0bf519a6dd3f1168f3e7da1804a65c84bae563d531c6b525fa488b6fac4ec13ffc793f6eb9a19822a3c4337d9a5a4142839283c12a6d73fafbf81aa72ffafcc6e39f64100a79b96d5a44f4905059f61d973b949beffa58a3d1659c6486d5753752b54dec0f0cdd1c60ea6254a66997e7f8fc642fa288d7b3961c7e9a8c863a7dc4adabdbdeba343d0c40ea14ab4c1581722b9a1c08c5a002ab936c64e0ae45fc6c28feb757ef5209db7c8a211d0ae668a4e9c01f5d67c2a9ae63a3f9df8807cccc6671ae7bb7bbf4884662a8da410f019a9a147447de3f503ddd9d8034e1ba70c3ebd11299c4b234494a0c6c56fb9e3d21435a26e8a0adce16d6c052178b47877f24b0787c385b814e63404263665227a57b526eae89512e53bfab1ccd3b09aba2fd18ddb205109ffe2c441c66633f027dcb5d3062df5e41c8e813f49caa7512e92f623b575007eac5e14030480391c6da20b4a3b9b03465e7994c2162878d2ec3e888011f02c382b16ce210508d655798633c61228584ea008b6f60579d4a1880c980f0ab508ebe6a8a27b346faff4c3ae73810a5f55eca06b9b633ce411412ee79dbbaabd58a147096b510fbe30fe0631ddb56523302b38b94ed2a017f015f784ef61f08264208d5a7096deaf17fbc028217290aefb68bb416f4021684896cd90c75cef30395762727630c433ebfdb8c68052232c4af7a89853a6eedca5d10e5108f717289357f9d84ec0c1aa2755442db6d6cd810588abb49d2d562aa57f4e36f87bdc18b5c0cb5076ed1c9beb86e22f4c8ae67a005a3df695e1c52d938a584b0334a98a736e6926faf1d0430fb56c8dc45a0a05666856a083a3a448cfc92e6fc32de6fcdfb5d6632696300fe8138cf6bddf619afea78bdc0de98c0617f8456e6e74bd32fb5b0d79b829ab045ed208b385641f03bbe17680b62767dc1d44ab6ff6e67395f41f239a34b100283ced0c41850a119ea76f793ea1b0abe38595f7df606d159738b1d16753a69bb70230973e26f418d8441c2f5caa093a0ef2785f08dd16c5d5a37480c004cb02c2c610fcf797d7415586d865905bde508883633179df42c16a645b06100f76be66da8d81be2aa8595ac06357e0084de6f07e903e9e0fa0b01f45146cef537ae63acb1ac83766abbd05537c564c68183a368951e1773e5a89673f1c425dafef1096927cd0081aaa9964ee2a26e6ac2860ad149828d6c1b055d537f2221178d1837995dbca48c8f6bb5cebc6a55fae53492e5657b5c3b320736075870dceb0b8963953bbfbfe14af0fd79cbba6c961e58afb0e1d3c139e1a0c36bc0cfc1408d401d38e7e7e3245c5b95ca6e5e871c5c42130c06d96f3dc871f05f31cd7d5f72f4405d426587a4a9338803caf1de0fc79528b055a25f3cc0d0aef25f4971354aff4fde0c84cfb3d7fff77245a6996ed0bc1b44be037e8e07b7da3d74df05e9ad336212c2db2ed407ed5f3e25e64e877e8d2b7150ac5b125769ae1ca8d310d4e7ddef99f1dbafef5564f5f2f7fbc3b98f11f8956ae8b108177cbd9eba6cd1f8cfc0ca25b1eab37a014458a6d264d80c1dda61550b6d849cbe1618d10e7a92dbd4728a8bfd0b3f4c5e59b048fabb6e641baaecbb487f001f149839aa828e11d9dd2656f189171a05fbe9420012ca1043626dee984731984bb6df305341592bf112c71a081d069197474d0a4c4bb6302288b54dc4283c01c6cee08fc774256da3396aced019fc3db1e6f21420bed73c34c690c98428a1c67f2f2f2c45ffec77915b4bdc92932429f10b069829bb36fdca3fd1c618914dbed939351f6de896683d4125012b78185a9e9090e763fe5cec0134c8dfbfd2d691239ab401a86c799bdf8f0624910b5addbde95c82222687ae55146443d7d98278ec514c09b8b204a1348539c5c496500ba49e3a13b340ff5c367ca56a23cccb80f361f27cc531011509f2c802a7729e9e0dad9acb76a480a5e1e46bfc70fe660a43166857f2bac6e63d207a851011efa7d2a7bf5b41055ec36345fef26f42696aa260dd7d5b9f4e1b8c09eac5203a79b4002c479a26846729215cd3294dcdab8e7b8ae8168c75572ff345b088e4b19c80f0beab3d096dd8acd5421a7d95d40abda86617455e9301048a27488d49622d1cccd0b6b685e5d3689a4f94b9f42f06e2e33645127cd899601e0f1c1b31f712189c17790b32577414ecb4a80c1f8acf2637a33b54e52e97c49b223d0a94279ae47d21976653dc7f8db820ea2f5a577c9ec31d75209a9de755aaae7914c7edcedd68a543afca3ae8f400c55d73a55af09c1a5f6c02fb5521a34adeca54e227206383cc575c661435314376d151952142ece20ce86709b7048041756f885a08e46564bf26c3c3b0f9de91630afe1d0557efb10f2de5106fce9ba7fe1923f4308caf32c9fa59390355a4ce6c79e1934f45010fb058fcd2dcd94d52a5b21ebf81f1864bbd45b56bb5959f62aa74339202c2c24b4005b6ecb371d07cd72702f6c1fbe8a33c41eaecb4a8308c8811241a15c7a2dfaf49dc3ad4810bcd9c000f309c8ab794bec59c9f59f8b9ceb73d5b5fb41b2d3f195e473cfee00c9a5d9861992f302e4b8aad1d435966722ee5ac74cad35d263a8fa7c8c2a6fd4933b318bdcdfb45eb164bb3e7fe28a2949ad0b76420626c93f43b576b13558e684fdfb35b4fde3297326dbeb0ed867cd2beb15f00cb65196de625ce3de04230beccb2fbe815f3eb287cd98c221384127535ea14776725813241fe52f93201c969e199ba797a2ac0eb75ccfe6902dbc1ef86799f27317ba819ad614ffe89a006146c88e787a2c18e460de5f7123f545efb604b98a03b8bdea817e17e63c5c95ec7396c81ab616b5c87da09defee1f2de2cf934032798482f86263f5162c8a15e7e5771d24bf7482ac97007e7d3431a59f7e16fcf3bd7f7a19f3912c003ca551eac26f6c79faa65859c8878c6a8646d03b78068963c3126e422ae0a9661a61cb3388a900a6eceed733d6c5abcf56b44dbebdde25","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
