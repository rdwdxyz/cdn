<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2459c6af02fbefd73efffd36a3e3c3e2ef0df1880f61600b88ee6b54805802eb36aeaaef70312ee547ddeb667838ff0455d7d73c2da2864db4a130925591fafb83ab3a2a87a22804e248775e01985e75a97df24ef6112dbf198c2ce70088b96bb294c3d31f31bd984e3e8dd65fd4017d89cd91b599025b28fe5a1bcd943f6b2e844b286b9b090e5cb21060aac66d32db29dcdbc43e847a78b68f6612e6010f3f2e92cc6d5c92a0ffebff8110ed835b86b4b393c2519d6991ce2c814735031b61141b5f4594ceab064474b6af27904702461d604fed327225b7987dd0b71be7ab3a578652d21b75a4d2b42d05665f7e9bfb38d4140f692af5cfd405c0182501d7f4f3e985bfd0b16d1aed8bb3c4fae9775a68787a053ff8978fda029d073db4b5a0c9939acd85bcd663e9d6a7acaeb95f437885be642f2e4c087a64779c37c5a432a630ca0998e6c1f4ef1e51705b1ebe50aab0ced2a8e72b7ac228097062e7633c5f80a225c4c07a301981f8af8ff0e0a20a3e05439272c042c20470f10611415159e3dd82044718552229bafe260edda835364159b3edd17b5f148dd5338101e0483a184069c82248107fd593764fc943ba52499a80b087f66157f149ab5f26f3a144f0778ef2e4d66710c97ce62530744ba5aa151e9994d53f1203d3831430b71e835a6589861089f59af39c64e9a627f73c15845c8e43f8107d6da0279e7e95d9f33bbf566e3db7c718ba3660b35d6c5e93ea57c888e482f19d06b42c2ab083e85d6fc8a0e48112ed8791ae1605970ce81fc64e626b4ba0e55bda6c7b2bb139e44658b777a5de80b7f0e78eb1882e78c5fd51f3356684e4e954fb2d096884b4bc9d94aa3308772d913509dfcbc238fbf3c2267e39b2334ab5010ee635e0e354812805787a95aa45a57c67e20ca43922a104fbb3c939dd3a919825e464a84669d47c6d76f92a679f8457cb61c526d95acf9fdec60aeda6133835a9e6816f2e78662a18ef7b2e700906ccf5ba88a405b20787f1ffa94e48e4bec054ae6b3e946dbce63bf065f940ba96428148272fc1b12ba8fd31a731aec9db769eced0f01ae5fc734aa4d9748f7fe73e01fd54232b4c8da73edd5a39b83cea694674e6b454a676c2c9075aef7637b959e73faf46b1bb8aab8b59804b5be0029a5f44b6372a692121804d7537eeba6b7f6ff8752a524b3734bb1912a86513e3832372bc9562f503cbb23eacf858aa32a753701a3b47cd61a2d4ce97636d8b76e0f5ecbaadb5830ba5ae933c04656769781e1d40c96348a2ee6b2e3f01d9902fe59fc6d2a22f59e7c09537e5009a5adc615c3b7c1584ced2b1c68f2d97737606960d2b574fb7f8d3948cdb3930600ee74dda0f658be3c4ebdb6ce2515958a939c1436e45476d9d257a7675a73d3a736910ba2c913bc98b5f603eeb49427b71cf9d132a0b4de5c575f31fdd571c2f8e4b10ef617074bf1b67b647bfb1db3574b165a099eea230e1768d047eab5431c07ac72c1dd93134ac761feb4080563436100850f45f0d6ab9062e47c9eb0b65514a7f467fed56449827fc167003c4a89be702dc6c8407b30e402f3957c69cb48a5165e8f1e2977316e36546d4c6557bfcd13e01128bbe6d91520bd0bdf696c0fad59109d80c4d67a5a39b9f582c891e3f5508377b83fa7bb943be63b91d430e38c3a814febd80439289d6144c510cf7a899fd68a2cfeaba5c9fca190d8085b95bdb57448bdba1642758de76d1bfd18557db7b3fe31f132b630fb43e3bcd830ad9404a7f288b162e8ad8dafd4464c7f83f4eb2f5c3f8c16f69c80eb377b7d1f9a9634879ce57895c5072c9c82f0258818424eb6f726a35258bf5bfb70a780798deb213462e5a985f032f347cc96652a75961acf278b27a6a9352870c8d3f6388079b6949e841b0225735b8dc94a210440492cd7ef2ea60377913affcffb9b2a9af0e127e59c5c2d033297a61690dac17a93c5f63aa0bd0bebf512fea7c0769a55ebe853e52ef4dd33a0b4a58da0b4491c24b9ac0c292f15dba1598574a0b7f4b9beaaeb1806b8490e5a5dc850a4a5530bbe5c903e9087b426059aaa786a0d004ffae7625b7e6ba00eee73461d3bba0369cc486d94a987ea9280fddb3779fb614ae08600f1e5323faddc49c9ed774664555a55e497a70f06693c2ba5c83c654c83316f93c8bba10a01e906f9346861e79d5754ac1dbed42cef71b3a35b8ff38bce3b219d89cd2ed00cbcf2488809c03c461a7ee50d3364307f9943e8abe4bf854436c3cd84604278ace4b2162a9ccf23fd830af0d33af19b38e4f129f1afbc4cc901d9ba8742c20b9eb205fb82f49a98b334c081a0e3a1ea952aee8da71c0f2d0a0cceb85a359a85a1b05b8a014b0e8505164e2a8e60f9f8fa4a89cc9e331f31d0318894f9ce3490428f3812a29264f1a1fdeb088b94b0aeb130e26fed85b3d354abb2d35d429bbcf4f420bfa54c40785c482cf987e541c600b448e19ad82c34c245961f287a21cded2610a8a17aa1eed55fa5b2f2268b109d377a76eb718549d6dbe62606da9a6f4c8fe0b02b23bc15d476c4a2cf5f1be4262f135d9de032c20a41298fd0e611bd103d8d75a870b05fe3d61f938e5ba9fb22f46a27a71f495f31a368b6924fbed3f6d41cea4af3f38c118cd34d13af0728d992fc4e4f71ad078b12358b546cc439563c5a548e8671ab22558fda31a2cd2a8fcd5b76484abe89f092aa78332b0a3602446a84125ef451925d3a45ba3f52fe67d9a935e9dd0a7ce1c3f309fe6c20369c1d075058de592cd4071561a31aa875a3bec2b77b8f9a421fb9640b8472cc6bf8dcb408b1db6dc12f7b669f02fb87ebefdcccb28a04898aa11197bdfcbfc56cd7da5976a3d2ff56d23e24f514cfc2d6662d476ddaa2c11a9c34e56403e5fd97f2196b0c3cfc733b8380334d916cbbbac6ec7e32672759617e83b4f5af01f54d9d89192ab3b3abe6a8c03efcb1a5b435ee4b30601dd2d034f21c41b9a04e8b547636a8b9dee656d992344ee5fc14c003ed424725452b70b1e3fbd9730fd315ead22631e87aea0d05384e18c896058ed3883ce65bf8b9a5c04a05bc6a3943bbf3b9385a939dcd9ed082f4d5978403f3d115dba66bec19c0f5c092d90a110dc99549f65e27ddc91c593c07893640fedae563be7c97331167dedf12f3d59637942cafdde580611a48a824855338a67d543edfde683ebe4d80918ee9572818ece879b79b3b013860f428ebd1ab79e76f67ba64c658adc676fabb5f73b67ca9bad44b5676021887f4633958c063804e27638bb9ad2a8825115f4e1d5a33e85f55b8012e7c539cb1234d75bbe75f3d4c91b6de4bd5376da6591d58262723781429035fdf5fa24e7266a2cd94ccdd87361ccea2b4275ff4b86ef81037c7f20398d003d513161945e5aaadfd4258e4b2eeb8fa05dffafccd63a955ae0923e738b9b71b03ef533cd206c0fa7b947634ae7291a4ad0022ae25473e207df0541cbeec85cd3e2f0222eaf63d25899f38d4f5c438e21267b6a92490ae3658c113e75a6cdcc53f679fbed7401c41586912f24bb37eac3b52297b2ecea47e8f976d8fe9543b2a653e4fbd68d97b2ec76d82bd68f409997223bb6501e2d67a2e0105cd28e540094f0e830f5183037889d7c281cd472a6ed9d1daefb701f553860a77bf04b21d6bb7feca1d701b9cde7f57484a43ab543a3cebc2f3254fa55d0a92cec26b9efeda49f0e559aff8ae88caed79d17e892e19a5946971b7236c9ea2da68862a5ba270ae7cdf2b4297d046aeec9e28b0e4eec07a5fa5302f03455fffe8997165843246063d1e6ffa60f4f89bc6b8702b2bcfbe7de52f188020481011862abfa1e3b75fb5ea5c9d14f8d196c670f919d7fea42713746ef6dde725f92589d76cb098570120f30daa7dd7e41f68e53e9a45fc77151745affd47f0ac12d786cb5f0e641c23af0276ca38131f86cba0b51737ba20c45e7218b6a053ea4311dea8e3c5ad5dfb43cbdfdd55a5d54f8e3d5c0e3f71d2fcd0b0ea3b533fdce78d29c741ddd0e1bce50245a7a9d94716ee48efaa150891135628f9ebaa3ced8f633e43d027fa1887ab28917518d91ee10d7fac4ca0f4ce2e5ba08589756fa06d5f3b4efa3b079b82ce8db5b861d7df50ebc9cc30e30b32a2d9ee46ba07799bbc0089a712172506db2dd308b153d6d6c7435005d404f9eafd1a2fb6d82e40c64a7ad9eac9836c829d17d562ef4d5d96289210d7b2cde943e96b065c47fd855865a54226a0c837d3e1e0d295e269449e1893f05b4d11c6b6cdfa8a4799db9a38951b4981fb6fe22b16ad7c5ac379ec7be39b886d2c973087f4684e6bfcc86a9ff7e5b22e815128f0a69aeb57f6494b7b1484a3fb1d2999723a4c9257dbef1034d2970612fc5216b23757a0c58f0e7a5b28a74c5815671c84824e58a68412a3009a85d79770e3684873ab2b494b15e76c7ebe375214a0b4824636ca6a85b577afa6148535ab8ef1d78d986868354e487d646f5b2b88fba3e46d44edde7b6fef284f59f8d47c90d6d59f717f6b6bb960029f96a24e58c3cbf0b03991e07809e008e8a56ef84f022a93bfdccc769b16d1fe737c8eee95c43d4cd340b2d0083a07e9821e8dac24198e479394d194937f3ada1134071caa68c4e167438899fdc24a6c0dfe282a3b7d5e1fb42aaa2dde88d35f2e10c04ddd042e6ad826ef136f5e72cc9eba11a08f80d89471fa10e685da085e5068d9041481e1d23be467186ede297e837bb3306d5f7c1085e4ddb14edc35855ec6441412691067513744987307a3127120dfd264dadd9322e5f322ea7b6e93b93e3ac5f6369c5c0be98951032e8c310c0cb056fe0977dfe4b3aaa791182e0af6d4422d44bbcc1ae2f87fe40b4ed5bfe4340f7b131868853a44d02e1515d5a90f77c647e1b7632f020939461c47e75132ee04fd87ab8a9d2d3ca0a3dc5861c2343bc16cdd094cc2282c4faf4a56c71d66ec2d8dbd8da80ebf5995f165b6e491298529de23e1038b56e2f81a94edcb72a560c2255b91a8e82d74d1017771ba6e24a427d57ab0660bee88006408aa4cb772ad455fb80a118f6f5dbc93b4ce6be732c3f08e82ba45ee7211c96ca52f1af5fa4d3992ef0166d0b4083f0ba390fbe7f4a16833b4a3661dd1ec26ffdb049609674bc72c572915ef7941c2782b5ebabed6d3da5122cd3ae2b58f3f0c605e8c273edc1aa105c9c175c8c99788c1c05a6464e6644834bc99b481718534676a5cb028d95d65ed4023abcabe188616e0c03df7ff79f9a3f21aeee0a9c8ccb45a10e35f7408e015df68a3711028cf95b6e85817c0f746025c985f048126b4e27753f9c170d22b30ac2dc8808a29cb705e2aa8f35323436c73123a7e4b6b92066d23e7d7037e86c017f64df43c1b92b38f0b6a2fd481bb3c7c7eafdd8c7ca99f4317f6b9e5cf8b3358a5f4bb2fe9162daaa29427216d1891e0bb3c5ed314f8ba1f8030888f1fd8854e55c65c27f468f7d1444127d04276e33691be3ce0e924176b7cba3b9fd809064b7c63be54b4df8d888bca062fd1adbadfd9f73bb3ecc53bf9d3d63f4aa6d6dbd0c95d76fe3e2ed9ea243f76f564dce8bd44e6ca0c12a1e4da120a0b8d01c2e866041a78151395ebbd7910fb7a61b7d0c556791a940ea7d75153e96c6c283cc365a31a8c9add18f3971aa048c70b3a936b4789c72329da0011f798231504f890f3482e27b5fcd57b82c2a752f6dcc9f65facc3a7f7a8d7158c26c73ccd6aeeb57ef49060326116a272bbf026b2bfb3109b90469eb64da59a9d287cdccab6960f559d320c4bae6fed01a2aaf5e4ddad2530ee0495703fcaa3657d85d57e3f59a5d4b39c6b0688f750339ea2bc08d7337b8709fb81d7ca7bc4de3bc56d897ce6a89baeb77694ee0765211ae960f015419992ecfa7b60e16a53ce3f9b5ae8149aafbd9648899e5c63b7ab48610cac96ab07ad4286c9480e8f5c096498aafb4e3289ba9e925352bb563362c307bcbe922eeb7880a4c8d1057bca689480943a7ad47c0cc39343e7e25a04d50a3f63dfbf80ad2911552d9f3f1c463df426294a9fd366a836ab73e42814dc5188999d41822402b27e3884741805f88e983472b157817b785c736ad34d835de2f89fc48e18b3aef9b66531bfd0ff4ec737c83cebf68b2841f3ace0fc3c5217dab72685d6acf0224aba888519c9b4ae3998d0038ff690271e4752b40cec6f8e481a37310d3212bca28d842d5814ee2db662a068c28f06cd9846bc80745da0cd6fc0c6cb712f789bb94c8323c4aef387c07efe5605eb81f8f4dd2c5cf76d7af7afc629ae4457f493d6cefe56ad2396c5d9178f4aece99e53254fdecaf6fc4e59fa51a6b1d6b278fd65fd2d644eeae7db3a7807aa48f28eff7df4de0a7d17196e3a2db8d91e4a54f445b03c36806b464ab3803d8e40f52ddd7aec4f8066f3fc0329108e6a586c2c4997bf918cc82441a1ce87a4ba5e6d442822718653a830ce271341aa360294f5487ac32bea2f886a6f629514acf92bd976c16b9d8d4f0a00add7c2d665ed2e6cf5fefe3e138751ea5c06d21cc2935c160d082bc4cd5c97cfc86e3c909e3db10de53b62e0ec684d8f9730d4ddbd235e1d394540f286ef8b75cb85d382a7400992e9108d508043faf1ebf4a940dcedb461d5f7ab296bd1aa2578a5157d8a11fd5da88c675f5d66c0fb27b6060a8eab23b91a6065c003f3f846badd6d94e778fadb4ecfab83a20a468544315fb67bef2d44e8a4c0d82c5d378da9aca30747e9a1efc3ea97949ba94a8dc3e08b65b445c7b28aa160f5ec4de91c1701eb29d226a2a06c29cc3d8eb1850b9e9c10e8c6ccbc36641da55b51ad65691885750b4ae917614ea4132a057cb241aec052cf284e00cc379c8d7ca7dce5762aa8f16637ce6ab68ce330298bba447ec9911d1496558fa7c475e28cd6d414b1b7091c176d3e1e7e8b2d5decf309f40504404f543a822b8a9d6046b16f0c1bbfe53edacc4e3990bc96ba01b3128e5360ea8d0bf7abe9f4f87f825e8fcbe166640b2e5c1f36b8a19e4ed8f50e13d22f22a61611744830726e244214cd74b729077dda8818e83e4cb9dae759026d0c694a0bd9615778402b5834c9f02e150d8e9661ca1696eae1af3b19db799ef6fa677338a8947421f3f4e350039a72b39befa0e4bae52f200f650a0374f26be69f507b51a2d6e305f95017cb053ccb93aab32eaadd93967e027175dd8b44aa9178ca9cffb4980fc73bdece9ed35687fb441ad4416f3ccfcbd1ae94fa83614dfbaab9bf7628b538aca95a5ad44a5d01083d582c04c868c0fe700b35c03bff006b3d6e83e74fe2cf60cc72b8f0e1723e3eb46ae9f154a37ee8c1e3b9394b7b11c3d48bbac06fa11a429040b049e00dae7965a998c657ecafba0374b917eb08db273e010f151f60e586d22d1127ee24fc6b8d5b3c5dbe04326eaf3e5f18494679507caf1d32ef29f5dfef87c592bbac43074ee345c9e8d0122f5b1e519983ada2574ff74873834390f2e291fa61586cc9b9106cd979e3916e14a5c5054ffa0f7f755404870a43bcebae0a24114a3e78a17374c0692628582ecc32977974c198f648abf32734c0b17ce3986077f3db29a00deee92666b3129271ad2f3cd3079d5350158fa5c0824b9e948faee46851c5bb6dbf8db8a220286943ef398d62207ee05b8f195ce2d1ae1ec2af7f24f27976de32e27aa8d9a0e183be417d3b9017ccbc5b9c6a133061b42b2fa9f65b175ca40118aaa6f49c39a494f8af4a5e105413956658f26ee0e34e7a091bb92e0ea2ebf20bdaa5fbf2c1f93e35e2da9effffb45ea5aa0940e2b4a0f8c7cafb16b9fd4fe2dd8ebb505b9d25c71fd38bd77dc7b7a14a16578961be6f13e7b4e056b7fd7ab05135d19ac5a5e6131059793ddaa5cac0fcf34075b7278dd71fcf3a5913ca7ba9579c65af2a542f39f479698269d7b34328c3cab48025e5a99a7a7f6d593d1612cb8eef667ff127435a26b111a2741a5589bb9f36aaa503a8fc33ed0991435fd269a735df4cc2d6619de37133491985e29fdae088f6ac6e8f671080265571b7c09f7094ac8648eeac0b169be6d868e1fd740333731928791bf6eb835dc403f505c0ed52e5f8c251f28c6849b4361ab095b50da9f3b299f4b01ed8b444d155b850953eebc33d3a8d01457bb57855f4540ed1db056d04e87f6f713ca4a189065ed51019ce94abc87c8ef004668d5fa94b00834ddd919c91e77fbfd66fdfbd6b6db2859baa3a891e3881c75629ccd2ee859a02645be87860edd6dd2dfdd4433cc2ceafb0c72f3808566a51d74309bf2db636732984e18b6d2eac2dee016df7924d8265d27687d6d891e645e97c8b61cffb152a9f108d5a5afab9029973137ddaf2a009f3c65fdc7fd8d945cc527aac346ef5909dc5e1b5ee1082cd6b14e10ee543578de1f1b45a8c343c4bf30d8c3e7f5bcf2add5f00343e371432e9c7fad01b8ae253ba1ddc1e7ed871b0103831966a1ebbfe5a837bdec65b76adfce0fc92aad62c330a3f30fdddab8defd916fe782c7b2abc03be5d1dc564fda42793c3ef0386019622a3fc0055bc7c26b92b64f4f870e2bab2ee98e79a5b15307fb7748b6c4bfc801931ca9b5bd34562c4490f9f4a2d4c7d61394eaa5d78edefadd92e4a973596478697925b888db322a5881128624bb7d5ebd19199fb8dbbb92196b9c2aa37245f62e88e4c4960fa46a759cd3ae9a6001e1e4944b746f49330eef1b0300629430b589b9af6da826ffde7429a33703aff7173d9faa0a0576ae3ce58fb42f451569ae503b382f5beb0b65f23d691cae8cbcde629cc242c1dacb0760fd9fc43cc3db62d46a40ab6b71bc4da451575925342df22e99218d4be93c0f8b5c8b3089b296c3180d38980e4371acb16b2713d0a5208cd45d9fe5c5b3cf968b79d0fafdd5fba7add2500d007c432ca86b795884b3b62333ca4e3aae97b7923e9378da7507be65ee51301c72fab2a0d243cb1b34ac98d813da2a0deea4ba9b6b274079b1a6502458a09f741960c786350f4e991c7121ed1270e5d4d2e4c3588ef5e47dd6eab4c8354f53728a2a2887de565b1c95e148e079f8c72e5401426e4bb084a2892c8a34975c81964957e326c170eea1df7380e0027de6670248fd5d4a19634599d4a38d954dd3f0df04a578d68a7efd7649acfbcccd06187d7d23e83a7cf17df578533d4126ca6a034b26075c2353bbc286f2e89f835dbffd303baec82aa67e8b1370a129446c35e83cc0654a470c25ab261d282bddd91007fd6d53e48ca329b758bd2446fe764a0710a75f01fcdcd39df2dfa246dac3eb86cd700a846418f0824c7a1520ba3b3a14d97badc8d68bcda90b46a80646ecf98fa79aaca4a780fb664a68322a5a8792e536e4fce329d59b3676d1114d2317269075853d0e1d7208b823bfba7fba9223177604b335dbc18d8383564f8e08f48a2f68e8c08c6f6101d3d24b05a725148855198766a2ba9810a9878aa9314b3bbe502eeb2a6d69b4c6165e36b02c2eaf8e33a3bdffde6fbacd5bc5fbb1b53ac3debcce3029c79a0ad5f80decf15c01cea08aa145b24a242e10ecdad64f6cc5822b1d581f454937174febaded27ce628593cf0459bffef213f67717e7445704dca77ce1b5e0470724e07f9023f38f49eccec4216ab76fffa6ce85aa78b6dfa903ca9fbef594bf2d84b06043421702c14f2909d5a1eec1f117f2514316f6778893f62866e26dd2f4fc219598495bc67a4781b6ff75a1ab9d4a5b423037c5a5429205df1a9a5ca183d7087bfbad01e28625e73ae1d6b71fa6aa425a825ea03ce445d5998f8c4dd02385bbab628e7a919c23864fd864bf6c479ecdfe9153947f0108e41c0f790aa2a374ef19b8801da247dd522eb335d17f815f732817cab7dcfd535108f92efe5092f3b4c809c2ea1dc3e886f24162f3af07e21e13ea3e053899613e9ea9f0cd8812376da3b83f84f589cd43d369da6f3712a1eb62c1b0df20a191dc457b081a2b7ab0a662ca2d184da2d9341a73a992f705d50ecb30d013c7afc4b6aaa21be6a020ac5014156fe9b425716357d68531fad0682a53e1d9fe1a0f5cf609d39653c726f6bf6e156c38ae5a989308ec9945d437ac1c2bf7f157eb3e7dd29fdb2197c5097e5aa51823ef18c9ee82ee14b87d7b834414c19ae7b6bb2d66eb5041d34a0bb36a035865a1c6af02f602e4a5f3c3dbb85eb315bec9604ba67b5ba197d3fd3306881d5cde1a2b433e4daa0e1c93b9782a144745e29306b87368e4f4c0d1251c0cd1763e10354d67cf9619147b0f07ca2215a3b7f4cf67eac84aacf912d956da3e030a826bf8a9326df293355b46458fed48665b58030de9256781158062b932ee4eac036047be385da1b79818175481b17b89dc630d6bc7db3c74b2644880944b77035e7da0949bb981506e9b6f820aa55af1d1cf0b30636b675f799ce6b328c2cc08b43adbe61ffbd037e8903d21a1150f29947ce8997e8c89e26184cf2349e19430bcdf5b4212f80f30bb769a20a7d39cf2c2fe6a584f9b37907d90802ca9e80b9cbea4c9881088a58e1f1d9ec0e7747a4b75c818610aac7ba65b7589e95594575948fbf21ac60d5a70049dd7ab794e4e49efe24382b31b88ed6617ee33af850ce7a149603d226a151e05337ceee94955797192808da7aa0bfc57d1a32f2997b7949492dd139826ebedd5212973f7cb897d134354f10448d40bc099d07f09055b9ac57f748bc65c3e8f71de2d8f4bfb227584b9887ff3e8cd6fd1c11aa30e32b1901d2d236172dfc16363930fc7f21ecf338b6f61af9761070850e835b7c7850cf1fe5b731fa22f2fc1c31dfbcb9af844df21cba9c6b9c46ab4abdd3a50e99f13a46839e4e3e8b46005b03cb4568fd207434ca50dd0551d090f092273d5042d35130cb05019c775e9e9e7904ee4a2fc8070fdfd2f3921be4e190c5256892d3e5df1e2df5e3285893d10bf4659cb9eb5a8f880ee7107a677981453f8d47f8568160e5b74fbb3bee51520699fdcefc3a093a0466dbb71a43e1fffbbf9809066b1c96d88fd19ef503b8bddfafb09d4e3be72b7a21c453ada3cadd399444ec7c9a9668ad527201013b07daa9ef2c222b88adee580fe3dd1e91556232e3922c192812f65e8c3f96ff6796e60f6067bdb5914f05fd713b9a84992bc69325e19759cfd361261208f03479bbf6455a23d286a6f8f41d38808e48737470befd06496c815db1c7e1c38ade6acaf65bffa50b23b94206316fb682b3cdcd244dbe2e80a475358fe511d20008fa620560cfbc52e8c21e6d4c48c967149afc448aabbbf1e733931dbfce19227361f9dd62bad68c59c774da1b6e4e0d03a6b88df545320b79419a459827654d0ffa9f27323427677dd3767068eb770334102678f37fc2fce0aea20e3346792278b4881fae90508b56ba8fc270106cb59e4557e35ba4d7f1b528be5cb2ca6096b4ea81a09b39dfc91ebcc8fa1713fa607fb1ebe20c2c2619e583b9f420276070c2aad69f8b10f55fc1ecaa0d5bb94c186aa226dd617864fd1497091b3d62283d08b8beded4da1dc666cc2abdaa3af6f785882364ec03c28f963b33ab67e8bb1db4c55c3d49dc192783d3015a3ef3f335c5ccc4a60c9b055277af98a5fa4595cb8a861bd415dea6abca50dd5131bec4bbe7165b6ab4848fb184a1712007dfe7e8989ec0d2bb2d1ac3108ba088fc9549027761d13d454c48d04455a183c5bc1fccf38a30ff3011ddaf033a4690bd6b80eca4eb98083c65699ef3ca233b3ee56b453d35b9f9bd4528505c28c01bff828e8144c4db6e8696b72bad71b3f21c8c8f7a89c835e067543a1cf9c5543f576575f9ceac848f7b61fae36f00a8486e5524815ba325b537d3ded4c71e688aa2600b8ce3c18293171c973a861e51c27f5b080a2bd754055bf28ef21f9b5d3145c94fd99dfe0af9b77b738bb32745d1b9def4b28dbb37cb580073f1a11a0e290d1602b51ed3db201fc7f45a7603721504bc2425754ab3a0cd5510c80184bede11925e48b30777dd3485a3fce6e7a87556c18a2c639686f5a15df9065d88bda20475ac1e20b1da0da2fcb83780810caa686813c3f9668677742b172cb286136ecb83ba1fc32e33ed734d8fa311723e8471a7748112df13ab45dd4908c2454202be3d9cd211d2dd68976df646535c83c1fbc445862b77c4f08107d52a1e4b536e3efcfed048736a5bbbd7a4145a384ef34efd12143a3070e6a3024198a7a2c23f2d2055ded543664071b92034ed3c1ff40c046557cf9eedda4b30a0e7f8384cd189beecf50d580c69f328c291e78151674ab90ec2b6959aedf85cc405ebc11e5e42867e4a44ceceb48eb70e870e1ade9f148bdca7b5bdf34a8cbf455c74d40cf34993800973ff191c10e066066059acf6c67b45066ed1e38470a7394e89f6b4664ac64d6e266f58ea6a766311b22d319b29174924d309b32047e2f960e8159621dbf70b4d5a7bde5d125a3fa4d186b73bb9f6d2745936ae23b964a900cc299ca8593d5d26235a99b8101305dbd59998c6c8ddf1cdbd9dba0da030c0ad217212b7e81e7dcc8c4919a187bff64e4d834126a99a8be6c16be35bf952f491a79708d78551f154e0cf98f1278e8a7b55a37d9d24e5c2beb5559fee4d8fe7913510296db12b1301a46cda19f0a67fc578081284d266221e3ead37c8351dbca0f7e75c54128539d2493675ccaa624ad9cac6f03b90971cc00c425ff4874a1f4de4d9ad23ef5c2e8abe1717f49f7530f5268677b893a85302b9fa4f4c869546df33e1cc1902be1e0b9628f246529399dbd0da75b520e9dfbf4b4af507369a8fdc6737d1c6b0920c42b6f6620ed871a6bb69a0158b3917f8b8f813b295e55574d44334e1cd6c54cc433577fba9c085ef502622ede3282c92db40346f90e2ee0edd674bce9043bed290728291e491d149433ca510c47c2dfb2ff2ca46cc481deb35650b3505c16a1efd1f27427811420849137c77a966d8e10f05433da4a4a786acd557d6e6df22ffb12632039290896930e6648d5118eb212d497bfb42f94e6209ff52c180a93b3b536657e3c18e756e5d7cacd70e76ffea0cd62407fd4bdeb7547503fcbf875d6965fae546143f0aad301eb4fd83ca6878f0599399f5e7ddbd88891062691513aec2bf43527b0933bba87f46704dd19fcaadf0db5f3ece81e3d3761e5e1b42bae37aa1cf99c7dc24ca068f4cce3bb844b1388c413a2c150f4cb8eb541e3c067f1f51072fcdfbb94b113d527becb92677231219decca74a71bbf253687bbeb570c0858df4e8aa44681b92cf7bba6748ba87024a56993869aec6cc05ec353fff623d9ea23dfdea6032e7664d73167d8d8b0d3c6d8d6dff2d5bbc825c9d28243c1b260a4e918a21c8928a6ca32a66c0a0b6106a2d1ec38028c3c74212008fbd080e4fb1bc1e8cefd194baa55ef9dd955ff956cf266c63bb5250431e5e34165eaa26228bb301d252010ecbd75373916bdd59b71c6849852fc955ed709fe3f34e3893241d95b6dfce3af5210ba0ff4000082fc2a4bcefa6770d9998922dcc196010514e53424f901320eb844fe68d8a743ebb05c21c043f6423676c642ddfe05a371b3c17bb807e656dc9adfccc654de7647038b8f2d957bab5275976fa22123e61b5b0f47bf07921eb142af23989c36311dceb53514b5e382148e7649e3f085e0579756242f4db4a4d7178ea633d6b1a2e89024e75940385e9f9218aef7da47ed004b33a042650997934399d526d9cef6aed0d26343b1ee0e79bd9f2da4a0159c67941551df87d858efaa6baad107f995298a43f1de5ee1d3bcefae6c8627c0d9e974faf56903ebdfbff5cdf7365b5b45d3e42d38d7ca24a9e72dc05c286fd89ceddb433fc2c592c13768b0809e934331c2143a9dee8373f625b0b01dc34d125990091a2c3b446cf3e0a13dbe9ffdfd34b6292c8772880c750bb30e55208562d7453e98800619f38227d243cb25f0cc99f314f7d531c2e641546c65b47dcd329d5dcbd1f165cebc7edcb025d6920eada5939b04c717c5579495806ee9005d566e78c7d483673ea0ab3ff8c4547e19ea5a803bb4230297e9ec8b17b231cca07b898519bd146cf8c107a02d668335e4d1b86c8d905be623370a3265565be0d4ad3ff094f31654422b42303a0e102141497b3caf10abc1618927ac182c32296058a8d610926ab429bc4bc22d0932bfcb86581dc4aaa6612b348642ca014d62790925bb3754bd5586bca0fac5e2eb5357fe1a2ef5adbd725e42215a9fd8460071fccc959865a590aec7570620bab6dc57e5b103293bced8c2433b17abe15f18ddbad6bb47b2dcb0ff1f9959887094e2ab5ac004f48f6b0632a9c7fabd59c823ee57112338aac2704e051537ff7d1dc46563d387c8efb37c692813ec1648eabb2b6bc1644891c0f5446b1d7a888ec426f88ece58c1fb78c7706a827e52ec1f96b7b3f719003c8f669467a3c68f0c9fcdb841126796fbef046da081da23724ba0713f60c3c9592465cb87b330b1f07aaa50a746a4f47e1eae68d9c0076325dd7010e92986d91c512c0899cc0dbea0fe689cd002c302cd206961edee1bb7e1620d86e16e1dd331eaa42dca304a6dccb5ceb52219023ffc2c0020df9da98dd4ed983c1d1126eb0684ceb5ee83bf7752be827af2b0d9f56de0ec3161d75ae3e7921355d7159ede13c282020a1f08e89862356eeda4f423aa2ee9ecc17bfc08e418f33502497fa1435465faad5ec2fb7aaac751b5e58e06ee46094acd0338a04486039a68bde7cdfb39e0c0ce59704f58585ed0a182c3cdffffc9636fa1e569abe441e650592ad92a589eeb89d5ec3f1bf0d727e6b9c43558e6755b1aa2862a1be8a2a4f3f67894d0e3d46b295e4398a3b6bc0b6c62d770f19afde07d0185672cec681c8c32b9f6bb912467359d395d0f462b41db60e0e7ead4495eb020c4b8c5622965f895f5b1d24874595cfeb10eceb71b2613eb4cb353322b2ff22a99ac0bfafacf19603bd0c86d1bd076a8bc18fc8ca30e1c35fceae69178623819aaecfeda589cd10901118141ce618fd3bc37a9780eb0606a84f047a6a3e066b7890149d0530e758e33e3f4693fdcb07e2669b4b02aee169f6b7023096d1bac762ba68dd2266c382552e38b9f7799c0a9d31d2d41a38140ca70868645e39a29e5fd586153de335b0d28189d175a0586b3c78cee134cc27f15df401bdab62653c6c11a0109756927d2beda31963ef41a40bc80e59281a3fbb37e484a121a1db92f2037bf72f415a1d57704fa9e92a34f633a5db56e929979b21c96bb44cd80b09bfbe93a7508ce270aa53b2f5ce523a5cbe4cbe1ff15754d233088817c7fc2003847a2d5a6eb31fb7b3933227faf500df58f56e4f619e9948ee7b97bc621e713f9b0cd0972f1966cbefb003aa664ccdfb857873b5333c572e96f6da6b72db066131b7ea71da9f1757d9d90f34321c74768d6b1e8c898ab17e7bfde389cc591b53b2de7f17f804095d0f2b696a9dd51b5461e93e5291f307a5eb360094381f408b51fe679e7967574992f9f9af6ac86648e8618a66e6b5e11b6555ffcc6cb5bd6706c09b03fcf383b7e9556dd81bbe9265fbe51b00cd6edeff36c4d9c82bb44002d96a4c313788e3c1fff8b75468e62fbc13d20ebe627882c5d1998be9038bf03ecdd01cd1f9ba9616f19babc853570cc820dc1bf1589ed14fb165ff0fc08224278817a2ba837e9e511248b3c67539eb48398c5b33137271c29fabfbb39fc16445cc55466b19efff2fd27fb949fc9bc5c220464d20bfe43b6c108ac2ef8896ab5cc968269cd4deea15d846f260ffd7fcff7e366632afa38ff58a623735811883d1b325150dbbb7b904bd07f159906121c6b1c485f05868da2f55f665219a87ebdf3ed86b53ae1633beb124a605725644bcc70e5996ccc02c1e6978e01363c0e8f78b72cbd214b982f05d8a35b693e1e039cc313c7533be12b5d0d76143639b04e2ac61a91d802d7c78c4d9c14a73da802e718f8b5cf6c94a29e07c229d916b397ab190d0b8be33697c04729964897e24563e5b26c6f53f61ffd4e1b1389767f0fd0a0c1ab001a2b64bc781b22070c4590defeb96bac07cd708bd5c0694308c9034887887103ba22ed4d656d136d131ae199e59846550ed63120464fb4372420792d0b6905fccc406a21c547313d333847aae01bf4e5ad3b232b4579bfc1087375c3e60b094407deff8e5f02093bf911287636d098a6a2aef224a6a63eb76b764d496326ae5b3397dd58551b4168657548b433ca81516cd514402cd9054bf16aa994d3a06295964da5e7be8e0fc0a91615df7108d04cffe8f2fedeb0f6741f969f1e79f5021766d848059ff258e0153d237b216f67b3d32236b36e85b5737b9352dc752a20d8c40e77a290282bcd207c4d87d82e3010a4d7994976155633fed47d4ba2f4f4152bf1a002fa17013222aba85c250074895f7cae5d37186c03082df7ad04696c7e5b50f565db30651116461f9855ffba82d009096b78d158d665112a58a2d8f44175b3c8ff785103336bae181878e96ea13749c8533a7a76945b71915f81e982f3fd1d2fb82e17c7e5d61b5eb7082365ca162f45febf49c524c72d7e22e7c4fa6674ed280adeba23a5eff5882cb753e97edc0765a61a163b3c34619695b9f20a6e15bc499be3348d6c769c8e6cc3ac2fa754ac8c84884c1825c8e3c9e25385f04c7ecf891c7c52f5732850a28d88e0c3510ee44020c52070dfc930adec9c80bba5d6f99e7594a7aa984f62147ae91fc4b95182ce26d9178f7386fc44b7be68207b6c0029eb9321179726a3e8ef0aea01f39e2dc7ed61f391a745d86a45548a2a1871c488195d2aa6b56227528f3460be1b2d400055612ab902dfeb1585827f8632dec61e83e9cbfa63ed6874c15aa373d61b82e1d1a86c9376922de6d3110a29cf394bf8f56757ea4e57f104af3fcaf0377a03c47a67934ad592c5657c9aab2981793781f254d1aabc67d0535fbbca4ee61d5f7868300756e1d1b1959f020867fd8e25354315a756416f3a228020eb2720e6319ac57193e781c7a60a6b7d4e8657f06783a7d604f1d32a2cf33f4e31498dbc290e013d69624af4cb12fa298892ff76549f0b399047377c7a5c5f13a3e0e06dab6bfa90ae7edbdb80bf96b08090e26daabb49ed381afd2d42d20b56577d8ff552524a51e570e26c19aecc6afc5f4304147eea066b32d6b9cc279c9d51dd9cfc5d18e5d6c2879f2e2054e2e152d71bca82d1549310df56e6e1f8b0f0134b1850674bd67b09f0a61c056c472880f14dc7e7f8a2195f71a7189dd1db781fab929a72ec74666ec738f96ab207a9b5454e0c23af3c9b81a3edbca5d4955f920b97c0db060318490bf967d739c74febeba36abd6ff9bc87c4963004ec8f335dcf68e8579794ca9499c8c03df9ac89ee5a9cdce14f780fb2b7a848d0b7733784bbdd8aa50d3d4f765e22be74d715b3b83a39af6d746e15faf48b152515ae7bd9727696a347ab98620ab94b71ec2ba6a67e26cfce2b6743aebd3577954883ae8ecd93f8585c27e6ca71bc532b2a3c2372c5fe9316db7d3586e8abd4d3e650567f3a72a919903d665c206ceda5d72bac54b847c6f11cade8a17292a56b114dd714f6652deff4a678fb967ae80d50cdbcf98bbeb7138d0006905b1155b8c6b3b7afee1364fb9a2f8e84b68a17443d4f04d559ed480b7a80c1ce57f8c4f3166cd83980c6870c2bea37235c6351ac6ffbf92b19df31082c5a05091f8f25d70ef0319faf967c3b6b65ffb6e6424b992069d889349962e8d45922a66952efce670efc5af6097f0a45559d8ab10ec8c8f51c8ed893c4c9f266979bcc2099e42aabfad05e150de69982b5763997e58587338569987ef70b1183d5c421e9d7ae47b37b8dc7e359ac3a20b8d63369937d27ea1b233e7f1767c86345e191b32d19bd0038cf21e6d572078d36f16347f6c872a8edcbe275a0f4ee69ea4182c6ccb7","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
