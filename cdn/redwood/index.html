<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"73b1659a4c6127d2684233c0f3c4cf033ec752fbaaed7f807caef8bac0e83b6ff0e5c91e0143969448e9b90725b867a85186f6d499ae39f38d1f758bd0f46f82c1c4f9d5c384714375573cf47075df4c83ff62a759ffb8451a08ec10e161033af1c0ca5171b960922c166605f27948aa90a28d36ba22b4752a646db5b38a5b4b7cdc546d80b2f9d67a9330abee6d526c0d7134b54dae093a332107b5db308b3420c79c8fab11a168d37752cd00f3bc0379f3e93d4eda307f228cba278606bdba8eddf97d61f69694c74f1b7fae5f318e317ab9035a640775c0a8656ba56ee846c43ba8f37f627067ae33ed06a9f38edf90fde125a3d2cf863ac65ddec67cc109c99eeeed5c6b96e57a1a611ce68d7f94eeb72c65105f3a5ecd640b7e1b9592926a615370498253fb3076af0b5070ec744c83904e74d0fe6badf20cf3b81434061695e01bd8d5c70bfab86d37a6a2535eb42a1546921ff44c613777489ca554647c46594aaa7f8f0e98640c4b2d00dac6ae23e65db4fb5083b059bd33125ea6a0bcdd2ce2d11040ce7daff6173106c1dd3ffc6d77ee736c5bbd32d0be346ef1a660184432e24c8443d9495a58f3d3865747d0aeb8c499a7e51b0cc665b02d3e8dd215f31bd478311eda8c4573d9a66443f49830a499abaef4bc3a55026fb1ad31762752684f53a7154e3c56af4a060a37055d233091dc3e3b09ddc1365e0945f06ff0eadeb881a47dda03d56c87ab5c03e8ac413650675763388f2ac624a624c89309c58af54060b2dcbdf2038113362bbbbf6282b95ace21b9ecfdfbb0e52cf3d6f5e8b90bb0278ff830f58e59de96281fec57e22a2fbfbd78e85fd5203ed07ed75b930ec436e3cd13eadf8397b3c453d94f0d593d08262a8f901a8c3f51a72dd60d8d63fd796a2afdc00f750c3dd10e04f438db8e66a11a795d9717dc47d9645e2dab919cf71769e2a10fdec881ecd1967964f6b710f359b69493de18ac5c052d1ed4bfd57c9f36745941eee3648333097b499698fc9a2735113204ad0f41d4aec3a9283bd83c63faab2671ac11dae917dc22d131d4bf40ce86808e4b80bd928d94358ee09d7de221eb5c904dba84dfd51ef1e7aa7c556b4092cb65d73c84df44d439411adb046e3066ce9b63b6f45494f946181e166601de22648dd68f2f88ecbc512cf905648ecc165f119534d6bfdcc99ad5542d66842dd52c0e09b49403af00330d7a85a4edf691edccdf764af98e5d550fb988254b5b26c67d08e73c78c450c3f4c5f8d0e77563751605d1595fb61b1742d86eadf45758a5f4f06cc3404c4ff7c0124ddc3004b4d2e74933a23875b571c59fc320b3e1f90599f11e03e53e19bc1f4fa8f77ec2c716f493e2964579c86ae88d953f8b12f2af6666cbf10abbc1339e226c7d141fb4fda3cf8b9c2cde94d73cea927556dd5ba012d8faa53f45f300c20ab01d68a8ee528ec71f71d6bda94ce9c6db8c8dfedff2dbb4435d4b9f695813a59f876455fa4ccd11bdc19ecd400c1c4d219f03b61aee1596c56f67e42a24e79255147e4e0b78ad094bfd0699c1b2a6c9ae34b4f1fa7b3206807723814ee6ebdaae9b0edcdc7167087156c2f283c8f2eb7a5eee529a810d8d11bc9baf9ac412b414d1029c353239d029946f4f20c9aa8d94815ff8994ce509d9cf6ac538d00f2a3871cc3818666a68589d6c3a1c1a8eee20790a007f59ca55b430d74ec80c3427ab72708e5fdfd153f24879ec84242e88a557adef37ac31310b5af48eacdbc904e485001ed90bea33812e40f140fa071fc56bfe7658fb2c8cbf146bf5a2431ffe179c142892a1390accd95d56866efb2380ffa847c4e970737afd8306f9aec8020d58bbf22a945578ceafa56bc86a0b3d1c4b58bb7da9c366de0db355af46c261fe2ba2e57990580a577fc232d6c9747b0899ffe92db8e9871780adec498deff4f0f3d5da752dbf8cec1e1f1d96c04d2e4157bb7f350c9bbdb07f185c25c375343e9048a7367aec0f9bc01d552cd29442e35bf1648ee70e919b8774ebd0e0a97f50a501abe9dd7313b9874c356b42bf8c782d1600b93c25706f74258d78a81cad703c3711b642e9663e53afd22bfea69d7f48b5cdc83ca82005a498186fa2500680b4970bf761ae4a7e0e0d09910c815c5f841ffbf2cf045f8fc6ec76af64025e3d1506744ab582692bf9684c2bb82a9ade4155feddc0282da0bcbfc79a901be44c28effad0d1b4927c2b4d892392aaa95ad60aaadea2b4a668e385f480d61caaeec067c44587c82f79f11fca828d66dadf2d15c9746d9cea3e43c115e9af1be104bfba47ca9cbc677d0f74e4893d23a28a89a9704dedb2d066198e7b4bb51b74c9222f8f8814386d8ea97993d281aff1c78d889ab693cb1ed172c4c7c7a117f43b76da47f0b6b73b3fe4c648326e58f1505fef15dc5b3c0e96d31e98a087f2f5023d804557aabb96d35755ed117515149a332a7139cc1d4b85be5dfd3d41705d7d2aea2944f5b7bad54725db4ffdc8cc94f97723b0d66a2db82ac612780c00efd40a226252fe945e80bb4ccfb270f54aacbee7eeab35347f77371f6ba39998b8a93e31f2fcaa8456864fcdd9ba6e2632738e3e6fd1e6c86472931496b194e53ba8ad9518475164ad64196648ef372d2965df180e1800a45ee578b0b3a0cbe67a80be219f38e6ea69d203d54efe6d4874eea64b50fb79243d87db91badabba70ae3dfeee9825e4259638ae8307c601ced44cda1928c08b311ce90ab025a44933ac91abf700cc1572511ab458096e520abcd5a538788bb8b10c5a505086bf5bc9cd4e8f683ab9e52ce05ebf63ce3f73da8d2db617afc71bf768623f0c6adaff9dcebe7bbc64d4804f62fc014af772dbee0302c0fcfda58f38f5e3eb266620f12c98e4e28d8914fec8e8ff050138e19f94628449b8e648f30cd5af391388a1aef885fb620abb00fe36bc3dfef1bf14552661134055b6e2f7cc7a488420f920edb0b0002595b8cbe19cac676f3018217c96983647b6b558543669cdf7248575ce6fd3cddb9f2f41e5805170bf6bef95348cb2243c778ca5f9b2195030fcf03dec8ce0994a45d46c5b806fd29f767c16c8f77a7fd41ec301310dfdb404407118837af84159858738e107f1290695de657a76adf18f032ff1eedc97dad964bd365d7ac84151ba5ee9e2b4b184914618ff659c70c90c42cd9897151840419d74017aea3930771224d23aa63c90580a31fabe035db3e43fdb766f400c76c60d2f4d1f077fd509a61a3d3918171566960803fd23c4491c4ed8930b3224e4e6fe68708dce43a7e1c5c9739793d270adc922142358354a7ffaefa2836f700ec93eb14253188079e3035d40ad8c60ca273657018132865770ec78c8a4562ec7f28667344c4640507910deb89d8be2f81ec030289998e312bfc8eee7f520773c4c0306b4ffb1bf61b462c191314863b7872c49a09bccd2afa8e311b59512b10f42177348a1e17d45c542c9990a018e774803477c2c1d3dc9fedd79c35c18efee0e57aa7224992214cb3dfcfd9a134e7e7661f681e991072ae73618634e4eba85d950ae0323ce32ce702d1110f979907ebbd21f8c40099f93da332a92c80260622a52e6bed70cd715f7d551efc0edb7de9be8ea75c3983c6ae8de11618c3a4d6f619d190f58a278b30aae917175b760178f537d8d26dd77843c8128c782e0f752e5be2768a6ff007c84ce827435b48c7690ca6147ca584faf59bfc33fa62ffe83340a0cfb96ca5896c5e5d91d9bcab4be70ceb5af3168c2c55c136da1c51eeb2bca64301b98326c4af831b513052999bb5286c53aaf5fa41a00f581cfdf8521776e068bec81c3174c57ac0f2eef93c8a0322c6c6f26a2a67f8bacfd46918c074922099c735b9e4f215e086b21ff42abd03097f7f5a590f88e4f60c631fb42f93aa7c6602cd6e07751b631ad11a338b849f50f7871bffc22253f058d81c02cd15aeb46e299f4a89e0fdab85ec147e57d09f0673ff866454eb7d6ed5dbbe3f1f335e110a36c72fa3e5e95aed575963e9adf783006b19d534d26b54f661f68661dd1d24b3820bb98b5576f8173a548e2ef3ad63d2849198d960edef32a863d9f0934c49b90710ee1e8cffb2356bf27c3d9427221894bcfeba721762e06479437e8b3c3c678dfcaf9c438ef59e3fc8d5e75170300ebbe2bf615d780bd098717ee2fa7745685d879966f57210939387acdf41cdc42f2e0feacd20e106a42b3a433c45c851b0cbc7e7fccb949787b1e4a15ae61d6aefad0424547d077a66cb00628c695cdcbbbf05a9f870737cf6b297fa7a62275f960cd8a0c65ede4bbcc7d7492f94c2a7f72d862e6609702a54e560d6513dc035b7c29db56a9d3f4b6eb6b5bb4b504c4b7fd51e0453e28acd0e4c8a103273abe447b7e1c340ef5e7d72d56e31244b5548cda8dd29b236ffe45b2c4b0118721c629c05f07f12fdd78634a054405e2880c83e4f7917479a025e708f30a38f7369eebba37bebdac1f06fe0024202b5fe762bcd9030630a5ee823f8c9711c3c3f4a924cbda23c231f05fb81285ceff5cffb03f8e872c95dc6608aa066bd893a660a75e62579d8d9fdbe1092d161b7d63fc5c011af3d55d29812967d6c3c31957acfd31153e9e6a448008283681b7fe985f0100bbc1d4140653c43acc114f3eb0f59514aacd172ea22e40ab03604fb125af72c11c4c3a5fc500c3359c0e92f5230f6977fdd43917e555f154c232089981a22c39d83d068c575b454868dfc59891bf4d16c05fb03a41c7a276680334a077305b0ae0c59528288bcdb6fe62136a8ae076f2e09c560226dd5a3b2b2eeb3f2ce233cb6cb9730c1757993dd16a1d8674762a0382bfa9cdb5a656c0ae043affbd9295aadccc4f2c6750c9c4035003c67682572777dcdea1a4c810b2394c5bc5d3a81ab6e81cac51028c6de05d4cceb592505486788282e60e0165e19a0a4051121fbdccbce7e4f5a504c6c1411899f96110a237ff1eef8eef4a98ddc4675d9367839ebf5eb7bc6794d094c1bc17579044eabe412fb197dd1b91f642918e0383c0d8f16420c43deb1bf9fd48c8b42628d7131aaa189ec6727aef6452637982f690d11b75e4fc7c5c99e3636a369e747c10a7811408719b1fa6b001bfb86e5111f077fed5a11a63c380f9bc281bb50c40c010652c204004b702b5b53b27f0b3c7b50550780e68d90c50dd457b1bb3a324a4e0a768e99f7b7d68ff37598151ea4fae8620bc61b25a116f67822503657cd40970f43debc901311c79d0b54fe2931c0320adbe856a90fc957d9380d826b4e5001e44c6abfd8b9563069e99ddc6931cd42b18ce8e16c091dd825f59743672a1c902a0072e52003f40e5183137009f840260040e97378c86d1274f9f0423e53f3de20a6db21d07fde7bcddbc78e4a25abe44e1c4a015826e002a39a835b7a05d719deba4f2f81300da37164d14512676b40f2690ac600059dee7713784a9a15f7b9e0bb995e7a0db996b8e904bf767c8b6c8a6fc90ab0de045f33a721e56d9ccb51f9c6256d31d99a0ec1fc08474ee455ed7aa50ded0d37bcdd8499042d1821ab5bd8ffebee76d3a73f012b9c3f0ee19eb9f827dabb38f9ead69688a53d22a54d64553f01bae22cb28bb779ccb5bcad8006ebb809150e1cbb6ff76052d90632a819c1fc8b5e0520af1bf1c9355e379e1af054ca6d59da392755fbabf28f3dd354398d34b4104088263b487b7990eb8562e526c4807e0eba3c983455905ebd1caa692eb3fd8b9e72ef5c6d4501bcc562b5b3fe0bcef7ab273c2b5e263d47579fd5a5cc31ad00292436c20d4c1f7092c236bc729a89cd98df2ba797c823f0add333dc6ba57410e41cab46ba8ed83d7376e16dddaa10b2cb9297cdbfac2eb41f48d7cd7d2b6ee328b22dd6dd412ea26ec01e2a0582e96f6242c86fe455b0644a4eacd26f65b0f0c39f0bbc6a3eadf6e10d23cdf00c8897ed83d2936cf64e04d0861e7e7e1d85d70cc51e9827599551975e0749456cbaf5f416f84a90cbb3f41d995ce0347239a17403cbb4794f1d638f190ab79d420251e03eb18d2a564a029c56eece6473224e4ed9b655dbdee14e98a101d5a885b833e784ad43dec7eb061c630c8321cabcd387768360a45caad897a5b9f22a72bf693a1e9a8385e391ab8fb7d2a8833ba6316f6855e435fe2e2b94b9eef88428de7d3640d6b3e4f6537b00ee03451cda512340f718d34f97b5e4a666ea7b8a9d761929e429336cef6e0197576b3b6c181ef0c279f0d13b2b11424c3621fc34566faf772074b47df5cb713b58df5218bf54cb2b3f894c8572c887122076d0825c2ecb3598a58567a5227d22ab06e88482c9b22a0bfc364bc972ca6046a1eda5ae51bbeed2442ddb4e0247aa7a9a6835fddd0df5e8236fd1403ce54aae74fe7b186e0a1416c395ea83d7237052a57fdc72e47db7987aef26a16856502820c5d89939efc4b4bda16047e922daa9cabbfa1060d11410c34445878d2d4745174d7bb9692dd92af281087a8460d4ed5201beec43e6d6bf69a93b3b34797393509663a4a77c6efd0c6650e7b2b9a89172c9b959c585de63931b87b546fccfbcdbb3151ca5931f08836ee7e5f4c3506dd5b1bd296157da1ec6fc119024d87d91a0c228b3dab0cb5481989378a63f241300f5d36fcb4ef9ba957356e60f6ce81ea2263a9775b795939735ab5a33ae964badd99134bc79b1a1896b7c1a1a7a3ef41784f0419a104ca16afc502951927387498b980f29d64fd80dc9a9d4afbf5e6f9c46b68a28988b9aebbde64297d31994ae7324f6660d17e801d8423f9f2f63bd7787c75672551b865c135922f3631701faad9e8c944a30f132d8592b0af682e5f3d328a938f6eb0d6ecbaae4e017fe02cc574a879712799f4a264fa11b443091e7d1ea3263beb346126ef8351b1d9bfae91eca1a8fdf32b2bcd150f6552748c7dd83d0728a2fad0a9036492205d182ea7d32c27e2448eac8674b5e79e97151c633eacd478222de6a59af3a4de2fde837d0c044c7223330a94a016098802105d6f35423463939875ded10bf74875d5529fc2d1b6c41010509a45fc7b122f1bfa369d542021a4b61b52b3841f22e0fae8e0a6d232e4f241126eb967a91f827d81f86cfaaf35e56b7f2698798184d81ed727fbaa96d60616e9595a33fde94cf7df90dfa4bd522a4118281ac6bc8e0d1d38aeca27ac6efecc2d43474995a213d56b010ca65432b3cb663e9f076847375222e78883d693af3fae0859afea68e67d973c9deaa97eced5ab88ce903969a7931113f3a9ec3ce97468a1df09441a1a53b8973573703c4147efce2cac38518c49a3ddf28342abbacab7a9f73e57119201104a46268f7ea0b715bab3858bee1e07298a34bd1a916e2e0e05539c891c119b33e77ac808723aa956b4e75786b88b0055639e6a186c317c3960de5850a4fdd5773477868b50e17272d3149b3fb742e698f6c13bf5533a808df290c7e29ad07d791d7586e1375b532d0f5b2ebe7a0618b61d26ab3236e9bdde06015423b735a60f55140ba36a7b5027a5141d135652321b7922c7ff3ea760087bf8112828d5f48a1dd3fcf7ae8d2a02f8dee3834b3ac19dde2f71bc16d5a6a5fdf8dfa9bd76f91eda19a362ac93846ad1656cf7bc8a83db39faf8e2c4f4ef6238df3d1a40cd5728ea2cf029af8dcdf9504623be6bfe0e9664ace9232bd87225938673524ee60b71058411e756e8b7a02ab9500b2d0be26e7a87413dcf3b19dc7c7472be4f438a8bb7493f05c45b7097bb6c25188e1dbc7c67629a943f8858cfc285808aafd8ea4b6f27101253b0b02b6b9f140a5fdcceff1e25a678f1d22e0021d02cf848f46b3892f4f38201319749acb0e75a1af053aaf5937a38c0e4d85e9fed1cb68f0f493dbedaa45cb44f044b8dfe5bf261cebdb76cfa603c97048c43f188ccf8c32bc273e34bddbcc0d4d01ca6c173da0d7413a6b499e63dd19040f68bb89d766a597eeabc4c8d36f2d43a8a8efd3e03fc5bcf2dd770764ae0c31a2d30f5905e31efd0a696e2c90f2ebfb50d3c593a5dc95f5b8188dba84e124be8fb32bfc2da6944439c8122a238307c09be616f7d6a9198e379cf689fbf7326b7611f6299dc2c1e2caad87d0368c8a2d81a1c31d2d71ae23fcb897d303558d7148ac90050bc2844220c6ffe0165a7e7277178a74678996eb7ed63a596957bff19d599b54a3ab277bfaf93aef5a90ac0bff45716ee022c255c4a07d5760e688c0b518c3e1ec60ed1af1fefaa21f3c3140ec2e40ac348c4f217fbb9baf69ae867dc3bdaf190afdcda3ce0ed1143cb7686c7052ea3b16052b25ccf0e39ea33f1a9c6b51abf1b08a44104d47b55fb0fee1e05dce23d31b3a5f113e0637b055375a94f2216d5cb2075c80195cf967e2b306e17aa22f4f2501fe19bc9979d464a2c41f232616c734d68125588953e5b30a7eb18d418334d487c5002298db99eca9c462ee10e5c7d4263ae704f8f5df1257c689775970173d217a8323c75f250943389f0dcc84f5492ccc9a13ddd271b3ff7175b4b275d7e9a84826d576b763a00c07f278899ba456520e28fa616689b8de06672a5c113f572c62ef9a2fb1313de5895967f492bb35ee8c5995a380babf9b8c9f12032a41bf5e7a1064633790d3d6a7c89145e956cb9761f89a9aaa74f1eb5e3509fbcce3080c453aeb8bddeaf8ec1c777537c3a43390fade6e49dccc4c622e799da70500509d4c00a31557e5f406ed7d009dda6871f7be5b51fc551610de5bc62458e39b13bc636f0b5fc1db9fa9ec3912cb121f275c6c6c3acdb4b4a1968728afd725fe701a621a826d64039457e249cf771a1b427790933c697f2019d4834e896dabfdb6c9a2b89a5668efbd6de6068b3687d03cfb6a4a963e2244897cceea54d205a7af64963bfbcae5e8f6207c101d812176304cf70c049d7bd8628cf6120e09e325edb127494fed2cea70538955c534dab37b07a509d16757a3b486dc53f77bb6c374d5469baa61860080e29f4896f7b07ecdc3f11437118b8fae090c568ee7a84b0c02f68964305ec6e60a2b5b3ecc3e8b6f332d67c07f26d483c01a92539194d66aedd25bfcf46ff129b91ecc407073c8ed2ab7ea837de38444909dff9b0710831092ba712a9491da95ed866cda475d945c82f9542472fc2cb72e54ac5ad8695c081793b367ebae26c031ab317af37928b589899cb67f9e2c848018ff93ded3b7f51bfb2d4a333a5276b96239389c654c4a651f19e8d8240981f119b5b7ae9bdca5a0c749bda47ab4d16e0fe9079ce392a4e455ec17e50ad9986b30e8846f16b33ca47b990f0cb06dc96adaa271f60d57c42b96e0d28a1fe7a1d9f8d70ae26ed30a978b02bc278cf2562c8bc12d7819c445aaa2458f016de18f5899bc4c59fb3f7e5e8aabd806945a2e8b28a99f0f685ff157cfd08daf20f649002c9fd4bf904045dc57f2b779df6caec9b08091ec12e4452c0f3f02e996b6066bbab40bab6ef4bfc826b1035957039beca6858082fb5234ec39fe9c78b46ab3c8cbfa5f9bf9ebc7b3b4f53535671179479d6a9f1c76bea3d2a3acf5484e1fab61f51b75331dfbae39804ee8808942b64b743744a9517a107c0f004d79403d5537f4d9d9857db72f7179aebe55f7636b251a96deb06c2d8bb3f44a9f595d70f59d1406d18b1079a26b881f1357734b64abeb0d399b39f95a6f944166998971828e4ee8f4aa5ea39410890691b8a427bfbd591c53f7b97d2397280ce0dfedd4f6cbda4030254293388092feb941ade893c72c61bcd439870668694d1053d6cb193dc04be5d22c09b9d0c7f61b4af83dca9a3d38903b035473c6bf5d17dfdd42c300f7ac9f4cc0f962c7a22d10a9317bddfc1daf81ffa6ee9981ce78492614ddd1064f9dde3efee6fb9054a47409e99138c34992db93a1b804ec8be1b611ca27edc2a959754d7b28672dee522f83a9fbd3e2f325422a3a045d88ac8875d5e0fe32bc812c1752f871afdf0ff964590b7202bbeaff3c3ecec24e610c99742ab8f82670e30837c2c1d3ddfb96d39e87510cef2ea27e31891c533db5818a30e3645bf840cd85af08fdbc5d8209d414b95f31a71ece88de0080c9f6706ab3bbdea91c73f9ab3187198eb43743bdbf20bdf5c48fc592e7fef480f0b62d29c78b0023857fda14b3bf2415a03f13b24a3a25decdc30c16c5862c35dc48c885cce6145f3b2471558d35952c1ada24005168f3638e3fabcee8710cbe41da2f929884247761e8db5e041ea1ba31556a4ed95607ba05f5b985673308d64d9f74a3022f2bcf6b783525da137d6deaf87d9b8171c6e6b793c755b3a4e0f2caf185e23268a93a60b65a3634b9ca70db430b9fe0372aead70ae66d06b6eafc4d8f4284e73340a301648750754962ccb3ca6eb7073cd69c78ebc404cb4062a54a3b54982bf2dee9347607b5e7dceafaaa10478cd90ee56e87a56e28084408b3918de9f019cb99e38410ea98a87d54bbb15f259357ceb51a40b7830d42143f849f597762db2d7d3626a12175f542ec1420babfcd840e723582abe1ff432914779518dc845fccab2f5778aec07a8b28967da08358724adbe61b717cb2484ce57dc52447d381e5535776d3341f698d96d24da3c694cc6f5bf37346c7c1fe865b3161194a8ee06f2500f45fe2ef8f9659fe55b68901c1ad50220bde71d2980cde32091562ea8fc9422b96df4e07dce8dac22949e16438b72fb85cc83378839ec0e7aece7e95fd4b2e7e5258b193c1dba5d539092febca802fbf8923ecdda798aec17d84872e0659d213f6f07da6f1c273a90d231cff5c84c9b1af9db39f940a7e7260efb5c9bb3b6475d65b361f99717aa6c2e092887eede64a0f21d9d853269c08cd5281d2e5b99b60535b547299ba46afe25fe13d8f20969d944afdcc6b076cd925fe01c6d5bba193e5ffe234f34301f24df3e0d13cf39a3b869419e597706588cc21d7cc6fd3081e5f2550a587c95937869f5061cd7e2646daf600fb01d0d76a0d034d4dfbdfb7a81d90e49762fe9fd0ebafdafd3ecc7a9e4bf7065600ede38b1d1ba8b3ff008f063922acc260ce4eb49bc33e64a369e7714e46f7297a2049e15231e7ab91232e29037fe56b8b3833f3d1daa53318ef767cfea2ff830a71d8a3f8b7b284c71377937adaf0365c22a29ed308b25ba756a955b0df2e588f060769dc72cbfe240a117ce3c6c10ca3702f2769a839309429ac4046ef2e73af0ef3f41f1fa0e70ab3b5b33845e4d07c2855e68b7074ecab675454cf272ee59adf1f6a6c13f5f3f31ab37c7e85c4b1269eaabdfccda360e8d237cd7795c5150b962350ce6dd784194bf6e22455e9e3f229996d7cdf96de27d7d92691f03d2b564d2bcd16ab74b12bd60d90b70152f3b0de1adb8d25a6fae6ff76fcb55eaf93af849a2670355cf94b33bc570a3d9f1d3e39fb601faa7a0cf2dbb2a77bb2378ed768d45c855fb423c7add28d4a511c46c9fbe6c6d01903c634247c558380e3a902d4e656e20f4f9be1ffd69107a23793d8e5107ecbd1ab11a97a3292f71c2fbe423bfb75a6294e2b20ff44d1b5c8e4b3bde17688cc452cc3f572a5aba6109bb50848f526b3c3deaebf4cc3882464920ef400ce8fde9118d39fe12ce804043fd2d901db66731f80c057f5fd15ce2a742683b261cca0b93d01dbd505fc4b1fdcc143ee5dd0f19e96ac9fabb045595e5f0c285b574b68ecbb2976f3511835692db71f72c7310517b496f12f4196b0d1dafb4df01a50d21eefeb27aad600c4a5a999a35502ecc0c487a28919de16279639b0a95e1d6a474b368cbbaa46b0f96cfe7d8bdcb913271b290b99f749e4b0651fd8f37d0f97c4da985fa9988110a6428408f38f09a18080a10c1a92d9c5d0477d91627e4bd212088d36cab276742afc2a4e65f993a2529525c6e9604019d76665eeead5b31c3f8d4184e72a680c4bcb43973b3ca561816064ed54f9a678d21f888b47282196e00bb03f79fe3eb90f1be1f8c9af7221caba0427c51417ac3a5b61418ac5284dad25c1018d4022baae0c170772eeaffb03e2c23969c975016fbe26db27f3de6e98bdf4fe40c9c9a3dc671ede658d532712cffa78e7b83078785f766a0fae301ee1e477fc3a6ab2d919331619d15bb7482b6244bb06f7911590bdaca1f824011db4169174deef2b14bf8663ff48c5683d0ff2fb12c82d0be935aec497d5ab4dd11dfe86a38b85cb677e56631bb53529e06e27e833a48097a3e265afb9d6db7194ba789f7db2caf24e9a23393d432d7a127dcb3e92a7ee1e9a63ac505a1692234fe6370730ae23a068f89a19fe20f68f661b08a77356354af7a3dec03a78f6dcd213e8e77b9798f3c5019b9a0ca274dd90ddc54abd63237eaf37c0eef3100b2867983f8b59c36b84f14f404007767b0a74f923749076cd678665568e79264220a2a8c133a0bc8dccebb3b3789eb98271dc19a5b05c1bd881a35e9eaa5c1baf3a67a157527651346be2fcfef301afd5051ac526b4b7c26409ff8c5d867c8a643b0b8019f09959945974966506866eae9c500a454965dc459927a0f4a52f92c07def5a6e69f4c455923348d78ccf6c6193a412afe7acd1837783145efd85586303e33868326a79fb147a463be8a63173bd363092c79fb39c5ea45b0389fea05ea4c421b3277161d907540e47fbe077401f4a1dba0e015a158c3c7eac258e19e12075238af8f75f4c98a558c071ffd98be8be1a3a81517b3cfebf19b0ae819f2d6b527e7f3a78ad9f5d1882b7a6344e6bfb62aad9ba5cdc043f6726c9b29d2634b765d6c39496b473c9a5dec36333eadbb4d10974597d7f1e24a9af1383fb86226b8b66fab8ed9000d94e9cd7b6ff2874a8648848c1ac772fcfce3debadb4daf01ef4ed67ede68b034646ae12ffc3d11afb095158c06fb99ab85f56c0d5195027d59a90ae30be67d6ad1d57845a41f0094e5b6d7359d1678e57846fcd0beff53fc77d50240ed683c95e1284b64a7fdfdeaf92d60dd75ebe6a212f21eb62a79294ea50307cf890afcc372d21ffb45d527792ce15c24065e96d07770ca6ec3931b76e339dce7e141a38f42166b30dcdd54f9a37012d205bbd7b56cc3050856b72bf06243a096524f0664559b65f9e002c6f5072d8ec1dace388f3f743624877d86b0cb0659f2d677daa7717e5999fd8a5bfd4af78f85cb5942d60311b5214335df70456f3d7843a718d9e9badd45757cba63ce51cf822f5277f027b17154faea7abfdd8d67e7f0803beacb5b1ac4b34053c3b44cf2c704aef74d0d2b7e7237f4399bceda2b8d75d5b8b7757245f4619471624f20a7a5a74b8ed0e7fea79a0b12281f5190190fa5b73b4dc3249090b8bb559759bbe42a9db39f1b926eb7bba27a29b061d41f4cc632c01d79b6eaf70c069e729a3d342761214d6bf45cdff4e8bf3e8252d8e8fbe15d4e4b31bb53df35231ce193cc538f6c96798758a58a622e2106035082d9aa84b18b34619d9acc22c2dfacf71016a698efebf2e8b25f64a2c25f927ec1b87346381a3c542cc097062ba11e025f6b910a3bb2e24ade7602f9ad153378fb459ee02c2fb97ec74a22e622bf02b141a7d653f2c0c9c92b0513faff0b9de37d9912665673382738885e5dbbe49f146d8b21a867544d202a09dd7ff0f14607231272a47f1bf9528c70c0a74f4e67208dd741657577d85aa96312aeb71d12a15a397a97fd059b3e46e75671cd1100bd6c4e4e1b60ddb02905d32fa1ff11dfc8f4e4063e6d9b3515e4bef352de5923b2d1d6243c716c0d3fd7a3419d72d15398ad80774cd61fb5e44a349fe46a2bda9011f2921b2078d5aa18db65e3c77385b82c1ae5eb87acc00743ec6dc3100dd2ed76c3a3d8ec461babc64087245756bceb33cf598376388071b1d413587a44325f7e0aacd7cb6f3770f18f34dc814bd83c3a7e22d18970b88b707d20f1e91c6edd3c3b22d79f38d3a773ab61698997f2f9e13b5f17a99b8df852afeeb42ef8dd500b8e4a56f6c31af9a77614a902b54ae0223f614708b38566bb40af919cb166c6c9637fd108c23a15a532bc039abfb099610d32babfbac1cc23bbddf1c2b1339bb9df3258e8c0d3cc105846cafca93503bc24af455b41116180465f661713feb48087ca3f22f2059daddb671f347562d220d5f232c3275d5f0cbc70e8e368515444061e1b45623b87381808c68ee4eca183604ef0a383805a564e6efa172610660af1adb3718181f6f7e51cc98b90ccccccafe24ca2c59279d27d4d7ed66197a678ce6e0fe73c2af21a2f33b137efaf7268d0a179f7f5edad5218782fb619dd9cc7a8db64dc61529d0bd7e4977bd957d44a83a8efb444b5c0b269312668047eb7860433461abfc9a2f1b62e92fce7704721f3ae75e508708743075600a65403dd51f5ea037b3ca9319352d98cf4ba72a8a0baf8c5d23d38a34658fa281bc463cfed09c7bb311fea8e309a2dda7958fb1a6e98b743492c35af5b1cc529778e96fe9fb7ff0a3228121b95533573454fccbde04a6081b6111896e4406b7fac47339cf7b3961bb01d54a9e623423cb7b9407849051e3dc22c560977ee78efbf1d914f580252743ba5e8c94c65d2837f46c7ee8d4fb86b51f9a48da986583fd40e569f78fe2630b94e2392fecf1b23f9388a0ac7a6c899bfe591fa0cfded83567e74f4c0d55a6564fb9b2e4ef9d184ea3186ff488b33e5c8f66565a6bc8b09a1e76aba7ef6464443df97cfa4d14975adc482de151179094b644b53a431d35c0915968f300f5a8b5ff17249e816cf4efb4f3f26c9f82b280ff732788d1ecdfa6f5ebd4cf1c7356fad07b0054647ac131395add04dd7e0d52cd6674e1a26935eb5180826b11e34d1e986378b1be4bc98248a55f6aaad10b815c0b37652fc5369ad30cef8dee88f1621263aebd2846661376a6476a69c5fda4bbef32eb9afd19a41e77c4d7370169c24d9d07b2fb3c570c273b11e26eaf5cbb0b498e280d9911d2678f37649b07bed78eed601ba524c6b3ce3fbf8539f412071b08f45e628b6ce2f0d9c741369c18b0f3f0a848eb93671ca1ece83d4ebaaf7af3d9849ffba6aabf366ebadef73d75685b7c4d80ce1d17cd7642d3cc2d50a8244805671c33b46267a48ac2028fcc66c983a0f3744fb95ef387d1f9dd750ab9a61c0ff43e3afef1d6c75bf4b5a954dc6ea7cbf656d1bc28677af41bad531de9448b4aae791b1d1db4d18d331ad4bcfcb94316bdc217e9ac6aaff7e28d07b6a6e7855061ce39b76c422b28238e63a7a2dc5f346ea9cc2f9fd759d09bda4193a91b673638369b145b4ae559fa089637d46af18e80de410fd67855fe0060f69cf3e2c2ce716cc0a254af3589c95afd47f15f689c4718845b39e013388621c5e70812974a8590497fdbcc25ba47ce2b39376e1501abbcd1746d791958613e7480e3fbe71a1d094db4e8f77bc6d8cfb528277d229763844a8a3dfee7712b7233b51460c46d3839b25ecfa6d650ca1af64daf422ae48804992b0d94fd94e5dbb797ac9a38760fbb66a4ffcb843a7da5d985d333b011c3bd80732dc8d46ba94dc73b4227a2fb0431fa86a8237f2409db3d0ed7fee51fe8bc4d4db8c1af7b3b246b52b6f499591be7f0e6ae69a323b9a22675c5b353038ebf4a909bd9e0b8c9c01e5788ea1fc99f2b90d8c4df90b273fff9c07db080868e126baeffd302882bf03033be7eb82f48b5fb70d9ec8f6e67b3610631f3e9f7e2f6331c6e0643482b4f0fe223697bb9734dfcb9b4f3069a5e1dfd56f07c4178616d93f7dae7001effe983bef951db07dd7a64d31001076a17ad57a89b88c585b06ab5117e79aad84c6c0123769459d55896c3492710eb36c3a1111fdbe8dd03880615071bb81b5b7d1cd08b34f7e7a5da5bd4b77916042dc7e6c77c7f1b91636f1f4130e10cbf65c4538da3a881373018eb495ac8062fc2d57a94177eda5f37892906b18ddde018c939af3a5785b08b88b44b0ade2c0d4be2e22818ccec6c926f60c117eacecc8447126e2aa992a93a26dab89bdbf0277ebb162a14048f2aaa5378613f8f9129f62fb782d9bc9ce810511f5395f5373683fc7c041772871f78751ffd0245724982944a4dc98d8c46a19955091022e9ac6ce4bc11a94b884a63f701f394d271072479b818db79cc32fc5fde6fe8c648aad6e476e1c1960785c2a043b6f0ee9e62069488f0425f47071bcb03216e512c83f5e8a914db5d5f40ac788526e083d9806f4df0e13e65de141724995dc9c838c73c5af72e99a3a85c1b26ed59a86b76de06854c76202fd8a6410eb611a25a89d58b54bfd83aa1a31f1fc454d8fdfecc9d44f1f43102d7eb0b13772341e8d45aedd37048afdf1c6acd2041ef1534ebd8a9ac3c574c116f66174ba48a0e493d4d8f832073fcccf29b82b873566061fea362c5e24a261030edc31d820cfdb947a24b69447659a6160f85f770cfd3b6d86e7018cdd79b87922d0c5f4becd91ac6c161e320308bf2eb37737e46fb25f834338c4d495b2e6edc75f9edd5a2b3731590610138fb4f000406613394f98aaa4f0e78a64f643dbc9c7b914457341ad4ffaf7315c4c0ba167e0f18f73a389be2bc5a52e6835f875a7b9336f990f7443ce9bcfad391635478d93bd3c0fdbd49b8b32e1dcd044a855fda8a62aaa9e7e328027669bcb7547a8fff93bc110abf0907b6ba77f4b1429df95e204fee90d5ae90043ec46d5cd631f7206b2dd0a29dfdbb0fcafa79b3e31559340703cbfb0ae90fab4944a4bd02c20a3fa55e8c3f2a96ebd3fe128af14b50000c1b50c7b753c14ebb37cc97f717dbce7649c77629ced3e56713241ade0c777fd452b6406521d52760585eeb2cf2524ad8e3e1e0f8892e352d8e7fa52943a0a49fda29f49e5d49520bed5058efe7b15977d3beda176fa1add8d89e154c6f547dd345602ff7de582509f1cbb13e69af9758db0b67cc31a84a749706d65601f492e963991ab41457c761e8967a4d63837dd522770fe7e1f5f8bae4cbab4576fd8beb1a6f99834f4f8e45b9a263fad21edab260e08211f14d6b20651a78a9311b8f6006831dc0e52f16963371176d1c24e1a8a0e3eca9f3dd13ae0319de8ef02e37c6c80777a02442294c61ff7e12329eacfe3f5e4291babd76b5a78d8136852e5a7e7c1ad0f3949f9339fd76df825335a0d6e7d7808cf3477c17ec9a85751a588bad783c5956a7af13447fafa3ce03482c48b111d72cf571298641b63eac4143e535743cf5de4770d13d512ff91a7bef92b75e779d7ed498897afab560c75e1c8b926da2fba286c524b932c47e2a217d71e990bf0a7d10df1278a12d9aa167500db4269f572517175c64ca848eda3f188b9a951642573a5606de1c6d48d17414c06ce19877cf1ac4c0e3ada328c657a7134fb96d161d0d9c23922ebe984c71219e22d44409c1442af02d487513842daf262af4462d2fd307588128cc38958be240daad17a4e405ab5accde0c1557912a5f30d859cdd7d3b439deaf82421a9146fc3c32e9731dcc62fc371045304894127853e295e986f07afb080f6937d7f5dfe7ff81a9add5490e5df0acf68c998f1efd41f13a06b045e92dbebd486efda410959857c67c8aab3a2583b2e4e767adff2751c732526b4bd27cac9676e0aa7a3263c062ae8e77b8c2b8e4dc887b679f57cdb8ff19db45437f989d285532b304e145301050046bb891a9c15c69786fb5baa3f015dfc635a01f9e89262280e5145848ad8329287677ec0d8c50e1f9a2a0d485664fa1f75f434052de5e703d9a00aad60bd7129a8a69bf199abb2963cc75a7f33b297c1a26f1459e769df1815281df0d700aa68addfa509ec077f70905ae8d7c24762cc158776300a82941ded4a142faaec12931a3fa3ba0925e69530a92353d723b4264cb0cd76fd46e61e1a8fd5b6590765fdac02188c6adc8a3da73af39a22f1ac3aea526a6409e1bda3723ea516e73f8cee31ac3e4d77a841f353c7000720724b5795761d2d40f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
