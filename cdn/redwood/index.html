<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b9626439865607a211a2eb3ad485622578e4ea4fa15e017125758bc83d9ece4c47aa9ba2f0b441dcc0df429a29dcaee491369517452d33d3aaea38437072ef34ac50dcd0f8cc1d756ec1aa5da5c66a0d3050c145c4b0b70a0dc6e516e752a2c27d4a6352ab8d2a82e37f5233aefb78315a7cfcdd718f0787fb4d8c8339d69eaae5a306832441762ac15ddebab31443922b39626f7af83cc734d6609ae1e323e5931a2d6f96dc652756ba3323b623b7fdff4f3db72f36fae9bd9efb4c7b60f4fd419f87fc3247b6ac52acb8f731c21e4f47ad2bf10a9bd9bdf8599a7bf3b892b46708b022a3ebacf0f61e3a31965e9f7021d9fa7e59bfdd54d9475478858f24b3bf2df599f59ea906facd0140512c1e877dc585711a8811c6baaf804c51ac304b3b04b9430a0da40a635089099a007c971b4a89ebd67c7ed271806b4ef3df7f2e8850a36da00e409183e2db421351cfb22359b104739f2e35ec738e033ade135b9062b649c56d5892ea89afdc8edb01dd0fd517fa3db28f199824aaf4d37341d3ab72fe854d43bfc174b4fa6c7b3131f66274078b4809681bb6a280d42a385173e62ec8cde9f2c82913d910f239cf0cc536a3cc04cc532b5c5155353eaaed7b1fdae7b5133c35965f6bada69a22e6e72650a779e62d1b562b1b424f27e2a619fb835b2fcd571183e8c3732bead9d6fe1ec1cbd5f5aece572beffaaf2ad68ce016cfdd7492502be4a054e146d9ebbc6d2c36210d94b745ea71f3f7da4a5969bf86b17d3e527f1bdba68f143e508d3b7125a20c6d93976521f4c08c9089668ff2626f34ee94a464a4a21b115081b3475eff4a380aab2bd887eccfa38936ea5a4d7aa8e56f790233a54d71ca1f31f4a463bb17d773ac732c049424c3bc88aacd686caf10462291ba18eeeabce6bb0893d97726c959ad678d450ba4860d40ea6e4445ce3bb90563e1dab891160d2cbd7e4a2ba48ca396bebc28ffe9dbeb6f43906cdc3c2e8ec85f867ebd95bf1fe04359eeb10370252fcfbd7137129d57c10337c4bedc28c81b1edd71f3db74a174699422ad966759b8f9665620d6221370f2077656d5b6165c7fe665d58c8e29211a78da1ff90caf20d3cd04c62ae275045b48bed5d5d70bbb0d9e64f0103f67d3b9869216eb5b2c914c69f07bc6f9389a1c33fec564c66dbc6882fbca1dc30b4e985503f93056095dd616ccb08234681bbe5dfe67ddbc5d1d66bd0e63dfe4ef0e992e57f9936be2bef82dede2e248eda528ff7a2f5720ec5a1767ce2038ce1b31bfcc6c723b7a78030ab8d15782fe3d8af812abe253503795651096b372361da4002ba2549f7bd59e637609b6ebd5f1a167ebef6ece9ae9a9610ce563b421e6304972fd5e3c998b41abd54e90113c4d69ed79332c2bac3b42cdc3bcecf0630f33d5cdcf5be46921f3ab877c972a10cd0bb893ef81eb3ceba6a985e62aaf610340db2b835403a06acd163b4899500adb3c1b59cbd66d9e48716ea059ffcbb72728cddf0eb778fbfcb9ce97fa7b3991d60953af27802e17b61f6855bd343ce2f735a881c61bb3ef63254e0ec978e8d253eda64bc4805c85864563cec3e83776f16502053469f54e92ca78a1dfe4575b6da9c82058a786c0bffffb8929f379f508e72b0259024d9acdf9b98a96322a5ef2c20e62bf5f395eab7f5c28a86ced190358a23b2fa5930a7646df93ec65de290e4b39a3643a2fbb5c677cc8a4c00a7bb3ca1d815498ea268deae42e864832a1ed6fc652bf63c060f421ef211ebd89df122643da20ccf6ee006dd3160699efbaf5fdd0c0bc10b0c26d17fc56fcb1af44a55487ad8db2e18bf2d246052f7ae6e649dac8d2044732e6faaa2cff9e96ad9e861210b7b23b0794d0946676a10fdaa24fcb4d06dd56dc0c036525ef0c315860ac098bc086ab729c1b66229f5cf64009fe263ecdedfa02a0c87a700fc354844f1eeb242a3f0f4a8732226eb2b9d863adff257f495fa529643f66bed976bd9c13bbc441595d0740085358cec73228bb12b81898de910ff6612befc64e63cf9a71e94ad2e0abb45e981ec40e726dfa6633dde0b10dde3a4991b464cfe20ac61c7d9a0bd9f07b955b23188ac195d59650f2c2bca4490e6d7616e8dbbe28020a441b23ca2b2535145ff0ee168b77eebbd4109662f1fbf3cda4b446640c89018e2ba8dcc558dc22d1ff28693171e6360d8bf46a5ac8450845da821defb7bfa834c7f0dae04bfb7f8fdc4cc31a5e2d40613285789acc9fdb2b38a7f74ed81e4c04f3a7196045b37f736d59f563b55a6bd041d627ef4ee5986ad4d84348bffa2d4283e14a50144dc50cacd2358194d6a702db45f7ffd5d511f73da254e03ea1300c110c1e862a9cd35cae42028c4b3f73f32c980a2158cfa460461146874041edb90c730245be1a7c3bb45c530c3a8379188901dab7fcc04a8aea909d16cf8e0f7dbe2329c4d618d1dbe883db6a51e8672ee6640ba61a56e99f99619e5c3936c63185fdc8603522c5a7bd6db0232b91a506a15221dcfd6be9d16a626ee5e3bb6ef395a50ac9860002c62b8fcdef4d05b3ce08e067a3723f239346c2ea109f5130ca83555083364ccf7b0daf9fc1e8e4548cf8517b5d7441d643440238330ac27724b6c9052c5ad9f75ee2bc21c8c86c78f1ebda58875b294ca9abbb94d3a0609784d3cbed3639193b61cb9d2163fa3394e2ae6f30d07eda69c4528b0ae092ff91e883c4d97a3b5bd653f702d71d3db544ce907e0a0f8a6fd6ad82eb05bc4f8092ba1abf21c76759a1c110725f46977e67e450d3c64a2270c868f1f0910b12b527f85f274e0942d81ad714486ff43f989a54372c75c9aba9fc3a87626f61d5bda68d642ee88bc4afd7b1f50fb519c290ffa20022bcb02649bd6bbdf17f4bdb371fce0f69d2c3c9624ac5cca4088a0f35f08949c8bad683c37d249b02c74130508ffdc43c92ec589f6f3290fc4cbaf09e1e06a4849fdf5d2c2735b77f8c994ea8ef29f7cbd61675043ae6f16835b760534f6b40e78503e24f047de9a5f190802d889e274be529847c5cd02141ff019b89e46972bbdd53ddfffd1f5b1b9fd95fd1fcb113f6f0f72f0784668db4f0839f2df329ef1d4ea92b38dcf08028d9096286092d07056552d4d9e88b890bfe86f3f84f9cdb321091f09fc3d5c26eaa730a3626495697bb4b89e11cf6b704564123fa053d201bf468cc5ba15e55f1e7c7e889f91ccf1be97248888e6070f9ed9d7927c38b37ba1d5426ef9067bf79450963821a41a0cc20a4839cfef43eaca82e895ed621706d7dad36e542b88587611f8b7cd47f7183a7d2f98fbf32b0cece47e655887d3229225afbe698b1b394232eb6c8322c6268282be7fdd2e3b97d45335259c3e970ff9b4a263175cdf9271f97dd2fee9de7efa2ef2f27681d05a0cfbd37194f426d3498be0fe5f62791b6be15f87b201bac8ab174665b649d66d589007c860c64cec1dc1bb63b76957c3c559e1943c5917fef239430d9b8dccfdccf4b2bd49d43bd247eec53ea560afd7774c056a49b3fd472d2d893f89e04a456ef4e8a48bcaf734cb97ffaff456b2f2805ba60ef093ee9e414197b0c7fdccb11eb0c8e19f447799eb0d6fa3a319088a58f8141ae724ad1f763ec5e3877dbde4719155c4b82dd081ca6e9a2be738a51cbced3e641da8fd81106c26afaa2296d31b4b55f087ee8185b15ed44360521c35614a134e4c8ca0f4b4eb2792d6ce7d9c43a850328fdbae7f64658b1ad4b9260f06c264cbdc96a5628f93881e39287b30085cc86c31c2c4d7a71fb817f326399a9f62766df2703533e59a50a141afe21a83e283c0be560efe47acd095cce6900d98e6be35636dec42c1966ea7f74039338d177198d68ea21001bbafcb91642821930f98f07b2a1ead9afa337af8eed469efe40b3fcf2ef34a3f49363366d3bcf271aa8f64e2438b748a0db7c70f1766e62081b127e1186183502e112941b5505799238c299cf8c13b804167ffa1d1fc11103f980447b09fb80b9400ad8f93f269843fb5b712a80f5226f2cd57c62fe51201096132c5674488219017c96b97667bc9fdd5e636a81af52bdf96c79a20a245845c7e886f32f533d7c68de4e7116a79f26c9f15b54435d9cbb3f4beb3dc3904357c3a6117bd0f33b991ec11facb476cc977a021101144202a69007f3f84495b9e3eab983ee41127157e03a7d5469f4c3bbe48e748d0529500cbcc5a6c74fffbf3af573e4e37e1bfc2a92d54a8018f66ce2cdaab1132d7a0c546304ecd324d2ce4ea336f703748ff6dfa74148177a37773e22215fb45206f2869e6c9b38aca2c8cb311787bef094d5a530185bb2df5f90db14176bc6f32a2fd7a5f3d32e97967058970dc8f413189372c04a846c393337b67457ef70a1af740087c19817abdb3de41e9ab81bbd6327763d912dcc363e4cc37fde019bfcd63bdb5d21e04c81e87bf7114ea7ed95b69cb2fb5144b3dec4f7a6b3f168d1b5167c70701a81c0dea0336a9d8c56415d2c3cf6fc63bb0f89fd7c13a3a21c3362d36837e1f81b68495c3004470a8156358257d3ba5584678e13fe68b934eb27f11b2163add375511b41ccb5a8f5bcb54d9a9802a20cace36c299539f1d2d1c89fc968b27068df6a249eb74fa2445aaf514728352fd81b495c6d2b78213e474a386973e88060cdd43e1b9e4193b2edd00dd542343d3739b935830f6f6f4c070ca9e91dd429c8b526a8b181ca6ab97410c4d158fff32615adab0e313b69a18d033148ac6a61e63e6a54300fc6418bd326e30e428bd39c99d96d93f544bd5b21d5830e64e05848f9c726f6d5c6e76e16e6f3ad595ba76edac73a80b1f88f5146033bdb0deabeba32214fb9f7fe2b55a549ddfe3ebc0925d2683c4faf5d09d4ff2cb06157276903e10f2c8136ab2fa976c6fdadc3897a8bd16b7372825f2cd312e2f5ef476e67b0df659d88f6ad6894fb7eacf44f74dc652b436f2f98e1ced03b24e92efb728938c66fb2307be9bdd685ba9edcb6914fe45adea12515bb3002bb375b41b024aceec2c70e04bf4c987f980ce1b08d9003798b7c4a62ace46ea07047efe9de15c336bf6de1626bead96099ac98e6c2397b6213fab7fc2bf8d1e31fdb2ed075f9a6b3b1bb5334e0fd0437cecac0304a6f894bd8b48994bfe8c87be5de92acbe6fe14d1ba03834792a576fd8d9ffba33a117b57b0d45d9c2a16f336febc3fd38ac626b5bc3c81c571a856aec1ac68b4d5d6c1bb3965791f9c42c908b4218f06a003cd244f806a1a0c7201a82c4a95b0321f3dffe53ab2f1a809a25d38e4a5cbe73a7dd039f7c8b89d4b8c0edb9e044227c01c085105c1a623ad5d5f4cda77ceb04d2d7dbc5768e616eda81315858a46121cac76d273d7e8716f95581484c2612a6d0e0b7b63b85fa3a39afbc1dea65da30832af3b6c8c5a6e14da0f420d3e3357fb3437fff541bae24bc29401ab73b5b75c444af7560ac80724b8768b92681d193c6d71306b4ab5e581fab8809b86718c16990c1affe2b6c9f60ff7832c08bb7c7c5b227028099873f2761f3134a7b39badac678fbd1fc1ad84add2dc8e3df2e92c096c559130d5a7b05c9de05273ebf6cc2a27c135f14224e717d48de75e25a3cf8313d06f90897a3804d2e85e467a00e49a3cc9960351365dab3ee98b5e4adc9d1bbed369de00ef72f078239d2fbf233f7277b63c72d66d6e224264fcf887bcf0f29450a9cce6e49f739cdab1c1a8f62f1b048120c4c3682defe5c68879ffd18de814073f5da6dae6316bc260e179ccda3340d071ddb14714886a4cf9bb35d88a4eb83cc483716559b817aa2b2f84110b72c5e2e321d9162c415c22c8cb37d84c35a9316f9956104a3b5323b66644182a61ba628f4fdb44c41e7cb33446077adb220bc62948cd2b6d0439c49aa8ac44939329edd5c12a1d321eb8fb045de43f8b12dd6b0699500519aa74565e61d1584de5021a4eb6d2fbcee93c8b8d93f5a963ba63beadb4ee15bea7989c3e163e23ab7483d84f9c36302bd8015f82467cd9504c6cc2b076506a3c45863fc728be5abfbd5a0867bcff5f7b5f0f797b919de9c6a2b12a8a7cacf54113a7b5995338b8c3ab23625c1ec375dc630b2bf6b830903fd0078392ac2b0300eb802211151d735b60bd7f8342b66aadaf12fecf0688e71157048a61d0edd5f9efdc6726b43b32b393fcbbe177b7bc72443c60abe91267c092394afe9453ac9aed04f87737b3acbafb2f95b0d70bf94b8671ae3128f4f084395434c3045741c4c497d8465140e16707aec7b8c4cbadc7545089f3454f140890cfdcdbae998a15e6d8965b689bbd073c0c30ab81307b94f628940af3a2af01efa193a2ca5e13ce4363fc0c8f8d569d15950735033addf0261e753278673b7170957d2a76f8fdffa4b1b6eb55fe2c1db8dfc7902d691c079a531ac07804c1c194efb1dcdf069a079733d73124f5318f37bf30f53fd7e36fde1a497a3c2d27f276287d25d65fccaca06bdb0334706254c9a6ef81f93f74136f0471dcad518271a88372d47fb74b33fb9fad56b418cefce445a3278088e1e5573eb0348141c0af305f2d1072c78d594edb525947d846128420e2d0981df2c149edbd39eafca910aa9436c9dec4912f08cb45ca618fe20a932e8dff02c784332f05d6546c47b8a1e067c0718729fad1f171373de2798525df67d91e540dad1fd2d6174edef2158ac35f6acd7b7b703ed697e7e4eaa38cf9815af369561e2853d48ff213fe107391d35c9b307cf2ebf3cda999373c86ef86de82fc59bd05736c123c3e98e4ec6362e8393db1681a1a1e0a6abdbb9d8919710f635101443bd7114064a746e84e17a1569530b3fe0eb896880e542d4705a631e9535c8329d8088d58a88563f8fba81d9820bea07c6a0990d000024a7a2a8301cbc3e0b9525f49f7066d6453f17df60db512ad800adb79720e72a75b5ec50d618e7d0b12babf1903f6bb90e06d1e3d2dc47a899d232d1e3608424fbc2650ee201763ff9567df58f0925f19dc50cdf08fb964a9a4928164e2032f2399a3de0758db8aebca226e9970ed2e350f52c7e636cf1965e35f415b6cc30406e2025c23675542ea89f34885aa07455c7df0a7e95399dac0d36d55e4a33fb812afecaf9d5bfff51750240e9c53dafaabbeca3adf037e40a55afc0e6a169fcfc453f2950e90ff0a421490c0599ae45feb8dc732edcaa087c42789e15ebc448ff08666cc929f663e6fe6c490b7644ce8614b167f0b6a1aec56e6f8f39c9ef80226887857db386153d54ba9ac54c4ff87e423b4728a777d5a1707f43ffbfb69fb48f6ae1933dfbf49716a93e28da58c04d2394bcb08f37216ec9e611cd3976256495ceb94284dd1d17373fe4e9c30f11e5af4ea9ec6d48eb71104d4ab97a94962c1b57a4380dfe3e64935c3f3c45a1e7aacb1b4c16aa33e41203e4460dad1d157b006427e0374b546a04f65dcc347c185e97f8d1ff5f85fbca51506691240effce44ba9c6180900b94cd7f17f8a92cc306ed1912a676e16803eda30134b74f5d75e98a91ee9c39607ac1acfba630149e94a7bce7c6ca6596f5314e1e96b21fa2d2d832a91b1415bfbaa1f4a5739f8df819cfe92cc7a85dc8228d5c9813b1875217bc4582732cccc8762cb39539e5072c24401b5c1d8e445399132c5bb341f835401d352f14eca4c41545d3dc432fe4bc51705c3470adcfcb042d10521c7a72a6b5209ed67564082f7380ce388308abfa29961be5b022af32900cbef20daf6146c1dff9ff51785b8f0726f4581f5ee1c792acfc710fa18d2281b2582007228e4e095f24f935405d181b16bca2b067c3913541bb4e92251cf112eb8833a2ec17e6c30a7010cd428a4450140f656d419dfe0ee8c23da83036f7e1d3b7728128a55c4f3605a58b888685c76c5538badc6cfabd29e4b37be20bb0417d14a2598ac1b6570f2e1975081bd78e54690a54b240609f9bf46e86eac07777b4a6ee603b5a563dce84b4c6db624b41289c62c3d6113abf5748044cde86712934a37a285ee59b61ff55a4dc493905f3448d4fac368c1aa4bc1c57ca95373d3b72abfccbecaaa8a2bc301a893dae053f1ca940232ccb1a2b8c4bc60bb5b299354e0116136ffb7bbcb67436f7dfba6821584031b6dfe86d76dbd3c142d21dd1c53acb111d2b832bc9be5b2f32abc9e9585f04f594d27719049640f75175bd24a1c931ae18c51335a695d82aa905d94aacd2caac382720ef2ef5d71541df75afb8dba2e4cf9c3b9182e4d4ecf5c71ef57391dab24abd6cfc38ba009d0270d3efc82c4565e99ff99d66d5f8455d92457fc23471ba3ffa2d75d8866ab1592d76ebdd23f09e107187eb5dde78eaceee1ff8d4b049d0d3ee478ab94e155bddfc93c9449a928506aa7f0968889892cf677d4030ec43d4880b88dcc805afbb7c41090bb3156700c71513ae642060353980b95153c3732b33cbb0f1e3564b252ff68cb9378bfb978451e7667c3848dec179dffd8991ef60008dd98e733b702013b819e4046617c52816ff2d602099ee533305ed80f228cfcecbdfff6ba8effed532e4b220d6112059cc59d13ab3d1a97ee20c9c403ac024b464578f3c65ca863fce6d509023708237f2df77f6447b98c81114be26f79bbc95be3a1c469c1a0ce7c2092bbfcad05f5b1ce24980a598e19fb2a9abaceaa988ef6687eb624e52c6b7b519ef1918d704b3433a3c9ce536161a4d4abc2f8fafd86a784a77efc7fe558af481dd64593401ad0389875dfb0b2b30032464764ebb8734da551842d522752411bec6ae122fc38cd2efa9294aab7714b52ee3a7ed23ec2b4409993f60f54beae78a5295008146ce25c8423b28fff3a2feac8851c64d4bab53b757472585ab1bedb0809d504cc82f2d0d87452c83d9584b3ca0ca50f0ae8ea79834e9d9acca79ac90904e4817bcf80de3f9b2ed6833e6308b9d670b7eb3d1a9ac5f0212778dacffe2098cc2904fdaa80dbd33696a72c9630cce4d598055392f52bdafe98fcfe0e77fd7e735358a3af269bd9e5858b3c08bcc54a6c8ea3759af151db4e1f540f3c0274dd7af4bda83f2b5dad07f896cf5c9ca388d15c1df330a7de0bee0dc7a2a22ff1d70118175a355b06d1847fb74a979ec566ddca05690be95db5a9bb646e5cce7a81efb53d26767ad4248dd50046e109e159c56f787d4685f1a283a3b2443bc3a336e07e8e969c34366cc588d303ca85656cfd393de5e558ec5f0c7d5f8b0715242bbb0aa53943db607ac92c5d0e2ef1bccb4105c7f66b5078aaa4465ad880e8bbf76648bf96c38b1bbb9a576daa3a9087b5377c11da64219d11243501fc42d10d20be10f4c8528f7b15500fe1362e80ae87671c4d625be2185c963796df97185c8934bc2e586478dc592ff9e1a74c828bda3ebf73a3f1784e15b8f3f7a9164d488116e2276aedd2803bd0da52c394f8771d220df04e651944dfd3577d70bd428798d7a93853a9a037011c8f3b4490f1a00394f611b858a271ab174a26867cb0ac955564586584cfe7f2d8279a70421dfe6de5481699fbb78eebf7efe998b29eec85cf2f070fff1223dc7d6cb8eea2ae3435295373848b51a320db14961a366f0e7cdbaf7836880004ad27461c853aece955dd5140cbe23c517fc73e638fbb986b5c669f37c2b60f28603ff35ec3b7d38c347066ba58c52a70d10c851beb481d13ddb93ab9060cc268a3737aa360cafa2a66ad2b6eed0642c4291404a1e4570ff07b434fb4190a10fa2d89322ed9d35c23e5923c0081291d0ca31d40bda283610846c711e0ab58694d15343eb0401d081068cfa1a468f79ec1cdba78c57cfd94a0a8fc721af4cef2641421626bfbb196647c9306efd33ea7eb1ab9de4651fb8c31a7edb77c45e1a31dcb7a0460f69f718f1e9dd117ffee84f5ab1d0b32c4be0ef4a0edeb87b092bf20ebe532e8af7262810eb575d54e3a2fe812d875588c4c1f590a41aff940698637ef6a7957ae351cf90db412553240e93205d11db1ed581cf777d2bc9972eb734bdb4b6fd462c4986b7c9f6aa97d654d10dfeb7b59f095162a579a6b5fe0b55dc54b87b73061f6485d232c6a600f26a94c417b7541604f2c2b1acf3a3ee1f7acc64022ca20e27396e5732cf0601cd2652714b63084d93cd04fa8b2bd6abd785b0341004b8bd2c4fee033757d97779762abbdb4409e529be43343765f230cbed6f5acba6534d90ca7f5f16a99351f5fddeb84767c9455ea36a7cbe9cdd39075a70d9b075f2ad82f860bf7dc29d7c0ec8d3f5cbddfc0b78bfe633a3822664aa40edeb5c75d780993953999f4558dc5d096781f0b16c2665633aa994f723009647f12f60d9d4664e547015c64501d1cbc512655c549d7e093771c7dd9008c16b31baf7a23b4cb3fe50df4baad3b9d10c1dee1bd0297dd951ee9589f5dc1fce3a7608adc0ff2b7779a19ca90654ff0d4e7eb44bdb02643f444bf03a52bf1dcb0169a600a57d43cbff0b79250d42c68a8369e8e72f293fe4cc7f16344a74460573c3366d5dc8c6b468c6e634e4a88303346232d7a46a4c2fe01f3cb8ecfcae627dfe988ee3ed517771e36400137294ad617926c0604cf2a20b342c60541ded33ba80177e97200e386e4aedb22b38b5cebce564abb2088f2af98a427540d014d81859e3a236628a46f1e443d5bfbbf5f5c02b4903f632a245c8beafbabcf378c12ebbd3c0665b01db5ebbfaf95a2ddb23825fdf270183d8a348c3f858fd4b778399218c87e648ce24169dc9debd66b93bfc90ce94214d5b089615338509abeb5af51aefb194c6785e1551521202a23d597a4a132ea307d7b04988ca5d8b21514ddf8ad4e222e95ff04e43dc867964c369a989485b61f34885cac253efdfa4d331a3f71e1c55472452ab5144a0a6b3e66942d11ef3437864d97133ce141fe711b7d974848c8871c5dfc6cad4c6cd402687656378cea85726d53c32eda0df3e04350dcf9bb090725711ba6f0f717852a8129f1b48935771bb6b85b6b87d4b381b706c3b23cba2b78ac5716ceb40d5d4e400380ca91c44ba6bb230c4c62dd3b80d094ad2b2b57002ea3f221db51b671083be6afac766fa3550258bb01d04d67ed2d90950e6e2f883683a60cda2c9dbc69c50972e5d2896639ff96b33c5e4f3529bdf141750bb0d56cf415e1a94cb8f15aa237dc1b99878167499ca253f92a11e7f26712e36a74ecaaf49e448d0567db9e1dbd095aa20fe50eb12338da08d794ccf3966dd857c9d79ba5843595b47bdf0b914af6516bc81251a6f20b0d81fa3af2aa01227401a49233dc9ec8b7909a192a004ee06a84204f1562c34b014bea92473f5d9903275958624037b3cc998b374e30504172554a4c121d0092745af183cdd06e7501cb50e8c8237d073170bb1b714848c4b5936b6e837fabf80d04438be2f59e223284eeaf7ac67f03e394b4fbe1540c3ce697c4098e35ca84e2881a7b8da653ae142679098a0d74146fd7f83f90782ffc08f86fccfe06b67064ab2a37d0152f9d2e558ad0547e73f919fa6a92d69e43d98681c8a7878c51fa98b668b8bb9f970ee71f6c41fc77933a6f8d86ba430b7c02efdfd78a44f821be49ac7e31e09ef2a038823d338071c5ef34b9e82ef204b2c108d99a3c19edc3ebec02ce3873ba6684e9d5a9d265c86ba03749e3546ca00c89a4dfc3a37fb054887211bcdfbfcf6918aae6fb85ca6ecce58935cf666961a0ed755f8cbfccc9c5e0730069203854227b2608c4cfe1b0dfe92bb6208e0cb0d0e5e6e28dcbb13da00ba28370b56233bd21f06861a48d84ce65d6cd0dbbd19cb428e4cf0d0e6838454e98b40f60b460d5b3f27d2cd30a60e775a9c6bb4222efd7e7fdeed3333c6faa73fc3f7c3fab9f95ad32cd8f050a9522c095ef29644effb376b9c0580ac3eaa6af78c8d8f1e8fecf94574f313716010eba39d506a563855066af63514ecc1c78287f2d9366f55f58cb161e5a7e15364492d22d4877b02519d6e82c276242b2858af3810a50b7cb9ad7b40b1bf2974a1cd082f403fa6c7daac577572ecca09a38b85ee085cac40f06837bfee976641572adc328e570e504ce16c5eebc0bad439aca98d5ff4af016ea7a144a28eccb5560b04d4b5f8ebabb8bd3ceb17cd65c283e5f2b6a98b4a89b569c60dbcd71ad20afa76c7020c3ee5fee79b20c7c9701595b48077e30602f521b79bb404ef0a8d6e96021cd21e125e496185fcb5b4b7cc296a6f02d2a0426772eaf983b5edced956526a5a985041a6c91f6dcd1d9bc118d9b2dd4d2fd224429c4dc033174006f62735a46a723187b71005f10c2c53fa2b7e054cf13ca26447721702dcf347d0a4153a3d131c5f044b116798d58a788fdbc79ec791dd91d706fc7ff0861ffb605a5934462e667a1a5547c9e6617a9ac2a53dadf4c54c34769a224e698125b01e370403fdfc21096a63a5071080a97cdf0c22e94bb8ee0ff9458320379cf1694816ba9231bc3298921b55251531a40239033badc78d4451edaa73555bae68be92b58b15b8c04b1a0ea3f2be9de523973f706ea072b6c17a087a4e046b8c2d66ad65c069a690cd6c1e666c73838b57b4e62214016eeda80f20f45f7f9e9b6438df470ab51c90e4699b548d5e0650ac8e081a91315fbbae6939e03476407c998970b0e69599e3a72ee98e4c1d6d7e63acec98ef05c687b9d64010cc48d30a57e16d01a94a1f1236be80442b3f386c83fa4afcd8e54c7e42794fa8dc8dc9d0926b3b7bfb1834c0adb9e13b9a9151c18f9c03b7f616350a8dda8fc37ca696edcce9cba5a7df456fec726e70ea5b6959f315de104cb8aa6b1bd84eb7f1c8940816e61564659b3c5ec3b7f1261a10bf54c4865d294df1e73509e6be385753fc3b6533f48df53fcbd38e45b8b571f761c0e445581d4cda9f06ad3bf8dc7748e1200f60531f60b1335495b2a9ed57b44f2682069df117391ed9b178bdd7d18cbfd6ec26608bd625b63bf80d1e72570de4789535ff3f3bf97d958fd2fa6418bbd1eb2e822b2432c321974488973f92d238cf51f242390f1c1c63a13a6b1895adcb7ccf703782ec9a5fbdf73de2d1407cc293bfc34b7b5b73c9713e86fe27891c1e1d373c1f2e38e29ff650ebf7c3d0f9b20bb5a7b5ff9f42f41fe0d787f8e922b2b5da7aa53c74675efa6fdff942c3db8c0c0dc50e05f4e55019f8cd780c7213e0c5c6eab77acbc0a80c8ce1d63e0649c195cc75332a1c102699f8efdc13501c20a5f047e159b1bdae573a97c2a82dc9601ae275e1ebba4c9cfc3413b2fd4a7e0e08a08945b2943870e5c06350d49b72b7817374405692a1d007e4363e505b999603ee5c8742a6793aa4bcaba9f3b03edfd21bef5405d7259f449fa6633166d2cc36e7517b35479a90ef6e59ddd24c3e5126c65ffb2fddd8d4fd7ee0f7b453c01e22015c01a79bd0767b7878fe5f3bcc291dc63c54e2212a7cfc75b6a2c62c4cd35d9f1df66e43fb4bf56405cea0610b1a7cf964220f767beb67c812cc466c0804146faa9f2adbee336aab12e3b46bd2d366c882d003db2d23451984cde83e140ae05599d6c567b484c0df2e999c26601d55d621993391b3a5cdfdcef40ea605a5cbd310f3c5fac83e4cfcbb4044c199a7e415f1f29c7ab9b542d7814bc2cc12a47bd178a6f4b7e8c3d258d6776a1a35b9fcc7f07feed05f93cd191248895046cf4a8d9fe1448bc43c4d1090a7cbf63117a7d3770bc6e56254a14f104d883bce0f10edadfb7643114cc66e288d3f275d01adb3aa7761072379e0a5e539bdfcb538072e38dc228ff034b2891c240dd24df97d4711a34bca85c15cbd7060363f7a5aec34b8920d026948735af4560d013b26a4ff4778bdf370a799a9664c2f9be2e4cfbd34b971a117bbf16d11e26ea5dc131ee6d0735a30dd24abb3fd60b2e112569283973f80c35ad59c4880b627008bd1a4fa2a8fab0ed27a2576f704d95eedcdd369c394175652824f85dbb27d9d29c356a8065888e348200e213cc1bd6844813616f894d772231b0317d9162eb8b27227174d5dcd468109d208ee167e5b9da3831ca42b56c53350c82ffe56e3467a0d6ef4a2a43897b2c1320d7f36e6e951f9fc6837d486b6c9c2bddf0eb4e2b4f8c5384e6ebcbba7ae07e03e983d056c70bd31821d9a937a118ce5be5a114fec3db773065636520c2cb32af2fd759749b1fa29471e791ce1cb80ad78ddf5741588084c73bbf44c77f3eb21f6f00007884b47af338dc04fdada07638f23262d32f26d59145fc58dd46ad04c112bfacf6ece07f6be4a64789a68997b27216c6b87383d38dd44d8ff48d7a40354f7386776fd74a1912d4f6a0005aacd9fe50da6caf1b17599d1a47966c513a71f629c81f352536ed84b9f2f11f95330837fa9b070d3e39d9367626776eba0ac8154e0ede23424460b0778ec32faf5ef5d24a289c9d637f04ffed048c68e3ae91d46d5ddfd44ac2db0d756623041ab56c164493e0bba6f2813aa5b6c7d5d0a4278f1bfdf8a50e4e6b0025edd426e240375d58dd3f170efc7f28a3b0a845ef703255ac118dfa05e7be5faf37fef733b81c8901ca21e8fd429c9bad8eacb62a853645f085221b932d440d90de126109949816ad9d24096fd0765c295ca84e9a5c55d3a4d26df8cd3fce49efdc79fa61f61de4e33dcbcec1d295966bbccd01e71562e1ad9475e7aa811645f2588e1655c72fd070f98563b9bd1ba3a787edf7fc73c50d05d9d5cc12c4318f562273f437d98bfcfcd97820e0a628a0b4e9264357067f9e698f44f8bf88ad946fb7b44bdb7004e3f555b94f86f52a3bd787498364c0bfeda207140b980c10f840bfc3f70df41c108f98f9117066ee21b1533ca174b9b61910030ec9f677ac52b97d29788db2541a38f7ca92f3159eadcd8a8a7f9c0390acf9919bbe705b4d30a1c0cb2cb138fef8b4e608d8a179ed575eda9cffff156db618f3d0a438948d8bdc645eea1d74b4179b834f8c5df80c4a3c9f0bbf8f9e13a820907506157636a564035934bc29420b163db1f30dee3789cb3a264c72b25541ee74bba53b9012f54e35c96ef931944f4e0381a253f1cccd84a804a2ebe246be815b5e55512ca43331abf10dfc316cf06b7039eb553032c6b6379e52ebfc9a68361a042028813f5471a809a7e3a37590ab1982f8e721bb220d7fcd45a8d397e3c6e8c1830f36b3b501314a79684e2372b80764d23dc231c47ff6ff4b34b96811e042bfe902aa33e60a0aa3cb274f0355171db7082c9260ddaeb2eb703f8477ad0d2a463f588b399d546ab49edc0d077febdcea61ced15e08cad153a3595babe861764480f960a01b3690599ab9e05f904e41377b292aa5e80ed7131c05de2bf29ca0300d0a6bad80875839d975b55ba7ecdfc603bcf3754c462695acf0e99921912aaf502f1b6a5d0e856dd2d4fb4898151a841e4f52fd0bc0483f23fa3ec077f2661821cebcef36a02fbfa04ef39464a8f7779fadbd27b68c38f2d62e6a871aaa000edf43dce56f86427eb36628c99f9b422660a223a4235e2bc536348f1b86323948250cf36498f4e1d85b66b209544320c7aefdaa9744fcb9241cd0a6a0341b755e73e4d0e3f5e0799582317366e7b36b2d313ee904f0127ba51c062e6c547556ccc7cc5b8aa6baa6b785d4a0edeab61a05116f09c7e1cdb4e73b9cb9dca049c9b9b8282489dc29ab583939dc40b9978a1a39cff18a972f37030ec370977d8ece25bcbebac67cb605d73ca7cab67d0a9c004f99f97038d4f0b276552e39193d6da92b0f66a1fc6e10390228693f6c85ca769e1da6001deb1ece25f4ff093b4105477a62cd7380145f23d5c418495010f80f83f289394f78b80b8a2cafbdbc45ebb4bb1d37c78d8ac0625df8d8eb3f982177cad29aa6595564446e379350e2db74057a511391216bcfcb0d7c227a3564a2e1ad48907dce52ef2de53b72987da3184822e56f0b954b2cfcf9a3f71542e69faf1ebcc3e2660a101fe13069d6ce0d88310d6417f0f084ec6f1a371458e7b2e5e1c129ed03df97a6f9af41d177673889f299dcbf0bcd326084cef96a1c7260e2a9afa433b34c1e9445895988f1aecb066487e1b62f79e3073b513914be981a9591738cc0f3b85d7d560fb15518e5c0b59048733c2747e3982414ef6d09fcba598a671adeeb7d5100426e703d604a5674dcde27efde14a2f4695ae044c5b64c6bf881dab4c7e13bb4e6267361db4ef7a2710d4e80f7cc215e5dc352768da100b0acd383808ed2604871d88258a418b54017c0b18914fc4f390b64b0868a3d202e0dafed72da5563254c254b3e819fd4a40cd2c8f94de5b96ce733ea9f7e5cc5df2d8b6e273a60339818aa671c123dfb303c660a6479dcef3bd4feab161d0e85ddbf91f1faf4a7fab402afea7082d48fb721775f7b8f1e5eaadae33ea68f10e785d140939ac3f8ac3c6062ae3f4469e9412223eee403ce0c0f114588bba5816c646f36057703789181e283924ba49cb060d781fda963e0cc7f6ffa364bbdb5d9601d09aef6f10f80731da561cfe79a0ebb232cfc0681ad4eded5f76d72b7042f9d3d23ae7e73bddbe5ccc2c6e2fcf9dc3a5e58ce61b6dd1f913d7d2979354500ef8f967e7df417da3c6fdb6d6b98c7eebc510a3ad5cadaa28003518487165c090bcd63138b51e937138cbf18354a0b56825e263ebca98059ba4047a798715e8c846c0b912a2c33c3a51eab6e66253b5ddba8655dcd1096798655d69c2d343615acb768c1ab1e672655dd48c3c864756b2b482f8a4bfb5815450e8a1a40bab16bb35a043a1433e141e2d597c38ca758c42bb7f02b97996ee14c55128bd2f746e1a4284743e004e41b40cb1a730c7d699b4bc45af40a41c1c5041db16d216dfb541dece2730f69a8e216bf655d07f07611dd46298b6e80dc306a09a5d41257eaca018f3330e24c89736ffe4d6ea484be921023dca896e0650aea68da4bf58cfb585abefd636ddf022951bc686b25fd4332b86af4829381955394d8e07b8f283045c3cf471b800dac39c6a1282117f54471e6c5e3bec26d9a280ae24ad7b8783a1a0235c0aaa3e3f470b7799cf6e3079a03a9d11be99df45847208d89597105803e59cd7a5f932024991dffa424110442b910dc8bcc155787ec081dd5c276bd664b9b9fde960ef2dc60d70179862eb3726f74e150965895559c1f1d2b35fc5f44eca380eb62a8d1c5a346b50170d5c854f92750366fcbc2c19c4a85f2cb96725d4d28d226e793c115f66dbfc47b8b4fc75c69c075c2d2e839a869d852f37853ea95e971b97e47a710a7f219c3ad9fb6553cd17715558dae6aceda70fc0e212a7cd79e64e4f3aafe6354f2979523bbaea98606b7ae280e6d7e9360c30b7d909cbc177ab8839a11f5ccb439a91118ff49ab607295877c521a32c8344f6b5642582ae4fe71427956743aa61d69deff92dec92f6b06fefaf7f384cc82d10a17329c22d399d071ba9634c99a1f6a2ca8ec93e279bae1a1b0b20520fc04db1c25110b5d3c2a3ed9e68827c67f9c39bf4da839007b0f6b4d8570cb54d69037dbb3ffd56b5ee8ca6f9f1aa73b9b4b6ddb21fa4aeade60d90bcc12699b54d8c05d00a1632468b839a100b65261bf275454b7fead1aef395ec783a70f28b66161fcb371cfc093f6884d23dec532e39a5c219a9884b7eac119d29da9be06bfe95060b20bc00e701f8e33c8e6eb8de2ce0befc67217127efb1fe44a0031e6c54f356cb40a55803de492a4332a12efc3f952ab7fbd58235c630cbd62c475be4169a3b829904de22598f37ab4db9ed0cc8dce21d3fda158cb3c4051d34cc0b974f3ebeee84a22b0d9914762725a94d9478064216ad82bede2f51223a3f243a56b81e76a108715df190efe5458c06ca9df08c25e3d360f6cb37a0db199224cf23e429c121cd90548d950e29500bc22d094e7de6a3251163871bb1c76c8dbb1c3e8a9bffe9e4137c31b9e60351bf163bde199916ce6832b0e6eebad9699e2795d97e1dd95f055405846de9","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
