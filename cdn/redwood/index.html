<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"898f4cd77f0b204dadc2dd4503595869cbe64b418dbc8a2024febaf4e533a4108dc84b6472d5bf403dd40e0d6c66364e52ac638ecdca4f380b07e03299adb1bbe27b6cbca7d0126a38389f7f0003bd0eda9b94234677a4a48bf72f7567fd3ecefb76ce3ba5eebab60c6266f365b6e01ea1c82d3c4b1f25569c19f3cce5f9714b868ba9b126779bf235137b541a8760dcc0716807c017c0245da59243b126940c4962c05525974a83eacf2270c1ac20fc33978200263e2ec37ca39448f41e98af5edd93ee60a82df850f8eeedc4ea2f5aed6eab84aab44d8e83170e98b106192283745f360ada086a43c585cc981682b754d2d03ea2dffefa7a24d370918f49d47caf6627b7a6cde6f83e1dc31c1cd3a060580a8fd8beab0c3c580b10d01188a1952852e5f8244500a9f3532c8ec6fb9e689f98a87a02bf3537a626aaba76bb93591e2a5edffde5c273c16dcf193aa0f0ec3813ea6ad1724945e1b4594aae4869fb484fc5ce15a5f3c4d57489fc76558801157073c8f067034f1ee4e975a6482beabb395eb97ed4f00a3ea0508aa54f485146f0430707dfbb5dfa7dbdbb7ded03e394314b3d3eebc0bef4e4984d53c6b2b7e5f25019389ae6ff0246eeb42a1ce35c9fd06d1e4e08ccfdf6f60812119221d3d8002ca29385824928b53b4ac40b0b70263b12c778869c7b57dfc6dd03645c63c46b851ddae5201b3cc99bb650dbbc054368709b6d4a5ccb2aedf2780582506e10f7fb7c3b37ee6c8f68083d8161163757791198b52f854ac37ffa6f62209b6ce2976cee3cec6b06c807e2a9fb56ff72f63f9162409155875a0827ac3905f070693da5eb52be8d8513c269fd3f041925a75ce947b6a22f7b1ac3db393c090789c393ec6e849dc87da6ba8fb5a3c0721982efa56fda5b6d30ad136e974b17bb3fce45a45207c6629384fce06a08b927bce4aadaa4c93d677d9c21e398ae4a933160c9e4cc2601805ea6fe568487f38619600a3e0ed6a5d1d2b3003ffd4867faa00b0f4d388ba74eac2fbaea5dcd13e61332236d567a96bffd685ab2cabf23c886dd64822b670d0ac9899901693fca9ec1027bb2e38ec3e165165023166f553ce3816d865610b00aba061bf56e636b59878a7b0948b222378b1591b06951d0e310f9a916668becc5cb0180885aa8ebf7417427b53c348d8614b69aaf6dc9e9cd658ac90ede0943e0a33d82976d11feef637506076456ef0673ad8d479107cfb099d951c6ea5f661cf36766a680fe294c5b0f61adea93a083758df49e9605d2c95db63b8ffda10a46d9fa601148c2eca72ce2de35423c3344272e7faca4e4fe5e073fceb8769f6dda34cbb973dd7f789a5e6acf10ef66a84757484561659c00127ceb4b728e900ed6b4598c72fc6c198795f9b9a4a766811a68a223cd94a2c25f98a0aa93ef5b612e8d8eccc81e8ade033941536346d415781b0521e2eba1bd846cf2d627b759dd5214bca19745b2ce355b45dfba6202b1272911d8e807b74178564adc316f720ba1dbce9d27c6462ac44e227cdfd3c051a7873d9a80f1ba35c455d1bb3cff8cfa2ebd2c168b2b2f7c7e394d103c75775d6ae6e68ba8686e30c770baf519189363886c68544941024916e6dbd62173c4888e222c0db31c73c4688e798cb0d060b75a32602b7d151ff9e0af55e52665d49d11a8f734d5482af4481d499be3acbca89c53320457e9092e21e02e63716941e284184c2c800d5aaaf9b16a36054ff9da3ccb3a49997cb16131579a7b0657c2e28cbc6b668ea4fa9b2e1579f6dca12b1022e1a4de65bc23c80d3394fb8199d74117abd75beee12b09e343eb9162b8fd2bfc25d47f4e0ea027ce1588c204ca8a4b3c5fa996d1cf3ba62a949f71175b07ae287a5e3d4b253dc3d78872d715b998cc7dd30eedb65b58b6351a75159f0bde499fd8ea1d7a51f364ada99522267496472f47ab0a44d3e055a604d3048d244ac60010f8de13601bb7ab3f520554f6e0df14526765dd6d267ea1e23168e636da0a5374fce5550f1a5f20a498024bbdba41759af40f8bf2ba45e91f5b12b28e84e5a4155ddfce5614221e051d355e8780c3525560093dc385b8eff8fa154ec320dab36378ccb6a664af23c2e4e3596e45e72e2b0e9b1b1d76ebafb9dc1a9610b38aecd8d2af6c53489743140257b0fb4c25812210c20d415145e3b27f2d2cbc601a0cb317c7b6b763d8b4afb083b92400262bd8174df5957a00412e7b0fddc63a6bc6b7217de4d9c95099bbb325f5548d5dab430dc13cfcd2be7204c95842f52307774d1b25b1d508be7c0126571a720aef80be5f6748f6c3c0f52c349ea8ab71489ea33969ddfcc66a1bcb913b6e47ffec241918ca1a9ffe082fed12a8c4f539a363e6ded77bc5425aeca3fbfb4a00e3283ea08f0fed0f48a8d14df57c6833ffe043b8fb7768ea2887109a5eea7c3ef15a37b9c486b18b3a94bf36342305009d724c387860d513985199f82695e0a80bed1b7bf46ad59f846a1a53988a699704947fa30512df772cb3fc3e988189d4fa384d18dd7934f02dfb17fabc3934c0d11fc45f18981c5536a5645325570634770dac8fc61ff8f7b380465c48870935667bbe5f0ca18d3d204f676ff55f1496d9579e165af9333ac0939b591ca33c96c737245739fc5b65c7eefd7e3d9cd6dff294101f78d647dbb32830fa5050dca98d7651e1af34bf8cbac0832abf650f23ddc010985ed7b0a09df67268481553d13bb8728b4182b98832de95cd537fb20085d0c187b8994033cdb7dc1ba9b0700ca76745fc5bafc7022dad919e92743448ef920a7b03e921a7396fdd378a241bb151329ba0a54063d45702114ef0aa04c8c2dce54fc9f78033ff6dbef2c90fcf4a3c36594bba1689bf136be874cd7a2640df2b03b22e55b893e4d85879fc661adb5c50b38202fad34921253a55ede4d407ff351e9efd4c6f221be4787e4da7e8bedde62b946cfdf24a2c7329bc36892c257c755c2791674e26fe10bc27e1ccfcaabbd512cf1bf666117197d42f27007e955a01b56b510660955e697aaf42426f899d39f8d557c35701db8f1d86f729d0e415998ef60a23fca1eb3c7ca91acd238961cb3bef8fba865e2b1419bba40e016ca5d91ab00958606e1640d381688b0c36ecabbdef91a69154bc5799f9ffe5614967dffef7c949db016267f20fa3fc281d1f7152db44269e73fb463c3ab4ce3a4501f14feecc827ec8da6d21950b55933caf745c84eeb0ce5cf7d276c397c4e6f9850dc50626a7b534c317886e5b61ce77c7823fd7ddbad41eeb601c7aa989379c9039f5eba62ee1653fa137d603d50703700f1dfa2b4e8ac914e054be732b23329853d76c59a954b5f4a0e5837f0a96fef2799932e5abfb38b71042b76cd20df7f9c93d8ebf9dff6fcc5292ab763b71b9b18b084927cddbc9c1148216efc09f379cbd2e569aa7de132a40c70c077f6bbd72f0d187642b5838b99f86d31d1aebc6ea0480d65252de120a34ce23a42ab421e388ace8327ec3d5c3d0fa8b1fd6dbca1956afe2f623f53601efd044efe84fb5de785e40d7b564262955449a723291612210e171a04e89ce8598b39a3babe9cc0e1c88f3f4941c5d5808ea23a795a92a2ca5bb47b594920312e30f120ebc0b88d5d10aa9ea214e079a615acef0386af2b289f89fd20168a7e7d3660fa5536e3883381cbf477ffc33ad90b2faa0ec87d006b31e3af39a246adfd075e3c31ab0341679c06b08f6fa0e50aaa5dde6269d0b7ba91b960e7b7d0712e8f0f5358170aca5f01ed50cd81c3e87fdc6ce6b8983f10150e343257015ad30ead9eeffe5982cd91987f85f85eea70aa23f5917a34797e377c6f452a0f62ab1d00e18e3d54ad56397d8bfd9973f3255d16a72cda11956d9f998d3043f5f81ce50e8fa4470feb94b0c54db9bdf8c62430e51ee7669476d90a100181d506894f27172a40f3514532076ecbee70f21143076632cd311d69b78127570da03cce8c0828f1f95b923eebfbe42cd929d4ab60985c24ac47568894fd19aabef7de5d2be1c49a7f242ebb73739c189d7eb9ffe16b7794b4667ddb379d0409b59811c9b2ee0a075e20764c662c4d3d7c7fac348e6be02c173e827ad373e6e289e4dcdc6835ea0fb3a85b5c59b9132a961365653d0ef35ad5cade764ff69f782399dd5055ad17a2e24e2c4b316f5f5e7afefe8fa4eb6132cbe8f0bbea9742e8f5080a90971893297f82e32328f4027723e6b6af21dee9c6d7d037cae89e24852063269037156d0dec5a9b43096f870f7db9c978444edaa3fa13d417a6057d304d9d8d538ef54d7b152ba47e424ea199db090583bf823bbc2c8515684d7c5cbc3397b07cd1755c3a0259b0ddb65ff472ed9d267312833fa851715b7790cbf8428bd5410ec5511cf3df691a3aa3dc27c7e93f93abbc946b3524fc9c095adac9acfc15f2ecaaeda02f507960029a85785fb35980c75eccd193b0b2d469d81e1c233aa305b417e7a8bfcd69c082d91feecc1ba6b706b85c6eccbd3b5005e146f4d842e32ddd8a161d841b69e1ea2a7849b93997727917071fd3bf20136ac36743361303ae312691e27a794c64d5a6ce351c0f1cc605d92754e0a5c8ce29b931cff9d3ec68e1a0bbc0351126a25aa2332950a3d70371b96e3da1f86bcba7e99ab6f98b3d9da32704a286143c36d6d4ccb3dc55fcc5a3cf3ff396e41c0546634131b6877efaa5e7edd505dd72b3efaffdf114a8fc725e83aa31b7505c26ddf2b5d1d907cd92e5c01c9bde683fbfb454954341f45dced24ef78c2f2e5497797a18ff47a982a1f276c6667e7de3ca2fbc7d3e1e0e273d347d11d43e1a024bc8c4b75f01b1dd16aa7df856175eb7d721a433a57c0f19845c5a490f8132f887e8c8e25bfa45cb851da12afbe376f9e34db80957e79a4ce18c190e889783e62cae49a619fc54ff30a38d7a5c8bb16ee5853e0269a736d0c1dbf7c9049addcb22be5a2a36601e01a4eab42a6e0c7afd8a3f37824f1b9632a68f59e5878f4d056d7de350238ee3671a8a0ba445bb5a9182ab9a3f256f941844a3f043f84bb936fcae3a9f6da31e99259ba404113546f99102c7c5b693c4e8c6f392ef2d73e474e674d30c441c45e76df0583ffbfa7f306a5489ba24482eea150471650908c9959eb8c39763f3f42ea72f5ff77f29ca544f80fdf3112562e0ecac1bc2b3d4956785da4eabce555100548128a57601a85b758a89a021e27abd34689067b0f72019a6cf538913eefc2c32137d89df2883c041aba47b81ee76f933c8b0676d2dacf5e3fc99fb620f218d9b089c751027664af51869df3b6ff7cb95f788bae556de9833176e6b506b5f1f606dde0076a83664e085ea3df6cf10d4ddc716ba20cc496175305f7f356b06bd02a951ff558eb5b75dda59444976191a5734ae3d250c4782c4c198f210f05e570200e48e912a652b065c60e854de6773b39b5d944cd1c8e0a66a954fb452ae464c417faa42a97167112f3c03c592fcfa1b3851ce87182e63a094b59beddeb37da491b6b3b478faed80a0b154bb950696b9fd94828d1908e5b142b11d15a36b35c45c60647ec41961761499e4e148c5be81199e6280f5bde000bd666b171a07f928765836a73a845a78d6187658a83e7e31bd7b2993eef52a07d479a42396df99959a23d07d5c90f4b1f09be1ba4bdd72345f4cf75f4733d9d6ede08b9eae0b2eff9af04931497b489449d72a6d3ef68caff9a3b96899420859cf8eb22a42b81468d74469b6520b774a8d881120820c1f2c071ca6e734183bd881f677d2ead820e163b297a82926bb2b4a9836b86575fe97bcd5d66ba0514c121eb36af3ce8a8a699647d5a97de3b97bd9f09601e20345d0d3109e68af4331953307a624155c4be218f274b90838b81bce44c3e0c144d639e7dc1a223ea7efd17ab112053ebb0eca29780400344f9417356571cf82e9d052066d1b3b2eb6df0966550128083d4682c1f27e4c38b80a1d97e5a90e94f742e30e4dc48cdb1ae0ab5fc37a6a719c26ab33ae089c8a714dfc03a0e4edc1d19f4500e84fd263c24f0e0cd8de1f74c4d874ac9474356d4be83d2515517cbf6932198522dadef7ae6b71c5f2f0f3fe30fd500b32658f6756d7da317ad17b748708e2918b7e073cc0a2a79d77d4618c1d1e9674504c30b2bb3248d54e7ed95085a8d55cf75e2f66d796670efb00d349fbd2f0d5fc11ea1564cd6a8bc33b2840be201dd653d025a64615fb262acf9afa317132aa582a5ed21d2db92a034601ece408f634def055177f0eba553d40b86e2152337467a668c687991cc94280adf6c92bf927e21cb0bd9f02fb1da8f9b3a6feb1f2e422c686951cdfbe7de641c0ec58624c17ef6e37e8dc333f79d5d5572fcf5a9deb01b02f90ae0f96c4beed29f832c761188c279f7cd17166209b6d1642b9bed7563e28ccbf5f85d17f11a92980d76cc200373c09354e87d6016ae06cf2b92a15f5260285871a2d5b82a9527a1701e15ceb24bc79535db9ccfbaf50d8257cd63677c10cf94691e42ecb2259c4c41e5d940a443cd07122ecc062690dff60019dfcb58a1cd25ff98f3fc80cdf01c77fe9c1d85660514a62e1a5756b54910dcb44ff64121e57a92dc4beec2dfd2efa9366b9638c4358f34cb068813b438d93e26378f1f2e6605162fccff215e1f53bc4ced38637407fd2c91850d4546498f0c35e662959d8d27935a4414a0c1fbafd8a37b01018a08c2f9b56b7ba2a75d764404c466a3a6502bb14b705e911d86838ff12bcd0d452dc0ebd7e852acf027bb0da332ee3bfbe9f6b079b64678a2e05bd4e79c53d4ef44a24aaeb5bb3c117a88bd8a43c6cb6749fe9e711d17d17800dacd807f9de31998a612e95ffd3d25d989782df4c3d461e55311a478da29868d848dd24b4d614c9212b40d7d6569ef67de9306ff2f0cda8bdb10c54489066ff4a88bad1d739b50957769cf93d2be770ce53136bb77d197a54872a98b3b646ed77c72f56893239f98afa91fde5240c71b9d533f9e5fe5dc0c2be8b11362b13733b4b3fab03921443f7a03a600e1189b3ddb8bb48c902ad76cd5b00fb0411921cdf5077b562d2db367d77acd5ff4332829b5f1d03473be4f68c082c9dad06ce83b9ba1498b902a6fc610cff38e870eaf98cd218d9cb2c2fb5e0be40c18b50b5685b4a65a9fb41b7a849cf77b7b9d03cf26f74a67feb2c9e3195051b2cf3a426a7aa46d40aac8d36bca710aeb9b7d9aed84bfc53d23986b62b0722f301f73e82550f8882a583202895487fdb340d13ea6fe55a1a50d4f5f39a0f505ff55644f5dda89c91c6a532d0a8b02f3b1492f5c03fd0b468fc75b27658b7daabfea70657f48fd7b4e44e5873de557395ec68904068888a8af0a792b33293f2bb68c1e8cdc28fc2e92b36cbe5b04171a02a4bc604205a708cdfda4bc9824373ad99a9f78ff1f6d1c366bca5bfdcc33e618064dd6025a66cfcb7e634adc31addf158ac47dd3b469ac3121b748743d664cda0a39a1604db15f8af9a54bb41e3ad96aa5accbf9cbe80af03a9bab60a2231844e8fdf131dbb999383cc73a413fe30405e2f3de830a9a723c6615828dafd839aff9263bf2423f1a92347256ac8a9ecd4153815062dbe0ad3fb8a156329b8adec19771f2f9671fad942a36b57f0683683f32816f880bd83dfcfc4072bc092017484695bdc7fd1c84ff3d6b5abb9bb0a57be6a4f311cebf8b5cba9db8ee1f0e14a8732ab6560add105323b83089e7039b4e3e5eb0b9fac071c6a64b0d7d621669b6242412a30d6710971eb4a9a59fffcf475fe4490db7931c965de0f839109af7bab12172af5da5ee0725fa1f4e9432533a5c9abd5522d51e6e333f82c8dd7903c78f726c86fc6c5b37fc4a41a74fc1887e3d3ee57e641f5fc98b8f77c37aba7bef66a82fd5c64e5dd5f04205cfa6495e9c7c86d90298b7f21769f13cda4fca838c938712c1e8cd38cf856b564bcbfc0c648301f6908f0a1c807455780ae9468c4f8163c0b21e148e5c092a840c2e85fe371cb9e7117cb88c71133ea2ebd15ab1c38801f86d26bcfd5d67ff9034484b2c44b6b3c15465cfe347300c632a420450f986c8d4b82a358afa708d24d9cd121a5656378766a7ef6d83ae1d7d47032ee93e515f305fdc61aeb630dea9706dc4e5da6fc50f056f9b6437e631b69fdc44cfba4b11f3f315bc478b6d0440a30305e9face01b785dd64c1908b96218722ace6cfb60182cfb13ba962d645e61eb2158c940751a82407db6833b209de22cf50640c97063c885d1ffaf40a47478c35b647886b1717cd3a707c09e01ffd69266c6731bc540356c856edaed24a6a21acd204cb95acef6f87bb7859924827fc212773dc913b67ec6c11b16f0f32fe2451fe8c90e0094ef02ae346267425becd7c51904625ce5ccaef036dd36a5b7cfb9de4df434602a9a3ebaad92d4508e2b9acb52899b6c854a19be39facb306cd75db1dca98f29cab11e57e9564abb3a8ade06054ec50d8134f52b3f123ee02c8a232971b0493621fa2d2204a1238561dc7838161623995d74202933a6945c13116dd7d6bb5fdeaba5c9a9e9ea47d415bcdad68e5640da1020147ddfce7429cbec6146e8bf678c9929d6b657623cd0e77f0def81b5c472201ebb7b48631e4981c60ec72e227a8f660b2613637527c9de5e8f8fb44f90436367ada299bb8070da50763a166296b7f379fd9c98cedb1d578ede6cfd53b0d35e21d0823402d0bd72d85c1f0be6d79e939b087d30f15ae6a8735005cde8cd125feb7501002449ce92a970d22616a9987d9be21b21fc96bc2ab9d7817ace50582eb766867266f5ba7a96b9a0830d2ce96ca2387746a2dfbc1dfc3055e747c9d1a29f9787ecfeddccff93fa54d6df9a1b6408deafbe01f38e164d1eb5a283054a7dcd3cda1e6b179cdb89347568b6e2a4d61244ab299902ac92e63804fd5a81b9486c4a59c9e6c1794c2b0056f47a3b7130cdc313f6a9140e265d49d7bfb724a00dc6e0004af562995dfe9278f0b9c4c3f3043cedc8114f5d00ffb82d37db61ee4079a759579754f13e351de14bd97fc11bae0023a0ed7bb5da55d428f81fe0b9eeda81322a88bceef47e92dfe2dffcc6585e4be59d6532f92c906abfe368f3d42fc04f2168486b110002105bf1d11e08e9f6e770f7b7a85bc5d4b7ee2d6dc9e5520c8e197ce8ce9a727cfd84bffce8e6225cc7f786be90ab3d9729475b7103cf886c1f18c0d3653df956ed3240512787264374f8480f101e996d2338bb721e182e63225048b9ee764c9562ecdfe614cb38cbfbc511dd05391a52892d5c3f8c09372947c4f2acc2237a7b19cd2513b4fc172ffde0c609c7b0dad4b6e96ec7dee7e0d264fdd82ae80ab058b356d0c2554a26acb45cd988fb1358cf1e8faa17d7771c2acebe294ba4b048126330c7ee035e69180ac6372d36561ff1839c1f4c363c027c9d8cd8ca9a554943b832205538c4eb38c8ced5ecb2ec2856aaf516aef56910ad3de913706c08316999e995bd45d5e7699bac30e9fb724859d0e6609294fddec643be290ce077aab4fc64956c64aec3953e4a9b4632116541e8cd10370eac9439db3c2f67b551dce7e80249b086cc6f38aeadc540fc339684d8a5c1bbbfc0026eada7123c4855bba8b2e723250848e3d0b27abdb5c66697f9a6547e84263539e99dfd06980d658baf562f023dcf270d111fb044bd626e4123958ce9bb02a25a7a877bf919e76373bd966e3d7408b03cb5f59cd68ae76e27aa91710639e39aa0f65efcfe7295b4d07013f24f420cda6e3db84db88cbb1d3c6fc0a836a3c236b698aeab5c0553d930e09a0ae8e97f3f35e61e00315127e75dc3d4768accc8760a8515ce1655b5aa10bac2455c862863dcc3c5e64fda933c646bd50272a6b3ecc6dee796e6f0657dde398851aeedf132b4e2fd1d297dffe6060e4d9d77edc75e650b571eee906e7fd2e63279cb7a2ee4d0ef621798831bb2f79f388f0c49c35918ca2e55a6a8512dd2e843ee19d8b369ffec2889ff179b3f60e0557bf2e13c5b93afa26058cd850a9ba2aa1fb5ccecb7986171a054fcc959dca22b540aa53612cbedc3c6f10151caada0c1f376c6fcf4399b22b27df9243aa49977de2a5d1ea61385819f9370166c9a922d7d811f7605eb3989987a36622f0c92ee459f4b5b3108aef935f74505846f078f9f65fa6a61d75a43ad2a1087bc57a5f6e184855bd2750e7a0884b10f46228695a2d211d3462ea4615de7efc47631ed19a547d857591420dfd883dd2a784e3a7b48a83f305254c98c172ebef35fa61878ea1606446b44c76374080837b16c094908f82332a6e5d9587c89edbe65268cb5991df4e0333b842d2385cc0655d8c4a64cbbea473d7acd77617fe59fa31bd6fe9da05802155fc39ed32f4a6db7fef83eee357932247abd5eb02172a1b90ec237eecaa11e3e92d6689e624936ad3dcd5c11720724e4d09047b592b023d3f07371d031100eaa2737796a5409c12a0beae8dbe9df9f30d2e3ab799dea58baa8195089eb380ce95498ea3ea6b89f93fd50b802f45609af92345217491a4556fcc8e0aac6572581565fd018ab0180b331b9e4715c4d87d54c690e35a5968f0892d651800b4cb1f0c62ab77c589f63cc02b42e60b21feab8d2f6b2d6a72804488630a52938c47f0bce2f4efe80bd044b958893a7a5be0f273236dc5f37f2f654348fd5d477922ec3e1080bd93ecc464c99946a8b064cc5738a2047dd0bbb60de0e9ebe244fd5cadd87246b120407c686d12a393280d81e2cb65cd7a50e144507b450a2c04abe0b24a5525f29642a6935580208bba1adfaeb50cc54a9e32c753a48fe876b68921db8f07cdacea5785aedcd5f27b29a18b0f270dd38c9197b9d40a2771e0fe791e969b10bd58dbf3cd6093a2bf1c66f8a89e36b7da28bd4b4a6bdee17321836fece765ca7486fd3a113c948a42c64e525dcb5244a3bce8125f6661eafd6dc5bf2dea688d2391ce022e5ab3635fc4ce0a3e5e583b5309c5826965c7115a1727522da951250fcd54e9ef3fb070665d09bdbdef67d10c6dba20d61b05e868cb3830b0e06cf70ced5b7391d5e7408e06f2aa2d6a71fe833dffa9bd0721e80d101a0f33544bfbdcb9340dd8fadda814a3af6951cc7cf86f757824a147e8e4095af0c54bd5099da3aaa0111bae732574edb8cd1086a6398151a19df2e56d2a2dc094a7a54bba27d7784fdb55eaed6a99c85303972c16514ee1075a7b5e1ef9d9b4609ea8eab65c29fea7acfb0e1386f1fce26cdfd3fa0bdd3db872dc10dc35d535283b776497ca161c89e8a7f67edfa278f6e7fab172e49ac8bfc61b321a56361733b03a2552a3d6c719e38858e6e7f337f19610ee1f7d2e7b7e39ec0d0ba59d9183320f56fd6c0079a5561e32af55d44c33a2db58efbb3109f79c67ac1291a5f81c8746a5e6b75d9efff8e8b4d7cc2962d9a0e7b52de1383a33bb1f6acf64c92987c21866482d2c3748f1eb8a5c00f95ecbdf92582da1a1162156c479a05706de47f711abc2ecd7a14a63442f7567d40949ff1d9b5f3b99fe548c939db7b50fa212ed593df9ee931f7a15b8d250eb802c5ec06fa63f384516e7fa6b7647992476d5b01ab605a52d5c62f2c92828ad4b353e2349141f25234fd058dcf97a7bf67145831265e1cc9348e5e22e7e4601f54d1e5efa583fd7e176797df73163d3506ec46202c4306c8bb216c160686c8859f5de81b883f5ddded8efaf66582d6618bc7d922e74497213c57198c58efa641fba608d6296e3fba4d058a1aa0d0b3603ef93b67e619817410b60c964bdf7af6dbe810fd52805b3fee216460ffa1c5031205791f62b548fbf5ed6c396ce826d120127a88f5901637829ab5d7bcf62d3553428b90c01f90428ac06c93b78f046360b2cc662e4cd64c641d626a96bf0349ec2fc77cc3e14d2c17e75c6ce3e19ab0c731685d231a9ee13e02f133f29040b7480dd0b4977a8f5227b4d9edb03dc2134020738ade4e9446e98745538b57d447d59d82b3f942387b0c6fea9b30aa8287620a39b6a2e05a49384cd51eb33c66a9609d47bd4e07c612bd01700820f63929e9de5e8e4cfaffa2e4ef099f7b4141ae9e8d67e9c4b86844176c3b1147e998f0a7b4388c658480b2a710af73840bfba65e7544b5bf32750a6fe354e4b2e1eb8a34fb2cb4c37d0de4a448d9a3ce86f048563c81629303832a2597f20e75de27ef645d6997ad9fba78a264aeee1657b4d7ca439a97d97f8609536b28ef437ccbbfe7952e3c62c0e9e4a5c324f23641cddcdb4c2a08107e7f3e8ac16d299763b0f49a516ebaa736203e68cfb99f098fbab1f3a5b7b8c40a39477a622b0340da9a3d4d166b98e24210ff94a094b021d1eddf057078bf572493543954976738e96af93e06afc6828b47b4679862aeaa3c07d61987541eebd1fc95134b1fddb2c032e06f04d2d6c59e6e88f8b6c962b45154eb0d54a44fa12f83a9e3c71cfd988bc20e87970c656a6e37d067228b04f9fb006275e14524004e1e828fa90ba3d4a9d34f8eea90d18ca2e50300df4a1c44bd90e8b2bad2b411e3416f0de5c436976843973db74e5088909c03b3f23422224a6a472ca7565522f00ca7d5b7327903e2b9ac81ce625c8fffcb2f4b1d6225c64aef3b706ed7ce2fecbbefc4478bbf03707c708ab38cb5d7de29cdfa9daa63daf97d6822997186b91203969049d7228fbe0c6de9aca5e9df7960223e8a7c61d36931ce7b3f9d41f2c6215fb06ab454884b9ea9f6a7f2551a71ecd337d73b43c7896dd29753caf0d10fa8f25542a3f4cc74fdde002f7d7ac9a7e58f3eb7f7c46f09320b6b536255e1593bead98c5367aefe0ebd3bdecbcd7f02dcbabcdf6037f16c421a09db5962b7c1f414299d3744a10a58131a4305c1a1d50ace8d8ac18326b2a9cadaf617bc660b29e0d622bc55bbc47ae6a23e8ff3678e61d4f4d134ac11f14106cfcf34431ad5ef31db062d5f6a7787996ff0310dbca7ad4a215629a79662bfe222d05c9f7560e88b3436548a84628644ab12279b044960874ea8fc9708e0d699b544c6fde7747645175781f77b80805a4eb0c5dece1be86bbc72a8ad09542e48bdab5f406c8a930c2ec0ab1d625fc632aa39680247f8663967cc2861c3589044bf55d02a782e08994a751348316edd3874d6a487c7ce250346e29e2d0f953843901f32f5c85620ff7a021c771db9a94f18cf659cac756c691df83452d21c7fea276a1ecde9a8e250db4e6ce33c56c921e5222362791bad307a602b8479b104ba9e039bed735a331921aaf6b6c8e57d0d8b9853feb324a26024726ea9189e7f330a8fc173c4a28ad06ff7acc65e6de2aa7a3de9ea511e8d4b3875b03ba93e8bf696bc3fb0e4458100ebe9ffe6930ccdbcfa8a6bc2690b0b12aa43d9b6a404e8b7a32d81758d0a646cf1c5c84679f10f703d5fcc344d77265cae02761152136096725280ca127a5ee1cdeb9147159efd764b89277d07f799ff84d7564dd87eca76723adb9df56c3b8b010e0bee861b93b49b0f896c7aa052d946bf34d27d5327d3cbc7b3aa25534a68450c0eaac71582157d11d6bad3e4651f83cb768c11ae80608047c37476376f65ae855d6893520ed8118e9151b4b48532043027e2e0438eeba76b03fac1d22f3ac505a0a39782b5b11672debe063542d5f38297a67a1715669f02a3c6bcee05683ad706e1e673cecc6e7a6d6412f709c902c9c969688b98cf5b4001c804ae0b4921218d176dbc22ad43f506bf319af48da982e90ae1d83699b6bfa6a44d9c7792641598d794b0336cdfeb4e8100ddc90a46c7983a973fad9ba29c345061adafe5c8dada8cc03e9ebc1a468108a536c75642cbe8006c2db6dcf01194fd0c7b2ca922a47cbabd014263051511e035ccf753d34f4ef3bc66207b9147c355e39a5290d2b006a6923b4b6498d101766b03f2bde0c618900a4d5c5bc78069db8303e22a68bc57c8d52f40aec28ca5b707777c0c5467847164994326980622a5df7bcd5c2e3b634513b1c2fc4b4fe283e5ce1c980fdcf649f6737ef06b15f77c1e5f792612b90663c9fd3204543648bba5461c3728e71cd86021910231d0751a60184bd4883d18a0243518ebc1642ca6ba9e7e2f15038eb1b62da0696fcfbef840fb03f953a4f721de10c2619ecd25a2449415b304392ef23e37b80169086b067907f867354013bc0104e84103b45d290af2352214ac1f4a6a09e3b385d5b81e8f6c92c790625f1ad7c92e53d2949a2514537800889e2cee287b8638eae39d4056d1894d28a93a62ffdd46c779562451006185c618794312f79e194dfdff53197b35349ac7d7bf3d42b3ce90eb1985287aecb4cc123d65b93613b68507c610637778193d26f9704eb2e4405e5ee98842424f031ed8989af681497100f573262f9cff7e0faa0e28eaff83000c20ad8eee6f902940685527bdd64b00ea7a82d10720d66525b6442f022582d575a75899e70c776f0b54e31cc9c51535c01d3eef691da9f302e3faecaa578162b5c6a1c4207cfc00200e0b9ffaa3af8940d862fea5925972b7dd384063a014952fd2e8d6e24520a3f5a46f926e3da4103a5201e8da30a0040a44fed4ec9995259a1f86ce2a736041c9fc69b58b6bb58a4e3f6002d8e7fc37bb4eabbd4c597787bff9bf4d87c6ee963481085c13d676dcac96cc42ed35d7aea2694437db81b467ef5edfc40c6ef1fa21bb140e707fbbf31fefa3673d66a4ebb6fc8ed4cf69db46a0522c3462d7f4ec9b9c0aa9e3e688d2d60e48e05789ab1d3b81aabc118eb441c3be6daa077c656ec93436e5ab0370e1791badba4a9122c56363cfffcc11f11cb41d15f2a0d42531995b1558af69aa0c7712ab67bc5ec673823d146173f9b658d4f4b6bad888e92e9167fc890d026d154f7165876bedc3fcfb39cdba530e2600ec94dcf05b23762bd763af6bab5059148824e276cab67126109cdf335a88530c84096b2a27da18ac70028d31c1d580eb58436f8266fd055eb4f513cb627c782485e793ed5a554da2c9e681c2963a3fc01fe50877428ac10b805e935d79c89b7af776a30a6a602fbe59667990b9e07ea4c93926d9c6941ccab9fd9822368735aa0c34fab53cc7983fd677c76be669765c219af7c7eb4efbe563b72fba400eca95539c1de6b662f3434a98f523f4522185985204295f55bdc99ab03430f2040b33a262416e5e49b92d6850d60cbc58a92d8bee70af6f7152b0fb2b58bed64e7f31193a49bb82dd6d0bd354ddba605fad4d6bea6fd1862bc2c4f801f573420d3c78584e71264357d3a36be36bb61b72ba9ca5263c04ff46bb5ede521d11272e7b5e014a0e534b4c31f07620b76a4094204919a394bc37de5fd7768fcf9384c9d343884bf6a970f322701789d0ce5e3d7f91b3e371cff123c6cba54dad05917c23422de1d8d2fd916803c3d62b734ae2bf83f1d3639f37425b7c52830bc97f01a2b1110b3a525e71fceffc1b1910bbca2fcb6b647d26f1e43df83da9a1e762bbaf44409fc9f8135a3a35476cd1106d417979586cf4f8053cab1477c826982c54a06a13ffba220b483076c4a18ed0cfd8ef399d96a0cdaf2765822fc68a4cff284d759e0deb1e765a537c7276e87205cd340a2cc8896b8b3510f32b39a1b5382dc412f87af5964eb5ec712e1f33da548f2b87faa5a3f83f36ca6d84236a68d07fcac437fcccc7078284e0fb758a4a138bdf6382079047180d5c2620f9ae729b494ecffb6d74ddf787ba027588b0ae2c5436142107b29f497fa1fc4ca71ab3629fd87a60d1831924f7e7e9f80d82318bf547db739ef92b7ff13511a872fe00dac1abe484ee5d2fc100a3643891396ef0574ae2016bbe19f59b0685689611b929c8817639e28a22bff9bc98e701ecfbe83642ec8b28380d4a718637eaff71d144d6c9b788f81fe925d14f82272b8001141d3881056e81c980de7da8cfcb24aa295f7dad9cc3f5cca1352846def1e716c2a9ed67ced6942f013bd7421118df67b3a3ef402a28dc05b0218baf4810f36f8641fdfa94f3df7bbb6985cf12a3f0df2b9cfb71708aee1dbe6b7bee7293ff7ca439b28033ab0916c9850345e390c83f29631f3b5e1e2e58b4e0dc3a0420fc3ad298f7aec2660064a48b1eca66d76376ad68beb0e824c270997d9e741f740dc8193283f3a0d377f6cb165e0186d38ef503619f22af7b86ab9970c27cd36bc7197d1abedbc104e3511cc128e8bb7630b4848274764a7fecd85e74b0ab9aa3437ba44c9ffa62dae5094557486e4ea21ef207ab7625e2dff6a9d7304fdb0256ccba2ae217394240896be301abb83282e436d7cb92e6b06073271b923402b5e68d7759ac4f3b86b2488bbc587d5d1bffc0900b573ce6a92605148a019f3da87b79160e6daaa0cc2959713508d239fd2b833d1f9638e36969acee97eda1f494cd0bb41609fc84efda723c59d79cf16d285c655d6c62c45d9b6867ce22287920cb5d70ab28e399523d89aed5a02b6b87012dcaf6c808cf4a14b40005d137664e2bf2e5bc1cc37704713fd36b954923a7847cc33c6ddd2ba28079868b3cd1cd68bcb8072dc960b4b7a0f00929a2a2815f3c08d8fbdd33d7f02f3e3c38ea103d69befe1d043529558e19090ea5e72e86e9d663bb96e2efb8009e53e50489420c12a57079efc64550689ed2ffb024473ea262aa06d140bfa267fd6ea11fdcd07b555fd6fba5370f83fff0d86800a591ba41162b0bb54bf4e6fc20d907357ba4c5ea77db8b3046ca4ec432ea6a76ca3e384af501e0163f3a0a66ad43e73291f748ef8252cf9bb78879082a7446c61d6380265aff792cf5ca5d7faaf29c64adaecd0b879216a31d1653055c83cb749895c5b0ff8ef133454ada65821ef1f33f94ef9c11a10fededac0801825331898827f76c8d25eff7643986fb16cf91f6a3ae66b70849bc73a5e94106c27bf36910175b3aa3bc31001180c0685bd8de2731611bfe26496871cce573f74a323a329b998f7e306f7e2ffa71bba42f8fa955f2be4887cc25d5ca70d77c7b74cf572152b1143870185694a5cd4ac18b3964f8c435213f130ca1e7d00c5b04700942dff25240452f83146bad1b6f7ab25721fdebf58acfe3694403dcbb20237e9558cb4300edf50ddbbdf18fc4fd11b4411706adad85b47718dec59897eadeea783fd53a0d864e53972a86658c18f90358b10f3fb67bd3477df1e8bd2fb3b7ff333c73222365f8470bc9bed67234c940a7cb90d6231a69175109e5134822c301cb8af33e114a4469547effdc8f91f16f3f26f1f6673c3008b808c425ef141a26632b2d5560f80fcab09ec36ec48d64e95eda96660714391e2c545f53f89b8d887451662023812e8f3eebb82e984705ce829f5b32ab0653968942f5c5ec4cc0c3086e91f7fc66d12358adc0b907599776ba129b9a0193972c919f7137d91e7f186363cbf76974840d06228941421ebfcadac89f32c8eb5c39fdf21d8c330d9b8f0fc60e1783b3959e81f39ffcdc43b712b7a301ee0916b297399c0d57cc86f432c4faa56d5564319d547dc8511a023f0ab4c0ffbe28e28807818ea5c59b109dc7d2de409a9a8cceeb7db3b0345cb3ac5963be420632923600362a377586eca726934528b301f83e98ca50434b904e869dfe87e77b96db37607a0d922c29ab7627190299f24c68f14281f6aa2c68d3dd6adbe2c990528cdbb26b688c6b93b2be75a5455d2285ccd3dc05df36d59802893f9cd681aae49994ff6bebac2113f45b1ed5757c65d7f7a14aabb5e3183d96f74c7ab813ccd31d5262cb11b11bbfc67a4790ec4c9e1c7ea4ef9dca02884e4923eaf46a073003d614c2b5a58af62a6ecc630601bf78bb8de97693e4f709772093975393135edc2db956c3c12ce288f7e9dcbbb09b18e2084cf6f635f1eb8d1d44da10920526ace5449ed199f286ae80170292f107ed58182a42e9858fe4fd92916a6740fc96ea3efc8b4b64b0f15427c757e82","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
