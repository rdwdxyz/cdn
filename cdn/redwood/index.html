<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d0f5f50367fddee3bee37c990424cedbf2a2474b598ab165e36828be15d03c2d081e74522f634144f1a0e86d8047c6575fb4f1210042076e770e84092fd9ae63081f4601c3fc10100bd2cdd2e65c7c91b2c865c76d136cff7febcc6207c00c93f300c45bffd47e2d1a2b2aa3ea2f13456faad46e8b4f91f6bef12e201d1a23b38fc332b28560369e7fe5ada906f184a75d1ab5de7b230c010c34fd6b658a440e8a043fd3896848576f059ac902ba15e7c9dc5d91bbd789323547176577094f36aac7c9c15347a6a5ee956b455079c6ccb3f249ce5a841fd89f82034bc20d542c17a76a3e6dc2a3cda1494189d29e0013fe3a0165a32dff740a8919bb8f08f882cece4e606ce7ed3daad759e22443fe60e02a9067d9ebee369bf4a42832be50ed499d0ae2181ad091146a7d8c081b6ef70a05aedf8f4774b160c10e70254edaac20a9fc055212b6610018453c839927f7ac5f3a519a9645484517e1445c48c927a9e1213eeb5bed9e33059023eeaf0edea8653b5a5a8acf8040ba04414f8a98b82df55587cc08e92343bc26baedfbadd0dd83710de3a699207961df7c5de3ed22b9e4fc71bc1778ceade1ba64f96f900f266f8e474e1ea7a683eaefddc96d7b69885fbee6e31110ed07fb543e48cd7c06c18377d5707720dbedbd720e62f875e7ea0f5ee146d2ab7a4c010367e478f17a4a23b19054a88ebb7f545b846646e45f846d71478232418552bba6c691fa4dbbf6506a5bfeffd7e7c5fac3cf11bedaa27f524989aa717515196bc76c667dff933febf99be929a9a439bea9ca79e72d15d03d13864274967b4e2c63eebb3f96e2e1c294faa38a7e4943494a8320a7d1873d6f959fd949f334033cdca8b10870eb42031565e96e76f38104633d02bf986ebb8f849f62794e99d5893a83740f4291eea5eaf3783513ae755b92f610c11f025a8aece869a95fb6113d8bd19608fa8829d266ce3e914656fb619d2bd35af8ef633dccec73109b574b128fd0a75ef52fcec0aad18a559f4ffc23fdb0a27f2e2b7f3afea095b6c5cb22bbde3536265f2d058d3c4940752535aca272c32a9322022ae630b3f00a07443f8fd999cab48414cf36b6f5404f26d7d66850cea37482a3898a282a45fc9b2b044476b3e66085c3d0b2d04ef2e5e3c9528a08802e1dcb983319bd39d70269216d45c9a9dfce040eab47d2bb895970482dc7a29c1ec075e5094c512dceec5296cc89a2caa684d2d245355cc64eb9ea4a04246103ccfcbadf9446fbbff636e6439718ee8db05033c5603acde0e903667840a5888e80e6a1643eb1edbccedf2ed767d82fd6f9c806b21d1d758b99aeac6b0e2c4bfed2f6169ad357178a7bbf099ce244becc34e9a2d2c075dd3fe505f78f176d36606b6835640f7d3622fc7b3aac36bc839552e4c83e372199050baf55d91d8f338ac70a7e4ebd3b39fdad6963e0233c911631f9d180a677f788413994cdc72ceb705f01d57190824dc31a560eae748bc5ce66b29e8912612fb4c6bcec951bc8e9620f9e81d3f2326328ca206117c72e83665e2ee5f3ae590c0c535129be655b83ab7c543156493ec37d99d0e64d7ba8e5288848b8cae8c1ba8e22a08c746890b4e01e19b2e850c1d60e7db8ed87520e1a1115358fea426decf81db00ced9076452d2503daabc72bf4136b930562f3b8613f7b16c6fff48cf8bced6598c60de52f30a30531052381ad73be7a82deb3c60315b87792ae87b76ad649bcef1c1874de75f9dc1beb175cd755b8be52f27f56aa32db6078a72ff9db3b036c6acf2b9da7c17eff8ad2e662b540e6a8d517041d81b695e87aad0616e17245063a75d414f8a64e11355ec8e96cd222dd60e21e9ceaa8def1021b6928a780e9871f3e22bfb4541d29de5aab140459fde71b82df5564ea1810d922267fe0ece6edcd64d9d13140875900df43a95e46aa79bfe4ed83d5368ebeaa759ceaadaa4c3dfb9c22d93c1d94e7472469b2e6367ccc9f142c8c0e463b502442ebc9cafeff6fcd121becc84a5ba445b8365d224b9cd76e872345fbae53b5e40ec0b57b3c6bb47406e6b516a20b0f65e64fa4cd656107b9915bf9a535fd8ef912632dd8b2c3208100100801fde59e428a4343dd4796b50aa324915d0a562d461589c5e10dd0bb011c1b3d2e2f27aed7ca88207818ef878113105c60e4bac180411fe57d2ed765b48231f455e9923868f7adea45f0d724fae23c6f91b718379db4d94597f6cb8d25cbbeb26c86a7f091eb5be52df8fe4e36cbb5cbae09892a5d03224500f6908a04d339b99673add51f60ecf43ceb4e53ff4f78aa49be81dd6dd655745de36e9477f39e83c653cce478288ec6a2232dfbe9375a3e3cb64f1839fe2f4fd4b065de83820a56c0c39063d5bba4a0eef899c6c68e87600c276c320c9bf69b074eca3254c8b72f9e2913c520e45d03bb12bb7e7d808c42b27b74fe8a4a291b0763cb54434d6be4a55b6a2395d4148b2c483485056bb19627f9dca1dcbf511a30b7f60294b4b802084b8ed8c33138b0ff97f00fb9338e988d222714bfcde6ee4aab6710eee8b1005046d993e5aafaafd31e4714d6e575a7263eba5af10094edb70250aa6d9aa2c70d046d9351c54a890b6214c830e4e302e14d816bbaab1224ae2de864e7353f3d5d134ab1033321a3b9691aa6b4b83798c858a8fa1e007004d91563d796a85592a3ccb4b0116f516acc9a9b392e73565c874cf5bc7d4bc0af0959ae91a3a7c84d349e0860190fa61c0bd226d9d3dfa8f5714b9b6ae1b6cf725bb2bf4126bafb5c08f2a41d448845071e4392a35b37aafda5b8ee431850a44bc65ac023e00d0db97499a5768428a718feb1c9b00d0e4a03938f74ff10a977d9a0fed3c24bffd0c70a89a299448db53c74f544a6fb2d740be617f9171e3d68dcb1261fb719bcc46c785d03880346cd13b69f609bc0d686798bb8f1e5f21b3a4feb818866e4b9ba842afa6ecc900e430f20dfe2c1e88a0ad8cf3790168ea732a93ceb6592d2209b235cf0f0cd20c5abb9269bfe1798ac2ea9a8e6e30a149ee973a93a85e3bfe0151e814ee0d67d1f272ead60f4e55e4d671f921e57d3c60c33576f7e7f4dff2800284189be762927707f83f0297e2e33b48f049a5ec1c65a8b528f0eb302d42b65440472b88efc162c953c044a3665bb5258c16de455db7134a5493e12cd587c9fba2b7ae05c3b9adf00b440b17e19318ff91e1b490d102336932f2c7e5b5b610b78886a1cf35cffb18d6c34404c371ac9c1271b1b53666e13d1219f34f2b2b12ff5e2d2fb0c3c7dc5ac5da170f573e1a671448c8457da1b179b0c61893578d07794e2d7f5369aa7ade2456d04951d6083455b7680645b05beea4f913101ae2ade2d003315d305442e9e573256c98c2d6403ea33b5f63867c88b13776f1e4f1a2d106788fd52703a003566f2703341e342b3897b12b84b6769e533b0337d7ce6bfefe2d4aa258288566defbd0517dcddb91fb5fb6f64d6a3a63c3f54334820e58f933b3adb7fe2d0417ea3435f703650e866879a5f8d6aedb992a0a9abcdd848cbdfa8ee5eb7d0b622c35e48974e4f2a9d2dde6955d5c6e188dd8c646bb2460263f50ccfa900239dfdd6068d7aa8214253dcd3895055c18ca59e09b99749cfb59538b6785c9094f2de17623a004127e9945828897bc9a77e26b62f2b8351389f5fb938c1f0f1656c6b686204c9b402dacb8e0ba79803f4e93d27126c3a4e10aee325a7ec9cf960eb6e622d90767a0079df648fcd0417edfb9991f0072ca1d50ae73e0c3c849faf956fba546e164badedeba3924664cebcdaa883ff256c5ee5f135d402eaef5c6445eb9311f4406c3f7720c0899a8f6e9c6f7ccb5ad3551c533b7e8d8aa9bf12e1f265ee7fdbc1e7e9a75ff06d351422881c5d98aa775f26786d76d59813f39ec5a0e11f4aefb6ddb6be5c61b7bae1bbb26cabd7fed4fe9e0aa15a1851d046f10b0117a727a50725ef737f1115cd97ea1b79092d8fdfa38bfe2adeb078fdd9f408f876ba0bfb90cfbfc24e0cdb1368aa84fff5c358074720ac66800687c05ad415d2e3523ba3636e53e1ad49572d06a17c20a4e8ce5d072270f80807b073adcb2abdefc8685a2235ca3b4dd30b6e685d0449cdf99cf03f4534f5794c8bfbc19cc479fdae8db035a7100ef844882e02dd6e465d07cc50968af0b07451bb4dbbf1c931317245a84f8eef5c6ea6b995c35992bab238e6685a7d0da866b732b73778fe28e705be4b7addac37b894e6c9696563b6ad4c77bb08f65f26cadf54f362056d9bb0539362386a391b815d13c0ff797aae189b20a337f6b36275e4e11dd84c6c53da1125f1d5f183eaf0f4dd9b24dbae38d9d8fe9fa8b9358eeea205b4e23dfa6c92e68e5c0dd30593339bef75ae10a5663d9427a687b7c782343473f604c68157920dac277f944915563cc5c56f141db33f13c046dd7e63c24352bf9ae7af9fc1568829510d6bc28484653515a11c81b23dcb16e56f03be1ef061a39f8937ea2365288c017bb19d36b1e3260d4e34e7c87a3c7e583c4b2ac1265d7686daddc9ce814f5c919984579279c0ea4dc24d0382a053b4a2b52663910119a489ba9203ee81e579f3e095371b74a8835a7c02a6c0fd8d9b471372236e13c7f7fb3083dc0af785fc899d5d8f7b543a6434f02db5ab622f1f81f3761136884bc5af5273bed7e327ac53c26e5f7a5269c92c3320bf15150fb7887e7652931cf2d4b36f14100f390a5ec57855711b65e68d3c970f04182d4a3b528f63408f6a3adc8b0a9b00aecb6c9aacebbf1f830c34944ea1b08f3f58096f08a016edcbaef8202f05129a82881ff3a8a367de9fe01f922f478cd53c3b219affa0a28ad00d670733ad32696d1c654a304278d1e9c0bbca82d2668cafd8cddffe922f0ec5a5e5bded3d284f1d62630293bc46f9892eb0c6cbff1ed4e236a03e655208258de116984a9b0ef32bffb170d52d251968d914d03eb86d375c9a8b7bb94daf715120e7c784876d11df8d8e7b9f106f66e6a33bd0a30396976c78d24a377b5228e51752adbf565030659bc810dd21c9b4f37e36ef7cfdb5032ce13f030a68a4f9c645c9a45b06fb2017072d30da59fb115dbb72c43e33e9f0b28ddda50df6ecb89bfb2da99448096f663feb442c3037770b6d52836533830bfb38d3107daa752ca423b7f78f7c705765b2a07ef1085fe9f317ddcbfd03a07410571bb7af55a2d8417c6aaf0623a917a6eb304cac8d8f384a94cbf082b810ed838b0f247ca39ad1828da76ef345632b64ac40b9fa359ed6e64269db56ecca9f972f8014a7f6ece43feda1c9726292789ed0c0e8c68d6bd9ec37ce215151d40c5971419a718c4b4f53999d05112ad3f956b9a248197451c73f57c9bdbbcb36cf7ccaaa2972744ba367ffb7b3a3ae7a9721f205ea4f530a9338ec28a6abb3b45f06be1c8ff62e395d0c1aff55ca819de6ec27193c3d072dae28adf252b0090772196de67ad228ee2a38df1803af84549e1470a46488190cb0f9c2f3563166cc55a66238d5a07d77bfc800a90ff5012acf71d0e2a76f4cc51f155473363e531adcad66b8b1e839bc4f70f4c60ddea06dad7021984dc54eb7d09df44d7d2f855d1368bb9c71e8c54dbc70aef9ad301e574e1a067fa3b559d9703a0ed0200a8da339dca9ca1fdc7b9eab83397686bb4a547e149ee55da946138ec20b81cb034276f62fc0aad8586eeeacd9447660e4704ffaaf79a64a66c8c77c8c192d7ff6187c2542871444495aaa737abc51d47bd5b561c3814e41439f765ce786c8fdfdf021e7a449fec24c909eb38437540def59e6a699696c52a0e01f21bea1d60f5bb047cfebc5be158f1c1890ac040c718f3546be6b7c0920b11d7e2fd5c1a949e44a4970620cc4635b46acfd004b4d1a9f1fd4b0812f22bc5bfe43bdd0af556b312cd07339ae8bc4e21280173b506267e201754eaa162abcc747e21cef4dc34b23bcc330d24c100d7bcde513e04906f682dfa3247d3586796626cfdf19de4261d37e7b91afd4000d2f4a0665a1510f263600028f24348487744de62fb681814daef7f7fd9d0a6ec9441299443d84b6d9a5e416dd50f4c2e1085aeef2d8bb4b9c393cfaf495de5162c9f52e2eccc860cc1242013bc49023d1578b241bc091bcfb69dff4aad9639bff957ca7c08d3b7eca3f6ca02275c32ac205fa43275d71f484d03b162528d238f3607b5aaf1d2c199c50a57f974871ac92551c8c97ec552524993aab90725c3aeafd27543c108dc82841bd534b8b297ba95e0602f1043db4b477012df480f168fae879120d42594f68347b9682f1dcd25d2db0183de91e7c2712851377efe1ce0eb70f828953204ba852f4f09f7f21139d6e3f5a99b2986de0861eb70c9ca82972d681dc292f433048912925554056e5bdbc4a8ae1c27c78e1ddd15c8700e943e27e0ed23af0f0db1728d57043063b25da2c872625e040c9dc208278fb7653148767576b0d411f08b03985062516f0585c189d330bd2166b3fb5a1eae879bad85a834ba1fcf57203a129f345e6bf908ab6514a81db38b6e7c084acb556f088537cd9e7c8fbefca44d1af28ad3432518c3a77c450605c92bb75b67efadebd5550c18386861c752839e50f2921e2e0f6f2d76933308aa689fc58dcf03e0612ee3cf3a8e32debd2648f3e5986df0e881a3e421b3fd54f1c5e20548a4964c2c18f3c2c7a70d9694e4ead101f8b973151284edd4e293f56cfb28863d32a00bcdd702d62d1f57b7d38004a1ec4e68e554352ae396c2e2c0362df4a7dec8d488c6a4031d0c06a9f7e9a7f930199a3b383aac0120003791be9dc39b88dc9cfb3905548a923aeab8b797e005fa39173de937d2cd021e20f2256ebd4010f66bbc91e13fac3e95c25d8e9995e926f3432f22a89837f8e74b0daec06ddcb0a458bc2fce84ed69d529ad1727fc06188526f970766a76fd7e819b72faf0e03623590d78645d94965b4da8292ec4ca4602fa35d64fa3d02d9970b830ef16a8f3cbf608e9dae489df3a8c61a46a4cff04ec19cd9b73e22c53af4e541c158ae58f43c022a42d8b39588c0f925d80d0a7009fc7486611948df8a8a81b0cb454274b57674b3f2f407dfa0cb945a6d6bf7636b0d0a7fbe142020563733f92beafa8881a017b191dd6b1f4c91539f038d335bd682418785fa3d98d4e6dadeb42367984d63d1db68d41d817eb0b34aad26f7eddb2788d5ecb02002e80abfaab989b707f1197d8e89cf21bef4813e6b54276040c3e07d381e07a161b666e4b9084b59c337ae759f3b81cf7873929b127babffa92eaeb629116c4668511481bf8919b446e6716e569ad17e65f1a8c12763423cf52e38e616b6cd6f417cc23fe4983747be4b13980304544811caf3204c061cb6a6c4b7c3dc44a1ebed4b99a7704b57a06666d5ef0938ae92548daa679860bfe4a1091d1bc50fabfeec128bca4bc8d2be12b6dc31ddbd276c1d5a91131d68e0fd5d19ca3d231166a8a3d4db091caad283396c6ea92ed25b01894babe5173205589c7fcde0673e0acf48fe0054985b75e362e5eccf2888e79d5b42d2283b37135649ba8dcec6f4eca65f6fca27a99f21c633fda464755c5470679dc2f66a3af8edd1bab5f715fdaadbcabd687232a2af5df594834ae35cdb014471c4514bc3f0ad061e855990c74f6e408692cdc9dfadf6aa5b20ea8a8540d5f5b50f707819b9ec88a3a21c15048fb22a5f17d13c3844c086503505362fde0d12a7ed681b163d604854ef6a32d5dbe8bd8f5d1f5b3db0f017b3dd7d8c514c3a92c2f7b60545ff744ad3bb31d70329e47d342c85e75f922b26ee0ac62a69bbefdd7a57e21be7cf028bb1c08797d3430e3743f86c2966c6982cc7a1f584d9ef195c58afd37e315beea60bfd4b540ec96b38f5e3fab8e29e1784aa7b17f4beef42877eef56eb325134ca08131dec184bf60150b1235862aa271ef6600100457e6c35e02d9cd316198a5b9f1362e967f77b976a4dbe082f2a863a5ad809321530da0153192fa5bb65a4cd22ab53599e67f4235572b1c34fb434cf34ce4c897aa41291cca97b412bc1ce011919a0274e0dfdf9b8fc9b75a3dbb0cc7522071f18f6f75af40121490ada369daf9b1177a32e77ef37865d72697f93f63d973b2df5068ddf09b158240286bbbef3ced5b16aff63d35308e970d351d51cac44c60e57ca92c4fc24c83414e2506ca158444fdceee87f398e925aea06490d773388bba1f35b2fe3363549f72c7da8f5d1709daa2dc857ab9fdce868a8336991b84194f065eb44ab001fb5a66cbff5d37356c92b7dad90d513e9bef807205f971a2ecc2f15bb7bb786cab0d3698640ac85ec016993999f4e8404f78b6af8c78fec582648c866643551d20f1e3f0a73ab5ce0b7f586d01f480a25063be421c37e24e1a16c1d741424157cb5ea8d8e883f262118b6e0b0ebd1e167950880347214efd5e39b6b0ff49fac404cad6fee9c99b4b9946dde78bd649571a5902d848626132fb191d9773044f697eca67ce1ea16910661ba11f19b54f3baef654d5e614ca80bb985b9e6c2e95db9a9cee555bfd0df74200075894a48642430ce8a8a943862377443a4ab711f187b4c16c5f4cefcbfe94441c1d593c7d6d51f4d2f1bc3b9eab862c19308c13473b224943c5ad33b9d315ca9c336d930d907b4c51688d71d6b70e0522286facd839e4edde4e1c50a2b5143aa8e183520a2fe5de418705875dca22795d7982eb89545136311c0aff9cd8c33b28ca6e6d2b9bcc33bc52e12065431a9f4e161b3abe26065eb93cd90d23b2445440303355a104561976a2ef5fa024b728a409748ba40d1b10e1b579de0234515e9ce7e3a41abdaa87b9650061a0526a59e589f4990bf334b77da115d7d69b79c6f833f0ac0e8f1df234ffff082a8f262e06f601bf7449e68f854bea64dc554f562d156479230749371231762efbef7ad5adf1b3bd938de732f0292032d5c9bd1cae6a662b76c5b62b8c99dc6b7304704af3a7dea47f8317f96e82e72af85cae1463a76eeec6633d4ec97e1ea26ab7f1c67c75d2316b25e04c3e2d47b8f944eb6480e24b66a5d0b5731298b1a746b2a5b8e3bcc9bc4f24c4989f054cfc7df5a01241346909abaa517878851efb96f0365c30501ccf7e938b219f8ba19690b7cfd21d848ba1f4b453076ed79ad2b465c3d64b265fea16903dd49b01b6b0d41fbe6103e23f71dd1340b6356621fefeb192029df22953706e83500cf324189d205e2d33247eb4f7816579d020c3c825ec541c1c207d56135e488d5948f1c291f2e08142bc84c04aa9d45953b4421d3dff9e40b7554ff0a6393a1dda6c1a42e629501ebf908ad3aeb25d367e4eb1eb06269c582cd18520b26367e2f4c26aa0fb2883284dca2d3fc384e85de6cc9c482df05294a5176da1e968275b355c5531fd1611cef4caf1f6ebb92637f3f19a9a2fd60a5b6f56b61ce97f06701728852a8774b12f7df80dc59de7900f3c2945d1bd712e8e0854907ea9ab50ceb6879867b9d0908860371727476196dbf02eb2c2fc0a31c65ed14108cfc0a6a98d7b65cd5fda3102c26a66a2ed65f69119dca68b108871aa8774722b7e721370212d78c442f616c1625f66a4d5a5e982fe1e0c028cf86671c040d6f0934d5df7b24b45ed7ea9c86c1b5b19bb45f59380674a4ae1d3d8b56fb43826d101ce151936bf8b3fc0c4e3f64b0312f4964dc9d2cba1b4f322d58adccc56e37426790913e818786c3cbef7641cfaa7090974cf2b2b95fee3f41fd50c40602e9b2305be742ec306623a372aff5ece6b83afbbd606a9cccd95b2ffd74b0df9f24ec77fea8178a24f5b51e017045b9d0575660f76335ecd120e9448e9ef6c108cae80c03116524bcdd32b07b317bf5adbb0d01b7925f1d002aa12b25079c4746d4bd3b88e1a27f893f0ea8a9b4a82a9cd79772afc9d266847671645ea2e02ac21f294d2f465adfb553832290af37194d12682f67b83707b759a66d6129c7be6d8c0ce7307da0059ad2c94b054404d92513c0fdead5b27592932d8543cdb51a61d692e9b5c6db0e2c0fc2e9b5a274a85f30bf3ace986d017baa35a34e7efb3536cafc9d77619c103450a5fef8cd99681126f5caebd7f00226525b14f4e1e1770ac092c7b603b269425bf646af1fa8314004c4fb9387335140d2467fead9858335b12a1ee9ed38e48d1ce510be383cef644e728dd3feefe6a8ae0b3f2c1791d3b823b2ec55a037327963117d968301e30212d35bb88cbd9a5fed1673757b66748231d36fb424aa3ef9085c246251a580307abe9eaf3cbcc6edf9d827e19c19b030abffc036bad6d0950480155feff4d5400bfd898522bc144547b8115123c5e2cd3cf5c1ec0765ea13030387affd9be67940df38e83f3a59af25af6a3e1d8ad8bbb9eca03d24467950faba3851eb9cfef76f2473780cfbe4cd26310cfb2d93e36a28ca46703cc25e8f0d52de9fb1d6610e49a6bd2681aa4853fe560c561c27feb5d1dcdc7983407b937fd083d9e25a9930a5b28ffc515c2407868df5e37b144cd092dc728046687a4f79a022d20a8288084e91e60bf1d740f934261b16a803434a72eadd1c3a3997624b216402bee36fe6bf96deb512e368b6fa312e7e05d8916334e32cb06085e263377bf72160a903769061513aa23a4bd545a2de7e5414a50f92c93339bcd12f1f10fbfe037c76740f924fa1a5253a7d1eb08c41c7c8b30d0d6f5c2b6d66c991a81ce175c18ddfca9a6ab5f11ec62007642afecb1eb244982c48cd104a8bf031aaba6c6fd53deeff63db4975ae02163eb35d27bbfc6c8230db7debedcfc6fc4a54a593487ca5d4971fc2f4a2e6bc34e94deb83dde72b80e21386c5f1e218f3bf505e2f5c4bc4bf6280537c03c41f494450b304cf341a545241a36ded4a041565df800b4a588406286f2216028ed74ea861e4182cd58c39ba3e752b621bad50c9b49cd534ab6bc8ee098a356ad25136cf811e440d3e0254b09453b60352afddc92ae3c9f499a6624ec37e602dbeb71e57ff49c8c15c570179d91c4d4f70a597e5a6da05387c3fa90e0a2b78e53d2b9abece057c90b345b6ec4097fcf52f805c7b65647dd8c8bbbf070c8338deb3dd90b6720624e99a669a44777cb153bd97a8310f1745d619fa191f1e6b75ef5b6cd71b8daf7f0520921778f9de2754bcb35fe9d8861d8fec35879319a8ca40bfcb5e253593c0dcdb0a375e7d1db5b92871709bf8a6585d3439412478d7477c32493ff159c28baf212d4ecdb7d4b6663e672a97a657319f8f3c042952ac785d961cb104e2077da981d23517e20c8918c17c91c50145421f9a2bc9cd4e10cc76e968eff65672c55b70584bae28fd9633d8810b63f0eedef337247dc7aa381d70492071e04a839cef84b98627e2644f264353df766ed2032887594dce433b043d381a0c5eff65df18c8a54f95adf743f2bb47cb9d96d98130ca9875bdbbd8f187f30eba7f519b77048d51f2ff6bf7160193dcedd0d51331f904677b4361d0beca47196e4231a3f9d665f02b12ab72b5a672a0bb602af48e186e38db8c4032b2ea55ee2bab9e66b6fc39c9304106da264c51187cd5b2f7571ac3b4290c79157b580d37a0e0839a84715ee20aa7d34fb813cc151ace6395d5bfed684d123043ff862ccf8a9b238b90e5f771cd633fa265428c1e2ffb8c89a7e1c12329a37ea09530109b9d1e40d5617a96e6b298427cb67838c5bfbed11d33cc2a93bb1988169c17bba9b27276e4b57c1ada27c2d0f975307f407e13bb19a64abe1f5b1eb6b7424d46e764487775d29d45b2ae5f3584f77298c9f05655c92f140efc0b811eabf5b46dc28b878f2d11dae719bdd38f09904025510ea7a839813baa4b3249a20b3a78c64e19db00e5f1a4b468128b6ad104c5d66b45a649cd6e32aba14e2fb7308a65838897cdc01c577c3f50fb26525b61f26f32db5370dd94b377778ebc07d92ce179e3af83ded9f92eca4451b209e08888bbcd2c45dfbe788a0ab8f91a37569c0874ea67e0c0edf19b1cf6052080a78aa6a7146de16b0089ffcdf0d0731eca4839f8c3da016d1f74d1de55ed683b9678bf51495f1e7d270f452e76bba50493c07c4dc015a819516e57820b2672f3a81fda875dd0f51c6e602e075bf882e97eb498034a9fc3cc653c5fa72c1f0dcd922abe18763014cf12154df2fdae69fd840696bd3853886d497466337c48ed3ae77ad6c9496a658ead33e8dba130c1a1fcb2f2d67160c59e380bdc59ba6375b09b42b1c1099c6b1921da20ee9ef33ca17e2bb4a19a0a823ff2adb4741a87b4668e267902169597af2504389221a1582f49f27165e2190bc6bb9f7e080cf8875872c433488d2857937a368868065f84d171caca74806f01899ef6359bae6b7ccd6462d83fea3b07a639a7a62791d34db58b020836f1b3788009f91f1c2fec905bb3741addebb69eba4f4adc9b11e74032fef89b076552675b44405d19c7cbc0e28c3a7c797be9eb530e3a737443f1d2f9f8c2a4c4e33f11eda382e8565d02eb663017d5d480bb9c701a60264cf46555db90fcba7ad22218382d85634f9469dc137ff055af3af6c3de96ad62b26dbaca2fee2c0cf9fa2d40ed6219607fe97363a17941ee9448beb645f574ba3f291d061ec51582a679d9a1a0daad1b57b1468dcae71a94f4aab2a3bbe0db77def9286f61496acbb67aecc2a11cadd6dd86868017859cd8d50f8c16da70568d15012ee70cde564e8c02a19066c74adc59e3266c2bcd862925047f5717dddb5a47ad67cf2cc02ea49a1af80377b98338d8c9bdbf3aa81417502d3562e5c019074e65ef73252f0598b7b707bcbbc1da18fa0a41620934dc556cb2b47107cbeb24272ae36e1395a098b5c3db19d8339dc2897bb853d4867a53c90bb15fa49fc731a535f1bdd7aa0ec37f66aa6a642b1f8c8cb94853baef38f18a574bf5834a1d67f174c5d493e3d7237e0b5d21fa3e7c17e2f17d6e51d674f631a8dc3bf72dad7ae8ed575d513edf0aa0073280ecc03762e20eb140a9647db306207256565f88ce6178bf3d6f9c7ec53e2c28fba6da2e2ba554623347f6fb51de045ddc41612b4e9a4ff0aee6593c1356f3cf44b8ee219356c2f9d8ec14c6c9d59cd26bceece044ca65950a91f4f0ee4e3237cd252eac99d718739ad31ccd5bf07e588e71013fb1f17c7166aea6506dac29ad9a5db5619a37a2f614c33cc41b760810a9d44bf33b933200b3671f416b785f22f1ae637877b3b51798b87f35fd47939206532537ffc7414613d1e88d657938c3cc8a8903ab8f161a32574c59eb490a9242fc4df646c1734a46e829033473565f47eaa391e7056948053706dfeb5b7813e0582f81e29b6ec9c1a8ca7f5f9608178a1c951da600ed84f2b88c4c5ba8022bb38727c3cef1efaadb164b445c406150bdad9e13fff31585ed08602a5aeeeea28902bc8f6c9e4f7bc0b2f1ab34895e280237117f4a90cf68646639e8da953bc9648a4e8d773a2538edd036d08088b4eab49e60f13e313b2919b5716e353840091ab674d7d0be90c065ab3c3dedc47b8b5686319670b3b5f92a458c435db5c4dd80ae46542865828e89d9eb6a587f9b26648e1816a9ccc3164cee17066f6bc078115c271ed4781195bfa56560abf727115fb8be5275a3c1fe3ed045ee20a597998e29d4aeda6bd658b61deafc604c134f55be2ce4f1d5dc61d8b73f2f05703f600a3eaeb250240b8368196ab167577aec4ccd3fa4e5b9db05876b8f3e7ebc0a52f7bba5d562908730c674e01f0cc97e58e43931f0b1aa81cfee1dadddf0de3e1a335f83cfb3cc71d12806091a256eda9d34518425f7d8f393aee2b3c78ae2edfd89e1ed9fe6a9988059457d3a911c02bf99cc01f23542a7ba2f2279303533f23846e7c8bca0ce7b543b747b2c4270e9e0eac47f8606e2f5abc26ec535a191e93b8b915f49b88f403923e303a9acb4ed84ea14eed0d1aa15ef527bb3bd34450cea4170a79cec3cd419c5f7536ca613c22d89ee7faee1027d2c236e6dd7c210e41f6a359a61d86e96f6ed44175213f9afcaa3427788cc041d110bba4e855f2876cb5bd1fb6c091cec5b34b58210047da1460a5a9d1eabc0c30592ef1a437a8b74b35d19d30b31a70fab46f7ed51353957e5cadf889699d4ad965ff36aa32c02c122ca23990ed04b70abd8c946f582fc23aa4ce9141075d739f671ee7304b268a6eab8eef1eb7c7d70692f1675131f388df6518b9df4df4b6cae11c2a697281bfcd4d306e766353840fac9b5ba7a05332e83354b56bdef1e5813c5f9810a688d97605e417d849440137bcd6c9fbe5f53b30ed1fa1e7669335b7da4dae08c8cb1ce89cdfb059d89a1b3f118480ff313bb7c7d10dd9ede4656342173ce952fc579aebd30d162b7e35d02e18fd614dc451c48e13f6ea5b7904d73cce5a8437566a4cb4c94c9bc3c10d69e2daaad1b1dd83543971f35762f52fc965da3d56a064589c86ae9448b08920146107bb560103e802ef3e200340ab99097eefb1eb45e65ddc0da80161116e0e030e2c9026ff02ce495b65d519209c4f235ae7ccc947501c12e1e7649b6163024e90272485526362785f02e5b1a57a3b88990e0403e7b2e290deb29c27d5cb3ab88a40d2c0c03f94317a62f4b3b1dd0f5671384f9ef38ba211624e515c3fa9805f586d7eebfa0d011d2012358f444611c60170d595bcda5196760da3c2c766f97e6ac6faf1ddff6b43b8a264acad3874e4c0aa7c56c54eecc0bcb6cb2df45151e64c092af15c7d5daf4de1969a84075fd45fef291059ae5251686214e29872b3cecba571c9a21eda4e666d72728c3d71cea6be053e57bd5b0ee7a336fd8fe49f643b39c5228aba6bea965c88606ad3dbac6adf00e7bbf80bbaad37dd420bcf622d39123784c58e6f52b163adcda1c0ecd29537d901694d246325cf46c6bfb581e23eafe79451c8c89c613a662d35af626ef20f6cb869d0fdf6957990d18c395926c2e62f7af9d27431711ebaa86c2902eb92466245036fc2127b48d2381c1b162f99d2db401cfa18c769f4ff608ec9ac6643476a6e2682ebc4951157f1e9bea399a0b1a67d96004b1564bc7c231df8aa4d669338ea1ab0815225418f6272c1bbe52ce33c7f9fc0304ec3505023a9912d71c989d3bcd134726b1568e2433c3eb3997501e6ac9f4518694ff47dab87bf1c0e8d2ae166ec2ba59d7ce75ffa91875d49bd3f6dba7c5b95456fe120944c818fb0666db63808f6f58cbfbccc1e9224069daa03bea7fbabc7ef1c8fa95aceaf847e607d1578eed7c81a689fec6002cd376f9f9af42e8494ed40a8ae7455c70498639cf6c83c1864b425181dff3ce53802e5ae0d5420352f77e644f0d3f6aac27426e9ee0176d2f36ca91fc9002dda8fa091fe96a81552ac52c00fe853d10698927530414381880a2441e25f1468abd5ae85fd2e376b04279eea7f771a139a7b2912604b8c5beeefa0c7185d7da2359f0e41223a6bace0eda8459b9eb02a654c11a0373a07f4f745270c9c6edc4facc820516be7cc7c9970bf8207f30170664c225a71932b54839a02a0dcef047508a85d032628c47b1ded6510f429368ab50e3a79dded9984d42cbaac91660021ec952b2d89d94e41475b059962889bbb1d4e7bac6aa68ae4e6d438ca726ece90687599a944f9dee0ed71f38608602baf37013e2d5e5db62692f4d4de0e68eaf1904ba02dc99385443dd7ae42dae1714b7fd7737d6a803ef204a1ba7a8c999f61133b22e1234274e7cbdcc6f4a05ff20fd9feb4146ca1ff08aa2aebc97672c60a759d033dc8e4c479f687ab5bcd6d3345567f01f4c488e6fbcdb8c70690ae88c0ecdd768ff52ddb1c41925f6cb65ae13a3cd92a35c831b293f92f6172aa2584ba814df6b90a27fb4ee814186ee5a317361ed8b30783dfae9151b921935ff152f2ba4de2c737a8a36917661078937db6dcb2452c67200bdacce6968912c8acefa34d2e01341c1336255cac7f1e718fd20c63454f83c73c9b94aee3d36f3eed107e43b31e88eab1912cd05d31f79df0caa3884300ccf5b6377a3c57c330c626767944ee1fe25827e33ec0af6e635b378ed556885354b620795954f19f05a63f00600cab8f987e45ed04a33c960bd34c0adac66f920fed70ed2ba28a5df961c7864d052f55d3f6a75ad5fdcb3ad1a5070bae53ffb446e55a4cbc04cc71932080d1d0cd5704c8ec9a52061d12d8b6c6db6824b654db96c1d64851a25fcb31af9e1ff7460ead3b52d3c8df36cfd559b2e0ae148598c76c84bb5a1df70124a1ec724acfe45eb4a8993c0d58cf052f31fdd3f1e1741aedf478fbc7565091d5902fee65fcd8da8bf04fa9a537594ad6fef620a2ce822c878b9e4bd8bf1eedf3ec434902aaffe73799fd6832414f3ae29c037f29dfcfd34d4b8f92016a4f283f3d21255e7490292229f95424ce4db947a79b14721399764931b30b07805c8bf8997087f021ab6499116d1dd36829a165e4ed69f1088569d8e35e0abdce2d548d4a3b6aa63748071e0d70a8d3353f8125f70e2b84d57a431b23f534f413133dfd7eae185ee1a142e129ec63de702f25953ccb990f269f36f136e54adc797ef2dd4881d76bba89b5b2ddfb5495b3a6eba81315be00e7e36e0be46934fd54ae3cadc3dd6d7f5734f3528f872d03e193fc9903fd7a0fc975ce092509162463066afae06c61f26b183544d2224ea7c7f51e76b54c0bd89155ce38c1b8884b6eb03ac0f7cab785ac8a98524367bca93c235efc561bd9d51fdc7dbcaecbdc8d5a1223c38c7088334bf52de4df388a325f42ecb1a04aca2cf6fb2699ed8abb12562a41aa1c750b6a00fabab6f1709b962204144de988e91e7521f9a0c4afb1ad9dd90849ae679890c653618973faffd1d493033fb96ddca987fff54f5a1ddec0037d83173422e6b7004f7bb199a64866200b01f4f1936518fd58c9662b4eae9a40f1e44779061201b479cb29af808df0c2ad32039c6a636c0679aff3b95a670e51bb68b179c8ce8c70d662a3f97d423d7a3f32b03ad3827044d7799f284859d2665eed42683d6069c54c6a28ea1bec9abc5536c5d138bc8b9cbbd209eb1a55e4fa118d1f3f40428008c54f5231c7e177712e9ccfb12d5d567fb525ce2d0561292665dd5b450bbbdc87313a983d71551fe2399086cd7b946e25f3c6d83a888ac23b09bd71c40b845413e79188d1d1dfb5d23387f55b6d2b1cfb855fde6a4235b23daf42407885f595406eae2490052f3557080eed4516fb8f9e8700cc5a35b39f6114e0d147df5c38af5b72c98cb68b81af0aec42be99c87557413feb6b1b6582e75772f28c7eb5248aaa207a726decf9758ffdcf18de0500ece42ec48a2304ea5784fda9b6d98c38c537ffa32f6e0d6bfcbe44948d171d26174d002f9ae36446220f25542093f292e2bd8b239a287f93d696fca97f7f42ed0267daed891ab4aa51e3cc50731e712bc7ff8dbc092ca802db075a2372e2f7d2ca5e3b52d23dbdfac8e152fb2f3da1578899447187dab983137fb491fab3e481c1e703ae5d93828ac58afc16168fb99e847b01fceb8a5ae79608f4a90a390a0f2532b48fe8dd6ec9e9fdd874919e9e8888e19404fa3e229aac22c389d12ec0cc51c3a41a1a37bac8e9a11e4258205a88ed91c733f88af23569028e9e0b1e04491f8317feedd56335251f3dd631f9437d4222036f3629bc195d3c7ac549a40d6f413110ae81cbc21a44889159531811ad12c8f466703458d83616ec094042470f0f5f3b291855ad741b531793156439873eafae6cc5bcf05cf0f268f6b7ea909042de88a1d05088aeb1a636f69ff374a543623ccb10d9ad0737d4454c298d981a06d4b7840082bc96f032d5d34021364ba637f72108fe1051f902e0174d7e7e73495092b527ef270a4513947fa0407c4c81dfdca2ed524ae783310edbff057436e7b2c100f7e9750c7e80dfdbeca35b04a1ddf4314862c0d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
