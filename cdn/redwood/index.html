<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c0c2f6c35faf3a13b8a313b884087b5e27b7cca60922ad7d731c90ea0dfb4572edbe4979af91aa2c771ad3bf1cf2a25a25a120ce0f06426a7a9c370120f3b81b24f561ead654e62e80c604c88e8a16e95252cc173e1e8ccb60762adc9a83641a479fe943c12ee985c4b66af3df238334d0c6dc52b58cc2908a5adc9a3a97790cdb0e678fbe11f0765e3b5e487762b647543d5364879742e12630a5989ab92d9eb7b7015f6af8335f74ac877f5866d975da832957ac5ebb4d5328047b50d1b32afc5365071b6ec08c67ec90cad3a9dc4845a369fb285e2740f3a9a1e993a6450721a13471bbd427678b5fddfcb5030b7d24528906bdccb065a0a927ec25ce30a2b1412ce51a1908f43ca2681a8e72de87cfbc2261a98fc69afe2f8da85681cd8768ab61098da31348818d1926d9def7a50e38173cf3d5ced5185e52597cee5a48971802f5fd9ffb4d64315990d8c60962441604254cf5648b6c7ce91c4185426dcc4507798cebce576e56b65af1ccf244a8e07f194e924c117af4e97bd11b3d152ad94835258aed537fa4cee2e17a6ba12777ac5f805f6ecf4574c1cef64751423fb87aeffe0fc845aac22cd2d12082f35726d29bac50f150ef62594878f8d341f1b6c47317ba8e76935888e203fb710dc7af44745c518c343549a4970684c8e6dcc8a673a12f8facf7bde0cb7f82c1b6131abdd9501e7eccd363c17610e66fff6c1dc630b72310c5283d5bca573fd3db0d79376667aaa3363f639e37d78c5c7add9828e9b44d0beb239b5626e9a481de72528e9a48c891dff2a53e28f6a75ced4b84891c9bbf1bca3381f28359f5662ef9c915b3724a3daad709894f80cee5fed22a8ca937f69283d330b0011f669bb17ee5fc4c114126b0d178e9b2fefae8eae1a035bed7865a662940fa6c5ad13662abc9075fd7d04226d6772ed541f396aabaa470ccf1721a3b0d757e523e1ff895ce9ce9762c726068bee7d3ab394cf73e6c347b0b109dc862924dbe09b2b473f0271987037802f126f852cc1d84e16d0f431e663a8773032b566b7a6b2431c8757b0f01d71cc43a5bfd5631be3388121fc296e2e367c3d5082d3d91b0181643c914f4279617e4ad7b75ad929f7b32fa74e2996c0363c2df1365ed3ca453286b518626a4a99314489706e6a1fe6cdc28a4d92c6b70f39e1d82d834059cf01e843be805e2efc72ff80c80445213f86ec41700c584d9c9fe42f6b0a24d91d548d9691efbfce85851cb64a148b2f4713c92db2a1771c821bda47f732ef2266a6930ba507800ddf109d31392ef0f24f860ad29abb46d88b80663dab0a2f5f2a5f4ba0682c203440e63517102964de89bc72ce51890dd7b014e289eae3ec6fca7c3ed225bc9ab6e76b04d4bb730a34077e6fbad2f97f1f40a3c33f0b187176253ae656a7890c08086fda38e86ebb8dc19e7611c7204a3acdf6dc4d2278b5936d1ba3a8134d0df97b6ca9b7b121f31dbad1a2eb0f7f5b7785c95b6ee8f44b823c3df4b6a4f333c368347b2be7322bc578c0cf285abe6ca84b347786d6bed03787c5d5ac8badceeec1aa446238875584ba2b083d25b7ab2674da6d577eb7276ab979a43264f464ec32efdfe1e87c195e09ed5886faaf3168e2d8565867fa75e4d8a5e8559dea5e3c2ba50529c825029eae0cbaada9bb5c24a012006a70e0bbbc0697c3b3b4f493d506840e52b0614253287306fac61759882b98f1a121a296c84fd11e4d688c2d45841182ac9b27229e18c2cd0ddbef02506593b224b6badb375cd8ef985ccf387c278e78bbff25ffc6fe9ae2e60e9983b4ce0ca99bf7684c6cd8870c7930e9ca2563329605f753df61a396391f4039d98b7a80e681c37f220813edee9e67cb539ca2f64e5210fffc540d3f09076f946be460ba348385cacb579c89c5e5a135bf8c3f2038dde28a5b39dc606e2a3ab17661d97e6554130536736998c055817c1e16e838ce36990620fddc6eb5e584bf3abfaa4cd08ec0c0964b6edb5b284ab0d26d725fbe9b1b431309b58b655a0b1562b9efe7dddf2fc808decb0d8abbefb7c90437f6ee6343c04d914222b99b8327933d596de362cb11b8eab23c11fc3ba581a55d456651cabfd85663fd0c01857cf703c0ead0ece652bd8394cd643c1b6c585a81d5487860d094a8d2ff2ac4f03133ce399784ee22003035bc504aa6d095358e9ba8d742453d7e95dbe4c29e4bb996cda6da123f955df46f5c8bd959b9640f71f92b87a2a95a1049c6a810e10f980b22b535aa058d40c004945b553f51137c9af31c371580de7a5dc1277f025c92bc2e7a6301984b164d444656f99e811ca5c4d78d7ee9d85da517e67e6a4ae4d803069c258729481e2fb38ee9f90c400740d6765938fed88d22f99abd41d33324acede0f247fed15ad0643fb3968465355fd77e20f7c8166e2038a770d2dd10f5d4a28c9d8781c07139abe79c9f7532e38359bef0e52942730b0ea89a190a42c2098cac6f4697c37a131f45cba6fa6dee44f57419e35a6b09b7bb0eafa173a5c1c993d80c5ff82c6c3718e5c66aff9924d9971354c3a11ebcc2cf994e9111c3fba0f964f745bca5b7f88a57af90fe7dff1a5176a877621474a33c8a86f9cb4451e3a0ddfac0c44c5141e5bf5fcecf89d8e88f2a04c3fe3f266b39d8d9794d954575aa3e3f3c040f69796bc13760b9b42e152ef6813f514bce4a9bfc4b357eea19e105a862b5124f51c37f3ec8d443a3782e83e170544fbc36613ab955793f68b30df69f386c25141dd905ca12856558f3e70cddb68fdad913aeaae5919011808cb1998c111ec637367b9b10da70a0f7f04fb3b489a75cb0f3651a999d442b5831c6d69d3e50220d85022490f555ca4dc804cf02992e65b6f30734087e738fe84e5e5e1f087fe699d822ba665447af7844607a83d26480e225af0a6a2df944f39227a049842dcef598497d67f8df45b7b612b1c717b9d0a7adfee02b3d68c63b6695f08c917a771a8171c4cb834d330e23c7f0bde270a95e79f76135089f19e2879af6860d428e92434005c3303e594ac098000f673bd5faaeb139808be2cf32593e15016c3e8fc0d90052fb6bd4b481cb4344e99e3bd5dc9e399ed9a3d12ffc5a216eef405ce46d9059280f5d595a95f99728248892cfd2f24a7fb91e1528a1233fadcafa0aa3ed7ada08192319400db8d9f1f2aced1fe06a9526ec84c8bc7c99a7f3f0580fd477d74be516e11f04dc0428844205b38e1c1e7bcf8743736d8b4b3b98baa7d76f7e78a2bfe12dbebdbe17b4ac6707e5aa3a429d7f10561358c078ad1aaf6b9c01dfa7250b4bd3fa6f326e875b5b437a78afe1d8aec81caf069c88206777e469cbb4833b3e0a9b173b34624aa3dbbf3a97be2ca2a6c7982467dde92436640254cddbd46ab7a3a90320726a51af9be0460284e8747030380e85f6ceb4c9d9e1bb6a9567b51976fef88fda22bfb5c7d5e3d8387ac9459a3d603d64db51f3e2a6bca737d073a6946b423aee79a0e30bc96eba22bc53e3b6dc4128ddb832e080e8486debfecdd107e3e17b4fc3f4c88cbe5957b509490c047386242d8016b91a65bb47602df381a002a825865f7aa2d4df6616fba4603bc14c9827f479428e14df4b4a7aecd76c178e481e5e2f8cde002db26ddc3ba1dbb79c2610f925d2036fe79f0f3fdb039f91bc3c9eca022913d8fc3e0eb5b0ac593ca31f2898829123ea4aff7ed6580c142506ad378ce91daa3bd13022a6f7d5e0b6251e5009813652b4aa7599cfe9e5076864d36c1c624eff32fc1d5fe472b98cb9276b67f8f68a6356280672abb2872cebb57fbcc405c19fc4eb5207bad4c0dc13b8b6d7c0b1352aac53e943218295fdae1d16ad50b78b23bf16387ea6258513093bb68a1ef547e83198a974f5c2c64de2908311c4af65cd9e1a2b6ae85f9386fb456780c0503b77fd0372746a35d6142acec6bb0e26c85c176f03e622b31ed55e3a2bea53364370ce6e6716400e805b6568b9a6d0e1558712d1c020073d3df044bd82ef8ea34eb670f1967e09e4b9dbbcf7e8e984e9f24712513491b19495cac190c2239c1ca9ce57da83b50667f845f1b5a1aa30aa02d4aaea7f3b9c3af2c8e73c3befb787918df7677d8d7678d350b26f59f57c23cd669d2c731e1768a0080a5e747e4bdef8f2d971ec6139177af874a026aa7c598a641414447794c23c39cf7034d79ebcd1f948a5c7ac00873c43a9ebaf4e75f176ed12f0e4a2de4db07e2a0350763a9e99db52f67941ac5c155caf8d899e06212d0151e084ec6bd25eb313f274b6e4354d175be14ea178364e05c1ea4462485a34bcbcb781069d1109fe9a8d308d903a31a6ce58e4d1c9847b3708f110a2a12480f90cb39e76114558d8bc28d0338c00c356e8bd9f5f988f574c2b2bbac9cf72d561954e661e6c87a49b46c2f2991d17935a70ddf3d6dd694475a3e81b92de98e9180e31d270c0d3ae9229e4ee3ec06f012ae08ed338fa27dc5c7d8e96edaf23ceced8f6effda5e2dd27f147fca44b517151340e6def616383b0067adf56cbf5885d995be2265daa986fde9cb366f79fdf1b2774b0f4842fd2b6ef05587a1681a8642fc5a7b6825c7220cb5f96cea15fc3f76da28af5cec64c3b76d1b233935b1f4ef0261dc22da92c74eccc6f5dc0d6f6d03b53265545d1a9d390c2fc6df3ab938160edcdbf316c9c34cf11a73c38c3920413560299918d2ced663d4a9ee5414517c803a29c003df03c609321ce7a1a01937dcb6ffac1aba36d2dc4c1b0ca134553bb14e709a6f7f92142743e66c179239015a58ba1aa42a72834d9a86eab6cd06a9c6d9725b801ccd55b3ec59fc318b7c7059d0637e8ea5b7014123754f92c7a319da13e13f31c675849e95c261d733d30e598c16fe12bca67ff83d1917b7480778f258eece3f1b2feb6c85991e956644d215b34aec5bf63c255d0e5a87d5b6b97e825d643dcd539ee3f5af13c14298ffa9015f292aaad7118b2a53c6124b1e230c8eb0aa3acfaccd00089f3a3b5ce4b82df77979071c7655c2e79b1ee1c0beff2c3dbb97012544126acd6c52b0b53a4b0bd40fad5b156ab20f36dba14af9cfa49b19b67ae145037513c11277e1defda2e3201b61498eed221f9da6f36e7df6464b97c00c82067e6256171c56d9a8bb9b915e2e283bee85d739153285a90929ec06339d29f80db3e36abe28950248f236c42c569c249a8fe9f138be3daf4117df3e508c4beab6e2b693b89f2a1fd6d88dd4f4535c85cac74abc4785a10bc66b405c74a03c48884c026264f2a491a03080e06dc1f81e05ab4d0bab971049a48e2bcd68fa0ce1c22c807cd70c062a377f5f676a71b98b1b271f682b5beb76ba267356f84d360c329435e4d00c51b63348e2511f24b6cffedea95d83ba55e2c10cc47738df98e68f70ba77e62352642289f30ce2dd80ed9e5b4e8583313d139636e0e63d47d47e54249cfb0ecd785f2130b0837068d76aed05d9b909a445fdd269b102bfac16b765b474ecc3b836b96321f4975150d4ed4e165a1bce3db376ea27e03853b503bff81b4e3d5347ce68ee47219f33c3eedf5b5cb27e6dd7113213ac7983e898e197ae07c7316f870ffbc340fab2483cfeb0eed128126f680b92b46275f853901de11ed7a7380faf121441a78fb1742e346f7b85204d67dfb4360c83d2685e179fe337b5fb077c80012642b6bb0f8c4f35889ace39b1132e9333d4b527003ab7ae50ac2e6b001b84e0e4b878852b792118ae3954afc10c8140f56c567f8f5417d1d565672ec3058ffaa1147c2ff50ab0b449d98ed6686498052a4ad3312856af751a9a9c0b321af8857e22141bbb84eb63b1e15be289413f77a1f0d11eb68556366e15b528bb96c24f7806c69a196c6e2c29e5f51dd9014fd6720504b2194e8503eb0fc557ddc5b970258be073182edc0ecf34710dc541cc21e1592c3dfe5c813e319b43d6babfd718606e2d641729d915cd45e078a49cbf0fc1b1baf48f284287407e7888a31652708625af3743d00e5e34ee6753c0a45b62ff8065fc868014c3934a0b366dd2e0539bbf3c9391fca7e89fc4836d951e3c08978b779417196b8f246b46464c49a29bbe569940ca47500ce5c6f8b3c46f63431f51daa0248f581b8bf23f3ff4fa1c8b5615ded3d34d4b2e8d2f385d31d8556fb96d42539dadd23fed8409ef3eb0a3c818ddc691980248b912e0e18e8c4a5ee6858e210e739f518b3140c9dc7f56bfbffb6791961bf7e1894a5042fec0f4eaa619ce3b241d91fcf4f2f058e4042e77cea685dcee07599188257a1ce39e808b362d00eabf0b0604540bbbdf03c0bcdc3a45f4c97cd627498ede04243c16bcf1b0423b7b70929a05cb9fc1048cfc6dfd4605d28a53ae5bebd9e94ad58bd152aa31abca3f12ce12c8a1ca8304ebfc34b80d5844e33f39d6be66902200345b64cb2b9f3ab5c81c05ab2586328622d2413572dfa198340952887a4ee851ba5acd1312758ff257b233586efa219225224662032ccdf89ffb3322b02f3c9cf63db600b8c7a4f06f7d382e3c2547d17533647bd624392d3eb47bdded359961515775823189045e1d2e9cccd8c5e671c792aa41d75b6f50bfcb6483c910600ae82f505c29625f5c54102c53182eee6ca032ea0f0b187ba170b5bc7ac3c8b746f5453043550195b617a622db30edf339b55b20fab92b50238a19640ae28090a8b2b2a302200115e81a50eb4b20574ad19179d9ca5a6e855696b438418908ab0edebee67965d9cb3b59e22120c49ad185e5831219ceac4bc2c6e5764e203968cbac85c5a5b08ddf0fc2e92c953a431606f2104f3d522d6ed86637eece16706f6aab589a3c992ade7c9b3a10a7c42ad2e4e791259a40dfd2d2a7364ae73f693424aece3b5e93b74b728be7d380d35db6715161b4759cae5ed0d9f2e8e58aedb9c8311fa09ff28ede75b3572f8ab25c6bf9dceeeef23b782689699f313cc4436b28db76e68d6b937a3ac68b2394ee15de313ff0ebe8bbab600cb6108e47b4a1dbd2d29813815ebeb41f5e621f274e92dacdf11289e57cc4b24de89534db9edb71b7f83c9bd6df6fb25ccb58d5a8cc7953782e04de085d863268ea5d841b8449f94184ff98ed30785dc0b9c1a3b200cbba304d2555bf9a40053f77f02df80eca64db8ae3ed29cb27287cf976809cd7ea4e3989587ddd73246fb8ad6aa3f6c4fcae944d7b8aa859aec1d525eaf9e0cea8d4f21d2f7c4c1aedd230964c51ee6d68de06ac587a419d4ef654e1582fca4187f4b397aaef433117031bd80751831822236c50935f3245dd6009c00c37ca89c8b5d6181acb0b19d0a13a0f6f04ff3697a7e1bb6303b895553d558595e55af8f676e091499eb3b4a9ada33095f0af318ff81810187640025d4eca82fce7d2e1048c4f5b2633ec2c301928f434c19befac659093f6eb920feef8e8db67a44b0353528225bca716902b0587b013a3e892324f0e2eaf86fca381485e8fbc9f9c298d0b67004b0340a918da62a6393b514fbbe50de5edc16af1c3e15476e09710275cd79bb6a8c96a1e2053798bdc3015a4f27b3c6424dcd151eba4ccfd91ee3c1b2508b36564a327746e2f4a8f4c77e7780a6aa3ba96182e9cd5a78ce44b8094fef15ec3599edd6ebdcf955cfe61e09c98a76c7ff4f4fb88ee704fe235016179ebeaceb237d68ec49531a471a6dbd804789334dc4030f9ef06d1c17c60227c08474f700e5b0edc63b34dafb4cd0867cebced007c8b0dbb1b7c4b5d2d9934a9a5a2ae743176ae8cb86801b374c3a8dae28e7fae7a8805ec5df384b6258ea135c2e12adb92babcf437c327c9ab6b624f78082218421b68f31e9e4142240628b4454d7690e9e0bc9c63456feb9053c1fd06c3a388d065b5df9b746aa45c33ec627aaf409fa19b07d1997942aab2fe744160e88e12ebaea771ba3cfe17591a70a7f4041128cbf93213b4becaa45d214b8ac2bf351ad59b05beb5f75c865d35c3fb57ba80ba0f7ac438fdfd68744428e2bf73c2d74c932cfcc6b88b3bc92567fc980a176ed2678717871921228ae64081c7baf5b1df0adf322c9f8a443bcff7badb1c001a676528fa30a034454bc2e7940a3cc6ca1bd264aa4e57815e81c726ebe1d12c36f109fe1e61d2debe6cb0e8550e477b94a6294c692736685a8758bbb7d793ca7bc555cb7113cb710022f508c7d1cafdd6e862d2551727289d47a6b61aad60b8c0d01fb0389034905d798cf61d89cb5ad681842afdd679260c7e4bc56f5c72cf7320481e405e6d9bf3a4847592e6044fb4e4f2e3c9d665ca164feec8e3d0c38d7fea97949b563e58d095adf3112adf26fe6b25a4016ce4e09c91f8b5f5cf925d039fc67347ad1c1ca0e1ec46f4bd86c54b60c9ea96ebd4d7ad3e5d89f2476c2b09bfcffc2cfe41d580d083d34b83daeb11ceff0f713a1ef0717a0f6cc7eb5b879e65eb38c3587035d45b97b3e5da10c7b6bfd0d7677c3bfe5079ae92de03fd9df07a59529373b422f2e5534a543fd8a82c5879046d905e05a0453ae7d9bc47429def76ed61b8c2044b8f0103d37411f2f709ad90f490b30a022a91617e68acc753e2369054ced8127598c3268b67c56ba683bc74cffafaabcb8ffa967cb584fef563556f902c316e4e0b0300faa4bd92a69e4832da8ff35eb419455febb6ff99e9d17f97fef0e2adeadfaddd1bed2a5928af4828ca334ad948b1b63f4e09d56e5fc69ade1b295fffb9f2769c77e7bd62ea5841e08d3f29d474a82db789f49ef7553e3b208229c4b1e9601496c256001b6686d27d1567b528f5f857a44f821820e04b52570421314cf35a996449439cc2fe7de616ccf7119859548457575298b245cc31e34d7e23621fb3a6974684d40cc22e4fba04d9096de7675452054990ae2c98f6fcbe4a0493306d155adb1cfc6bf027a5d86ad56c5b81d3f103d72340e2ca732260e079471fe4a87721a903bb9c809d1f8eab5917c29fb5c1eaee4985d7bb9a7456d14bdc12f551adff61a3359782c712cfb7c2a9b4165118a0a2a2577fc44292a5d97400e16660986238b8c0a2108144379034fd1370556269c3aff31c2ac4f4337374bd5ff1d9f3d5da0d01186bd303f143bf02e9678722400cff65088ecad828ad1dbf06414c8a6a3e60d1d4097fd0f5b5ff1585633a3ad7227feee573262cfb50840e1a503ae47478135f07f04cee46536c6584bbd28b92b68b12e25ec0fa2c9fc529946641717c449c5f1955dfc49a5ecd7c4fbb8730fac354ba7857320b3af3c54b426f57934729b5fa7364010b5feb0eae3a448a71bc3f253897bca6942213f4205d471a0b5d3424a33243a9a69624a884d1d46430dcc6396f38ac3bb82743b0e07ac2931b0fbcc88dfd081c6df9b18e3f7d9a58f47db886f8f144c959bf8b9fa65114adc1a2af184c766e1969671bca0bea7b1f7a7afc864526c0b046749997af6548e74393241225f61d3bdf5a7e1e4f94d6aeed2a297b71dfb2dd44b076175e02934929d30d0b1fb9193dd2df950953ca2a5b45e1d7bf93e18b9c50b13b06dd9af64ce0c53274392c65d51411a5816d9466c9a49e352f7195dd8d0955e283dcf94532b646993dac9429c97d49d5c2662e88b2541ef9f9a4f598e68e4be825db32b69d0350ca2bf6e6418dd4b63eff8fb6b729380a6cb9c607804cfd40ad1bca5ec9ef079211e7afa5636a4b0a6863bd9981067690888db2bbfd0add1d5b0b58c1d2e59bc871d719349b9ca6f3a07e2a0029d357dd29a08585f3b6ab883b74665c98b95aa7f323cacb4f78f9a46890b65a1cc0cef383d95df71231b96a0448e0cbd0bcf2a307910118e68ab72efa0ab3968eff4c15bbe5cc12750dd4070ea7a297153305393883d6a7f8898943e619d0384d7a21b6d9ef5feaf59e7d3b69331d68451a900246a51a72bd07ece2fc45527c986e90173d1d754811bd4fe05e84ccfff7e8aeb49e2a47fdeb60e206de7ae4e663e125438cc0a2df04d4d1ad6c604c92be3308c091f8a0c4bd490a3a6abf014c4c68d60b19710a226ab8cc6886eb403201004cb43d9175d8cfb3ab199970fe7ac0f1b0e82f8765c3ca8c6f4fd1b7132792ce3414083fe9480635dd9236c87e9889f121f28847b6e665437cdc522c6251e3df228f35e705935d885e0be530874c43a36d2732a7cb32d37f193d8e450fba2be9f40ce88c9422afbdfbdcd8c1be40195311f1eaa1e1fd35999bd78c2a559c64ad2d2e92abf6a084ab62de92543e7c585c009c10150647c20172848e3d4f1f5b86fb28b3139488d7adcb31cb59d02c24ad0951b927ea0da7a50936ec22a810ddc9f88f6666b6cf844d671afc3fbc8dad2595ac48e10b7c86b205541bcd233bc15dff1e95b9bb5028c46661827399a98596561213350944e8332324e43e21e39f71ef5ef252e9e0f995e6c6fa153391cda47155a468aa135f7afc04eac827a5e0669462f9fa3797552bb96b2b68e1a794e4e767612da29463c3731ad7879a3b9aecf5f85be9b25252ee9f660092c849abefa0f15fcf7950e28ceae710c12de83800a87ebbe99dbf94d0bbe44f67f87e83413e2aebec4cb55a37c68cb02c79dcedf3344292fd4fe358e83f7ad694765596d3cb0c4c594bf7ee0094f384992618ac7324b0ac7c52470904b52fc0f96326e4902d7572f6245176b9b418c55b8ae4eb10f1aeacca711094ce073d338470dec1b3e03b4cccd6daf14b21558b3c2874a7447e5c1d38fb61f40a992feddb3ef6726b078056020a6091cd7e46befc3bffe2867ea4a9716512a8c20a6a66a6e7f2fb45957c41f23f92ddd608c749862f3971df00b5910aeaca27c9d17f984fb6d0b9885a71d6693869da95b1a5421c4838c8ea9cfd43d5d0f1250f1cbf8bb21414f88f3bd630fe33a9416ae55751e871cae69b5518b0a46c0fe10c981bc0973a6ec5a8028318800af8d0c9b56e3f59895d75bda57253c9c2a302faf18afbb7f76c071ba7dfd19aa1755b1f189d674b5239a6214e7e2cb0c025a149bcdc747d8dcb73a4147501a8d0408456be718494ac1d710ff21bb44454cd2182b7ba07f8adc088645e975010664d73ea0fc46f1c152b01f5fc2feeb7b1deac082e0aaa332d039dd74dc4b383bf410fafffc059c9ddc655db9d5adf8d52d945b782f60e89d319c091eaeb44606d2d5c41eb8c6d244d9aaebb28028117748585dcc2f9e7a2e9e41d91f35e8a200ef2735bbf7864f6d50d6926b46355c36b2011070f9b9d03d676610b6d7653a219dc4dc1edaf3ae551531188a793a7dbf05a2477e26111ed5f98f3efb7a80df331868a09cff3987487a53d94242c16ed90f0426621d1e7a29880f1e9db2fc996768cea0b76c42294754f352c048d3674c4847816f8f944fb5694a24679abdf181b2b00b022e9cd52b5e9577146ec000015bb5a2a076ea0fde002328a83fd839d3077395c91ab94afaccf753742e405e5defcf540219a71b092e171750a2573a87e776b9cad118109e2ce0306f2c00847b3e46de34d9fe64b3c8e50553469b8e0160f60cb66ac074a342a2be3a8e27c702f350dc33363003f817d0ffd8537d4e1565ab4a7835685c33010cdfdef7cf3151e9a29c1f6b7814ceb6cc126b167b1ced64741f6fe7733a9849f1f81c009f8e239719b11fe89f1f1c1039f536edada13900edc475aaaba702e6172e17600f477847c29fe7e2652c5848979f7b8c093e46d2b00126d563fc697963ce14d405dd262d2e7444cb9baa3fe1bca2cba30783267d31c031ebe9952c10ea39bf7dddcb7b2ecf61051dbe8bf18dde872bfa90eb8e7e4ebdad498e1e31bae0ffbcffe9e63f7ea984eaa6061b1a4b37beded315516ea25762494f009cf0fe2824c1567cf1210a1f01cef74996952c09fb76acc4f90936754d4953103d7314be9795dd39a82d69e99f7edb8498581e0db44c800508b42b0b2a5a3077a1a5f36aa90156d8b781f4c7f5a652a2e59a0d4a0d652dc5c4e02c8d353ccc78e3ce243c7d37591734b106ff049e8c8be714cbfc0dd0f6d76f6c696fc13c47d9b561e074587e794ee4c62dd1b8a384843f89cfc8262dcbf6ec8e24d5327497877a9c34efed345915172472b12fd0ed2f0136ad69bb6f1bbea79d4d74de2bd5589d77c46a93468e2ae0f54bf65455c8b429c42371d38b2401d75740713cb85a69269016624dd34ac814f557cfeb0d8b7f2434483ff2483fdfcd5b59595d213943db30e8d13e14d437b43dd4347bbfce2f92b83f7ca7bf241a80935e8ab716b5f1de25e76525a7caded3aba7625bf3a0f786b1b3ac654872baa813bbe523b9f8d697ec21ed384abef0b2653b7749997df594a4db48f39f84092b79b2d32c798298813980ca5e80f85282d44f75fd4bd7e709952b0f992c34a660a3b9c3349b9b7d3a1b56cb646b970e6e24a16e3adfbafdebc7be44a681f025fa205fdb9429ce581e3d29277c91e987b6cfe40120603992d1677f228dbc581dfa8016eda0a82dcb488d5161ff9c6ca5e3b6a3dd80256ed821929ed25180417abb6ac47bcffbeb2853377518065bcc7214e92ee089800270b0a65a69748136aa631f3c944c030d57a8b8e73a4f192612e06854766052d950b401042cb1d5914fa152bc09476419fead6ae368247ec385ea4185a43ed0b4483a9c3cb0822232888434df40dcd71b04dc69c9195ebd7e49b1d3b4681cd69a1dabd0f2a6f7005a41f48906ebbd4c3fedee19441caaac600c6b3111d953b62b7f8cd5b6011d51a248133a66ff31b03b14646c0987232995bf858f5a7a8689c7bdc248491eabe7975e70d159da907778c45f49f414ca2aadfd6017b48806356279218ebac66077e3e21d05f5b0fe4db830a1e9233bd6d78bdcb72b727208f41d90cb0a88457d109c71df0b27b221993a0cc09d389ea5ef30e0ece17858c0f42b40c9fd259553a3a8a18ec8417e97e0b9e9944ce09e2fec163f8ee413d4d31021e992b16248d3a1a01adf36e8cfa4d9c8fec042d23511200099aa67d666cf124ffa2735ba1a559d47301c04587f4d346a777aaed68edc866512740175c955324f8cb138a9215809853384cf5113625c6f118332bb6f53fb1410fac479f64d4a23d1ef5af1262ffe31080f18b558419b70e04946d444534a2a84a528a4f71cc7ec880a63c82dcc0fcd102f4e46f6021ec2004326c8817466f5c1b1a595f9e80b5274679b965ab22bccabfe4c5d028ade4066bb266a16e7a3cee2df5c0481c4e65550216d515039eb293ff702a3f93e6195700d95e21c36fde63b720e749a57f8a96929b05a6447da6729e9a2967e8fd05487840068b8ec184d37641672c3e15d731f61f1c8ee64ae946bfbe55a83ce9be01ebe9cc65a62ef38cc20592654be33724443a1562a3310f060964bf701b1a309768cdea73d430c57fb9b5b8303c3bf7aa9eae208f48812ef1adf23c1ac2b2bea48e95ba2f3a0bfff0a47a1e748f0e71703de720aa1af62e7f3824e399c513c839d1710250eeaa17b8775dbda9c3f76d967cc67e4f24e9e183191e947828fa9cf84962b486e61e58ab1d2ccde90a8836f54b6641ff9c36bd1e0ebbe40a04d097702adb24cd4298740252a452b6832e16251ba6ecb87351178a6481c5c946e210a3b06abaca3c7ce9a715734d200f28c4125a5acca49f8c2603011995b3c2a84b3e4bc35d35331fc135818397cd551b75c396caa914aa7dfaee50cce1482c1b8b83a7f79c0eb74b4c418c3edcf31c399cae7f126295445c5515d71da4ad47c3acc776c4dee8abbfff6c01b2aad2d5ef19ad94983525aa3b46eb7f077f8e7b6f59bbac6aaafc57b6ef8d822344e553335264798eed20d736c6419ceedfaf63e86b71075729e7b94d8686717dc8621e67c49067e2f32ae02c2b0ddad7268941bc03c8c0db6055acaafe18ca6fc7c84960fa9bd2d34241b81879f2b91a33a7bcb08a9f366c3830995c1ed6ae8c185fc36bd2729cc430091489265edb53df2ccace134c4cf6af2c340e51dbc11b3176b237a7089c7adbb2bae18313d2421e925360e02bfb14d0f83ee00acf09dffe1b04737a96b06dce6655558dc9feb0fc36bda4f6e8e250cb90695dc0c51525287e0b079e3aeadc19ef603b9257a7a80afffa85d0bb97fdb327e5ffe79baf99efb356ec0d21db10ea019da7a707241c76a6e3ce52876c90211c375cc9a716df607468e3169e29dffa42fcdbdb4d2ab5dee2cc526a573737f5b4590696167758df64ca6468975555ef84adbc39da8b8d90a8dec1abb05a8cb37139ab2cd284834ece928ad673479ab6260d0193432dd7b598500a2711a4e59229fda6b093130924f973ed027d437dc9d1c1c5a8402537b12a4f81c0166d35f8e1b32759db0f5dded293654dc1790dc74b68e785d986ca385173105b4947cb536585c8335431db4957a068106c894df6ddcd188d885fe6e2dd72c0e5ec07b5a5bf31f0c14944b010941f74fce5d923bd16ddce81cdfcfe3ee9a89f88d493d4d660272c57594ce0cac773a8d36c8e3ed7eaebf0260168143e19ff224a1fd3ac2c3a1db3fabd431722b0be297d60f4881002defe295cb0b04df84d0ade99de3ea129f4716b547201ba803e1c7d66427725c27a565f771ae91b988bbf5ac50f773e171434a0ae95631248c3abd3f619bbe4da7d265f961dd29b819efd5681b0832839d1a599e22909f95457adb6b40d907f2e94c5001e45f0ebe544ac9e53a68b4c965e2776c966134c882b6c0d7bd4b53f57e0570b8da512ab1ba4c3ec0f818be545ddd682d11ea9b7ed9bfeda565ec07da81753c53ff69da5b3bf389ef38dfc0e0e3a97ee1b4f2c350d580652e0a554e8fad9b15344bbbf93a069d335e1155b26d784f5f5887214cf865e997fcd9f1ab6ec065ca627cacf70085643d7ee49e8bf94bc2e258e6e6505d25b741290b554bd7f9251bb0e8f98f7bf117f57f2866a49c52c5c69c9b079f686ed942eaf348ce5f0af7f3c8b1a4bf694babe7bf6a159a5ee8e20b16416b0a0007d815c85883bf4a834432ee380180a49b2d40f09f9bf72b5f6a13013aa9727017ec6ee2791455c7ea6e9d3a2fecdf6fe51eb5b82093ca759eaa73ce5fb914f1fea202b44de6ea966f0d104c89d2f016769741b2d75501dc2c001a205d532041ccad82958cd285f2c2a8b6c725629f06f431e35479bdbfa56859d42da356bfa5f5461b60eb6b9722faee5ee7ab4c374dd48b86fdfe47de7c5967733beb9fac1a7c6fb73df447ed2a8f8421b42303d178edf943bf4db737617a0f1432e68f314ecfea02b8dfb92fb2c7f34b849c59cb0b8b2710878658f82a06b3f1c17dd55d1953c36b354597f52dce9ac9752fddc1e7d0deead6578da54dae190c0b29a5fe6f25a95a862d1131e72d6443265ce090ae79f1e9c4822e45482a86f033a3665c1a7783aa6a9bc2aa81524f6706120f3b29bfc2b0e0431dcbe3dcf0271fb275e2338a87d0ba7e762f0cc38a2767fe0691ccac0bc1c5f5d15ebcd3326878da229b1667b0c0641d81a666e6f8fac22be2fb131e199bd2966fed23a022a1e87ec3bbea08ff6474e9de6f5a07713cfd5fd764cc6b61067d18a0472b9c549996ab8f94a6cb5abce192fba3ca8b95ab596e8925485c9996eb7cf34d2574f65c90b06a00ef1694e040ebeaa12351d6e8d47e18f3522ffe113d8127219e37f1d46abd240b159731e68c7e6f0bdfda427e353fbd1e568929340c7998e80595680cff02e5d55cf377cffb6d5de0a7e93997ec4d58590712daf0dcf386a8ea532f7413364ca16a0aade511b94bb335972afd615c908e2bc513437578bdaa5abe5c91a282e7b9efd7c65ee0465f325212080718b9e30f469fa1b1f8ec8930589f63a244a8c413dd31563b93cea66f514cecf4e2809b2029b45f8a0aaf3231a6933d327cae1002257023550b77b94eb024ace968d10ca37fef58f1cf63566e73ce388a29dbd6747ae68596c694dbd45b5a09eacb5ce15c2ee669641d0c03ee332964836ccf9966597f0a01068fd8f1ef1a8750d2576d66b275e86a7555beb88d116142b60e880acbeb0143d6e837b5aa0d34851bb7f5dd857288ea1f4cdaf40f01fefe5b353c86d6cc2e4173227b50ba24b785b39d81752bdc0358a3e26985bf9489d5b26f1afa772a8d295e5d3b3082a5fd5aa51c2b1f5b0a0267c4bc82e6c2e21409d5a1713c3cffb0bec43e5d4ebb9b31c91ecf4eb73c8d9345affd587c7ca7ad35b7152b9c89f04f516cd1c32aa16fe4d8f848639127a3f579411042bbdbef4f43e56925d89566eaf790c87c6907c4ddba131d04649bb3d9fc45f74237706996b8ab6d703967f1a62b7024c0e1d9da1454658b3d2b59f847f306b9055b7d2106cbb4f172a3d861248b46849ccaf2d7de7d9a86181258c471fb16f513df211b8c8f92b727ff08a06d5b1619cff1df96e0f977f40f7668acefb2542e07e496fb155a740a4847e96bd567693fb11d7262aa327f41ea74595d69e208ed0360a38afbb08b47a906a9f51d8602b1385716cbd5a63b34808a694d1cd1ebe9fb62b3452ee01b6ace6dfb3d3c81cbc98ca006793636530a30f1f8946f5a0d417ca8073f0b3b12462fdd1678e833f192c22bd8598271ee7ed305e5d7e1a0d24cbb7bb736b9cad67447f8cdf442726d0e6051dffda9406a0844f892fad38575a90deaff26b9b73a2da5519b1daf88b582ea32832de59d5a2495ad380f9a49168c12e89d0dba070d1086316aaa8400db48f74adf3438d64c23947df015820edb18c9d5bec82834375c4281ee4be550ce36644000907aab2590d88f027a34fc6a3fdadbaa28aacde2af1a560e831af15c738fc449a160eac09a88f69d72f2ecd2685a2aa4ebda4fbe5555629c269065de85b1b344993ebfcf4b8338cd39a1d9338f37b0aaba87a719ee4dfb804dd54699197799e0dc96d26e8fd40b89e13d5deca6334648d1dbc492758840c6d0b7e869e392100a4885190199bab01a1415e86582a64e19672ee6c28c31db4063d47575dfb636a93174e5c901b46828a5a0d393214be1da04c0bcf299048136cd6d26bcf1633df7713a7be39a0faddf84ce8282beaf9136069a43d05c3632e36f0cf12c9aaaaf4e6d0fdfeb93b1ece25203164a5daa45e7c87fc6082cee303bfe423c088318d4512054a08909060a95c525581dc63f463b1f5e7d070fb03c3691204594398c4120d0ed3bde95bd2534ee89d0e7a38400bf7bedcc11040d7be6c70be328d2578ba05b439eb334eb287a9aab795b009019b55d19206584f3b7daea7dd7e410823b97cfe07e4dcff8984969310e18556c5ec7cde99c9177aa876fcd6548a59c063dbc3267e89055ac67485ae2170075b7d0537e7543006e4572e550d1720dcc9260876467930c65c6f58cbaaf1e76e9646affb3edf54f043613634650e6129bcedeb6c41c252bf25b2149c49a67f356d8a90511665fb5b17a42f87e76425629b835c2fcbbbb3cc94b2e33c4c02f726786eddc9e84b686e7d169b152049bb1550605325743ae34e7475fc9bc37fc4c73078cb21a3a00c2721138320cfeca1a8362bb9f7a63443931a94d06a3cfaca20b74c7017e0f7d007cdc97a3fb172ef0236491974b4838cce7ec43e1025fb54271c0b5c0e1988440b47dedc25af958eae23194a96600b297f7ace71fc1a79c093f6075185b1e06484e3ab1e9a550b38935e12d72816270ebbece688873bc153121ea17ef3625843dfe02c7029a801509f97a53a4e79e988f76ccbb8f329886b0cda48ddf3428afd31b5ac8a780b1eaa16ad7b2fe2d2b0c1f26072ede17cffe9a21cd96eef1873a090429386c4bd9bc8332e11ac5243e37196a15e11d2846425ebe027bd0e0257a831e0508e7ba01be7f5b1b1ea7904f6136f0742ba2d51ecabf3ec13279856c5beebc6369fec95de10a2c3358570987edddefaf6b84915a853980bc73bf75b78af686a172cfc7e49540095fa1ce987f024e92fac137c42eac37ec717aa101a69a06c816fa9ccaae42da3b12cb32b0d821edc4b14f472c717a285a52062d1fe","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
