<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"076786d984dbc0f24c224408455de8023cd1266cb95b321f7f920fe1c2b35c731d9ba635f22ebae7dea2c3dd57ab2df41e58c74f5bbe840df6dc49564076a91d9b0b496f959b0a30d2f1f0a185d1ebdd51726490f4d890f0bf17e459487082bf1096d56d4c99324bb6ab2934b8fc1c5a47d9757d3b6bad41e7c021dcc4a87c49a71bda1940f1334a04f30ad59e16e7e93e352d40ef64d7bc45cd561abcb8dae35db5bc93a1afc10cbdbae86f438873f7e1d56ab69732ef14dc5038fb230422805f72663fd7772ce72c4b080cc16a3cb60e555b49ed396f0a90d937321655e1f9ba9fb363e835f4ef0ee2bc06ff62969a2304d97a31258eb51c2334ec090e6afbe3772b8e63d1f878b98098a201357eba1bc4565254a05990844c31e2761072b8881737c8d9e89b361784335bd4e2bd9009bec664a10d224683ccc679dfc6fb417619c94a920f11ca8e572eb570beba45881333734405991b344fd0a796316c572b6baad7a2c6d667f7cdd94964d83d4e358fdad78859ad4b4be46dcb1ec38d8511e7535445aaacb34a95ff36ecba1b782a63a564f8ddc829ef4670ac2875298e9811cf4ab1a74ec98399276a3d1c1a691cfc654247e8205de6fdb55fd8af6c69044fccd88bc7d1e27126fee651e7dc0172778ce8c300d03f835b9da2cb5cb527ebc9eacb6c18fdea17245b5bbef6e64a22c2148956a2ee98c75502cd64b06bada63434be82ceac3336630f08c9feb7da3144c5d421a47c3795bfc1e8e8764266281b851b8211ca837f78e89513e2292601c6d05885633ef3b2174ceebdcfa533af99d76e629b23b7c38cc544455bdfea2d6d141ee77296dd390c69fe57752584730db3f897fd3e1abb7383f471943e3fa2ba5c8910064fd87956d8ea3d81e5db22c7bd35bd48ab2a7febb9a48bc4f495cc2a37378b04e68257481414298363fbde3db289eae722728e2323daf951fe16c0df6be2fcce3ff87f40aefa6b8143f7d3cde22cbe4a3140049f1886664825b622f59a79885d1c752fb185e07fdab8db69840300fab83469d9f7e0b830d50d308a1d801910343817a329e27ce764cf56def24d62fe67c1653aeeb7eb4c4e40a09abbb5fd1bf68cf03a4ee98964ff77630b771a8ef4898378a3c95d52ee5528323fea6d4c29262be2b63bfe365d0b76b6133b4f91a7fca8051e0649656bf47c57e16bd0974631918a90d2dbc6facea89bcd41081c607584a20243f5b54affdc9c2565e2b2e8338ff2dfa87294d38bc5a5bd6cd5ed9ac5415bdef877be133876a62b0b35fa60c177f4c8aa401dacfb506f84c910d8ee2c1226c5d8d0af70a4fa47037558243cd48ef757d8f231294dd7157c8b788b7f2e676dd50bfbbda2d3cb630e181ea7f7938d492c8726187cd3c3c1f1df5cdd59181805856f2e1dcd4882d3bbcd061a1dc09ee7c3961e34483d9a79f9895555bac0f42f1dae70e2c96684dc33e1efab69466a1435e9dcd95affe7b98824a8c0fc0848f1e7e8bd08941d87a0fbdd395b3d871f45211e2c73251173c4a3e1068c7af9a1a50e82863537c9d10af56a277399adbdc473be7e4baf2bec5e0d84b670bb446da97b9300e51570602e82aa3f6e2c48662b038a4384b436a4a7acb1f60cd792d58e85ed48fe9b43d497bc9ac3f379099371664841b65ba53f3db955402409298f526f9ddc8b63be072a01b9542063c53fdca2623dbf6ae424ba0ccf0dffffb6b5cb3f2437aaf8a669efae728c6f2adb218ddd00cf75a23d3c632a7069ecb6075468f02bfcb1ca57223f28960a574e104b3686754193aa1f664e2cb9cef8c8c135a00ae0d9547c2b0a8a8ff9d2af33a57489d4e2be3d1b1646c16c39f38c4e6bf9753868a32ae8abb8ac025cc643ddd61d5fec9b255b2b2e113fb59594054be0af6943979cbe268ccb341df7b9e229d04df6884632dea3d4677b047325916e59e94c5be8eb0d55b2141520410d873d5e7f4f0a5519ad3dcf1b57de9854edab479dc980a970fb48e47f1e3ba667a7b3efda9d2581f1688dd41daec45323452a35478a0e597570d67af4252056504cf3f5ebbaad69daedb5f9f79f2791222ae6dd4348905929e074752e55a294cb9dd03cc8bea70a96241afd915aee15b7a1e3fbeaf0d397b9a9cfba3cba1ffc178c1927367490b67b4deab5b54562d24d07fa249c6cc40ab88776afd742fd042da8b113b64ff63680e17c7c0d16ddd359c22fea03a19a34cf807a1e97105ff0f1cef6e6233bf57b87dd4b7b0a34878c41d09e9cb81e9c86adf4540c052f211735038f1bb5a886249bec437bbf1aa8f000dd280d640761188e1a5ea04da75605903299746bc2b179ef99503a9104be1d02b4aeda731680421184ffd6e77c5d5d4eba4ba6289f8bfec3b5b36af2c06d9796aa5cb42b89db3e3b5e8d51cf403b68c35fce65ce28887fbfcc3c57b055e82e4879d9721c0190b3e4256d11b1e70265aee24dcfe7f52da0f306c2916a3bb0bba4a797662cbc74cbeeba7a07a4d2ce0d7269c40bff32b003898fe9caf8193458cfb7b2fd95d99aef27742e9d0d719f836cd142db8578299df18643789576f3b7daf32ffe68f8360aa732a13deab6ae461eab19f33cb6bc46c061ad964526b6e797847f509207718539a8d77b2eaac40a1d7037677bdf88d699912758aba247cfc4ba3e72d4614f92234ae170b93e03b352779c24acedde489d854704df7376fbd8f1ac26b4a4b68094763d26786652b4a88a7ee6a5eeee7b24553866086a0db09212c3aba91c94e55dfaf2773986180daa519f8ff960e47558030772be1f5fb7ecb5671064634c16abda36ab47591895b06e4a5e735fa1f2ce4eee7c5907c1653d560601a8189d837a98c55c0074e44b16684ed0f0ec1536a180858f7fb43550a837dcf5141f6ff3a0f2685a1aa64a2babcc41dd760a987a2f52cda65d6c762f8201365f2970f05fd4738446cbff3fec08a07efc6a6cf7c8eca1d7154135e721a3fd9119d9bc5636c5c5bfcf2e5af0ab603c7f31005e56a792b5f7928be70654aaca553a8204d89884a43f66b1f2b90fbd17448650b416312072e17b68c7b914f56140535eb49484e98c81efde432c4d6fdcb21b0b8129b04f837433d97d0d93987a304362a5950f1bb184ae5e34a4aa6d09431dfc58cc09dd16a6fcc1f002729c128b20429198f77cc4c46baca4a339875fa723cf2f68c9456de2b3f3b7cc15ce835a68c22f41ab4c057b02a3315d3f8cf324ed6043c819cb122cbbee7343097e745a758d7745562c2ba04688f8443783fb9060c970bb52398810d7b148347863c59a20f193a93312dd12df6d6c410706aa2a7f05ef41f82a7dee5c2fba6d43fa268ee3f158a309a2df1740925ca3c9cd27efb3a608478199b6b8d39119a332983df6a31aca4c334edf22be8181a881bf5493e0b7e53ee4f5f8aa44d8fc3fe79be2edc88400dff72380af9bedc0e3585d062db4ee1f398820ea5a2c7d383abbf5c41521f10158b8b167f8809a17322063eb2392991fca4d843a188b46e87c043bd5adaaaf452a77219b813fc16d153b585cc479c0490ef7b0fe0fe0ca1d3a66b31cb5edbadd88083722abbfaae301c0c35aeb573e00aa329506a7544dbad22a476299f87356142e3f06743d5abd589f73ec8a9aa31bf902afc7235e957252a1d55954d3056f73b5cde7b72854cc19c4c01448af0ef57c98e61f0391118fbb07e29fa71ba60e0a7ddb3521fe8a1c00424ccd220670f63f1740c8b21d29a07df34d726e8659c69f870b6ccf6fa2364b29b235f2d5061730dd5034e20e951658769632aff9f3de45c36b2ac1faff0ceeea59c037a095561a9f519afdb05b787c07697f17c3e34623ee550ed45888642c18ba2e81dce8e1d4a3d76205e376bb464f0700afea4f9f98af201cc124a0dbaef87144526f5086fdb9b9feb4a91ff176c622a69e1a74a825e36aeda1d56dd966bc623b2c265806a65e3d060e3e950b3bd6781b8a559b5b0a2ef2e22f907fc10f5db75652eec5612a07551fd042b1f359703dffd563e0ca0b9df64943c7605a82e69a4055c1e0bd7879fd9a8733a71b70d42b571fe16ac0a74815895dc4bd6cf1a0ef3aa822f038b8e48228302cb88152c39ac52efff96e62398add2d79fec7fef20f05208b70a63a3622463a891c482db03f4c1f9fba4bb6e84ffed96e9c7792fae0d2f76356ecd62ae468c4e930eab42bc28c9431cbbc17a750706a5aa0370b1b7ebd31e7a7f51e590b13d0fc53f19410c16f37544dc49279460b1ca35099c19bf63599cc821f96ec5fce4ac289a6f9a31caef115a485846de01ae294b7cc2fddd26d9fa15f0df6169544a6e6810755cc20315f35c8c1b528786d1955fa61bd88a1349284c7744d109d490158bf95f448f41a7b6cece18b5ea211db7a8487864ed1031b736aa28fe5a9509462fa03ca691c622a60d86afbc7d1c8226c9ff5dd6bd977eae8f8bd589b0c123bdda483e13b149c2ffa2d09cc029f7831e011d0f32eaf070c1fb0c73e21b2348f8c91cbae7a3002662190a9b72a9ceb5a58e24a4c9a151855728ae1ed511222698a3c17ec4f2d64fa9f0adcf650e88384a0cdf4edb93d3533c3ce68967e3b2657abdab10407ce569a93c44a50bc67b07635b2b85ac213f4ddcdbcce7b4aa352ff934578f4af079864f37d7f3a7fdf7e64ff4f85c370bf4733daa275a849e72f78575bca78ac24c659f93b5313bce3b4c66ee8e9ade17bfb5fc25c35272428056ad6e2d53f3aee6506699f2ec0712ddd9677c4fcb5579303d70cba25908301882ed19185a9af6c2e3f3e57a2af74919bd3d5300adc1d5927581b0d1788f42eb1499c07c55b3b0656061582f978061e12e499167ace148299fd55b63b15e826989f272f99e72200143b8e562745a0a4a2508ec3d71454da48a8696494356bf0ba308e41be368a9f3c46559b93a457d7d0387eacd40737f3354a5a37e7d93aa727df85f1568ef9e063897b159cb23fcfb08ed862870c37a0af07cb95c59d53bec8abc448c760f4bd187681ab72807acb6fafd9b6d2cbfe5ff7fb147aa17b534cd83cacd9257e4e84c4b63f111f29f41e748a105b509a73f91af3ff5cda4316e5416c10c6fc11d1088118fa6ad8eacef8d248f84d527674b610d00998dfe0cb045ec668e3420fb3e0e0bb703e6bee4d255807854aad98ef287fa8dca189fc9a4da8e00e12317e1c1c541ac7719f36ef8cbafa20fc6597827e8f1a9a7ff6c20dfdaef72f24bef44be2a6471baa989eb3c58d50bc597319de75a7978855130f213b45cb5823eeaf465d5af6e386536e286abc304935fc688f2665bdd5390e97971e49d09bea24b90a423045fe7ebc71f15ad50db1eec6c0e473ab928d65b4e43a13919f4a9b437815546f5d9a6d091fcf0462c77df9a33a4c5a36a6a78b35a867d3ffb5e1a26c676172d53e3cc215f29e3dfdb2835f15fffa5161945e96439c187e13e7a70a944cf30a3c0cb72e8879b1c9e1d451b5cbfa2c26d85f73fa41b4b27c58d0d544381ceab233012566fb52ab9a013e61d0cd4d53524ed0d6eff1de9a50fa6d3480a35ed2bcc1dfb8d98d14b9b8ad66d72e46900589f2126e5bc6562586a1b99b4b6e48ca3f7e50efeb8a0df3a249557ea3e39df30a605bca1db8788886cc906486fdd29791ce44a065f740e486e0dafa3c89977b2e4183f23df90d4a2293ebee92283a9206d0ef6b0735bbfd80ddddbabdb10281f6d74e542716409b933fefefbcaf90e4031b42ad81f4902827b40344f2706121c1ac7c2bea92895e94a68c6c7f59cb3ab384dc94530a94e117edc12cf020b7ca456b43649110f6741f78baf65bd53dfa13207be48be265b6b76ffb16336ab9faebce0e52d24376ed97dcab867b535e5628832011216cdfba7faf8179cffe2e1a7703501e6d441e1b367789c5ddfe1fb712497a2046b2a34f9982432a53f311a37b0f1ed127790451631430f340d16d4aac7d83716102c60e3f7df63c04f0c167b2993421742589bd69beae95484fafd63d8f3c205e61739ff8c5fc09a9bced9283ca0a9d2c89ef1b2f9216af3e27b424feccc5790f4cddcf8a5e27f3419afee82eac377928bed3ad4e7a0099b961078b91dda87adf26e3787fc13d92ee0e581701b5e58b249780b060c7340ee39758f442edd97df14edc84f69d4b782926b733a1575939a50167d82a98db1ba58a8bed5819f41a3519bebf96e9f9697ea3396654ad8e5f3bdeadd32d30aba386fcab56f083bafb1c2d35ffd77b3b0814267b66dca46d2235cc6896abd441326db512783c7cf2f23339c1e38cb3abf711aa6994ecb6fcc76044c8348df80f406e69c0e5e78e4c82f19b50cca498bc708d77735a7265aec0d310a1324801a63cc9584dcac9bda80905bc658f9e36ff344e9e37bd647960a11d5ae08a96c01dea14b534c633c6806178562d14e85964cf5a510d3645d0085b86de852321cbef69adb61378ae3c559618ef7107477fb05a65974157553f933aea458cdadf974d0c97cb8654393a40c43066f2a43f47263c5bef68bb0b8bc5573153ea8aad6b5d548ecf2b2a4f48d670b8f2cad55bd6c195e4eb67840cf32b11e96ae896d8860b9710532fd480a32aa854b04299cb1ee6c047ef82c75c29e74688ebbb27848eddd3867db323752cfeb29736fe6922f6bcf60f1deac87c62209f32fa6d1075a4f32dbf79e62d866c12c2c83b1ba69611dc39b586b456472e509b2b3c7de2d26cd43525412ce7969ec46bb553518aa08fe981acdc8aa8704d214c79965b081326e4ce489df0a16238d685b8299281c5621e1ba3f983a7a7695ddfcdaae9b72282f7aede36e55ac5339ff69ce72592609ec4788684831f0ea9069578c1d93eb4d079c58a36217fb2a0343bf09d22c740bf52738fe806f543ee60cee35a1d99b58deb3f1f3520d08d79052a32ebdf2297c539c30f4680156971388df30ca182e0bafd33e6106465f83a2d49f23e7ac9ccca6067a05f454f09dede32dcf0e4de32616971b4b1e961887bc4ff7d903bcb15edad65f7bdd2b108a0e331ff12af38be7057e750b89fc9f8cfd089db0813d7723e66a214911c65ed012b654cf8f92a30d97699beb80a687d06c9661e322397a063415d4881792b41778293a587a2cf51fb37af1dd30a5b6cc5883728644c9e4f17578d23d93085035e5cf43c15c6b69d3d8f8fa2efb60340582bb2a3cee16d9b376950f9e706ae037d855d511558fbc2451c6f30357a91b2da8d8b5e94d88c4c22d654b8f236a316dd598772a7507306c96b19b43a12af7303ceca6c9da39f3ec563a651dcb1974a369bf2ddff3931728d7185ff21175f6f492c7d87875ced8fc85c78125c2d7f04164298205060d16a9d17aaec2e5a9b73721587b0041d7d6083209e650889e060c9a1b348a77eea278ade21f9e379d1796531f67731408c84399ed18ca9082e79da39d631c7d2c17f1f04ad57d00dd5dd462cecb5c725624e040319e7fff577e9636d348346e6047941c45b61ef1321b706b0d91e1082b1f36d994892622938538148d274f8f99ce2e1041f1173925c15042aad1ecc57ed7e9f120dccf764b8b9a819650e3618da10f894ff049d515843426489418e0626c1317a8aa48e3e2fcf4ea55952c070ad0a88abb432bbed686fb24705a7b55d64ecb018b2c5c96a38533377789059b6b724026b55981e6a34dbba5ae974e7ee06bb98c5155aeb6ab5008be48b5d2a69dd62a14442a288aedd37101d70a087396685a13458415b1c789efb4df9236b23d3c296e5c8f132899f4e01d0afb761d9e1039ac1534a2bd2924669c15e133b00aad64a500241342a4f9b14900164db86f73784d8269e2aa66f9c0548abee21edefa2971c817039038bc26f31dd1e9fb1bf03b752000f0ef38a03ce73ad61b690cd8d275df3273940f190116bceb8883b3c53f977c11fdd7ad27a1b4c61dea582fa4cc48296244bf0d06607602b303bd0aaf144b688df5da904b7cd887f15561077c1fec55a3b4d16dd9de28c7032cf27c8d0279cf36713d054e8a370f2a977ee906e935692a929f48c8c29330894c084b8ac992612bcdaf57e5b9a38a30238a06099e04ac00e535cff241d823472484e985c8a8e0a032c89de35e8e0f67c2fbf639446135c292e59262fc250e2f22310c4270432c3988227bb6ccd450119730f334894ba689b56e99900e4a3736001b61f54d64167e2344a0cb1c9f1fcfefe7a088e4d565bc4bc8236be73e3fe48b8623fde427b7ed80ed73560a09a7bd47eb7b1c03a1423c1e83945e20f6447b543381334dc739bbe95f756a9f7b9cd8b9b51714a4b8efbb6cff531434291ff76ba994b9bbe3cfe84c0892393968b968b588d7fd757df85924494dd9dadc72cf672a2e22b3f30232e1d512a8e9d6de8011fe0777a22143a51450384ee067cf6d7b6c2153077a23765b3d991da5c6347d8eca4881e61d80a66422c1d02aa6446c53aee01548c7a2da75d117027b1f9cd79b80b7796f011f82a4f890cf6a1b86eaf9df23604d3a74d7c4c5e239387e5b3cb26ac3eff0cddc474fd0fd2e0aeb7c10d00999120e8fdb512ae095a8db8d172bf69e9ae1ce96070a92d514c784849c7a951d969b31e4dc354cff423ef39805ca58e507b127a1997eafa31af28ae5a63fb7e6b4c6668eb16ca9f1bc2728fb98cf05df116fa3c07d16585f15cfa126efd1bb91a2426e431e884bb5e26e8c4e02aced107628b53378f5b4d266f0afd92d049e8381e6b36c99dac3b39dad4e898d6a6ac133f696cb4d8d24783baf4c287967c8b2abb08b2e928645a488a1168db965e596da0d50cd7536cde7c5de8ab065d2cfb0813c440a51580c11246b1abbfd25bb8c527fb107ede8e7b4ed2accd0b700cdd0692add719e7d0186e3eee16f4939a2015bf18d5e699c707b4dced6e2557e68351853f363d862c4545d5fd1f43830c0c476c68db5364b83aaf6baaa776945a6fbea16a65604961fa51465997a5ddb652bc020a68483ffe05263cc2b78a24d266f7286001958efb905f9d1ddf0765d22bb99e50787c6323ae7082ff63d68b3b0b31bbdbfe3a790b829f80815a615e285ada0dd8d7fef356e839f70ab873a6699777c1038f94cc8301c82f4041d218f77f616471b97f4cf9907d5807897c617617892fe279d73537bd7a73f347ecef27be37fd9dfb1c0330d4738b3aa7050f0cb886b1897247ce55412b2b737b5888b4076ed9fb94003066029d8b2253bc629387f25fcc8827dd3c39ffeefb55327bbeb800b22ae2df298ff41166f125fb34bd03fca0a9deef9e1741f47a464e3b92149910c9449a07d620f680843761c3060d928f3104736d90a8a066ab9f476cd82d9d9782f4281a32f9f0ebcb2ff18b2e8eb20452411019cae868b4fd15e7ab70dbb27c346e9ac4c63039cd072d09f957cb0ae27832137c2e13c4f7b3e53a4c9237a9f31b89cd4654c72532be43a261ea208c1032301dd97f85159f7eb47f6e6e854ba96552591564e78531d6bcd726937da50b6c26e8fb69668275966ce35d044e216399c41fffb9b5a99ea92c117068f7f26ed62637f60d3f129b9b454d6fbded9606f4026bf8d9468a450c41752df28bd584407f6dfd595ce29a40149822aee7c270c26714f17fddc90d3d2fd8b6d8e3f6aca2f63508e92cf06a2a59ae03c8ef9f3c3c7a6d6cca95423018ed06a9d5cd7f37f6102a267e9e4a95c3c5b167ff098f530698223b6be207239971814ec5b4e267507b952c6dc88c46de5ebfe475a57bfc348125e1c5e7d1e96b7ac583497649e7de4578deb42923b6d575b9acd6a0077aa59713d6a252bc43bbbd50b54383b32fd6ec9851fa06997d3180d673999dd06f0bdd49dc2e30f32d337704b9d11b408dca30358d316a7d805a268eb58893e1fe0c7a6f254bd44e461355fa82de32c49a6cc506429e3ef7bf6ed598681564c6b68445db8d07ce91599c3d6e27b82479c26a48e1989bdc7ab1770555562a1f67c7b5225afa22f5a4ba358ba7f80f4bc1be17941935ebf7da83edc69e6d7fdb3ff01fbe77c3ecc9c69d5d05c9f3ba71bf75a297ad3a61fa74436b183f82cba7c9f9158bd4028b03a65c67694f7fbfd867d1bd23ec2ea605dbc015baff9d61a3407201052090ec893426201b86bfdcb5e728406762a8a4d0e00a25814d8efe30251c98c81565803a85214edd5f6b6b23cd864e8e920420af3d365d7570b283cd3d508b469dcd51470c44f8af82e704a3887a7522c877921a6536137b7733430ab43a254970194ea01db16e273e8c395b1dd355309a7cc6ca3f78216a9a015782fcab01208b4d0ccda16dd5069119f4536bfb40ec67393e414ef2bb4ed455ab3f6e0b4f33e44982a263953e03b16d82bc18d46283f901a4eb1596814d09ec118c6546f85399f8d06ffc455a41eca24d0711453cbbfa8498d4f7409f9917fb5c0fe453e9fcee7b9f942dcb89d8854445d9667ca6a45499ea43a7a08e02604112008fc486f2a0cb44e001f2725347a73639b8b5665f9f87bb85f902d8a3739e8b3e5d76d74d295c5efa1dc7196180e058381ea57d7fb0e5b95d4ac1ad73aa8040f778c97ee3ce8e40eb298c239dce8eacadca34518ca0ae715ac06b51ee1dff0ce210107486b95871bf7c1d3329435157a389d9b9dabf2cc0de4e9a9b45dfbdb9ac17ebc95ea051c24773dac38548333289e44d5bd367b18605a6193e31278b82003cf9544a607ab84db0a4b4dad8121d42c5631c4d46c1b7007b0d39eb485d6d12f978e7097000cd845f76bce722a6b7371bafd6af30c38e41e04448603503f22984837936db85d4a968209fe0d85edc9ad373c42a40bf1d52835b05187c4ab5a168f81ede9d87c26286826e732bab0192f747172b6c4d6b7222bff919d44b1a9029d67962ed945400b0225549d3fa303fd9036c73318c0769aedb8a76efa2750c55a06cff1ddeba83effb777981e71990de912966da7cad66727b5bdf0cf04d8e3c4068dd6d6c0a204a6eada0790565e86d2c2a187fa16cb1b872d9cdad7c9a4c0dd19556389e02a49b3014aa88d66e40f15954d317bb86b919498656711fe1dfddc887b508f7d4e1cb46af38fcd755c489f01c4a4a3ef8b318ba3f73a35dac02332a3be2abfe7758514f8a7458566be665f027043c63800b23e3bfe8c5b1bcf67df00c95f829a4916d683d343454259fef2d63164344def1daa296f13bde084c8bb7c0b3879b089f52473087d429ae133f23e132580e12a6ec0c7ab25b43ed7aee4b2074dc0fdf15abd1af185293d5a9add37e793fe56fa959efd5f9d42d2cd04d890fafeb396bb5721f7ccf451f6c36af033e2527ebb9fd1ab6f98eec2b76624064c71fcf98dea26c005e9168fcb039078e5fec756a3f362d6472e9bb6bccf36985f71976270c09765a86a8099291de4259a338624372eb05647c22779895b8757cc086edfb11ad6b25f0a0a329568ef5e1822ac00478bd383319be809a85f9a67d9bfdcff9540b8460fbc0b1a8b89fb06fe8a40b2f40156434e4b53a4fc3c7f5d149ef33fb26db2e29a287f47f4225e1ea50b0e695f343486ec4ed24c004fef53d595b0242b7a5dcdb667e7aab366b2cf510b40a0b5c3d7fc3e31b97fa802c63a034b2844b79f42a0a3990437838b3eb18c29bb7f426f97a783c0b6c47a2c52d78bef80c3fa0cea0559392a7f23aeee4365669663fe28f9fbbae806587b496b774640a903e148e36c436f55716ccb3e22c903e865d5d4c22c18bc775fa73668cbb3493cb07ecfad21299ef5a10afe88ffbbf92412b4de9d4ac7d345fdb4c44670aae5b140ceed4565f730ff31086ea9570cb396089f2706060614564c6c567658bc73e45ec88c196d488b3abd4199379663a43ac87d72972cc56c45c33d584db74c9898a681f81207f614ca2a07548a1b89becaf4374659d20187882279bd21d7e72187da8ea9d7cbe709bdebcab347ab8ae55c91671d7689e7f3f18561fb26bc75a79c0917f2939a140a87d98139351d6dd0c71f1c3aa9613966dae661dfd4d78c2b0a897e7b0f173c02c5d03063af17824b99678a1dabc477051535194e652676229d1ee7c77f671fbb8a1aded75746442f1991ddcbd5dcdf7a32c8454439f1fb9bdcdcdcb567f968c86054404ea3c0d4deb16c8a50103255a3867b32a1684ecb87ff2501fca5f7995c4d70dfb6eed05b33142fc1fc4ecca318f7a2858eb234b6627557e02a658686d671ed9cdba83bdf08d545ac3c20d38baf4b871b950449cccfc608a4d7e72e63b092cae1861b905e3818e4b08953148b7bc3c50aa508fe92cbef1c5e1c6d939d848fba13f499678555dd6ed12602e22845cb79170dfab012ffc6351bee2507386a1a06b3081214ff67ef0465d47d4648311e7e3c75bb3c5129b5dfa9dacc2a7cb6c105152c2268120b9eef377eb3d1d7f573d848da9829dd0929253d77bb2bc7916c6c7d1a5b2c9812f03cb156416afacd15a4c55aea1b3b0ad44a4f09c60fbc34b5c10df6e81bb31ff891f76275a88c42d55faece9074315c2fb7a04c051ea2aca6604698ed3fdba79a5abaf306c9f2a83f5ef2ddfd9ac60d0609b58a4143fe2a2248988cfd9719446c1228cfc822d0b82cec1aba6c79476503822539da1435c046f229b86d4d20e1f59b46f825aa9be51ea8b33a7da51ea879e0dca4f8bbedcd7e8e0e60b0a0ee937398a9344b963865ab5dfd020528d225485c29698df667c6b217debe818beaddbec40bb76d844d6e3788629b5059250622a91ba5c9999165dc3a8df1fb260159344c6ee41f54333179fddc983b104b4821bc8e05f6a3542ec8fd68f8f219b6e05ac2be6a921c7fa0381eb1889fa8ac3cd9724c0bc6b40d463ddbe8c89352223ec6f601e09abea1f3df4f0606e120f399a18c8533716d8c3c6adac3c1fae1562f3c70ec3ebc57a9b2602d269c792fa565cd16fea05cb9834ce69d363a7eec057307f0a50c59cdcdecf763aad2026105d03b6ce5a6ee9a4cfdf4b65e3fb3fdbcf117398fda1bb13a236712133f5dbacd27fa3519ecdb120fdb95841cafa6e5aa226aff7573817c3a4a75ef8841001feb95d214d9261ecaa787b23fb47bb0be8b3a92e723a119457f24c2561be89957e2aaf0ebdcee8c77421f0cebdbbf746d69769132af2b10dad5a45071eb310388e807e69e972326fb01869fa830b21fe2336cf518f0f4b825f192a35ebb7afaeabcf2770a9325b6b3033383e1e81ca20892a4383a24a23f0e10e5eed6d7231b638f825e44b39a878dee7f6234898b6ae38566e290aec2570b6f5d58fa6ebdbcaf09ad64603fc09bf025788da41c6b0229cfc8c99828322f51273a1e02705a8eb6d8d138cedddbe8be42ec3c370b0466d8fa3142cca743671b51426d5ab2c7ce66c05e2b3c913222793f65c63276592e62fb22ece0c2bd5d46f94b24189abd3ba1df0b73916f536b3937e77a80fd31251e46f8ae60bcf72608455fdc70dc4696954e0c70c6905bd952834f7e0c1b2ec4377034e51c46d5473d3647acc891e7d13fc619466412231cab92f37533afc3f2bf063222a7dc25847da105b4015cb925d228f5a37627d6c623c876153616c7feb593314088df81a3474d7c2de0efb6bb22731c4d8e4ca696f6d21264e485aeb51a965da69437fe75f69753ae06b1cb8ba029688d007eb8fdf1e7c678adee1a1bc6190b30ce954b7e5109b79329926e524ff62a1600a33f5148b382db191ec3e7871df954d9e6b6b5816cbe1b4510a21fd8d88de47e0b74a5d9d5775ccf47ec3bfa67fb9cbe4c5aa7597b17d7ee67a2dc5ea9e569dea2d82279b2c2cf58242fb3d3f224c6bffb7d7b3adfd6e420a508e3861c79a270c50d5c3a296a96d30efe4343d41d6566fd29a22476e4ee53d8f627d4e6d2a765f54696635ff51975a137505859e888843a3709b097e08f52de7ae70667db3190c93bbc2170d2ffa7ba92d9b0128c829d3c178e87c25bba59105f90a5a48a61d5508e72acd1f615a569ee361fd71183f775c43dbe8c1b4f95760b410bb0b0c3f0ffee24727528d79c2c32c2b415d6a9a7b192ab9243b2445bd40891040c5f5ba6330d5f5cdfe0f47020f089993f4b5d7a21cf94dadd386a80d5da93eb85497c4b03e0dddc3a8646f4e9d7a56ee18845884ca05558eb0e3777804f4ec725d1a56a2cc8eb874332dcac6f492993c1726aa460edefc5f1ad24b40597eb0fc22f923c9579d781402bcdddae81eb3d9e7f90548835b4888dc63c459803de69f90cb1b0d27f3def9cc64504ae65e963d284a0b85aebd02be9972378ca4c4a4c5b26c5844527a73a8702efdc686c37fd7b205086decfb5fb46711d67834bd4498cc24b5c51e9962989144da05a6f6cf5ca6cdba50e83825d83b0d4ab68242c95c6881c552d4842f9fba095a86cd5bdcb8b6638a46c207af71efbfa335d2ffbb582d60791f6d9b9b59426aa4748417fc4f6aa3caa04ff1e2a042f7bce1bd017ab7037553c145c71f28dff414426a918951091d61f3fbb8b9456e4f0e6d6e6fca4b57d628f3c9a3be779766b966691039c747440d11dde2cf79b7cd0f1c4f0f22030d2c258ab105b5411fbedf40062bedd05acc9b8ece8b90eaf784f0e0015e663320ffd4323dddf811b0d255cfdb4122062147a58cfd512e1f1ba765bbbdbe1de7a159fcd7c1cfd01953d153a1d2b31acf09b78f10670aa70f025400c6e37760f1b03c13834d742e48ef95cb7a5c489aaa3e92632a8532847f3062a59baa201889591c6e70adb89e2d0cef807ffc426a9095e53efbee0ea041be73b7f8f6c0a96923548b8f92a7bd590a3df16cd11e51c78deeb83883a87d29ad4fe06323cb0504c96a4b8a8da695de9fba2ce45df1bcaf9104c1a33549f2177d8b352ef9e19d0df8dcc95cdbef36d49954bb4bfff04ed1a861b78a53b043d1393b109a9f7cd939230ef4ccbb82be75a21b8f86c9e69145f3bbfa2e188643132055e078f7b7da605dd66463735b5a5d6a57aee67c99574d36d11dbe1b88bbf0f5fad1eb6b55f579b271154fcbf5acab1709514a5f671a035aeae6cbe0970d4b24f7579bc178f3079d6e128031f88da73958c580b1180b3b777228e108e53ddb1f37d32a342f6b728ae07fb5c687d35f245402796f85903839da6011e3c2354eef75f19cf9adc8f70ad151d004232685651a7e59fffa70b47fabe50c75d9f16a888c9a3b7e296a1cef906b3bcd5c286151a0aa680226d77159a38e9a464188a833343d60a4fe99df28025b03ecc65e2a08fa63f6f48139d56f4fd606f6c559183caa1583eb458e21afefb6324f788c2cf5016b4079bbadb30af9a82702639cea16334b8df35d5fcd1b385be5f3a11a7af6a779e777222137fc42ab7271fb6163866766eb5ee294f60be614919ca18e386bed5dc117bcea3249c0dad7b91ad6546c7d3f387cd6982b3853003512aa4e8847a95106a7735fd0c3162c7d0568cd15622870be4f96b1413e6f31c395d992545fe9b00feee0740e86f9c817f0639d9d1af1a7c845f5f3090b447b779d12a034333660ea9249c30aafa0894e394f173708c06e97647f021c1ef62081105a15df5b25ad9c74d2308fe2e9a42c7ae830bcb558ff6c478b672c1b15db711a67bd120f2a7b811375e6f7d52db49f14ec6a0bf0399f5e5119c9f13d8963ac9c317f3db470f9ab9e277470a279e8fc38e1e779f25c2869338c1126c997ed1b5d08e25d1378f054b7d6009e988054ad398a25f0db2dbf3b7e4f5b3c598e71eb2daab579c57b183ffdd584c1f6c12e5165add7d437a163a0b539dbc212e1d243ed2a75de6c66ca374c06e03c900b5b8d50dbf400b598b55f675a0bbf96b02b01056aa187ec4fe57f5e857d45fa7c577d3d9233ece4d5e442c562461987804d1cc85b188cdc4573365de2b6dc19bc9eec2d97864da9da9492728d0f24bac3753f104d143e68317bbfade2a17f4620000fe84072a541a85c3618ed37f0c590c98c836bb360c66029f2a8177a2e4d3faf97e0be704d68d1bdd316fc723d5166118438c09822a054e736f8594b2b9cf4cc534843ba63edf40a7c3d25e7a8979a0927a4f869d72686f75d6948179805647af4de0046e89a0572d62705882e74eab8818ba5a23931402c188df0d751d295e0b63a52f96b03f07b15b239669af0ee2a4a828eaccc7380c87d63d7f14d54b6f4cbf07f7914317fec6b2b8ab140674771195751ed6e966e7462c813db819e8cff57af8f2f0cf3142c021592316324ad4be0c6de2281df3c9c86d2f26c5b13717ccb3d0e2081624055f35971999b9e987206034af5dc67059639da45da9287e04c0e6f74b313675680e8e639c0cd28346d517459c7389a20d580f30de0ef50bd131f623f8a589e4129103b619203a53cf2815b1b2c07075b0a36a1db2c4980bcf1703b8ff064d78d52eafc712e4ab99bfb08a35a645785918aed6dce53c5910a36a184a033f8258d0bc66ae55064d31dfe98de65e8758fadbbb80f75f7ba26f21f83a28f66c72388842ca199da37ea877e0688657d5fd0057ab4c11a205bdac86b36122c2f55cea0862cdc38a474744b42e905ceb5d8a04263dca429a3ece1b03bad989659f9e7b9a7a639366956cbe75175d66d5fbf971d1897efbeff669d5aaa54de228dfbcdb6215a6001c7a22f8f0e402e29f3e277f3d84936df047f97024eaafb184a52222c37ca8251050f214627a4e9a56751ce80e8866ece4b6e6ad26b7e47d5ea8a18063f579a5cbfc77d56b1a388e54f48872a6c1390fbc5cebb58d89d1ae9f1982673375c690a57fa941de91561f6119573e5e72997bc99d295d693287d6a694145aa4134d1ffc9f4b53505b50bbf661b3ffe6bd7196053a6efed452c7a47eef950f3c1d427a342c93bd876a38a731717035b99296674609cf9be3cb39f71721e0e5ff0b114756008799385d7c6d345e6bc0abb0976632c994ca5e7c2fa8df60339b83e479104af4370a1b50fff544ecaa53c005d4590f9a2d033137cc7cad26ab72eed1a84628d6ad30547c9853ffa05e1bec7438e00144c94b9c8efdf62264b20a51d33d944ef96087a27f6a5b601eb16f983c773c5fe3a1ef6bde6515ae61041094d5b11e77e41e4da9b52460ca317124cc9c2fd3b362e43b2d2d6907ae8e3550c7256061ca315715f93547238de72c1d8a9b42f1c93257a9d50bbdd75886b173373d9427bc19204364507fd8caf9643cf88ee7b190229b105e80dab4c78f5ee9c52b51b5811d33b5bcb065fdea21e6240ec77dd660e068776019dc677aae23c165077ca33f795e491b46e50050a5ab6d6278ae961ef14d3ee9819b3acf8c379cffbb6b4d4763e3029114eb369988c362b8621397225d55119803717c96cb04cdd2b085df86c69ea5cc1edae3303599a19383676c2d516c4208191c31f9d365ce54eac3066bb6c2b502a28ece9df2feb0dcf8fba9dd16eb7fd2a01aead713783c6a909770146322c9739bd6968154fc6ce41a9a4312fe5b5b015b906f5fdd74b2169271355a914d45a03b119cd79e3182de1f545edc2b46290636330078d9fbbcda7e3420a8368af03f217afc3c0e6069a732142a57613b576129006e30df5758873cacaff1d102c20116df97e6634596ff16329731c83731c91fbc36afd138206d8b60e98c99586f8f8f90375eb9527d263ab2fb42738eb8854befd11ef210b053f5e0aa821b43ec24ad94cf14b0b5ffe3bc235551e2d3d4a029bdb0b56182d0e7ba2f624be0387101f8501bf37ffa9545e3f1feceb26b542e2b33351943f8aa73ed88245b98d99ab6cfa3636290007892b9d97e28b9133bd21c112a0bf6ba48dce1d1147a23b4ee40cf21cf3db624ab8de2138be853ed91adda2c784fcc8c03ae93cd20f79b3f95283e787c1932d21cf0d1fa951fd66e18a0e4e1efb4aad75ab4ac2c3a6334f9f0bbc4a99f83535b0a31236b3e296bf11553899bc8e5b63319c33e2c8dcef394b0d90b470289ae5ab53735072060809d4df454b7346a491db9051a9146f302819cafb3b0ddb51","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
