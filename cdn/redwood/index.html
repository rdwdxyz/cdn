<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"bb2124704feb2d887d26f39dafcd9a20795311d5029edf706a93ff49d272a760a2aa733b7e20d32724ae6f1a16469639f81cee0a407326ea761b7874dc8978c01707b399815e0e920efbbee46b969162824734d79aa1db28d50371cce8c2adbf67ab71ee63c2b84bd7d5d9aff90eddf90b50614b89d761ee6201b4d5824a5758914ece4ab941d61eb4861b03b7cfcf5e5d79364b4a5258abc09668e5b85256c2b833c621b96c566b5c0950c5450d195c7fb88e7edb2c5770a0bbeb51dc990c59173607f4ca1f8e1d149e571d58a0e0c354b3b27a60927d68cefdb31325e8058311a2a3a23c24852071146e64491b0811170df4f375c8b87c3058989f0de2b86e2165d9de11e527da885da6c44bd8aa990cb58e42fbaf95e49ea308d473bdc567b086411c6c408aaa90c3bd2ba2c1015eeb4a930599c85cc9d612d66ad97e14ceea5308cfcf1405a4edaaece433a83bbd1e66dc1fd53d137a3f0d59757fab1baf693ec2e3d8a9dca2702fa3372f986df0844d95d306fd631cc78fb3113d2d69ff0a120946eafcf3c3d78ea9a98295f0db806211c4c8a9ba2f5ec57c609a4d7084b3e6f7be4f8bccf63e24e57ba0d3c674a66612fbce0939d04c4d8a7c5aff079934557a29b475395bd63e5eb9c9597a1fdccd3994f0996a0aa89d1c0ec3d2186d910d3a96672b9203c2a511d25a960e8bf07e53ec360e3bca917bdd4844a66441e52c8c60fd77d61075ed081af78d8a18f4e202aff7c9ef2bed4a5b7d95db2ea71ee7b2984d436a51f382c41abb11d34d93bcf10d7abc05314d3de6e225224afe789a69f0ec9e2e837e796130e8d822b12de242f09156500b0eaf8c92213be02519e02524734d110f601f6a1a83c42efca21f0e3d31acf3ccc9f522f56fb33aa229bcfa0f3e3be8f8cddf05ba6c3a0a7de89d94e30b11d56b300424c136d18baec685af1faf1b9e630392fbd2ddf928634f2b2b014daa381002a5adc2418e794c215374bb727cd9777be587c38a1b70d3eb62e06d16e6ed48c87af95b9d7c56987bd965863f287f70ed31bda75a06b92112a07114152a9e68afa706df6b89ab614ca80fe2413cc637bf56796c03b31c31e962ec3ae92fbb6240af05537a1572879475404a458531b7abd99e3fee44031ca77d79a2081b0465acc1b6e8846884ed004264e534bfa57faeb2cd795afbefc3b72aa200a47621d0d476276bc8077a6e62c13a933ae55fbc8b3d28085ce1100151cc288bc9131ec519145cca9ef5fa37e691e53be5ce8f7930f4c5ca70ab3aa18cdbf113249a20a2da4f46f4f681d2e293c8321e14156ab7e1d7460cbe989676ce3191d6fc2b5903f901205382ee1de1edaff5b396fb69d3b44aab70b19a049c7abdea05eadc4091d685e5dcc8aeff02465d492cbeb631ad3e7d7bc0e62ef133349a9c30d5a2950e71b1d206a2b362a0995c801feff74bb6e784742feed6f0daac5b29e02344d17ecf4b917aac6c1b442c15d3d2f32fe85c3ab9b88fe209c84cb94605c5796168bc52c33a06d673caef66a17b85e06860434923dcba0924cfba60010aabd940b45f83c5abd39b47ff34eb33ecf06333df2985aef282662d33f8233fcb95c3289b60df43492a03b0ff66cbd1a50cc174018cc7d85850d684844e9142e4729d70b46c2da31fe15f015e6a60dfcb39b463fce98aa3d7afdee64d845e483f17892257c286be4097d26eb4d4ad66e6367ad2270822035a88175aacd3fa003ad5d610d8e961f24b680ccf0606a4414df005afa6a27a9a2155748c58f376edac137f92a0edb9cc9eb135465860086c5040cd42fcf531d3bb31748513d0e2bd8a2923611564685d596b1a22e3d79a7a52b4c00f87eecd99922e488e15ebd0f39d364dbe0bbfcb39c13b933843d886a034bdc93ef2c780f4c9ab7d895b22c922c13cb7764e934cbadda53f2d693a8a3b1a753c989f18fda3d3a2171c69efd94d36822deb9d366942644c7502d31b867a6b8ebb59cbc0e66b1c1255ffd0fc0670a9450136546b7e95dfbf286534abfb45aa8ba52497058959022ba5c22e31d461174fadce7431bfe9d01e1e3eae9f57061aa445d7181a5dcb9c96b120885477a7df06952e7252e3117a2770310167ffb72fcdfd6c669fc5ca2d5e1e8757f80f33984efa846c6be622a12f9cb54abe69f181a05760a959e8b4bb17a2c55c76d856d9ea5b1a447d9503efe2027d0c0c26acf45d2f48f393ec344873bf1f80cf31c6bebe14b33d122f11b6e3294120b28ba33c83d49f09a0e5acf423559dbb314a674bcee2200a975c0f7cd591cdbba3bb26bebf932c6e3328cbf95b70aaf956bfdc6c14c907df7b54663f4fb58b57368c1e9dfba15a7de97eb888fe8d5725b31ff32e6984083c083dfa4df0793d6c4c19a12aa1840636134670ac9933e33d7e1c903a61a0e0a763222e05682a6dc8871efec3dfc5cb2b2b8a0a7cf23aba3b0a377abb605eb886caa437600f385c8942be454bd127dd8855a71fdf28215d05d1a42493e94d12e5324419f2685f89e5eb63af2cc1a6cc71368b7ff334fb5329f342516758a161bff98fba354cb21691d330857944fd2a5bfa422373ded0fc6fedd678806f8aab4833eef8a44cccdc365281a2525b19fa7f6750db078b4d480c0bb68f3ffb2a6ee74954a173c7d2f8f6b4570919e6f7b7ffede7578fd0d9cb0489e0f5b5eac55d98ab80cbf498d9a367842161e9160a940ba6fa96f11c0b2d1772621f4d87e4b9b69aa1e3bd079f9cd9fb928c91d85d123b3c09fdeb5b6136b36d859a73ec6515e13202ce95d34852f35414a646ff8169fa5f883229e2d624d6367bf964aff582c085400e0f53fba544f041f760f1daea55bb589e45a39de1dbc7119eeb7c6697b2eec118ef6f7df3de40f98b310f1f3836571aadb7be8b484537052f53cc29a9719305a5ef9dfc9844207338e863eb1f0f236923128cc4badcf0c0eb4d7ab5a8f2c55177733848f3a35f63cbe36b8a73847972288b0694c87b4b44e9e3095e69ff7d1731bb553afabee9c8ec23e0d85bebd478fb3e5c6b7d41c82bf55862debf1e409956badf0f00d977e4ecdc6aef6585590d503a289ba5c81aeb4b21230674c8b3cbfc8765e775949218fa6a4da389a1867734edf87fa81e898367d590ecbcc25cf1b9bce016f9287ea708ed5eb91da3782bfecdf56bc9434e2dcae28bd074ec3cbea705d1f734580752e83db61a5571fe335a779c3a9a755bebc6ff48f621e35714baaaee23305e29383dd8bc978db7e1c508aed259b508c4795f0184153fa488bcd5d2d53a8155cc12422a9ddfc125f557ba7f57a829395e44e11a5d66ef67688f18e5c43319e0c33d6b4364e0fa5d0b89b134e9170be808691c3c5db77671534bde10f064c94b0548250aa231e43c483c7bb0087e6c22ffc72a40f9ae0a26da6334644f9bea250102ff9ab376804b1d0294744a5c320447ffe8edfc208959423a39d4fd7481def084845171bb27f48d6405d11051a8ba7bf0a3004f592a108b4bbf3af688c264336ec23b65c9889219a9a9ab05257722ad894ae1907fb59673c6d7e96ecb888a2090bd443192fe133843cac3ce1904aa8f030c2573ccdc3ae239c091308982b13e5a4716d25aba1f8d78712e8527dcf9b11d1f9290ef3c264c1ac484f05381238820b1aa58b212b57f949fd55ba6ec2ba4f4b51b09ac45355275ee7c645cfa47a7e7cb439ab44b34392232f19bc6e971569b3b8f0f7e2acb6bee6be639eca8e70679dc0122f88b320f4754ddad931c59b62c7a94d97d99b32b90967e3919c0d34c783d587d978eddf6aaada6d02199dc1375f3a5111b16d93df1da55f1c29809f7f2e7df29aa58ce5cec715a21db75fee5795c972cd852eeb9f55d77dfc749cc3fc9f22fba909cbe91323fba85d333c81f23906fee67156286c5eb3c0151aec537b3b5ff51cebb4d7c2832aa240755ec0cdcc9c3910d2784a3c894a8061ac9aa7f4f11b2467d4ff74f8d2e557df226ac0c36742389ccf44b780b6c86b034cf24a37713b4cacdd9402bea66d2641ee297de81ba61393c35f9ba388d51e1b8472eceb687e5552dbc8edf8ba0e49b2826dc9478ee0a3f3888a177032bb12cbf35aeadf60a5c62177af817a6c9777068d2bbd2f19b2afeed2fac76e33aa85b9ff4bccfec1cce794d1d025dfdc3bb8541bcac3a1d4d81262164abf8ab4fd9711b4b0ce4c94c05ef4b45238cc36b369e64fd1a36ac51ea038ccae44bbe91f0c759dfbc5591e596dfc1f68ab0dc12ee4fd7a2a45bba08f8af25fa1e2b629b2c216988acd8e35d1bcc47c2a91d96acb21e97946fffbd08725e4a8fd67e88a90f18ca4b3e3d581e7cccf9f7b9203e1eb1f7a7da4b0a36d29156392b42e3c296bb39713dba1115b87ae1cd6e6aa6608a144eb90dbaf99d332abf9f168ae1403e803b4f21ecd6f7826ee2791001ee5f8870adf4b1587c8471a203417776d2b91426109c61cd141e620855c3bb25540b4081e760fe60ebbdfc518a8006b790c84a02ab00816ed9997cec41840b7e832a74a41ba907bf24a702816eb5842c0645d67113d2a16222b72d33cb1b47bc78a84c016c301efa3b4ff22f5da4eeb845d22a678a441946647884e3c1edbde72c4f935a5971b8835d88e2eea0668a1de007447c02628840661d28704d5c7e79c109e012507b29f5888b79059fb57f91b6d5b2e42ce3032f6dddb36055ad08d3a5c16aecf287240053dc462706dbb3d4793a958145355a6085f2ad8501211db07a78f31f629ffaac2250c1482b86cfa8ea8c5cbbadd9b6b55c48d2015b82ee8ca58bb153f6ffca32d8c9c7a98b475f3f4a5ac94dd8601ec7d089c1cc4e11ee6bbfe54f8a900d03ea50d27fac38a48f6cdcaffefe0985fa046ecf4ba9b4a95b6cb3ba6a749b6b8810e8d39753f09dff8924dbb450083fd0b4788c1307e0d248a026e0a980c6f03a7d11a7a9bc01da5bfadc45853021df16c91bbc474d23c3d7135a3b2647d3009af3aeb4d8f2cb8fc2d618d2edf84cddbad702c0c43a681dced18121ac959c36d0352eaabe23828dc85db0e4b8c06cf1cca77ea86b5ca9503614bded0c2003ae6c3424ab649304783282a2d9f5bbe66a81e3d9526481612f7c282cbb08bece70d8e696f9735b84cfbb4f2465f5eed6bd99dc1489ce240dd47e610367b26f2e2a765bb001e7ef62067fb73d1dd64c1b38555e599383eca0bf53af88256b3b8168c2fc2c0b227964e04d8af4efaf358f7ba03167c5df0c71a83f1cf0b8926a50d8a7bbff1177d05c8aba9960ca48a9e0d281b04db00f7b69d9223e5bb5ab4aca4f7d30a3e4dbf7c611ec80007581950b28d6e5caa8b7ac422e476ae323045bdf99073dc85e210807c5874aa6eb88ad8d020b6a8d95aaf11ce1f9dc830fb4e670581bcccb3d33c81c3260df27a9ece3b73c56ccb6028b751fa96b0aba3a49be44ab718e87787c5d9f489078389eb46fe4bed1d6a7461d34431334f59a7c1e84574142913f963e65a4171d2ed9f6ed36cb59451e671451d1875e562797b9a25ba92fb577224ddbf18986379363ab78547cf95c4a382500281dc4eab8e2eb15072e361830a81480f9e2714abb2e6970b82eae46829124193e3b8e2e2ac5d57e6711c9dbf86a229b87496507a9ee58b5a558bc27feb6f1c1e93aa30c70187b1a7e0a3501d5f8645de48bf74993f4f9130c7bef82b539b3e23b35395ec2e508346c55a4b1dc728e600c37c35b3f8223efd496a7eeb172f54beae636fc7ffff650fe292f4e92ea189b2ffb4c0039bed92d8e38d02e7a087ab07ea15587fa2e561fa6309bfb0f8f4d67f7ac5c14bb2db536fc5c2b57f090bc970e9a4ed8c0f383c534a0ef9685edb855db2332e4ab921743bfcbabc05543d5e71b521c0af376cadfa40b4c734d51b7f19ab8201d9983cd003218bf6dde288912ab96309fb2886bf46037ee3f87d3401a2a9212fdf2634cb86feda4427875978388058d4068dd41c367b40e6e0a5bcadad68053f549b387bfb4d5f33e6c403b07af25e9aa4bdecc0b09d4412b39ca65e4d53475acf03edbb81dd59842206038de39a004c040f2c84af89c96bba3e30998955cfeb8f8eccb01ba77ca082d9e0eca8a4b246f290d41e11cf0914135507df422c2b82c1acd9456c312da71cc8e5934bb6ba8773381b640d77f8547faa3c495d479b81de62d6b375f54b8766d3ce57c5fae10b9089d6eb1e5b6efe8de9ae2549d2c203dbb64924bc4c4e20481983d4bd00a43af24e387bca8b3817a4a9f5a96d68a99531bbfac04b32a9e2e16cdd0f3b72d520c251756e2df7b05004ea559bd8119b75afcf70053d9bc78d856e6e08faa03c191acf2838777cf82c041ded18a8407b6da17bcba8ad6120d556ebdad05054beb18c75d0291c72c4077783992df8e5831754221a546428dcc301178ebf85b8697c5e78c59f06494259737f52b2fe029c74f5d4ebe2a3b4405f4ee32d7be81eeb4092be07b16ecde9cd6ec7a0dffcbefca19b224ad5a760b055b109a2f32097c328293789136884fb1a6915c94c9dbeecc85aaa767f64d3047137174628e756b57fbb9e19a8d7bedd3c5cbd23ef434e920a93a7f36a8c453df390ec72abbcfe911608c737d2513797530ae1b651628eca1ebfb2a8f8ff1af091501c5b05b8852cbc3f07d8ed90f81ddad80011d825396e8514eed4af092a8ed7c977e478783307f059d7ba5ae8781a2c2d0dcd8a0b8e20c8fec76f7afd3c64a705981a84152166160237e183c99635274d16e54620fe009b65a5e59aaf94c2b549b4aeb6aa377817cba0885527c374911de011c03dca60b83b4155388652ce75f8f16a619f28c17f61df3d4d0868c3d85a16743e6a8fb17de9ff8f49099bf0b32de9e212c53566c10242268de381f26803d666ec2bfb19a7c338928df2ccdecbf78e1ea324b95bb951487117fb909eeec60463653946403e09980f4b6715f6f3d212e73a01c8c0f84aad3d5737ca735696f94c36b28b9c22e82e4f1c52bc92590babb7f59622b8a3f69d006fdf8db700c9800ca51d353d6fae407e9536f9bb42156a72e7bc259382f93c2600ccc39002e38799dbb8b6bae96b4a3d5642f28acb1141bd98c1bc99462e9256a90abaf977398ee388c9179ad73b2a58983f5904fe6fcf1b5808c4ec4986320089eca84654d223f85f1f8d7736959b6bd8319680547bb75cbe368fc4696c750f98949bc99bb94e0ab1ce0edef13441a92052cbb80e086ff094495d500deb50a958792e74f06c6149126b90c3754611988f8fbd7c11be042bc9457808b35d49ab009ea29f2a04b420a04c9b1c1b9e28b6b433cd3bdcc80f0fd61e3781f3e6000101e131de47b46aa936a26a243f4015b27960d8f1b78f28d9095916775e3b1bede34540d5ea056eb2611d26b414424c02a6da32a8bc8a45d20ec70d83cf7b6b91528e843505a60d6db01e44ca12a8a1e5e70364a67192a3facaf936468bcefa5a455d931f9399e72c7ffe4c029d7ec712baea5de2e2c38ffaf3370d4d6148fe5ffcf607feb0562e05050c49c6134e4724714fb857e4179bb0c04508a44460481e1700a05aeb15c38ad988c45cda2b7f4cc906eeffecbe3c54ca25d1613078033a50a3b4b56924af9eaee21e9dca9f3c600026de87c36c9d3eeec7d3892c4a7955591a5a415af6ab442854ce5f73e086ca0ad72bc9e1f00e70afd3433e1f5ae56916f7bfd98c8ff031140e7f8923416330c6032d14840166693a986c932285b87fa0da9d4de2339775b803be7039959cb9135171306a33892d650e19a200e98b1edaa34683beddd7626b6650256c5e406d3f2cf9e2034d4e2ca18787ede7af6814d10d9ac50e7798ce8f841a68854dccb2b01018b863c58049a7c987a32b3b6f89c7754e54a31581a3c485a02af29cfa815fa0652505c69f5a5cb3dc05d8e6c59dfebde3c59d8fc44b0d0fa8c807bfac36998a4b8f8eb14311e356cefa4e1e969090f0f20954374e9eb7fcb0539339aa241d22272eb6c1ca7fa40bb5ba720c0d4dd299bb2fe774d7036e496ea9415a977e80ec0055d7591e20fa179ce6042bf23c4e83ec0d641b9acdfe5a0dd7317664794f18fd961b207ee6a57cce5d499996e28e8abe0601539494eac9c1b421e4d542dded33a58d28ba8847964c44ee2246c3ac7b9f161f5c5b2f881fd07797d0e1281248bf2a8eac51e72bb6a91e6e60f7a86eb135fada3b1166ed3423de55e5b1a1b0b952b26586e1746486ffd27da0d6689f23d6fc556bb588590c927e29a33d9fafaa5cf3fc2a8adb746a09665c09c6dd20de29f060edefd794ea90339a8e526f37660722d5fe70cd2f452c5a2d4739a84228f98d86ae77fe2af29f94b9180b584eaacc2313863483edecf9b95450a2499491fe9166b324021aed42759ace8043825502d176f9ccae9a82b6409569412609066a8d6f2af77efe6fe040ba9c1732378a7ca7afbc98acb36b0621811d8ba5004645e0d1e832c186cac8b44d9c3b1c7b9e33980d56379045ad8bf1bebb0afe527a4c4d91cac6294754c99a77eb80e48added1aea8fb9626d3dc2b3fed7735a51e24bf0c49d545412f768973d82a28f7c113e83b8cbbfac21df924e7978bfbec6fd9185133f578b95161e65199490fdcf26be347d08b150973235cc7ad01b5ea373a9db94be597440880ebc01f7891bb9e739a0c0266cda1bb386e0969248585bf7437c3a80193c195edf92b93b20776bd1b9d00c83f323cd63b6888379e0e06b31af5056fe3cf2458028d3cb27829011ca0a209febec4060d7d4e35b540a4073a54fcc4fbb51d044122531f89556b0caa8bd3b427a7bd44ab8a288cf81012140dfb7d91b406e065626078b9c6494013b5a7ac2fb1c914200ee121cb784e9975475550e64ffa86050c3a0ee5ced38fe4361fb2f8245fc84fe26bd318c076db0adb71cbd354cea7fa9aaab26e04c6df2cd0d9fca5001591be2445724004de3f8d77a6b8e634600c7185a6adf16f07aae542a32684647449bdf8921f63a7acc17c5db54287e456232b8eb4697b7129afafd335c74273a7d57b8571a49e9cd7d9715f29b412df103597ac864597fd010541442744e49ce85bf267dd378103106a025a4a483cee26fec208d4c5396a73076ef8a33c35a24142c9025213a5eb6eafaacbd893617fadce2384ff2185105276692fe7cc8b6937e2b6e4af089b2ae9134560b46b206bc9a712548be18cf6ffff86bf44587dbba466e66065a1e16d2f0169e19b99449509d6e8ffdc4eea96d51a8c4a3691f9ac09db3a2b2144708a68d9ed81192762a8ffd7a5b8b0d61e2127e79203a2acf14bf761fab92562dcfe5666aa266639fa4b58665a3666778c09dce03ba36f7e4c91c046f4f69351c496e47c1f523e46e940fe465f114e5814f8abac5d4366b926cfb17f2da95e769f1c0563f999d499dc8c336e3348aa036642bb145852eb6318a0de489d5b9c1bc88c555ac82fb6b2edc295131151fd50592b6522b4959ccfee022fd4de741536225fdba0018e641f27bdd5880eec815a3e991c72cb36c049ee88753b3db19e5cbb7062feb7cc7edd8ea75429602d2ecde926049ebf101d84435fd2f2519fe5f7b60900518c195c15923dd04f24bb0ba2535ddb6cf32abdb1c2ec1b8cf910cedfce1596a35ff385051b2a7f497be6b6403048ed51aee65adacb5492512f448131cbc2ac5f483239bd50dbb487083556ddb74ab118bfb6bb0dad9723282558c03892b391bfcff9f576ec0d7b16020f827cb06d72d427fd0c2d8b2f781efe1a476cf83ecad6e0d6b408429414fce5166e23d1cb256acc3d6a798c3c08a887514611dbb82c6bb3a09ccccb8739cf73c9da6c1416530ae6e72002a6375f20d25a3d2a530d296f6e8752b8946533685652febb2ef7f3c28c9e7f4e2a1b59fc811eba82b0c1d46f0ce1d0e654577aee5b11ac228e0bf5dcccfd0128302fd7e7a7b756110b9a31b1aa6d121d2aa8bb0c2f06046297144a11455af3e7bbb3c5534508efade0d9532ed171b5c27ddf4a72ae6393058b834bcd3fa2a36d48a211388ae39691698840924e60c07cd3355d9c39ef7c0d789cae61f583819922058e9546de08e484c0a6fc0714bd3386d164099458236c76913a7a9225f90a6de3915bccecf871e8fb970c17e9a079b82f805466621534a992e08a29a8967160ed3d3115d3bb7bbc8f75930755b1148f4b8bfab483709c22a76cfcbdcdc034a5a6154ba1316bcf4dbd778fc9f25936a4b051aeefec5bdf01545d38a9d3a9f8f960c2f9452ff58e5bd828425ee85a22285535915b62ce501326d3bc6fc4f87fcddefbf9357721b35a01dd3a56a4ccd819c2217682cb563e916cc5cd862fc2b5aa18f43df06224e7fcc005d108c86163410be4949e3c1d87ae4e16f7bfb1324fe8c5a582ebe500f8c694667196a647e77a59fe0c06852f08184f55c708feb18fc83107fc88225829a56dfc2a8549a0bac618bf544a342b946930f277cdbf77dcfcf827df6f999ca25a5fcc9448e6192873e04ed9773d62c2a0721a303adb38e530764256166417875069a3edfd6611c3cd7c589f4a3a16a7fa1fa6f7a0932c873bf1685f135957c8ece18d9a4666f211a6c7cfceed10be2fe24179c7bf1731751abe23daf81bc9cef232d24f3f3a059df180611919102a24762884e8b53fdf08f365600f28ddb0bec37238107e63823a096a616399d9afc1d7c6f6cb579dbf6ca82b48fb40beafaf4b10f5e3ca2b72a5aeee02f76580157c6a08189cc28b97efa9d1525656c68cb98b2691870cc5a55e3278c19f13432ccf3a65e50512a3f38cef06ddf98c3037c60d2e98d167d333c34dee4326436c7970bb5a75836dbe60f4b53cd010216ed112ca59f9e0ae1b564872ffce3f2573059dffbf7c8be60ce464276146b789a4671cda5481031e225b33839bed303dffa6b4c9b8dc52e9dd7b189561724b2dd6052c63e0db36cb7c2b495bd33cb72508eb528ca938d7a04244853a2b8236b112f5e2e6e173743a5f109e633108b1e4116a9e26f96b0e215e15ace734314823f8503be019b82f3d4db589135cbfe8ab87947aa86d71eaa896c80d1126d6046372b7fcb4bd3b3e3832ebafa1bdb807bca6cc85ed845db92703d82172572c56717d63c4a6e23fbe3912980937bafb16fece8d8ef4e6bb16981b5e1b1a8ea18a9f02890a4a627ebf72ba3cf6e17dfca49a0d9a06130d2b01187e43af92e502b0728a6ac32fa279003b375cc3976cb0f70d47ba407190b4967d83bafb6e7cf095ca346abcc0ace32f95f1f396969ea97f2f0b3c741ec05812c254620daa752de20446215a75e7c2f7179d5c138447b6951eb91b0db79ed2b756e0e86590833548af0c7df593aa433cebcc42445947124ea067a204b4f7d8ef6daae5e1e9a966bb6b4b0edfb471229b25a04fead34521d430954b09937aaff752690ce401bf57fd621f6f140c9c16729261f0e6ce4ffbea474de00580bfc242c6e852a2990dd9a7b920b62a4095b0064a5dd1f481276afcb9a3cfa7d91c65cd2437503d4668dae29abe13c7ada4b4d80b861c9db7073287a0d1c158ad7d72612299a9b994b54a8fbb32817e28bf816fa5626d3fb2983cf12d31800605fce9bba610e16d4f840b6dfa3d7bafe1bb6329e6c992b8b177da48b326c6cee1e6ba36f76517522cc16358624601e59922d7ba0937cd784f633a8fe65145a0335e140519abce9476c77cebc045d9f5bea6994342c1a4397558b742c4ecf9c60fe056a015d747ff374d13ad4d8d7b40594851789ad1f9fc40a53734ac2b2fc79f5c03472448bcea0cac3f5b0e4a25ea0a9d84dfbee2123cceda6eb0fccfb64835f042db1bc96b75fd1434a486257ddf9b615b9516567f361a58d9f17a4eef8b749b78048a97a566bf8a88314a45f95901c4bdd7e6ae452233576ac2ff8132230cd309f0c38f91b3ac1d0c17f00c199f42f2a51f3632183e2ac19d0675b4f7ea521ce202041de95f04cffadeb4340680f0b94e9f858d437f7e347fc754153c72e811e7bfd1b0e608b528277d63804c26ad2c04f6b7d87eb4b4afc694750d2783f75093226521c8a7e06d5439660febd341695be2ff08f0a9c6caab550c9e6ad96ff5088a3ce8ec93038a8208e4b5d71485fb024527b5bd76b04a87f590a25741e8e17e8d3e7ae932690f0248b0b760639c508c333b7ad7053be35c4d313246913ce00d1277900deff3bcc00eb9cdfe46c82e745e1dc24630b211cc9754c650869c0d895b7f7b4b702f11041c230219979a5bb1078aa95f1ddd1382cbffa3d927639d564995e25af662152c2041794eee8e917721142a3cfb563e6a65c69904867a798a714636f7a90ce7b2efed4c481193cebd6e2114401b70ed4ab88c2c2c900adc63a8b2f8dc30c7172734a369c7b92fd1f9002dafe39162aaa2388dee76de65b0e445990442dc304a537cc0f5701931b6cff29844af51d932d36f513e0f2bd6b35a75bdb8399574b9ba0183b7dd980e1692cccec9e45deb00bc68e4a8ad563e8caff7b9a9dfdf0cd212989d1688fcc943ccd47384c0880f0db20e8e7ce95d7d9e0da63c853702dad59e60e5eb11d0f09b7fd76bd41df18a9daf1cfbaf0f4bc0bb9ec67a5a5253a1b3f2e2eb109f9518023af7b0ee65dde40355c3dca11c293fb955f024335b418563c9775c21ddcffe2a409aed7563cc01ff7489f88d415cdf70c5fcda594d986eb30551498d9847622182b7635ed3f384f22d61d550abccc0187f8c273ddd2b1ac67bdc87e12050fbc55603fbcc9a79a8372a76fc08d0451150c9ea7688c4e4bbc61eb32d733d3cc51db3c1b3bb8da0fe3147af42ff4dfd8d2c448a41d78aca817f85788e23bf03d37670914d103ba20fa50aa5559bda862b4ea298de41b1389ab1cf0296083cec7f95e08cd67c8264bc1a22b659d3abfe6f8ba28102ff3128fbde7a89855277df8c6ddab3067b2d67249a1fd0ff97f712fed63c8bf72f244871f0f970cf9c243f25744cf17e901b2144507fbc1aa087e39f97fd847f841c76e4d94280b505b963be507f994cdc1c297011a9e5c1b7e2452a26f3d9d2b043f4bc961b418d197057e67e60e306f2d092440eebdd999c8f624351ca2ee38630d4c431d7f3ea9bb0b5204a73486b47754a65b6a9fbe1a6620f3566a337a0263bd5dbe6ee9227415b70fd5dfa0d154ce01fa95e4845e4ee923fc453f3fd249ba98c675467f306a71b24b5f9fdc8eedcea4cf767a9cc29215d06120d54e5989e52ed21310b0656d8de64460ef699c36916b43b957e3101b2da580e18ed37fbb999e726d7966944d8de3a34ac2d6483092617fc7ac141976d171442667c6816eed78e246a229e9858f985346b489699049b8b6b3f4d88deb2380fc67a217efb941500c63536340018c5a296711e63cf3a8d2a8f3455a39895c304da81c88561a15057872b9a9cd97245293d014bb18b329c87ecb450678ae4b36ce021cff79a407aab6e2d156e1c787db39c41a8871961bea4f35e5fe25938e9c3d02b666ad1471a7ec45b3de62ef042c37c717539ee646e8f7a5bcdb7ecf0da4b71f2d1a872c08a46055b9e3957b5479f0c4ed6712a6581d34a7c64521b42f18f90764247efcde17823b4988259e26d92bfcfc3c978a839f3f7f24bf340806c977feb4403e37da9fb3d871485d377cfa187edb93170c42817aa02e92511ec3c37cd87ce20a4a0fa5871fbe785697499ae1180a8953733b3aaec0fc28026f616a8ee2eec975a65cf462d427a194955ca0b8ac9bb807bc661311752166f304a3e18e217c0d0e4d5960861411cef471b4f9cc04b8a2bcafe933a199a1c1593332be382d89bb4d3d6b4fc83cc7241d63bc3915b09f0e10563a36af331fcb62599c1ffe6a13a94b5c21f5b01a5e07d161116da2ae2b62a4c32877e324e44a5ebeeec89b3af6b3dedeb63f900946549de1535c1dfd22652c270c46aaa074b60bf90781dc2cb3a6d54da734adabff0474ac0de00542b8dce51bd06b13244f4eaab47315d093ed5411d319f79df0065c59347ec23cd08d42d4aa0e13554d66b0c00a645cf061a0ac538501edddefe499bad3474e67069c780e249079fe2ce9064706185c02c6f057754335b2f097a700380dafe7c7e551dd51eb601c4928c1a68e89efc3a9b2f35169f71403d79a04e20e32e4429474f2220e2bbe3ff2e182e1f1d818126493b73ef65c11896f84edcbd3fdd525089203f0e282891ff65a9016ae6fcb6297800c68f68a06e31c603d5b44f2ba94f6727ddec7940f0655ca3b63a7a9b60e1919a5a1e9592cac93ded248deec78357a530f5906782723a778e2f1ed687a4e5b3780a260ed2fead3cefcb91a2f9effc7fa074108637a68901197e296388b65278e79858402eb1a7dd2a7b0fb0d4dd35ea8fc675eb117120665eef09afb3e9cffe09fe08fc29f29d50d5b5a8db8338e649ed41cd3c12945dfb46f0e8fc27ef957f2a14921daf04a57fd06978466c1c4599e95b79b44cd2bda9ac1350d0b94d6f15b281b8809f386a38c73ef9f9de9d10239e577e65111a07ff4d88aa216442f1bd86605142cee396afe3e7a2fbd75289c23f6d885852bfdcf63439a96a4cc5dd9d16b307ceff554930f54e939d544030b9574bb8f74b8fdbd5501685161284c45f487b1fda85a2ac32371245db303d1160950002fde0d22b46485f667456186c53ee25cac5b21bacca311fbec4bdf32bb2532b0cda4e7d67a89636991e71a4405b1f5f99a5527e331c7f4096f562d01a1dd735271c44bc2cafdb93d8634b67976ac3280f3a17bc7ae67b3aa688d47e0807a2c7d7d8cf8543213a593f67da67f69e97d7bc932723ef4772aa0d1ec8b08ae6bea669d6f01865926c9f5332bae8bf0c3670127c22044c93ec370ba3a5e2872a82d5cee3733bb89e6916da1c162b15a57164c021f139bc8f8411fdc420469ce0689ead830fbaf56fdd5506717ac4dabd6e732ef90d580088550d73e3c0aa21fd9cb1221fe2f1c31fcac9e350072dd32875d7c8ca095f770ad9cfafd1d1b9e8a02934bff0d6e965b1204098a6e28823a4c228e7b34d34ac4c83a5259cd1ef96ec75245d47e22ce787b9a144198e8386932804dbc85c594ef5aca12e7ccff0fd0e37ebb0a8bf23168ca7a82aa81e11bb3c6e06584b0ab76df8cdcff2c30397a4039766b9251f4e087e420765237a04b1f3f56fd39cac5af388cc8f96949cfb0952447abff726f55a7f5c55afa112d60f1cc7376d27602da75af6c548efff6a0c8f7899038645bda2b324fc63844caf8539a700f9a3d0c5599be6a400bb2f119d432e732da75c626af57f1fe0aadcb48fc5e9519bcbe96c05bfbb4d78a6f378bafed4845ee989ab3c19ebcee2a0357d707c0fdb05c4346fb525cabef8cc5a639635cb1a338ecf5b2af42959cdf56569d02bdcf903824477b5b565e48959d29319fc90f638f50bf670ec7794d3922ace6ef13461285c16f2d120f80c92bd4c2f52614b0b74859e7fbf8e27954ab3ebefc9f7ceccf8177ca6a702f0466d9133b6ec34b1f7f9331da56f49efbd34b0871145469cbe3b8bc19eaed459873bddcd4f78c5ddc08d02f87bd185da8f417c9b6ab954ee7881a45de86ffc4834cf2e5955b37a662cca507f3925ca4c52bd9e71ac42e7db22e59f9c2aa1be8368b2d738504062b0d40197d8b2663f4d7c5c25550361eb00d33d7bf93c3fff6fe75b7d9cd7a050fc6de3d8777b70a98d90d01296d0fd9c36c563e85f039a9797a2e6109ec79146acb3dfc8edf5a6ec40ab8c9f77edd7b26c2a17065f7868a524711ecfc721a4a714cdfd0cfbfcd11109c0f9631deefc1c7ce93b72937768ef471039abd4822c26416de8ec22dc37533b109a16a1730f564acf51edcd813477927a2fb09c9fd950a4326be9b2a17d551a46ff76d7788bf98d2d4faa62cdf5d24b7eed94e9f2d0d61c93df457a04c60b8dfd10ca7cc18516bbf836b2fef08f1c584708bc570665df2563a21f2f0ec27706494ab18c7d9fa9b63808c3dacb690b864c0f3e173ab0129d68331d83bab0922130395df81ad2a6b36f8cb226344996b61f3479c91cec37542c67949dd0b1eaa545bd8e0b7ed6338abee38a3a379ff0f07b069f41a1f27a16b40a82dae16f98f37c59fc5aa5e62d5c0b16445f20ea5a2a8d24f605d4e7e421fea7e3f40dfd1d750285ab331a3d019aae504d4f37ebb74a0b5c98b09add8448a12f915250f69e6743bb662f8ef5a633685a6135b0a972a187870174a35ec11081da047da78dd10f68ba1b122c650930d245c6846a85bafc66bfaa22153b39590de595ddad514d9582d36cb5b0c45e997aea3a74d0c1a277de453c70da66660ea864fe9aac671ca2a27003bfc4f276b2e949db0f6dbe64daae0ef2332907a05363f6754b3a29d877065bd8cf1adda3e2a021d3f676cacd2b24934be06d74daea50958c1a4218189d5a5e02c51ecff63403640ac41ad01f9225813d75a467eb81d7162ab3c894bd4392e46bee21bc2642cb62a71eb95be44d4f031bdbbbd0644e1cab14c7948fe22b1d46867fbb344812c4d66b85d8031e651191f4147951894ba90af8420d77abb90a2ca5948d34df2172e93d567017efee8220df1dedc72c6eaab10ea7af215ae50bbb101a8c7543d46e8c0420a28212fc316768dc4e51a1bbb6b4c66cf6aa74cb122e48b66a3c4dfcc0a903e09705369ee3d7204724e8197872e6b0c6c23a6eb3dff85b87b9713a06fd29ae4e26167a83f6c3e75e9a52b6aeb1531805a7be1091b5baca2b2182c50c0379745d487350b66af553d60c1d2c538c1f66773b4ca3e5bb8049002a50aeb8fe8f6bf77f68caf5b6aa03569e9740b900b0a95001ff2e2e20fb96be2f9e1d078624dbb7fff42b9875e1c87f5d3496fc218daaa1b4c845069da483ff4b44d082044b33836d8faf3fff2d0d588fc5164cceefbc042ec0fbe75ec3454564741ff12c9fc161cc70e4ba52c3224f7ff1ad6534d98d10467b453895f1c7f43e6ddd0966aba25da409191c6628d6f60ebb29ec19e5a944c40adb1ca6142ac6f3444fd72097fd349c7b9f7d0e23bf84d565d52dad6e8cd75eeff54e7a8a21402d4b8033b0b5b18b370e28ce518b486b092f041cf31a7f5730e52b9b1b66c27c7fd601e4a900eb47e7eb4b1fc3bff0cea83b528fe0754b72858161e3a666977771d4c7428d292053a92fcd8adca1b8161de4ed355669e67017e2d4d2425923c275588b6dc4fff6fe57cea39394882d9cceba4f6666bf5e243cc59b45cea68b0be678d3e1f0ba023b95e2a18113a72031aef526e04d0accbb5abe68ab8e01e50e8db23db2b3213d384bf596e91003965a2d3a76dad04007087e1825d46745cd9f88f89327ecc8136747479f7b22cae4318a88317c04e0f0b8bb0f83c2ad5dcbe0a285e65d79ae0ebb7c865ec99c84c53e03e859461b97af877c7eee9041c0e4121c07dbda4cd302620215813432c68b85b8af01476744f32d6d15e7abb249616150a679a6fcd290212085e470796d35bb42533ed51761d9eaf78a798182b5036e9664730e9cf98d3d660e3be950f8293430fedb3442dd869caed85e44b46b2b87f79904fad00249ce8859176f819ff682331b1c66b0b8152a2ce24ff0deb0c83b1b32e77497b93c8b2fe931c639dec251f5f97fde2c0a30ae4a45ca36cb1a3c76fc708134868ed8885bbf41c19eb59444e48521bc3d6e9dd1b88d88a7e2dbbe0a9442a99a1284d88d1ded05a9544c05597e4a2138d5ddffdcd18898130c808c96c849bafc28e291874183d4e641a5fffe5c2b6c284a4c9663f619e92183eedeceb4e5bf114636c8d212e066a95dd3e2a7dc4ed4f5e2703e87e6e3d819caff6580355b7488861e9deab6c2d58ecefee21ad1e2ed47f4255d7d484c742c23c0d8f8966a0bb9947bff2fcb4b6995d3a0e3f095c7e3ace4d5bdaae2cfcae09a8c6afd40237aea54665cce1e8080d6fb5f18894303043e9f1c538a0959d02a3fd2f4487493ee5ec8db1658845bc137d0a9","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
