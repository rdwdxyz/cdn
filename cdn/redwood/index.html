<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7be60e9b931ec5600f0dad7d9b7d39672fd6d96ac4cca47d1c0040d97cc9fb347560cdb1d29e3b0f0efe9ef46df6a47aebd7384b2b655a93c6523ac7651ebc6b89c76e3f60e237bee130b2ed9acf9effbc97124a9ba14fac5500e8f6cd0d1b01814ce364514c21c161afebf82fb112db33c6d230b6754f6d3c2475f2520758c1959537647fa38f055efc1ed2941778750602e28f44784170bb70244f983f2f362f148a72c0222c32de5f5a6edfe4561ab535619f36de419209174a4fb3eb15971883dfe7251ec4d5fac7204e2a1116a3a406d4cd6818a3a5a45544a48c142e5ab43dad4203feed9f7901241997f25e2fa069036aed8588aed07a68ed280fabda293f3e8d70cd8f7ddedbcce561033359b2a985584cd70cd76ddc17e30700a73656f62b533ee67d2ae5409beab7ccc2c60c8276d455242ee9cf2bf025ff418e022c1dc56fbe6bc1cdd803b33bbc0c2e257c3afaf98a9dc7434d864fe99125ded7490d9c439ddbc49016b065507a8ba97d44860e961ec425f2bddccab061d4f57c31d176d2da661146f1af58ddcf8649f52a65f803c648943ed7b7b1595b2b8542e1b7367924fac96c36b215e14a28a0a780ad3a6bb41f9067a29d01e60d2711b04d4cdee53bd7e540e7cd88cdc70540f1b229a0855838cdf5ebd29f048e096bd06586c9ceed4191e1ce0af2a2e3d6f50eda80d85dc88769a4c3ca470030d7238733b565d7b2d67258b574b9e62015e8b064918af35324da614bf389501b0bad0f976558a658ecb980726521bcb6267dd37cac420eabaf963a5b3908b2bed12d196d465494ff10c8b6e143357a0808b3ed2a3dafa8df3993c2ce0fbcdd6df351b8b8029b307bbce1f473787b004aa128088e3c2e93a65ea70588fef01f0e042adab5a8235f06c8d1920be9b6e01c9aeca3f74835b4d80e0afacdb815971c8a7e50deb4a390bb3bc7fd77adc5ea8547c6e74742710a123c5bb2f94d05a2f7ad61d4910f3c770b17d1aee8bbe7a1cbde10d8166fbd2af42fd374c58a91ef2fbdb5a01daf8ac97fbe4506483dcbbd0596055bcf57868c7162362842cb85d861b913376458af8964d2c6994bfe79c0343900e9138808faa6ad60d1eee2b62977655a523c2e06abceed98ab6eacc0e474e6a900c5e379cb862bd300d3c366193c90eeb1f03aacca9e4e6986ec9952ec41b10d61ead0b34583f8c879dfb8a9307cfbb74db212722798cfa670b23cede7c07cd1ec46de1754aebbf126d1825ac42db0e41b4563678b0739465b5fbb1d2db5ac22576efed5aeb1cd9318c78b26a97f6543458ec37f44b97c44412ba9bcaf2093f316d1cb03e7b12daa145a3d612296f8a46c92c5fb87d180456c7f7df0b0078fd58b1c14b8aaa108119ca16e27944222acf30210975814a9e8c019e2b05c365da6765f4066ceaf42e939905da240cc94cd4698e6cb85249a33a4b033c2fa4a2870b45fee7b21ecbf7b3f62898ab66663c9dc84b46ea2b94521f4711670c7b5332939d6de19cf511eb1979ca06a122f7819f9b0a2e2c1bd903f9bda5bd3e0837dcba19c9a3686fcd5a1fb3f9f4008e7845bdb78cc6679612c46592c17acae6d3cb79866e28aa3fda77f2cec4c299ca89d4189e5875f616af52dd5ad05dfb03470773a6580789393f27418fd6b78235955b1ca5ac20eeef50269ded99bd7e86575a4618b68860cd596b48ba3b343156f3c30fe4ec1ca26c6e7b9ef0bca04f9312c76792ecbdedbd4cdd97960bd614a46fb513c1e28db495e044f83b6858981405b2a24861747533450436a6ac8515ca9d197ac456ea785e60fba60ff031996884f00bdef69aa5241981b0bdd7f0dcfe9df1e42e50b7bf3604260cbcc516586bf0b233caf81c54d72beda76e43b74999c9d2f2350578f138b8e8277b9b542f1a4695a03b9a777f954a3e875d6a3a6f50feb1a58e53089a3825eabb6e1263613911cbd9ad3600faf2f05c725a5e0a8b9db3f4197a61b89788ca8f98f7af78c3851a762185f7f57bbf2ae64a84d09193860bdef5af016fc116443923a7bf74ceac3a79982cf8357cc6be63fd1feb7481907b196eed4a56aa3b9645c0e969aff2b794f3af02aad2c9d24d4e094ca3e232972a41bf63ee4d39da687bffbf9176dde1795b5fce9e323427b8751b835d5eb4ae1116cc1847d1dbf8823121619b787b5f2234dfe3f1c9e147421e1b4307b9d0301f7a1316d244d283085d03d7169c272fbb3ce3a29e5c653b878ccd37871022255e933acb25c4d8f91d4832f57a1ad83cf4525e7c81a5802e5a9451bbaed22694c865b508998efc3df33d5706a6f83228872fcf083300b89b228eb5f39a038e14f08dad25bd0a2ecc6001864b4d9356fc9bdc1968614897638833d064ddd457e0482ea9f7766de5f53667cbab818b63945b7bcb5c61f6b54a218fe0258e73e123c6c874295fadd08c6fada2af6e1072ae1f443e3c7347a3977a71d56b8da3acffc5a3bfb97ff05e622a616fddef56448531868b1df9fc8e4a1355f2b325831010f663a70cef55750438d1abb1642ccbc394b5571ed5539455543d9f467fc212707f041eb3dbe7942c1cee5608463937b55ab38d44a9e497e150c763c986399b1499b07ae56a511583e0cb0d6cb5583044bff287d83a254c2c299396197757de7a6bdf7641cf7f135015a98324b609754be8049a7e6c0419f64a5f98f95c15d1aeef5a55e38d2b550115c394a47cc3d20c6264c1d43f30a3ce413ce91e994b2bc00a860996ca6a3b63f2c5922468eff24572316ed9ac9d72a3dcfd6326fb415d1e6066cc7eac209cd0dca81db1c05e61cba01ce95da13b2784c9ebe3cd7ebe3ff947219ce115ff9207f58b3243fbeaa99a4940ae8056c0fbc522e5ca5c404f84ef3bb0883475a44825f2e305039295ada24b0e0ea33e3c47bbb973dcd58a55e934a278d42164f912e397ff588ff31c6dc057021918d5ddcc260c105e2e47f76324758ab08c16bc5a1eb83e1023d1a0d56a1c6b6841edd1041edc50531aca9b7a9e93b1ab7239513dc03d68818f7767390a08ec7830bc65073bb6b45cdb0ae39613043a2daed8f1472e4ab97204d1981ef2fba5c4a788cda1871cdb5ad3b78a8305d28cf69848f4ad411379a7f2ad0689df0f1905fabddbc110f29d51c92d49b66b818315696ab6873037684605723482800df442320b2278d6b116504a9d9e11c5d2ad80436e0c6e256f5da65db3e44704acd7abb215ba57e4934a94802fc767508e8a2b505a139ef6c46ac2cfb2d6f993c9f151d365b0cf4cbc07713463ff9295753ac09501f9b52628ab14fd20e783e35e4c1b372eb63a71e8cd2d94ff64f038c2db4ef6842f268449530794c4a73651a08a241538295569e7849b3959d91f0c2be3305cf7cb01b20ffbd3480e98fd3b66cdc1a9e9602f83418f878525873b5bd3e2950ca0d1e7653d16c059ce40bfa75124ba05dfda045b0cf72528d961ad81c406e4a2ddb89267e6b047205fac547ae24698b5f5a7bd9b8ed1f3a6372c1c405b1536a0d6e58d3780f35fc3563cf464d5b65ddc4ed893516578111b81db92713e6a16b39264636fa1914e51b6ea8a7526d962aeea160119b7448cf4ff6551f35ac0f03f1b4c73078823418b057f89ea2621191f8771d87ac93bad1414bf0e63f8003948e21cdde78a34a4d45fb4e2ae602b4ac6eb00143eb257879935de9c06edf22190b6e60af553e98b4a0a391508629ff6b29bf61906483977c477e5a7f0953a2153f1b93871d31dc571a29e2bd0c09e2dc4bcd39b09224a45afd90db5521273e721513f6c670c9fc5f723a166fc1527e07ee561af7d7448348320df18c8b9ba08bc17fc619e1099a425f8e74f50296d12ef2153bd88e5ff6da9ab91da4d1961e615d373d94a9ccc234820ebb41a4d150b5527ca26dcbfefb04fd03a66895eff267bbc23f1ba2a859bd93601760677cf06561f9b0c1353098792f568dc8e268024203cad783e7de2b9ad9513ebfe51d971d6aae2268945a4acf0d734aafafba9b600a45768e2c64498ecbc591860147c07f87a3819607c2bd861c99740ad29ec9839bfeb3c5c64e89b84d4f5b36ea76424290c3bf8ad2357c75888ad71bb3ef9ff8b24d024344812733485f94684736bb3fbbccd51cd436ea02f28750a343ad0a3426c3c896870a0936482bcd04188b0c5ba029d4a4c3f1c20b5436ae5bfd66f271d1f001339388ec6d08acf72260e89803a19b2eea46d12f6d9668ab77e0fb0f5dc31dbfdd1223a8429266f12a810d1b759aede5db2c7b41c4cc35298de6398da882a969d0b666f9b25131243fa092ce97e4eb071c31085388ffd5623085c3ed2c8194647c8b69a3cec109f91024c27c87cdcb4525a250628c8fb5efe57ffd08ba7c491c04098da8e3b1cffc524294be2ec97c8a7806571d566eab792240f54c775ea030d25c2027307f4198f16009d3eeb6cac3e5b026bd4fe09712167887a31367ab4e160707fa53f5b65ad44f25f6bc8a02444b0f0626290172e42b0987ef2180e58dc58cb04f30bfdafca7ae7d7bc8cf8b0572e757be68f10ee96a3f9a5e364e3b54abdef606f6cd0cfd850bd2421e72bb29527cc0b7441156558d33f15805a2eff4d712be7f0ebba24505c75e3be642c4af25117d504b028f37c680723c9972470e5afdce86936528e031fdaf59dd9363b850cf9f2154502124798a87f922c7e64362c8265995ece211cafcf3c322cf12d08ae5d37c6c9160af9d64616ac33d820f311f2fff2cebd73159e560891626926b4da653ceb0ee31c9240ded81f8b40f0e4144831be1b35aca4cd5b91c80c85938839e459b49e5bb4d7c47ebfce3a4d4fd33a21c732f7925cc525cb49ffc7750619bb17d5222f4c2da98e5103ba0863d89cde43cee394c245e21278d0d4f43b0d233dd5c26424e3e02ad0cb4f4fad0b71265add3b72248c16e82643ec25cd6e6724836954a1601c42d65779e92acbfdda22eb0e4339c8d53b4120a75b0d9a96a7ef759b91bd87d2be0b24981ae62cbf2931d0efad7f3111d8188ab4f60d78ad31ce8d034104d7cc0676b44904cdc7fb7915f7c8e5cc72d8fb4b68ca78622c2c87efd6931a3ef33c9513710ffad014ff30b472958ae473a2f0757ae74cf706a7e01b3c170b92a545acb20fb2fdef2351c16a9684588c0411fb635abd45b27c7c4e481c49ea4ed0df5736df488db0e9bea7b1677157d1c06787a444dc0bd2f4d44d7d6de13b98f571b944ec04950f787d53f4f0b8c5514a380d74464b42b0504811fe5e83b89ec0ecf986fbce3ccc268a1f57ac8a40599bc1df84df5412a9fece10a80328f13b042568d820e54aff8642df74860d5ab0e9d7b47519237d32981b24cfa7b066c5cbd02cdad12032a850f0677f476382664488d443592ad775b5030836358fa0d8205f03b58c53b9e3fe0cf09ef8c33a1ecec3229ea425b56a2831bd54941a587f829ea58444559c99768c5f9a944ae242499ba0becb5f118b2ec1843f9b3b350fd578536d6f05edceb23c4a5da440d009b3d0065e74d6b6a086e50eaffe2f9c5a3dcec80ed77fb33326e2c76f0bed115b34408926649bd18e04127af3cc7293724e0b099b5d37a77a0780b9acc38afb599773a0d1ec7d7fcbc5c2ba89cbe525bd0a5ee132e9e265602b1152cacbc5ff8b318f008e9cedbb552b9cae1c4d070cb5986ec8774efcacd4b29d0a8f962e861e7f5a350f1af67f15faac6ac350373e036fc6770f45a3d5e807a511abf8dd4d04f1cabb98c4e064e016d188d1e577782c0541697faf6bb6c0fefaa1e04b3fa103262d61225295fabd532fdbab9abff84abddbf490fca99b5030c0e0d93bb02b0c96d2933ce0aef9a6897953d7afea9591af9e24643633c2afa0f95ffd9e949df8e84facc8e6e86a8ec804f94589e046ea430ec30c185fa258eafeeeb494a43d89e1b56a51929aa4fb2d607570b37bf88c713e7d863df5914e7328715dbbe88b82f12e99fb984447b309adad0cf86a19840264bef9b118699e45d275858427c39677f685bae98857dbee9471bea3df2144b0496ff3978839e7370bef72ec25035d8a04b73f54ffb025f6edf2ad9a9c0a1adf700b3b1fc3dc398e381e9fd20e37855cef368a6cf8b5c0b6f51cfcb5d188ee1ca748832b42a700231a0fbd104c432b18450ee415816b2dee4c8685fd929c3682098424361cf18e34ed96e9aa0fe055512be993340ac1ee4dedabc89e83d42041f2e4d7c315f8ba5f7b2f5f0963640182244b4df97eebd783da3e945174c802e0efef558411a3d9ac716f02334efa59ea25019b76187adf52d9192f878949957d504c938d5386510e10315faf9561612678736f1109d901056d498d10f50fc2120b38f72b09902f3d32455b9b94eea4f56ee9aa98ff22854664140de7b9003e7dcdd15c627c465162b8a7c22565589b141b75e24d3c44caa09ee29a5857e0971a73d785fc877b6589c4137ff10db6dfd59caf79630a141c6dd951b74330e4ca5849e434e195a5389206b415f90cadfddce4bda2a45e936e3fb5cc809f3b67a2f14e4fa0075019314b5c83ffb0c84fed10db81ae4a25f445d8f4b3ccedbfc923cda77c46d84ab78cffa31bc47da983b829157ca7da4cb1d74716d0e10f5bc6ad510aafe1c8d69ab7151ff8a934eec1a73c417ed0ff201e4af29a13186e56046a8f7c92fcbe1bae802e05e145e87bd9b8ef1ff8bbc83f689b3b6335e21ca8fc97f61c304b9a020c0cdeb10a29de2335e7270e1a8974eaa3a55c16d8b0404f52b9af080698c9330800f0cd1a3f7f7bec5ed01bfbb518512eb56456e30184978d7f534e46f06d7c2454a1ffe506c7ed67b74511328a8b59be84c6e18689d4e9b7edcce33da3c595f43dc6b4c33debb6aa8b84a4521cae3572111c3d6b4667d7885b71153ec1cebc201c9485f9d7077dee5370981e2ac4bd9043adc689a23c6fd7448b0807bfc0e40cad2e72ca62eb5c96473789f170d8d611b93cb9d85eb5f773ab7683efdb8638f5600f9a0aca59f121ebbba4afd69a259c424d70995ad90f75f1fc2610be44472976a79805b2a1da4047d81b0b57ff190da8f2e12af3c2a030d32fc275601f6f03dcedb556be7149456525b8195bac545f54b1fc4082e1f8ade8c737fbef003de3774957e5b5e72513f687603dbe16758fe1140c83baea72c34519ae448776a37685e9d5722d0abf68c862da862263cf0d6c6a702d5037cd00b51ba4e79523c510bb0ee4148441749c8341420cc707e5b334d9788b332b6542a6bdfc7d2c3aebd2a2b240569f4be5ad7898d7efa095c250ffedf80f54085a7abb62aa2595ff21ec66671da41f61a3cf7ef15b3e0f6ab3d09f2bd66967afb9afe0e39d3df5fdcad58dd31c55d4cbdb8accaf755b159726bc76211ef63b027ddcee6da14684ba4ad276786773a0caa96e6d7d3a3c07e4aa11098609d0ff176350cdac62deeb858d6606eadcb2a156bac42d084a6672ef95bfb6d77b8957f7ff9e1c0fd5534496e5c3801e7eeebca53682e3e0bd9cafe83590ccdc118795f436f5f80bb638305073e2e294a0ed865aef08c1a4cce517951c81eab573c7f39e338a22eeff88a2caf58976945283cc1a487ea75208b45de3a5f32cc9b4527cef96a068cee7d8c2f9183f2ec1b9e1ce35050405581292db574d7bab56c81b3ba0be4ff09e79ee31758e9669f12e5be027f324b04d25881ba1425b0115d0e8758f15e23001aa11e0b7e3d6ad10760a3c6848f8ed85958e004d882b49b293c8f84d847560bc477bf5154eb7a633e2b5f6edf56362dad11610904e0fe8beef2c2b18fef366863e2cab45a29845aafc68c81a70f85d0dacd3e44cf312431839511288f795935be7bd96967a5c22e6beb86c8d65a6a95f65e73116ad998e3fbf3659b7d7056b6c03788201423e1e1422da710aee4c8b24d26056b8293ad63732bfde08a5a60edc845ca9caf830304b8d176ca71b2f0f9430786efd2a813c297697d6da369295ef58631e2ac6c52294485fcb72ee770a356b7a1b511269e280ad9aed0398d28a019d70b1c9749b1729955c433e11fdd261a0eb85e6d20cffd5bba066840eefa76fc486a73cf94ea1ac49480eeed27f64a7bdd58308ec6f093be8c851ee95c7c5f8f5a1c6bff30cca9fe0bf23127c6db7a902a0406a1405b12743f7172920295caf80a2ca3c96959db7682aaa2c400603f5fd1244dbb4bc581f8b825b25a8ef6826fe39c5ac667b09e84bcde5bdf71c40c766f59943203459f0a88a8ec307d67223e50ed9f8c8713fa2ee1799abaf8507a350f570f1e1fc04bde0729f660aa1a3c80cb93ec5c3a335ca5823580963fa4308b9cbb885765304419f4ce7c5dd46afa06fc813ab141b82aa4169fa5b95472642ebe1e502ae26269208184f9fb3c7455b70d661a9158efd1d66195148b48f76267efaf36a6391641fd1d71fc5237ffa42d5bb93b214f6d6dcbbaa4fed894a13021f76f330d5381893daa03a45ee63fd85cc8352a12d44ec1ac1637f1824a4d64b755313fb14bac07525adeff1640b1d2e5db9bc08f4b33f89a82789e792212cbb29a7a7725315c0ff47bcaea8d952981de619d23f78b9773832b4636ce7629d74bb3c44ba38e62a9f10975f963d8a5f918e22c1ebd0c4eab1d6fcc009c98c7ec9b347e0fb4fe0e50cef20b11c871ffb967c92050c4ab369db2ce664835b49a89bb8839eb14a634a243ad5f8e15d86d9e17301681c7e1082d14a82b69a33196577f82be300e4be1c24f58dba4832fc0d8c2e186a66f3a10c6fb9de509b56e626b75b7ccbc4eb83980801c73c8f2793acf9bfae956bada1dcb909e897560f441eed6cb405ed51af5f4e2102f3ef6a9e00cc374439755cdf616647d68029474f9a47d6a6843c58fed9d0bef3a80b2cabafaade3fa1b073fc5f5d7952c8c6ee9f1acf254962f04b2f679a3d633acd121a7b83235245abc4c95610ab7a7e83a6504cea61b5d4db92bc26143f6da46c0d751fe01a30f9331d1458b94296856eefee67d9681e7d9846e43587bffbca35aee8e0340e7f037654a36899e452d069cb9621f0d5ccf2b409420a594c669317d044a2f18c7d9bc0b75f37fe040b360360aae8ebd7548d3ed8ef7f1af6e5db6a570c650bda149ed06abecfb3cb9dcd33c28aedd5689625265df7cce9b998b4f95ff5e9b79ca0089f81e7a77b6f8512a87f41274870da3132edb5adc31569bf32e90c874bc95a6f2e07b48bd6b1999b956df2239ea246520795da03476d20c032f5119176e51714d39f2433ee00b455fbb574515994423f4415e78ee9e9d4da23010bac2425cb38038e5ea6139c87082733b00885f491bcf11eaf45af4232a2d700cf2a420674af58b8c29df6c7b1889af3f1ee2d5199da47a53a6e5a1865d81d6ecd42126283341a1ae1dada01b921bc864b48ca585f9a5d04532eb2cf7a54d04c70cf7ca4b59ef552d9d7612225fdd6441d5a2d5afebf570f9b698b325df4e004c8658c08d64db0dd0d993fa2fd22bf3415fc1fc9d5c7554a04b92bb0cff5ad22ea654ff557a2cb05d18d7cebd8f157100f97b78dbdbc6bd50fec506f34343cd9462c98d9d56cbbf7adefde0da05b0bb90602506bca55ca57fb90e1b27162d2caf71121223ddccd456dcbf3cbcd83daffda5722211bdc96cd24bd7424bd78e84847f81e1190af8ba73f263d6c97e2c2ae0e4544c622ddd088391132fd767e643e8e9c43eb6f93c1c0d8f4c49437ea4ab972a2ae6e0751e2087ebec68fda4869a64e05c18b398b27641cb8f7e3f36522144d9b7da7cda301f38a146b7d1e2ae5226ffcd4f703d252b98a4dc529f41c4d80171cb6ce85846a6497ffa2c307cf3770ab6d1a2a5784f6707e2a74c08db5203586ba918c3e1792c4aa164600e523c7d4eb65593f9e0616205e7b2db97042e2ac1cb3c27cc26dee7273b482c2bff17df9ec4674efecdd11e085f70990b44426d7851c919f59b7c7a37e4740e61dc860643d41ab755350d330b04a00189d08d3f5dd14f2f69eb05e1c85e8b3417f0e20feb0a12e19d6e55d913df0fd6882d0ebae5777dbf237d180169bc47ce40f4312f7147c26a2aaff30af6732e4b8ed5b9818dc2983000de1f3fc94bb80e5d3f8ade1a531f42a3b5df760b1bafdd718b8dd3f53dac13720b030eb6650ea2aa089922409a1beb56589e4f4daf2a3b7e631b1f92ea8dd96c4d77e77e3406ca17533452565cfc1e4d6a0d5bed71943b00786c9fe5b6763bda78d1f41d10686c04cac820abe823c7548da206c28bcf9d311b0b1d1cb28b3307ccb78fa6651fb1cb37bb361f67aaf9903ce967d1884ae7aa72b780cbf00b5ad85ded53026d9ff01787220f4e754a4b7abf768d3e70bac8966555d97535a6cd38277a66a89da2ba92e0b509d679fafae3fdf44b0eebdc15c590f3690dd35294c70769639e04acc8d5119bd2f604de100a5afc81212f2089d42fda7e9da7f551838a9fa85578f173c1d8420d89e020127a5f5a4cdb0fe3113faefd5c97bfbe49f50fcd344619d8dab4e359276c478075063562800be2d381ab3174d264eca3424fce274622eab7e1e34365db2d2aadffe8e6f62cb923028a3d59ebcef0bdc6bfd1b75f82a98eef18266fb4be547a7d8d8ae0c26b690ff36bc1d729c4a1bc0ed90d3a266632e56dfc0604910a58d078ff9f7df43a6134f856f402454d408971cdab0b625e8eff70848cace7440350ff239a3543e5381c24988e2ee0fb1a61386828b07820c5adeff1c577978039906cb49701ee090e8ddb746cac7e87e0a66cd2d828acbf7dcc95cdb97bbfb9fcff68ca555c2ca0a53c0cef85a190344255c174123231f3577f550bc90a206aef5c5e60d0b3cc3d00f922ccc5cf39d15a112696a580598c7b71fc4386311d78d4f6c98afb7dd9bb62d167dd0ccf32431030a0d6a2165def420fa7df4cff5b779d66724afcdd15ab4947844ee0c0452cdad350c544c3292fd10e5340bf8a686bd03bbeb2ceacfeea2d2a8db165998fa5cc332e37163339a0655a3664b40eae475724904a26b0f2d48b53cca11ce081bd7646016a6a2f4f2bceff7b0644cb97bc5de985fd3b23c9f6a9c255a51d6bbfa40b43ae3569cebc79320804ef75ee2cb4932f2e3a9d749a1624322852dfb52dbb9d1cf598f7c2c67b058e051b979eaa3cfc06fb6718bb432b0115d8cd9ca8b47fed8394d0659669b7200b6aa8600f405ef225d4b3b957080f0e44d5dabbcbed6a0a7262b4ab6b7128602f5fe0ebc027c8f8a3fcb12dddf2a1058a42d77dc76dc583f6173d482b564729242c0d3c93713e5e7232efd8b0df0b07506a4b3a52e744ba17e48bb537191de5312a8e6d3cbbcc308dee4de6a83e2185a995d03e9582772a701ffa1c6f6236da6e3d50d6b74b42693c7fb95279ce470364ca56497e47a1a6b3d7a0e45121d8587d853956bb420585b6f5bd0c0412f3f7f47af498bcb36c364b77543c9c164b6da46c4f096919b64c94d65b3411ab00977c35f05d7df057c3d434d46f5056eb894e6763e19a9e1cd430250133074db6277995149b13dddadf3fb26b4fffa5f1cad208a0f388b2153c186521c19a6cdc46d25621e2dc754ab3975b02ab6a31f8c9f042948f8e79dfc0a5b475b90383c721f67eeceb502eb793bdb1f2bfdae2d8aaceaaf8ae05f39acf01b780e9aef2f24a39b76471c1a09fa485634cac50718bb027818d62c9a5bf12b7d4aa377d508368f34a552ac20e7e096ef83fae6fe5897255bb4efa8eee69479e91db1cad95a3bb4eb8d8dffe56f1240d091fa39052422922aedeea66408dd70bf4ea712685562af809d0da23bb1b87110d3f16bcafb8d5f2e8d3cda77c462df77c265d0bd046359b56b4424ae562682464d36b45873b501c6106f30dabf8f2fcca3912b5236db8769a512220c404277f689fcb52594da3460c4cf8ef88684cde3e8820594f0eecae365f9586f04d4c23ff7157a160d724f3b7e95533f415030d4c3e9c5e5294e20afd9a8b872173274c60e74ad90c631fb82ec48bed7be873c407d5bcfab7e483fd56d62e903b4d1eee3208379988c3d3774c07d6cf0f6d45b3e53d3d0df54dffb53220ff4db727ff75a26027601191ba09af9cf7c1f4ee444944164bb2de089f93fded1ed5e5809bd8d84a2d78b12eb299cc546ec7a2f3ad221b56c83033da66fbf548ce7384570c7158af4fc0f27ed6e1ea0c4b056dea315dcd32790258ab41bc1a09df58b120ef50ad636757a71cefd999153fc3df198f3ae80df8318f0c0629d8c5352533b2481b5738813d1375917cbdddb35fa1e498ebeec68ee2f0bf53bf6f27651d2a9c1991025b65f6b925b09f29e74cc325de0d00be1575d537781508dd098d0f1865a7040ce24ac575b7149650f2433cb8c95d9a08e41c399b8f24f52fc0bf635fcf28043d6127fce870219b6105baa97663d6a1347b90bec930edcc72fa93c918d820f562f9d34de4ca1638544ac0d30484fc4c0a27ce1b38e7fc610dc8fffd649096c7aa451f7739b43920052b77ccd2990dce61a87434ec472dc0768fd3e9561e2ce6e7eaee2eaa37dd3f63c85a046eb6b73529473bbd8ef15219f5dadaf5cfd5e4a7eec973881b6e74b8ded6d3b3a7ee31016b66b8fc78051c39afdb7879a2e4ebfd5aa7f3acacd4d5cfaa3caad923e9b12b8fbca8719767cdf6de05fae91df4cf51c1aab5cf15d68f5de10b1f8f6ea50b0b8812c2024d63696a47b95515f42da7a70ae24ae5584461cebb53886141ac5181fa3385532f391ecc4744f9b1b57733d89d3918c3f02df9b29c4cc84c321b700d9f36866972b17f4f06dd5ade172f9f62e62c5cb5693bf0e261a8b25e4d27f22306ef084df2df4bc199edf5f0d84b0b52dce6f75349462d1b501fa9f69656f17e47d82ef2d849da4bd9ee4dc404acbad1c3e13d131e53c8d7bc06fad7039ca80720796785d4c190df265f4e48ed2fac8d1aef22fcd3d0fc7ad21d99e873974ab8f6d1164c34bd359c15aa07e44f04dfe9149b8c4d253cfa92684a06b1bea6e1112fc37e30a25e5e193a7dc7dfab83a35a487df8b53d578125e81699bc9735cd0799bdc72118639bd8b50268a91d634c629fcf267b2a4390c0b8c0aa0d125cead4a82541f2f018a581ee4434bb7d316d8197a89c68303a2f23730bd817938d2e23aafa715dd84e7145305427b87faf8fe415fc29a327f69f703196e2ab42910f2f20f454ee67457783800c0071ddd58bdf083ef6e2dad9e1d770988ec96639251531a53c185a0dda56676e99b34a8fabd95bd81f6f4ebf89c3483ccfa91d1547d1d458d88e89c7e58b21fe2428f5c8e4c7f4d8c3e618e47879051fd46895f69daec0269fb4be92619ce5f97e65a5f49322144954c414d33f92c7eb693cc1ed104f3065d1eea0d4dc3abeaa73e758e28c0515b0bf0b5c1a93d206bbfa7ddbb34a3a3c9a3946875493ee7fd864c55371bc1174ebdd02401bd5d833414193a36a1ae8deda51d2a80a063be4bced81b4926c978a50b51409bb509949f2ec0e9ed7b3800f648e6d68165a22b3f309dad2041642a5eee219f77bb8dd604d58f4b30b4a4cb1e317ad92492a91bbf67b817da40aa78cb0bd25dc9b1686d7960746af395b9fff33f8afb5e369ae16b7fd44043e8388920ee4796c10f32fac60d7889f9ac7c2c6a5b93490e478308d0dae7651d99be2a45b629aec618860d0a9732d168da828dbba7e942f4213afdc2587ee2483d83df19b97185095e3d7fb60f0f7d9c51b622322c209ebf335d633fa6ff0a24986038e94d97eb500cc305f4ada9bd655c5912b2e711e89a7918d3675f643e70e960468536078251d26566645bf57817d099c1aec5df52ae8e3bc78e73444a985a1e68b00e0e77c425380daab114d5eda3d4caf1fff8ad6aa270ba90f625bfbb50abade55f836a159e88f814f2c906d53d043629e783412eaf2629d5931f09938523b2575871e23af39dfbe48c84d3c5c55b3517a640b570bc874ef96c35f5d5ee4c889ebcedb5f264ef29e249d4becda56885adcd632a525f1d4135130bbb5d5d81091ea738933396ba8d35bb58f8e6d6d58c192b1fcf9c5b50bd63b59016b4235dff05381f9fa67cc29b080127f7b4bb69b0a1c576b9281d57bb99ea7d33cce8215760a807d16be2e39a09df9277bbe5b0441cc35e834b7e9ed256e3e0c9c9378248b2f12d476cb2cbf7976aeb4ec8490514706fd5d0198e08ad130121513d4219bed1f1e1531d7913a3a69136409e551e0322b131490756625f1635a1425c63eda7e20ebd904dd974ad4c556f7f0843081e718231dc59a38f0b2ec2e8e19f76cc6b7ff70856c596d9d64eace48c35d362ff7036c9af20539c90c9e08de2d8c3e3d9929ce60fde9a3643a05a475398ca139da9331b672be780a61a6f72db9bb0a41d07147ee78e09f055666733ceddb4495d7a35ee970486109b020822e041d49abc35b7522016ecfbe86f7630abfb86d2a1f693f22ecde902c2d43aba154b4d64c551ffc3724eeed954d9d386d387011849248570c44e50888216d36f92fb205ef979ae97142a09ae94ac1ee44ef7db3c8a6562f20ba3e5b0889432c5c27e4f17efc25a213a9bfac7c3118c66aff0dad788b0e157a20917b939cf78e7ed17451fe91e1953c620168149e4b14d819e04954444de26d45764c4538c70d8dee9886651c53fe99570628543086df0bfcfccfc090535b24c73479db929865bba7e9e123910b8ef48a60c4117adf2133832e317a5c9f5b44d7dea4e43d50676b3d841b1b631bed9ecaea2f935e4f2e42eff39b6aee109c3729e226c2b845449e789e4b30d33ff91ae1a3c219faa683181fec9d035fd3209d488beebd2b5febaff2698227e8ff158082f52916b79c7ffa75c99d968d448fe4543b7ff57122bdbd431c10913fa30e64a9a993ce3b754780dea02629df0d37b673e9a90f7a21a8946b2bbc3b10b5c01355c64365f27895ebb5802cfb58ad5f52cc1fc1eb29102b9eb03b3e678f9807ec5e098afa217800e4a544f6a8801eeb9d5c8fbae30ec73c9004d5e166f0e2a0a0ce94b5d632c93550a9bc922d045b470fa9d1733547b0eaba0ce007f89bfa0769a2afbb392f58083de6fae798ab30d6acaa40a3456592a6c4d498bc5e3096c29180648bf33cb77a080818cc5cb60e6b99bb1d39af4a91c82eb4de6f23441baaa26a769c2917ac9f6e6609f15b56cc5ce6b4dfab9a534a2466def12001d084bb6877fdd02259f4eca1c3d6f8492a81dfd1911a6d01d41c4c8dae5c7376bce37cdfdaa3390b58f259b52af652e543e6fbcb85f9f6bc4ebbccea8d67a48e8e50ec7e4cc674a51a4cc30585cf99f87fb46c7354de9a3364af62d3f000b9a4a3771ea865051cfc3eb268f7c24e9f30f179b1f2d5a2af764045d056ce21e5b8294dcac8a5ab9cd2bd45ada0562c0095a5967f86a9dead6b33e72e3573165d9125e162a71d1fdd2147d24d28918fedc217c5266903981ac3e0f03db924bf547271646d81df49a046203c88e9dfe2f82b02bad08a266b8280ea2b8984f5786d2b5dbcfd6fc44c9c3b42fd0d75e42543f8d3385bd0d3e3a2d2dd1544c3fbd1591ba110bd2c26f790688d5961142701f93c4ba294e30af80cf7d9ecf0ee06c886213a43b275afd0074d250f5ba0a943af2e91d5dd92370c5414a7208710d4e15ceb744026933b31610b0c490fa4357948260bab2279fb70ce492f2bdeee7a2913e2509eb75cc87892f2f18839618e2408c21f51c6d38afcbbd9a6f82d8e2a01cdf34686c06013b87d009d3da54fe82b841cae31faf7fb752de8437651f7adca99f3f07bf00627b6d775c3b2a7d8399645f405c731359f01d08f4c60adda9038ef1a9f23390f252c293f8455082df13038fff287d7b48859b99171d6813365dc6a278b70537aab3c81ccf04ccbe82a4844d03469984ed7f58aece203523bacdc575b458a8905cfde68e145b3742dae326b87628fe0e7348999ca9e59c758d881f3118dcd8e492a28d688d940524c055b5a4abb199500e6911fbbdbd6fc11da7560047a6e09a68f0f5af03c36f6d98128b46818ace384a510f43aeca11544bfd0f3131a9983fa02f8115221559a0c105119e49200031ef55818ed67f167f898d54c91ae9282eb564507c67fdd4608efd9d7a10ba4883a0afe7d95fde1e355551d609abc87e387de0e2374485192a50befcf3e572716e78d5dae50b49ef2c37bbf6907341f748f1aef5a5a271d3b23e907ac5d2891753eb62425f659478d25782bba86bf81ba9e27d441eec851d38c736d5779304a7243f79273ff89ef4203b37cbc1ca6e00e2d7c99cdcf72df607f0aa8d6b5426cb5ba962f0422d2200d5cafcd9b858b6625acb40faec9533a71ea0fcde97de1e0d4acb7bcc21d3fbd821a9ef751b491aae24e68132b3c68f19a7e570a2abf2f6d93fc95272432a73c5378fe6d2c7b1ec9c30464bd640b92ecc231191fe1a4941eb649990cfec4874ee0f6bb669e91a5d7a90de48bed12f01b1292d1471ed9fbaed6d84b6f02898dfdb3e711c18b27c2fe8a6cef2ad10258a1fa2c54e70f1b6bec6116814d79fdab4232dc3da978c13da5561fe2617e67e53029f4f9b79a7fbadea96b37b2accd9e27621915fad8fe5b0a2ebacc12cddb4f3e5a30cdbffbb856f3e8753c470429ee311d931abe600dd592309d2ccddd11579b1a248268f169cf9ec6aa21dab9718940436f226042089b498193e4c304fa9936eb7fa7f1eeea6091955e9d7bfe2b74e8a10ef1888a35eb363164b5534052a84fb9a6352d77bd44c41e70741f219bcd20f0f4d4bb525ddcdf4af6a50b2bcfe6165def664c6f44b74bdf4879c04cb27b56aeb3d913ae20a0c4b1cb4061144617ca8e343b60e36f7aa845ce45c185a2750920c3062166c4458f89d7da19e4c934f84223dc5b95ad0c0e6b56c4742a513dcd9f5e03ae62bcc7813c09ce15d09c87f15b7b9e4747a2dacb49aa673f4251cc35c221ac8fd85e47a528824b4e8626689a4d3224ca6629ba6c3727331fb0913ba8546ea581207bb30c091cd47fd5982223c4e5770f347c7b300611ddc1b54466e16eb917870df51cad194ed42173a849011ed6a9e0208c6bb8372acf1eda401df6da5e895564f74629f5aa3a11e5561d6069dcdc03acc3e961394f6355dece1e587579c537d981f6953bbe87187401526ca3fedf1179308cac95573ee05546e54fb0dfc8476c7de30c08f16bec5e060c79c3e149f9d4d2843bae3ce6e99537ac466e556016621ccca3257a9d2637501ad445727eab160a2de873eee76bdb82665555b62a5fcd3327232d99832c2aaeee6155bd250a183d6c27f9322ab38264773c9dc6e8f055845033570518219e59cedc88213367b13577c1f18514167957844dca05e26dad4538f4018d1d564677ea75ae3d3ef6ff270fb023fcfb7deac57f69dd3d4e9ef9eca54ed3a884757837a8510caacd376c5f36438a58f93dadea22d85670a0fa330cabdebe39d4f22ae85414c49bab44b54bfd869b8371b0a9de64ed1de38ee9365720c0baf437051ce746ba04519e4cb9f0fdaf14e963d4ea888a59f1ccea815ede030ebada7e0f8ecdf8bc9f640a5e00dc0c45698d2c45be8adbdfda10b6dd7bba090802244415d03efe3edd77c9b906da57f497278928194750e41a87bec94aad1a3909c22e50da31d6ad1036b198aa8d977e36f5b7b3ff0472b9041c9575c79c6a5079d2bca41a82532258286ea0e6da7e905466b07a5234852e363dc9b48e615824a0440544ede03f4a93a90f52ed36689ae176a9f075cde449c3e6b7b5728c6abf281c2b6ed62da0cde66154ac8b0b5eed9edb5d1586ce12d41dce1a88708fb153676f8e1fc3da54801848b019ba9e4030a686137e6bbb52ae90667e881496f7cdbbfa0ddae3fb141dece814ef8eaa983625d50e130cd679b17f2223c7ceb5ebd5b4d57b2375764f7483044e2008f0095972dbe25f689124699e1e79ce72d26c3555ad35bbf8b9d3b8ac64598c24c88671fddfd6f11e1ba0","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
