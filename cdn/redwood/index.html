<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"78ad0b1b42cb278140c3e6399d8fba673407684e24314d2ffa6e7502c1679f644a419a198c32f172a1483f5941537936e234dc36f5c58dcf5a2e6dd3dde0c8361e27ab365c683428688fe8155889637657e8fa0942aa5c96711769a38a4c742a6593587e22fe55db329329fc0f67110e2b4fb78fa4816610fbc775842f111b002815f4835ae00c686ba78c45ada67eefe50b5d3a9e2471ea093ebe3e33078ca6b2583602eb8fde70dcbc52f12a38d82e132dc80134099619f0c3f9a09f867eda9a56a566764c0ea22eb5ac92c8fe513a7a0ba0bccb58944ab1333699c5dbae63f4335bce251eb91c837195442643a7e28e6055e80d994a4ad12c6090a4b79d9da82a1ea5e3739cc60bb2892ae31e99db6313d14ab7529e69156ebb64fc3fcee28779e159b4726ba8c29e5d72b4db3138fbb58e067ad37dbe7325ef5d2029e3ecf76dc42921cb187678b4c51285c59234e09380dbc3ad4d05cb40c7fafc1ed931d9b96d9f26ebf67bd2994aa8ac7fb1eab81bb5c24c5d81835a1fc0b35fa800b44c05ab797e7f24e1ff539ca4cbf86073f249b67257b948724857c58a9e5e9194672d54695e3c98571e1ac8c007d6c49af368a260905d2c2dd28603a02b385d893f6a9ec5568d34bf77e56a97ce976e89677d3357ffbe9d009bead1c139733d5bb04ae54f252e76b66c4cbfefe3f4af45a8266f1a5d2e3dd461cc0fb404ed3889c342d8411e712b9e288a5b6495334f2aa7aeb4d5e83bddb5e8d14a8a410878a6955b4a7b441ae48f88d4666286e06a44d3c96873dd2c1c56bd3a8664f677e9fcd65f8ccde46370df4d74844ab58324f1946817b31795c67a3e8a757a4fbd2574eacf3335ad8cadd05519b1b695202cbc2ce63b6e7dfa3e18eab589b1764b23628d3423bf35be71ff031d6fd3bc0a8bedf1ae5b30bcdc0b5040a3041ad0090bcc130c2c02845265f5c585d0c1aa137ab0362e51863533bc50b3b32fb7c9868f470878d00b77c6fd9c0de1569ccd9cb15987e2e0b1e42a1d4ef522f76ebbb3ebc0e9bdd7c461469bf14fc16e267ecd723fa433ffad64a6b553218be8bc542bbc0ffe58259b7a1ee6c8a667c18596fabd401dbc8b347360cc50e6b8c80d49c3444b3f5675620f8a77448c79d6641c4d184c96e31b810cac5ee7905bd6f7d1e339e49adb70f0a59e3e2b9a93bdf7075e8fecd384f65e41b953966bd27f469d28a5265b3952a304a49d022de1beb4561e85b323e5a51d1a32f6c6de2aa60e9d7e15ad37bdceaa1876072d65b1cbfb34777f9b9ac68fa6dc6940311c9303b381f299a38fefe5fcaad49350e9a1096f31b46cb2a1a327e40b876e02d2524a74c1bbdb1e3fd23ccf14c2f27d4f779df9efa4661b6f1d188bde9ac329c0a5900e4b599c55bc842382d82b32f79ff4191aa1bdb380c42c58a73445133927b4f2d43cdf6e6d0f04a23434415132ad297dcb20ace239b81b51b0fbb2d1019e0a91944e2ce0802ca1dd013e3d0f7b275af62b6b9fdb011d124d54feb3ed28ff41d319485264234c35b589b2bc0a5b0bde29edce8df8dcc7c0d426dd6da2da4ea30b107eb4c3a2fb87abc6565165a8f3165a5bf98b770e18a3f27e10aba73721218335c8a07243cdbe87e3bdde6974e60f61e47a97f592a0ed62dc2d8155c72f7f4578dd87a9228a5d504fc52c466c9c8e74683f6753974289a255df51ccbf7b2a5c10a9eb0b83b86a100b3d7c3908bbf809c5158ade99de08977e7e5122db7b1648ced55d412691bf87c153e73f0faf3d6c21197021866612305cef4d1d3e8b705f78d089a647f8bcaa2f5caead4fa8498ea99a154ec6ca181707e4e19b4e64c551eab5447bbf2c54fee4cce509437d04ca4a9b67f5f0488aea7b96c1eb0f6641aa0c42e927e4814d541ad105301b737a7b691641302113320cc4437c99f6b2f56ab0ea1395afdc60f53e9a44a4ad5709a2536338397d2c0589a446f8d5b9d05304401ba72ee4a821b68652fba2c4cb33b556add0c5f61371e920e0beb37296eaa43d0c5ed36f1c2dd3e65cd6ccc1ac2d819581a68e4781028b371f0ac39475b544cb46940dd6e456e06cab3153c93be437067bbfd2fb707dabce5914d094ce2a5d9a6f716a625f6b571d743c1cd0fccf213da3ac8664cb3370daf2840005c8205f1c88a8fed5be15d1dafea767ffda9e7fab37be6c3a4ed85026a9e81d3632806c638c0fe9f40c0fba8e53b9d5831bfcb3d4b2b4fe072edc6cd7ffaa7550f97bc4b1236b89ed0c78a034db0af31045781255e7f379b3ee12c2b72d6218d6eb8e399c11e4f81e7ddf4bcf1e2c95c60695031b28a10867a3ea0ef15dc0c0e8a1ac2e58201e088248b1e277baf57080b83dfd2975e339ab15aa25a9bac7e3f82c800e2434365a7bb9315a9ad58d0a3dad6b0b423a1a1557510d9d9fb34df7e6e1f40719d98cdd03420dc592e8f5da59de7224a5018f18ac4f2e8daf327c609a5a8b122819229028779c898b82a1c0243674ad85a793f77d3b23e96f306b0d60e1fbd35fd8aac258e4dd8951ed93056095983a66cf65a00a1bd50618b54b8b3037bfc58b41b9ebdfcec3e01a90726f092548c42da6c18b63336ea410a248a7e955adff073c332f93d77cdff115490697bcb998316e0fe69e6d504dd504d96312ec837f752a81aa6a731d38b45afe6c7d5da0ef94f05c2ae16b72149ea349cc281b51a7e30615641a9e82fbcf217c8a140ce7b25acfe878dd1cd26c8a09877e2b7edffc106b0387687f6359d05938623a388dd93a94ef30d207aee9126d2ace149f6d1017bc8803917fc03306ba1552292b6ce6f946088ac0b5803b473ca77dafd379c3ab93cd54f33bcbbc1ddff16f889a20c98791bd00edf6701ddb298e53743adc5824885d6185b0e426291d02871b1fe33ccd9534ad2312840b604c131013e14b3827837cd364d9ef27de0ad13f0f551c375ba2c95ff552b2e1e1df69cfc73e65e2c729cd780ab55c6eedaff3225b62aae88bdc1690a9ccac7350691ffe73d14a985a0b062e784f987c9638924cbf08e43cd4f3957648daaf316d5bea09b59aaf8d5273221ce76a88e6b6bc5539a0809ebe3cbeb7062061c37dc7322dd8be414ee2200c657426f8039eb98f44a9e3481054bcc8c0e6e3b6a06ac4bb8dd0e7aeb20ea9af2852b3d420f1649448345a4daca1272358fc6e68fb858902b562a81e8186df8d9c48b44aa8a5a92505c9d52cb457aad6ea231383d0e41797a8c9e3582d82e1ebfdeb82572a095cd370941ee81ca634443da4ab4875e3dc8b09073b0029b8369aa38658eb06a83b64760803bcca20dad3e681ee8f63884a1c2e772da65880243c9407750806debe73cd60ece128513b9642da45c1fbedbfff9d26320ada51901a7a64881354ff9c2d689ecf4c6053df4b863841a5eb0bae54a10b4369c0277d975421b3810d766cb0b5721e5d624861e443dc6d40f231c502e9fc47abc3d390f2c1ecec0a1429e3aa9db112da9fac394e7e927e7ebadfc9d9393bdd54c643945cd71ac5005ae4a71fefdfff6976cf733d6235c4604444f78508ea90aa9cacaffba440e42be4044890a846af9014b9e51fac528173b28dcce8ec8bb981b848847bf768cebf6c80daf4b767ea1f8046ebb79a2c85183a866a6c50828bb189e8085c2918c0677f7346be969af4dd6ae18019156250a6c99f4cf9310651e5acbb23e05b2eb67d3b6a046485a0b05c0dcd819c11f7e858ef2533527ba3d035fe3d6946b7d0701b94526db7217ef34019841e349a5d539ba31054c167c54bca0d0745a1dbf0111768c6e0876c7f06806c15af29591f5b2df0e8287eacece094ed04a0ee9787506313185fcd99fc7bc2d93a1910dadd5638327ef56f7c72c6f62369e0c04f4529b45fe1f9584e3898f54e9f9ab29bdc544a1bb0eef8f81139fd06bee59bed96e111d3c48dc5d4395d7ac95ae955f5c6fd14a63f83c527ba144dbd2fb44993d602c94367434ed4e8075956f9e4b8c589483221ab869e12add7f0205b5fcd6f3bf54e72905dbf705b363164bfcebb9c739318667211efe4afbd3a9a40e432ec3c58067650feebcb0f3d6f80842482e0fedbb596e0327a5472655d273198e7c09e979170726f94288e3ac4ab3c0b8956038269a845c2a428ee345a95350951b9aeb23639dfea2b17ab0bcce939f795a246a0014f41837d5a841544fd0b3c4daa127bf67a4547846274de6bbb2b30808292a816a92fbdc101e26bdbd2a0038e3d902b113acbe98a0f5e47a137ba82c886d2d86b384a73277a0f97090b95a01adf7776602bafe5dd5f15860ee7ec8e909e870a0d52b3034f38c138918c7d62b714f9940a419d963f9ac1cbb3a225ec00cfbff9093154546c632502eccb58299873b5c2395a43da1b11d679f54a47ecf93b3794eb8eef74699ea041fafd85f451b4e7474e719fa18143ddd053973a5870965198797d13d60aa6fe6b33858a75dec6dc9e7b96dd11fac99cf25edbc81d524a5b978d23f2a0e559107f6b484443e727fbdb1a24e854775b937857593046809ade04ba82577e9eff2e2a328b8314ec6ebe7aaa8af9bd6afbab8b5272882b30c64ba6d95fdfed6bae3e8676efbfb9d1f81263978d1e45659677bc04f00bedc435527db059fa9370fece0c82902939002010f558286d80b6baaaa2e8b9e6e682aa32e57f44d81f8af1c4e9f93057d95f45723a35880fb14e7da51f3458a9eddff89e373a284e8177d756e52f3025b64adb0925882f7bc2f95f6f7ae73053ab3e74852d369f38aed46235bc1d37318d3f1699e92d13558729017c82629fbed573adccba148e026b4175bb4cd6309ec1a0f21de80055822ef0caf9841ff01e2a5950989d484f207dce85fed4ceba6261c63dc56aa4823317b42e1d532936dc2ad9b169514113aff2ddff1e5a2ff0bf9eb8fc16ac7786950f1065d65bd26ed9ab01300468f8541a580ac69f7e7672e166b20b516115bfc728c9b8fa2cfc38da0fbe68b5213229f1adacdd4feab8d4628931fcde9d059d35abe2459c56713aab8ae51d2128df098d9368cc36fdc5815790e81b9fbeafcda1641e05f2c8f200c91406676aa04a985cc7fd8e2e3dac22c4d52427bd2722a455e29d10a0fbfe3624e85b9bc15f6231b5227353a1659002122ecc9a190b56cb040eb779095100eff8783cb1c8e032465ef69c1977acda61eef724d90f0c123e03b3add3c51ab594a26b93efc9dfe219f0827a6c06c3300d4a1bba90f0f50828cf19b465d4d6524535544fa307e2e8b133cd1c501225ca2f0c8e6e1001099b7c0f07f7ac5b2b396a6daa2c7d6b66423109da68d860af1019e576729e85b278ced20dfe779103f79ba141dc9c1d5bec3da77344303d66f713414f3395e38b7706b9a4c99838b5a0b619498e20039e99ea05c8e56c15d9e53de39f756d71bb313b637edbe94a3231f508dac1a6c54137dae4d66a3663299953df51565e933b25eda83388ad9d53eade27a6616a94e944e01f39e220799a6158470d3bb2bd43a9a5196d1cb0b872ab0ecd69995e7e5ee99b9da35d301203a97ca93870a0cceee7b881cfbc03ec95125c039e5f1a80c7965f2e370fe8e7c3e451791cb5ccb716901eeb24e0e9956b3d97fc55166f2e44053fc5894500d8005f75048badd477928ec900e4a471e0e563b41f5357f8580ba4d92c9ef4014e2c6439b70b33c6fd777e42df4a663b0d7499131f83aca30bbc9c285d5f310f2765f91c4cf041c0a3ad53e838d55369ede0b60b69dc8c7284b8723beb3f8684d06352b5d2701b5e9e78571fa275bebf5ebfa7c52750da1c96b9fe2651032f2f7726a87ff06d9eab79fc7486c4b6fd40cb2049b242d8af10a571b2d5f6249ffbcaef70f521f9cd219726b93786da4e1416ee92ffbc5e9060291647711d15e8790717bd1465968d3c87c2fbc37c6780dace638bdcaf2cf3914fbabb0645c116c088dd1cd26725c37abdf5815c7346d151a35d63ebbca3331c412fcaa46c132b1fd60cac1f257d6a36a55e228871844604e37ddd179e498555fd0f50e17022990c2d934b1db14d4a40fd887071456a7b5a0d05c2ed46b45b4af4c5b6aa1dc77078b61478074c5f411e3be054e7ccbee606d74083ac996c0dac8c79193896214d480006ea88113f02855f7a0e81e9ae8bdd5fc6b086c3310ad2d28c5354ea892c1de9a6667ec8d2b1c9fc4ee239783696c277822a8d7abd15b86fbe40c418c5b037a725f86c424d224e8c9d634aa967aacd3ff227ff0230907a2c104a5e20e6257bbb275df8337107d09b9fe5b21c6f317cd2b786933412b8abc25afea7bb4846c77e3bfd6d3b505e927122dc329ff31d6a20d105229704a4185960ea74c584641d6ce50ffe239d422e04ff3fdc19709d91b3a68d1fd31171272c68e5277bae0060f6415494e15ba0f002aab749a5da68097ce666eb32ed3b5e3beb0fc41d5c63eeea6761a960baa500f36604b1ce88906e824383f07fd83e58d81aa9f40913a48a9d8f478fcaf94b8ceb45500c0c83a62e3471b225eacea3c2fe8c5c4d8b5d0474f6ec20f0cc18188c7e97b08fc2fecdc68d5a48e953cdc47847a86188168cb4f3ed82b8e3deecde573d528ade0416b59c3064490af56d8aa9351c86082a83f51c83879749b20cac2315d3564f41b8ff5dd101920f8fa41659e927ec57e73a416149df375ca1a6881a99a6eaba94dba8016fe5b360d33fde54e4dea00fbb3d87bf6571663b5cf9dd4794ebc53a8b5a896c51e0dde485348d5413f6691ad2673bcd04f4f4359de9882fe1ff6b695e12d8645dca55f94aaf5d73f94af32a22f51d61b571aedb337c7b6e2c2d04da0e2169cdf2427d5db20318fa98dfd5b5b4c275342c6cdc3104d2260bef3bfdeee76c54edfdf924fcf16637cfb8e7707c618e8338c9f8972af8af3b3c9f7ba246d481cda14be0dcd894ee17e707f21dc3077b53b7ccaa66a73e02161c1e775b190a689da5a27c047decf7101cba2e894123faa32118e11ef5326767b476f4618ef067f509277648a2eeb08fec7a0e672b020795519d86e3dd55bc961fcdf858532a44ae7762ebd7fc3863627016afae39573b7b0d7ee05128b62585ee13519063ba109f766b7fa2fc3321db4d086457a220650ca84b4e5fcc6a83311a4d9539b4309245b98c9cadad255b49db688fbf5bd7b0b92853bb34a700653f808a3cdd23462c94ef753b4692544c81f86b915dc16d1bb4de891237266ae3d532401f88858cfab24fdf74bfff56bc34f784438fa822ae33db8d0fb2b1a3c86ac688bd37379f54daf680858c1058d98c554398e23d36afa7abd09a854fa45f14465c078ad6b6548fc71ce8558bc7ee20e189cb1d8f533ad156ff6aa3cdb8790b03c21b26c1a45ebe0398f0976aa82ff92123783c76830b72a46eccb8e5f5a5da80f44bcc3a053bfca942a0a502c10fff5ad10ed90158cd0564e2c2ee0ce4335df5f753f99d82b44e6d388827251748866d05e737140edc1dfd9f33f2d0e779cfb5a08d0603110a5852bf9f473488179b2f2458a7a6d247fa98cb436d97981cb39af40b988ed0524372fc66f363cf76f93134c10c80c7962e9ffc9167e59ce41193d77b314f9df97a0f0090b1d223732d866652d4e9ce7a006664bf0a380ceccaedda3a4765eeddb31d858717041cbcdce1fd40e610866d19ae81ad25fdc3c24521597a10e19cd7c1cad10df2e0cf98ca9409029816874afb9dc5042e72d631e076eaf2ef0cc553b61435eca04855456ae4f06ac9b145efaeac00268e8265c44d35e9b9dc0218f80896542ffb65e14747e1982a4cbff152ccbe8d628469b4df62c560ba54c35fae88beec84490c6f4ce075e9e73ce8dca5ed4cfde972215c29eff35bb1cb132358aaf9de5b3c510eaca0ff3fb3cb317714f1d0eb418115702f0bd7e3e60d863d3929a0c6ee188e2829786c1c62ff03d8fe9270d2f644a203cecf17076bc9eb31fd1b40dac3dbfebddb8278d956c41ba0e067bb3615d042600034198755b02dcae30c57f75ced20799b8fcfa20272525c3d149cdb4d0f4e73c09160fa4039df261e26f276421029d9b5fef5825c70bd9523648a613dc12599edd0bf779f4458f72350db34ed177ef0ad3337615a9abbda4be18bc3aecfddd63d89cde8caa8430b4dfbdf42f43d6d6f3ce05c41f196a2c62f706cd66db5ba675978c64e7a31e8b2e9efa8809316cfff465dae766dfbc84c532bf01ea4898e704f75fb1b93f9f6ccb134233b276893fcbae8cce9ab28b21cc9f9f887c8ee58aad7f7893df1b88329b51ec189f560876cf9350cd69fa3348615b0636a5920fe2cbdf675f7058fc426c38da0ccfd7e64012688e6267d64c2c0a98a9a7aaf79d5855c23b7784fa64f51db3873fe73e228672181f731ed5bd4cc1a6af5e85cf3c8d3a4e9f5bed3be8b48412480d90cf2def72212914004f669f7e650b2a64e4b625a7fcf39cfda5b8d63683f0b7a4de38f279ec2cabf66ab4c77b7353ec7c0b734b49bac038672f6f8105449a52935ac94f3902ba6a593636d676615165929aa939ee01fd0cf7e17da122ec2e815af7dd54afab875c289cba11dcb1439a04b154ee49694d27e9ac8cd94d28f08abb69980077887e5957702f6d7b285311a2ac56d0019600a12f09c4376661d47ba4242eab8cf9789ae887a982eae757a226302f4db6e8dccaf38df9961f3e1cd5b34b2caedccbd31006edb13211e2a456a6d11d45103a30517c8cbe0fb3c4630b95d452d95bb5253344428a539f34d6bc4efa23a9cbab19847161e0367063030f1667450d39bbc47a750f42322b888b6ddb73bb2892754a58a0377d1dccb0ea9cf2d604fcc69ff858c41370cc888a1a433195e00d8ee807d7f25fd7ac24feaba486d0be3fd173336275b284f3eb689de90bd170a5f397064e95ac579d294b34e5a61ba4b74f88af3206cc48731223add22d7e34ee860424167bf9f3d7a9a72df14bfb76f83f154753334e5e8aef07abb47a1d93bc0552bc65b8d8f991985fc194c76292b3478685371bc642b40e97f8f8f5bfb9c2089c4c1e2b88e11527816cffa8f22580cfef63653411b1eac90903574b0a1ffb867baa6c48b55b6d7d1ef98f32a354e8b00965b08785ed4b4f61ee6f899bab693f2d59d26956d2659df4ed953eeb0e856623ffd1449e67f8f6b526459281a31b5bf6cc259dd7858577b021cf2a419b95de5230f50e90b91c2277ffe65d69bfb875b65bb9ca5e31f4254123bdc9e06db565be09e1c043e6159b75e65345708174993a64b5143198dcf819e7002b9fff3b86cb40d5f51f4f866491a40deafa80046ba4bf0a419ba0ba8e8e8decd6ae495a6ed830b3d857872afcf7c3589a2414cdfc22a578ce9636f1c8cc5e65067059a20007fb2eeb5c1eb687b291616351cceddcbef1c49dc4046aefe6e6a355b228b7898f0acb6735c88aaa0eeeb6c67b185636454fcb73032a8c77efc47d929b5b2bac1525cc1bcd0ecaf80cc98a5ddb50b4fe1f5b35f94cecb6ea70540b6ff882bc5f0eb2632f18831169bfb11eedc6c0acf1438002c9900f0adbc3aff0636738335b56e75a8ba7a62153f79dcb0d7a7aad827f66f5846af7c14c344d89e59a60bf889e40080060077d44cf2313b390d08f30902a179ee4c5dac31577a034fc63704d1cc46bcceb9a54f5904d6d48de0963181c7b1100445f56c37e10f223f0026547aa5a9e7ec731803afb18562b414ef0b49053b31b3ead1361cf3d40d3bdb50b3c23754a5abd662a7d422ada574bcdb22cca8a63bfcda14d043a1f70981dd557e0a2a67591ee8a46884c73a6132f0f9ffd6fdcd7ad9dc721a8ecda83131c6cee70ed67f6b9d37c340253b2fa0d185bd5e3e6bd1213ac4a1579005d1db92d082b313e0f692629af8cd7fafc47d8a2799d54fad89952cbe1eb46761754c687c6ffdd36670384ac79a6bff5171067a0c12c180be5650e10383846dfb6ab836b55632c1e938478887931e0a4cf3e63ed512c4fa7d790b138160d8b0c6d23efdd874dbe55b312b9cd3b3713ffca687bad847cabe85cdb2aadfb52589ebdf68e9a5c9746f41f7d924820f3c8c86599f1d0fdf2d56d1426bb179fd43b886aae9a774474af1f038a0b144d292edbfe57ff668dbaf831116a8f13969376f13fd6ff22e963bf83070324d77a158c05b05a290222fa21357c18579b6372bd2ab9afa808a6775855edbd3f069968580200741d4f82934e01da0d229eaa362938c7fc9b72465e507934eda51c9dec47c26b64c6237638bb61ec1bc3b0e238afcfefd9a20ccd8cdbb00393857381794f8909a468430199818a96e435e2fabc4d524ad31f0d779ebbcba59ed08a5eefd10df5eedf791a9934095d0d7968f22264983d60efe19eb01c652c7eeb6aa8a83ca5e56e761b125e90aeb6d223485d91e533662246f9a2579b8558fe6c3387ac7a740244a58e13eb1853bf23818b80122fce7e18b9622b94eb33d18656efdd7df7f7c5a86c613a68af667f138a057e767fc28156d2b96c0fc35d8689f529803e607ddf64e8e42e0579a1e22b7819103b9c4cfd31e5f6eb45bf8074ed7043b3010ae7453cd3b085e8071b229998a4e3615e55528bca68119c6664448c9047d69b7de7efde50dd23ae925798d2c98c125338e318f968f3a0b0f2f483c509695ab57522574fd1666e7f5bac8269dbee8a6fa9ae37ae589ce2933d0c655ba5d580d6ffcc597fd7063358b5315058bb86fee5b58b04a4a547b1399b4fa12b72d266478fa13623b22d56dcc7d2b714a6c4f7a1078f7a3a1dc20c19c47163c71b319e08b22f4a15f09be21ea7eeaaa64b8bf588f0789e410a493ed36c9a07991d7522882500252ad5e0dad11285fd79b5cbb51eb0d534eaf5a43e06c419defca98e12570e080c09f89a83b8d5bdd36b5b9b58e96afdb4700cb101fce6719a59cae5f3a3944716d8219f730171a5d550573abe24d326610b741e221de72c355fc7bca7edb0c8bcfb947f43da3d4e32931d74ac404cfc40f04669fad852cf4a2a0e6b92a28be10da80819c732d37bb1a9f73a4fcdf0f4e8591f0250f7857073699996ed634d9f79bf8b1dfbee9d544e09935cec5cfe23ce6256f203587661bb5b5be0d2995f4c0a4187bad00e89780cff8370283c81cd26ea8291a780641b904f796b96dd5031565853e2d5bd7e85748af8d04afd07f8acb0609f5ddb181dd073578d2d02b9c9777e4573ab6c294a7b68df2c4679b4b4d3d789fafc2e7408fa1f91de4afae8066935cb873877697b1a11a95de32b1de7104f89c1d2631dcf7870d0d8dd86411ecd208656b93de573eeda1366ce02d84d9cce0cf420b2be0938c58a3babdb3ff8725c1c03edfafe0900e28a7fdc9b50914e133c46adc593f3731814b75f4c532a6b57c9bdb7795176cc528e423528190d46529e8e97bd3c116ad9cae463ed30fe5410fc59f10f2f7a0f0741961470dffe426b91d77d78bc78348721305fd4f5809e9b185876f927046d9400493f2228ee21dc511f8f6a008143d286c230ea4e589c6f14c3b96ff54c68dfa5dd1382e5cf82a0007961abf6b52ba2c73b0494a1c8003f13b2c4a960bee1c5af83f6a80640b5b03a7cb059573ed06a26d19f654617d82ca42b94a1cc75b1fc667ff01680221885a378250e2f57fffdc43a17fa5062a847dc9376f8d4cd0065de8093dfe930980c1522b339d1088e2a7da1cab85f47738ea667a86abf353d7dd1dd6bb6094c740c9750c8809443234d232f39b7b970a25241ff3f4346692d09a9f854e97bd56ac52a14f24aba43addbbe22d48e4785934dfbedea43c88995888182065e22bd6a4ad60b9bee1242ea3b5e43610b7f92aa3ed5848d7361aaed70e6ca4215bd6f4acd0e0ab35b846e8da586ce0775353253a919fdb6218b7ab112ad0c6d35c59f42d887b44425ea103163c2b39a681203bed44ec373b0b279c3ffb11f6387d446cb67a67e3ff298ab6021c47c58848258525374cb1c2cb1235e08f3b63f15b24149c7d53b453cbd25484837148c6c03d7b2a4b2862f1e179cf4b89e528e39f6fffc54e16a19ad357c2f5968ea31e0b9aa274b4598d2e51d87c3806d498cf9537c8c8ee3ea0c9fdfd75ed3315870db8388994dbed19a16ed178bfbf52bb00c56af4ecd9174f853824ad6b465d8833c6722ed6ecce759c389544442524dbc03123f4544411c66e6d504933d326a575d5d0db13755deeb19995a384ae767bb868f64eaf2b84e84b445a648c86240842ce132de8de99cd0e945618cfd89eecd79e6f9a93f39531e8f58a24b51422c97debfafe04e46b18fe28ad272231ca3f25ee0a95594b532300410c381d015c7160bb5efe9a72f077ca9d50cf289792e9bb5276cfc8241b50781a7baaebe4f07bdf7a60848f997395a6b2969f118491a68222452ba1eea323ce86590fb582925fadde71209cc52859a90e0e8b22aa2ad54f74aec6c30989cc8b1c957b43fe26352e782e3e630b1442f0c53d5098b8fd8de326bfe1b4d9c4ecf9a525073907a7a3cb3b3b345408855eac7c13a117fb14fabf29f71071cf5fd3e646dd37096be8e625df8897aef431fb535420571613f8619d494a4f132367c99c55445f944f4e9297e83c157fa4e6a5ea095196ae762145e38954b2fcccfd5849be3afffb8d6e25481ce0eb447fef271403595029213bfe54d08d34bf5b9413e339c889f0b4c095c936170b5af3ae715d3fc8d1c1cf049ae9a3152c9d87f6b2b83210d4e7e4f940131c2c8b7a9cbd506a8d64864ded9a6217fcda60cf1b7545828f4d3d8f9a1e0ae2374db37629f83c5be6a7c776cb3ac3109f0f9b32c105e09b6ebdd1dc4406edf5e488c4197560e2f8cccb2ca7680e4df669ce20040cd25c36acba7f664ea5a87dda99f78dd63aa980e53ef7d80835afa4fd6625fe9b9434c1a7999c235b909f4f2ce2a1bf8dacb27cda1fc97702ebb2f468db73df1a0a04e0cb641469f0c406534080fb227ae9bd5854974472e091013c66c2a10302a3e5efb01ceb841bd843f9eef42aa7e7f99a99d97d78e74fa121586509d20a9d769326d00f15f41c779c5c145768dff189e9397cdd865a7798824cd6ba194ad9dec0efe39bdf185860d15c3ddf1a17e411bc4708f15a362c6daf726c7b69aba558af6ff35663ba15580e606a9627a868f486002c160d9380808e5f9e75043c55451c64f75c7cb7a8f026415d45f51310f0bfd24a375a3519f0d4168d617a58c7c4e1f6477637fa91aa3265560dd74e748db37088247031d48be1d8ad85dc1e15d2af54c4a454e9c8ba060c3c2aebe4cf57b92b963fd0c4588c81668ae15db944de916da67d667ed83858737ccb7e32ddac2588a5c8f170bfa920868a4de86034a720f6b563c658cde9ff8dd54fa136dae2ccd9bbdd5e5f7804a63d50ece88a902e7347fcd28be2fbd077de7d62a8e156a53940a4164980c303b1c9c854693f4680bc7af1a877dfee8969cdaab3be2172f710188f9556a3f4c5ddf521561296d8e9017db62ea50735d337b2ea6822cbf515e4d66db085067b679394ec35c1770949978bd8dfcfe0cd34b3b422160a579d6785e35445cb06f9dcef73b627fe183ff3f3b6c7885c236614d5b9c29700af8bca0443fa9207baa87acd95eb7578e8a78cfd5b70942d21cd94ee1324817a5d7207ac2294db72a08a0bee2210e14b7def1f7ed3f04a63836484ec67c1c04750bf79aaa034ea842b731e0ceb945b184c790fa5c372729d7a0898cc1f80d317d0935515262bec846acbdeead26ab953bc7341384c79f1320d15d248bbe29f511fbc6984959461a08bd104c320754153890a987df29f59a770c1830ed80e235b792d59cc78f03a8c15ba34a1f78350a6ce2497b9cab9e38f82e5fe1d119da9faa83617311ccb899d82b6e81ab0df7258ace737f8b983be865b3364730ebc4e9c40417554f64998b8b52024d3b9b513a531e17fd6ce7dc7a1ea1cf6d51e4a8af94c85739e5e5fb92800877527cbcad6bf780d6ceae4514cb2ea098372fb5e1fea625e72cb6c1af954a048d0ba26cd4be1db53eb99d74b8804e748143eb34899f696767e6876ec565f0eab43df753a0e87f91e6fdcdfe2e01a47af28321224012f87b9d24f547bda2695fe8606b8ccbb65bfbcba5c6c80028cb2d2e9c4e258a40f9ecdaf1fc2e95caf5efde8e28ac8d4b6958e66de21dbd5e7a6e0e02ca77dab48f848bebf65030d482b77baf523ade26b553c23d8a974557bbb58704f8c30ea80bec30e920e6cb3298c432d829d907538d14505d10973b19d1543c98be594c62c1d19a566e07a7a7fa35c8e2d94b513c26e66a63d874be51f605256a69d07d87d06051373abc5daaa3adb886b94da69406a1583f0fa8a7337c71da78633dfc75191ed90fb32ccab6973d769fb92d749cfab7746e49eeae3d54f522b3300662a5e77187ab571cf84db98f4855a94fe32a4d9a97e1bd844f5dd4b931a088fa337dcf66ed02f585bda5e7eadbd2ee74bf61281105c9fd6970feb8c4cf27604fea24283618185737f4f511fbd0fb1d9a9a137a47a880929e275bb2cd87fc7df1aa5b2567febd1d8c619150f0034769b3b4dd56c8ca186647b39e53f07c1cc79fc4a2a91fe460f4aca724fd27dc2ca1d5404121d6e1ba68083433b99e05d786d807ffd96f6a58dab38c9fba863a83e7779ebeea5221b87eb119edc99fe98c6d2807cd58ba77705d95ecb0b534b29c1c62d4e6cbd90be9d7ae4ec7e1e821b427e8815e5e21c23e3b171b453b74f545d96ba79cbe32d93003c64160b1927bb067bfef9a04f4e573499424325f537b19a0b290d414e55f591acb3b5e3f027633da15e003b3ace7783460d7de59dcf8d8843b02f14ced113f57757e76b241f55e802f84424380184d6fc3d38d17026cd204dea1443d553a5f4d0113c2ec49312f019f2bff333a7c5ede0fcd095adf1762f1f3e75b70531cb4b132b7b5ca462cd83326da3e3c84a71b501918437c1ea5685ea6989910e0b4f3ee186c8486f03291a1616a92342c1258124ad504c582f7fad445bbf888350106f64f2ebda9c880f7c3741cac02445f2dd1c4777b16098f75d7881390c7a39c630c41dc1ea36b9ce3b52cc88af2d45c4b2312d59e6d947cb","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
