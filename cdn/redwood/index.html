<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9d1af8c3438b785944c39b6cbd41d524dc5abb0a2a724c2e2d42099ba631a60e3dd08ab68c2241a44d220793f8da33a0ee28059141a744fc882c9100531e70d90e45c89f22522c06b462bad854e4d7d8e36916d74b6545ae852933c2242e12335e1709dfc905c805e710eecd3cb925f45009e235acfe9d2e893a6b3a1ccb72b386f20f4b02a558732b73b0714269c7123bb888c2ab433045e2227c114645c99b1f288b6830c4dc97cc3dca744ba37ecc93251d9d8d03acf1a69020f634ef86ae2d8dff9124b017c52b5279d3e2ebcc4b0b4ee023486df1f1f22596acd69ac466c22b029e8ea318e9d09ec88b0b90b4b97f6f2ccace8a126a86c0f2bb88293f0e907c724fc9d2f7dc7bea93daa00e17bd5a0a0665a6b71ae00d7a6355f4390c2e2063c5ee304be0388c141f1d773580fea5b60a443ed96732a3e7812ddf167985ac64d12b3271206aa1a9f716bc0e48ac8a45b4f5786863d95f7fbef3df095a9edd886aff1be404f1870f53a6807238fb38799c25079bf58ccf7b29d7ce4449ebad48211ab3a4aac23d4d9abfc05d4d70dde988b8b7d280d00f8ef87ed02d9279c1515a3669ea45b9abf6ff4709525dbb78a417597139cf4c1f93caa65bbb9d8545b7caecf25d04ed8a511d8c4cc0a076423df0fde0f30b385df21e10a81bb3f3d04155505888e8ac22d1d61aa4bba80d04466e200cee84f3ac6003aaca80bc22afe7fbe5e7c4924cf85d2114442635325e5ea1af62bb54df53dea4b29b93e1ef87a89b9306a80c559c1e9eb90dfb2d101bdd6e27c322edf59044f398f9ed3ec906e5ef3375b16a9e1860154366ce9387e8f704011129ca58c8e415e08890270c346ef1d343ed797b82f6468da2e2166c1b1dc8a6e1912017b7908b9c201a5f4f08319aeaf9c34646345d2510c9eb68aeffae787edcd6b1a8f5b03f0a758cfb90312c7774a64e69ea43df66487ae6ac6ef4d78e14e60ac1ef43fbb168f333a9f6cf6b82d63f6608afb49df80050d66264a993f7ed389853a9632b3bfff40d7f9d1b9f10dc810ff99d10321d1ad05396c36ce5234783052852b12d0644d498d2329c870b9f748ec9e6a5525fa6a7b3f22141da59f619c88f0ded48b4995ac40c5306d218387098c7fbcf0178ba6e205b96a2e2fb0fa77e5f6892b61809a6c2b19b36f85017cb074bb1210561df5131121db3d6afbe3b2af3f0c7965c7bdbedb6e69bb2d65b5d5239ef09c3c6b3e3229e5cf7da06de46ef5312e66128ec91aa62bd2d796819edd1e15ed1cc55b75a34694f3ac7e3acbd0f1e6c557e8cbe1341755ec718f1bffb65eb1082887e6a2cde98e09c40897fb89763adfc71506b74a13c04f80f86ae8c5bef234dad8b2e45ea541f7b95ad552c2c17949b497bfef82e94b7690873104762507a1cdf016e39ab82c2df64aaa65488dd525ea2975dd989b1723bf2a799692c8f25f13725f5c42191c98ffcd90885461e3a39d083badcc1cb66adfe0e05b5af91a28845711795c7745b2fa2afca9b292da7b40fc17b97c3ef35ab2c9b2c08435e746a0552bd1a05bf50bb2846927a81632ee72ea7b70412387725a0ccdd9041e495c1a72758fef2bbd925a965469d391adcf70e6a98fa1cf5b22ce69f65dd73836cff9503d1b242f3a6a14fa44b4185fad20cc07f49f9959d00170014031644f0e147268cbaab61e2cf925cdc51644d91b4fb61ea084b92e91df36206c8d7fd6c5357ec7553d0d50810eafb8ecde58a10fa2bedae85c61d5c885c9438ae0f9742129ff7952ab56f14fb888063630b5504809eb97143b3f608c7d5834f87a62b65f5261a0dcb60df81c286ce0e5acc54dbdf7d6d05516673380de8d1363044091fe77179dbb181ff9aff208196d7664a4bc98b058119756735d5261d32fe8bc963b701c0d08ffb61cccb7fe045e6fead7789771c79212a682b7d7afc4ddd2d94be8028844ee063c75f8678c541f99b0254a429049bb0d5b0ae98375128629aa4093b0dbd6d45264826948ed673c5caadfaf37fd69d6d7cd884635c7687eccf1f94e9e6646855dab018183d50365cd319fe4977948d99fabe12e4d05af6cfd3eedcf565046c3046044daecc3f491be6d1a7bfd5173ca36dbfd42dc010e157c08a84e8b3f1e5a3eaea11db4253706588a540a4fdc60452b4e3d68ebc81c5118ad2e4724475b8c7a7fb27efd5bc62303cb4f639fafd30b1472ed2faa372e69caf84cef462765fbedd3a737047a37ea85cae431d0b6fe3a15049220b619efa4f5312f908cbedb4d0fa4647c6cdc42708e262966dd56339aadcf6c1158b0947e4a7f885870027faee5963af4e1a05c6149390d29becbdec0dec825919bd5bbb7885a0aafef6edfbb9405dfa831ecde998c7e0133be2ea4f4f52b18edfb442a3b1e51c83cb15148bec164c7f5f969d1a28d67f93dd385339dd39e4544a50dadf93c976808f69d1e8556f12a38a773e2c40c0b5c743d051d01ea43c257f39d2080194f9157249797f3bb0aaa927ee03b013dc17357b12413a9f694ffb81b7ec5f5c100b401fb9e5d2d37c458771b9bcbb24597013566796c43c83c223fe29f4b4bec22fbdc7144ba6983eab542bc96947f9706618fd7c1e12bab6b8d94bcf9c9b55e5b086c9a5fd48d2dbdb8bebbd258c72d35568e5b4d40967d5813de0d2e3877e9ee74ddfd78464940716b6c713595c7491d3ca72b3a6de855a2a0297255a6cb5c4c3e13906e0dd37450dbf3c9ca86054f9dd84420d94b85d80cfbc887dcc99b8b9fb9c4399fa444fa868bff25041e305b065f2a874d66901ab69aff9e3935e4ad1401f0589b78684eecfa8d7701f8891a2cb24091efcb20452d8a9efd684601455ef837c6ba12185672078922b25c7fed459354d2b21677eae0cc334b0aab3ebe686b973d42123ae21ca3c6c3da55af690a7606bc1eb49e35150c6a3b4aa8913bfe5b7e6fb31494efcabc8c39bf7dba4c399f0cfc7fa8a2497656ce89f1e2445f683c744dab2b7bec5260e02418ad71ec38bf8fd42eec6d509d8a6833201e0fba6ab1797248aee6f89a10be28acf3449455114fc31a21e88714e71eced1ac1ff6edc9d43af03c51bce168d7bddc4a2b7c842e559df9b3be4a27b01a4bbbccb3928e2092a4f6de7f2c59fe1c0bf33e84c7deb464a2cc741eda72f22230d0701a118823741746f98e612b8a1db148a285ab41c653966b43cd0b3196fb047112b315e58989cacef0ff7be3e89d13e26ac2a45fe1da2cffcbbe274c058a2e04ec07f6aa44405edead6e9e493e9be4c83b32002a86049fd40a26708ea37980bf7f2d6b6bf747bc891b4ceef06b0d1cad738f3111bff8c47072787d69c58cc35868886be0a54656cae6e5921122dd9d771a985c06c570a4971ff4d6395de0387615e8e738072b1f1d174ec40f34d7ed8136b34a7fba0cc1d6038d2723cdfd48ef90761fcbc72ebd4b041f833118b79e6bde1348d32ca674da8b7f65987c04632f59cb3055ad9b2d700aadf39cebc07436d6c9add8a509e1df5b7bb254376f8ca30b0d759fa7c65a7ec4881b6665c8bce216ea717a108967aa09daf115b058f8680568cc7bbd1bcbe7b9fa04816a3caf838bf7f5e66e4f64ac9fc82655b12f6391a0dee641d01080c8ad45d6df0e19ba16d3958f82e279eea322a566f7e3c92df63f995931bf0e0bb2b15826317a157a31b4197cbbccf6daafa4c3f97a8304d6d623db59ddf68a42e8ad0259eca548ee99cc1c9c47c1fcc1dc88f83811ede921c97560a75e74fec2ce7b41f128b1111fc088eeb471a4706915d315efde2538e38b5b15e78578c97e115575b53a91a9de9075ef98d84587a133e140efec3cc489961790c33058575d40a7696df14c55bdcf745d5f73e8d0393e25527369c565b258dcd164da2b26663417b05ff4523890359962829b8eb41be080cdaf5e2e87bc38f118678a078bb706e64732573a31707da4a41bc42c47aff33d0c521362b6ff1f2cfc3beddc1927823b1569dbef480425031d9b94803ce584e6bbf76099e8b9d328143ad0bea74cf3205cd9125c092a8ba6e6c03aff80339e7907dc2b7ecbbae923dd39419ef0f2e8c3d49e19b26fc4ae61a87b017d1406f29da60ff81bbda19671cefb716e3467f8a446acdf95d32266a9b982f3c888ed21695d46eaf31d4c1e02d2a96ee79470c5c4a16cae58069eb68cc633e8d9e239602716ef307a5a21a0d8e6daed7d85afe099b6e793b2685d9df69985e0c204f87e9a5b81d38fc4e3f9f1933002748dad9489cbb2ce814ec9943d012bf21e28ce3b83da913be4d20828f41e770083fc7bb2491de04d5011c23b0143562fd54728b960145aade997e197ff9863f55e55ae28b60f1d66ee532c0164d99d76cd54b3f3826c82c311b0b78db6034e2e09170a156ee1bb06d483d90d9c9061ef4570c7c747fb1dd108fa51d8496a176a485cc9bbf6f9dd4c21f29050cd9671f31972c5cdf8d461d78a7945d163efe8ee92c724f992e60eb52f7223544171676ccd5cb6a4407011f49cc19bcedddc51acac65967125207d715c8d4b54977bed16da29167901bcca5f0991d256bab374b03d6e0aff60161d818bf0af1a7f56b0aed6da1b61a9ce670f0b7488cdd6ea3a6aec80589ce59f167793deb67263090ce08edd711bedda8d1e8f2209b0d3c39c47a45a0fb2dd909766ba8df8790e94c30c51927730dcfde2ac5bdfc335dac55186d0523a054f30c027de3247e27d2de5b8b0257f1b234faeaa31fd4a1f4eb99d62e1c9bf3a194b5de044f9861330fdce4b7350868acb99a3d3eb5f846e13de59a93fdbe071312819b0247f5e04852edff95b5f28b6d37b77a2a6b8d0542ac58ae801357b0cfc2b4e9415c6c5ade99d602cb5b1d0fdbb6e1468e14260ab8bd583ad9c8b5de8d684e466ea0b98abe9e1d0d4fad6a7cbfbd8d92549aa8ff2793021199303704dd9d43e45a825c2c36f6a358cc7fcbcd098df7509aac7022059573ce1f08a44cbe07c5c43e2527d88e82cb801e6dd4fb41abd8dec7a4bcc333196ed1009ccd8a295f58b702cc3de0447c3dcf66e8bb442a4a8df72b1c4d0ed9f3c1ccfa0e894e10c1815a4b1b386043f4bb66a55653eb27f4ffcf8ebaa4ab0ce08d074821efd345f7ef0ce24b3d7292c554cf20dc4b2fd54fa75d5389a1cbcd5d7632ccb3fc4b63dd040b833ff0a4617483c46c96a95f41b5c5c30c386cdb66115c60ee4aa0015e38d0ef5163ca007c3d00ce6f040280a4de170e6b36ab7a887891ae2b99f3a3535272e6d2d0a0c56d88b10a5d94d277ba0c57432d2eb9e4f43c2c1dcba31cbfa910f6d744b272050f552fd83fc61859bee43f4c3eb066812cd9f310c733941d156172eaae46f2fc432d58af43df78fd92253938286849db4871a563846dfca1d44957b05d9809c6fc276bd562f2f55bbab0b7d8f9aaac118d051bea53099f62e49b69f74f9d1bddb5a061a4f88694a3f766b051182fd8a3173f688a459e08f39bc2ce0fdf861396f9a1ccfd99bb576e1d07572bed96a6463cb72d92438f1107a2f8f1cfb91270f03b878b453f32a7a204495287e0560b3b46322dbd398915d0c6250d5eaa1a25eace0e2c4b029c0785246a7070305df83ddaa820520e861f4e4be5e47b02d991df5545558cf1597ce40e05a5521dc1cdcdce2256d1ec57e141ac494547468dc2c6533272a5880d1d1a89a4dd5efd087ec0ee0b71d50fb6e4aafd3de57121d186ae88ded71aace79f3329a16493018dba3f3ee94837c9b33604194b25d4144f15e558dba2af1257bbfab9dec499884744d7c76ac033b17232038a7686c8dc6b24a57530c8346c0523521d66bad34c65ac977c0e0d1f59714d1fd158ce6774472a6938fc706c4690a313ba9188b757b898c6e935c7f00be03becf18b50f3e1d132aadabfa829eafb782b633c5640259ff1142cd8c12f834d806fe042d730a7dfc30869ceef85cfad765b2575c7f1b24f32d3b35a2fb396bec80c4fae7b02741d0aa09d8002051267e26fabcd5c5c7692047c9075bb1790d8cedce181707e30df7a5bc839c081b23c1834abbc5e0b36664472332602236734066ea2bc8d377e52cdc27102f1bf029bd9709aec653ea0206224ff86083e59869700a8a4af7756ce50fa98a960ce1e1b4cabd2ea5a923de14925adaf77d6865ff6735b2118ea91a5427b4ab581e7eb272301e892e102385e8fca997a53340956b8bd6c6d401432dc4cb834143b9f908b076465263a0126107023477c8d347d4071a2b38ea10709607ad58ff667a08065eb618cc6348c1ded6a5ab0e0be5a0cd7f3f02ce10b9c442208deb7b13f048eb9561cc7de98fe8ff69b2353c1d7206fa9955dccafc52f0c58899cae2715ac424fa843d81e34937c67149ecf35aaeaa6c33e841371c30c164d501aeb1097c89ee290a9e5072b1059dd3029c65080a94fc83c9e0022ee858728db635a1bb7978e17a77f927e9811a7a5a495d72971de7e5ad118b7eeae04be8d2618ca6ddf10bdb11544015f3059b8ec09ff53f49e389fdd3f6cbb8f57c5d7e0d092fb8db5312ff9eb0293d055809b75d3d053a8f14ad521b80e165a6527309ccd8e3a8e544c0fa908bccd087fc53a6fb4c3666b87e7a011265c65ac3ecd3f6d1d22b9a768cfb9ca8699f89a839a9dc88a3644e5277ebfa36706fe0db1829d3d806616fe81fbcde64516d5ca490dbe276ff7b3b314f545c9efb0ac1c96be859f249c8dcb7a6c35b84a7e13f2ff1abbb2e934063a44b48f8b4ab70a4f64fdcd1cc1c73f9567994a12f280dd1092d0c6c3a22350c27c1f12083981c6cac4f833b9116d4e0f658153c863842f84fd4a5af23cbafc53a7cd5e90569295f96a070d6fe7359fc4d8855035492f06671393ee3a80d44c97a5c99072da31fdd8962214e2f4c4809494b6227610c72dc30e86b7992cc741092f9381111f8d434646e30d43f2591f4813a44dbfbaad23b9d81947ff5a888b5ed25459969d89dbd8251a18e1546dde1bf0b999f48d957ec06d74e95fa149d6d5f9b60e436e23d13634f488d45efb2f8cf0d00247e0e7008469c3382130facbd1d37716ece06ebc32f1d6246ff26e0f6b2eee3a54bf678c33c67c32ef6420fbfdb90c2d85bee0251fb6a19a635a06a65cdcf8a8e04c604f60bf6a605142e57b69abebc2e267d1acb74d979f61cdd1f55470733837c82f2f49cf370151f66d43fe8903483b1ed0bc845d1c3c3705c313070f37a7c06ee862447ba3068ea06e7d0972e3ca112cf68a86ed897bf5995cb9c72bda60ef2e872cd7a295d3d7effcbb7159c954adc3f8872fb96e0bf389345a0f837549c3c273f36f011b2aa3bacb0c63511bc904d3f7b9f8848661ac8272a31954509529786a026427d01988207d0fde7cf9cb1600b5a80d66c644d947adcd97222b0d810cca662ca369bf8a7cbcbe310a5f449ee8bb2ed251634f167c2fcf9e9afda9c29be975aec6a02cdfafa8a9a6667deb08b0e51a5171aa3d67a2892c5247484f0045ddb7a3c4994800d2c5a29155819dfc112c9a4cab0c3fcc79959885f73b8e767e15da25519786391da048806fa830ed80514867a7e65e8927d9726f8653cbc7598f50ede4c4e15a5d09b0f043ebcc34081a2d91f86a5ddd762a922d477586291c4c3d0b488216a7de137777331ae329810a7a7cbc52065a420e6d7bd3808f0ab52b71ff57fb14b76d4aac720b6a4eeb141fbbeebc4554f8f0c1f836774a37e3eb017e7b7e4da50bba7a96e049a3e1fceb3e2403f6dd3a4e027cfd7311b8836c33381ac5a6f010590143a71e05743f81e66eef12f1abb748f929495ffa3cef64a4ad0c62906c73bacc2b7885895efebddffdc852c04d72c7e932fed947907a7b2fa4483899a62f184b11e077e69fc3fd4dd95a25ced47f4b55781c3e32e23152899dc098d62e10541ac6e9e9ae480b2c936e4f5f002fcc2ddd386da120a49f4e1a4940255d59385f1547b4d514a1ea55349a7fe122bdc92d4c93f2ef44c70885553807a7f1c3872942157cba14b8149cf5cb2098e222ed374f14743c7fcd02c1dc546ba19ea17dbaf317cc705c95577a3620577206e6e45922dcf66b12b46e79b8986c5fe1b62fc54891964fbde7c1712abe20f619d470f9cfd8a1a0c809658592b23bb2ac9d9a5322e81463c1f6e807b8057400381f11a299127f690e944e9b6f7fe72b9abd60b29569169f99df60e2c906e8a9e547679df6f10b65d95610716d620cc252485a4e7a8266fe4f7f0f9d97c6be563c3b34ce4797ad0d2f1ef8bbc1c980a6327f955ad77c17ba4f757178206c45ddc0a1492b6381c97bb5c29824079d179375b049ecbde8becbd0e5c65e6180101415004741d9958d8272a9c57516fff478700585aa94bda0c8065c2ed33153165c9e65f594574cb99158d864a101430c129b4d5b4f014eef6673c8635c6a405b5eebe3623d1c323c1cf162620fe996abea2e7b4d7fb2f8264d2cb51bf0131922b7a73a15cbd0a441216f216e5815a2d4da9b86bfd708d728cccf99737e3cb7f6c5bf062bd85224e48232d025b1cb459b79de8951929a0421dd448f2ef8539cdac56538a056ca6cfddc680fb984ac80d482fd75609c95820a012b56e9ab5db895b5a543cda390d612806d00f994a15654c82eca76cb71cb97edec2c8376ba831ddf2b653be3329d1bfaa41d97ea333ea4f85d8de0f6bacb89f1b05ea0a79cfe4ed6bcc5be4a4c27a8caa784403fa9602ba9b4ef12d614b90e5fda4b00b8aa169ddcf206f2fc6c9f7ea4ba4c49d9ef49966938af6bd66dd77b996b374e6331e9344fe094b602e2cdcc2711c296dfe3426f685dafc496435869571259f76d63a2cfce299f4cb77e658aaf5dc2e9b13f3be458b4f0aac65079af693698a05e5189953f216ad867c70f14120307e0f3032f1091f750500348f8e7b2ed80fb59b2751b2c753cd9c97504e3c5f0d90335660c8226c625c03197be7b3701b0d1b8ecd196291aad76655dee5166f3d2a8a915472982d8c2d5706aefcac4e26643b766688bcf36ec17a7a2975ecdf99b83f4db994f93b01fd4bc002f39b76a1003d45097509b69e75b39718214a4b0af0b80cb0c04dc423c57b2054d35295c9cc17a1e49572c789d9ecf47d9ad6e611f2c764e16c78b4029c985efed361fe45d82c7813fb36d15458474e146d75cea3284a7eb7cf0f8201d390c48db10dc732799f7b6396c607f9bf44be28f3a7d0e154b45eb4081ee24d3766de8ffd6517cacaea2da16c5ad80292ba5ab1d491733a6ac4f334c6cabd61d6f5d2231cd48d7f251ee543d9c4597d16d41bdb1b2cc5a04d6735f0b1eeb31ae5b36ac4c8f063ee2225afeeb8225e1b21a83bce741b1389499feb7ca8703c621eba19603288ba89f80e9a45d6341437a27345505e0b1962986ccf55b3355cc938c5b334ad09cba1f230b35709f6aec25b5dd735701e3cd1b3cf131edd7002bf6f60e4533eb35f9e3d59e9c966cb8c9742046d0347fef0bb8fe2ab8cab280299e24a82cdcb9f6305d3cc030d6dc5f563684c149b726e3023a9d3c4c20e96b9d7689fad856193a0bb2394401fccb1b815e3666ee700c993063610015da251fe5c5719ba2dabc818179a4087ee99969495e251acfee316b352300ae9f2eaffa8df285f8849917e81962bb8650771676d33ec177e1c8987d3b77d55b1a8a826778b690cdaeccb41f34079df5f4ca5e8249b580cd3ad51e3c52d4ecc138c66ff0f5685c670c95054bae6adb541019a659b1754736f4a46069b71414832e96a4b512fe0a80ca8bd2017cfc0ffb79bdf5791bfafcedb4e64d18abb056300942407aeeb2fc3bc2f888d2199e65ac73d7e74be95b0a6a548a6cd0375f78b0f9a80f273700e21f1df72000a452e69404fc9920a231b55fdcd73aa1de51ca5ae3914428df789d5938264aa69eb87e4f25dc563ebd8768437bbbc4fbe728ce7a04f06280e5069cec2cb5916ad076008630cadc9edb08ad6945dac22202c906d508143b03671354244af05dc3e33eaf40f390daf11345bd98a50580bccdc9128147023b8b2c7eb3eea7d78562cd7ff59d7dbfe7b09445d62103b462f679008e7f6ef7319f98a4d884683440e413b532d457abab8e741ba1c031e6a049c293386d6b3b35bc58ee8fc034b4830846c4c2da177116369f02eef96733205e9e81fed297fec816cdf623e665eecd76f979b70530274da969c1ed9f5cc8fe2f935bc4ad6623cf8ce8f5e165ac17923db5360d464c33d9c0e76e613ec722c11fa205ef0690e9f5d74dc8e83769408607404b6bfb373a7defb4041cb2ca0d33a40ca9b236ed31952d171151641166b2007bc04f525071f2072f87b7138f09336918b32838fd8aebd2a0beac4776e363d67c82b01af0731bfe4459a6189e1e48e05648a43a0d34b90eb1fbd9f2b8a19b46f31935098b30aed057ff784ce17c62ec9bc0cab109487bdf2beb8caf065b1903e6ac9edd2a5975067310f99d4abda30d5cafef087e0486abb04eb6cdb82c5567bd3d8654459bb6e5f560a85b957301c743a475ba22d902b0e9405f9676c4bce70fa45e00a6b152406ccf53a036ea983f7d7afd6b017e29935385b2cebcfa1fd4bff2179aad65aaeae67e30251636e0695d08d9ba842cee39cbcea09ae457e6df06764da86f2eb84060ff8d9a13b97ef228e7062f9525d9649ab7930730675d4fa49b2d7c0622ec3489da7276d78a0146c5164d5bbe7b3b3dd10e8d66c048544b4fcf6bea8d9f038944e1257705f5629ccc2fa428d00061ecd47db64801290c4f1b057577223870625a2fede25878cf1540169fb165057d276ccb76c1956f5a2df56032d559a642664c8e32d102ee27a1cef03d13e7f017cbf70baa13ad102e5f6c43852b368d6c347cc3b615c28fcf7f83002291c8f05fba2d189c5c2aa387428f88ef62c08cf462b86f714fb053f0afb27beb74d8e893d66bc964b01925e06438919b1ddb899d893be16d3d55fcb5cf1fd5a3e6c82353e1dc692b85b5f1acea420a08c700353113a0e30f5b81f5292d5aa1765dc72a8b3b510b4df971b3e4121d5be80a3b8abcf127e598709c89c39d208591a4c84b16db7df765eadfceab74e4a73a97a2b88457147165875952d40d79417e7ac7a949bd8bef7279245ac466d1c3b3a5a729896bd0cd7fa5501489d821ed2f988eea1c999b38fc7bbf6405608b95a4d708c891b7041eb9c895196371de5629778fb02bc56f9cc66b379706eab1882425af65a92a259daf9f6807d0afc760c8a13f33145be3aceb43b735fb0790149ac5deab14dd3a9a27d8c42623f9cd18d3f8f5885af73614b6ba21b16861f72d3ae1dc804779b98a41e234471889912a851b1c72e379e80dc055dfa65b527a7c80fd5fee4d6b7edb36d3efa02158a408cbb3eefce1d993bacc056807f826b5cc648f839640e90ce6bd7d829d657c11e3ca42a093c8c5c0fc34102cc7cfb1f511fac7c119e8ee7fd8f2c841be89c1a65453f51108c9e0f49d247b6391c9b6729fa640bfd8ff8ca9b1fe08bee2ce01d585a233b46ee5b2b065c797ca1ab0c697befbc194f70953f23853b266ac1be6b65a0174bd395f351ea12374fc78d146b1a3d618f674cf13e64d4494048f7dd6f2e01e9c51633870c584538ffd858bd7ffabb4444fd3a5710627505a34a56a1c8f94552810d53d3c1ba2342233bff8e1f8c06b5d961521f79f3012473892fa073f8b3db3a572d3778ba677f53beb1e39e1eaf212cc4949055b8d12ce1f1effd333fb3dde67385cb30db5c256a209b5034eb997663362e73fa44fa99a27293f4139df9e4b890f45570f60dfd9a4eb63c1db09648b898ef58e8ff36a871ae6bbf2abcd8f2a7e29f1a18086c6533b5a28b866faf5618532462f3023b99a26c5ed4b7d6122e1c34d9374641bd5f53afa355315999d714e31bd4b906b236e790b09ab252e5809120e4fed60e75a5f40b99a643e694dc91f25f965ae1a1701d12155c9656f4ef8e4789240871f80bc51d5b0b49267eb7e5e2cc4bbf3cb266266dcd0a548aabd59634e330827ee4ffea861a669310d326e101cf0737fe39374da70f4b951614e9cec1ed3f170df55674c14f288f6070b1c052ad6570e4d022876952dab9cee2e7014c1fd39d81fc0f52a4fdb4f94d6676c6cd45fcbbd21c60434f0dabc24e81b316116e39d64e501c86cee5e8dc03198abe64b5f28236a56c7c5d805172c2a6d5c7afae88ef94ebc6d605c75914a21700e91b8e998e442f81d191f4df27ef0b56ceb41ec65e9d1356323a9c454b9c670feab80b02733e4e08e3c424eb3e664a15698d6a74e4739e53ffe923311a82170b085ff6afc960f636cf9e8b1a478d76cd34b843f536291819e11add7da7cfce117ffa7b337da1161433068f3d187113436b619464d2f768b180044328b9e6af81a176a8edbae53626161b44beaf57c2569f8555aa9a1177bae688db5814c1c5c281a5b772502ab227bbb5be5466870c308df16a054b5bf18f666a7a8bd20c79ba69f45f0a2d1edfa6c1544d7d8a213a65c2512804cd90901435d84b9fa7ce3ce438701e20ae8dd8d9c1052c7b9c2be58fe65033f614b15b563a8a634a650554b322adbd945e4b7c11d64fae5ab5ff5ee027955afee3198eba948cb240ea8652ebf6588eaebb070c7db2bb56486f829cc0e65fc6771373e9f213bc9d3f039836089ee6c46b2ade12d53e0e13aad5483cec0c3cfa343d85d86386a931c84d6fbd0c9eb4267c2303363e156df431c06b16239580356c9447fe9e0ddbc01c5156401897fedf65cbca9d6b4b011cafa6cb2996dac9d209143b66c40a8bad8a4782cafa032c3957064ae1572b29f42ad78d18524474e06db450f936905dfcda7fbfd1171f8eb399204310615ae024f5cb4eb3dd78b1770aed791e8082a4e413c1d7d0cbb17dbf924f54e8c6d845964af98ec2a28e0f8d9d9631edfb18e1cab2f3dd15f515cf8bfb9402cd809dd7f3433c145a0556cd1e8c49d5be1789183610c79fa3817cd576b47e71b730e96c529dede35fa216c5b373e26163e71df1ccdca9f93d1320f63b55c5f77bbd3e77b8fc5f41dcaa96e3171555fcb4ba8c120416eed513da153d4a18504a6962c4a41411d0bdab738a14d1c1aa0f5814e9fb8419134f1bd87c05a7f780d4fbe234cef0c65c04e301485be6a8b7558dde852e15b6160c55ca053a65d68e7ddcbaa7d35343c7ce07f1218a3cb7b9c1ed99a79564b462d96d51e322685f06f66afa9ffe7b2972058422684ef3f17e784e7b91e892bc91464fa0090882e7ee9b49ccafad027169d97ca949aff1fef1e37061125f56cb930319d645341c5f114cb8bfa93ed699b5b82bdf4e8f7311f4a64249175472dbc8df1f8af20cb700372365c7220b1f6e0930b4f9469006ee34a916f64d16ac1c361ea2c9068b8cc0cd76a2ff7298a5f6d0fb86cc5b5345d60303428de450660a1574c0d6c362e11dbc0fe3f9404c0f2da0b5db4962f8dd28d9a6860ad5f35c83ebbf107101910970483f9c51449394bc45a5f7af02ca5dcaf7a234d49e0679ee85d203a42f0ce4735ef2e750b430dc52a9b468011025d32737dd26867db56d7d9c9364e9d35d8d284e6b899d1f61ac825c7f2aa723453ca433140a375471f31bdd03e5376fe3bdb2e8dc1598d28e95d9ff33885285b893c166211475e8da7caa014fab373a30324ee20e6d498d8f9581b10d5aa142353375fcfa7f9ee60c3be94eca685918604ea853deb58639485149ddcacee2d649fdb979432d9fec4596517295fadbc9d5c7381e38a6a67cb55ce90fe94fde4c11600dcb4251fb9baf12710364b614eedd54878008aa96701e8cc99ebded04ee8cc29710f8b21aad5204d1e031a96cb5028ff39055b52eb9714673ce374833e9c7a05c3bbd791414544897877916c634c5437653f532abdb67975c78cd3765ed309b211bf51e7526dfa247c3d4b5bcbe8bae315047e065ff3aa7d4ff43d821289b4896b5e2cdb4e9193fbd1b7bdb04ca19db9269e5d129a1b52265729c780ac43936fa4105f9dde8098f8a39eafe4182ce23d4e33433a46467148e00b2294bdd050ed6a4a071e6c05f4d8301e1c0d185e1519c4decd058f849fd70dc8571ecff19c1488f723334c22930c80456bf1e5a121959cecf5bc37b9c5a6769da5f5c32de7e68107c8f0d096b26e6f6ddc72978ccf17118090b7d29e8afc8d2476a770883550bebc967d7f9739e1ac63207b1848cbf303dd34540bae70db4a11e2d92e567db5f16869e2c784b895f25dd47f0b0ba77a39e762a7ff018e7a77e257d07baee222be66f8d07372d7d3c39423cb9073bc64baa483a52e5ff473dd7174aeff46d407fe866c530ed235655e2b05e282f644880521b08a33de41a52db55087b508868b62d79bceb319f1e323cde693b3c259dfa78173999ea11c41607968a5f8a130605c4cddf1bce1358073485d9ab1b8350ed8c968256ae8922416eb972cd2a68288b4a9ad8cddd5f87938ac9ed2e2e72608fd0897dc3426aa392987bc7c300faca21f51758e8c2f4127271237e7cab0c28dbfd3320dcf24fad9d8c614918b670d19b7b440f3008fe0e88bbcc2fb98218db89efb1d0905506d13fd998de731356e2140dc286df398113c46d63f04f1e5e6db972fc317d1e4233032ba433e9546ff263c8b5f62f10674ac16d9dbf0bb6c907898aaf2eb492400c5eb6f0a13b188d5c35e04413bfd2e592bbee8fa1a386edec32591621cae57583b8a9e9366d8fef0950892064a1bb2cfb69c6220a9648cbc2f024dbc7fb058beaff6efd22e51549f7bd39f108d82b571d4ac152966fcc88602d27a3e88ff56eb158bfe3f26527893c62f5284fe7211a2f4bd2adfc8445cc06985464771e7b1142dccb7aba425f0ecd615f574290305f6763a3cbbd91d9ea3485f99399b9868699065610a4f7dcf4451c8763560f9c03078f2e98b69ea7017399dd0bbc9ac08b6d5870ad6adfaccc8464dd61eae081aaaf48168571b4f5975760eaadadba05db8282a03bc8d7473e2130cac4e1ea29404092f0965e5771d1ef7282a823d4fbd29fc1711763f77b084892b424b61f7b2cd99046218cb6da04f12840d23136725","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
