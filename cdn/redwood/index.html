<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2b1f4858c647967b3276d08d1a09c30b913aa98582643922276183d0e67e66e512e74bb47323ee8df119202c604cda5aadf2aef695bf81335f0c02d6074235db463107a8d7c1a21f3d151b50c24e20748e6ef4a571e023b28e3b3458c215ca3d7da8b9348eacc12ddd44003f19589531c6f65bc72c3f6363d30c13ef979636ad191b8c14b5735d3e1fbc95185dafed26591c10d18376519aa2a47353dcc1084ecdbb1c9e4db54c9329e9f008f99368b5a8517fca9d79d685c84cf30b278c6f870aee84315275a129ee8ed5af62e4ad93c8947cbb37af2d6836c4bd3b1010bdf0778d06fbbba09d7f7594294e74048ca99320bbc82e9cbc3c6af10f53bb5315a3136a79b58bfdda96435f4d36d000c327af22ea7ff91e44bacf5dfd328018e955fdc0778dc080c83099a666bb3a99edd1c58c56a8aa3893584ab4b1305b2d39c974e30f4d08c913cbaacd9dd9e81e9278a0f4af13ef584b3500d7659c88fbdd07948cd9b6637871baae9ed56a7c0e8e4aeb069e47d71876189992116619631102cd9dba9bcf796226927ac8ef393e732bed3a92f7782179c3cf5ea2436fa2e2d8b842e922ef21a74326b1f8c9893e3f3e8dc31d916e7699fd5db09841d918a9cca55365d65bc31cd6893c209e7ba66d34d0ee79e5c926246cfde98e52e39343aae521e9cf46be8d43ee16753ed67f0aeebd77b3c3389dca84049456f87d5e6fb971a5a102a8e091fc8f9b684fbb88d8a6e5490826505466a4be6eaf192e5a68ae5a3f4206e21618dff5fff378aa966a104aa12c47167b2ef39aff32e15646399d28139a16550cb8b6b6b4f7951d48e15c0f9c295c079b5eee9f2ee1bba30e1dbaf896d628e80320d781de97c58615ae6dd1b5a554c07d78afe4aa8b7ab4ad522207352e936bd58575ff04d111b24cc4e5fe2d15c58bb549d80314e9b83e44a29854a7f3c28490ad6ba433136c0714899bac52e23d15b757e9a0f2b5b800e69d5476961a8d0033eb667f30bc4989b7003df0254709e03ef7f2b8efadaab90be0967bd26708dfa225494e34dcd9136be4d03e2e872b051bc38e504efebeb8bad9f4bf0abc04fa9e87268a3f6e27572d938997befa5e599bdf8048088b2fa1776557a0b917d38f1dfba41a0c07cbc55f1497b8f39da6ef988b1d0e69aaeed2c9fcfe30182761611a5008bf3eb1a063d041f081c3c05decc83a012512895ea61cb5d358ab75e9e4d14e61dacd268bd9562bb6b8851450e5765ff2c0a16dd251ec02384a7765bdb6835d8d4afa854fa693da8088b899ff8fcb6c92a7e9411b312bbd029e1fc4d6ff6e1e516ad7c69facc721bbf1b991c2faf6cb691409c5f72664a9f923e9c80aa41bdc8df3999baa424d05b7d7e8c56c56ec224db101a98d36da3417cc3fecd568cca9a67c949812ca60453997eba58257c2b963fb54b9b2a5e305f9ed997d5bc9e1382b6df3bb03706b2afcb36212251ffcf6a8ce87b14bb4d36d6e6ed2d65938338c86ad287c8826d37722a86323b4bab1cae89146a4cb501796f36bc147b3cc75202d1bbde591b2569b71a4a287171c626780e0e52343591a33cd8d202b0cf620ce6524116f089038ffe2364b6ca4b21e2657a6cdeb59200fc5e38bc3525b09ed683f2b99e7dc86429dc5cf46b1ac7857948d8d1bdd5ccda69e9773ead1ecd5298021ecd2c02ff7f5a553ea6d9ebf1e117f96292b4078babec738c3cdf4393d1b38fc8e3af6a9a1a34cadb69e37af31cfaa6c66403559a056e6361d03eaa6088f33ead944594fe448e8c61c43cc043c92d09e7eea7f93d74b144d82498168b4f55dafd32baf93b246643d09360dcecd9babc61be15ecd13201f7fbb8bd829ed2799a194ef3d306b0a55b8176c8a600f8437f6eaccd483005b3868120ae21af4f5080ad2b23f61576840a6a811b1fef6a2be455f810bb533cd6b5a53521176521995327eda72a56e1a981a9f4cbcf09392948c7e104b9d6a7c03e151578e22be3ea68b0784b07d45fd20521bb06f399044c0d51b8f7a624361b6a41f8b3df5280b5fb83edf632c32f45ffec2ddf90539286fafcc527393efbffbc03249bc1a508c2b0b642b506c6e7d47b4a915e203cd1891d1d2d5663aaf4568eb9182276c46db6e30a80a4b3813b013e8c0d72155c820f08514070d6636fb85008868aac69d70aa161cffa0596567668ad2bf5bafa89f2bd67e01e348f213983fe3dcb70daa062f2f873eb8dd149fd99e63098ff97fa5eed89073f9473916c6af8dc7d9e5d3e4d3a15a86043552e16fd463cff456279f305f9c48a5e3726e3bafcaa3220b3c5dd4d97df6036b47b792ef5d9dbbaf8f7e106dc4bfe8feeb09a2c3c8b29627cd6e5130044fcae0232383a36d4d8dd8cbbf96969f541ca2891910ef8d808e56079a656ff5b944d2e152b7d04c02df6d029668bd35cb5a7710c8ad7725fca2c2a1308c02cf34dde733ba01f3a19c79ab260c9d6c891127c4ecd2a539b15149f05eae6b3f703d222b018461a325f31a90fc8197f940f22669bc166a5bd0b3bd62618fba145fdcd11f5136902c21f834203480ae551ac111d87c912b84e70cd5315f9bd132da1202e966ea7aff0a7b3069970a180348dbde3b3ebc7730d48d308166f527d12698d4f2aaeb1ac65f794bdfa12cb12b6a9eb6f7ae985c296ef121780c93cd08b0c7be3576ed3413321cd9e2c8dc060e71549653c835662678db6f3d689c0137083471f38a236c5b185ea71a270f81f646db597d12e0ab812c221602d84017fc819cd78f26206316aa868696c6bbb50f6628dbbfd0c0a4745b442c1b66966e5e5a383b6b964ca01f44bb499eeeb12b1900687a4ef46ebd7ba35ae861e1684ec7c71669c41046efc85ca4d8afb223ec6e94fdca16aa6ff64e1123b1c7ff229a715d6ea0b2b006ceda91f8d234527787e5fe702c8ff45f9481ece0ebff12f3eccbcd2d5851d2778e6a8afd12358256183b25948db5911a1d2f8f7179c0c396b8409a0f5e49fab4767673b8cf54c1ac9f25e1a1a20df7fc54c366ac24fefd731374e0990ecb61f9b41a7d0db781f5f0f243d69c6f4ec55fdfc3bc6e72d4ede3942009bf54e8a55578db4e9b5e53c81bfa8a7a4df84ae29b7457a7fbe8b9da2b2cdb8e0a167955b2c2b270c73a14bc1628316096cb77ea3b02f461e37482eff1a8ee94ecad8d3b796cf6efb22f43e6c3dbda7171e401a50bda804b42d516ba0cf13edbf54dbab7e7aa3203aa602aa446613a1d9df1ba184b900508d5f1f4180e82928c1a33a0ba65bd1aefecf6d91a440d146785d12e1e46fea1d38d3b077f2dd83891781105fe49d7402d35004f28a51aa9dcd15a2b37b57a1b772f3d6c13822043c0871bfc0292f6d40a7d42f861ba17b87b9d1ff975487f5b569c273f62d9613bf2d827179323265d2ef77df6b53e8ba810dfad6cb46ae186cf4818ac66004b59633c62ccda3661178fc914e6a96ffe2418b9fbf188cd7b9eab4b9c673d8dbb8cc4d0d0f085b4849c2cf67bb2e3f58a22f1761d687c645b29e6ee8e874668ab7e552a036a68fbbf4cde9445fb35c95b44ae2706b2dea0773d405421e9b1d2c8f0a5606dc816b717a591251bbbe3a02ed9b4282ba78bbc11bec2f4e171609bb8f380b44dea487531fecc8bb0ceba61148551f910c59cec970a983c96dcb751de84fb721275429221dd0c6cbc717909f86e2566e6218d6135f65c14a7e56260a4d88df6b7b8308df28046fc4a20b9a30202ea53b5888a1c98c21d336fcce8768fa4db3db31fe4a5557a1ae573829d70148de90e0299ffe20bb1bb3943cb51157361f220e1679520ae48162f5085497e0877568463ea6393a3c5428c1abefcc0e05b1b59b580e0735e5b9b4069226bd0a6dab9ef1e049498f0e253a9e9e4df4105c4c03e13078e2a629b8acbe5555a7c56ccb477ddfc7b30e561dda9b4d04f663ccb50932719a258f2a55a597a94ba31c3e14ab7a3274adc20bae44c2606be9db8a5f4f0a066c8a5fdd9fe44b6d78af3b601cdab180e3e7b2d66dac37aa26497a58b6b9c1022eb47bcab1b93b5e5d3c96166a7094cd078c0fd0a5a5de5de860d64d08a20d5694373a7c95d539e46fb1bbc7c22a66b68f7c92953bb7bd63c89eb82e3da7dba32420582e962a422404743b2a599816d866d1cf565e10c7279a42b21006dd897fc58cc3f545876c666099c621bcba94ae4872d0ce15f5bbbf5e43a41a3e5bcdac84121a3209ec429aa024d4f1781ace879681dc3c8087224e19997213ed895a8428c8b8e7d9765f6d2a59ba6258b7b0c14dc2da353d546cdb2f1d67fc9022d8d67b32fb5e8d0f1901da375ab5b327b84a6da5f777866f4f3438f978117d7136983498da9b34a95f7093aae5e9c6c2391aafdf7a169fd4f1786f32d4acfea435bf962aa94d2f5c147977d90f9af6016d3a659b6dca227624344130d993291ab47a5350886a606ca4f42c4fa09ba75eeb92edd5e98c9351f0b1c6f4f74414ae7f9c78171ead75dfb5f05ae4be6244cab1780dc86fc4df205c9b105f14a3fe9e1d10bd18e18a41d7aa3d0f87b794dbcdc617765ae02f9444c9cc2ee3da216a298d31370f28f58807606d5884f2e060776ac96a998ac411d9f27815d8df4d2e2c5810511f8c4bd2b7de8be0e2e937eeadb80d57e3c223b20c9601ddcbdcc80af3f363a06d457d152c64a0195ea76a344e930143cbf13b4a30861e4ba37b4ed4026a8fc85165ee2623e76b4d5f81c3ff4f24f0b3d9ec9732b3e3952e73d169957a17751373b254005d23a38bd7213498825a7ae80882abff1304ddff7a507180210b8d00c99ed749f77129bc3e9e15f8c2db4bbd52e7d774cedc8915c252f72ef1a0858d5a7e16397bf7361aa50f3e689197b81f50da8393678eb0b16a72341eba59f23cc81d96b7999a379720e4bd760b940cfb6783b32321f0bd20218017c145495a80354539d3604d09041b45b96afcad16127cc7eaf16287ca8b60e44f670400f6fdb18c475fed8473c46bc1b361092f3900e62f25f168a1167b313f7ee34f8b20af4e57e91b8147498dbe8af0bf8a63824c0a6a2535aab66cb4aa20b3b40b88cfa151c96ec69c5d8cdab8ecd2feced9284678204441bc8095237db74eda6914c6cceeebc125afd48fcfa676814213a004098a4d692b5facd4e0c38c083ddae38a24cba35165e6f7280a5bbec7a4a8dd75d90ac2edc07bca479e30ed9d0eef139a7993260300b08881e0c700718ab0f313b6a318263cb0404e15abd1f32d53e204a133e4ff6e25c765135d651cd0eaed895ed8bb526cca901c348eca921d606ee4ccaee9623f61552dba0f3cc7acc06d8d0925ef61485663d6f09158b6928a81c70ed0019d991dcdac52ddaa798448468bf2450cf6e1c20896904603328cb738322c57e8a62c8b833f1b3d77bb804a739a21bcb2eca159ab513db8d3bf1169f6a66456021c0a000e694321ae8208fbef5bff9b936e17deb14fabcf9fc78693f6a971ef819c3d51f2d120c085e4ca669150f7b23da5e8c9c39a6ac80b971d5de59005d90d8b98473f891c73f926b7c56caa2f0f76ff842254cce71d18ff943579986e604c8b7285eec81f242e4dc76de758aae253b0b7bb2eb564c0ada5ccfa16d6390f5abc053d610677c5e2e430d373c123fc3e7a1aedff56bd16e65f67e079263788102ada84c2207001fbf2d64ad0c2f750b136c0a7b9545f973baf7b05a6e43458e784cbc7dd9375652d2075ab595dc2bd0527ed7be835dc5cd3601f2177ceb906e41599cd3703ddeb6a33db27d00e476151a5b6c5b85f49052b88b58eb64ca6d92c7ba894f58a86e332a20306b6ae079f1cabddede8fc27d1f1ed7869c6fea84a3521d5575e5011902a348aac14adf5445878801ca5ddfc40e63ce48ef38d654d62bf92f0c3030ba8b72ddaaffe301947539063b4eef9a2bd0b91a26a4b12b2b51c17953e0db0e608fcb451b9d808bf051bcd3cd6b5188a3e575a069f0057ad3b06d4c726e0a118a9f1b701da9fc61e1b102ac5f6891173dc7558807f65193407e44085534474ccf8c0ac157ff9b0d06bee124376c6eb2ad323d4dfbc9dca2341950183f1b1a4e36d3d5ec2988f9f2f1aa3ea84b581d529180119e4ea69dcd2880672361a8e93953a87b9cf9de0aa8c891f2979cbaa1aa0145b7cc9b56d1e3be3b78453067ac6c1418f01292d367579f72ad6322b8e73a286c4fef102589dca0b6780e5bcfc70d283213b60049c7b868485dc02357141060df76fa43d128d0b8f604595a19df982245ac155f5d50dc80c115fe0a2e34990b0bfebe875cb59a17b79f13ac5eef355649ffc3755afcfc0f9cc4c0238f9b4b18fff0cd837d7b003a8970a5c25e7aeb20d22aca941c7a2b97c39678004d4951d62f37698ccce3ffe345775f3cb95a9b7683a26027b99e81f8f7c3f07091dc1ee3cef3bf81737724486f07cf00e8756d14487e41f393090273223848508f3261bd96c8927e05ed17302f0b858e1f2226561041d34ffc988b6214bdecfcbbe936eaf528f0f9806db92174dfa07c32894a75783f9fb821a264b3d51dd7b024cbf74c8849906924091d5a91b6f2df78cda3ac44ea33dc6af9f48db4c6e754c1eda668f70907d31b4083d10f0f965a94f6f4f16cd2cf1ae777263a94f7101b1fd572efee3b07cdcecf3a2d051b886c405a38eaa9ea10aa470ffb01dbde36c8e438f9e7750a3b9710d39f3623d9e366bb5422287c7a6488847dae65c3ea40e38966a5e22675c4fa47c237fe7d456f777285d71d59e2757815a330fde5c59d7ddb21e7d8779879e29bd0cca990c6e1a82e2f8515bd8dc2dfdcb8bd0ba94e9cb1484d30f16152e2c8e70cc4172ab622131668bbd4f0abe8accfb8640be3a652f8483f9b061f303c3a42ff4d7a3946258922eb20ac4121abe7a9ab3d6cc0e342f02e7a594e6752f5c0e48e4c6ff343a3717139f4b63300997ee093ff13c5f01fe5b013df287f1528f3a581fd224ac56309c06a69d0489547968cf8f647ca540e7881c117a59a0a262276a323cf36681067bc583b3c369046c3898a198d0b5cce6dfeaa632d12f0af19e5e607507bcfe788666da8d264c3d3f9e6a49529e2f39517c8caa959352d044f878dee384ad55d758d8573bc3e9f53e0852dc2b5d5cc31f5c2b82fd0dcc0fc04285886ab925194112449c0ad3474dd11ca830d58fef94eeafd785fe9f6de284e84cbfc11e55e99afd082e5b2116bd2ecc9c8fdf6190e1de9c89f414626453e7472b22a42d96af2e73f2c13285e251e7164f7551da4da13e1cb24b8ab433092920293cd0c5a54cafd4e21b00ec8373ff3cee32277961735e817b4b14a069aa8f6ae77b832654b65ac3ad55f7676e6f2594b3c76ba8f8df1b3d67c5ba1b6cc2d1d585e1fedbe15a69f9e5a3b291d1a05149d419871086e73719cc376c0b73f9e21ed04e8228d79467d1eb44532a8d6957f94ffc92de45d025e771e4678ace849a749be74be4bb5b1abda596d551e88fdfb71c2142980011e9fe80faee7df765b9badfc66e4f3f3312e4ae2b4b0edc6d4438c68b9f5d8783362af129b63c7b20460ef9ec784a0a868fa0911edf75f505f57db8ea43e3cd29bcb180229cced05e48910d094bd79a6d82d194cbc51e360c96bc99ac7473b7ab4b861e213391c489e96038df42ce31b7f4e31a619d44af2bcf1230f090c10ef4ae7d8fb4633f77711b8a89645861e8f13cbf1419f1a700eda9a9e07dbef80b5eda97359b42aa1f9cdd617bb272e1d0c94de59835e0a0916a7429907a8ff80daca1ff0c55eb85d5dd8a3b64b6ddcfa0f79c86ad09f084cf5bfe89ce992686d21bd2418b9b1b543f4946d5ebee35fdee5319757225a9e13c26dbdb1fa536492d40981c81288801022b4c53fbef18c614a4db433dde9097e40e6f094b5eb6964ba4a56349deaf4b90869870bf62bdfdfcd7988cb4034077a274a81ca742b534e10a5bf7fa2d859842d4e050b6c89fdd744a8648a7ac517eadd1587d96a22b912a6dde4b29ec1693e8120bc4bbd29435dda8d8e017da1d9e067d79a5ef654e2575728ac447f743ca6c2ccdf31f5a65ea529df4303da669bec99d42024387e64150507fd917d55b27bbd8066cd37331439aaad7036b284b2362c9b01093c3e36712f30ac556131a56691d75ff78c5471911491518dad3fdf5fded5c003dc21054ed919067648d00e000b2dcfaf7dbbe62905394fccbd13c25b9bab656495e46d63b2456220006355808332d58055d0eb29629a1e602c8bd594443fc8127f9d2bbb12b4ba1fd4d95b66eba6f585e43508fed999b04fb116abdf73bdc50fb03528a8a03db790abebc4c7733c7b40eef3774d97f1573e46ee35cd93c5c6e97285785042b2b6a1ba25b74548272c9bc2e498750416e04526fe79ebfe456d315e9b24796cbd30ec1b5765c4436a55d32aab54cffb9bafea63c6f27a6a76ef5c709acc484f2f3b7c4dad643a00580ab8410ad8f9dc9b241ceae75f64996b691caace711abd781330d20f05937a4a9e7fd1f0b4e9d835b3b6144fd0179e364f69d61cc3c5e5ed66bc703cecafb0de71ef516de5ca41c2cef847fa56e4420e18fc6367b94ad9f3863188b119bf98d8f13b57ade7370f67cc684dbf12118a7aedaa615fdfd4e4bfc978a07a5b10802383649e2dfe9fcbdf4956cc9b4b4e2c26f2f2af8a8afc73bc714d793f231ffbbef7df478770288b62b069b5d05f3b8b67d2a06c3c385a52d9bc6b39c3ec28aa72502d192b07c398c756fe3882308145f31bc4fa886b90a93767476c67ec7a663e9030ea12c8baaf6fed3287a02491834bf7853754e910f086ea16766d8e6b757fe58bbc40c0c00ca3c3248b09132687c7bae5b77b7fb30348282959cc4394d5282ffc653fe482e19945f74040b23265c20e27e38bb761ba613dcaaa053941da2f9e9acae755109f40e03743f4a3fe174a6850131e0c9069a459ea74bc259c93e90c41fa8eb4a59aa5584acf66e46337ed1c430b81515f57955aca01e27aa9a81149a28bfc49dba2e52b3d8ac86d7cbe3004a1d419d93220086ac3a98852d422a25336f86bacde47931e330a76ae9db91bfec0327376ff68e8003c9dd54018e2e5e102010c668f73772c07a94849285ac7fc31ae7855c6b4514a4f3db3dd751658ab6d91139d4e4b5e57f88aca1e9e18acc9d96784b0da137f4989716cb6168ca347062c9d11f05d7abebd3972bdf024e2fff4debae19eb62a447688a2143f8099acf9bcd6e90022bd7511e41cc0d8495cfe7ce776374876ca1fb57c6cf412f7c90fd7d5f0ef76f1ff28468cfb9d9dd886cdc0e82b6b1e8a9daa638d0cad191dce7d2166dda2fbdadfed27b1a905410b7331153eed3cb34e070f53f4ed6845ad952f19d021df77c53073bf96e0df86cf4e0d291ade8e732d578088073547a4658805f2884aa4259a20d9e0e0bf2f4c4460bc816cc099631e18aaac15b05b9a8fb5a88c67d5fadacf03c2dda1eaf774c2cde722dbf156a09a07082443ec5eab196508b6b8b003f628ba87d81a91207b17c562c56e707241ebc6d4339551b4ae96ee7c8ffd11b7aa607e7633a1275a4483fa5926836a5bc1fdcc2b444bbd932758dd5e91f92009ad8178228b999f831b8c1af2f09c8b23e05270db513f8dcf7bc48c2e665dd9c9a10e4f0ff6aab9ddb80635f5c672e9afcb41bad8475d9570137bbc8492ea1ba214e3be3751bbf1b4c7b78857aed480f823e8d8ed1e0a9347d7b7d893be8f16f1055335a722972ec4e628b59f7bdc6c265f2c1c7db71ebeac114ec38b73a87fed70fa3b5fdebec6df8b6abbe43418158a6f669fc88605373a65bda600c6602fe5496aeca518c1f90eba0ce9d082d8d9bcef7c9f7f2ceb6e6c2d77cc01ee934af836207c3295f8a2ac5ad3db314d342bd6826b8bf58f13a8ca517f1f21e551dc14041139dbdf24ef9e1b32dd5bc2ff6b98f18b31af53a9ec2a32ecd967bd2db8792093794183842fd1e149785c0aa194ebce364de99cf0d806eb1c391f872c46454ec3ecd67a220b9f6f12df44fb0c32e0966428dcceadba26c323a70e22294779078e69fb7ce130e2528c16b0cea024b697313223f6ccfe5578b5cdf4e8d2de0eda00857fa347272ec46542a44e88c3cb946f4610a5c0e21fe4b1102a428ff923b208c649e38aa244074aabd9abdef4fec6cefa8f3893dfb05a360cc514cda9f552a90438bf2c86d936cdf21ba04ec56a996be4349e06573c174d456ece9b8ad5b9cf9ec7546b45b7bef72e12a0d15813f88f05075f4a358ddebbc179848b6e442734db2fe78c259d7ad6074d127424f873f24394f8efe56a4554c9d2eec1494a9affce9eb2f223c886ed4dc5139e24e1a1ff3138bc5f9cb868d08ecac77b256de7fa44498e977f67dea213bedb5656881963996086b7fe19cad97b77fbcadf32609051ea220ade5a1836c53817a6c4be7940b3edec85073426e32836a0f1b8b7327ebb2f5854ea5338705042d9e6ce302921f3a55cfcbe327eca56d596b0183ccbd6fc335ae8128746fa50d4a3c17c3033b34b695c73ee3ecd5f4912ec8a4f1ab8aab47778cac6a390fe9891e844fd01aed2e34b32133c5346feb11a0d84c3babf9699182455225d32d6f9512a80217f12955e137a3720441cd80f93a79bfc5c4db8335a1d1bb439ae3fa56cfa56e8c22002d64d15a2321b5beabdd8bf5e7aa75b805c9b946194e5c87b101a99bd34ef214f729611a124a8c2cc6ce0fc32661351786b52a745aee7227cc9f695cdb5f4ae13d4c4bfd661895c4c0bffa68edbafc2bc543ea3fcf80ccc4889ab7722ade5d759b6be1b4e3bf1e87da5f606a1e5a4e9bc176f809d234d527f48f4795783b4c785cd1089e9939be5f76a6e3bae9dd43d57328ae85dda4b8bdef45df7f50e5964535c6f4f206a59becc7d2a1f3c0dbbfe464a274b642ea56f4b1b31651cbe3de0bbf28cc640d1329ef17b8c7c9761fff175123d96cfe87f675dc388714b8ed1aba802c8e0076987eccd63dd322d21fbdf7ae4aa070399a9b32cefbb711f7e6292b5de85248e801ce6c4d36e7474fcb26beb805f0fbffefac95ea41ff9cef5b0721038ebee41c372294d5521982b4e09a0bbca690df47ceb49a40452e189fd6bfd474baee5067e27b731870b447d576ccff5d46abb0628a1695729d9762f00b7cd0bee5b799c469cfd0c6cf17b30b2f541dd8071490dd5373055b3fffc4878ac706155aad508dc1270084ad79d05771dcee24805aea4d27169a1390c1eec10a111e39235ada6b2a36a297ba31aca1399d49e5cc82d13b0485b7f2101cc6cd0c68904db468e71f7589d5df98e4168996930fd4fe9b8ff9e40c26095f89cbe4f3961a3e950753efb16414979583e270716087e8a3428984e565a72227045949a999c001f44619007d60e453bc3ddef6e67e430f13b7c60c714c9f770032e549bfed9185514fbdbe828a9006e77f8645a97c18ac74d80ff9a350a69f0f55c9d327d6f4ef5ef48ede45dfffb1935cd21fddce5eca38f344237136dfaa26c06f1f2e20b30a1e09f7992ee749f37a47b36f7ebea944ccfa94aae985f21d42d0b4c0ba72077d0761a7ba700e2f32b928da3e5f4b3fa2fec0494390c729c86be1ba2a7d06828d2cbd41b542aedd5843676164bcd06ac93472e944ca2e81ab3f0592172414c029120a90f602b8b0b403f1b16630de9917f8b6f7e1c098eda9d868e81a05592f52e4867032a0146ca04318a68cd0c884e3794e9c4c0e16b6e90475a4a3b55ff8bf4bd18c1a13c3a811762570919596a36bfc9e2c818966ed36ddada347b53e3d64979f99f75dce20bc83e3804380916928a21ca2a79bab68ac69579bace012d224ab625146698dbbbda78b751290ddfed2c96136212c9e72e29796c35358b75c6562e64a06fe3c93fe5a92c0bb178a92255b6f9c873a113a512612539e71a687afc18c7acb3328e097ed622489a270127feb291a67c864003f3031538a12441151e2bee2347a6823929d0009b62b0aa17e24156b4fda925599f1a6e1ec11bf1b92fb10c0cafd398259fa097d7da0ac5d8ce923a3c9bbcc96754c820ecaf31cc2b7525478c5d1970f43aa8b25fd28d2de587973d5be743a2f41d13f8ba40aaa6592507e5982c9d7f9eec89de448f59e82f635c453fcef8a87f95e6aa806b6f798a8a53869f176e377837e46e22804ee942440bd5fce2b9b8ad3383c949f6b9c8cb3adadf8aa5fe7b1bd80e1006433c08e2eb006eb51c4c5a161d526e69f267717762f19c054c1cf87a3c4487b265aead8e6dd64d486c1d484c147fed19e58459ef890939e11e9a9987fce5cf57a3b6009b23435dd9c8508bf70aea2b98e58015a9e2af5883e2c11398ba278b0d8b496f4d68123f9501b574281f3d2e11a9637d819e84a449bfb3896f781320e7d7c415352b998d31f060e43e085fbff86e9b2fab7f0f927e667b3770a137a7624730b8de882f055378ccb4caf76c8e11383fcbd186c3b53e9564679d4d050e5e9dafad1f8a9850f86b9e216935f42b1cfb685b1b5371cb53e59c65cd36e7548070c3fc7a20666d5a172c191d37080cfcfa891f0b4f691069eaed4b6fdc3fd4eebf0c916879a6cbb65c6f07fe9b40d151408fc1c5ae0d5a7ebcc0cae856b978ab493b3db1a4f92e20a698f79642fcb9d9fec89fb1f9ce9eb70849576016e882011927b4cbc17771bbbbc4252a139496772ba211bb333a787613f6ba04b6f58c6050a5e354b1c111126e62b869a399c9e197546b3196f5b0cb8aa189e8481a70705b629b5a916f70014eaee216abfd809e9ef5565d35dbd4bc587c31e75064f7a11355ea8217085e0f2f01d7c379416736b80b8179d181ea76c01a75e98db423136bfc1670f7d97c7a1e41299db6d0ed9e468bfc6e165fe0121437c26282eca8dff49f0a2de8cb4a16f9df70880de3ea9b8474e8f4a69fc428910146fad59f3294b6c1578ca5d3e8c5e81dafc273471d6f3ff8c67165c0cbc7651a45cdf7de5c95f63d1fd30926324b9e2396dc713c5b369945cb3b13574c5a32aa5311e83cb104f6577dcf4d906d25c14ef5d89526b879e17a365534054e8961ca6e0142728d524de1a374bc5aa841ec9dcc5bf7c6d95aeb1713c27e4a366a1dd97606761369c77728196b67466840472e8a40cbd56b1d8042b72fcca733dfac53fcda2166359ffc72ddaebb1def5fbe2d8448d55d5e0f9dadb098adcd8bf749e01e456f9c188675993b36824a820f774aea5bbc288f1de8afbee1413e2c762bbbcebae13fce7b2b3eaf1f0826baa9bdeac2f5ae5080cb30f02f7cc97ebbfed93f30226cb250d5006e40984b461994b3e76244aec3e6c36fb41470f93900d504ce89d7da85dd658838b062572d2289480c7d0c0a8323126d6dab577d412bb95654d86c291b370a5eb448142743ef1a4d53150fc269045636b8fd842bec5acbf30dc0e920b4cfdfd3db8685fc24b4829ba2f27f7c288df4e9ff878903e72d3dbcc5959a63841bb6812fea1478db1c275f2f85f79be7a9c760e06f828e0b1777495edb5d4b208fd41ca1f3074abba1c27b0d22a61e6c6c0f6c5ea1f815ab1678a9bb74124552fd592840a25c6e5b10b25776b2d85cf0635df4aa97613f8211f4a3ad00e2da2f3da1ee89b6a3083b8961b6e1c5b65bb8000fc745e3734bc19415d56caa88a60c36480bcf573a32e4bbf03bb4b210d0a6207f2b7b4ada6e86409a1c60bfd01e5c4b32f2b5b6d9e7157a7b5308333b56e15ddcb2bdf7f1499afc0c7362c92939c1149e7ddbd8b7172d417dda26e87b90c0e012ce993ab0f7ad2b953ae7acf01863c3bdd985735a3e962f168d99b2b8ea058272753fa4208339f464fa6cc6f58536fe16f781937ec0eef15e30e14eb693f8c2791fda10afa7c7ef7d1758338cb99cbf62ad369098a9e313d7e6a01917f852040ab23a3bf103fbc913ca9a04362d6bf0fd22390279e16aea63617b3321a741f6b30cb3949911071a366ea055c3986bd056744df70b0d24ceb60fe96db186dcf12e7577c3c1b42105f2af1c555da42bd0d51aedb2b31ad3bc1f4d03c26a51740315ce1951b175218a4683c11d1d9eade5efac9aeb1e8f9eab6fbe34bc9c7763ae11e87714ff946e1f5acdfec313f359a40c51d3d816baa9c695e6506be56e591bdedd76eff58edecbc13c1e6b6b07df52f2f6ea046be902a1bd683411808967e8e4980da98edf0341f495a0b6ba38e754e5e7844b411497a5ec7b47e7cc7fc30a3a4ba1d272195cef7348e3f7b45a64366aceb12408b2f7b69ad5321c1cb7787f1bd269cb34f643a26ed5a8497e42d24721fc4d860fd1f66bfc168f60edfb26512d6efe70575901bb671ea8a14bc0a9eb4cef1aaf595f2cb59bfae58aa86da67e9c7ee3a81fc5aa278ed2597911cd4d45fd8b6c6fbe63337e45a3eaf852e3ef64fa70ceb9f1a2c5a99b6e38354a22527aea226cb6cdd2bfc59ca57295ffa87ba30fecd7c702486e47a9986f410c2c95d56d71ddd5044eec2c612c18dda0da276d40c611dcf19519c399f6f7fb3aab7aec1c64e7ef5ea3dcf804ea4e30f0b71f71e541e93f074e4c95494c512313f9e31b3e3bdac7cde59b13e4cb991579f5ee43ff71dea6ae78e037b8834be639cda53524e58e0b522487e971f1dfca591c320642f5eeae86462f2ae4cb3b261d14bfc8d479e2ad969bbc6c733669f6569e1bc89742042567ddfb72155064cfa981ff16445b7c8e320ffbc55824a5a733a2207ef1c6b036377438ee32d2548dca8a3c382fa5f57f0a24be3663ff7f8be071af7d0a568967551275c67780a2f50ee3fb21c65f54766cf22a8df3139b2b30dd19db3d30614ad1b4b61e664b853ebf46b098d93d4dfbd4d4bb632a3c1f0c37c943a657d18cee42619f4693949cbcfc02b5b9537031c33d96eb6ebf470e9f95caa5b39b3ed4488f27ecacca1bf394daf77d14652c350ae1eeb03fa596f5991741331a1973079bd9b3a8f61d5685ac293d7b5c37d10df01930e1a3472de3519dab4a60ef425b3039edcd3ee797d248aa8ffd473e5ec32d1053d39f5a565b96f1e21ca8c61edebbad2cc5d4fcfc616ba31177d864d7eaf2f51c","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
