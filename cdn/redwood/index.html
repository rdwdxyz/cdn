<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"93db7b4da8ca4c2cbcc0db5aba0c6230fdf4bdf97dd7fa1d967f7d005e47c3e8eb95f38cce5e50c6e1f69f3c6478916510fb22943781b150990d1d071968cd08f9838a9b8993739d07679da41aa5960823cef4e506c33d3a68c6d3b1b97e0e97738cf31ee50cf20c6164ef3924625e0245cbad14badad13d50440352ec2ff4c12d3bb330c0aa178fae93effbd74866865ca709980c77b3a5dbd712961ea13a1d7d6fb6f4052293445a79d120566e30f843ba83a19e975ab07578df94794812cc8b6738baec3910b2edaba762dcfc2d9b52688ac17351fe890bb045bcccbe1835a7a5a1e70889b831e2b3c170c6d7869b905ec69dd0fffb66cc36b952bffbf17a86e39ca7e42cba9e1b24481362fdf53280b2dc3ab54f636148d45ab52ac2ecf6095cd76fea708fe96776db9473e80c3f78c8a0d3ce2ed2cffecd5f3222939ac0f7b4fcbb442ffe5553b2f3adcab8e5dd106419e76b1dd7c63a2ea90ea9deda96c72ba36d8aa5defaeacd3574833798c280cfc3487788c5b1da43bf4f04416045166b806eb1be720aae489d63543afe28af6d60f71eebfaf1fb999ecae82a489c0b7c74dbd30e25622610ecfcd03bb3220bdd9a6c691fbd995bb03d927f07cf6ad8c0eb99364799bbb0a3e59128fa94b489a53b68c651b4973387b623c7e0f68a4c9d1d0bf23ccdbb352b95b5a9b8ad1ba3acf2f359a965a35f23bc5351c55ff435d4c19e6e250db19638cc5a41906b46719be51e1f773c8619c65942dbd2ea855ce77f9ff2393495ae3cef5d644e0db13172bdaa466d84a86650216403b1e04ea19de6da20f91261b71ce407b310bf8de792c670424d8d510cee8a2897fa983b110aaf59888acbd5cf4628fb227ca810fd50f42392619669b688a0548e81a429b09ac0378005e89f5ad183f46e78913f730d47ab437759b2a7b606d5c397644538e73f708684432f48f1d1c470eed1a8fd6e1a160e52f0e819c5d821b9bc7041ff31c370b73062ab8b92c6701e0435ab6b210317ece02d863e0b8d07dca6edea01d69f00ec538ea9dc35346edd4acf5093908c31d62792582c90780c61a4a032130b75c7c0aea622a5c37d588455a42eb5d59ea30056a7db19e7ca8abb220b338ecfcc0799052bccf6cf7bd37d8a0ef93468fc3cc7f0cd4bbd49d82dd28ae6b61bd3ccb625510d4f55fc527ebc59b4850d8562ed4a1c9c82d7ffe27e4e971c771f33920f2e227c063371b4fd4a06c75f8252c2ea94d736bc5e26c86ff46a5a3c742b70978ddb422bd98b5ba9cad19444ae82e565a109a516d8de417ea5decf528a553d7bd2628b82f1133392f48fea04f255b3ab70c11e7e2a1f760038ef935deec8b47b9dafa057286ff07528c5c51a21ec44d14de0bd1ad1a73832200e9432416d6fa930f1460970c9b27276d1904507eac79bba254537b5938b6104c43f046eecb611f38d40b59920c60b2b9c347b2420e36928688897ecdd12f34a17dfd5afbac7c1b328e6aaa71d005ae93ccec1bd0e4ef91c263c6b97f8bd97579cbd4139669996d44e9ae180af92c554183e5ffe9886ca401d4b362dc05a04d3c15a90f14a1bb9275603c8bcecc608e2eeb2fee177e22e7b334a26cba72b4b9e6dd7e6aa5726b966a2b19797b7715b911af94ffc6a01f47cafc073c1d5811eb5eeaf0435880a4f1a2cf6e2f4a5e96ee54a4f0894c0a257aa61247083df84dea6921f6d57a70d1534537534ed75692e50699aaed15542a276b48de6cc269f7a8e03b7ac5bd42ac64ecae94c2fd55a0d7eb86d11de8b9c4097472cae736cdf1dd42554a748ed19b1607faa05a57b0b6701a09ed1670c2a16b486401893fd663d4f189da3687b08983bf4053a0a9eb7436db77fc47066a41bde5210b6b0b81eecd3b8700ed2f92bf423a6e98f631d5c4657919c42e998ceb79d0d91cde8bc35e3a278e88cd598f6f064e060c1d60d991e2fd6074ab73ebdd44aca8d2363ca37bb76e58d5d960119fedf08cf2c25e8b2cf179bf5ed6834127f4fc8ffaed564af0ccf263204d823292d8c504808465be26191482ca9cf131bdc37eac622d0cebe5bf33303d3c3ea3ad5936b042d2987035eac28acd949acf9d1327955afc62038aa7d00021e96bb2d6a9758475ebc7ed62e9f8410ba9734ad0964d46219790813666b3729fe089edefb70971a29138cc723f3d1d8e50e590372c9f8bcb1cb5f4fae9e874ce501c1e4e65ed12d7319af2e53e04df6dd0ec386000eb481731aaec65ae4dcb1a35ae792a837ec6728ced14dcd0b6b218ebcdb9c158013b88a2615c931fe3e43aa217d327fa4bcc1ba55dcfe1ac57ad90591055ebd008ca3da45c5e8bdae75210d6771372f91850e28fe3de0b6e901357674f187c03fbf7e49f5f61a99f98e41adab934fad71408c22c9a3deaeae2587f9af0a2f8766df7a3711a2a1aaec35e5f5cd2f9bfe9af59112ed69c0f6f61c5e5efb366adb65841c1fd1dea5304b0360ed2188bf25ce8d62d11327508721d5d2aa237310a08f4dee3e51fa208f4e953bfc5fa3dced135f7180bb780d3d6ac22b3476253fbb9a0f31612a7ad37bc28dffec492077de53acf2763ed513d24912ddad8bcad03c83e3605647776d87de27c355aabd9321becddd8295f2351679138fa734b5c4510b8c44c444aa375cc2736c5fc770769717a7ac49f48cd74c8eba48173751919614abfcb0823e8f5749238c29330375651ec8764506be1de083a9c506c9b9dd02457428730557c0f2b72b6dd84d8aea8cc88f3f4298dc80d45c8b7a193b11583be63385a878c0fdbdfc52117d257a21cb3b611fc3eda9a946a414da91ae65a32ff2766e784af93ea4cc6de1167d4a15424050b8f7d0ec1aa6fcd0b28c18066d25d7f8bd6ae3b8f249933f78e55d1d36df763dcffc63f5a7280ac2faaea0899a98b4f14d036c483d15c7f1c8152a6bb3668993d97faf4f5a2f3c120a6def5439aa405d0c27279dadc131d224d4c3ee1d3a9b67b03332214d339c5d34434ec333f3e277aefcaf2fd7ea246f0fbdf663aaa5df3d3e4570b0acdb326af6aef27e23eb14f0ca301b297a50c19bef799d0a6ac816c34976bebee8c809acaebe08bcb0fab7a565e4a7b961f323c0e278ca73734c0b43b1741d105b16c7b81c20d7d7710943efeacff5cfcbc1f395c14c3673f3c17b38b4cf65ebf7c080a4287d1a6294f9ba857652358dc4e20b2c25532fea8b8ceafa88864fddb90410629368585eeaab362ba6c00a069889136a19df7a6965a08ed8fce020a358423913165e3b24c9db3cae12b2b7479b1a5a27644ea2eb117aa209d6a755a8158b9ebfc13f9111e053c7fef7ae73b964dfc634f3edd958b5a5bc6e26b882153794d86a42e12a40853215e7056757066088ee9ef4736cab4354b076cb3e453e6e4acb9d7efb7587f3ccf39f82c99e5ac5cff8b7ba92a58dd354581a180a63866d141d645b156cba71974b07289a0e1b786f1e495f4d85ccaf976ee55262bbe3a5a9c3ef6bb58f4a3f48d83f0f1a63933ab6799519ef6aa2e96953bd22f58b7b4240c19ad8fb86877e11f962936387d9a2ac0b69039bb9d5a634018a102cf615e27a11011160db83d765a1966ec47340cd3c2f0ee027d990ac20562f0e9ee1ed33dbe0b894fd9b3caa8be483ad38fe89be989c9e645e71985f44ccd3f2018a50afce5a68175b670f5e856af70f708ed76badeb365c1427d3b6d34389fb1b03192375f1a1d3bdeaa33d6a87ac77bd4e2f52dac151a9fb8f5d288057d53cd89b12681376733a896de07ec2f37daf9ef5593cf939b35d5a847e612714b5cfb01feeab54a571c3181782ba954bd6016514af1f4470897d488a77d74274679b422b9af36575bc60151f3b358dac74b88bc52c29a645e3cb38b9a871dd35f03aaa12cb58f2a088ec64f8b0295fd4f12f49666bfd03ae91b93632221192c964e1eab424d06af187b7a7eb43cba472e55a3a81266018fad4068e783cd1d0e457df54949f22e2bd189c0879fe35de3b98e4858988cd6384bf4651734482a009e50edfbf3911d7d775d8df1c79e6e546cc7035f740acef2b1f76917f0556623730b484320fd1fce13f0343dc34fb0a5c17c56b43fcc8cae5f1f6d6924f422f5f43580c40fa54a910d4795631a9c663171acade5278ecdb552a30f598794b2f5897d69376610499ae7b89a5e33c69039d1aef84cfb560c74076f8712d1c9a65b42d773d8e95040ae67ea748da3ccf3eef7e60162ac79211c4cf28f5d4ce758931e174210044cd54742a7706ba11124507161f54cf64bffc727e115177ff98d3054a5f63296ace10c75cff6fcac0424ef9f2a976a1f79bd1cc4c650bcfd6732e2be8c8f80911eb3f552046672abc5ca94ee60874cbb14f9e49cafadf3b7f92c96c509b0eaa0a4b0b03773b97bfe8dfab83e41cbb66f8a09dd2ef7983ac8a06930d43fc76af1dd61b195563ec2296a8b371b20911da8ff4e685040ff68288bc33192ddbde861dfef3badb5c7a6ab0e7b74a05dcbf5d21b16679c2ca203debdf3a78da401090bbdf9de64566a926598adf43187811c95d905d9b0e1928af0f1a9b277fdb49cfe45eaddd97204753eb82b750270b89fa25347ab35be926a5b25e1255b9abe548148da2b4b83f0a2d3d898cc8e9f5dbc5d9e7012278371c8f7083751e7a746f66eff6fcbc542d229583370639f6e0b36df6c20a068e779002b86cbbb45c8c616cb238509e369c2379aac0187d3bd661557c5f8b4c6d7077504a747e99e85a70c40bb566622e1ee620d607393d048f46f8da20a93d7aa3a5817c3977a50c9032aae67fe3ac598d803bfc1f356ac00fcb1266b7d03e6b1ea5a9ab0a535933c7cf0210930cd93fc9f878c3b10f83647fb46c7c03056ee79e9c1bdf0070c967a565c2042cab5e5b58529861fc569d05ea81e0ab329a2f4b9ee905be8a0a3fb1324515503e016003e12d723c339b8a7a8d0139bf41c63655d2eb733beadd4212a71e7fcfa9b152f833d88c1c9f813a5ac213e0a3c461906193fbc2718bd959e97edf24d1a928404077c54531f9476b3721f520774c3ebd9c5f90f1430c285935a68200be0333edbaa0286f8ad5f04450fb1422e286254e68ff731878632438e6cb19a764112e4e92c266d98273646dc57838a3320c6330542d6da62bf5896db34597087b54c132d84b744823f2408d6b3d76b6c44deed92e85b1e71339940a63e375588a0f9dd629b9b4dad2ba87a7b2e64c52b3d2ff390b34324baae63ec2d526204ea4215045229496eeca1fde2ee325d92f58921744b149ee3f5713560abd20a70d82d68b32f7ec8875099f1cc54d6b7719f8714380fac6a3910dc72c701dbc67ebe2a99d1da701d3951b30ce8a36a165cc54e7ec6ae31f8976ea5b139b62f174acaed6c7586e8739dc1442a9e1b576aff4efd2d9b921d6426bd37ce983838b4571cfc9fc76d121e43d6638e85eaafc8876ddf1b66c84827802e7356551306bd8a05d85e196cc0ed067ea77bd2bd36a52a2e4efa734e49186b7495cd505304dbf61785b0c1acd7fe0b608a9218c8f8ce0995473aa7026c22f1cbea4f4ea17ccfaae347becb18a9f05c07f030ee7f4dfe5c16ca7985c9154cca9b81af7a9b06cb16e06f14544613691e9de1031c4a1e7d85bfc08c7e5e73b1d27b86c0cd380790630659d08abea913469e7353b0467c65a8da18e052492ef8f3fc56803af8de2f348cdf87661b7e9af3fcadeb37d7b2acd714eeeca1dd0da08ba5b7fc6afc7e46d2880203fc4bab8a3736d81992ca05932a5f546c861d9fac49e49677177e65fbe2a90e7fdb29b230abcd21a28a8117ce4090025c345eddffba7c00c0b7c735fb02d4e368b488b80ef7ff14dfa0b0f6fb8482e595793b2fd843296df149c77cddefed69d58c246008b1de3f12697fd72afb82f459176305ea2cc3b4ac4264733319cc5b14f2430df8e089e31cb9f7ea010b2c94b51f1ec8348eea11cb725406e1860327c46c84b1c01c6c8da844782e3ad287e7b274525d94f1f0900aa8fce856a8b97f04836fe405dd16f48b9da0aaf6de579f9c43ca67574b16d4be2de90b1a7258c984bac67899fc3ca21ebb8421823cee3fc3709ac5084d17385a66c98090b316e52c7b59577f0fbd115529878df294218d770aa538a54285b62fc62977e0b27214bcf68f3c6ee67af8c59825af9f2664eb5a5ea35be8e61798f89ed09efcceff96cbd8551f4f81ef6521718e667fd95d9267f5de53180e4a4ced0dd32e63b7606f7bdfe46c57c548d104463106f1db9ce5d30664c483ac28f3655ebacac06b442cc1ab113df3e29ceffa7c667eb1309c34237917c9af86d8970d36270c8dd7ce64d71b3a76d911ed7dec65800666c9c1bf2c9bede12db3c59d87e816d2a7874c04c3aa76c9a7b683042cfbe925486dabf68ad58c13723354b5ac37d50c12f93552cd08f78ec5d2dc18a3c3618916465b20827d526731bbae866da9ca20ca2a75bf9dc46e1d025b5b8ee15fb60857d9a560302f00ee477f8ae8a9c7f92267987f1c3134fd0416bf9a72ffef900528f4f6edd6a85cecd7454a58cd66a70ec40d4d402105905629cfdfbedaae7052927f8f25c9661a2fe95edeb3fc553f9d8242895e813708b8a8d8e94e65afd2e3f690efb972cb60edd54e224e3274bf38448411c6e401df47d091c0b04ced1195c27042be929bb1f94e6e7743d20982da0744568768576bf4276b467d81b3d8ab9005825520ecf0e478cbd252d9614070d6b39f2ade2be5ca41326cb8156721c65a3cf0723257db049e2fdaf7260a1b6035c5ac1dc12ad29c7dceb9a42a429d9d17804f8697a7e6c0ee98e7e373f9f65ae89e4dc201dd8781ca9fff4944dbc913ac5fd003873c42618d75e2b5e3804e8722c3134827d0f59fbf363dd4f956fff0ac26abd40e3684e56cf22727fe72440ec76481a29342cb1de542a2faf2c853be7ff3c24d486eec953b02bf39140a8afadad9d0271a5fffff56c4b13b9d7ca5a192be0efa7ea7a98e7b02b3c5fccf1aa02d39b967f52b82527ac93a42ea9d95a6e198d35c4e7f6628c17737ad1ee5881be03f1f1c613c20be04be9cf146f99d78e7fca42749906f3b7c2191ed72d15d6f3c7c38237b8b493addae2ad6ec0b0cb9e6fd577b841ab6b3dbcfd95227b0fb1210432ee66221f5b8cf9544524700f154c837c5b7cf00883ebcdf16f543c37959849b8c1a959247c3b10356188e1eeba03a4294935b9c2882b9ce8a9de5a61b1aa9f2fbe7e55d00a28027af0870384aa3a17ad02d0204dad823e70bf0dd4f4c6a0de16cd9923c6ce3237cff3123ebda0b6ca85071663ad8ece80430fe8f4d1ef9fad5a35e3d85588d8ef2683229d0b2b15cdc545c4ae13e697301b4a7b0b14141c724ce47f0f046d9fcf326818878f95ef39c8a1f346c15bd752b1fa01b02643766fd23ea91dd21fb9d22a8f6c4f894f6f5bd0eecf4055fc54b1ad55c39dcc3379e4ebbf77861ff1d0fe93703959f5bc331f7807590f6bd6b4adf0abc589ece34fb8919e92e1f01beff28bdc46435cb3b29920b0c0460ee5aa6d0601ee4927af3c154844199ced96256cf952f271bd0828488b7b787b7b772c02d481f8a672477f1c81bd4e85675e110a553ed97e091f13ee7076ce6f8c3429166a7b6f9a84123e7627690d9ba25a6768aafc52714c39c9a1926926714f62c80974617f521291a2d43a70413bc15906d20d9fa1357aad9aafb68f85c042adafc63640ce34c3a687edbfef1d2208e1e98790e5860c178599de4be3bf26ef334b508e252e854d9f39f594535e518aca896f117f2f112a6c968b75b5a73190da6a01150fde2caac9f087fb84dc249bc98a980aa7fdc642767ec66f8b32f67c578d38d18bfbaf7e922e6ca84b1b9c124069a8819b868f1b5d82831f5ca457888442e180d87b1ad96312270b3c4783c8b266600335edba5a400b3b7441af052a74dd3c6c81eb85aef140f6f94158eda56d248a089fbe72829ed115ac28b999cfa7aec12c2e44e08ebc61abdbf1480a177e6ffdfda0a54d8b02aa23ffaf7af381bc13348d392cb40d99c8e81d9932e49d02998c3fd1c9a0bbf8c99c32aa68cd22a1edb5fcf7e39a2bc337d027d96328e4b9a0f70cc508db85390da465090987efb05c012dbf50d7e35bd463481cb15fc9503b6559f8252b6ebcf8f170c99666d8580cb74548065a194b2d6a70c271af9a3a388cda1fc2d16811112111a8bcc126cfcc0957c63d71cc31a25c770597c1458c9ba19ff1009e45181c1c7ab422e69499fe1ed54f3ccfef9402cba6f1937d2e0805b77838d2abe369ba7f9b85b6854111441fdaa1d96a7464c8b467857291639b5f5f57b0ef3f023bca077500e42c60a3c99f9bea670adfa0cad17f85f9f026a09f7ffdb94ac16394895b28cb5de0e2d40d0d02092d41324dd277f864e3b047549c35a7a28c4cb3c6a02564a35f3ccb2c373ec34e89032085b17182b20e5a393641fad82f2e864186e360b8eeffdeb5c4f2c6feb5d975539137c9e267603497e27ed5bf2c82f3686e7d402a6d571b4c532ab4c6e0ae391e66177cd46c28e085969b65505ca9091ee732a8f93df7d6205e1bbfffb577db7ab99d1bdff552b25ef2b66d6aa25eb3e57977992babd52a1479bdc176971009669371b08c5a6924a88a3dbf92a7e56c140d7108d08bc79d6364d3f23b535540363e781e91de8d89cfde91ddb93f48064d57d04c418cf0990c5bda2c1ea600e71e7fca2ee097983695f4053f34bf5e82e1039f49d0cabe89d71c594aab56ab9c1684c35eb7a3e88ab1ca286c01f0053570fdb0fa8c8b8a0db4e3abf5d77ae988068ac747ec2e153c323658765e02f5ca01a360a5ced8e05bc7cb21564db652e36392ac912c0ec3ee2761b57e3e9f496b1ba8df038ccfda90ff4069d2e805678a889af519709ca4ef1c4b39f4239c43e0ef35bd60c0e81ac13a44547285d3b0eda2ee695857c08ce4c60c55dbfd06a9cd7443fe0d62817471b2f2e82d5404cfd642fdbfee39fdaaf75b1d22876d4a292916aa05d7fc0a20b29da9a0973168887a3a9fd917d136db2f3afc588de9c54a456bca8e7a48e001bdf75ffb65e798a8614e4eb8177acef85f66e33dd16644f73a7a3dcc095b5e70e7749d596b5d5a2ac2bcb1311dcadb62213d42b2a7f167df96839f9411c6a1e50fa6cf6bf3c5c8f8125cd941f41e969bce6648ada704ca3695ac29cc54426bc1a871a300481d0ba07dde52e74e4fe36b283ae84edfa8294b77df0f1503ff4204d155f7b4e05cbfb8f651c9531c066b3d896310c36ea4be2e8d2830bd191ef06516df304bfcc99a514b8b2af7ddc50138fd0c418940742e0f47b40d63ec200e7cce8bfa0a14c27386c2c38b64818c4f128ecf46c46cee536f9412ad8d42f7e94a4bef0c3e4e1b0338bd29d93ce5b1bc38b184e41f1a74260e9e28e7f3dfe9b53c59320bceb6ea0d3936d606bd57674f3c2d0682d47fbdbd2a8f2a3ee22b5b8daaad98a5f96401d0496ebf4df3a29530833795f1304cb5be5d554118321b0965649dfab603e6cf9d0d5a308f6bcc7930d137d7250bef174632258d4348192c4428e966ab0d459c6da1b0bf3ce212770c97080d0a6c5624d4b01b0574dcc6c98c6b2587546955e9e35f97e44e2f5a88d8c79665a1d84f66ff4a1a7344ade679bd196cc93fc5c29f3057299c6e88d717ea85091f0dc5f7c22abe4ce370c97527b7d0e0dd20fe186648a265488164b93f81e551ee7d32c84cd45e6020fac444725a2e2942feb362a8a70cc7adc87b98031d442efd17e81c23707e5d3824c9d58f6b5fb5010c5a03ff783af369c2ea420b82eebab390206ea4ec0a53b02ad22cb98f15b5d0c8dff5382018472981ad015ec92e8d81923c87d55f5897a8cd6f98651ac906d9daaa4785f204494f8c48ba18b4d8ed709c00ecd0b26b35d56862df61c7589ea21cc3e263010c9c3ea9d79d4416fe2f3b713c7b7ff3577245c9ce47578ad729d3c4827795e99fda886ebc0fc99ba6cb9721b07925783785d738cd95bba56fa6ef8fe523b2861d34f48e5d392e49f2692137bf0454efc8e3a3a65b27bfa8b2cc509486be59edbcd679c04c6fd9d3d4725366750d2e4d9fb728c84cc16232389aad20ece2f61894ba9e865ecd30bb2fb486104a127729adb77ed4a5d72e546ec687ec89f62e8a0bd99aa235777a6cbdbc5f92985fc5f63436bb3ba016f9088a0b882f854b87b351caa48b80cab5443d79734fe04246a3c0fc4897554c13f224764c17368335dda763bdff40a37b42f24e244ca31ee8a54696f3b89ae1baa28f154afc5b0d0c4bd0a5b474a7b53890615fd403a7f9426aa2bbe2043fc32b5983623847703ff394af11ca4e4200c513b0b5510a2a30a1a6a23a630ba58aaf9de31e1dab5c01f239c7947e92eb05cbd283174309f3b37eaa8b085c91f6755fdb01d98aececf7f3e31a79bebf459e2477d5c548f25c0d8e35697ccdea71caf440041e67c78975dceb98b5f2124d4d81dc8ec9da1628f5b04f8b998f48cfc7a3bc29adb1b46157389072956120186f00627cdc1398f05d019ff72feac45ff96a9144f55b4531dd8d7f49e1cd11914701868cf27a44d9d24aa5b3869a02b8216c48282dfba7882c825a4eda2468e2c233b6da7e1b7394da30ce4208276f6ae522cb806229e7da0ff1fa2577086f2cd37a519bd7a0d55990fd3bfb29c39c327cfe7140db387f4f30f192f8d683a4a248695575a43a7200c39cf10cdf996d834f3583a1ffadd6fea724da83327456e9d00fc40ce19d33d3056ed0e52db23f748525c9b23b093b726e454a1b39022b6756f0a150d7e59c333ad7ef761505fe4603ffd56ef182f1c0c36b5a41efa3f4370148e02970a6487205a4b0dfa7e5751ea70d39b908ecffa0aac8c07d3bf9d196db4126a2084305383cb11eb1cdba0bfd400a7e7843b715d245712c8f9a8122b9a83bea6d5290990166eb7685eb837ac920187b4b17abc2f5c08f49b31bb6200863e5592be50bd6c441a02318dd0f077aab9b3744fab39998193151b375e19146c5ba8599aef6c20825e66ffe406b760f0e8e4c5d33ea44b0b386f591214b13c1e05f7b68ad4370b26ee8642b4f45cc3c260dbfe707f784f6a488112a56ad6977bc77ef29765578343f882e6981c999a03ed1c780cd87ea69fa7cc07aadc515ac829c83c634d6786a56f39cef5af43df3eea59e91666b26a83ea5839ac7d58e244e76ad86505937c557f42d3d56a51a1533ffefc63b1ff776296ccde5fe90a6ed5e26e719c7115615676e69f648add1a6cf2c5f8aa83ac6ebf28075754eeed947af2d558dc6c51da2c0c0b9bcb397b1ddc90b0997c627f049fefe210e1171257a09c9b2def5fae5f3bade6fac9fdf106daafa03b27e9571823721e9160f7728dca6c952df0d0657dbe1d0ebe6d9c929ad7e1364c26b53d6c18fb3036631a847265d733ea1831fb539ec90bba6f76e03dd23f1238d9164808eb14fa2b3b586ee065d89c1bc2360abbe1f28d71e69df011fff529548083f77a76f3b82701522c989ab20c086523f96d5f1b28abcfb8da1ad5922428b0568287e123c4a354169bfd07e85ef722e36b27628ee2728824c2cddfe5a15dab31c3e2ffd0ab83ee96a1d416af1ee42dce10f22cfb851e74e4a6aacaa611e3df9b11d416c29868916830be95327d386662f3fef97c1ef0bd4cc6d57af224cb674afcc1d1d913962a9d7fdbc1f630987737f1ff8f94864daab2fdf0e912cd59b2c1fbda7cccbeeffd441678315a8a941a120db03aea21fc621064b130a0b5c25002cace174da4df4f080e4d3897d1f41e09f5e326a9b40324f131f3e458078263bed51e33e07269cb5dced6ca610a6e98962b7d1e48eec44e40a4d34b63344122519d2db6f2abe329ea8b8d6b0e382cd685f1be6ec94ce3cb8622bf565ec5980ed1971863d1ab1d6bf71432c5dcc20fe22619cf1599d4397d7e2e9d86c37472138b3886cfd6cce39de5ef621deb2078989676605cd50448be9328627cacae743d2ac6ac854b5969f37186ea0dd3df6039b77e886de0dcb9bcae41f16ad4a9a38f4f718f1c6494ab8a3594a3abaa9580a293083fddf3f81020c0f54bdb0a47d7a35e6995e327e92691b316e1419d154949db297b9708006aaee7ed0b1bc04fbd2dc31bc6eea7749f13cf373441903c2379c7564dfb30031d13132cdace136c6678e1ec38ce23e29019a67e20fe3ee039d952a43787a655f5f91acaf1775582d185760a73d20252669bb7cb567ed7d6abcc2718ca8811a9cf6e5899ac1e1ef16f611bfea2a0c1007e904e076df95885a914e6d8c1abe5bd3db79f30ffe449eb1d10ddca0c237f7ecebb65f8287c2a7a295623be51af4d29a1903623f7b96040648521b51cdad78f29bf4f214efaf477dacbba678f702f2e172ea126053c9ddb9cad4da4287a7187d35380c9fd52d5ca361e600884e407eb39c2c51fb2d7419cb0370641ae3a7c4649b5a957e205d42445b0599f589322828bd7688adfc174635ca06448e060eabf099508158de78e2401e2de5f8cad010f3622e5e7843338cf9eef89ca2d0b426e60204f16d47e198420c4532869cd493d1a4188a4bc8a304ad1953045cc3d05e9a521398120cf5a4be6d17d5531fd44e1a6f635b63d0fd93369f9921e7fb39c5cd5adde36d8dfb3e2b67c594b4597a5f101c019f79e1630e53ed0f3003796647749fae05dc8cfce58fe82bffa4f4a30f43f30fc729750e845348bf5fd2a30db3b179a1ad8e38be83c03ffdb1dfe9fa81089359ab9ae5ccc221a891b1d37cc8e0f8fead3664becefa6256a2d86e1dbcec59123f86a27f2938a74d6d6efa633ea271f12fb4fa02b6593004816c55e900da95aaf073d6f1316d760c17def8ccaf56a2e8919a505ce13708b3ece9abf993a56c200c92bff0a2a45bdecc1841c40252b30b63f48a2aa901800f876e73e4858e1e88f241fb01ae9d2025cfcc3cf90bc3a159b15ce388c21df9dc3e2421ae13946d164a88dd81ef121dad137ba4f59a57c9e3f77b4605a013bff7654dbf3fdf525295a88356c15a2e264c08044bdced2e647ba4044d68e29a52f462e9843d6672254151092e799555a93dfdebd8db9b41b05a321a9b1695710c071145a0460779a02a205d7d34e3b36a8315b2bc31b964d73f895bb5301d11c946b1b1883c663df285a31d94dec0cebb11f3aab3a97fef71d26f1ee7a8f3a56c95670a71da2c1f4bcbe5f2bfeea1f3a4f9fc431e36fdaef131aee5c799e8d95549a4161293abb2a72a63f3f3b1585a433af86880484203e6f494b5755074b488b79185714089fd5568abc3a5089d301c65b77132dc6cf0649d4ce84d11ced7898910b97ffcbd254cbb4944615b521c4390d176a400e719fefc6352d2ac897d2c1e8860351f8fd9f137744e62b83e1f5c84e01915ae569c9c402460a8c2f04ed72e64221ff3a88ed0d3ff2defec9d9868f1aa2a4bab484aa4edc35c52d2e1eed9c1ffb389786c1c2630c630204bdbec6b95501f0326c195346d4b1e207d226e914c4b0e80b0815746bc3ccc70a793453f9a22aff5e040bfc393a350fec9d709d552dfbde778b4ae9ab4e12ccc82eed0a83916e67cb8d9f3bdee72ac5bc494e24a3ebec6bc9b6166889ea5f9a3103ff8f35f68bfa3902136853264108d2bdcd22fa8764ed49b388689796fba4c66194eedc5bf20b3a49f027c735a661e500bab9219227cb9fb66ac49ca9cee1a3aeaa36bd6ec50e14875de1fb056af131720944bbbc4f23f9f176b714190de8b4f2e9115a72257db9a87ad913567ea46e075806860f70e67a57c6371f06a24ce8aef0f428593ef4b64f6f4b5bb0dfd63337ecc31b9d4c8387d0796816153298b4f84dd33fb56b36e921ecda84e612db08ff6c583635443f3a76dd4031f56fb11f32efbe2d10207d1019ca7e4243920ebf6f484ec214876a6782dd90e98bfab1d7f6e37a40a79755748a217a818afd12882e882c866d5495b92571f306d874f5d36b24cd76376a07089f3e3abc50abfd44a0e86904d365f66b137196af45796b0baaf8996076cd9958ed6cee68302e9a726238aee2757b94e5bc81321146d2b850b07c6f190cb8cd879d10647d1eff94734a62561786ca99b6f5a118efbfc68473d3b3a317803d95f4b3ca322584e7eb7983f210122f5f4fb2fbca8e9b64f0e96fb8025dc7d9b8b0a0d899f99ca5b9928b2368c8278f69053f9bbacefca3a7a7b30a8de8235b7e397d7417933153396a27f2b88904998204bf2eee6869bbf196b160268f3002062126d34e8b8cbe4bca9a70c4b628c7083dfb1a8fadeacd4b4b7b461b1f6b3fab70d6ae54d1686b0771e68b98c2708cebd9bd40e0542c0c464724a5ab681093aad6ef567b9efcc72c07597803b778d2803ce30c239d48162630ba42af8fb47318cb6d3aa51bf3aa2cb4ae4f6fc1921632ef371f1dda1f53683d9f0444cc8e1427f957f43d21e7410b078ae880fe8a7bf40ccb3027cfa3fa3d908eaffc615bb97535011051fa94a045474d8b7009a7f04c912f7a6ea4b2d26e17aa8a60ed3ceef4ebc3863333d259c4f87f46926148218b417f347b5e27137d4798db637fc2dee5483f00d119802fb29cfbbbd053ee3c7272460a74b029b93ed4b22382c6ea7fcae3723e6157d30d9a095764865ae79a1d03395d766944808ed2c10d9071ab303dae94e52491a23d8269a60bce7b362a6013d3772e29cd7bff289f42e8ea5a9e81ae64ecaf5d64bcccfb7c6faa84bfd43953b59d4a079467940141c52da5770fec38b4a3743b5093575408e96def4f0749ea9b80ebb99e70c91a73338303209533b6f6b7e176062a1bbac968db813f7d3bc689e5a8865cfa7d098b011ce9544c6d5d37af6a84dc3aa4309671710049d85a412fb8958c4791568d923b8d3a84cf2caafaf0dbb8f55142938ec334a62cf7dab0d948bd241801a2c27d38330c2d084b487c688df46d6dc98fdddfc5f16b304a42636c9b5fb8362ec2b6f4502bf05fc0910b146f41a8174b3fcae410cf1ca8225d69e084d0657f48ca89c917220922e423d41dd433899eda16c2d6898fe7709b6f8a58bcb031f1d17d3766b981de0eb3e27752a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
