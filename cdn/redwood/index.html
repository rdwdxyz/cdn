<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"984417ec73b08c8ea61d3431e761e3538192ebe21f84feda3487f24d7951103d89de1f3acb945761cf65b4a6ecbdf2f2bbc6339d615efb2f0c568d419debe2aa54d29eefd7b542fa76af342032390daa874aa7794056feeec0c1a100a5cc6a91ff42664ff5056493297b193b5506b6a02f5e31eef16a6ca6d8125b4ce867f74004a5e4b3410115e01e17819ae4a7652243fff4b55f7867417b8a82cd19fc8dd6923c73639aa003a88526bdc4699c9d2abf62dd20ddb6276a47259f974f94afbb198c459fab9e0506d6a8a212037bf47420bf57472be322db2a9c65048034d57d14b929043003ac12e0c813508a6604cf6a8a55832453f6240be64235eaaa9c1f638ffa8431b77dea18084eada0e41f160ab51f20a8b56d0284ad9d46e38db901930f6ebf1eb48fcfd166b6508c9a466694994c1e18d97415e61f6124904b21842a7d07901aa4da205945bebaeb7e222091d3897a77f9ff3a41a6eea031a044734c699ca51b705bc129d11c72f6364a4c8f92be2d90f795ea104132285c9e0be6f49c2cb147a4ea4d962f0e8dbe3694549be29d9b41088fc71ac0ccbd7a8fb44beccce83a5a73986f26d2010c6af24cea060f378a914981fd7c94f37a7eec5dec19ca58dcec40b5c3036085e9db9a4a8a84087c63c6f1a4872361ab6e4a722a8629c5cb7f1e6421d23837ca63e6a4c405602a75363fbaa23fcbad64cc04d5cba583a5877c6642b8d5037177a37500d20c8396807657028b001c93cd34ee7b740ea21af5d76c2a93a22794eb0d8b86287b82ead79098fb3bfdb8e3eb2a4e4d48657cb201c91b6b0219010eca1fd2fb3b73a45ce5b010ce1bfbacf112c70a23f5e8f89b6701790bd60ed1ef205fd77ef6db908088e5c8ccbca26926d4660f7cbf2f882c69635d80363ce3934760d6ccfc244f56866e8170d116f57ecc86fddffd2020c2936b57ed43e6ef5188499351d97a5e6f4df9e9caad287ce85dd1b6b4abc42f1bb94bcace293f54a3f276cb8a894ffaccfdf40d88545fe0f02883c9d715a4818445f5ec1699ba31155ea430a7f1b372b1f17be188fd995de86bb436c5d33b0f0693e8259423a2a237fcc16080f4d7335e4dc6ddd8b4e9a32bbaa5a61623e310a174906f989a55e0acc3826d9e556a9b12989d46715927f183f7bae355a6759f54dd81f836aac3f4eb9a599fe2f881d577db148bf8d6d79b1d1e21714a294bf803fd581c80914dd1f9c8de8d789c22a45c1556c143396997762605cbe841456bebb83bbffe99a023e4a5689bb22005aef64464c5e26673f2026b6ad62739f913280720e3d96ca9a0d5712df1855568bf6af6f0de5ff53933c32ae38d8619c875e2c0a2e5e0dd1e31e0cecd52d6989b6cf0615e8beea009219f4da72f34c14e39103ec2260c1c2b67b43d0d769671648a54ff6c054a1c748acd5e902ac84f84bc359fe773f99ad8a75ae906505bfd9910da7716eb25790210c75e59aa77b78f43689c3492bbe881b1e7c77a168a3172f225d26b5a533e76ba9d4988dea85666ab8d0e4364b1960a17482ac29a2ea626e146078ebc23e10195655b94ec8a45346fbd7d99f891c2c9453f4c374f87c968b826d9a18d49e7249d739c95a3213aa9f69120fc69858b5d57b331ec2720677c61412aab97eb8f443d4120dc576eb33436a38f4617e812c342a6abbff95d68142a7b8b0e79f003279fe7d56f5a89bc88e2dcaa67685f7ef33e1108191f526ea94e82c7c7590a5f4fc345c194b0ed900ec684bbde28143cf5536a0f8867388bef55a0bd439a58fb608a05ec24f484e56db38d576bb2092d65e85dbd355a1be769fa97373bba9cc818f01d6d66c9fa841e0935ee057a17937e67b3e1e8314698f47f00f838a74e6723401010424be4a289d82017eaaadde3988f9e2d7f983497044d14c3331d95a7b556e73c3b7fba8fe21876d9ae47e836ade7c02fbdf8cea2626206d3a8f1cf0a610904ab38bd548bb73d80dd17246d3a87a657064506fb77f0e1bafde927adc255423835b17d48ec68e45d9329a75e2d04e33f475a5f78917e8363b9b3e443976dd45123cad510c1b6d3fec2107132d12041dbeb97df43a80366b2d0fc2d0ab66cdc5bace74df41ca0efa0b6c8f004b4905489a20808a6006102d3797b76c0ead0b6f92a71e1b4ea6c28c6467529d703870dafcb9ba253216be65a32bef9eb845a06f5e2c34cfe1728ecc9f1bb4fb93a8187a2be3d5f22baba725c8ab600112971ff925d3ac5209b73a30fbd8c62ac7ff769b9d0ceb28a5875cf55498c9056cb903f8610096ed8c355b26cd354202f014139f8c1b6c263cc8b2af0eece0ce5417c42afe493da02b99ca14e822b852144a1710828c32a6058b444ce72191cb04d04b1de0743157958f1e28578462d9c6af0e6b708ff9e828b75fb49e9dbf26f336a611e5e46a9a8e49b64bac5bfb9c8a991eac7e7ddcd920d50069408c57cfe5d4653cfbf6c388d499feec245731b57438b3323998fe5eb8e7ec41d1047968907ff9b6357839eec734abaf4ec1d5fc56812cd7b6e172c19673d89cf6b6046741c24ef0381832d99d1f14b7352b74cd2cbdd713f3ff8263755853768f4e34f102597b62eccb8cfb8ba9d26d05f41b3da30dcf0e3079fa86b8991df59be222cbfe4dfc5d21e8bb3280851b3cd7f8ad5eae0d8d5eaef465f9a991f5df942c9e28b016996fa92f0dd4cce9f381b163ef13293d9eee3f07951affde191a5c27ac14da3d70a00aea1dce1698dd00064be245e07dcd6514acf48de0d3e9424801021272ad4a5cf4958ee20279b15f3317869326242befaf8f98cbd8b035a31e72d56b7a110763a4990c1e0dd5a16caf3856b03605eb5ab7227644c6b4b093409e340ee67e21b696cd37463e88b1e1437e053e8cdb66afe231ee9b0776d55aa20d5b529235b88a005ef4dc2be5be3d17efbf4ad8c8739c0a289df570196802158b8abd9cd01546503ccddaae774c177595c2dae7be9a5c7b060fc007a1ef6692f035927ab0e3c426dd908326cfd26e2c4f483394ea4aaa238989c7f25c1919e113cdf0a4ebdbcd9307490c1b33f7a4f69ce206af474cedeb91040a892d647cb659d3fef5b03c426d642c278c613b5d1536000fc458de4f1fb9473a68388f8639d5dbaf832d4a999778a84d050e1f9a205d3df7b40d66ec5101055fa8f9fbc35a6111cc99373c1c4ccaf68a44d931cb5a8989c724ff28fbfb82f5093e7058c7d5526d6f0ca76dfe3348cf8ae3ff49215079949f71d70e21643df851ee9a8ec4c44a7a8aea64399fdedc0bb2c138c69595095c8d4e4dc0292a17fe20d008b86536bdbacd24f4aef6efd1a991e2109f8dbdb559d302e1632ff4f0b6d9c77c13fb3b5cec5966e2c69d966747a794a812744bdb21ac2fb1d382584fe0308e2146401d5ce4056ba878177985e22e314c916ae45d9b48996a00f3edaebba582e236e46228c3d77eb182250481fcd03ab19fa0114cafd26f2b63a1c14dd36ad71cd6b1159a3c61b841d22da41fb22907457faa2004ce866ddfe7b6a3c31579295b8dfb969a1b1622d43bc2e65f9bce24cf03fe1c3f65d1e5dfdb532d5941e2d892af5ac5ce6bb721242c88989025cb8c350436791a02d0cc2cc1aa1e730900e8bc4c54122e52897bc93d3f9b33c65a1e5a13b378ae7e4e092628f11111bd4174e0fb5db261ecda1f3155789387fd25ecd8f0362b49875ee680a1a138f0fa7aa9be5c0ff4967c80817a80438430ba721eae1237c5b4db8887f1571eedb4d698d3150fa79308b1a72f347f2520cc6caef0bb9df635f99a296a3c3f6e711523dc099c82d785c5294a2f87a8e10c63e99d7d4edcf2c0f75c2b702c9162bcc7f47195c079759e53cb3f684dbafeb7a61d3b6a970d9866435f5e4263036a3e031a0ac4f7a0e83ada510d543be6578f4bc61e15d585009c913bb0af673994710f38d7cfff01095592f4dd94f1a97d757c2ecf44a02a75735e14ed1d7e3e8fefe2a737f378b6daff49a0ea4013ee881ebdb53e4e65631c0aead55d3dec902506739f2b3c66b716d02956dd4c8f948884c7aa9f56a583ac835a1d52d41c54330ddddfd63a0f12a89871e234c17cdcfd5cfec7a6e3ffa72f26378a9b6d3abd605793b0adf4f0778582cd436aef732c6485cc04d7aa9a7f6fd84c4be2e3626d3b08bce956a7fca4668b241194850364ebf548f6b73dc93dcfdf19d36cdbfff28bee59140e5a654803749c8a100f62a74910355de420b429841470a506cd91c6dc14e56e6c866a900bd040d783cfec5a9e14146437a2e3f2dcc974567f85d0f6a5cca5cecac5f39cd83e48bf29593fedc1b2e5d03e8d4531d2c2bb3703de32369ea07e273ee27b7b100a92f0f678e364918338cc12f043116da18df3e3b52ca5713fbb19c0d8c0d12c529ca32c715b1a1172be6966d092ad633438f1d24af71aa8a2678d8dc02a78efe1a57804ac08d49fde879d3e1d0bc7d8eec82fedf3e3e499c044cbc3646a7d6be5973b5ac7d29f9b73b740a0f3f74f26d56315d93ab0384bb3f18ad6946ad9bbff580a9431f4fd5e4d3e8b87d76db4223b3ce2086509afe53a902a5c1abb70e3adba676e6bdf05811b9948afd66ed75f708d27837c8d1be859bf8d17be4e0071cae8cf0c5cdc0a3ce69eb05fd76144bb7f7a064e8b96d0c20f07d26a42908b8c76e547f1764aa518c39ff673c70c9ac01fc959b13f45344f0fd984e4ee253d57ffc456df1101106a375ca2c66e4eaf1ce287e201075fe98fddbb0ad5fb8f2cc1b1c96f479edd9a60b4f84409948bcc0fe82a9c8823313f070ce7ebe98a350187b0b862ffaa85d8475d7daf4f0149535800ffd18311dd026d0c25da2731f91a767678528629cb3c95ac3387125058e3c45943c7b21aef3acb327be5e5364f47b5036185fef9650e5a76d8eeefe0dc46bd3ae30fbea9df5aedb25f14b7ad32d089bdebe112e7cff0cb7f2d97232f746d955805fa5d71038f8550c31fafe4721e374d6966d06bae3a4427edfc9a382a297e196697f5a46e972743c07a6b16ad216dffabf164c6b8369f56296efb513544f48c31a275f6a2378f1072b18fdd5b232eeeffd9ef54d9b69d4762f6443bace7679ac887f25f73ce4b657fc11b6d092e185d19f6ae3bd73b7094a8a0dccce0a4524bdd37a3be8138a49491900ead166c76e10fbfa2ff3a920c8751e763dab165ffaf1ff5f2c98d7ec9658a5852e7e3d4294a5a54be06c00fe7d7db527b7bc3c579283fcd81cb45325f1168ed90aff4b70fd4f7c6c9aaae890a7ad6f57a7392c943d21d3cbde4a92159b1a54952a076f778eed659cb46f1832ac13ee0110ee7ad072d932afe1659fe8ef610af82a959275c296027f8c764723b14ee337233b4f72a423a08253e3ce4b373105ba56edf4ec457c829b45e0265cc83b6aae5a99c9552cdc9dac94dca162776cf7a295128c1883a40a635c45b84cab067a26b4a87763612c05086db5256c2ec422715f8b4203fd1e4d7d1bd042e8348cb114047f7bf15601aa390ffa3ce357ae2255ad77565616680911ea30010b1e790204d9cbf3c838e26230bb3a6c5c00080e1793ca7d68fb11be7f62d4f647e3089d096c1f5b453de38044b5ce1bc891906c3ac76c7eed93f2657f57487b8b0c93960d8c587532260d45cfe76073ae2789b19013f469eb67bf5388adb63992497bbbee8bc7fe3036eaf3a3c842ec14039f9ba484d6df1ee6c1883069eacfa4afe50584df6ad6d0da5c41c658348d0cb01ec007f393a3c835210ff8d4b9dba77d8657df5709fbbc982d4d370c1cd9c2bf71576d38b0ddbe4d95ca2a482ef96e4179df8250053c88a2e9f08c7a63b5cc0fe99dde99a49701f2d090dc0f2005bb631df7e25a7bc10c72d613e3be427be11611e73a13a9470f0a4915ffa585f9e10dc810c13036feb7cc9865fe22b0a6c710f365c88be078a448fdca38aebd485e3bc42cd4af684f7bcec54d9748bfbb13e4bdd127820e03675fa3ac2e537d92e4c695feb4f36aba5c4e87a8e07e43395dc977dc8a444957ecff31e286588d31ff9313c407d162147d37df0299e573ab77c755a4854e1d6d5557b751a926825e03ea3fb5319a5ceb1244fbac2d9e25874bde7832c4ac9d330b7b3ddaee3aacdcd7ac14d2d8a09774aff9490b25756d5658f59886127888e7907d21979753e1a635798376c1836411bb757da3e2b186ec982cc709e191506272dd84296c3bc1aa9557c4835ff68335c05ba7ae4dcda2618a89afa2d9e58030c4745ef4e24e6cbfc7cc9249e2b88bb129682e9128f49d83f1bf7d29f146ab46f80cb223f4420a8d363abace913d73eef030f7e86a486b12214afc95a7336b14d7e585f01d54361ea37d3e199947d9a9716aaa0778be8f1aac7044e631bd2d880f7f605ee3887d49c12a82040f82873dbc24984d1b01a3987b350e42e785fc62efbca3e72474b889bb4b55a3c67b48d41aee6d68472ad6770e77d826123e4558dd0611964b3c5b93a300fc53196431325dcfafdb8270ecc08a82abd8ee10d66036d6d95809ead7e9b0cecea44304aced3343ded43e55ef67d48ff24a79c83692a5743fd609f61ffe25d92fbd89f58cfa0efabd58f9e1a8bf0bfa419f8063aecfabfeb66dfcdbc2bf52f2f884f663ad3e6ffb545707493614d654cd9020cdbff73596ad7529974c75f265951193bbe7dd707662b09f34403d8e9c20b143b55544edeba2180e603ed66e8cf71526cadbc50463493e877c5279cd7323aa0ee771ddda3d6c473da307f160011d98acc94f2477fd7dba6b9d79a9b4f3ad66c86e5b7d4c532e9fbaedaca3d48cf230fd721b07d9b3a95844da21c3d4df90e0e4dfcd19d0da60bade1da4746493592a50fe4151908ca783cb1471ff29261c52d47eae97620bba7968739cc0d5e19334be2ebdd51ced1e4d5183bc5b75803640c6678560e59f9a4f3b3304bc3877859541b7444762e72140fa974f6a3ef8384844e1fe7c12334cf51ae75cb8b79fe43af736a48fca28eb693b32051ad908dbbb5d8ab9575cbc013d0b747b922d46aa8400bd6780acd16a902fa5c44e7f77ff3de44ce0b18823c3489518db43ad2a0151a82dedacc4bca4bbe33d163e74afc9cd900d3b85f8cad6e073300995dc02618cfde3f062ac66384213d2c28a1dce996fc698c164827b2680931759cac2fbbd0550d79e6ef9338e2eabcfe23084ffeafaeca45cf00c631af0ebc0311e7e0b7f0410393c77d97c4e150aee3d879ded99e6d033af641f551c395fd5b59ed2cb8d2e66f6e4c7b750390f2de9a9f38c287ede5a407f9ee9fd57c67a5881e7ed65230e4b7e10ce474dda9f8f4a56fdf7525903eb725270888dea00351679b3134c86fe08c4a04ead5d5a818cfe5e6751f9cab2bc1b66ce12d96f7f2e0335151719eabb5ef00bb11b949c54c880285d618e9cbd03fe693d4ee052c4ccca4b109207d3ace37bf8529eade8aa48c908d52ddc917b6c8f6665fda6cd9b1bd60de096d7cdabd1bed42dde10260385daedc53bb0acc395161ca2ecec10d267819280886b297cceb8267e9366287f8efffe69d637aa66d7b41c40d3ebfe9931eb68c9d3b2c15abd7ef19c146689fa736f912a51807dbb3efbfb140d4f25673ce6bd2d55d35798572c3bd9a5d49abed1acad30d4518fdcbb5c7536b01d14b807422273c541aac563b7e626294d98b372657ec4e6607ae0b8ea505fc7cc073c7bbaa6e561975d3fd7565649c2420a75415ec3250b66d4d47184186dcd073823568fea51a51b085de06dea69fe726606e49c43dbbf9551af720e331501f09ece47be179dd5059ffbfc9d24add2291cb50bd8b6f3fb73760c86d58e6eafaaed543f2aedbd7316f0a77fb3a745045e4edaca24716893b89443387bc1bd38ea732150c6ce4507707397b2ba6bd458a6cac97a8d84105d023444be39cf64ac9059316f4d41d4b927f135c2fc0ad23e80b299c6d6bc86dc620c40f4596fe1110e7b380beb7a27e126ee436cf058d69520455d7a98c19ce0289108e4cf4379d6ae840b1806a70da0326fe64ee2884d6047946cdf6a8d20804d4782c79afb1a24f642c53054ce92a337838b2644163d5615090d3f4aafbaa638a8c7b161befaf767975fb0225758b08454ae9c73869f34c9f514b36d9c0fd23927280f49f42e049f43b57b7b92ee8ca4a319895a77d84cac7798b1777c40d73b8267d06b6888a25454600a5d5e21c305671f51505e169fa1f3fc2251425772175a2ce5d3263c8f7d7f0d4eb952c0954f06661c54a8956b16524f3dad6ffad9a65e80c22adc7f98f3f12b9ce8dcd20692caee69182fe3993a8b6ccf0ecf438fe11913e9d18709ba4afe79d27b1f12e439737f0e2a079150e40a87d85140560f93a6f288d2bc67216db74dda56be8ae6c1da6a3dc7c5e1d84c2cb7d6555fdf31f918b70def60c0d2633573a6a556266fd3f80632d2901ffe134839b6064f05a335759bca8916647ac0a350b2a7ec4ac2f8c0926df21c4939f419af489fe8cd95b0816f9937cd0008f02dcf931f4529de4002649cb060d94fad62e36369af3f531856568c3f079695e9b3cd11617100166d0be2a70df5b187d7adf4a7c3b823d841621ac63904c572eb9e008e9e2e0062eb426257ec3e97b5782cb903205e828a6d675de63a08d3b518d087f8ee033f9c69c24f6569d89201fd828fa5df5fab6d89c3b580467940661b627b38dff874427e8fe8699ea3c23b49f764ce2bc4385bf71715943a558e74f82f3fb49c79f02a864b6dcfc209666fe94a30e4d522a6da828bf247bcc0f6fec9d69303bc48586520b0bef22ec0759312bd4d7198eaa509e480a17247e928a45d2d8a752693eb5cd3063b847920736a3284e9a01a1dfcd7356b7dec208231a140c1079a3b80a8ad8058edab226c95c5606838ab3c45f4889cf70e6b88097af9d2169d1e8c51aa029963561c9c1a40938fe0e211ec0b254aa8e3e58efc0da22003fb5a9d2e912fa36f23d81ed6dcb88e5191aaa674b517c6968f00e0375171f30642b53a75ee9ef241ccdd2c0366a891a58b62abdc94dabbe7ef1af219f614b054dcc53622a0cace231252fa698496ef8914ea77b3e2d701a2b18bf4b6f7e5e18181a8921d8ba3857f51a72dc577e83eb0ea4f38560f631b01744a2fa1d58e07e4be94580e1698927f9c1f8503a756d59cc82e50df7152bf29706807b5fc4585e452e9d9a5aaf57ddeeec48e335660dd8378cd760704f5943d7a39fd50df4242b98631bf0010087dcbca51ebc0a914f3a69cbf7f05d49c8c5eaecccb6a911ebaa9f614014dca7a53f451fb70b4a477276c7ae4652d63edb680b4baae74e2f4ffc562b6d28e99c2c0d83433fa41f4e10c330c55cd075878fd448a22391d55de8f1a9262ca0e678848e773fe77d3c223620db8d63aa0c29e9bc82a17535921b7ff6d85fbcedf626f6e9e17a0c63ef884d70660226e3c0c6b889a9f39d351185fbe41c237bf31802db7d593a8780e862464c0efc24e08634204e61b28308566e0fe60b57ba9ea0b1e0215bc2c99517ade37dba945bc8830a5101ac41001881976c5b6a622733260953f22eb634511f98deaea328dd8c27682618b27d91f88e732fb2a9bbd41142796f51c53131b302b9eb8552e5d92f1734fc7cbaf9c1fca26f4e5d718b416b8b38e227bdd0dd21aed63f1eccb704a433087589c2f9fe64e3cd34f6dc9875a4eeb07af632540ef778ad278fb555496e142bf501685988bb316a640680c5a1748f34ba183c52c8501aa2940848fcf537642adbe006828460fd7db64861456f30c62a826e751796c8d65ca214cc066021425d71e58e51bcb8ad49aeaa1af2a006d3fbfd81385cf883751304fb10e9f2667601db3f9f9a43b16947250443020443835f2926121492fcab54ed2e5524378f7c6be232c3716cacb39c1cca727eaa865ea67e293ff198bf21098fff9b32eaf9a62745f895762264ce2dc1ffabe850adafad736fa9d39397a0129bfa15e5c2e280be271aa9c5835873a7ac9a743c0cba6c02630916a19d78549fb96059f44ba26f1f53a0f2644af10953c4c485d0eb8040b2deaee5e444696cfc526982d4d8cb1d845245393eec7b532cd042998d2256688c1b48fa2aa1488b57e9a5352d9939edc2012100dccaa7fd214c6e82ca268c62e0f3924afadef1b879e386c6a89d2cd0ec782c314de9e71f09583af6ff3b3e3d679847a8c068e5b5fc5fb80c26cc42e2cc6c42df857af6c84b09f6229e42cc22f10f8a9efec286c7e4d48a66b26a49ed7be9c024dbb55c536e999b638c93defd1204012c723ca4ef19925bd7d664c989de905371c46ce87308ac08e7f84af7b6d376e5ef19facd7c5052c26601a549f5fe9a5bbd81818bfb6693761e70ae6e27f62ebbf7ac29ea3a1891082065d6f1dbb5fc4e20ab51a6d2cf115a163c50bfb8483b9dc473a6c0f94d49bba8645c8afbaa4c7476586e97e0f279a5ebeaad6c12d4b2a8f3521ac84a5afa5afcc910e5bfd0d5c86e238e5dd00572612b82a82c31169af428250ad22973a9f517f3097030bf06a5f198e50bb82e6e0c31c234fa4be7c2e2658fa19545b854991dbc77887a18d26fcdca915a7a00903e8c266bdcf2c9a3c455640e6664b1eff97b64614234c88fe708cded7fb5c453cc2f42e7f35b70472655865e83f0049597a46d496610662206ae4c6e885146854ad6cffe3cf14ba5ec1448d08e7ed853c2111541d4624b62d946d5471a76a77ca415ccb3a65454a3964d08771f1ae0e3b4ab16f30580646c3afbc38e332c407714c04e0258cc0dc6fa6d0c676b6d5e702f0ad6d2812dc393464002366e7b51b2227ea387ebe14f6e4f18e79c08d431674fd2f632ae8a481b8963c5d5f5c3d497599f4014116b51a343c5b2102653698398aa92fc98143ddec34003fba5da6ae391935b1d37f15c5eedf2d41bc176b45931c92d9a49b8909537630974afbd797571fe162cd9d6aa4dc4612433668b48d8ef9474fe3aedc9a39e43dbf290d658bc44fe5e619019e7daf2d3152d077d92d37a0eaa7b56d953ea3eba64ffd7e82fd17b9d9de656c1b57fb2730948894ec1f841a4dbd1d6992d6ad984dbc47ba91eeec3d6fd00aea8f775cdf99d569d001f0df88866632f648d031291ecc468e17b2549d4419ddf5275696d1abacd556bf992e568e4325430a2b155e107ea6ad2f28f16cc40746754ee78370b72212f3c7479a4dad0e847940ea461a675eb6577a6a0e7971faa3312aa9c3e1286c7ba36e3d58c38a45edd224590c65cffe68d6b319e4b527a0d0ad2b4afc0b94a18d06a6a22c5170cf5c99da290cccce1e086d3f112819910af5008ba6ce6a928d8d68e8c91438f733209fcaee413b9a39fe43226424ea0671a340a2d5d996acc86ffc6713ba7ad548e0edca3615d06dc08472c28cf7251a2761438f7c497175f02fb4743bbecf9cf569094f5b0588e43b3bb68811366525cb2eedf3551684e811f376e571ded18c9b5bf5ead6b8f2d04dfd659ecdb520c845a516c96b0ec5f91f4ef1d69689c862c0cfa71076593cdf8575332fbb8a8f481824980c95ccc45cb394b959a9b91d3c874f2bd106b9885d279c7158c36728af9986e18fdd8c3830a4e7fcd9a94b446b5c7f8b36364e0cd9ac809f9eed64aeb5187aeef17050dbdb94939901dc6796e4ad0dd8e57e44ea4ea927c4c7bbec6ff800addbd3c05898c1c2515fa630002c565aaf8163cec3fe9b395c6696e28474d70e33a8c4105c034befdeb89eee65bae92675712c4fe13c385011a7638cbe6ad44f7678a98b38b1d7b885467b330faf5b82a4a0e71d7f3936cfc21efa7d52ca3284c011d7ee7ea73f23a8a322997047b6a2d3dd5654d4ddf53289bd6ff66be0b400b4f5a30b9a5ef3e2ab82c4a0aba91f5d0b496b465de8c5facf7d864849fa7401a381a01a1541b468f21c9af44171f03017e423d6879ef3bbee4f6160430cc53ade2b8260b2834104823972574795b9afcb734461dc73008c46a30e38296b1ab3bc52920edb348d9b6505182d4b546e0a3d83bba2bff20f9b26d9c41410df57cb8ab1d6eec7cd5e3642bc6333667bcc41c7692f6176f3d30bc198cc148862b44281711e24b13cf2890fcaae537764f9a5f48b2c721f7b55a9f3d8ad33bf56fda074cfc28f692f163161381eb114691650dc97930350f215bfd9119e541a6a6e3a3f35f469ea30c90175e280796ef1304967e05d3137706bd9e24c3baead7dc8973e2def621709b0f209445e1ca4b7ce310297bdfdcdc4c3ecdda53003d72004f990a9372a42a65d5daa73a8c0b5d6f897a4a26cdeb5bc3c98ac3bf61ad52e5f42e26bbc529501989f408bbdfc2e95c637d0fced70119521d3dc3d94d0ae7b4cc90fc5971429f64a9c931749f7637d3f755faa41939306a9728e84c7a0db5e9cc246296375d090dacceb6b9550bc418d788ae63d25ade2ff4861684ab2a9ad27ede09e77dd41cd510a45aa63e8feb6b0d90e4cfd4970513ff83fd55ac8a5a2bd17b908b386d375dc2c1a6fdbe4ab351cc7a7b1592f22b6f54b8d5f2fa6bc46eb78736a6818d083c410fe442724d95fff37a29ad66f397d0ac94752ff6d9368dbad255de7f29a8518ef5d22c541ddef0ef455b54537caadba54a143067450eab2934fc06318eca3661c2aace5c23edd99fb66f92748a233355aaab8372029e7ecf1f952ecb03c31c052f43d1ca48d9f26fa5eb663fa0944e3795f364bf2e3e940dc15d8988eef64b1f9f71487988277eeaa1597a91871a2892c7c10fa1505462d48ce765c1481dfb213a0f6e6933ec512b7c6909fd04f5816d32925462ef830704956be22e2e467668d75b2bbc895d150f0c4c8bfb51ef4741acce34760acd2014f3cf4d89cb0c6d448c56ed15ba9e8a181826715cf01c4411816251f46873fc6b25fa59f7360ffa90ce4284c0ed41bdcc0a554bd4b4a38f95d370dd8fbc3eeee847fbdd0cc70b40fc95c71eea8976b67942de630093192763931e6b3222df5f57ba205d231301575e0ccae3c9a325908aa91fd6a9bdbfaa17caaad5799a51b791b6b70249e7d039cea3c2ce541ccbe5ab702fc2a24454b0718316593a951c8b4e43ae0c2425f773eb78b1137ccb9f3b9bd7554d655a5d6d34b5546939fdbb151131653e09163a418d7fcfdedf607f060b914190ec183b03398133dfab67b7a7d493ad775692ea0606c0a8ca8ab109a5bd50fa1cb30b81fbb3f1227c9ac861203092ce8f0a0de5f8ebc4602ff36d91cce774b204b39d481de77bfe134778b13c8289825a58c074e6c0fd7c79cd278281bcbe08d88c2cace02325de315646c7d7a424cc7ddb0dc90fe148749afd63fdb18d2e9e34720c5d28e562b7d4f8cc162db8726d663c0b78e6cf9973cbb622c12dcda4c025a5dc0b5bfa8e5582ff21274c35fc2b432fa1512483b921b6995d4fb5beeaedf5ee9c1ed724bf03abf607d1f91261960fe5dac51ee8fdd1d82f8781b3ecd53bf659bbcae9f5e1cc74b1eb1c61f76486464844882d14f385a810cb7ebdf8d545961042d6369a118b1cdfba44689f6bbebfbc70646199eccaa8cd845b9b8d9d08326a94b8183c34c1e25f1b6e3638c51090d6bacef6b55a7a06171b1ac392188b76e2c5630af0162eb6cc93c5e0253d123b74db6c7fb82609233442290067d9ebb5fb325c3b6d6776907957ad6d2f684313f0d94e8e6bf35b7a257b8ecbf3ed8633700f556851f17f3484b1da38f89928c6944ec37c11769f3cbe16151b9cca38ea6091df2151e83d3c93a51eb9293235ee86dc54862a4235727fbb80b875667f7deadb528541fe85313fa93eb9c293dcd4f606049f617610f93ebe21bef08965a98be37a99aa358a1a16dac1c58d4b0772989d30628187c8d5b0fdb177d5f2f5ab7d11a758e6572b8841262f32c82fed1e3f4ecc8301dfbd35c477a7ab3867b47d847c05557ee8f6f41c75eee2e232efe5e2efe559b389f4d735af68e1518fbf9bf1c4b7eb7f061536c1d11544cffc9517f31759716af2ea730f4f3ffa130a9ee6abf73bad3df3990ca75e02db1358829579d24400a01f5d32ed94449b8eea0f928b7ff16afa4bdf010eec2eab2dfd4e5bb587f7a4c538191156d0144493e815fd897bdd04d4ca9a6939fae54ef344e808f7f7f77dca6aef839384dd01947c446e95c9bd1258d91627c10deb1319f5f3dfbb288c90fe4dcca09bfb7946e56c689386d78b179e93dbdd7eea3e8b780e621ba6b03bf53c7e79821f2a5663170f3c2b5c7d9ef2f11afd8e13b757eb78ab91bc06b8d314181f2e25fbea2fb6b0a4e5b17b7941108f8f38a954735bec3612fbeafafe693b3c942fd0cc0cb724e9dd60f626dbea8160ee553397a4342d9a338e9a4f271343a798f65ae52b56a12fe6d7bcf7cac92fd80457ad40f14ea6e25feebb0bed53a544a6d42864fc22711e2fb88a72367a06c28411bbff0f96015993e1a37d09d9ae7fd28ceba905ac15b08d5bd74dc64cd1948f24a98773df8f229cb5ca62d2b5b6169fe61c583ee8ef4de3f09c274b110352d06bfd2d2212781ac3c3bf2056a47b70661ee611a1cc02a62994aadb1eb1b40d1ade12593c43058880ffddb8d989275e6ad0a7df12c0782a703f65cf5be3b56260b76d833f3e2c7b199e30ed11adaedb4a5444115aa58574d5cd1ae75e972515d96be544d905004b9f05c57f451ae50b5165547e84a0aac3d7615b1dc0a8a16bd345d7a656cfc76eae7a7f0d413278bf4f3e6b5e7062e0323a79d88597030973fa51cecdf2894341591234396bdee4c46d49a4729008c6f58938aeca8bcbb33fad52ccb53c87f15b29c85008089d251465e3f3dae17bcbdd3236ca9efee13cbc06edced7f4c81754b993b952dfd42e999c028311ddceba4b8175385870531cca34c05ee1f6c26d2a27ec7eea72d1a26c7ed1fee6b65c6c17b3a4127b8cf61fb0068856138c51c816057e0f1f0037405979276cdb0720e85860052488a8276db950428d64780eb2b1f46f30fc7ae7a3513af9aa9d86f396546ecc6c601fb35b7548a69ef10e5163770d97dafb7a10661c92dcff7fcd669f597bd795aff12eaccc35d74af863b4dea049d3fbb84b5f0c78ecba127b8d7a233f5bb3ed47a40101937d4be033178a5d29d00659930c8480cfc4bd8cdf9bddf0a09511806e0a648a4662702051183a2355015baf408e2e91b3192990fcaa7ab8eda82c5d757aa0ec3251dd002871400d695ae38c935d217d215e63e2f95b77b89dad64d7aeae11ca84b72db0de7bb0bac5d423bc5ea53dcfe6a3d953c9e7efbf25e097ef5cbe8f8ffcf9cd8926fe60c5ce1061584128b3436f81f01c5a7f776c28f341517af0025417f4e6b04f6fb3b2da13e6af6a77d7ec422b2b764d1f4ae1b161f397b71337d6e57bedf056c93eaf79b85741dde2715fe0ead49295954d78e2df2b0e73389896723842dafde7d0e12ee291c17f43e03a623e923020e9f8ec618f12af98dd577d38fae86fc747656463b635bb10411d43fff0d5defc3b098cb97932177cff2690fbd58bdd399d0130afbc9694ad0ff388463515379b85a47f52a226eb0aa866d05a3772329f73d7eca8b3a06ab12763e5b490a3f00d846c32b7043be0a559875657f74ef1fdc5ae1fd21e2f93f0ebe26ba6bc019369155091275d3b53fb0e75136c32f875e7778c9c94f137afc1fce20822d7d48bf48fdc049f87c1cc90b626330c9a30ea2cd0dd400e3c75fe59578bcd46061e6b166d073014f1610fa3ec4150c3d2a01a3035b7e6f6de57b2e3920688bcab7030ba4bbba4952b7223d18d6300d98f00c35224b374967c970734ce38b6ad1fa7693ee27ffa9a0c4ee4a3fbd7ab602e6026c13d5a728f316c27f00705a97c1e6d3e7825a6864afac5c8b1742341e5292dd352bb4ff4b5ea18f37121fe60734778404cdeb923608ef0b5c459c2bf18593f1bd0ec9b8d08c4fcda106ebf2f553d5ee40d763116cb3522a4dc7099ccafcc26a4e8333be075753211d4c6c32573c627556722e20459779fa42a699ba0fc23359db9a444498ec585150632cb8500afb0c99bcf425320326047c64e03797ffaa856271042b88ea3baf9fbf41c5dbd2091a908160d71e2e069a011bbca4a0c4dc9b027a6ca93ea619cbff0d98b9b14abbc5b808cd14b91927d6f7de20c91be677b62803f35b5d38411a56ad17984f429065808b121d90892ffa183c1e8a3634faa6515b39e58d86a5574fcf9e939053b070afba7daf0368384f75f443eb877ac901e1fdb5a12187953a2b6ef76c0852bd0914d8572f8ad2e49c52971bfb83fd4e3af62afc68b0d35bf377981ed0e4575b2221f78c5f7205a49c48e399100cb4b95ffbc4f4310ba78ea0ec44b7bcae7546c6862bb83bbacd09c0c8a7b755c39c1d40ca8109d156831d24f7397c68627b7130bbd3bada7e177d21484c2b11908ba3b25da3fdfa08fa7622ebf31485f925970e63764f76ef8eb815678f6395285922256a9ca51e59e5fff81065dd2256b864914f1ba6437780d90f477dcec7f231becec558d6621a50d9c9f2a20482853f0c1b8bbd4eecffbeb07289ef435cb69161612cff07836f8ac479d6bc91641341adfe3c641b824d4842104efec1903b2e4701582b447080ee8f8bd42b0e2ded7be0db5c50f42c43f25843b90fda25b8194036ea41adc056ed8eb0819f699fe061dcf0bd7e9a53e5b181ac2104cd281c067558fb2937bbd3792437fd12db1cc03b0464edd3826e3a5d2db50756539e477107eb21e84c33aed3aa109d4f05cce3e4fa809d6422a85ee8a88fd2a37ea2ee86e48d6499dc16b6beb44d7a22b05ef25e39bad77aef515abc4467c66b06fbfef1739ccd88e0f3ba449775148861132e1d464ff0d54e183081f94a5921b7be962208daf5b6756f3578ab84960d3f6289577c6f3d2109df706f8ef36d5fc4864b910bb67ea81c88e71fea90cc37e701550a6de07e511c97ae1dd96c4d56a38fdd851831dfbd1232583711c149a0458dc6dd4381223185f04f35685ff0046f510111a9838a02cc3d530d9bb87a5bb36140e3c6aca31c6940c3509d44cc23208c10565c0b1fea34507170c8a4c10770ad79d3dfa5cb1b8a068770a2ac8d04ee1c469ced758a72cbc7a131fbd6d83db2a834891aade559704f3a0e0e6681a0dc2935956d494bd27aecbb77966607137c3ce58c709c838c39dfbe4351ae12d19143ba404cad143e6d4f326ed87dfc9fa16c11058ea24f8cbc24f842b54289cdc0f207d577caa3143c87e94c87e14ded2d11812a015255ee29d910d557d1e430d864a8fa60260543a43d45821642e0bb81f5156080cd5d2af48e31ad74626cfe0d2f576531d3f8fce89b8c10ba0c561782c967caaf89c74db810add55784f09726bd23c2c8fc6504e5dbbc0f08565024d354f51320a6b7d0407649cf957f1bc91c82c10e52384fcab7ab371cd52188facdc5726be87c8c52cdf4c57e1ab421c32b68815683557a6c463947aa67d43773d30286734b67c3ed45a63f6d8ec7735f0e470e14acb0b2016e3de0a77f98dbf3ce7ff51f4efe746f0484d916074dcffa848c4fec92f14846501ec5c513968f5c71248edbcde47a645e7d584e7c9fd7fd400365bd0a4780e430238e5b6b8ac25c2fa9294e7ee9c2628c50b9a60117053eed67d602a27b30bf1613bc7927e4331c3e3ffbaf508273b777302f3927f672d5bf74c5afe849f3bc3142fd0dbfcdbb9b3289c2375333c12723094ee5b8b3d6e52632e54b3f4825b8eeb3e63e669864107978edf55aa12ed787f2616eb7bb4799c695e9ea60ff3beb8717f6e386ce6dd2ebe40db83d04b84afbd49fb44f6c708b637f6c7b8253372d246613dc51d6547d1079d0507112f28b1c5f5de2ffab7a9f763f75beac6e5618a6bd84969c915280d003970b3d3c0537b54b54e1f45c9d7ba47f37a56d6f377b4a5f97fcb9199b1d280a508ccecef38eda5d4499217e2ef713c82eb9df3be1095516fb426b8c82b00048e28e2b18de8e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
