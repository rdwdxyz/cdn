<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"900a6363cb18c27672d0e2cab3154a4f1b43cc2e07616d79d6537cd8b3f35ebaca0f6e9886790151dc8453783dfcc140a854e440ed2057d30e62795dba5329ba58b823a005d5ffb6abf0c253896b5b37ac58b6c78c02ee719f52371c221cdb647e52a4813833646d671af6deda433a0112a377d6b1f58116879a67dd40aa577d0f7b325bdea36c1159704af7937f40589f45ea73c37f13fdd977d6b3d0c3e76ffccdd8b7f37f801c174fabc0cb1895fa93483da5ae7e6cd5227a8d40e865fbf6a0780adfd74ff4b65c03dd5e21b7ff283130a29b5283ffb96bde7e46e4f8dee2330166dbd760def80f1d3933f8320e868613081e5c70be3dde00d6b88eaf0d064f3ec37ceebaf678821b93d1c270254ea71bf657147f2cc29ed9252fd103d704f0c2b93a07e6b720be1f2088981787bc0673def76636c337a2bae01a38e1f84b54ebae73c63bd5a0900220447eed559078be18f11b4d26a1bddbb94e1d6cefa8b38b14a441dbd877fb191f8f8031b8b4d55219071edd258f834df850e9557c58d365cfa3ef8f1fd823e9ee71bcbf269d37e89e187709ca64e11ff8e2ac01a0dd517a52ebe25d162280fa3fe3bdab977357a9bb91fe8c3447b470720d77901c8052c606be29f55188394a3522197b928a81bc7babc29bd2d84ccec16d5d6f6c8b1b3ef6e506ae96d823802c282543313ff6b29ca1001eab15c5182da5ee8ba41447fc6dcbc53dbdc0440d232678372ce087628751f851d9c9b9a534c4f713cabae603174517a34c387bcc7b16e9a0fa6159e95e707135a0745610a25e78b046d3b32f1fc3bd83ff187a71524c15a7affcfc82b47ad09e911e1f23699c750b5e4a86f470b18a171737256e50d1c1b71512f6d40f5a392c106526e0897c2b3ff1e9100aabecac8a4359afec62f75ea02b37d25c0ad455785981b48277c3fa772e5cf289604dc99a1b37156d27918545d7768453634510815de1f52d31dd2c793ebfb77e072465d08577756e968234cc470c9dc6d0d789b700ef9ab18390cfeef0a43fac5494e0cd2b8098694e68793e2039e5561f228643ee101a11c9f643a1f134d5242293a75a54047d2f6078495e401ac34262e89fcef93adeb90a6ce48d07703b326ebd49b3532c95fdfaf72be5478c9aef9d04a354d735879af70b880847a80a6d737850101cdeffe63f5aaa60a120eea8f943c6577600342badac7a62dc3305e627de987251f3608ee6cf3bbc915f0011b9f8d95b8644d442866b6d04d9c5334f9d09a18f042646cb6537e41b140bc09ed1aee53d64892589689757a4adc59a76636c8f6b376997869f31e4035c4da241030efc30e3498e58dc3ef31bec6c1cb8f118a25a8f69da92c4d52d3ad907a52728280ed1b51712ace9531a0730a93e8671804993bb89513a94197ad71f3c45bb7c935fe50a1a7b49388aa48e945c53bdb2ada47656ddda903efa1d78ebdf7685bdcd020abba53052d2f63e9094cfd8446ebfc695b49090392f439ba8e7a3e99c3fbbc3be34106cb8b794e4333cfa102dbb0c4c167ec2636f52542b8bfbd14170c09a996297dea6d5b7b3cf0b87a5572e48fe3adbd260e02c9a3bcdd23309eb8639d6241f92493f9bd3ed3b7aba4347bbb88a01df5ae83857275fd2e1ca2ad3e3448e577ae96be0ae7285d51e991a1da9ee21368c663bd4e406fa5cf77b821ed07e6dd3eb75f71bc787cda0e73e44820cbc8a9372308ef7ac4ac8dc41e78ff4b04bc3e74f667920637b4c25dcfb7a4f1040608d2566d5f3050dc8f8b89533dc9cad5691d3ce52f85c5ba1837d9a7262c3516aeb679210f2a966cb87c0c5881b11e5fae23adeac162a52ed3ca9c7bc400cb651be5634a0f674dc029479b95f77bac1af6627691d5f0cea8e1c7daaf076fe1c2cd1a7745a093326c89834a1cc2bd602a7744fe4064f738924f901325c27551cd3ffea57b3205286b2752278d93ac9c364f65ba75eeff8e48279774f4716870dd59293789ac4a0abc7f451d209f1d5eb2530769650c2b4730a25e6a19deda293f51eb2fe0fe8cb7d0477b12539538b91dece114d6a886063406fc4e108cb6d4949bd1c165e65549d90d0e27ddb7d05ac14da81f47472832e87a407746663efeecb8eac7b6ed1e099326725a54be9628376f0378c5013e176480cff581f0d15bee444c6d5249c6636516f41698468bdba09998ebaca4ef0795f91105c7e2f82dc80809ec44966d5435d5d32d959082e53814af828eca4fea068f3a5f43b21fa28878ba93a4089f96d01c60056d182a6c63309a7cd5390ccbe45bfee60c2a14932c2efda160e260fbd27a377a269f87de97d7477131920153aa613e9516b389cbc674de3d08d17ed13900c2d885b494867316767c563c9622519df0a5a8d555894c318bf28c32ace63f2660a09ef42bf07f0c58bfeb3c01c245d392639c5bba0558e43b5e32faee6e0ca3bff8ee19ad97aeac01a1c5e8b2bb773baaa8d235cabbce55d1d43dccf6d2db811c928387bffc3801347b18e136f7deeb1a3b07117d69ab5ea35293533ddda2dad6e118a1424ef4127e4f85f8c2ba75d8ece6391ba02bbc855900196c3de2f6faeffce1cec10d1ee386aa201ce7c24bb4000dbe1b484bb8ba1316cb2f9c25697a2a81b22f8466675e0d813a92f2d78cb5f448eaf2b67e9cf118162e9c53ecacfe375c10627e018b39865c4267023cb817b0896066cf1dbc3aaf2d684b2aa40df2cdd8f16734ac0db45395ecb5e558643892d7740e1b00ba942946dfdc0791f78e7f947c933681f027ff1f18f351fcd69ba67aadfd6376a478ab94a90e3b7faf2f39eeb4c22fc720574d96af0192a09f4f38528131ea9efa9cb619fa1ded7aefa6077766d0511c04b9cceb3e3cace7833f7a6c2708c73c4dae75d057fc89e182d9e5a0385db3474fef4ecc2515b1fe615c9d7605418a1fd3176f3ef99ac2ce3e14871c6bd3be4a555bd3f53fef5563dd871ec4461ad81ee6fe60b8070ebca30289f7298a9849896a7d58a5eb4ff137264cffd3c19009a7474a88835217919ea0ee5ec7b6981f892fb053ca498de36e46d3abd899c714701f79976208e17f1558d426fab16572b9f487ba2499cca72a61f251a4978d43af58ea8aca1f1ca9e767dc00c9a08d5220f2f199e8d55de0f510130e2e1b90e76fb314796190c443e507dece9e31233fe3de0e6e2e964661654c9f4166b6658ae4b34e50711c06b6230ec34ee6ed2eb9b6a2c4ad041394c6d24771cb9b1caf14a841a99e5c6c8202fa84afa3282fbc9425a8908cbcedeafc1c1e00d97068b26725984f8dc249930568a5d0125245270e02a8773348dda7d054c77a791d394435ce3740b6bdf31bb37a30095bdba14b1bfd50660db503814299b25dc5a520748d211543fc76fdfa7c0846e4a5739ea6ddd9d4c3da89908b57bd9fea6e36727612b7f18347c80fde5cf07de66515459a8468c5ba5a905ae94a2f3b267b69f88c1bd476aab827b92905a85914738aed3bb1f067387ab8cec379359d98917abb616be9240aee05654ee65bc97632e0dc0d7353568f7c9c3d9f0b18d1605654c28932f8f1fca12635a5f4fd2afa4e4715ce115663fb2ff74ae561b8a296f8887d97cc7af6348408e78b27d41d58b401ded05ea2ad1d4cfcf5f73ad4ded02759ab1b500c959a796dcf3b805921607f26d20a1b2d5cb88748d9f449d17420f094c4f3a2fb6928ff77bebc6c3aec28116e69ad828ca08ee394b4cc8c8a157c8df5149948ac9d3fe4d357dbf8070379dd1dde6f1a97d1ab2485de2a4e94d487b81d5b0e453534221c7c210ef1d9ccd49f61191062d91d5a851104954dd1253f5902ea55ff4b2748d2955acf0c5ca2291bee3d211cbe177d5a1e0867dd058e2e385762648b400690aef2843805c25f69015658d82de7a1491eafbd9775ebcb717c035958f7a79e9699db29b5109bf338aa44814fcab198939dc7d9561e5b81a5e8942363ef806f6eb82905a53a96d88beadeec8bde58bf58a7c0963ecd6f197a7c3b3c1d56c9e16e48f37f3ab815bc442277c4fc7c5abea179ce0e4c73f8d6f2961e5148d0061d9820afca874b9fc2cbba62cbe6846256c299d2d7f0033115f5e474eee9498be50d77214134f517a35dc9fdb4f3449c62637206065284bd5ce4996fa818496408851d6e35e87e12b76205b00762f60072b2285f7b3d94ca5e9313a6100954a7ca1ec6d7c45cb99fea8b2216a2d86097450575c4f328024b8663464dae0e7be74c93081c380cb630717269cd95975e6282136ffa2115521cce474717c20d3228d40494a2ae40efffad31e17b2624bcfe7c27ac3feb3f2a8f2a3d8f426d854bc36c0dd9e81735f9d35a290e58eb352d6a05e39c284c88634cc082dbfc0d37336f30d300bde9336e25ea32fc1f4a8d51e243bd1c2a224636d8cd9590797a710939a1748b86edf8c73f6e9f7cfc9d536ccbe8b3952db865d0ecbea523821c3054080707509dca0fa2026fa14f2fffb5018430abda912cbef07531047ed96e519edd7bf7054873c9b612b6468f1106bdbe36d53e123e3567faa7e7c3b30f986ae20c15a25b2fdd136ea67c4fbc067fc3c13d3e870ca3c5097350dd7e226b71a2507ba86e9b9987b6ae9b5cfad0fdda0976273770f23d17f3c1804cfc5d49beb8eb78ef9b36168b2e317538078233f76d21df3810e5236b3576af61a905722872d6022821ce6d1fa5a3c6a867b921826546904e1502edc4670f776785a3ced5d7b07d5dbcffdcbfe15d19e63bca083d90318c9811cd5b55afb20c5f7a928477c1dd7c7181f109b44f00451fb09593022522516a5b4ca6268d5c42a6e78ff386657128dd3a9bfb396345ec53cb8be7aceaf9e21964fc30e7192ae3b2f743b280868903ed7c28728fe95d3cfaf4c20d60ec00cc412c3bfb3da3abc8a6c07388f2f6f7a8aa7bf04fb0262197e403fc035cd4176cc2f426141571b9c95a0bb1e1f89b84fd9ee40e56b9cc2ae7f32a10d3ebb8b0e7c2648bf3856904dca93d0e1dc81a8ccd4a8e3949ca1a7c3edca7d52db2d2e47af7bf26b2a6a772808d97eaa1a7022ef871749693a3014134b5beee97319b27b0bea800456ba0b6c2f1997215d7c2256398f31f9457bc05a772f19999b9a2d9c9e60d9d21fee9bc4931308be8298dd79425ea649a88a590ac5c2a3a86fdd4da2f3e37f84273f411903ddc6e705039c3ac4f83b83a30944a924d3a504592c4bfafbfbb2d98e884f729d1d3447db2498aaea09999336d0f4005f9ff195590fcba676ac178dc09e30026cdb9ff192d34f66bd65bfd8e77f0a79d37d139e7102c872d208316bb94cd92115abe34f653bd7421c3e318516b2d5e3ad8cf4731b717f63b1c052f42ea2760531515a5aef09b183325e4efa0abeb10cfc3911791c57452fa8e94e11055713244864f52be43539ffa0815b0fdfbad5d1327f87d3f2d8fb8f1846d877715963c1f229a08186a11323a970cb39e92cac36aa27c812f22e107693532db352bb48a2a948805290957b78977bf35ae12309544550d629393747105fdc7a560bbc1c7fbbd238004bf4c716fadb6c111a6bef4242af8eaf1f20651e0dad04da70e50bc479c523ad079436714c5a2a0b2d7c59ba426f0fd39c045f945e21b70835e09e1ee603abd127dc1aa7a0f97f0ffa5b60447a1127e5dbd0da92bdadb23c2b511dedfe990cc71701602e79cc2ef571e1e93a16d2188a0202d3a16fa50bdffed25a937489f366c5cbc7ce8bde7e256faba0929c63efa97a4a228e3ea685e9da579218ea066a43b871ae038e65317c3fbf1faa110203d5f46227395dc6355809156e76a99ba2182f88a5795f4698752f40ff3afec51b73d34fb038166aef8aa521ccd901ce5c96d248c7e422bd93d9b7553cb985d15c2213d1a0b1944d321afdf8aa2dbf5cc6d97eddd2b26a611eb98b86844066d3ad2b212849288fce84b310285e273b2aa79c1b2942a5b596fe9c2f4c6b81949d847cdcd8dce82df71831194dd161342abca05ffa2476710a028eefdd4009f59b6cd4aa595fe51e23cab5cb68cea4bac52af98d3c424e4f2ad757f4b122639edc2766a3bdd5b9330f5bfbd7a0a65c81d4b2f48913187cdb4a005b70a27ee187e9855d35d38c1a5e3b5ff144abc50d93bbf45f0c7b8f25aa0147599328187786c7e7c13b75a63d1a522571c6842f53062886b06787d8affdd40930dee0474cfc8a32236fa51fdcbac62678ef08db6e730fa98f9b5d405c16a06a5797f193a4f12d8d1fd0c42c059e7fc9e3960adac4cfa18a60c580fd58ea4c4424628fda69f4e0775c238ec93ae856ae48ed3277d51ada34e096f485e95b39ebbbabd2921a9bdf5d340d3036652b2567ccb08d7054e32d8305d374dc02183d7c184206a96e806d87b713776a70863d9fa0444fc703f577aee86c5d4434e768ebbc5eb775561c67cc3c2f042812b5f2ef153ab9e60aac65e2a6d2c127a6a942182c5edb84440f11c55c9d20f41b4d2edaef52d5cb7ab680650d7e802e688b3da4481a141244e02c63f7f6ae8ea122b077c969a72baa7317f8846f2a1b9532859a568e43a847ebfd5649c9d52c7770d646a19612d92bc8482da4f619d5250a5a156e68c205ab768eaf443b36316db12b99d0fa8294e2bcacef501c25c990041f9a499bab56a5cec22abf1a4a3ec8d86d603b4b43588c56aeaf2d73e620c469384a3345785451674d11aaabfa697d07e61f6f963cad99daf2fbf72710f46386ccedb0a800524c7e86403d71dc5c15e74ad0bde06539ccf179e91c5e3eb54e1a45fa4b6e5846413c5a2fb0bf13bc0cb0aabb8d92f7e37273dce19e8373266af8b78b5877ac7bde5b27ddc12962a21be60db0a3223f37e1703692ecd3b78d922e834bccc3ea7042902357ae8dbf66248c2550ad384ad34f51082e47a572132414a34fc310127bea32f1e10c8b0a5895990ef90ef95d5ccde2d7d41ef9ceeafcf39f9e4d76e8d4f3730eda1b67dfbdcf5e115de06afe64b6eda3b9e93fb6dbb9b5863de8c70d2898eef58e5a41388f7596ee88ce31015fcf9f17cdc8bdf1acecc753fcff678a51cfd3f2cfdb601152aca2abe33507c575f5679339d7079e65155bf002077868315d8b22f8a547ba68ceee9b8787bd14cd8ec7a0f3bf33fcd94675dc253c59fdf06c76ef832c1c1a2f87c902853cdb173520065f851ce01c3200cb4ea7cc35b2cb47231966cee77ad17eedca285586dd60327ff83b61941c31d10280a923a6294ccc3f6d246a6ed85e7ebffc5fe83da497c9cc0b34ce82ce7296cc6db2397a80a559a033d919fac1ea43549298b08087e3009a203469e4fd8a1142cbf5f3a509eb892c3fa981e66bec85e1f76e3164abb5305bb52baf3d588555e269f4ee97a14665160ddfd4be0855e62c7f1b1cda6633a1d48f912df6c958c8afaaa7958a6cdc192c31f574b9bf3850e805a7b60ef86f2697eb193b9857cac7d8208756bedd2fa65cf86668370429f0caec75a7e0b6070aa4f48628cc53ee58e9c89050152f671298f5b62b0a131fab6b54747cd1424c7ac1ddc68b6ba0ca7e09cb292c31e524ae36320a03fa39fc6ce4ad11e49efa9dc645fcd637347af83afc39863a5f64e4acec72f649060c46988f09f0e815435356304638ae568377b62084de63ef4a93cf71d22e0d02b8edfad4e68dfb1e02ff9cb01200326ffa437b2d7d3095f6987da6a89a07767de7ba7b87bb754934bf81332e40f29e744f4ae4de45409ad925e9e35b00a865880cbd39fb9c09302432ce980c30d33ece59ff3a7ff6ffa687a6385ba2ae7f79efbb3787d862d9b972d359aa512ca0dd5edc56a1519f5d195b79ea5e35d3e39c804129e53d6db7fbf6344ae6b80f2eefeb1fe38a643d616826b3fa784e5c1d5660c702cf65a6da452330afd9a7be193b6e5404033b89a5b87989cb556a32fe3d83e6c180814a08bcb4ca8c72c24765977c5ff3581a360d945bd4a677352c60c74f884425a769c557471c83e104d0dfdf4ddfa9d115dde5a309009818fbee471f74b2986ae4d63c2e2e778f168ce023a33c0e719344cf9c7ad71a9eb5002b213c8b1187cdfb151e7bce89f80a17e112bae70b382fb588cc09b783a7cd2e3abe98eb677a8cd1b370637775f99b76413cd88e3ed1f02fe78271d8f07b7ca2c0834804576280a6a82d9e55c4acc269fcde43647551605fa8fa18feeafdae83b6ba37c4b45fefc91eb355bccaef7d082e591809801cbfa430d6a63e66be5b695b8f939d04caa630806015588684ae405308c9ff8d5959881f3e2f0d8fc0293ada206df39437392f430d06db422eae9826f41aad39fe7e01dadf293d74177d2929534aed8e205065a19eabd4393a78d2b45f33c00149909e0086706ea37aba8570591dff49f21c950afb2de39be9cbbe279b74bd4fc37582637e0ba7e294e2a51e3b8fb3f0489d7845fbff49666d5b61d5c608aca11813c522a4881f4e1b7ce5130609788f5d966f0353480c899fd0259291d4b2704d2ad3f0c852813aa0c16de819e8e630857d165a0da6ca528a1094cf19f46c3f0577a05b413b906ebe2b3e728715924b5bcf125d71385b754890b676f1ee5384e67effa6debe0a9005beb9987d8d2b6a21be673a6024f673672831d08bed8532cc662ff1c71b8bccddf549a69405b7605493d497278134424ca8b5d204b77482dd182f63d3576fd16e79d35b91cc47cb85f29cc1a18e0d2e63b89949021c455030147bec44d10a497db52862fee4f21297914784cf915c1279bc18f8c65222cd4d967dedfbb68b7152eca39eb207a428d292d2887b15079f3c95227a4600ee41ba4121ae46b0fcdb7e35a71d8045f4a10ff9f35de5bcf9aa93d1c725a79718abae2946ff6a32cb52831af58522c5017954bd097b691b4cc4255406f71224408c9356a38cb684e3d1c39811c034f703ecea34d820886e3dd35a5ecb0464ce6aa3ae6c76f768abee688db87a99810c4115695a529cee1f57aa219c2cf5b37ebe09ee69ab71fdcd0ab6dd0dff12864d2784e634deff943f29609f0c116b2a3280a75a4420454ef28655441c747217dbb1bc911ff748fbb9973281f7924c699e191787584680a187eeac10fd61e8dab2d8daff968e73461e611317e48c8c9f8d858c432a3ee8934e7afcbff2ae880c9e90cf6c5c6396621058f3059c7ea54de45fd88fedf15da354fd717614e408d4b73dbda77d4a13de411291c6e22b94c527a245716883a9c61157da2bb9ae8382cdabb44e36ddac72ca4928d4f940164cc9124faa5e664dab714c0c825a401caed181ca32fb90eb0908a809ae6bc4ff2f552e5686f8caf84410e7ad7c3cc44dbb02462fd04987d30aac6fa9e092a1dea71919f05b8054f114d7ce68cfa0856644e62d042277c7761e07c73c19a0a8f12f001f8fb69d295ee41cfa5fa96f4f6c42d8db4e8c617591575104d048bc0fcc2ea7b325e3a5962987d4d2e5dbbc9b0bfd815db25fdb954af7da5bbe05d1ba783e41104d63e1b1218241d5655036d1f25478e1c42fb2f445bcbac85f6579e393ffaedebb9ea315d350adfd108d69f2cc1088b8907e1af00f679cb52ef86e3c0dcca179107c80c99a6acfe64be5a93a5179ea6422316f8d02b8cf97db680755ba19b515f6c2f3b9f1af7365a612cbe34f657c736076b403f16b5084c470d4769ecf79d66e2a5c656ba0333ca7e6989ccaf4f2a27f95416debc0d1feef47972242cec5b4b8803aed28b223b71e7aa7201afe48c4dfc7d443ae3fe9fb126f403b507afea10c6f686df084dad36f8c0dedb51d43348820a3a6714ca43e3460dfcb89d55784dcc9b7ba33728822a90f1b3537e2d69548aab6a5cc4c9cfda9e3bbe5808038d974002d67e6adf38a26a4002fb8d7a3652a528d5bca76bb54d5e68e52b6d7d3cb38cf21db05f5718c507953245a4155e22b48ead96b955fa133f66334ce0188479bfb89544d045713a9443eff264824d321f7ccd43b097153c7687a3859f6e6f818f846cb0f8bf285fae7792f6e7f939e0ea57583de18f911351902b816688c3f12d914c34094437b9fcc33275a15ea250e65593e6a34ecff71b570dbabce1d1281f24d70bfc8d4be569d6c808e02e8d80d4c59ff9ed582be11d2d0c9bd138761ecf1f6c12fc910cd0186cd4f4e0767127da938c1a48ff57a62d4a7325e80d1be052e2e809d01e25351a47475ef091e1c0b3bf2fc13b8d5acb4ed619fe64bdb0477cef39176f73e2bada61edddab6d12b07e6e877204696be85bc102591d60bda9fa3fe36492277792cfcba0e5d5d7c2be81229b329d7d76fbac46df75eebf794f5a5af503ab426ff35b8747ea69dfcf207110e034d467c5727e8214076b0c0fb0c84cd1b0fd5f09303a04791f7409fd9041265240bd142177ca1e76dee58a46fafc7d0401be4c186e2a75fde01a0be69b96e563c4dbf009210ed5e8c7c245c825b613e4e841696bb70f78256517603f05df0b81967c8c12155b4b4d6b3b54c3d00b85537e8bd19272e965b365cf474b1e5ff9fc8a2f84757335f8c4a2b77fa4d7036bafbbc306065f11847849cd76057a66c28f6db1168efa2a27942d50092d5890f01b5b2c4730116e74a1f1191ad8d539cb53a725ade2e28790fcfa31ceb8c16cfff9a2cdf18356918d213eea6e437d39c35a11a26416a0cdfa8365a02421f854de7c6c1a43d432996e3640e4de34962f7d4b74a36b7563261daf5cf862c39c872862fb6865a1e55b7337c7208d20b5680511d1057a6fffa536baba83e02a4cf6dd1e9410827fc47218f494ba4c4965daa8680c76fd0e408839ba57c81863a4294b5722ceeb54c0e33aa9d1bf8ea27ef775a0a1133d776fcd0155aa56c6e1f64c930f3c0007b17e3c7f4d3aaa7153a75f335a5f6354ff38f74a5998ae1b96d777867dc57f591030379ddfe7b5899f5b03bc68bd8f9cb43bde390ce84f805d2a78dbfd11bc7b647df5f1a18006d5037220d9f3123a07a64ec358fbbc6899c5c08defc7b74c935ce0391129434903ca834f47772cc350c11dd37880e07c7c90d8ac697ebac28d23056fcedf439ab56abd71b90efa72d65debc8bc8f258d2c0d616647aea0f0e8253749a84467740a7128fadcfa53aac51462bab4e1583a7a89db64915171afa75e9968fe7e10574f7f0d0061f642b5b2c244653f117c513e0d345baa716bec3d2d40afe2e47cfef4d0b0db8d997409377f3349addecc46ea416f9bd95ab7236485b5515d57739c149eba09235ff914421cfefd6e213e13398e9c3f99ed6a0a1e85c954866efef05b775204857ace86e98ffd9940b6a28d51992b78e66e8c4e8fa7c70f212c01204d95569af02376f1268cf8583c8dc341a60ace5ca371843fd1e9ff02420e50db879a7a4c14798557733baadc7893386c61c44f43e474cf188f78bd791c33f5f32315e8ba05700dac188e15e61958c08cde9bb966aa69d55b7cf724fac20dc3da3df127ae8d9413b5de87d0a8e536cce5150c020424edd286e240a3bc6b4957b0dd74cab4303e46d4da829c3fe90543e5fa24b15ddb5ca4ba19211ca237c793ac7bf2a708c42d0d7d11292201c41eb666f33ac2538d255a6851ecccf4e623457ed71165d230ff87a9ba8d4fcab9424cdaf31c3603e59e5f9e5a175596a12ddc2f44a5db3ab74d0f96f11284347b8bb3d66d78c272e42196f16998a2880322bc408795552249d4f59384cd5cf93c9f7cf373399e4d95c9546bcca5ae019885d113dc21f255315e1409a7d21229ac792ed6b09b4b2891aabe2e35457805945251223c392cf378fcbdbb152842ebb0e94244faf589d1315eb48490032d30dc821fcef4c2232984fb3a4dcd44b7611a2ebdd98c796a2e4d49d598d6d1d64785d210357e530d02d751149628d04424ff56779b56ba8b09a1fc7f3d9096ec47d97e93b98dd266831359d98d9b6d990e67fb8c36f0129ef4609d5df1c0a005a891d811f304a807a774fd7b492e25aa36b514277ba47854bf383e6502e8f5ea6268c2c0c7eb3f643dd53dcad2a4b5dcc45a24ec30f7f6cd1c21d91ac8a67416f76b0f83b231df10c94ac3e9c11a3dae7ed0cf263381333a935da763b29399d7530d038e7eba3ecf9447f03b3fe75c56e3dc9273df716bc5de77ce9bbdb9ccd7ca13f43ce359faf052f68d0bf7c0d07155b78abe7f8af04aaad89901dbe8b26b6ee45573b5fe52e2c3ba62f1f0b2caf80b8cf52213b921ea18118058f2a39665e95263fc7d72b9e43e11a9d884ea397ff79feab6a133f93f695f0a569fd31111cee26c7d09f619350838b23e6cca70458825fa715a021f3a44c52970f0d9af7ca4d7d70a916a202d1c4b5f382e7864d7380e7f756519fa87d34508974c182324df9e3b707eece3cac22f6e08aa00f958c12d7f052c83a88151558e674da8f705e563de31decac32138235889c3c72816fe62f5a0439403aa65b4dbcc7d53d095eec4bced8bae547494f3f7dd8d9be7aa40a64bba52b1380575558a10afb8c8e3cde97005ecac84bb7b6ea7451af83218e6cb50e382a0dd8450e6d44aef2bda574e436d6c9c546decdf8ae6fcb03ce8eb538ed7e37dc6727aac6108e43f747f7ca3146cbccadec166c31d8d1f1cff6586d59e301ae2c89e5208f435041ac3e8e7613741288dac44d755df269fc0244097a9160970dc5fde554adc45fc80f19ecdbe482ba4f6235e9f9c68ff6fd085128f7e16e843a96d3fbe1a3e8bbbaf601c3de5e8647a4267f22459b1ae3fadcee0fb8c4190a23f43ee90b7b72f160913c18b86a630b6523432ea09cf4abda9c38799f1e424ed6f1e7f88fada69fc246ad039538595e6e32aa2add2e681291d89f5bbef52609670f76d904b25707b710906cdb3cd7641cdbcf6f50b9c0184f8d33e9fd09140e04cc617d7884675d04a4bb0c13d1265cc85b4b44cd526f8c2ad2adfcceaa689d3f4c4a5f1c7c816ba17fc006e2c4c8b4da23aa53f7234223a2f47272dff955abd98250e13ce0b97d5a544eee64c2f9cf57ab28b971efe2083b426555d655bf9e41b5aef54c01a939c1703fe5ec71269f809d92d88f4c1f53535b46d2dbdd93b0c8ca080166d31e08412a8e1da8c24bd9bc41f7ba71f668dc367166e6cacad007b32a86ec1bcadfd27b88b700b99b1df51ccf5d88b3324b4334c184776bfc35b60e16ccbddb916810b2619e8a9a7447f5413e946c150e9e883078b285cebb4c5b148b14cbf99a20692d8a0effeae4beef562e3a3d892c16398c568fd07b2bce501e3fdb48de878a64aecc35dee62f836546f457b860c2f06e1d2dff9982d98c3cd793a126b39192625725425cfb2e4267a49b198a0833bb0476c695dd8cf82c6d1abf0cb0f9871ef4bcc73d6fa56104c98ba95eaec0b20af5a924a16b6b063aa63b0d08b1809c6457577d4e9c86b67063e8f3af6cf3fd11e4baf86eec3ecdd4ddd5efc9a2795b68aaac3296d82c1bd2399f882a53ec92a1724d341a4be2543c5335c8b9bb8190305f927df5883de94c90185575d9f68d28fc8e360abed01062aad80b3fc1a67b496434f09ca059a250eac8d46b4d3bde7848c7dceb8a9e80355d23273fa36eafcdff99635d813bd45ea16274eab6fefefa5867930f39870ca48a7dc50177f22e840e844ce7168ee5d4a6ef2097c9cc0ea2c0f94d2938b58fce405acfb7820925c7286f28a726c2f1e2848d26524b4a2a551f4211798cff23b8e3e7a4c67dffda2a78a65ec1297e3e388f975ad410b9144c3b9cd3af4fe405e9f43028c70da237f8bb03adfa0f52069b93de6508c6acdaba8a1be8d7e1daba98e7e17710b96b9592746a06b452bcde99b1dc9beb50e0b6aece46991366565bd6359c5bed0e79c147ed3615fda90bbe193ed6858db62b129298cec63f6e11b27b1cf9cf3af85213b5f689dd9975bc921226b8a3ea581702ab7bd85a59a4e78bcd639c1f43f1581d0c7cd8e6ffef3b6e2cb34319960d6673cd12e86789bc336326170b7a669d0806652b11427ccdc75abf89e24988bf7756298833db9406d06f35bf04a3efb1c16255aba1538ba4686fa77703176b92fa98f2f3872a622fbaa7a3aa3867457ae6c136510dfa2ad7af792d7ab28fef33a87a15bb0bab26b15091f255f75a7ffb5403e0bfbf3251c3f47b0d0178f0e839d7b0d092cd1e9839a82529a5aa23fd51a0bb83011f71138d0355907de490eb24932ecb986b9fd7df2fe530a41fb22c2b1042f5d15bf2ee99006740e40b6cab71895f6de2969ad0588aeefa976fdec279487947ff5cfcf6d9007ad59c942b27e00ddb0d59b365350b329aff4e1fcebc15cde8f88865984fa43dc01521873968d9c42ec7a7c90cb5cff98cb105181eae7c7da2163022b02473e03bffac30ea6ff202baba394778ebb8b843dd6ca6224d7ca1f7e1b127654d4605fe6adc33dba7a391d4428a0788218fb67937064d9b1653befaa047c03f5d011b4b5c8d11d83b90eb5a8b247bcddaf2815bf75f92ac6eeb9cf43c37d612d5dbeccab8e039992d6def16e61e9ea92ddb4f6dfd42b15b5fa85d6af915b9ebd8dd4878f60de162fbb2ec4064f64ea78c206b9b84afc08fe4a4ff0a89467503ba4fbd576be0b36142bcd9181ef1c5a8ac54926ff8d4bb1a40503288315f437200cf65f37cdbf189c50d0284ceabdc08ed438dcf7fe6f124a070a64ec4276c26e4a437f1d4afe2e461d87849b02c59a9ccf7383be164431bc35ba52b4a81147bbe873159455c9e2ac8cdb8eb1fc34c02bfc1026b4808678d01f2bafd91804b88b36fe39508e8cdaad4a7ff803c35651fb100525db2f8dfeda536ec3b8ca8bb831eaf87d61ea318333bcf63e5b85645c493953ef87b56881179dcf2284c3a7304528bf4c9947ca30a1fe50ce4a8ad509dc34eceafc3db6e4aeda213132288e7d64a853aae6f1511b3f6141e05a220fa0b1a159b0e17fd34e2f264512b02888a955ee0969180cfe9b7e6f15a589a1e3af5e32f0430ec70958a88ee8405cd30908426ebaf8fe528bf2db101aa3086175b7afccc85bae55211cbb52cc7730af5325a6e8a733a72e1b759120b2e107ec2a3f535ea1788270c41698a397c2a0b290c17a5928a27fe56a0c03ff68b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
