<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"aed16b57f562b96db1c545bcf586ffba829bf0ace932ca816ee43b074d6e939eeb7b49fbc5805872d5a8198fdfcd875f5665c6e945df494ffbfb203b14fded5c9f8647488480469befe5a3764924f862a2295c5a97503e6296f26ff890cc14f6b81c0517eda56179408e5debb260bf8de1684a9f5ef72d522c468c245170fc57464fc3c3b1639338e90809e8e767086bea95c7accecd2fb0e57951e26bcda0ff0b32d90187acfffc156a53af301e27d1a6c47d621d2bce5da3d04bc9ba49414d11b6e647e45a1593b023e5885d02e2d15d5d880f649d9b4795c27c4cfdc5af31fba75f98c6cf37c9792a863b9a3145d3b0963f0e2a9ff44f1693ff25515ac2bf61bac5d1747f3dcc8c0aa4b55e0a5848cfce023cb9975b80cbb7dd3a00e80173fa4000d9b15c9da634bb45b65125edc7a17e4d921f66f8cd3429bb1b42916376e853be8dbcfdd4ea59444ef97e701afa945ff603ce3c33be2f6581986176be03385a445fa2929686979a4c3dc6f2620cf984e6a52448a00de4a0dce12aa3a81e1fa51eb4717fc0a85cc2093b5eb846f6deed8235a3acb496bc0c3df2d6e19b1a84cbd720cf5b2cfc986b061492fdd0780a4ae2126660729405e0e06e9e24a3c371285f58dea9734fa748cd946f99bfb4b9b5d4ec40a71c9d70e0c7837f6cad789fa5d3f379e5126b28c3006c439a5bbf26f97f2cd4df5cd35adb17c4b9ca3a9cf8c6ecbfb3fc3ec540b95377fad94dcc743806cb0a41d42aad5a3f598bc7ab58f4e6178eebd5a770b53dc8a8a35ad3e3cfa9ad0f695c7f0d0c191427bd334704fba7b1fc9b3c007bb6a5ac224c3bd712c7c981b633ceab85123f2d2179c47728aad5b1097cdf9f385001dba9c03107b725a1795e16a9deda99460580d67157ae3aec0a5ce58e02d5749d8a9f4ac4c8b699b5c71bb3c9be7279964dc4318b8f36e786d6fc4fc97ef45a98144a0743560bdbe69f692b7d06daf7b38cf1686880da2ee577b12f8cb2cb0a8707884c12e1bd777e43cc16bc50069282bccdf8cc5721f834a6099b34bba1820d1570ed915901c59a0ba9c6275cb5c688693da8a44c59e0f4d00f5bb5230e529cf5e039cdde6c663e9665bd0812704d1308a72804f034469e64d8003a91c4d50922fd23ca3a16833f93bfe550077f2fff708cbab11d82096929e9b8250b0a30d9ef69bf2fcd66cbd8ab4c4d2e0db45c0b83b32a4839e3a9fb7527800ea87cf4bc239138e822c933f079fe8037b26cfd593a4d612338cabc9bd086d18b52127ccaa6ed0e5828cb699f76117b738b14350ecd071ef93ea9d4de6db2901dcf898567307c56344eff25471742c0fa2ad65c959c3690e61d526f9a595e8cb2ada0ae031c6a0efdcea85142462e57cb700b3200aa6ecd2450c51a64d048a79870c64f0c654fd61a57841ea2aef2b45ee60f33a79cdcdce7aeeb3403f7ea2131fe467f77ca005f17d2147fec305e5944c3da3be58f5a4155bd23931a15282f31f955908f677c1e6cab16f56311669a8ba2323ecf9c24438696b02682d5523dece81b2296fd504ff198ff2506b724c1759cf0fa64a424c0fd3b310343a1424666a5dbb6a17a8d2efbeb50c5acc963e15993435a3191e45f8856a1e08a79b47874ba88b0a056c5cf575cd4a8d7b6cbb6d5ee6f20e83ad0de425e31b4018cae0e70920cc65b4a0ea1d8b75b8fa07994862cd1e4b383e06df547a87b2b635a50e63bffd96800900509bbbbfb9c9d498331c5b5ae9ad5ed4219519891afdf5587dd4c28bb37f9f38381b46ed97488f5fa74bb9ca8cb7f71a109cc2e2cf37272add89cc475d9767ccb58b48be0e6266062923e400fc9f52816beac4f17473b587bf6250ccdb18eabec00d569de7143cf98e74a3a57a5bf8e528e9e6ca89e61a10905ad5fe0a036acc4219be767e64b7e08e92f9e9f86de69009131be27b2029ebb3cecc46a3fac75be2e57f51e20a20323fbf009e8f07901c0bf97111017cc67d6d22471bbbb007a6cf9b18bd7edc74dc2d04c3bae8010e05f566cd9b2bac5958d94bfe59b63a7df05e08bec171875aa3bedcd91a44432a5f49887296a5785c66e9e9f1b8c27a563f87575a95f806ec290e6f2eca3d609c564f2540f376b7008fcf882d19db7a86086d56b3562d95907027c172e3d30826d90fb2d9145a7d7831b2674fb6339b4c8f16ea7b5001d0670803534bfdc80337c6b04b46d4beb6131b0f8cb43d9f6f94c34cd1092722f52711ce9ec0c6144413f4476c4dcc4ec3ad47d3bd2b738bce0d0a58c04b716c377d584571e8df9abc4e8656e00a05030a02aa257946362194cfc469ce7279ccbeb5c1d1c268aafe2299ca9bb1dac6d5558b62b99f47702c83e1d91df481491dc36f090abdbb112166c17aee2d7f3947b8a5a9db001a7bc5e0f37336022af8678e0c1f27adca846e38a05be6d4353bab031b3e3ad5d489b32324dd60f8b6be4e46a2473ba13de5136fde12546ce8bc326f2c4984c8943deaebc0bcaf07eaba8675e45e75276701db16759dba0d6e121cc28550ea04449a20cbe747beeabde6ef6fafc50d747bc8164e18ff1409b360ddee9f627c05241f9dfdb2684b4cb0138acc68b443018b68a0696464d3855f51ac436d63ebd2871154e9f70898b8cbb76a7f186bcf501d40684ab255e4bcb52c8e826e7b2f1ce2868f56859df295a127c331ec4f5b0c106f7aa860492565ca6d7a06a389f71f25d08b385e9cf642981c50253f9e4638abfbe16c0ac930ee688de36aea6c2b3ff558e0264e1e16838e6f54446cf3fe657776acfcbe5ef28d21687e47195ef14a20386adecc438d86e2bb465676f83ea8234da517caf1f56a334e1645f471c93b61f2ad4a9c61bbf67b8276af8d6fbd3b1ffde48d70ec9e9610197aa42c162bc8f5287cb7b8290d31ecf7cedd5d4a91fa87a27d2bb94c4fab388180c1e84d8f4bded7a88fa6b0975568dba7ec73c68564a7d7a809278ab7430f95a14944af70dc67d299f6fea7bcbaa473c0006895a0b8d7f1641b431506121d18a6065249924ee7eb4a7b5c08d10c23881efe0b0c2b8fac305d494d5627bf2e0fe861c78178ed87295ef390c1ad880ef708c1ae0f932cec59bff04b7d44f4b9a469c3fb28ef127de68ccd694243ff0256b8070caedaa23fe3f39927a9d985834cfc0d465e3abaa374fe79c5cce7a2f84124826ecf23b27cf4bd971fecbf15934285880c9ebe2f9e286604b826090facfc951ab971e2f970d67aa160124b54212c70c182cae44fa75e22190a8c6c7d7ebef4e005eebb6c4d6d98d42bca9a501ae8daad6e3fc39d55b5f636d092248c8fc36c9f74770a871902c8284f8e1a20f0a888411f35a141419b6d1a2ea13d607fa06e0a77f9ebe6b9d7feb7f46eebeb083465a18a56cfde46bceb134af6e923493bdd9453a5f6cd487f50b94427e17075a047ef8202316a30574f31401dfc89cede01fc58360964984a8d5355853f297b9a48ff20b3a04a26041ee1767c84841bcd179b6de8202a9b11ef20663ba49e7ec56d2d93b3fc4bd83dcad5309f558406054e586b93f207a206eca5e8ed957595b380e967847e856c3eb8757869417917554ecf28672fbd1926599311677313ec68720c00911b5a44f7dcee0b495a24bba0197f8d0e39011494d2a42574cdf9471673cc4c93e8f64fcd8955bf58e1def632e18a6ea263b48a3dd0a64e797aa1e1e1b5852a472369f357ec629feb67cae9ce99569f47d2fd1448d93b9e95a9cabba51d5825dbcb6f0a9542689cee9bc9183375c3cc0560389f0722137b326077676614a61e3c161ae4e643bb38a90c46e295308010da931a2d4e98cab07226d3fffebce910330f3bfc76b59bef78d85b926facd7ef4eb9049f01bdf6f553d70ecec4dfd98426e93205a86fb583905c1ab69e22e425edd71de28fd3a49f401c3bb79c1391f91cc6f7d95c846ec73fa43ba5fa621afe17156d736b55f4afab4e298e12ce9276c7b1cd88f18b372f63c5ae2579df3ccda247ca2d8a6a49ae7cc8f137a6dd5c5fb00221f1a1f97fb990e4714ff5d8deca4effc79ca770deba669d42a34797a0351c9c003d9713b95a73308a287926ad935b3d4b85a980b9d1471e7f73b490c4777e2cd89d78b3503729bb4806615a3c8d23a658032157ed40b49501c45de541ab5b32bcf34dfa625782fe6580316d25495b5c9901e072d29b91284985c20fbc6b8a9a695b74b348ee17eef10b81a06278e5c218410417a8f4971837420f5200fbce830ed6766d4acb7e735602ed9b5150ed6faaee66cc32ab4c76bba915363fc24d07d1ccd5df56104feba681e35abc8ec4104c8d079aa9fcda7d7cd772ffb67f40448f47b68c7a026540eab60a0d734e8676c5e824f249da680c061bce3678e3bf86fd3b16fb0f6be38d1fca952e2f922c6a3bd49d4c4a5b64f66863804e99b00f221746e2d91ed2b7e0802f25e81c07039bd1001ccc45c3703cd80f5ce6ccea452b417fd671d38765972e5f3f5a1cd5a1aed3e867f16be1399fa33ee0ac94b8c7b6cb711444b345cfff0b61f6c07cc1e603914a826f62a9a4134b46b0b673cb74b78ea1e9a9a5b23c9645d36c12c1548e420c20003cebc4f1a76abfa78a5b9290211fd4d7ba8b08e5b1901701cb0c7232ef68989d271f6abdfa895bcb1d1580bbdda56a666b09be60839f4175391979929768724628ed4d1c26130295af28815d8b225709ddb7661e5ff4030dce36449df7479daadc84208783539436b9e130bcd5c1b42e30179b879638a837739000b17848df73ddbab248a8f55aacd3c1a8e2ca55050dad7a1f50024cd5362567ab7d8a88b9499f72d58e851a9fcdbc2b319209b418320cd3fb9c16ed14f6467aa0f019e201185df5bb7b26684dd9d53db5545a121c0fd28b5f17410ea2f5f3972fe97dfb1f1467586d60dd14eb6b2f0b216778b75768004a0f37f55733d254a2392fa629c1bb25c460b415da15db1d9f2f1e3a89339dacadd99013af452fcb441015d0014fc93b5e2d9b3ff6b1175e2cc4f82c28fe0bca10b24bb789a148ae861d509725b2cd012ae049f8ef91f784b14ec5f640f9984d0e5d92096e455cad1b46d0109cc58c34a0e736573084170cfa9c757b88d5fc0cbda72e0958cd787f44a8686ad11d91491830cc78f187652c6ef03109ae8aa9c5150a57f9d31b6ba8a26234c83303605887b278b38ef45271b8fa7cf801c18b500a4dd7ab18725c62d119c9d28f465447e193d0d10e95c0337274cf7cc45732a1a5f833d1682cb4e243c788e2ee1de63e1e4b0be72076dcd9b6e9e42ec6d67e2257d34190594407cb031c2109c0ce527ea6fabb8010ab0ef496760a732ffb57d31aa662cb62cfd4728de414793e86117d0417395a29c42ec737c88d09d50786e64b62f4a2e651c45b432d2604460a9395275ebbd226e66d98726d9000723aed9aa527f0bb2fcc62a1b881055c5c7ae816e1e1783e4653726f02ee32764e172544e830166d1577c21388c02cb334d49cf572c5749989b6ea8f3ba94922498e71fe7a9504b6696c5779be1d366cb0870e84caee1fe1b94760859b6c1a194f8d5659c274d4ebba456a9bb28d64da4570a063494c3635cba85716549da74b67696f09e8daff1f43137bab2faf61234df5941648761e74a301adcd8a2694922149a850625ed8f144311583983a945f16bd1fa0867da152966c35de441d2ad988eb67e73d7d69a480b06d5ad0eb2f7397a0e66c5a87b4c819116da9be3946e9b7f71f11940f27ec08dfa6e784b6e06b7f975e0c7897f588d29cecb2dc9c5d693a6b501a4faa5870c3ff82b22c6a91c8e229ca00313ad2656e8a6d21fd7d6b75fdf7fc12bb844905bfa7059a5d73f112149f0a84a4b8a030f440ed976b1dc9d51f8d357c50d3d70350f52f7ac0b56cc35d8c65d2bb1ff1698d7ac239c1d9f7ac2ba62fc2ab8b4b9ab66d35136ce09321916f84db88e27bf6825adca3310e8787dbaebb36ad61ac4ac02954f4278b2e1f21f04f8fc718a36fdb058617cddc56b66bce5c92465c8b54a13b5e4bdaf0a49de064b4e97328d6626fe1d08c0b1b9f73e0533369d46d32b7d644aa1eac7632c8f193e0e73ab9cda4c86644067d719b6c81dd845c2c1ba5a58e7335b50d192d31733ed30e77d598ae1022f88c7ec748b958b0a91bc74bcd0d5444d8debe475f04c925b6b3821692b06aaf1504e25fe23dd4152fc39b1505f03f9c4976ad7400ecd33c3f8b8c06d02a75894e8d18dbd1ed431d5115175278969beb618a82c29a4cf559af9ffee7961baa5cec34476ffab36f795390a2787f3ded31f35307379b97c367d7a400959c08cccb714ebc294d4a2b01a560ea1ab249834b05d4d5c073ba1ce20effac071d76ea9f81bb90eae728334dd2e7ab5a396d52006661c63ee1c8ac8b5f97479c3572b6587784d6b32aec310f72b738288f833e3831bcbd00dab318dc938dc0885089c9df5f243f59b62414296974145214016105bf1f0e96c9d8700d67ed7703a3f48401d18f0ce3cf393a74e9faa7b420874fa7cbea3109a9702e0e3f5942ae1479ebfe5a1c0f9389b205e80cc90cdc72c727c3d4c22fb3cc49828281c6ff6c5f46e760fa27f06163597d264346e48d395cb42fb37ef8204ca13ec78b55c51239b7de62282607b2bacbaf9bf6d68c1335a722317bade283cb137336c3e2832c01d217d5975337b850892022e7f0d24438331b5f9248b23b204ba049d6b50f0a6ac2f64c4c0621b9929ae98df2abd88d0fc5f57a93f2089a508c5e49beec1ae150d171af658c7dfd22fde9d43f8fa669dc816d640ac7edd2fcab25ed8170f016fa52275ad996fe42cfa13392671f04fc122a0020c38a54cb8b5677a9cac335bd54a75f7b5d94098ea3df43db571033ce6cf0d280a6b23f1c45f09110f091c0cb4de928b45bb975af3edf789defa6bd52973f8626cb2fc70adb4ba3f1778cc67043205c0e9ce08f41c32d3195de84e4daefbe336ee6c66f5291cf270596376299419bb2cb968aa96d604dcea60fb46d370db75666f84ce6161a9a23de341efd73350954997fe23b9081635ab777c0b31fdb770e4848ebe35dbc5b1b34887bf50330c420fa079557b7dbfd68c6f5a5974c95bdd10659f6b466a5e3ac563908798c15a996cf28eb8fad3f5ede01c323ffdc0e1584052d4ceaa23511389951d9a4bb4ce8c3095e573644cbbafefc3feb25af087b604e699bb461607b95b64dc163fa04fa18e92fd8892366ac69cdd2d7b448787dce054d85f251647390d91d91f786d76d45e42bc0dd11be16235f6d8772a4b451212e29e0c0936c5f8e1ecbc3a2216cd735d8fb8c60c023e54f4690ca7f171a76be2c35a0fe13fe4351d4139bef31637a5e8ff8addebb5e5d343d6df608414a29ae0f10ec068511f5116b74aeaf6599ccf81029bdedf4e4867b2d199f921606878f8c1ad5c7da43c792ddce9a1c67aa97a2835d08fe0434ddd9f9d368a39197dd7187c0d132107c45c526348acf1174fa36d32cc829d2204ca928e48e86fc69162ebe7eb565919d06a2a86fa70b98642498a0a7ba0029a09771100cdc7f5781126c8c782c0b88d3eedea28e1eadaf139f41684d7bbd03347e921fb3e577e5fb813a6d4aaaa55de9473beebbcc3f952dc2141ff6e737884e42a38df5079fe908c7595882e3393ea71d687bf9b2e6edb112660af4bfd9c1ea5bbf99f02d181bc9f32a71f978b0e10e221d6207f52f802bb89ceb880c5c98e0d827f6039f19ea4460a5992b1036a3d8c6526921800c10cc7dd6f4c953a345f36718249ed36ff286dac4fbb922a0a78515eee7e48a90a945c814d5f02a8180302c958a9e2bcaec83653ed777cbc989615b0d15dbac0cf6d693f711c65bd9f50a3221c158ec7497eea29a7aceefb157c3cdf2543b36c3479bacfe33d0097912114114e61f61c9c0089e3f7f0b541efb420618e88eea78fa17d779aad3571a1192f63fc52fe136fb0cf66e0f9c3f10a1b9c23c917e0949900ed4212b14ae5eef2437afbe78e12f6f6a33de7cb0373674e5e940388347db0b75c834f0e55cd6a85a5ef4537953da9fbacda8ad8f5e65b2abf12237e3ef5c30e687605d19bcb75b1e57a4ea5ebb80dbb4768227ddef01d9415c789da48a8ddfca34cebda54a3d36c1af4c9d8d050f7bd19b1188662ed3f978aea1fff6ca907500468ae17e10178e5b2dadc6aa1690f0c18277cbb4ce99455edcb849e271a4606f34db21beb4209bd1ade473d9e5387f361beedc4a5841d3546468aa2764cc108516af52c0702f364d982a51f95cda39c70a79d4543ca2b5a04bf4f4b85faa0bf48ad3d3e34b0e1af7aa9ca99d52adb34667d96fff0782a340cf94e184591bf061eb9558d91d59040e73a9988153685afa9cf64bee4274ec3190fc2063f46679e33efbc0af5eb9d56a0314dc53eb96df422222488513561b25b46f054e051ccdc3ee481b6ce6be43f00b033c0b5e0b0606bf211b20857c163a24e7fa2711629e96351edf8143815498a4309b96b500100e52d80b9e3e705ce5b14b45fa0010e8f090bb44fd325b5827fcc3659a17cb2aef3ae16456962174131a71e2d274ed7103a71248704b1ca136ede594e90cdfc8ca0e5ff6466767859a590a3960653a6b9fce4421adb3ba54df6474c720bd8ed4445a56a2aa3bd9533d3bf4b494b79cc6671bb9ec792d35cb08f4f5f64c1deb1df1aab5c8126727f5202f89f1d195a5b0f09b517d6b574db7be00a9e58d2418a023dbefede6df68c20d7354ae175d3b1abafdd771d5e3ae4e78d8fa0632d1fe172537cca1eeeb450bd526a691d56a5e71a8bcd7d7f4208510776eb2f96af3f6ed6b3f13aa4b0c1521db6f1bf770d46dcaaaea555d7f7c00917c1dea1c7e7b714d3a56c3233bfac30ddf3d4f389a88fefbf9bfcc5065c54776bd9bbf9530f7aedb1dbb7d5162e5ba387b4688fdb85451e424e4a9ccb2cfdc105f609a67c3b988724a8e9bd05cf844df65ac3b7dde6b36b6bf0f027700620529f1c61f040530847618126a128227e088fcb17d2459cf2a17643f6c7693bea51e631a49182771b6eae5bf0dd45d0ad6409e407f9639ed04e28063a7c5719d97c61b0d3b012a47931d98c7d23425ad4aec078d86c028d8495377b15e25dbd20bc490cf8382ab00ebeff4736ef4276b8d45479e08421e6baf89d9e606cf0feaf13910365b404dcad772683d755f1d5775fdc1f12034361ae265b17b92ae96d547be9331e446cf18dc38a61f0b6b346930995c759362ea2587e1ffcbd2998a976b01dd44c57459caba4dc7f3130979dbf273a117686c12998869416ea8a97b5dea8d084c843661e1b3e0568e75d0d998d1a484f021c40a8150dfa08d9ba1a9d7f1a9c917b228fcfacfaf38214dad80eb2185c9f9f7c963321f34f45a06bff2dfc4ff79ce3efd57505c783d5452bb8b8c0156a8afe0a1bcb4e43546f152fdc20d57dc94d2eb4a7b9f720adae113151938308c663d71f66f82c61b47a3fb40e643926c1d0bcf51d1ea0b58341294b469582fa675c31af0309c9808e5540d0066e069487e67ef4f8dd0b8910cf226599e974f9e0c8fa9aefa13e13d9536c4752cde05bdb8783a4828fdcc3ece3f9e228f4a24197303926ff24abd0f828ccc9ab2c9fc653fa1ca4ac5f7667d5d06b10fa809dcfdadc2202a5a053bcf89465322046451e6c1d905dac80993428aad48d674bff682f1d02fedde5c42c92bddbc63048b414ff83a3499d5d4c129ec603710898dd221da427e5371a8aa00b53cd1794325721b06d1e8531c3f06d3859e7c87abbdc5a0f47d057ddd81c096e9d74b9c03eb8871df8c9e9e56b9ea2ee7b47746186bb89e399f7227152fe61dc0d1634ffc04b1bda7d228f5d29d969d555d54e15962f428de2b52d14b64f2c1adeb3ac0868211d1729c71339bb4e5fe952249344e711cb2b870117bac7f0dd13c4df31d2d1ae034ac7798a09748fd970c2ea08968dc0a900cbb8954f3c5fabddafeded4b2293351d69d981e760fb7db18f11f932fcc709f7001c9a6ca5c9c7be0fd80ca1a39bedc49f114060a9280bb7d6586e02e64563b1d96da2863834db7aa3f2153b45c3fbc3197aacb42b04829f0a5e932c394814d4b8741550ed2e7f668eda01728600b32e452237d8de001fe3dfa06bb34550b4e8660660444e689a4b9ede5273a837a72817a520c9041ef2ae0c37e8c396658a286066e72423f2ebfcc8f60ae2103572793328f11ceadd0286ae2e45d056613f295fc932400daa55e1f5c4148e9c40a4aea4e0668f83910c4c1b8975d7185ba210730691fd71005d840bbe54d0bd7f4a1faa687cd0443a5c3ed39c1ec161c13b768061768abf53d2c6dad09f9aed8e4077d76b493597490a226e9914d7920dfbb7646e1bccdc30db3ee40d2202dff44e231063faacdb9d81309ad1feabb9eb7623a5dcd08698d92d6c0a04fe78210bc0dcc363772bfff932bf98518cf79b00529fe5861cdd90d04b7c5f2d5bb94933ec8331ad5891cc4922a6487608963ffb5200d90f443cd20cba519a1213b07de326121c21d0a5d623fc23a549428864ea2468f3948c247f22e84aafe7af321d64617afdbda4b6f8cd9f3445860959ef34e285afb7b11c18d67270e4a335d35fba52c33ab95f668d5c12b7bc14063d554b773a9d1f901cbac497fdc325101c58bc6d617fb327b8555ea53f27bcc8588638af5cfcf1156f6fb4f7437d52295d32ccfa5f10f8988799ddcfb32b334871266a09da29b81dbc4da8a6d333f1419868c71e2f5b2c3b0ba6e5f0417f89921b8f52ad84859caf5748636f8d1ba4cda678cad21e9c443681f2c4adb5f4fd4ca92f43152b575ceec80acac57097a0ccd08cd26ebf73b6d0f5333ffc6a30393434e72ffd91e4b157edf72a7831876734d6ced040fe8e70e2564171b84ad614c34d5dd739f510c130af5808850acace42879d1f9e9596596a131912ba5f4ef6d44eee9c40d1148fac98eb7408d15ac469f2125c06cd49ac9ed734ae55dcc07f6d90ea788873a0bc8f523afc096eaa52e04955ab22950861e0bcab94967889a41723ba0838749b389f2e30bff38c11619f5373c8848c12d2e4c5d194509f23802b09ec0e4d1c5d6223073ef9cac74eaf93c61110abd9b417cedbfc99f366f48e435cb1a8f4994bf7789638687459256d09993a3e5483fbd2e5eb823d8ba7ee5ce77d786b724ea858c86623f7991b7fcb6daa578259265808e8bf0f005eb41a8da61f0f256b6cae1ff85915b7855e92c2d3842b85c062c5787e9b236b056bd5bf11521b4375544b703dfa06fe3de3f0a572df2fae3b213281de390d93f2362612ce054e770518e08826190c08b7709b6f39f05b3b0e34dae49ecbb1f94cd5ca4ce176436b0d21ce7282915ee3d1f88846694295c1ea9e42fb3fb532cc0f02d0b43d5a1e47a3ee68079f6bcb3d7eb605f8643a7987853dcfe047ec6551b8b21814e0463d03165a65b86f624ccd9e64fc09e8af51640353715aefa609ceb025abb4991a784ef6865397840146fa9dd6aa28cf4ded02024d88201045adf2062f8aa2dc66bf327ad25bb7c24f1eb5a6684701a62a89e2878f5c213ed14bfb1f170de3610ee0eaeb7ceada6cc968953ccabf0d424f7eb82c9fe61003f1838500fbae41aaec5be9c7eac08b302e5faa957852c96f76495b8a336cfa8802cf2b81e9d637a1d76038a1be9b818235783d3b3e8524c6955c3330fd2d545f7cbe265b36879fb2b61a7e6ac7dbd5ea19be5426ae02a79485500cc160eb8f431fa0a367153cd8463de696abae73b3c0b67dac3a39d80765fbb8b507c3f88ddd42ec5ce7f5d612c6c00e5d3277138cb7281fd5d1c33a17d2c2fd04971883e38aaae293e48d2665e158303011edff3a190e35ecdf3595c67ed58cff9bb101fd7f0e4f9df8d48dfbc4fe768808f24586cc7eacae9198228be1b21ceffbd5cdf6700d7cd6d1cb61bddce118f2e9c3cbc6178e0f9593a04e4e5d00d42470832229dc44eda60fe05244b9e429042c19c8f3174c3f1a3e1976b62d461b527f1d4cfb6e9488f5e80cedcd048f8629ac6b812cf3665580ed219d5cbffc1b017f4b01d1294b017c07cef220199e31ffdb51f308fcbba37046f39568df4410ddb0cd98ccd9e0d4b88f56d1299504184fc3a309455dfd774006994c8f5af368809952cc88cd80b81f1c10fc43e4fa31359ffcc80557f0cbecca379ea50040e36452c621733a6977dd5cc8aa815177a6116601dc4df58493428978bdedf9580c1097c99ef2b5d8ab048c63a7e97e0048e4fee90e5683cf710075c132992e15930635bbb80e899c2cca2189b6d8d2f2fca410d172146be3c99444f52af989346c8f60908bdf0bc63dab810b3b9c07313230efcf1a82d2fba517cd48b6ef1589a210489b0cae233a3166fd7b3db7624132e9bb9d7dcb4968c689f617bf6b3965b10505ce9bbbb820e454f2f0bf03acbf078c9d2f9539ee5089c88cbf9fcfbcf32044fdb3b06ce7a98d897e8ae8986cab713f4bc1db5cb83715d56a45f89faadd4a4d524c809d6b13657a2eb660cb4bb7be27303306aa6d1aab3899f39cd445078c9dbe107b4b96810962fdf33bb567957a09021933584a1ac8c976982dd679eb8225322f62e68985efe5f7b6d7e5a7f2b508788d2bd87e0b47888af5286ba589ae2e67a772cf723b5f103e17e9c84f97a5dde3b9e496a5234d5cedb3e4c2dd7841d0e9408ec5a6de0e8ab188ce22c98b70eeb6115d8a8098410884818cb0dfb02f941f29556332cc618d5b6ba2763e5056d34be22412e56d583f3c77d8bba9592184941ae5cb88489bdf6ab8fdb6c7f64b7e42400f97ee9758376c0df0373f29d0382e7a4285b87a12d62002a10f4135766137ec516acbb56b23621f7ceee1ea7a49005fb2d216a300a6a9e2ec30b2b80a7d39cd3469088700d0cc735b84bea0f71736789057d5464b6f72e1d1c0d2c75822afea8f835ed0be1b1d09fd73e98d46be03bb42aecef486b861fb2f17045641e72138d0f0052c98dd2de4d58ec9d4d2d4b36433e0339b149bd1531082194501c5874698208a3bec13796ce939cf13511115f3d3fd6307a1c09c0d68f63eee4ed7aa286ab29f640e0e874a575e505666a351bd9fc7b168e784abce39524dfab68b1bb599d6870f3218568039855e18f5229b014e2f138aafc80aad9210a0e32975b1296c57a14675dc111f896093a806eea13e8d6c8923ea6d01e6cd3535ab113bf6bfc38f17b20b8dca77c41b17341439ef3f04bb77e9f30fae7b62eae4355f3f5c301a619af1bb984fc83dad9938194b7b67fdb30f60ac38e04e637bf8e799a3b8d7f98cc04949ad4c66b917280e1d63e8afe50464e209b99a566997fe906d2efc61d1f62bd406b7fbeeae1f4c32fbf781f3a58ac9d0fd2be23987fc8a8a06fba938fdb7c0ee969b7e7cc714adad70281a21501a7479436e6e0521d1539d94c411e63fb76df9dde7f3e8ba50ded946f39beb4a8904e3f86f78988c528a3c8f3d94aa140cf66c05b6c89859fd7f0c5cb355e3506ca98f14dca9f1e39716421d31a8e2dd5357deab7d1ddfaf73afdd2cfa59445e6b768298fcc8fa2726118ce5cf05a5fdd0592c1d49e2fef00562b9512ee4a96e21ee35bd33cf7c8ae52e34a1ca210b996f619a30f24d2ee4947276a49059006e6e580de34a35d3e9c832ed1b909857ac04d3b6789f6b080d0081f62afb1f4cc56baf42d2ea0724a006a2d1f0cd80f4e1fbd0a9b17c521f39702f114c056acc6b88f1ba8d0a2e86f75819e3d4cabea114ba81e86fe97fa9c567944a1e8d7df1a5a2986fd407e0e2594562f2c5454300dd53b0012306fd39d41ce9688d52a3142cabe1c04308cf80e9d018b5c733f69e5bdabd03ab246194f58379ccc0619e8c1f39914757667082d3c2c16ae31d99f88b71ab1b9dfdaa9642bc99d28dff7a30c3dc6605f15a06d6685b33e40af1bc63c764ca60998179db604cddb53d7e9c4d6314caab65f56fcc7c7c0d46158421261b3095db85db6b0bb184170a5fc1627f4a5c412f3061afd7dd4ccf8e98e90f378684a68df574e3020de0e5b51c7a048d432308adc7ab68cd8636eef1e9275f4ba41890990ee0f527d654ecbd7d1f4ff96c8b14f9f0085eee7ff94eae622575b1d207d9d74e4b2cb43baff3243703af6dfc739d783736d2e8b4065ab58b5f74517bef847df0b1fac790731a4a686f49a5a02ae8799d13722045db53072cafa4d091a659c130c22373f3f29c882134b408f7070081f2767ef4eb666e38d80447412a85155813239b4e30c400bb2f8b9db50cc992f417889eff8f586e5d451747aca4b0f2792144559b4cbc7b3f81648bf84f7123a1f920627fc8b5a99160f6ae59fb2be08cd371612e745c3d0d3585bf6760bf1d07d38a4c5b95828c2ca3fd6ce3cf7e5c46ec463ef47b6da0eb7f2e686467906ae7b766a67c86c467c09a8064c4df1ecd10b249f1ba5121bf138d5df60275ad68081ede41b572704b6d726135b2e2f678f3e0e9f86770a65e8b93a67433eccfac65487ad60a8b01570aae7a9e2a35acc9a69a10268b96ee59714567e33ead4410fe66ab83e45608737a9540a2f108fdce897bb9126d3602c39e8ffb34a91ebad5d3283cd7240a725145bde668a132b85c9e64058d07aadd8fae52e00e8795d3edf50ba627601de818e9ace3d0e32f53ae7790b5237065892aeb48abb660404399502067dd555a4fc8bd878db1ca668ca4675dac23a438e3f2e911798e5f6f84b3aa87ed8f8d966deac101d6d69452c2d1710b352b2724f7acad2ee003660a5e64ec1f1df452a8375cdb08a8b17ef0b06f5ff037dc992bfb0841943082a8aa0e91d40db3dd467793fbc2baaf79ada7c40e4e0cc41beb0b23f660069af0387102b1269f2202f3e00442ea550c64dcfbdba111c83e2ce9267eaf2d4f658d9117f108f42d33bd89740b34a0b6905e09884b2672ee06e0b6c57b7423650044970c9f83c662059da07fd31c24fc18971e880986dca6c9c80bd3bcd1051bf90a771a9928312479a396ee18e90d061eefc170f60516f4ac4392238245f737bc68b4b171be07d95f55e885f6fb37d4ef2286027ea38ce6825a9cbd81c30b479290de2485121ce4a5e4972ca3de3ed35a1092f5bd81c7926b1d4719ab53c753cb83b76e608c72e9ed87851153ddf7afd5dcd46f23a61b89307100826721444d4588ee1a49f3a1c467b525d3a8b73afac59a93d8e83b459e311e2ce233b7eb4c87db86d080b3e9dc09f3ab33e654a053266336e066e80f3204894a302bde20f09f107a9b7b73138be89d38984cf2d9087887228d5aafa3d546cbea17ee8f5d61558093ed5d5c863a914e5e2e3127a2dd8e4cb98bb42f15f7191fb6ab3f598231a808eefbf9c5e817fd87cc24b557d44734fafe7e2bfccf520023ef339a0a9b62cf851bccfab97e0fcacb25ccad251c0ea1d064e8a406e413fdbfa599d1cd57419568743cf06c33b3d838d5da3f610751819103a1600d5444123c5dd9c4bb1f07dab0a91259565b5a8451ef4aed889a6632327715ef7e1369d019bbaa98524258723dfb24d3d28f2269351395ae9e68fddd1045e8a785d778ed2083ee5c0b976a72f285f69fa1dd9b3a3ca913925ba87db11fd4174fbcf67b1336c54ee229b5878d89bb49aa9aec034c22706c89c0e1b32e0e27f9de25f136a3e223ba61587ffaa4761abdf458575abc7bb49306a754f13b6965e468f4a4b394c9bcdaffacd5b93ef70d100391147f06ba5a6078c767fcdc718844b8e4aa8e7dd5bccfd5d82bb0b45e5c46389235712746afe3cbf027ec924013ac0fa6771308b2e912169f36098cb8c65bf3f31212e300b8e5851b082b660246dad81585e14594b85c75216c47d054a101d260b7ddfab506150998849a00a13a4be240d1d40127198881daea57f50765204e267805bbc9ae8ade5345fc807fd3c26f636958b854f5f96f71ebfc207c3364b4fd4550b42c03b5398d1e7b53f7a7d14eb09f62a9cd50ace3fcde73ac9a2e4a9e78b9b1315758ec4c35cdfd41484a0fb1ab179504668bbef5b2468cc1699e78052d185c345b49aae5c8f125655718debfec84b51ddd6014ac4cdb2b2a8a20edda15ff2b91fc583d5248c59ae881c4f9ff1cda0269375fde4c7728cd8ded34a60ffe10fa88eecb5c397d04fcece56777bfbde4aa048d08cba0ff6c18fdb44bc1e8e09df61c45f6ae6ade91fbed88684c24463851ea19b574e69f50f52ed07725e8efe2eaf8f197fec9c09c266b70c9acec5ca34d1108cddc10f26cba2f7e54bf34b960f6f7d3502b5fa9f59cce26fad824380e606e45f6db8ca3fcdffbdde2b00e02655d7e047aee451d3f12c074828033aab2aced92ed5bfcc1f86cc149f272a1276fb69defb78f370b2bb6b62af8aaee8347a2e6125b877947f30d9043f9eb70469889f33767fc938592de7602362783ab30ac07abb860c1f134d0e83d4a7627ce620daad9b7a1284a0a99d304c44400da24233206aa51b1abd1faccf3f6fd996f6d823e0fdfbc490fc086a287d0b8e2977a277e850d9079bb324366e1d7ffa5614d1a972ce2062b67179f588ff6d024def07154601a3f926cc0356a4fb1cbb89861fb66671aa493c700cae56945c985a46aa2a7e2510a404569445c3f629f30010d26b6de969c9fdfc06bcd710ba044b5705d826e6bcddde1abd6358e544765573e77e7837298c5cf0adcb855cd8f5f3e194946d5ed5eec7306d6a52c3a35a0c0b59a8c8012167ad74afdbe261789145eaee60d70e945388772f0854469e6d01d94ece60487d6633edfdc9cf123a0271b69750a39360d792137111868b162df7a6d7bd8f04a7e5825b23359b46cdcb7a9b6cc5e014069487c051a5de7a86c7c5ca97ba017273502f8f3b6d152787f2074e62f892b6f8e0c4d5bf27d5ed9026f079c418f3421af42a099e53bf5f963d9d6243f800a70f41b07ad01807b0c0db0942c9f20bbef74e2ab56319554c55824deb174317efd1931c4ba816252b34d19e948c78376a22dc8f5d17ef21281d86ebd3ab7d675d8e792c85ad6321e18aa2489aac6b6aa748fee7dab3756f082a7133103996c2579cc8497636c89326057eb42f1fbf2e5007838de02c92ac2b3aabc864db1a13875d687483597bd0022150ebdfee098a5cf2ea5b2bc1b697bd2dc3fbd2ded54ba4f1811df6b3abf6e163c3f553de27048abc4e92f279bd6570aad441ad3d9c1d5a91bcfbc336464f460006034e4fbdcfdfea7837710ecf10222ce8d6ad677b3e463effa3420152354d5f2bcd21b9c26277420b2c8fe026e3cc1a255e2d34f719d61b028c276bcb5864eb76405161265608287ce7b36117a3bd8f0330b97c2fee61497f84ca1cd1806ba8b215599982e2b81549ef4a7a04005df3c3e2869a41581ffdd06d6794e7620d927f98b4e7865868f38a5f6559018a0838cbe87c5d7ebe5fffba17435068d2f7a59b66d16543a52914531ee18ee753ef462ae527ba52df5507073657df1fa8fa8ca1dcf03e45c808a0c3fb92202ddd56b150472d17efa7bce3e9aeb75f8e6f5f1b596599359bdd276d3e5d91ba6d5b3fa26fbf064f1e7564b2374459000375f15fbc67b948fa3ee76b835ca06ec10173985721410982821a5e9765e69af1ed90c2f4c6baf5909c7b3b834c17e2cd4069eef5c66daad8ad9ea16be1eaba12066878f183d8514e99b30f235ad97278c921f6a2abf5ed9aa193a66b801bbfdd552569645c8cf3fd0067af229b34c24bf00a44fc82e8ab52d1ed0b5797f3ae1dd28d12a99196f8ccc3fbc571ba240c1dda9eccfd9225a13cf0c068b61af84097d372f4217d2cc988097ae2e5d90f589658df83e432b6e1a48c1be34056c6ec06a537efc99f3b2074caafe0613b41b10a58eccf95a61bb6bffe2ccc9a9f48b74bd40338b02a1ecfc640078f57d9762b6b3f7e2813d82450e994ad31ebee80ebbaae009cfaa7e3ee880524392d5adb533c6ae0905dc639324b867ffd2b04812f6","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
