<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a6b32c9f3ea3fd4bd52be3728534bb6b5b22b29107551b8d060b45ea4336c65ff830f108f96ebc08b635f00272b6ab6cb2e310a41de3c8e1512f421abcc281098f3ee7c32f020130e2e9d98623ba22f5f1c7f8555c20a96c674a498bb38596d4ca3dab3323aa961bd6634337eb5e4a2e993c5d9a5a80a00e71ff929277055b539ae0305cd20f631ed093fa39ec2bdd828fe8e50a3d8a0a97d551a77aa2bd928d712daca60c832c4611c8b8fe892e484ff0dd553e8a2f0c3af5a493cba0d7c7ad832780b0bd9533d3230c8a3caa8f811178c657a88fcc81533e83b6aa6a96c2726e4318cc6256247427557d71d6d4a9a8af9dbbaa4b5a147603559055ff192faf2ab8405558be79ac8655e7a54e1206637720562ae3ac69cb6bd6c9fd811cb805bfec258f816bee1f892331027e4ac559c98ca3e0a8a663804ae7cddab3c49bf2f7fe6a6fe2ab7fdde2e94643e0e44a14a76f8ce507aacbbdc4798e51fec62a8ea0e60d0f4d7a096c4e2a46ace83c2b8fcd16e2213df8703027a95b8cf38add6a1a5c9670ede179ad49545554386e1b871a9e18fa78fee91d897b2d524d7f7782b61e4d9624294e87cba9471a9a6deba465bbe4671cc229e79052a602c975a4abd655ddd8fd581894778f3accc2ccdf2315325a1a233dda1657568b25b1802f4b64dba6932e0e5c96d06804666caf4494b01e73bf6e18d9b377dc2465b07b81ca11b1f8b59cf5e30f6d85ea1df6419796b1ee8f805e9c8697e3b1d725a299a44e0b87e866748498b3cc2f4bd97ea6282beab8164af3e1ee99d94db726b48a13a63f9a48442f11dd75c6284689f03de6c6d51892e30a41f42804ced2c334c0ec1a86d9f246c7f35419b9ebd6288b1cd5ed7520738a1ae3e86e4c6a84edb4288b1cfed2a5f643f876930e9942fb115f2a682b3c951920cbdd9bac9db13edd61305001514900ec21ec9105f8a3d7359135411b12c780006135a5384573ef21ad314ace723eb760270b4f14aee1a809a527efa9f9cf4a9325ad111aa51a96795b88be3ffd9c9048fc86f322398e1fae820cc600e2d1ace1e834064f4f7122fc12386533ad526a76a3a28ec98ef57e7fb485ce6255e3a5b4d7c2a34fa9503d512eced017930c6e28045a9349940187b8514725120b12843032a450ab56fdd5737bf3dd56caed3581e77ca76bd1cc49e648a7ccd0be40281c3b6f1d02f0d77a5899d1cd911e297d12cfc819e15b46cac43dca94c87e41e7f0d110757439d9b6b471aa6ca455e2ef7cbda6ebb362e78a577bf40fe90ca9b4f532d5b5611a6f00c9d011100120885e3d6bcf90d6e7584add88c674d1c95664c6afbd8efc47c26de2c9f2ce4ae452fdd4f96fd51943062a0c2109f270c20e6fb6765c949cd023c415bcd002ba6bb2bcbedb1a765a265193308f49c9f3bf1e124ed5e12b000161d45b19bae22fd7a090d69592df7ecf98a4c6f90fa29b9248975aa987eb998e254e7c9d5f5e827b8f00607ca668879db6be0c072b3f879f97d635974bac0ad2343c5f7c335a87dec13d8c0c973839ce20d4bb28055d2e530bb3569773adef870b1c74bd4230ce5204d6d84754a691a442a943ce37fb4463c316fa50ba79ccf17a88e78be91d66c976527a3d12e468ee14173d64e75c5e734c36ae8c9681a4e6ef674e639af0f1cbfe40f492a590d46818716b396ac5b5d7bb618d5af41550cd8c936c6cd76ae934d7fdc93ca8ce3fdc4d309a4135d9b37cb3a0309f2b6ced59ca3ec5f6fc0f60cbdbdba8d57bd5f7043262c306312856f79e972856e20858ac283daed86bb63e5c7e817dba824cd59f90a849f1ec5cb38a75084525126c434efa9cc72871912c8e28c35ee28b149fca2525381fee6a195baee3f7a2616e03fcd17da18f6d5ef7d93756123da86ed938cf7fc04ee45501a000c7d16055f3b405d2a26a8e255af91fe0b2fd567b04d7698095adcab7425878436cfe0051d43b7c04cbbf276d975a5988ca02c8d777b8df643896da3f031317fbbe09e80d7ec9237115f5b4db19ac7efeafbb424992b8b4c457fb22d39d60d8cdafb8ba11a971daf2334e0fb60f51f367d173b362927d91427890e1be23b13e3aa5dc87e448edaf5728cf68799c7f5349e5b5409ce663728a2323e444d5a30eb6ae7944c1a9bfe7fd14cd4fb49a86852d99d7e92526524ee7c39aea4709ff5e736e51ed4f95e35439b8a717a2093b8d78862abb1ade25f3437c7b8d91655a7ff27b96639f10939a2ceb3ff18a59563c78ab81c007909aba0ce459c99c234ede20bdf5aa0993c93738152a14702edaee59d41adbdb61be87e4a04d38bdb16607a3e7d430303892b7b1620e61b11aafa707baed16453f049f10508c95aab0852b44b074e37e08e17da5ef2cee3b4e6c1b471eea66f0d66e07c48a5bfdc064b2df42d7e4ea1472235d0f35f88df2037dbda2ba97ce1db983d4ac089d70743aa6e7ba4d60a75ff9740591efa961bff3027bce1b11d2c02f09bd6a25059da24f092bb82be05ea2908e6496a5139692a2763fe3a50b51ca5baccac146379cf3c1ec378d71fce238e0a112e7f736fe2579f95cb7199ea450cdf11ee9ff53bffb1d38c30f7f48aca007c6ed86a95633377bc948b85d71852ba76b8d9f1782e1d0f22ecfb677c73500b6336cb9de86972926bd2ca3100c03404758fc594ad182307cd7ad42998749c4f2b3c43285957b6d832f153347ee07471eae30fe09928e70fd04030c016c11d565cbd062e8fe56a98f4dca264b3e36b2b0ceb90b69f76dc8af5114ac760899fcabc57f804fc8569bc2a334dbe4956f56d6001d60bc0aabb0ea59ac423979e5cdc3e4c9b9d85b17ea4ccc60323b958ffbd0b9e2f0aa52a95d67a31fbb860f23b39bef0d4edc10a0b9297cc6364470e160564d1ac00723650812be3914f8901e15d739e9729260bdaaa4d6b633415eafd478e024f44eeca9be7caf5ec973fc93a7a6453a1130a2d2fafeab4cdccbc4e2266e7f2e6a21d43502cabafa50d720b7a2cfd70f26d6fbc1352d897d6fe0d9303504960ebec7974ebb044b0d233672be538eb12412aaf5ea25e90f48b14c37a83a5134057af5e80118a04f048e568a177cdde8ab7abd9e0ced970dbd67d15715c81eb387c32a5dca5576eda842193a9780c65215e8a447028bd5672479f5efafd1d72d77c4b9c3f0177faf8b26232560febe02228af8eeb8c533e30db6df3f210b81c9bf9da9bdfe46129d330523adfec2d6fce5aa7a3704d25e0ac6121f7fe9b075dd6d997c96e23dbfbec23ec879d4092252e801096189597e502ae1827f99e3c3ce7745d60647f66f634145e55d4fd75e32c15739393c18529df491036d181d6eb7fd7b2fe12680e5c5eea59cdc1d2ef5bb5593649907b9b3f1f558640f64b9d83f5767a2599b8f046a28130254ed83ed79471a5fd6e229b8e805ffae9521a4e5ffe3e98a349105ef0d7a402fa7197d348392c03f9595c875e16e233393ddb704ff7f76e9cfe9e606745a46e84f02ffcadff84a58612c14659e88c2589576ac3ae323970c73c953585ce59373c61b0bfce41f9c4838eac8ee1042614d8c942a052f4309fe37bcb3c3ee7783eea7e1170ea45e57b8b1235b9990bf46325eb89adda82bd09f29478924187c169b4bcf1b1a74ab05388909ce90aa2125070e4845aaf1520fff1f121cc45ea8dcadd49d8856806ce7f2c33703db1a6802f2051952b355f0742bd86b286ee53390a1f177d15692295ac71f7b42ca70644d729624a380377873027004979489ba8a7c09fb885d7c6059606f592d17193e1031c8adab459c8858001008ca4bb3e8d2248e6704492cd86b40f7ef659d72dfd7040bb4a402b3517887864ee2d3b82425a1235f005b22cebbf085dcecedcecd6ff01b6967230cb13896fb1adb3c01607cfd18318b6808cc2b6b3ecb7eaa74047f738692291da01b3110a05b283769fd68c418addca8d29ceba9b27ab714ac2afe5bd83a0d2a5eb88ed2341f4175b27e8b45f7d42d611f2c272c19421aec7faeacd6bb08e1cd7ca462e7c8255b8a82e87ea5c2eb024b1b695ad093889cf2a3529af61605c4e05f179726cc5e2f49d5778bd3b1404d89a43cefc66934dc7d424535cf4e74d8b478a65eba009b187edc413c0fa66887b50ac26a29b6e4ed54618a1e1e0ee92a2ef510792d3d04a92a6c6a79e788a032d76032b42aab2e04b7ea3f1224f089055777abe6da4f95b6c4fff4a6e5ccaa91a4f6df60c6f588de8dc929e868b7d634b20570a08f90023167ac1aa49d62dd72275f62c3fe30b23e3024828f1ced495651ff7c5fb09f0e00ae4cdc5b9ca195ca192804a74dea63dba8860d5fd4624b1c7e20d47a3e1d4ca0fb2600ed8b2a21addbf91c10d853051fb488e3facefe60bbb02deae3e82bec609ecb5510a474792d5164129ecd747adeadb80308618eb385473a6a0704cacefaeac62d056c38163718641409aca57903821a8b5bfca8330a1929eeb7f633b07b3ff51ccd3715ae603d8d42d3666e32771634909cd97470a18317edfc2911f1e25fbd653f3cfa59e266b899774e1c78d8a203f3e98abaae2b70fee755c5965e6ced0e137f3a4ba6dff063742d325a3cae0d68860d7aef547684d4f1efa0e493c3dfbeb6b4001a215a143874098cfa15ec76bce25ec912ea17a6da115ce65b22d5ac65e0b58b8804fed89383afb71e347425d90f075a5757ac685d724beb8c3dd4f0e6f46b50b70742b14275af2adf6acb40e4cbf20f7be01fe53caa12c22091f9a7d41b386b693ea1fdc3c59bbfbadef834364de2c62db834f05b0415c222cef3ebae879b4d5d95cd67cc8f665f7ff1ed814762a9a66220dfd41ecadc4968e3a24ea5c5d64f9ebfdf43dc7ae7bea361f1c223be5bfce7ac45adffe9712963948ac16f421981e093369c3aa5646f0cc95ca1fbd04f691f1c42cd3e708b8edd51db16789d1635023aca1ffa54356e879529090edc876aed27c14b86c86986bdbbce3b2046897d88d3e16c9e0fad0e8010c0a1ed346b7ad77eaa37efe279a405c19af6aadd888450f7c2fb183d64f3e69d9cba82c39b0d1de22be312b1c394702e925821d838d2f1528e1e234af7cbaa693dfafb58599afb3e804ae4db174ee49b940fd7d2e202e72ea0380b71c96690ccb71e16cb7c92ef1cb8881d55de984e8489167921ca17b161c6b7f2ab4de26dec6216942f866c1ac42b2671c4da17ec940a207aaa911f6f195641b39fc99ae35390589462c3cf5590ede0e44a3800e9f06e46a113c6112bc32f0f4b2472794ecabb783965d81661a0f046d8bc6df2f7bf159db88581d5b74e289fab58d07d61978ea6b205656425d4326b7ec020ee6740c455bdb880c6d16c5280b35c3f59706f5a346ca5d0fbb8a3e62352c4c5919f15e49e157970202f6cc85da5e02cbd3a4ee6c4caff0da13162bb5eb0cbcb510c0b4b83883c72bda63de6ff4229bfbb59e23f96bf9cd8e90bb5232d61041093a25774b735467404876cb099cc09a49b7eab5dbca55d78cdc1f70fdf0550913ed85c13622a659fd1b6e078d8e7df65df011992bbb3b9c0eda094910c62c8aca875c7746182b5a90aedec562b8b91b7c590b4fa0c84a21bb65fd5197ea5c199fe75eb00cc4a7fdbea925faf65f7f80b6fa23761cf04ac715ee5caeef9b06c03c7c2022d5453c0c6fdb63d4efb7a0f1d2531b6b101133cbc987d681ac2134fa06693c54f226818f392adbf78ba81925934e71582f9da4b7ade83cc0e32772222ce5c009265fd7474cd977567d10f242db442f6207a5df83442596057e856b2ac052d41fbd0115f9141aeead8358ee31a87e5d4542ae3128c0bfad2e000ec6f4e39d13e61ba1e76d58ad935831a82853010a9e080bb487bf29c365d8e60898590e5eddc0bd54fe1b490bc4e56adf773515b88013ac1cea63e5d26df4ff1c13ee198b05e71f75f7c650775fcff3ece7a7ff06caee977228634d198f38fb0ebd7f3fb8b737f45e23a7965e946f6636c92617fec9a15ee81ef088cc99b9ae53b4ff76d5228bb417fdcbb2032d7a3787bc781f9919b7d223713025126f03287c14b48b23e8b6e705946b3c330067ca1a23adc73fb3d6960abce8606bac7ebad043a727e22d06d01cabc9e13cce8d118f415a6954f1349cc98ab7e70d159ccfe464915c48417b3570493080f8c9c1e2f25169d3d34616561d4f619e6cc5b2e2ec8c80def7a4199258fd346d8d27c81ce9ae99d6547bfa7271332cf89f2a9095b8fcf03b59fd836f4a4809788cc90adb1b0bec7f56e6f3d7406c1514fb9cb247e12cf0cc933caf3544443fa3fdfce67e2a13b2d0f2dff9502572159f1449ee0a32a4a725b62d8212fff8e0f8cd210cfff33d6e2185db96a2ea3cf162cd334366fd95b90290e2c5d458ac5c0fb80e08bb9c293375eadfa99fe83ff0654c70777b40c79e923dd24f3310352a2f03943ef76cbe3b41e148762d4e9b9867ac5df584ab1ff40d69be109108d6e129e9db9d2b2b840188bfcc2b6c1701341e42320c9bfeb61330c6d813b542f1c483b2a508b27dbb974127c7419fc419e90f0ad09b643f99f2349a06b4be4bc7e1bbefc1057eb876f8161a4566afa63853baaac756cb2c6940f1f358beb67b1db79e1d20c0c1d3c4bb9108483d0615c05d00baef1792567bc10e628051ccb153ce1887b08c8ce9bee806d70f1339105e383c32627083faa1a8c8c069ccc19cb6e6a6258da9dc89bab218d1888f3bd7a4976041c73aa28ca1ad26e1ade84870967960ba521a9c3353d6ec64a67e659a298b8d27be2b8ab43f3426457828a97b6b428c72ebe2e11932b30865866aa8258ec78e768815a854ab17b26a9a07b5bdb2ad0d998094c6a805582eabeaa097e44ffeddeef8e25d4e0e318598534fe02ddde1d7339a79d95bd0a422e718dcc0ec3590ff528fca7eea615fd7ecd0dd5a69c80543130795d156e0ddc8084e7882913bcdec2695f0993846d92334d95416d2dfb0c1af7dd963997948dbd289607291e63bf90024b5553902063b30b54fb30e65cc2d68e9865a8f065f2673985b541e4a99c7c4dd45efac2d575a03772e49edec4042f276dccdaefead04e239b1625fc24cde1b967bcca022c0c2211b9cb8ebc3250db2de510b82f78d9597f72ec55445b541c4c9287d9a7a6f4587f9e46c9446acc929383b364703604ab66e1147a2761b74d59ee85241359500f70c08ecc1415c8fd1bea050d3d9c20828b61554473821daa7da5e7133ba5db96bd8e0e64763a31a717b166cd30cb106817ac2f82835c1cb3c5dc81a430bbe95a5dcaf35e9075b677008f680138813655c529fb0b7cd4ccc415b68dc0e32e0979253572dae72b9935f0b1d523cce3408f297aa2abe74d14c573370783f317cebed37b65891234bf643c6653ee52c8758bb3e5d6e865424af5faa51c9ccd45e769d73e5bb127098b664bcfba15761d8361f8f360bdf789cee0dd4add8ccba11afe0c864d35e33bfa47d19ded4657f65fb0b1bfc38661878a948c3dec049507965cda3f31be7984e1a7244dd053d0ae7a4a83a1e99fab4953ab0e52aec20d108bc8c20103930d975bc171ee33a259247e02ba358bd89d399907596e2b0c96abab1c03c68706860cdcaa199e64c6ed73a4fed0bc48864ee2aabc7ffe4b35e2edc146c754bf403802ebb7bfe86e99e9549c6aa024ab8b0dd575858f86ad18f555681f6ec6129bf8250f9f195a1f9737a19206b7bf804b699ba5992e7896667a0ec2683fdc3a6f02589572c0a888931d2ff2f3766625bb88ed05721a7efeaf233b6894c3109274f4039fe2ed954b13394b953d41f52bafff061c4d49eefa18573741be93b843e5a6ecdef1e72d774b4cb115813f44ce47b29acc8aec07721ce91b479363c8f427bf4301f7c47e37ecb4b62d6df1b57e1c4d1f327e7edcea913f118ace19ea562f71178bffa1faa00c20afbb878fb91dc82dc8053765ef81d7ae182d4adb1713102ad72f9b166dceb6f36ea6a47fea033c53ee35fc9e35699289a9ff2771dab7737bbba32f4d8b0311bc42a143b1a3bf7edc0fd5f4bfed730f5191c6457ed36529c6a8905926a50582f00d5a8242a6c6e559e063db090a3d66df2e70ce5b6c7bd094d2825962ffcc50634278d19c752a3b095a322869686a945b0991870c82c353440cbabdbfc1d04bef1f9119035e791eec05cde4ba71a39c3efa70af06412b86bc1d4de3ce74c1f392f8c60312ddfdfd2bb834dc29ccf1b78aec761d6bc13db97e43c950599ffd6834f808bb3684eacbc5703ad7cd54888bf600d6d9fb727e994d5f0aeadf833cb6ff538efc69271317b3e7cf9bbb5a7df83e73fb70edcf4375cf8dd582f21878be2e3283a1bc8156468d9813895f6070f3b844e1280d857f6039816d2e9d03d1e9476e19f204c877181ed60db9f2e12dc7e83cbdb1307d54b97e0f32a9259c3a200824634772c17070ef1c74cb67af897f269173b5bca424044983228bbd43919d08968f0bb78d4b9c146ded87bbe41eb140cf7512c2bb7e256efc80b9a3fb0a272d25e160d4909f006bfbcc467618c42113d17fa2a3b71f48373ab7ffec626e581fe9f8d8ac8efa590e9a2c05f7b42c8b2e6571c05ea795d749b05f07a48c98b2cd98cfea8739129f44581bb8a2cd0beb9ad8dc7bf32ceba4b6c672e4dc0ee5ebca530fc0ce2cc275bccaee421786c015cb201eb7b9ebaa7dc4cc5fbc8aaf591aba151fdf7ec9f6a8f3f7a3314e7ccb6a06ec036c47e25981516bc9a1b1acffc26f89146af45d79778f76c87d56aaeb6c701e3a7efbec9e4fb7cfd7522410930f7e8bcb9d18070b51d18ee8f5ee2cfc88ad741033137d0e7e763b44db64d48c577c91efdae26a901ce3eb2ae44f918ebf0ba8f9fa2d4994c373856f0d17e2948211da29b09927480c3d7c7cabe9bf6491b8b23dff285d7f42066a4cdfabc0d9fc6344b3225913e866c31d94fa5d92058ced9d7753094295be11694251de1acad0acf3c8650a10dc776eda9add5f295d00ee0e93d04332432f63fa3e31e8b958cb03c831d034b982fe2c5a2888dd298d943202407388f86256163253d39043aa23c3135700e43a9a7d68841eea2aac81c663bf8427a1ccf14489c1d9ffdea084a055a53a3578f3f20a32900db4b3b00f8e6f662a17bc79834e8f4de162f98345d498edc8620ed60bd8d80107990e1d29e627f7641f731642a43f71e7f707e9f228a8ba432a0047ad9f9eaa95237cfb0dab03eb4e9afc478189e47f12d96b1ddb5cb5002fd22da9507e91872665da27b0337a76e1164b89c1a7735491aa37869dbba42866754f33ab7869b68abeb3f62ef1f0ed01e747bf5b7a94e594ba81834746488680dde23718befc13b1fd6211a7ff77573b3b1fa738622fd21805c220189432a55db5c53fc0b6fab411c0130b96f9a5873a171f55568bdffe51a1a6395f7d58cec176b3597543d870d0de6fcbc3bc8dd981631cbe749235ca216dd6ecb332f011d2e8460f3073e76b413e833fe90a8556124bb0cff97ea66999babdfe61893eb5bc2a6e5bba30b0e0db9afced3c305da0b783b8d1f6f4858bfc04f66e5e7aa5bbc8832dc465df509624dc21931e0790934c38917be3893ad30a8d7c47e79e9dad45544344375612fa28a2471ca6fd949ffcab1a649f0bc8ec2740b7ea424de36fc6c39cccea570c5a769859eb6777175bd144a57f190ff507786399e45d643dea655d1957f9d7386cffe250970bd9b2d475a4e242abd0bcfabc9a8c0582aab8f0cecbcaa7a653784bea2d953c6521baa036c0d478dba9b42123045d49f17859d8fa67566c1f301127d06450def6906962c5cc535b3a708526b0303c22bafebcd34b0980cebb3c657cda0d94d7b9a1dad0233c7a02daf2b1b76b4e859a76a4e9881911f2c1b3406edaf2d6108f0039569c8227234130837c71ab7a3d7e6f860db52f6304721d6e6f93e24d6b5af7a3591b92552f94c9de5f9d9145f05378c9ce3f73727959fb2dde793b413ff18ad045005b5eb6463249ee5914f5e199eaf958c28c2e45ec3c0b3c62b3df92e23a38fb58cfae0fafdbf1ce0389ddba4e90437894799686cc51fe619641bbfdc095dac595e124a5208b11bb56b444258bde583ac21a96b25b91a6f0634bc272db49851e2c7e470eedc05f28248b9054d4caf8a0ffe9cab32ab33d194e139b0cfef2b5c0a03d9449fe5a91235d64d1d27ce5250da93b52e780a4f1793716f7bd4b2801cbafb213bcd23c659512eaa8d8c95c0dfba6e4353d8d4d997e5996386cbf9237c86da874ac511a5af8c0716c9f8f4ce847842c6d16e0372643a231e5509dbc0dabde8a7aea1dbffa909cca485d9b16d5f6877b3d14fb353f47ada955e10f6164435aa58c6827cd10cf931d0b31c19f17db95f15992e67b5ee662fe6bf6fc6bbca2f0d36f10e6b7cba0c9e693fd7ddf4c673ab78193450659bfc1130b9a4460af59e9268975ce9d414422ad002fd9ef98ffd57ff85dcd2c6a118314294a93669d28a94025465876e037b91c61a544c8b4a6507bee5952f0ea8292ecbc93d88df74dbfd286e323a93a0da89d41c14571cbe8d3862d710996d31bc3a968cd6107330324de5a083da12b6f4389ac210f31cd23689e63b02f97ea38cd320e13a2add93125f71db91eb30a414f9002a70bd3f563d8a5e459c931757c43696ee63d155708a2f3576283551949a0fc5e41681fa5e9b4a0e3b5b6fc525e6070e688fcb1e3a63dd424f3a61244c67a97124cf1089760fea863f1b9d26eaa7a995840824e8b3db5d1a97289eedcac4d08a3c255c5a7dbaca6d3810bfdac7e198ad86f624f1fe644fb97b592c14a6439004b649e5fee474faa54f4145c3457eb7f8e252a15d6733fbf5402146842e69473c719b184941b22b4c11a8388ee1bc2f326b84d1d5fe3d4d3a4d04938f1bbfd1e2be1ca77bc2d2cf03872ca0608af5b8ad36ee081f5d73f9b8bfee1b0875f53d257a920d80bca9a657311db533755f9912b18b62a0f6ee908fedaf02d53de8ba699695c4618878544f26871c6a67f3f3972ce585a303ce11804da6b100df79d2290c34e8cd65a33df9ecdc2076bff6a6c628f93424b6ce024fac0933bddfd6f686889649de1faeb691a41186d39027c7d612abb9585c8721a03e54192703b832800c15b0bb7214526957cb27b6f0fe1f3409b8aa17afe1044cc6cc5311fa7679f7f02fbdab9776d1ca6da860192ab472bd8fb4eb32028b5e15d4e8ab9406c9fffbc39838b23fa7c50c867657af3e7cce74825d10d90f5b5fc1373463ddf6833087e5500f2225d533d17ac42c5735c7bd9fee7d4f000fa189b312af9ea67a2cd7689e2b1d844561683324dfb95715702ed33fd2c15ad4f212c68365085a68d27a7d3801693cbab884794c7de4930d096a71edcd0c2ed45681dc01f239f38a6ed5c848ce65960d15cbbcc7a359251f21acc985a76dd96e0dc947821588f73bfe7b83732f62b011991c332c52e18cc15f7f7a50c2fde31f97b9aaae4e998b666748e2fd2e9b1028b6c2d0008db164a6308377e918ef108ced9fe88ae79e618e725ff3d2d45f4f482da9a7369a210ba7f12c5d2957536a7cb0437c9d8318855905db40fe7021a0745167094ff4363dbd813075982bb59e134b7a36b0a6b4f3d2071917de37b35ab631bfea9aaf6a4e920cf3b637f34a752473a01206c4d989e761f727fd3ac9cf7e934003f1bdbf497199f70f1ac7e0d754da57d04fcbc38af6c361ff4e8a506fffb57dae453a4411421177f03c048db9ca24b99e4cb57129f19c3436337536608d78a81244474f763678b7dd6a9bef6f30c49d76804fd88995e92641f79b798e2ae132800ee47c165b14dcdf779e9d4da214ea49848c51726d7f4c2f39d52f021026a6ba0b36d4750252f5cd181ae616673a1ae23a3b3f9134e7c19fe4abb0b3cc34f906a8eac24dcf1b2dfc7c7f3ac21ab15a30a8bc6757d0a4a7c8fbdfe68ce1e482a0590620c3b268112e75fb5a1b5614bf8ef6d9339ef57905334e64ee6649584f91f9bd0f7493f8ee5c2f81afa2890d5f59e44a0ad4f86e473945e667c34ab516fcfee196de17403f4e15c24ec543c7057a3e9e46ddbc834549d7886525f847f3e3b2025444dea7a8e8250e314f10a03c3190d5a4f2afdc46ee479655f98637edf91cd2a579696d1542b69fab5a643ccabdeb1bc5ba18aaaf5cff566f0909d549274b6fce7548191833f266aaeeb2657c4cdccfae6a2b0737c6e9610de70aa63ac55196d5891d87ebd85af65fb3c3105240a3874b60b9aa0c6ab0f8749b3b0b98f4debf338b1bbeaac591196eef75aeaa1e235f0e48603b998920e52c335d0abcd910897e2339dbffad8ef01d217e4b425fb1de9d1595389e4ba575186930e560619f85574a084f3e7f1f7a8087d1921a47251cab06bcbe039734417c1ec8048670a678a04a75d3e2a25b347d011a6c797c34f2baca2855666e9b46d026cbab8331dc443236025f90468d9d3412e9eb54bc67c202a0ade491cb972585528bc85571fd2618dce70bd7bb473cc319a5d9adbbbd2b7b6a6c63998fb5ee6c4654a136036b28cb58002d63aeb1f6876758c36684e95948f85ec3147a8ebb06fd1d7735a1dea73f9e77c10efa7a5a8ca4b78f9c25e461e17fdf4721e8cfc7e96171ee215097f9b9edcbbd3a879716d1f483c79660efd50d29778c7228e920f55adbc97675e4d995dd0c409642265e2874c3539418552845ee9eaec5ef7d75c08f3dd958b282e8317777b2b25dc1ed9cc4bcaa20038e6d9ec2242c9f09dcc077e8b98a06cb40b24e6bec3aa42bb6e68b96c05021aee4bbe9b0bc833bc83fa3db516ad9cf9b2069339c19a845084e879727f608d88b31c570711c48fc64eeb89882210f099003eb8bd031a4aa952dd632c85908348383c2dc8672a3b9e26cfb77b1c14f991e75a2979921817fb8650d555275f16656cd153b75ee063340f69e85e3901231e0976cff819b7d2fa6698b6441399b18a41396637fbf3ace575d05c19da16d4b1017f70f4b22f484d3de12c94f79b14198e2046363e466b8aaac5c416d8cfc4fd8f6fb5ffb8fe9865510b85b1fc1d12bd1e625aa213945e06e67177d5830f84a95da4e8179da1cba5bd0bc90ac649b206fd204a32294e115b365352750012687de241125ac5b7ed216e0de56097ddfd2c7436c0b7f0c866ed70482d7f51dc04029040d2e8974363974de1681ac8556dbcc5214abd11804de17a753ea1070de3bd1f80b5921c03984d58ca59be2d285808249fa1cba549e386195b68d1090e6ff5698d059d9bb19b0bb190e96476193677c1da0dd4a2c8a1adb6a5eca9aa8f2f90aaf1410f1b1d04c987fd0f5fd1d2d9d38bbade8379a4b26c815ce3f7c740aaf29a5431e52833d76580c4309a0e1986625ef7a7bd2b42216732680fc48c0555d686203c4160cc7a175d48d974fd6a946f483107f6fc181e231cb1c5b5b9037692fe7a403059a3899dc96496b3f399b0e488a2122dfea92a03406dd39268ea0600628474263b91195244a88ca66cc77eedf93101888197bd16b8fe2e84298a5ad3e9fc775a391cc5cbe315680f101968f10c0f135fbe398fd09ba37d536ee869d10b29d6b571c12595d242726045eae492d75ac12b562de1de37b9a3e4344afe2b04608453318417024821b4839afe8b9f4a2acb41958468138720b4956f766d633af2198e26a4394927b0a900c88777b8e38efe9025aab464e3ce3e23422de1a98632ae27263f74b8b800278457a2ef7856f8677797b4adf4d478cf0e85d06adac04ece7d431b6ed503d88a5cc6506f682c864eaba3585a3afd3abf90b7e01e7f43f8f25a23e73374d9ba1d2ac4d572f5d70cc9598e947cb66e7cb807d67f37d09a8ca932a3849135a1ddd03c2a804dc0866785f253474bd414e88174b3040a07a6cabad6d70e1560a26589d1e74cb180da4a55e58a7692f74cee56e3a7a78a01f26eed86b2c8754be3add6dec93414c9383c39cc3ec75fcdae1216db38515f35f936ba9fb76d837db5571be5d6f76a5c0331a2e93ae68c3d32aaf877b43f26a6e801c1f79a9bd77da2c0af45a0839047051bf8539157fcddafbb9a2b94c589cb7d098b6758821489cb413beadc0e31bad41b93177d197706dd75cc7a8d8ba00477ee306d9170f5c357ad2be93ff8cfd81fb08a3ade832cb160b46060697f6f3c0a714477faacdd3d01e7320ca11e73c8e195c164458d31a43f8b0cffa3fa2afa6cfa7a9835aa7b798210160881ad566c8b69e91702c3e388e62bf0a18670e170a710019b3334d7bd899c7cc6dc8fe05ae355dbb1eda9b54a3813ae70199b333b6c0d4a4ad9bd63a3b100786e29081877ef12f24840eddfb64c8f3d605629a09f4ad12e4a6a18db2cffa24404575596db22ee8f9bfbe0752ed61470f7079bbc3a3df6c50718d63f307f2c533fcd56da9cd7cdf6ca05ede64fa6022f0c5a6a2f2c1de3c6955663056ca8560b925a9fc273eb042fdce783f9c81373d822c36555b732a5089681fca634f004572a64a401f5962a2f86137391c0e1f97d0526062c8c62adaef6f38ec41ed70def0ea921718eab3ccd652f195488c49e3fd679f9003a7c3f55f505de2986ea114423be11aaa0e6573f4e3481ebfc82bdc13d6ec59b2945fa260a646cd185c5ad53467edc0b7dafc0c694014138345989fd038f0cb3ddc11d345117f533b8694edc4cd61e2006a8f3c318212d43c21b8fc8cf12918c6336a594c7f75b9d0647ced5778c54f72ce7941fecbbe7e81a1f115d0169b43a6f9178b67d2c867d5ef7f5c413fe2edf48f1a75a7924b48d4bf1da072098116b3b3ee0298801bb6abb46e70d13f6cb7283749dcdfe524ecd2a2d390ced4d9d5f1c775281df78b458286cf2a3b7395f1b0eaac2a4f89c7cafe31ab03c260e9903843b12f420b37b1624341dd2cabdfd59b4a92560c7bd8d7f08673e344876be55e9c9d515a00b1d8429c9c00cee3161803b5fccc1569ded8c458fe2ab404e7e45fcd0302589234ea080107ab70bdda7aa485031507f23e04f29007692fab5af879d3b70b44bef35822988125524949422f2241227215b911cbeb9159e62b0918e9e678911d3ac3561f753f8c8dc59b183b9db51b22e5370d824354a84f60961af0e496a589074d0b675a2457fa7f2d0d1b5c7028bbddc33e93192cd97295dd89494459943548154c35ae25a2f26d13d34726569b9f552a0a9a73524462dc926688a7fe18b88a117f6bc4b00e36719980195b5a56b01d342aa8ea0f6dcd4163c81963e952836c42aaca1069f2a2194fe26c24285d5025a4c11aa387bfdaeb5db130c571de966abb880942e7e00d24c1ac5e39cebf1f6c2a9961c3b9847e28813c7acf8e92f2784ea579b6a3644aff42068e76c92f7060f4f1fc43a7409e9c0b64275da3596b69d199dbcbf395843ebd6fb9c5c01f8b952f3080a71a5a1222a1d588468e2d77301873643cc515801f21666c52385a515d87b10db4b36d668e5a9b62de1842f63637004288f14450d347ffe43c349b95469fdc6aa9245403e465ee7561f009be1bc68241f1945ec06986bd3e683295213bd166fc9e5ebbb8477ebd5a821ae673fd3b95f492d8ef2582310d804436c71aace144fb0e82da6f74b315c0fcb55b13cf353225f2c29967f2113d660fdf279f91084d6b6d6dd7db159762e3fd956d8f4fc4b4cdf09e0d15743825e74ccb09cf4c82ea27171b2cb6f87a18afda956a5515ad53d09c3a750cade90a2fabe8a9e2d9ce96b591f373cf49e1a0f5ae370f6ba45767995456241fde5b1dc1ee4c3674f43e764ec6d7f538a1b7a1c4db569c1b7c5b14c0c2e678e51990c17315034b39f3e861eed1cc7d3ccbad2b885975aeecf1c400562df650dd98fc232c9bf8c4cee894173434620f902cf78c02d7eefecef6436c0144c7d0262ffc27e5a491c3904a96bdb0b3cacc09626eb2979c0fed6175054f3a443ec12d8a5057262499c797de73368981376f9e73e129786dbe3bc00d936168d7f55daab28d12b5615d5e2e6d1a19d503dd5f2d5ba3347f556833fe4ef99b535da78d62fdf5cd2a794828fa2cd6bd62fb2076e0fb3998c6d8a1c0423abf21431211a81b40bd3d38b0c8f9764afb51272b28b869a6cf8f5d188d15c68aef623409e6227ac51b8a02565880092ba03d43134112cfdccdf199aad6959703830ee95dded95d3251d982be895cd3c74d0d208fc89c5189338fe3ddc0e7ffbd06f894e0d515b9e36919158789fddfc9a14eb48b6efd1fc811e5dc88d440d5872cf77a254d828a20d34703290931d81db03b3aab842ba1ad882108258e688f7a41cca9377984292aeeec3e98e2b04aa9218d967f01aa16fa73976fb0203dbe9fefec81e98961b95bbd894f8b1929b52b6930285c9108fbfee1c063f14262e348243aa30f2b32e0b9b419b4177574eb71511852cac9335762ef5f124344d90bbedc27db96cfaec0a76bc381683f3b25dc503d641cd4aab8ed511cc4a0a8a84c930ba54a909aa2e3489e028f9e809ac6b82b7436790af2c824111eed00cb4a17255a30dc6654403e1f815db06a965ea2faeaf9f3721fc995fc52cec6c2d20cc9b0a73f56ce74b5dc6f0a71aa836fbc9799d70db7bc0f59c5c448f52035641624c62e60531b4ed925424fa927752ca68d260230bf64057cd23c10b5f8f79f25e5ef064d83452a8c898598dddfebc48ca204ee325052dddb4631f1f8cf30c13f9ce1144d44e75f5fd98b77d42a6d98d2ae840de3e578230bf5fb1c8630bea8553a2bec6956289aec314f5b80260f593dc9cd1ac666c6f10d3e02d7c3215190c7ae407b961b3ec369e0355b33a5b2d44c5fb81d88229fcc0d2bed1e5a4cbf1d28225418b0c5f5e521a17829273bfeb7cd4d9fd30c486fe6a2392d0c06f9a7cee3d11641a8878bdf4dc5b149423b48c29318a624571942a36358a2ad33e558d086100956c42169177b74a75fba9b25788e37d037636fe263560661910d3755f6978af49a97f24e94212e289d8d67cd63daec272020dbe7dd4c2a5d5c5ed608b1dd466fc03be1fefed49174273b780d466b90c3ee01e2c8afe3f0dfe3fb864064ca43e737ee5e791f7ed3a7e590bd57e76593831614b8eb37bd57c8c228af7ddc1f16edccaf970ce88be06888a2e47d47673edb2737f47f2d012e25fa3898ab88420a9092995c734fd3d4a2d71076423c40cf2d8fbda43735fc55181734659a96409e6e79e2d079eb549b4b251ca0d47cbda1766e8f0b78facdc1477d5257b3844848252b0eebaeeba4eeb1561ee1f21d6088302cdd21bf69d5a94e8cbad99b3c5b87811f96f9c64778a38a315c77c6ef0e8344c3973ee23af3209ac852bbd0976c992514c44c71bf4cf2d1982ce10412ed044f644215808ea34c1f56d39106758319ec42f5bef8d8ce267d598389355b64241a5e4ee92b472d1cd3301b9c83c93c582a03a2dd1a4898ef64f4aba5eb9c09fc19558da67015debe440bc760dd459b3e4875463992b09003c40391ab6e17f698565cd0a199f60fb71fbd72e6d66cafb447690748d3c71405fcb9eac47f024adc25b31256b8bbb34bd0687c885a73001a3bcf5436d82fbf420d940684a93e79b51840c50c182980b12ca1c03413c2517095d1cdffaeaae83426515c4703e03d5a2415ee534ceccd37b3b96d7a529f5c102830d3ebb028843a44de67d26d8aca7724465ce1157b6cf0e5471eedc9ae40a3274b921f2ea9e623da1dae9088c3b72e9f2038e9e7f0ca00d2af6e67121f8410d212452bb40a2845c2f45f70f9af27585651f04ee169b9bac7e20d8abedace0149b61889fc2b8dc0f8e59fe1f52fd77cf0a776d55869d4f1fec22bfedfa19f7bc5cd9c272e6d1f4a39de910dfb34361df20f99b23d5c9f7c2d9ec586a42eb3136d231b389a09f4b5b45cdd3fddaead44e9b8cd66056c91d79e5a5f1229a9542f16841c43986d2084029e6334e490587f747ecb5a7c288f0922f797920fc48e07b2a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
