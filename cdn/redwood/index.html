<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"be6a413093445a6a1b4ec3b40f63322e5205a3048813867ce802d24fc048252480cc368457668c907c9f7afde6bfac941fb79f57df28b25af54007189e1f5f848fda2e3f9c0161174b0e41cad2af39b68b28e736447c634c98f8a9f810f178f4e1bacef270a2709f69585ba3e1086a6d6fd084cbff22b417d45ff29337ef5a012690dea59af6c9a1922c666121280f110e4228c24b27b58b5ab413bc7668286efeeed22c1b2c2d965c1d2773a6137385818fa8e8f3be296d50e0cde3d9051499a76d67e8a06598c6078d9e33f8fbaa8f7127831dd35e958c49a7346e0da64e9f936fd4f9def813083014ea2b23e125ef5ebdf4f2072bb6652eec638b4742c4ccdebe32242651959d5355f3cefafbd6bea5ea0b75d235f7c854489f4364203099f0e8c838298c57f0babcdaea43b086336bc0159857388a747a9604660f2e7fcefa7102f0223794a742cc62dcb789a6753dece50ab57a40b830d52aad9b744cdc17c8af029360d2a9dee22460b83432f6437a2ae2d50dcbbb72d4cd37a91d4fe71da47fb05f19383bc81738226a53b219461bcdecf7a56abcb3e3048deee83fc9da0d390ac77b2a760727f367b508ee6d1cb0e5265427d3fc82d688b13c5399fae47ff34809262a88ef665dc98abcee01242576e497ade3aa2e0e853aac0a3d93e78799f284db39c9d862a519f8f08379a351e0929476f58efc7d8c28192e26094679ed493b5ae849567d10a3366cb9198237a2be1772e041415252d27226b8af3a54733dd1e5a9a72a8229325d8b2b5db5b50fccdbb645feca50214487801308349c5e5accc3530b18e90ae954fb05f34615156c94d8e544476cf6157d2338819fa3784884421ed258b9a1c6f795f00c9c2a60300ab1b443b91cf36ea0c78186e3b942551fa407eba3e2ad6dba196288b7d8b71505f29ecd92b91a7b0d5c793350933145e3aca97d74255d76e99589604839fe9774da24910f8896714ab016ce95a942b14509ed276247e3bcde494b19dcc901b9911596c3566c0b04e8b201f81d85e89b7f29f5556e770b74a4cc1c919a18bfc160e6f7a724f563aa096f0a23643505ca332f5e2a197e2875edcb6599d84e3101a47aad25f7b46d22f0b9b5552a1ac45cf6ee9d536d182ffa73d31f361aca2c19f24edf3d40bcf80e750be8972f159fb603256bb9c2c425ed15cdc64fff6ae63198e34de63f365fe4ac9049c29f384c60970c9928e08c2dbf861dd80dfaddbc9178d77f16e22ed79e7081e5f2c5023422c4e47564da32a9ab5378e5b907347e0e5bf0b01229a513b5bcd815e1beec863d3b0476b040be9222c4fd43f0079f58d2df87b93ea347ef60318f051f0fb0a181914e2f500c1775edd5e3f83fffe470296ca5aced97d3c84cc77b665e07665acb35c1e15ef6d6cee95cdd12007e2adcb89a884e609ae408f84c0f2e308ec5d141b64cc870accec92e250d9eb90a3243b7521465e0ceede3e0da4039dd324bc4943b99bb358ca75bf87a0cbd80e85826d9f017a982251ffebbefab426cef14151e3feb33e281b6d7a30bab1652452fd720ebcc3d0310a62b9e614be861098946ad178e2811ef20fb457a18c19d1f5ca4cb911d09e680b6db6588bfe989422b9d2613e735d7ec2f0d03c4ea0049e86db3aca3ee2aed19212aca85fc18457882409d6fb80217b428bc328475a7db26d98e21b9df2c12c7d8778c9439e8148005d3f80348f08a0e4f7ef4ff5b916f013d3a5fa09f5fcbfdbcc3d9dc255abc0a9bef4b92520ac5e4f38eafc00297414bfb14d68542c41a667f7c47b7e4f698076b4419eb9fc0fa6de0162a2ff9c81fd64a7ab4eceb7538df89fef61e66d5b2b970e27a751a355e90f09f501a6e565edb55bd58cb679ee7c533f94612e4582f0f2a546ca2f0040fca045cfa6661fadd3943976bfa0ed16c328f4520b6007e19293c7452bea86d5486a10be551b1bdc41e12a75e2326818e39ef2b809339f5b703dc42cd2e2e60743bec38b08666b55ef8e257670f87e300b3b95fc6b6dfbab60c23bb316bdf8a33dcb3539fbd9040e57a04934d19cd42757f8e6318851c4f4e443c1ea5fa329aa3fa37dfa4b6604a17361b3b7311377a4057bd84bda0b4ecc0970359276c1c46d5081d841fb2f0139e24d8704feb93ed97c182572be584077c550a1ea6f74c82eead99b7dd6a252eb3e42fe0ff2d015307bd06fd460fe332912441bcdc66da9295936218c3ead6f0e011cc78f5c87a0bf73950c4a6059afd37c684b4135792cad779e4c773a32dedbd4f7ce2f29b6bb6982410806fc315ee49b4c170a074818438f8be55b8b47f923f74ebaa0b96f781625452107295e9c1be7a93926f189f27c05eb9e7b17dacc62689bbf373a645a63d9c75c42601d41f869e2c5fa2b3dfe368ef3eaad75b9cb56d4b1993deecf5116864aa3139a19569ae326fc2b01186293d9d5d297ad96cc8c43ba4a4a347f961884d48641212f36dec701245c0dba3b4a698536b69e574ca98ff92e7772492506d7b30865449ea522c0160e5ed9c555fc6c2f7876ef2aa548c2ac96bc1bc0bf04ac37cd74bcadef904f93aedac87b23f3161b2889b05e80a70b4ad4e22d20d829cab2b3d65abccfd1d584129c1d35611fc4d34bf357e4350468410080165862cff6c91746b4de3200fd07747f42c01f894e3e9cb255376f32a888bacc363753af448374a6fe8862c5216fb4b2eac725a083ab409500d9a0d0ad201bfb8d4fb5372d1990d039dc2300710d8df40f5dac9200713905c38c329c438f4ba1d0347401343a63dbfc4609073366180f45e7124a1d6563ea708d0b30819624940bc24d499bcf55b332c73e87642f12547074437f11907d45a63518a35d0ee5733f49d1614c58b9c9e142cb8df0032185ce2ef21f0efc2f788f32d52ed66704cdd344e5c1e2081f49119ae456a58d726725559d276dc022945926c17add14a10818e8fa108beebddb9a873a69684ba59a138bd29de8bdd47765c1614efd201ae7e65fb01186016eeebf28a7cd4ce725055a09114c4bc9b8d8917c1e07f80c45e150503243395f08ecfb376e3a7faf8667732dd89f205a8aea93dbb6cd0179bc5a0bc8652fc4a0afc1dbddac7a0a8c90807e534c0676c78a26361bb32a8a287636f13c99b05914902892cb6a08d774537a81a6c2308b21b4fa0d30fa9cd2412e0a022a177e844080a26d9ce1a94fe79be6263c413c20a0370919814a1f368f7291d6c75adaeebeec4462644246abcca6475a6ed46f7c37c243a4fe4a61e08e9d2c9f8fa0dc1aa9020eecdb0df9e851a6824980f2a50e966a1e5b344d27dcaee2707de50d3009beba800ebdda248a26958430229185594911c0e9df5a9977bb149a38721579c302a7a48c76a39e5c552a57437b14f50005af749783b15910fcb325ef230ce90788244b0f0e2ae287fd6b54651180f824ee63104ed621f02248708728f784e8ec2992293dad6fe5a50de729e0e8b8665d9b509d0ea33e7688d47aa5c8805b415582645ba061be19793ffa1f08eecb7dab597f8ebfd8681b4bba86eac52cc1f26cc028a3db951911562ae53e9836a855a68ac9c76fccea91422d9de1bebd3fc20f7376b34c369ac74ae38b6da4607278a87bc50f687e6eca37064978744121cde82c3155e01c9072b6306e3e865f697471a1c79dc24a2d2ed1cc43fadcd7c5a1a7bd23965a0fe284f28294cfe3d6b4e07c9ce8a252d83eb2a60f24e5b248238f6b76051223ed066eb08266c0ab0f0e39ec234ed6eec7c7c3f43fb68fffc3319e3253496412ea372ee475af2835fc21057a4cf188e25b4f350251e3092e9037dcf0fb3253fa93b4abdd3471522c3a6cf25128eaa3962959dfc6a096eaf907a2132f4bd60620feecad9849930c36ed219773da25a65454ee483552bc804d62249b375f0203d1f51c512ef16f4d14732fc8b7e07b470342b9119ede3c093fa847e0ad4d2d3d57c2397f8a78bc9353db95be61adde1de5e1daf31874968d10bff16ccd7834bc3d3413b73f41eacb83f78c50350824f3f82f46e073508c4b6b47292b0c724245b77f6fcdd4a11c5e53601eea3c8125c91240add1a45c3478ce3c8580eaa59c813532b89163fa3712fe7cbca6101002179f65af5af91cca819a04c563048b21357be6a70840762b5a4a539aa78847f50582bca2b9ae8d74bc0e3272e8439580edca170e39d486f0af8f06947c1ccf97a78dd9b0b308300dfb01cfd1c3bde3eebe0e985753072d6411810a039ba6cbd1be3c407b824c1d7149b514727c35cbf92db410cce8c7c25bde208f8de12739fac6ab152dcd2cced714d5b554f1175383c451fb9bfbfa91cc2a453a0921c36e268ef47cfc1adca8c140127bc56ee3181fcf8949f3f9e20f33b201283ea18c9eb308286707ab49c6245d59075985ad2cee77eb17d6f54419ba86792f695112cad620fc2ef4a420d3054ed4a0072b6fb85a6a340e2dae4816ef299422c2f8a275ee2305377700dc7dd94829bfdd9f7d3674ea5f9829a43fd2f44e4630481692cd2e47ce16688a5cf6fa21508841e0a59dc77f1bd117067c2a3a0e04ba1fe31eb4f0ac28daecff05ccbd6676c021a6dcdd3660aeb1c888fad8a528c90e89b39a19946c805c049fc47ccc33c7535107ce7b1fc42a519e51ebf921dc481ff920e8af3d6a7060993a719f0f70abdc5efd136f21beddadb8f556c93ae430f7f5c0879ff39abed5420460d075974faa120a3057b3c4ac41e7410da629811fc35a573e68b38fba1d3fa34771baaf97ecebd6803be98eb4f2082bb5516d562f0fa9ae48a3f4e10f0649ea34934e9bc332323dc427c954977e2eca9d268197301aab87180855812fa1e33beba4d7998a5e0fb9dcdf28be1c2ce87d4ac883f1fb1b7428eae2c383017932f05dac3115cca78f52952a917c0512431666d8f03526947e6d1fe7c95da7519b773e63dec92ac8b13fe4c11ad10c7b2939e351d279ee45012811b49c8343e99637355619abe66b3d3c3f99007c5f2d3733189865f7aedf851682abb51d3e2da45fa3b855360f62a669c6226ab5f33638f61eea76ca5c2f45a3007a2c9b8576c942501d56248d9276af1c475818cf3cd24ed927b714f667b0ab1208d749672d83f27d30f6f8c6e31a2d8c9f30ace87a65feebba77f90ae2dafc3797824c240d82ce32f07a40a1429864d0c4b2319454d3a2c7293733197be539ed01849e0e403dfbd98d5e9e0719eeee552b54d853e5228666462f9e59567f8cfa4572bf36500962d92bc339a81389bfbcea22bbc9ac2ccea1e83b255d000c2db14ce96b2e1643c6a1b0f0b86d81d057ac05d0049f5c05caf1611a3634a350b1b5b1beb0475aa2b0ee030ec10955d47ad73f819406ca7fc84799e2a0b4b32ad1d19db8e732e0667ea184fb15165f83d89e6f54f9477c25cf41dff2da8cfab8c7a5811036bc02cda48f42c77ecad4053071990c0c2aa21588f284b2be02df82113c5d698ca92ca5f6918590c20043a6e4b74dda1480de1fe61f34df928ba73111e44c73c1bae5fea730af771776bcaad928fd76ef0b42fd3ec5f88591bbdc4d7a7d91f809f5aaf8ed033fd0023812a70ee37768bb6eceb91431ed8a26bbb3f416b82c302501b0f841cc91c625967dcf452d7055bbca3639a8433ab082f8be15db5019daee26fa2165667ebe2299510153d6c675acceaf816722f5278e9ffc637ba29f7c0463ded14aaebc4cdec4127a26201188ccf9733435dfc5f0ba67426d335194d701405cfa7cfd8f61c9814c8da8074205dd4b756f2a41e75758f5a6eac0643a938fadbf4b67908a17fac12d4fa76fb70262f7aca1afd337d4c79bb7f90d29ba893345f9540113b05532baa4a811eb1ce7e1e73ab2d732afd237902b5f643111c4fa1c91eab21c68bae9e789936111491d1ffcd796ed04cd6179307713bfade75d746779992fc31f56e467b7c20d54edf3828a7d51982663c611c7a47df4c32c798e600027fadf5e2aa24d651bbe7d9f2b8fec3a0f5374e60fec323f9296b9b76ddd9385f0fce8f2d97cda24970c8dbdd411e311fea5791d5a5151c92480f44cb4b7e5e0ac6f177ad0f8e368afa1244ce45f82ef18ce18ce85b46726973def04c715d12440edfe04c380b2fda191f308dfbf51cfbd5745284579280e510098cdc8c27d4b18b939b0cf37edd15469e09fb7fc88caae721ab404ad62509d19b7f7cd9005c9251a5eefc4235140c2744a2e0ba9d1f609e59860455f7f55b7bcb6fdaef6fead65edcf433e20b4831334435b3bd06aa2fb6bf033a6adc3ae80a173b9dfcd4c0ff3802aa8ad076e4ce965c614f25b346188e1c232f264fd122acb5c3aaa816520845471a7d04f9cd1250f0364adbe5df8ea11f93bb82d9032203a8eb2e21f42a2e731bfc32771f022ef3f359ea9ec15d0f835cb9e719028edc1e6cfbb099bc33c6b371e3001b7ecfe4c4163e44c373f736b44848287d1b37ac00ba22030b54f598d8c173e23360ee272d47c726f7d49240ff37299c6e76f240a9ad6b5090dd1313a7bec09d6eb38763b804fa4b760fa69b1f29ee96399cdd1e7adb7ed4202f92e6aa87e06815a0d65abac2aba60645c4f44da3ebae3c200fe4c1e36dfe47313251a5e75c72604d15c188014e557132410ce1f86160f05f8758c776ffbbd4c00c5eb3c0fde0be83f8be74ee72fcb4669d0351651e300551370e7916a3d90770ffc3e6f4382cfa691d3408aa8ccf5a4d4fb96a2630c607bee6404a92cfe2c61479e066ad21c63c9ed27b4a31df370756602dc632cfaf74ad958a2146cbe8420d8443a393ea1ac0da946de06eecf7c6c082a76802a9d96f8f8a9185a3ef67824fb31c62e116db10e0e8db93387bd5a65765e6fa3847f2271b8c2190d3a3a7d6c55c83450e23d885af9cd3e08c1b21a136c379906786f5a6a96befa85e41ac9df29893b2aefc75148046d768a8088eef11eaa1ced141ced3f0ecf424a51568b67d683380e0e90429baf08bc7b80d6666d7b082614e5582b3f02a42f51d08168f9fb3f8e0443b8a556aacb0aa7e4ca611ffd9fd55de6ef32ffd404153b65e16f692b1d88d7597d4fe20eb0d4acb8b70a4ef2b72978bce509c4a4e9bced10ec5ed8dfa0ab0701f81fb85a787c32684acd14c140ccb98d011e5badd2f080949187e5c1f8a450089bb8df1650ffd9e5844c731c016b114ca5f6e9940cac422ac3ebbee616731e4f67dd42bfe9f435d4a3493ef034bdc65a14f5270dd4c2faf89deb58a2ec99f774d3802b4b0b219f278dae41372a6db7545b183946e091eb3b538196bfc4d054ac79d39ccc8a5d82088aa18c1984acfe6581666d3670358eb9f71ee95226c692571b11710cf90f7b9c91471b47ec3b39387291c05fad653813cca6882a32d23023186e54049865ae07741bb43fa3d2ae69a98060b2eff9f167d42eb85f9b03b8efb12c36cc20061b7b58c9c82a00603d50831bb02adc9114b59b016b6e3dbbf32529a5c70ec84c7fe007538df90dda32bb487667e50e735e8976ff85865c2fd7d31f938f5cdf6b925f37d3f82240d097ca1510a5c7537b4debee356128e4ebaf937e79ef43e1c746137ea0535d865a4cd6f62ec3c87c0aa49aa5dfcb1b705599f88dc1609003298a1b6ec267ca2c6138d89daf9f2f4b9d71dc3a8d915a00aeb813bcd9537d06d0405deb90eb31a6b81f373b5534a63b521c50416ac16e137c484729edbb80ab1651c634e46da13b5aa28cf500874227debe8702fcb4050af0981dd46ff79bc94b5a7cd6ee8a724fcb8f51e87ea64964ec55174e16fca10c8b63090c5b6a9a94b8049482d4ef23deaa56f769e43d0a401d388f6ac61dcdaddd3696a9e270212da7c743578da32d3bfa89495a325dade4c8906d847d720d81a742bc404a1af199aab9aa4b3620ede0a8b4ca034343120a48d8316dad6d0822631c0d24c33965307aa21cc7ef5544f5ad2526807903f2ccca64daf5f25160f8886cb8824485dc05ca383404120c5bd08ceb645335fd1993b439f6540f4a445d097cee43c0f3fbd10e02a534c1f51b9e9687c586ff6e36731f1b9d2c76f3094d8c0c0bc219328bf04252d2da374876bed90af74cf342a4093897407726cb0368620464244a2963a7746ed055469b0a319e172151d2d8aa17d6210747f67cebccf39f79ffbbf75cc8e858ce054909dbe084ac77533dba668f5ebe80f650b404862eef5804a191dcec956d4a0dc762639ce6ca480ffd97d00820c9cc4e0161b74607eb5f19bd770af5fc7322692a779fba3a695755cfeb18b2b9aa39f60f3f8c99705c6aa13943b012d17cd81bcfec674f6d124458dcf5731e4e1d11d788b62a385cd47167c10b61f39fdf8fda6b0eed4d9de826fece519f59c13e1daad4ef7235f90fc75c5fc4aef1e8569c1808e188d8c86b08ea881a3b098c136ea8ac3ee3f07c4c7e6cf1b06f7b642923b8fb74be3b3a510696bb21303a680227fe0f689e05158e95977ff9576263b4278103206e8c1408da2893965637b663baa23dfd02b11f38a4f1acb69495700987eca3d597aebeb5f035cc4a051202c1c61e2eb24d1ca5ff3c78e4cfe32afdeb1f7c21e148b0eebdf9a3d4114bdad48cd33ffb6a0cfbe4a72d5296edab6456471334f4302040595ccb2d394c4ea12cafb48ba5c5e91ce80a614968346d288559b591cfabcef3bd13cc6bb840f04dd0aaa5160236fc8092a1b96e0cee274280f659205eb3984f9b727564b8603c63c8b67818c7c0397acedd64e67a029e80c63c3485bdf49b21613691e3c3b2cf1413a16b055c4f496e897b79c4af7504feaa6a24321df8fd8fb63ec5d2b20b7f0e1f6a856d9e28683baa0feb62d740b83cfa57a59d66329b1cc0760ea9863047b30737566f3eb9ccae2a755ece474ee6efb84ba5c0e0fda7ca937a520576cbe697c8ae0541fb7695bb23d4025e9b68d68f189f7a621c8c7e340ad39bf164e8c1d60a7df679451aa34634efc312b90bab134ff2fb5ec1fb84d89a3c79fff32131c47df43b1f11271731ae7dfdeb98dd8f11109303abfa9c3ce50c1487be827c0b3548cb63eb3aac2118ff3d26820ebc6116d0ed57073c9f0aebfc31f9b8398be5721869b863776527541a43007bcb68e8bcb364c283fa3b42e60849720569c2478d3ce9d71ac08075749c9b8f3b1d88ec84d8d5dcdc13b59a3726262868e787e454ade242239eec10829f815a2fcee4ec77d9a969aeff1e72aa63c532babf159ab6cd39f96f314f42d7a889623989a6c26457298b74630cb6a6bee02f0419ad8d8b2104e90bf66465477ae45efaf47c7bc47f1778c1964bda281774938495f9d66a84e4da96f2ae975d51f6c187cb43bec62fadbbbe83ad01b2bc549f31e3bac0f936691d88a1018cb1cc7edbad1fd1dfedf37e52180f03bd70d02a651b3df46c57f48e4fe73062d47affd80253efc9940ccd2d20145645715900e000ce281f4c644f6d9c871824459025416620c19f3c4c1625bada397d7438570fddba1f634b9718a4ad2d02b8e85919fb55c83e66d99e315fc81c34d9af9709c16acd4a890201ba8fc8c54f9a0d5ca1bcbf8ae982060692cb4cf21eb6f7089c869b076662e1391d6f747b751a493a1c83f29eea1e5a2baaac418759dfceb0386f9d0e8070c3e24a813a5b55fb8af56e628910579de8ddaeb69e66c816dc57d8267620a03e5fc6eaf4f279deba1eaea7296e23bbe2f05287d166b502d2a961bb9fbeee122b62318814794828f58ece291a1224d4ed50a80199c565add10d36002b21946edaff77bf1c1696c468800bb3ba0dc68ab8ecae340176e95ef5eeb66647388ebc00ac79a649c6577ed59314cc9eb87696331708c6070807bca8033c6d9195ea614a63422e755ec92b1bcbdfc5c9b222ec874724ec0e45bbb7f71cce4da0a2ca0b18ee3df277dd9a08cb67c3bbb9fa6c5218fa1f9db4ce5398577d4f65f13ea615e813021e7711fba82e2c4eaf079929de0777811fa1a3b27e512df8f57ba20ba5f97c42ec43cfe67a82e9f4826e8b2525ee714e64beae876c142e1b35844e3a6a39f51981388681c2b059ce64b58695fa76e8674ea6113decdbef0cfd6b8ff8db3192d138e040eb52f74b0ce828e403c3f138f8d70a3f7d612b5cbb1a46aa1fddf36638ec338f1b0c3e64a8fa05a8812e9cdb862c6b9573a9ab1365201848f05ce5e3f8237a7221dae4b97c76e41ce0a5416900e341eff389a6670a2f9f11a113733b541447f418d9c189266cc94c2b186eebc774fd69af10455a7e2670f9f329252431500b05a45f9833adf0f3999f5da8fcb0290daa072d51990e1af3bb07ccb9036807ce58ac2b75cf727c5308fe50283b335a5468769d1ce61b8c2f5b040151596a854aff30a4c184665a78fa65886e224250798a51b3ea2c18bca18b7a3453cd040fbc531d6e19916101ea4e0af365919268f1ae02a28579938f9ff92ac490117bf7ede8e1839d979f5d5e1c55670cf201156050c0c36614ebf2add0e0d01e2c31dcc2694a5655ae432ae5710493ffa94dd551baf6b74de381a51ca5c56ee26dd80dcbbe366152d25857358b83ef33c342eee49b95506f651bfb0c3fdabc61d7beb285140ee4a92a3008fc62fb96e9a4d646bf478e8745cff6a4313d4bbd8f5ba88b7c89a6e1b929e6eaf0a442ed15fcd4c268e47041039a364590b9c332c19651f2e755930c1bd32ba4619e4e5a4f7b7e1e4811d0ec5db6f03085229ceaf446475d5b7df445ff720c9c6ea76a3568294cf75fed065c5af19fbbd2019bc0393887cc2f96d249be5cae47dc1a13537dd5ac63d3c0345011654c50c4ca907cf1186a4b3f02bee0068cb0a8ab662bdcb294ef1148ec9de7313bf9cdc662567d0866e60d53b800127a6015bdf1cc774d6ff8b4ffa6618b0b0cac8e2de6626c9215c3988463bfb7764435e5bf87739f223e988975c962f8391f3a66a2cf35ceb0208279132d1b669425fd9e0dfc6f316ca7d9b1a50a571f83363efd43e4265f9b8f306e223f7fdc5574c081d7cd3dfa13cc8c4b1a0e0323957e2b512b3a656a30e56cc22d4e89250ac03c9e878876ab1ab4d36d0af76966728d8ca5ad53da491357028353b4592d5b9091357fa99cf083557b90e0058cbbb88c50c681637498cbaa5dd7971f253cf9b8ccd1867142489f268caae6c0432321cc535709ed8bc30ac8b765ab388ef3e540cee401938a37e9642826f78b7fbe942f22649f645db90107881c75eb90693624ff35affa798d7627d8ec63759beccd5a998e40f6b2281b46c3a0a808f1b81edc3a7b0b9950a039fc3e5bc27150c5b8a58cc40bfa469c1fceec9bd62973bc21163596930baf2b4ffe850b7c26aee39677be2ff014eeefd5dea7123b9dd2cdf1a02af9fdefdbe4786f81d047f8211f8cd162d1bbc54c2198bb7aa2663b78deb2f2eb3170ea6415858905bb3815424f190fbbae45746c5e55abfc1404afcf9d9d41196d22e9bd78db8df34a1e9b64ccb5aa5a0552e1fff5784d0e42ea0310c7b1477874f7412184963f70a33e07dd55f59bcbebfaf1ac2ca6b89eb6497dd0c30429b15ef11aa517d7de61e35660b204da3755b553f5cd08d01f0c7186e84b8183d7f3f7bf2825766a45b09d4ae7409f96c2c2c424eac44b509097bbf0d9579a50b9323b1f12e36aa3773a508ac347f7eea5c84989e34de3a58c986112a1f02fd347bd529f163f6395c6b23f0ee6af6e2a736c825da03ab8f5424ea7b1f5a0fdc638bb081b8a76e1c3a5ec601a1e69f57092e262a16c0c109cdff130867f6ae6695875cd87f27a83df039bcd19a7b9aa35fd35be7aea90fc5577783e0bfa527e6c5ff76ca393ce22daadf483d5d9c3384f760706e33fcb8a6262db831c9989dc98fdbb6b7eec0dc0804cb23ab436b98788397ee8a7041f866580428a2671f794fe3ce42dccb441247fdf86cf401362f033162da6eba0b8b89f3791403003ad4db93483a06dc8260f4bd645841a5b8f2fc7eddc513e87fc18299a6c5657e534f694a37be5c7be56018dd1047f5d5d10c95506105c6de4e17900d274fa64ecca33b3798f8e3f5eb9c6c0747f8cf5a0300fb6dec9d320685306824dfd234ee4620386599e10e655d627a42b3fda1d92c8a6e686bfbd7ce19eac6ae06d3bd4832a3b9280afacd49638b8500c7112f0258bfd563a55da78174e6e4b20400349ef1e7dcfa797bf6f8343af9e4a8ae8402dbf22ef06fca1c0ec91779d29d6be64ff6c591d6229baf15a1889538aaf8f0b4ff80e008d64f731329a79ecbd4669989f8eb79453b4aadb8f1ddc602303e13cba7a84f06537af44f18bf1b6a4aaea33268d9499259f3836e726013b318347922f66ee8d53882d0d9cfcfc95413b92e21f48ecf40073ea3496be1095cfc682bdf66a93fd8df803311db3b15a5fc754da8e77e5808b7ac2ceae510beb32775a6879b54b259719699c5c3c21550bbeb1ad5bcf7b1600f0369fe86c784b13916cbc7a3de602525f6cd214963633692461acb2a5c896a695b3a37d361040e10e603b7e4cd54298c03f6b99ac657f688a2955516598a6ca110803471fa73d92de0d47f81e37cba9e7b50b74cc6fe16f95b0994abf88875db8f059c2a202bd5b1664b4d2f15d09b051b71b2b1fd129b544908b3720e60ce7f6aacbe00883657ec57d04a828e6f709300b1988c086deae3847554b11053915cbfac4497f1e18c7d308fc9b77ed5eb33c54bfb1db4b76603fd154b740f6978c4236b449794975f1e6e1b7879077fccb63e5fba30cc2ff89ad7d281ed9acd29e510cb12d55202cafd99fbd91c22182b5f47242b9752306e33a8251ccbbd124b0f4316d9019690d56d803a65a9b2be06331955c8d5081e43486b6b2ba92d5197799e57662a0449fa26c09a76c396ddf6f91b8af77f3084588773d2d2c45230c29728868e39a33abd74c52953fdc0d2ac6b8367a762a9b30570c777c9f954ac0e27de0f018be4b76a0df0a387be2b46e1ed6916b97765544b5ef4a7a3f45b41eb6808ada10aa4d81eab1421dadb2e22d2d0e5593379ccdefd245bf495df5b66a195b1743b69b39e47484b39a80bfa005c2e929760f505dcb1731e31634f5a3f993459d6bb0535169c2eba3894d6053c2afbb580356bfe1a3b4348fd292e9639cf57d98981a22927b09ebc5800a5fd492ddf2a3ac395df9c07277377ce1e47693078b03339016f209cfcb0b0c2930996eda6ed73d79f7210d065c16ca5648bee1989ca7d9be2f32b866a578e35cac275fd99e9311cfe116b50f12d8fe4b4ee5437eb9335fc26cfa592ee0d807d1e6755c7ba3f10ed26ba8b0ccf822ad916466f8fb3ceda7f6373ef5a6b7d098b025f3405ba0080be7df4b8857248610e3fe27c2a14b338a3a35b23f32ca9bfbae8a0b2a253b96f025bf15d92779a62501cf062ddbd401031918864fdc0dd6c87acf558f78d47701f5de19bf1438cb2366d2ad02ae0d908af90135d00956b4d90c8fd44da5f570fb03208003b66ce1745f58270e428f340d8f51ebce11a0f07a9df026fff327dd296c2629de1450b8d2873402e052c3a0fc485e36759de1e59c69945c3bfec25133f58c2f73b72591231be2cc9ba1b00d6328daa55aa00c132ebe8493e172a1eac2f1bcf5fb365b761b94e48b66ebfdb28bbe80577db3323df18b114c57c11112d8570fb052aa1edc929562501174513862ca73fda164d5dadf7773d611a9aa36883829aecf6f169a263d378b2e113d403efc87960ce286ac4debce867cf525b329d60695967a171b06747c59d9c78f3462819e182f700506c14611ad9b9c7b7f8260ad560f5b83a66688bbaa95a2e951a0ee2943c966fc486feaaa3ca6b97161592043ffad9c251be5db5e1ba2a1afa7ea890292650536e855fd2865e7675a652b3f1d447de0c0871d558c5395146bc37768e207a6f31f877ad7fd0a0e2fb7d17d4a23c4f19822bdd6292b84b007c8fa7bce6f55912cf53c9f1b2092576673e74d2601568ce54428512b264a03fc7841ebb3eaeac5fd611b848e99280b55fe69c47818439033a8a5fd53c09577cfec8c06666573b14b16a466536e26bbf582b4840e5639ef9212d0b7f2e6c14de1bc76287ef93b7a284cbcd982fa96cbeb384ed5c8c04529c424777033cca703038062bc1aead04b6345beb0d1c599f09b582afdbfc7682277638faf8a3e559668deef501ad814c3f567133dcd64174e997e9639784298f4de3951dc95715e9a52b25388c325c4a2b56cfe72683a5b6b0f8c0f035ea5e79543427cf2d94ebd158dd468b09dbd93b6054a739b4daa51eaa8dc611edf7f0d75a2adcb68e514ddd2bb4dd12fc80e8cb24c80d7b01aeccf18870367890a72a3237762b415327d87b7a6b47d14b17c823eb18a4a988b2429b3e2e8208691399398c83d1807f1aae6458aea8636e90af21df96a623b15d406a34fb30cb66e51c4d8f42423b724c09aaa4f5bedf999cf8f336b58c4819b5839c8251d11beeed73b814b365e0ffdc306ba9592473225c97891a495213e480125bb72cfa6a01f31317e9aa523e7d12e0b6630ace11c3063f94f9f1045603053750ac06e7e32d895df123d1500d8964b00f4a58a65a0b69410b21edc30bd1266d6735955d10266dad5238ea68e28dfe80e8e47d0558965aade6d683f9b2da9d27167328d9a6658a9d2a92a79152eeca1b39a823edd024481978990ede2d66fac5c7eb7a460be179c0002f3e6c2b0c7985d374b083cfaeda747267a053f449769a4989e4b7ecfb7b3b136132d3df38667d6f5deec5a1cf1c031262fb431918cede04cd2e89104af297989df0235ec3bbd97ae08946376130dbc56dd51e1ed0888327d6d602d0d343790665aacfb49adfbb8c4b393e17eca014e919d414bf611866739fae5addbb8f6213853eb94b8688fffb6fd9c2af7d908939be0d9e46db3fc979744bba7ee43af87045ab2cb19559b0686c9aaa86919aad1d45439a8b3b41855795ab59ebc2498cb3cf42074ec516116b6a6e85124349c55ba8c67b87ae911b2cd83ddf6b8ce06e98751ef732f198a4eaf5366e31e4bcbc76b87d8079c7b2f5c46c455572174505ef89e2f5e2cb537b6deb959ac80614a38f91f1699ae47f9ced8fa2bc864a8185f008f2ae881b2e1745faa01630b155c83c56b9b01372932ceabeee87523b2c75425e812fbad62ee128ae7be561a261b08958c3bab8ff8e1c17b9e7a024895f4aed35e03d79093be8fcea2d822b74de3bf6851464ab4a4244eebcd6d4491e06435569a287d9776027ff4bf1b824ecfd0e8f3c69ec8886a3ae041dbf23445bb75e237d2f676ca463b356844c80c6a4e8094aacadb6f98ceb6b451df7aaeb0d29db527df517fa64cc7e8df148ea8a6e5cf565fbcd62a0502ddcc706d401f16347e6f035f0e1b74ab5d795fc71be7389ff5875f7b34b41c8c6d40296e85ac3045f8515e3dfa2b1608507664d180119052d341212efd6d1c8322d2540ff41e93fd885b28ae7aac007ffe98e4c88c69b219ef34bbb090f9b9af33c0e126fb22bd141fc988003fd31b64537f0e9137176e3f8a7b4ee2d59e6007d85fe736a3fdde203d26e35e272a702151d432f200cdfe33303c920ea501a5fe6d4acc619b3afdf424b45bf28004bb0e9570e6245c051dfe1ba859bde384163ac54edca0aaecc39d0130d05df87ec8a0d6ca4b918ef80f297b8ffdc4e23e33abc1fdb68830e44c55e561c55999a5a30657b265b6cb3021979ccf34047c82d6fefe350c708ee7c806be6f7c94407692e37814e3014b14bc18d01723dfb5ac062bdf6c99c4e01c32ebc49930a3215cba627178f808de82dcb72ddf92e772b6a45b67235b8d836fd3ca692a83cccdb7853e94f8d8a9840dec291b1bb9b5b31e37ea7fec8a11f7f536b3d0f658b56d6f792255be292b8024068ed071ab82941b90150061ee46fd41b2cd0476cd715f56d5e913b460cabfb16ac3aeedcb9c7096620eedfb6735d55531a7bb362e6a5d1e9cb12448d05c23b6a54cfe8fa897720ad2718a384cc34e4d27464a225a126802ed2abe73daa532010d5cedd42e21b944c12a93f71f57f828220fe3f35f6cbb786beab537d5c74e7ff974754d4ceca76f609704938c2236267a50836c8550ab4768be8168990e5254f4d19aa143d2f98ff37e6b519cb644ee78895131bb56c3610311fca7cc1138f635ea930edccae9955acec869db7f6c6ec5028976a1ff5c3ab79cd137168bb216dc2fe6f7a6fd121b586a015d985d21e20700c92227c4d0fbf2ded0c4adad090dfc7c4d0f10188bdc500943eea94eee5c3943b66eb2b282f0d38c31877ed8c599868648674b1aad2516fd9ade3f4cb24966ee9021e41d1bdf7b5b88cb134ba39232374cefa3cf30523127abddbc26c33fa57b4142fa11e6185432724eba158fe3732537015096efa33f8104ac30b5b04c06853f8f263f8d572199b450f3ef1724d4a4d15c4f2155c31e44f6db1cdf0a90c773274d8231a7dd247f13458b4eb58c493bce0497aacf14d3551b0b67f39f2f6ed6624ee76cde6db7f1bc548f94516cc3497524697d81c25d4d1b3750bbf6aa3e3fe5311bb6dacc308812b689dd52802c731be73839fb43693d291b88e62ca37f206e8bd505035379986779534528c96c3b0193d7b0fca4435be7703cd0ea76daad0af8bd70c01a8b5f8473064bcdad94f1aa180329ae0b9aa7f8eb17df8c339859574e6c10bc667e1884d0bcc4b0a8c3086aeeb85d2a0ea40c2d87b7ee314aab8b676c32d40cf5d2d3e3261408d46c2656c399a9f6025c8e9db51a62a7c0a6c8366ed135fc38a08d9e35e4476b7769da95e377ba6c28d0633a0254d2ebb01c8f024b00f08f766ed6e1bb6936845ef22c92282bacfa6a60e4833df6483d9f2fea7c0a8feee7ade290015f35f1cca61ab90e8c62ab0a360cf8de148a5c9bc59122f781025844cec4fd1733d7b719b6c7c5c0eb0de891c771959360f6bdc88efe7d6dfd2915fcb9807de23b76f09bcc6eaf4c7a7510c2d5d89ddb3e62cb1d85235bc9790ff6499828086e2ca5efc0097f9b9f401e4e2c1e4bc9c229e8120fe2a53f3ee9692b8cca72a49d61088709640992039c4a780f315e3c7e9d3ea4764ffe2a4f99394cce7702a56a7d67d6a995883ad2467531b5b03f70f0543ee2b87a4ffc2b861eded8976fec192794d5bfbb714b8da4b12110485c3f039ba31a465810754e33418b37d1703d93c73a68f53f8c31601df7c69380d0fdbd2e020b00000408c379db0e1a401fd0bccd6a20cee0179e4c9f9d49ba382d47fd5b4847ca5bcfc1f8f21f8cae9499ac2d4301baf35a9fe55e66685998257a1e50966c8c93720f2682c69ca1eef0ba9921665a08c0a60fd77667244d1483115b484760c881f178a25465673ab264a8216c65eda9fc85093d7b7fb5d21b464ed390b9e6acc4e0a5626fb90e52f6e060021fe48b4149751221f15b30e63fb9d7181806115ab5532cb299dd48b5f628e76e9a2f9018e81e17d4f31ee8437e45af1d143632beaa1bb430cda9f1b297962364c75ca0e961448b635f7986451ed2d62214b5951848dbdc021ab99245a4b669e374b9895a017a2d937e252b04633eb3c9efeedd4903fd7eb257337de8ba5328358ed9acaa15ea7812bb5a1aa9c52b90bd930efffedc1e6e7c698386f48b5e9a001405e9529ab31999ac898df6f8598ced2e4ffe6e62b09204fc4b21626d3f936caf8ee802458b46cc92f31e8fdee26e2643f1e1277fc7e7c80ab3f88bbe49490260298a6d4fc50e3b34ff6699c7b2740a808b3bbd556adcb6df0f58b99fc88f021bf4b9f2885ceae6b6f1bda095ab1a3adc96d1ed51aeca6567b11bef67def5628abb3476a8b4ea366d86634a2858a0ade2bd07fff2cf97d9e465dbb31db9ed6a7658f764b453867f39ad472cce969ca399b4b91125247e90d1b2e480d1a0ab8da46df5e85f3d427ca8e80485534a0e5d108265d6b1f7d314a69bc9f639fd92b6ab2ef5d9a16922d1ea3e34d9a366873a1c6b52bacfad8fa8ad1","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
