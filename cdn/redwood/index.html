<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"096c33ac9c840035efdb6c64d0b15a5847af5635b40346242fb6abcc638e65c73408faa900b494b950dfacf677f9051ed69c1fd7d35c0ddd0b72feb7db739654b709344954a1961b4a3d16c479768dda27731d728d1b1ea52806749f03a3b11305a72006e2e32930cd523a46c4ff1efde0a765c78799137987ed95773dcaca22b0f7b92ae0dea08a3bfb64a9df4dade29bd91b9bf0a6486c4929cb471a5408d44420e97bca10290633f161c41b5ab17cc13f1898871380964658dc3e3576826ff9ecb94b6f1b616db0208eec7264a81fbd9f56174790ac2b357876160359e15fccf6db437d598b81885a0c31a3ae16a24c238112fd869006ab35cb0841a2269800ed708f80ecb4b13aaaa4c1750a2e92c497c46effeeec92bcdbca6c1c6986c54ab6ce58100208380307b688506b5f64c8c04e32739c877b634959b2c5cb6c3ab68d3c9a4172ad41679094b7df54bb96a6d95bd7363e1e7e97e7b165af82846a38420ef326a9b5d6c5ee8f371c43c5c352054507f8d7e9f217858128f8abc9be65b48dad572c8315abc440bf0e4b9f8bb3f2a6184ad16f6f02119abdebe286a2898e64d30550c77950d6e299887f1e41bc190f0f69b671ac9c426818faa85db639447fe78adcd2b8b2c65a254f94a0887421290d099c4b6dbc70f53d0cc7e6e52ddfa151737aeebce1a2f96c98127f4498815dcdff80bb1be9de0b05f2cd66932a06f28a3f364245c0ce0b41247a6ff0611a2c63c7e753b2c3c00e2efb28365bd5dc718ce9f0e6c42bc3d12f72b93c41f5e61f8942a499def8dc7072579e74be008292cface7a692917e55a15e5c8f4ca49b05a18b4698a621a7873790ff8e466c06e3985cf835afc82b507326188b6543666c8ae9cdd3748a968899b399bd28e923548e39c0e6ca9dec6bc50d26991ff16d9663e369cecbcedaf9357ee04aa289fe631f1b4c23fef7cb8c901a082d4b0f521ffb49a9b38f7ef6323894de43de21204628e0b7a5500581fbfea75c18f40ad4d14d446c20d0cd6054482fd96d09e72b582c87f6c5a060c75a463603208293eb453eb78974b8e0d5c8d95a497b7d0b82cf2971c540a6303be42a2bd8e5d93224d20223b787f90c01eff84e025ee4cdb15f7fcf2a78d097742b954d370b540162096cd2df42a9001faa459a573726c21e502d5bb047539056802a1a3669e6c898b9431d6b22df031eb998c89c3a3a5a4fa0026d7239d964620b5d6cbab80a7464ee6d716c71b36137cd393698a45828b4efdd91e378e26001726a74fe575c8aa6d88c5aadbea8eeab43208f2e3f4eda7530c565c0505f415ed03ca9283742f4ff434e5318216db9c808046e8a145c9ef23f45a1cac1585b93d5baea07f7cf259584dea780658dafedee9935e2fa0daeeb2df42421d377b62310c8aec799e5407e7fd4fa586a70fe53a0917339672776fcdd176df1e29fcb87bf7998b6db37ff056b559cf12ab93666e0dd8c75ce0ac651de72c2167d49dc5611cd5b4bccf66634f37fa51fcdd77b031877bf1a8d1df8d8d5a4d6001423474ffdafa3e905b2ac3dc52c1ee6858272952743b9f8861dfcbf3f226b190b466e5866caecf74970d61b0d73cf2c66da423fe0e5789e2059e605adea6a800416b13395f35aa3a636478aef7690e15a1a1c971234225befcf5b89a7c1afd54543b01292470ee29ec944d58c28ce342bcfadf7edaa9b6f6166b42b51da170e92b367503434c87f537561cbd9b6331febbfe152029ed214fe2c62ea78c941f383f4218edcaba48beaff56cbb6ca0bda54d3ae93d9bb063946405169b3a45d1b2177990507aac656eacba6c25dbf9fecff73c33b584ac59119d9975e209ebc88fd4ad72ee382e7dfae9d2d28c84b37a88d0663bc49156c7abd9e97f04589fcb73b8210d12edaee32ab4b957fd04334753fb5b16ca641f37579258c3f0dfe0d7f168a90b20182b2bbdf793a375d3f85a00348317e27954d45bd566cac9fc01b82b2388c79bab042f6fedbab0cb30a9ab02d37cabc109864f6cdadda589f2bf24af245ad8de0cf602fd41153b08ac1903b6b337c6a8922b98a6300ad749efd7b0b4fe0e6fc2249644b1a04e6893864576c1fd7d2430e181f119810ba5d4653ce19e8d3628af465d2a19b761f7ff2c4ae16015927e54a78fe7cdb9644f596726fcdac521e42e6a1bd5b0cd4f0748b56792d7a7d2e3bd37e6d8e5ef43d6ef700c1184f5a045463366d56883ef1c3de0e4d811a593a53b44ac9261177e8c699aa7311ca41706d626c0dcc1b61381900e5de4f9e885575f497b0804e3bfc7993e4b3d50c2f2ad965a8d4ca8c1307c80d3f1ff5edc303f7288c031c2c3fb2de62c932a5057a437afb856f09c6f86812ed8de3b32d40465a1ff751373427be469114e11d2a67c675db59fca82b0be83ca40857a09d70f5b24d6fc870c4206b16e4b30dcba26d2e8678b1f8e9caf4a4b98234b672c93302794491243a3be9e76940142acf09ace03a2793f3f73efa88ccc70fd9c221bc81b9909924e6661ce754646d972bcc39e3071f57716874063de12ce8195b73e2b104623f26b813ef37a4a0b832d4350065c4cd9163787098a7d9b5d400334f040abe155a2954ad1f7ceeca5aa9d09197d0f6a92e21fd7ef2dad9eeb5dc0b38c47bda91417ce5cad35f4f7fe53b2ec837f928e38a78a45211bb0b5ed61f5513dcf43126de2f42303cdf9c1898d279b98a576d7662cc0763b5a63b9f5f6d16c4bfd21821426d36ab3d118cf6136da21305d689a4debfb1756884865b660c96083168a47f887fdfb48713e6c5a0c5a2ef88ff88008f7aa8eebe32fbb44d5ddd59e81316b38f22916c271d59f06279a5c1f3d2d6295dd1ba1a37742f70918ee6892be402675035236c5ea5da6138bdb02e6f2ca7f0dc0a98a728e7c2eccbf18511f23453b1e1986b4fcbd92d461867551029f802028e9b5b934922e2c83a33c99083c0dc8020aabbbddf6d7b5cd00b73e56967387a5c5cc2a28d11c930a27bdaf74af29fb66d1bad433aca322a36da9283b3678275e3b3d78c7f8c540d209e1bb281c27ad056740c6257a004fadfa691d25ba0dacc2cb3afc1d54d4e455aad907270ce2feb2285582e84f11a838214bef385aa4def5071511e37a7f3132403fd6554d49cf9b6e9de07d51e15c70ce76dc0e93df27567a8ec805b61ae5d89e30acd6b0dcb1d791f0a819a61b163422764538d24522f895f3117ad5c681733d71b431c9d943e0359e5541b4d94482f4f03891f4a03a4bc77e6ef143ac05f7aa82b54aa225b5a68e09c3cc06309f70d47922e61a518c0d0678581041f239d827b364e9d1d0f94f1cf6db4e58d1e5bc3c84e8a6575ee223c9fbe485a48dbc9bacac496b4400a8c380f3235dcd75dedc799b4d7808f2ffbc4655715f71c075bcf39edd04f4aefd90fcb98667e9570d71f239963a36e7cd783aead51df4cd2720e60dd4c1e4ccc6f245e928a5ef4957fec032c6609a6ca5e692e9fed566e5ad42c40608a61c051a0e85442971f96932dd19727a60adb0933f1125833121eaa4997dac465c483b3ddac2ffeaba1d98715aea5dcdba4c1d86a486482a7ac2e32c4eccb610acd5762b00baec1d6920558323055066ed32e1c9869d57416fc42a02e38179d9b115b70608b948f317d73408a2a87f901de0999276cc3e54ff3fb70a687e76510b17b4896a5df44a0752c3dd35915c8e816127bb1acfd2e4d13357dd0aaa336ebc04994f3e4c6550daa2b9c7a39e8b27bb050535eb9eec111edf2feec57c8ddd8f747a977f169c99cd9a39b269d67cfb9dea19f5c94e9750401cda0fe5b4733bdf80b5a7568575e65e846149dcf90a52990fa747a10f90038aab2797ccf1078d8ba0b224240e264a77f69d7d1b61b1c77d3f05208c2157f79d50661b6f634ed4fd9e57ed3bf72228e932b82395b658631efb62d1a1ab7912338113f7d4341baa46a9119763701e3df6f337b40ec105f6dab46da360e5d566eef2e286ae03ef12af633139f1a7dd8ed1ad7ccd20504d1193262f927888f2857def77cd54663a546fa295c92f663c2ec407b6e1f46bbc47af342e7863e1f36feb27651d78879b9335e9f86a1caa08c5c21d9a917649501e60d48824ec5304e2bfaa3a3d174d9a356cab3c8a8f2fcf32b6dc8e43acab5c5bea5342457c62ad92f1254e578f07f4291aa49527cf56bbb74a03e90b0aa3b25ec91e5c39e814ca1599dc15d632dac2bfd5a2ba10b84046236c9590d016c2e5f4a59791a5eb2feb132cab475391fb5280e0596c9204cfb502233203497b07ebb09eae4326a43e223d8b506825dae819e8e2f4d2832957f7e446408d30ef96d5e58d76789c92fad9719d9cc742e5243409979d9474a401361c847a5355f1be0c23fba6a53c15b7f602a1cd38c2bbb3782b6c3164bce932f4e9b656a0ec8b20a9b36909690aea129f2be95406e0c0deee758a07a934303608d4672064d51a59c026a2795937b1ee81a96be06f13d173a55ab2e1560848a1d7f0d5b5ea10de5ba9b099f4e07951149c2f3aef3173ff0b04580ef1c0f44bcca1a489859b70620381d88caed2bc4b7d44c995ea042296ca4617a1bb3abcd2d1e44439e0f1ad973df71891deadc1b9d4ca57e60e438cb6adadddd07c90b7cc72c28ab7c5497ad50e48d58636fe19d3bc7027b57638dc9b279af1202fa8349d406aa20a80ffbea64722b81c93b7784e1d9b5831ac5431d63d38b81b86ebf05596c027ccb327f7e1741ce97d25e5a6f2a5249c61dcb12b8ce5ed6126cb5f6d8167a2efeb9a2eb0bc7653287aabf908355c570981ac581f0a4645596f94980782e74238475be3550165b8e6aec65dbdc10d92b9defe42841d38b2f56f3b49d8b314cd448d17f78e999f4060ad90a0c1321de8490ba34c33cabb2353ee94110afdb332a26f640154b2506b5ff9db66af09d241bfe98fc95314f7be80ef3d64ed4d2ced4229c715e8577bedc02c101f60860901a900de9fd8e32674a46e1b9789ec1b89bf174e36363aa9a7e8b63cceb87650f4e2bbace09a99598d3c364d33a8b49fbf7874d0bcb584af61bae213c61f0171366bf90bb28cf896d36f57aef8d8bb89ae040c5a5d664ef92a41387a52941dbb271dc072fd5e22b7b0061cba0aca53963e5d163569ce1eaada3445003f3f2927a436e98beab5c92eb70de0edfcc655817f53d0b624df338de197f6ad3cf38d9722b98591d279e879156801ad0b5dbbdb246db5f354746b1dc0a33ef77b567b4140b517320f4c68b44d8b76e420adc8c89b4e33d13c07f69fbd36a53133ec4619e8ec22724a381ebe7688f9dea04ccf3d092f8f0420bdb24e763ae06f55b8c84a7992d0d22378ebcf5f948cb28c0af52274907ae10a2b8254d99ca1d1ded5d22462244d897fa55623939b89bc294afe27f59bad045f658d4ed9f9e932eef6482c734228e25c26809768d1024e12978c287a1cb21fe16907ba38f26e7fb5c8398b8771929d0402fddd71a6ce8d49acae469880452da90e476b057683b6459a1219ab1f1513c1ec6345334246d8bfe559c64df445d7ed0e48a04a030b787b2acb95ec08d4a151785d85ea65ae9cd263e92db935682a6c06b939626d7f15497aefe50500055486b400c629875c5daaaa6f2877d70912788815c4ead074a1e80e207ff3deeff72c96e6e98f7fd1f5ea4d5ebf855b6a4c914eaee1686b1393fbabf68840088de0e9d62fe09d05d8cdb1c083ebbcb228b9c802bdfd2461855f5e5477a1d654348b59c7e3ac93f6b6b0f4ab95f3d299de43df4c17939c410af16ad6cc171456dca8311f4b9b441f9f18bcaee59e9eaf226fe8a90b443b1e4946cc25d991cd1f18c77853b50c088ea96a5f612d72307a4d632a27c5e70e601200c270590f87516d23ca865db17f07ed560842ab7cb5ba2ab85299bf82b0ec77ca9bbd711e65b7bcba19aec9f0e01e30db426b06411745d37840dea8ce5ad175dd8c9d3fc66942c4b01ce45ec50cdbada39c3e4f05ad97f76b28c27bed641680787bc738ebb2e5446efeb10eb4ecbb9df2f9238b01645777f765706437234e4fb160d0047cdc5bfcb3e312fbf83a1eae30567f549e80285cc85e101903f51048006b4e32ce5389c23f70c0cd6a528729ae7978ff54cb7a9ef8a8b9febc3fd4977ad5aa50a4213880450799839e57e666cd0d54641b09bc50e9bdc27569531bc99e2a04db32b4c1ead6e61307be14a7a4bb237467afe6c115bece8e046b648ecdb0c282465cfd24842927d8430681583f235550fe635ed78aa290f53589412d29eaf86738f7f6fc5c77dec64554a5ec291d924c236ae963dd8efd5d4bb21cf275e92e460cb3d537b51e4b9a8c29946edabc693548879e4e3ed5494b75de2bf2257a9cd0577ded6f59ff492e67f6a1459ac9c4897928f786837d3e4603566fb2e44661afd3b3b5b0aa105a78631772b6a1434c86f2090c3d5eeba956b9eccd1979144ae02ee61882c7b51594d44952b478982ff0647e46638e456a0e7135edc0a22efe7d2eeab9e3aff9946661875ab2f80ce999967df4b33a0302221a4c5e8b1c37119a13aac273aa4bf73eed878fa011f8e77db75e6734890ba0ede085dcd6a4a5b0828507d116829aefe1d413973e73f5454f67e0f807381a44cd62850285e1df2795d998c7c74a12a6a11a1def221e684fb11b39570aa7a6b329f4a73ded63907df49b8922aa9ade1397e36e30142b058a809350bbc7a5ceacc90f002c275b5eb5b4474158159e6d1443bd265b3f715e206f47cc6d17d80453cf34b26bcb07c78410dfbd782dd403ea1759e089628184b6a336e7d1644c7224cfdf694d0149aca386dcb4c4200702c36962f5dee6b643f6e88ef62a15895c86fd98d0004c54c09d138cc6872fc539550162137a715431725390aac85ec770bedd17d377096f976e060231cab24ac472cf5f5d93e37eed63d410d74e60846497669561f7eb2c79b47b58f35addf608cb2c005383e671557036f778d86e79d46eb229da39855fdc3c1d264e1a92d638fc69d1a7e95f8c1aa30d38cea70454862e12cdf4050901942b41e3fd545b08c28977e08412a8d089f8ec1af382b9071a32bdc5b0c1a758aaca2bf1409f38116647dc56c1175143450da5a028500bc14eec2678f9426ecf42e9ad449f87235bba02218605ecedb8760062bcc0b6053d220f8b68345bd9852877dc6a49478c6e62584424298114185f12b02d0f06b76267fef517361a577b779d464aadfffb2cea8e4596696fbc31e13455d7ce02979dc8a2ba0e10eb154abd32278434c60f1ae273bccd9de8e37a592d6366a81033ae8ed3ed94aa52daff4b7a7fe29ef5a2dd3e82383d05ff9c52a93fd980b2285a4c1831f3903065fd19375ab8ac476a3bd9f6ddf2964374f8f40c7e0cdd0ff3a4b8bf1c494c9d0aecd0afb26a5cb63048303b7db36c962576116791293d6d4d9cc87f31ee7b2e456f5d283d2dfd5268f64a8ec666880ece59bccd606d9dfc1915257fdf398bb9553cb987657840f82e5634ccc9203b378bc12461776cf93bae44754d60bce0b8cbc8ded892f643f3fc5743bd1b4ffc3d4216ad8cbbd5ac39beb90c5ade19698377cbd0d2b5a0d2f7f2df0eee4488bf949e16fc4b77f66eb72fc85a6e9421c4e311c141352fe7ceea0240898fcc6f1f4eb688ebdabcabb2d52dc8f4fb5e1313840166f752f5d31d19f7391f27a0b5f7a61713405057ae3d2f0976c65469efad402faa24b55b0eaebe9a6c41068b441ac58ba24654d8ab1da6a4aa75052a668e892a1846f991a1e04192973f0e58fefea3c57a8ab99b3555bea1ea6716bde666cae935b22321da5cefb9ee991ea234b9e3aa2f367373ade989a7546554fba10b68e7b0eacc474fd416dadfc72627e0000341cbffc68d6a5be0be4c95a0cd07fa60fafefc2b61fb1b65d1e1af0e85156eeaff08b228fa7cde4db7e8f98adafcc7fa81161b9af41daa4e22a75235be55728560763fa0ee0458d57f835d0460ec5a6af3b0a60fbfba018e5277a9ed8181287c802a7804a26b883ea809704ef67544a52032dff9f733d42db20e7ebd878ac9f780bbc6fd218ce3049be51ac1d8691516d956319d643ff2da5744e6be56459f852b7998f415b40ee40779ab69b585fd50bb8388e9eaaf284d1582ac3e6c7056148e2a34c6d45c8c583e55bb0d91ae8cf39c0d17fa987732a2763ffdb5935fd30559c8212083660a3d75cc4d29ec87e3b4c711a3aa2f92827189fde9ed30adb632e0f14d47443a584a8e044ca5c71fb99499e582fee0e10728eee466ed4f3ce1e2ffa7da8d0f40863c264d1a906c5f28cbf75bc752c3390fab6643d00e45f7ea44793e8c5a3df8f6aa64b8eb315fa50788821b2ba71f924599363693e3e8d78db3f38bf220f22dc6caba95ea0bd89ae83c4e54327d0b81989fde251d9492228499e89451634944bb02293a468819da42289f09b73b858a92f7d2cc3a529d2752cc5d6ffce3007a6216647c546a5877e7d5c45816f25aca7aac8c1c71722192155aa6303c6d5ba7a1ffbcaab01a00839b2120a872453af187cbd3fb9723b0d9b580f5954c108c01820aa3372fa8ebb640a1eb6c09e35f62ec7528925fb139719e736690ca750968024c44632e6cb5d524d82f82e00a6628b7d1c5718ad200be8d65e6c7461c156e97891cf1d672aca2f78ccacd31935611d812d4e721dd6567f4040f3d4042abd44d116c9d6717a73f206bd328b87ca20bc00df838a6159d8ad1e359396f95c600a908ac709fbe59c41e0d7fd4df9f0844409eb58dac3759733c1d2cc7d50af4f463d76eb6f2e4b4778fe5ed3d42fb1b0d14d377e3522c6b4ce8319fe790f15e7e6901c04d9eeef2208a6a035496ea7f668c0cd8df523655297013e261bcdcffa20ff22e9b1cb900c871792eec61f8b59de02f5d73a2fc62c10cd61d97cefadc44406257dd8d288ee0c11ffed8204c9f9713263a47523a82c2392d9adcf00b032f1012479d5ddbfea2aa3f45fee3df75a57efdb54fa503a986b8909b20ff78d4268e98bcba09ab1bb80aa6feea743e9a3bb98dc615f77d91df6bbcdd3e55afe822305017d8d355c99ae040b71ce6e07e83ce10c2c3ad888821495f31afc02ac4e03eca960b82cc9ce0d6326cf35a401bff1674bf0a6d911a58643cb04f52adf8c5175f4af9ca5cebe8265995b95be91a5c207e2ddce9ca1ca2fcd4dc0c01bc968490421728e0074c8307a698aef2dd7fdeb70f4946cd4cc1a44949f6aff5835f20effe48ed499dba1bfb2889676ddcca6c1ff2536548044d9139ba02971548c0f38e2c061957d3fa5100de41f82280413597b5a5ce77fa8c90bd4055e437f3c0d08730315f58d719315a35126d6a65ddbadc5118645b3e707728c0fe99c9f1aa4310063a482515575852b719d189d7a08399c9b6ce8726bc57699b85a43fc66baf01cab2e651427bad1aac4c5382268c8c3e010e72d0ddacedbee167ce14ba4c35d073de36e5363d76898221ac5e1fb11186b5a0b0c8ab8abb12c0966405f2d0a03b1e48d6db09128e79b9223a052b398caeacb07cb7d6300d2476a5b982ab919da2221b36648227f71e21752ddd852d7df91ca14e989a5c52119d930e24350e80cf5bc76eb33a3ae74d773672f80d610bfe66f757937a156dc5bd30451f9c8623801620ce8ca4c4ef9d4fc7d726e15700168503138ac2a627386384d9429c4e8a6da04ed627344ab79d2c4686df7207827eae523cc0028f046aa2f24d76d0b5b28c2756f0f4f48a5af1e7b1189678c25bef2ec2febc28d3519da12f92ea591b1f954ce790f42f54c967587fa87493e47ac3812b6a64e9dc05128b43a07e61ca9fcb2679f101491f1906dd8ab7967eafcd17cc7cd4eaef944213cdce80f153a6bec1fcb495da971f2ac55e9020beb7f5c911add460f6e6e94dc1e5f6843efabdd0aff2b1f0584cfb572b7b046ff0d5a85cd48384bc270601894c4cb06d55a4c4b0926e13fe62ca5b98c844ff15e4b9d05f1c6a74c013b361882e66a8946960f9bfdf72f4e000019f44054fc9c3a6a3ba853ccfd97022815ab620daa82a16375e9cd5b982a9b7b987af32d710ef6bf35fb2c42d0fb887092f5da45d964f52712fd647257c5f550ef1f6a106488feee986dc7d70940807ae3ca8e3618f9e3b31d28c02c8262fe70ed30cf269a8ab8d0749d606bca12fe709fb1b43ba61cd5b295862f69aeb4841369e4d1eae761c54301d43c98c094441cc810f9f4997c9b0bfffd0805b1ae2f6762fbcbf67f2a2e9fa56c42b4ef2f12e20d28b8eccd302503a4c912cf7116bd7df43fa5c899bd9225280c52e1bb8d51b465ce8988fa7d4e52dad4da7eaf551bc9740a8ec515d25b1e1d346e55bc613700b95155bbb169c4de7a148569d05e9a529f28c827729642e689c6dfe55170906cc56d6b2b0c7db204720dce7a3c693cdcb8433cb6ca6466f890edcead280a3c888c3ba15969a7a06a6710fbb1bc2163f78d075f259e72a7f1bd37cb4c8efe73ad554e6e1ef12e6852f2ea31969dc2300abd69bbf50f166fae0d0b77e8f7d0f87785744a05d137310b2ffbce404f14c882680f576e7be55037fe66c27decc481dcab6a0364e4b23c3f1254e0296534b65853cf5ffc2355ab11c3eaa7761fb0a5467b9041fbcbe5a8782946e9e0c1532c5827c1244409acb7019aa4c026415dfb8148f93ba958067e3573c4bcd5a4742922b22c52cd1fc32e2905da7c13c11c78b8d2e9535926a84908e97736cbcd6ddf4a8af7ad8eb4e5e56cb389b0bb4f857f316c8e5118de537c2129313eda84d7f97c7915a80b63b4878e6c2092e92c7b06d89bc0b6d00163f5eef45e56808379e408cca57db622037fcf64170cf7ab01e52da08c11e2b6c8611eefe829f3212d43f8dfbae5ec7af5d108430638e1a22437a22574409041ca076f83047fa93ec6c87504ac9cd1d04bf82b5ba920f9b1321749196f1d719f43b0ba4497c25c1262c687dbfb836f33731e833adbd91d5841028e89c7ca3c0902dc57dc00a4617c9f391a4fba29cbdc538a493a8ebbc3f6aee3479200f2919ebdcab8dc1d11f9b33f63c76030ff6b739c1e9f6e826b38e704f86fea72cac737f9c4288a43eb9c9b4974ea44dd452bde5a99b07935753e3c6056b2cfa8e8a324b01114bd07a53bc8a6b3c1df4c1159724dfa8f1ad2db0905764f2b96678918cd4ff870b8e891a0d70e378c911403d8f2416019281600c3f03c52428228c7b0ec66da4ee6990b32384fe613801cbab1d7bae888846dd76dbd7f44202f043b5e7430f35199feb8579dcd91989e431d670bc3d5bacf24ff82fd2a0f95e333670f78d1d02bf83e2b385c5c094833b60f7d2344c0483849d0ca81f0e4a2803e3f9b44fd9a6918e2ab4e564997d9e5e09cf37efabeeb73ade7ba36f73575c007d0253e93a3062545b4d5b40b00b970d94ef73238577cef67dde2135474e0a49dd9a8eb7ee5cb4923708340947b577ad195b0617c4201f03fbb67994eb61704af341b86adb9c6988f63a0b8549f1e10a7189e80bff4eef91a8b7c7905901752714356726195f736cc3d493f24d1f02de4bd5f6b271815687d509911bc25cabf6ede952223dcce99332a85d663099648b9dbe8c4e9e6a847808158818eb217b247930d1f719b34f0b42eb015f4f308a49a61b71b23e5b0913e5a86126ac87772864fab1c3cfe290bb960f28863d2f8bf77c97b4c62e8c23d2d3832f41937ed46f4ff7943024c3fb7016ae94c7813a7d808bc851b35f7deede3a944ce383d352985ae48015975fb7dcdc32fb0decfa5fd00ad4be12c8d23ca4e069e1e17c644a63633d7b685a796c5a7a497d8d1a9665e81e440f3b65c25c1c4852984a56914f6f185e3093af1dc090a5b76dd4bfd8a549e29cbcb1d87d2f7d4a3559a73bb32e5a3cd26d6be55255e276c227f773b2713922e6a32305291f3d7e202d0eb396434b410aa2f9d6a446bf14f42efd6f8bd72277345e966b07fd215368111c5e8fe226486b32951ab3a99ad3971b545e01b93db594c2fbaaf26da72ade4b34a2527e8d05fe82ccf164380d86ebd893782bfcaf2d4a46533caa81ef08f41e518f72a825fe599861f6b9cf2e2ceb73e529d61087950229b09f14569cce341be2cd335b02455bb995ea34e5862b832b8dc95c1d492d75a58691efa34f786ae013c1e5819d1ef7d4e1f4da6c08e532d8cf9a9018bdf7941a7b7d92b51ce0142489f1f73581f43a241f3e7fbb33088d07fb3d10c2b5ae8969d4465401bb780b1ed077aa4ed8c0cedd87e41c21530b8fa39b11ddad5222d0fff501a852d6e063ce44facde16060eeedb0ac0ee72919ef53d91a99e42a7e82111bc4fb279d40a98c5d77177d84baadb935e8114762152fd6cae52991cc639387a5f0121b56b170416422492a18db4a07c556e3658676578040c866c2a6f3aec79d4ac421f19398e609934ddb7b308a7955a36801d91bf58713843070405becb01820a2e694b1912431e979fb2cf70f0f8ac8ab7eff8c80796742ec43bfd319bb25defd8e37ec043e2879128da56d74e8fab91fc6ce7ff5142a8a5f7c47869602835baeee7e476fd74cf29ccf0155f290e59a9b0e75e1718300c76f4f82eff61f4af623b0c34aee63d789e585ae2bbf38bf555241575b7bb0c55119de68ace5c4c66a1a5fddbb6b097c6521fc823a2e11174ca07239bbc942c2b2b6bcbc2691b450677f3f435f4aba10ff5c41ee603df967246ca8c193aa8679bb8b34517e4fabdeb783a411327ee1d3e78e2d6a0c84a0a47a0e11c11917996e8d35dfe3f06cd15ce0a5c1a6cb655ef77c8c0c66a730765257135998e116b368854886c40e1baf0a8130d4cc5561f57e862e2a92fb3eeabaca51e8de567b013ff08182ad06c53e0a5458a9152e779784d17196df8e6aa46ec2ea5db43cf4be4b6b8b831da1f36aeba424048e45b81a4045d15257dbea957c6794d28da17f147f969440c29306ef148aa1c55e653813f9ae3d1c94fd174b23de52a341614c48b5cc935392e2ad4a290d4134eef638f13ae85eabe2052ce431bca32a26bc0825bb59d16e3a01eac8887092946188127f8255a3b5b497ed18d9ce4bc4fa89726165801df4568db2be73cd9492ebc449abd3024be65587a3e0adcaf8d697771a9c59dd54f05cebf184824b69cd92717e2880aaf10e4c6e41b0b2a3dbd8e5640b4a2178b383bf2ee0026f789402f9a296d2d2f8df823e581912812cd8dbcf6cb20a7e309f5c95c1b26eaa374bbc6646dd6037f400ec83c2c06c47e9d76428c3560c6612ccec17b56e83e4bd60cbe4bd6f03f106f34c5fd0032f2cd348c32d28d0c9c00fe2fca9c5792268f98a1c34a942e4f2af93a5f288ba1766ff68f948be9518b8f6901f1ae90fe5f686ee833543842714d196b72526edf89a95c40babdef444dccc7693c7acaef76264127b7b0e785347cf56f173f00bdd4d45e5be7930a7716e05ab4c84986f59b8c083e829edc693f4e08bc655414a2ced77351f4b120e6b7eb210113ccddac176665bb84f91d6d28b51963c27fe7c8d2d28b0d0de4de50dd117b8b862e31b15014bb6f7473c23aea3fc8fe8fade07b18a34114db348fcf1d368fd1c1c843fc09691b5ed6e1e2d181e1f0dbcfb9156ce5fa893e2d93ca7e37819df473f8bfac04ab1d5683787fbba428b7f1fe7defd004df96d1a9064c654999c5ab27b9db3bd79dbb27a8347a5f7a82a09e29944ae552a96ec98234569217ab366ed557c05bc1250488b998ec1fe48dc4a6a230b13adab6e338a0e28ac1c57e77e17bf96b10833e807605f7d2d601a88eefaf18d21915f5ea2cc4abf971a8e55687604f193a41d86ca4de56ea11d245e2aeb78f1239908b851ebd739506a1cd422ecfecd0c514938f8bc48989bbaa03f0db52df04fc2e323c121a38a28db2929fb8a9e515c1425ce7b546c445303f5cd1faa22f15f6c1b275631d40b2bcd952c3d84f14ba4e33c06e44c27bb00a42303cb2de955d82fbc4c0410ae73b77676a5ba050ebd124c5ca266d37621252bcbdce4a7ef9bc0c38b904a0d5f974581c9e92494fafcaa9f117571fab690156113ffe7fc820be4651fb4626306a147240e3096e66235eda449c9f612f3e0ac46ca39a7e948f36d459d680ad9851a7d89c1540088ef96730b9550408db12cf29bc8f12faf9f022c5f9dd094edc791115731bb41afab552b64b127885e9a85bbc1bd5a9e6d64529fe9fd134898997b84610265e904d58b5947ef9b58486ae9b563c0b888b4525e89ed7ac5d5a2b6c3551a2eccd0c52b99ac9ab2cb5312b9c3b71436a041885d282445a0a712b97313828a49ffacfaf1b0723ff4273c4dc865fbe457a109f3c5b3adb32617eaf10524e816a1b824cdc52b296f14f8c5ec6a914a49f13fbbf8520486e37dddbf51107ae4c14d3a67055083e8df50c598835ebd706928dc0691f2aa11f707d648db7043e1b2d81fc06d9fc2c668ff35bda5731bc33eaa5c6154c2b54db1f387246fac08f58e5d7f590c04b589aad085d339db803a4a66d9df80fcbd0e5abb15d3b74447a794f1e4785afbef954a94c4dac2e08991bfc3677be19243ba8501057989577434f481d09b2a2042983cd7aabbb256a258ace00a45ea08e8242df874f496f25b79b1caaa08488bdb8accb4bb0c1ec4441ba188e7819931e6527fccfdf7e82731467b2dc8a03c030f8481105e125a880cc2c3406de7289170f41e38ea75bcddc00f53b22cc66bae3348ccd32c8ef7cffd640ad4b25d2c3a2cbbdd979319118da525c26ace48c36470031277838d6c8e8d9b2cf6b965b87ebe9aef6e80f094b47e2ffcd634f7eb0e9a83355c0806ba3f72f8ae124d2b88b67102de2629707421713a3daf4e8104f85479cdb38583aeb7d35d2d3cc26ed10b53bbefee2f92aaf2a1dbda200bbacc479f8787640e06567a16e5bbc50a8ee37e4d588e9c04e9eca980c4350f980a4d6daff982cc531e124220be1c44ebb7de7b5badf3da7b481d7f0797326e3a1800a2c11362d850ed394507baf4c737b0f1ec08370c281e170983f3a11a5063c9540d2c3dfbba4e6087d1da4fee91b6a86061e0df3610dbabb0eeba7f4658b8a23ba4bcbe8a2e12a90efda2cf7ec5f93a08076b70736e279e7cc3de3395b049d6fec54a83547068df2d3d55bc4c7236a617cf98f2e6a12463aecb6017d1bc640ab4de366421b197d858771ca4c6f198f097cce7585eebfaa1c0dce8eb6e7bb1aeab344320f5d04458bb7577670b07bd18fa44086ce6e4d80c5f5f4a9dd499885c5f8df0e7c6e4a2dc326b52733180879b2b84fb6828329e4abcea810748018f4546bb21ebc73fc8130a21680fb177dd1e3c46265044bfdc097b54a5c3669895d76957a0399f175f724d5136a6dbb6932411c7be484812c7398b7407386d117dca02a32d46ac52e6bf717a6146bdfa583114ab29d86ac5a72a480e5b5cd92436c54590db5b8b6f8d21c2fa299bc9dfe9ff5314137d390a9cc282915aad5323b0cb9bf3ddb9e24f99ab370e09f23d9b42107e0094d27ed26bff6dda4c0f093d617e9cd9c8a6550ed7553d5b3c7136bc89d04e1f3129448bb11b89784e4be5bf7e1e21ece4a8967a857b007db36fa28549b1d3efd414341ee441e24c1aa7c76738f48a833992caae2da240938ec62e338810faaeec78b7d7740cb39475633ec24e371c1b18be5e9c42de61ca3885df7fc5d63bffcda9786e695a95873aefaccdaa9eaeaf43fc6b4372e3f69342081ff813b10a11b236113bf6f66c39e0996bcb46563720a6b7e13348ba2c848bc0680d770cdccf947da98086dc1e2295bdc61e9bde0fa8b976347f67cecff364a55177bdd4b0cc3a5061a5d7418feee2f8767cac8bb36938154e90b08fe8aa11b22ac4c4f6707002ff0f6b3d46b9d2f3519c5e01b287caefb281f9f05ace4bf64ac231a0cada8ba8176b3f6352e492a2f4fa5730c5b039f6713e1c824ec63aebbdfeffc5bde769eb4b3c0609bcb33707568064a03eb21b2dbe099852694918afc438df1267216609aef8a3f27b2f08731fa9b8f740957d338fbd32e2a14b3cc49a37c8c1c80da48532fe5fce1f27c1b3730824c14fe32d2ed2cefc2346d2cce4f47059054829717a6f89f5b44f66f2b9b4dd93586e5e9830afe9b273d02a2f010ce9afa9bc4ed7fd310aed8b2ebf9874395bf859980fbb4bab754036aa5331a1f65b8ac6dcbade8ed88c4d17e403ceca3ac1cf53ae286d1c18a596099b754ec5a4750103ab59c181c652038c8e522bb5201ee6407a9e6ba2391fb8f52f58e0b3bef4d6adb4df1e17e952418a60cef247ef9b5b3457a19d95caca4f42bc513d7ded7970835f41fdd490ec47154f42492fbb6b41bed1f4a73fe717a95efafcdf0fb45ce88e8562a219b50b8e9a1adade81c88445e69f09dafb02e8a5368bc91c75bad4d196ac99a3ef782dc1cf3b86787d93bb79a3b77f8307b97fe9978861d8f1da06af959fa70269a2d8867e39bd5f97ce882a46f2e57a2b284bc11490a55be7c0cb750a865d26314da8dcf318047d0df7b65afdc78236fa273041131d2b2a9b074454925585998bca9a0c36108c493df77cd33370f1d5ee947d22add75cb9aeffcba542200bc39f90c2db30bfd23144fa87956a741c339a3d74326e7fe0dcc4f56c218a0a44a0b078e9fe86e2ebb77431763da72b622efe7ae5871ec5233357c80fa9cc3d1af0e4f47775c1295f2665a015975ca0367f1f5eda147c012c57edab56376970423c015daed0855917d0366e1c2a68dd295b4cbd76feebbd81a210ac5ab790eef5d7939d917c960becbf43a2e98f23bbe7c2c380aba42a9829bf4261bc79d008ffbf7e7fdeb609154981122b6f391bf490bd186a48134ed40c6daa309e3a771d614a07c35c4608442a6bbef5f1c5f7e18b230697b3a5089797057d5d08e69bba21b4032c62bd9a616e7fd69a09a8fc0934901bc4847115eaf899289ebeae2b3755e1510ee882a7be3d75315427533152e5c3a4c4d43f9bb794dd7d31608c23848990b7cfca26ab35bf5a9d2c4d2761001ae36046b0cc3cf162e3cd38aa31d23fa549437162b4d3c812387e84c4ff5bffc76761bb77c1bf35df8411c3e9050dc448d16f595f22a28df6828a4b9bb9bc91b0bef589141cb0160e0590b3a79661221a25789adfea442fad78a5a2899108438faeb37890d32cb64560cbce1130e4a95dcbfae0e371a0383be4dcd6cf43baa7595a523dcb505aa4673351b1885706fe5ca1d6a044dc7f62ec67856ab52ded9b309babc90fb7e438787787291e67a6051d285a9e963a6911aec7306b1eebae1eeffcc1de420b2d8a43c6b6cf657d5809f3e313ee7cf7ee2e4af662876f3607d082bd2349fb456840de73409eb3658c22c4d4b3c219a8092d24778fb7afc63042c048d84ed9a33e608a4fc347009886920b2dd0f90efae757654872075b3ae109d380097afc7cc9f6e91e11a91d5300996accdbf5df85ff7715faf2a066f0de534300831cc0e18d648b8f41a3e5a7c6253db791b4c1a3b929e2690293560e3816d94cf6e45b7f5d9c16acd8aa316ba6a68fdeecf0a0f901297e916220a3c40f52fb32f08c7d7371365c1a8569c595fd2a70de5b82a5a3fe9877a8ad3029bfe73433fde76994e05ba4bdb3014198c1e2266109caf756f8a2dbe5e7edb2d3a44225e46936a8317b98053ed2544c6a1106c1cd6cdeec3ec22a9c29a5a3428713e32a393a83d9478b32bec2e67317dda71c3cef287c253d1a7f83c6dc41e36a89d62621c34f6547d8ccbcb5d803427db25be843316283f544c35a92076da3d1a3135a964caac94b610f450d3c21aa33ba653452e6d410517df51da66e4f39a59c62089e4071a68ae95807ddda3e03dd3a2a6d3204fbb9c7e34a1cfd89174939ae7630af613446654ab3784e67d2901130b911d3758dee43afd8b16763aa55854c67f217cda4a2ebb38b29b18cf6500802769a52d72f5b992ec2c935339e38e5cfbdd14","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
