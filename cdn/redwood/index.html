<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"fe43bf5a56748b06bec407b2626c9c51296ddaa4c16037469ab572d3daf92a81b890a1b7a405464d504c0e08c2e7022b1dcdb7326a04028e89a5c8baffdaf09d74b93c53c5d263ceb76191e0e4c9d6f5ce9e4926c0b8f21741806b9888439c7405849d41e7f2bd61b2bedaa45ce8ba7d8388f837662b12c24909a276d4668278887a031e485ef6d75afff8b62b99df4caa2c7424c5a8babbcbe7cb294108d21c07f04a30d9c75cb910998ca6cf43cde829a98c164d9b1616bedfa63dc3911f0688282474c6ab9395dd31488c7e38e9acf1417e3e5107e6260df78fb3b4a407f5827ec52242c3eeb8571ef5e1fd0dfa1e88c3e185e2d0b70d90b275b94f306fef983019b4a406f5758f79b80af478b1240435e04b17249b34308dfe63ccd3e89b3e183c5b4b7d2f6868d434b27b3b8789aa572493efebba6c51edfdd369beb11fd6733d6ebf3f055a5a1192f72e8183f8a19dd822bead4a19e6747fcd7246a4319546f065fabd869ef3b9324e68fd1d9db22144b89fbdf67897ce06b3791c33068be520e945245522ee88155fe4b904690741a1b73c561ae8819053744eace09cf1de56125a9154ffc2942e379e2ed9a0a96314f378627c39709360f09d61a1df49ea622ba67aa8351ac34c0b7d195791cf6d6b83f7fd127bdd054d683e4b514dc16226a25909fbae7e959133d9bc05116491cb2e62aa011a53e07a789937609ec1bc9d63b94aea46e87687bb3748036e7947a9b13eede2526f9339ef1d5ed450ba6f32b83f6abc49de7452e5c32db780d38728ce5409591d80be00c689ebc82cd27b71cd66e31a0b153b7cccaff79d6aa6a8fed2b7fb8ccf6523fbd0e97e9dead470f1728ba03eb2f27a7d89c9451f57e35a159c89c297a31b0afdb57a3a865382e0e7f270d147da885f187f61337a648c2958f1d15f9b6a274a110a95099820846026a456bbba36357f5b19b371e2b3105e9e4462c355c6cdcefccade08aad12c000cf7bf300140c6f6b224f9e310b39eff8fe86596c5f28201968c824e32da888da38db7d981fa966133717317b82366f3402d40b7b567dab6f5c6f8b00580a746cc75cb9dbf5fc7b943730b5b828c38b84afe5dd4092b945067a0fad3b052af5c070e4734e737060412c56c90823f849afb77aec553ec214ed6b2e41dc12925a7fb2377a6027e99063078f142fcd935d9b052c7452b9f2008f851bb2f77dd59f90a86d60bc656360b432b0e690dc7e6d9f435a60bd634bcaa2074d6d68d9938fdd5c9731021f0366d5c80f1fb500cefee6733fa38d6fa74dbeaaeec239fe9c1f364e99b20c6dc543deaea6f1f46401010144f1151864dfb77b2da47355c3f6593502408ef7afad61bafecdee95efa757c6d0573712dbd09e96de7a33b6b85b01f1cc2bdc2617a1017fd16ea260778c94e1add16b14dfcf3adc4f694c21dc988bb4b5b380f22cb3fea2b312293eea3a21cba2814bcaca122c7331d9416b957aa9ce9da63116c9bf65490a1de69a37e60db35773b990519c7c11fb01f8f7b3a3dcafd7bcfda6bd4930d99462b149b0a5c287662d3dbd35a1a4a2a35a200316056d9b1fb27bf69ed0587653828fd502a036682dbd2a1e4ce9cc4241af62f976e109200b7f9f96191d90415591c9bac073182ea853296b5b9a6516a0001fdd7dc44e2fdbf2e84a66a56a7a58ba50612841ad47bb4b10b6a134d016e58230bab4e29e7536e88917087ed03cdcf1749de0295932ef05f2fc16c7994ae6cb48264377658e68d51f01a88269baddf8448594702e1aecf8a8dd8d3f9751a5e92b12f3090faf7532428220ff432e2904be4fc4d2ca4075e3e0f79d49b9a2fbb9f9ed187e7921e569d0720367f5d6ea253ef59f1e5e1d4d6c0de297317152318894650782ee0b7dd5aa24cb2525ad37ec55c774e5cafee22ebea0221823961ac650d3766ce528ac93de93064db7c7a167a920a90e10107b4dadf70a5f8f1a4e950a7a52582c7c938d8cb7938e223da2d6ed4f9c1cef06752c149038b4b739d4e2b90e0f5f7ceae692d34801765075eb7e28f6bed16bdab806fe303dd38c342968cd434bfac7defb5862e88d212246a6f0bf9e26d2aa4f491d9174b18dcc832d1a29c39a471195ad8375507c262353de255d2c6560cd1bace80a37bd776f6bc77693c8097cdff74ebeaf131b7c147d7624e9455b27b836d384b6db649b156b4b9a084dc66fbc7a90b0612948bebde8c38de6460ac3507db11cb80470fe8a203d2b6a0e3a7ec1bde602596aface3b6858b79f627eda0a0f84e8f37f57f242cde6b7e080f9024f957ce06e9f1fc06084a71a9fe5192964c0e029160e2482a5aaecaf11f0f48a166a2008cac6f5a484ae5c31274e87989b75c5fbfed22edd876341a19cf70188efc28c3e0fde6e7f766632249f81e13a1b6b984f9d9cad264b7f75b7732576d5deaf806e335b87a0b9dd1e098446d2568793287e4bb3a1c1392ac4bd96cb6431e463ea64a5706b978113d408e5abca682e56d850d7e5adf8f1b05f39a6f1d6a317ce716c892185b46e8ba1cc8901fc360a94586803868539e105fed2e6ec2108acb1a87c2223b527b45dc51cba8967ecdac24edcc4a29d2d433aba59de64b60b2907f452e0d1713876c7cfd57c6eaca1b3ce8d6196492b12f7f49f3245b6d4a84533a90291a8fcc258b616c87d8ac046982baeab923e8485710e0e1db88d67f9ca707f912dd14d7da46704c93863a7786c3baa273ab9d961a4caac1297cb9a4ecdcedd3015bdeec1f91c058e76b18277b7acc4f5213504cb82dd26c201cd92686cbf12dc6636c491c9a756e5c973dfdee6f1d51c4c56fdb25b7c301998b89d75810bf68bad1585515f5ccf89c193b369f0a5d17fd50e0a6c57b4b62ad172b24a9a99e6f609a2d7d50d9cf7784a3391ff6e7710b9509c378831165ad33ebd747673da3cec90e3a5078f82dc9d2199a25d9cade53f667b6b97e074a79580889c75e85e4146320244784fa3c1406a01581e71a3ad9942bb107431981a5e45a80988b661946103a2647439811c8d45c4f86c86ce84300c09bdf00b9f4aa89cb05362a965bdaf65950259d970d7d630c3fad79a86e292b15c0185a27650e079f8c4171bdf3e6d3ced99a2251c91820231b7757606f6f8ad456cd12319c0ee405713737c6ab0c89d7c41c43439f30a8ee1828d29e9f65a1293ed269c79d2495e8287fa9f79012ba9991e988e30a337d65b69f64c026dfbc1570c22bb6304a9803c82da41df245f101327bab72cbf14757c0d9ef0972cdd78f97e527601f105a1d65603d86d47f76180e1f9c2eff8e9708e61f581136b346d22cae54d4dbbbe0379586fb5051cebcd3d9a78fe987754ef6668a1a7ba8559a9b2c7c808b838ccca3623d23d7861957c67a2589802acd711d80402357d73eba4ca2d2816e69ffdb90a2837f9dd5930eb8f73fb7a7cb6104447d65180c1540baebe8f8a706ca6adfc93a6b708b36156c5dc103efe1ce3a767cb13d346d67ef968091e4b7e4069a07a7f4ae32bab27d1584f207a0dba6362881581736fc7843465008ece11d1dd5bc4cc69484e7c0a871897f4c0eb913a8529dbe8f9338710378c82e4b2cb4dfa5d380d522a0c0c13c1f5c0bb527847a9f6fa8ba4e4f2aa7cdd932adbce1f3dedd5f250ed0f46a51089d0b86434a42ed178566b5d04928359d2a80d94ae8797fc1a0f0d7a8977ba95b953ff46ecea33131ca8c9c692dde4770f782d0888cb276a73e95a2bfcbaef2fceb28af9230f9796f6f09de03bbfdad1c6e0f19251991ac89b0a85a15a07d9688323767e3b1c6ff479b2c9981962baa959e97471b5d3d51b6a929c02c8788b640695abd931d52c585a6c6d020678e28c346aeac1dc4d2147c26315fcacc2f9cdb756045eed8b204e39b2c34b46036e2452c7dbb6ba3ff6404816841f9dd2763cb9b1e3d85d1e442b4a65c31273e9806ea087563b37ee84b708888806aa4ce3e261547fd131ad6430adc207bc4af090f9f32561d662ecc01fee57f6206b0ced1c241ba0a16136806bfa70c869b4f8ead59316e89972372334650dd3eb098af2309fe27bbcf9bcd0c8d6f05cd0cdf70509f219548373dcaa080bb0c429e9365a1d8a6d7d0351a9850f4743bb3e95a3e861ee255a152e948ffa2dcf256d488b33793edd571f8ca24882cd91f731234588257b36acacd6aafc8e544170411631675e44de3f318dd1ee9552261fcd046b0bc3f84903dde3203bc4f5f1c547fe55963795796c80b40d1771a450476a1a591dd30bb7514d109d1addeefc56d215bd4c127635102784192588a7f575d0ab0edca770bc17731491bc8a4090e066f4ccb4fdf6ed3c1d7aa87f1eab3c915e31108fd28305084dad7436431497157fa0f641b4c0beff67f37a0cc7294e40fc4cfa4b672d723225a13e008e26969e1e94d3d715f122a4933d5108ad3d32423063e3e74a3d607b33971b9d8b17f3f7261f17299482ae23b196ece4a46a8a857701b0238992a9cbf92c3ba171eb600cae7ef08f156c9514c65d34bc48b75f654590418cc67fb8da7a1dd678209c774361aedf0066df95c24acaa9ec92a3dcb0437b34b1c767e1fad81534ae65d8a9cdb3f43d8f9e0e17c7efe1a28b1e2f9fc49e3cc8711f04a2f23180c95f62658a7e8d53014b9019487ab9237b88c2f5402e405fd1b76de717007cba24a0f2c811a421606090c2f3b8313b6d877ef7957e5e800e72fb3e6af3b0ea4a6eaf8a64bc7f9e465804d21810b3ae44829f1f25a803d84d57cf2015b7ec7f8deaedb652aa7123444dc4685cb4ccbc77cd3907e5fe99e9fd04d5b8afcaeb35ec112dc5bc6f1e2ca2540695f373ad6f7185c3610d528fa4d8a4a16769bae2c7295fcf419b3ab8584d5cf0bdfa5fda88472204ee1cb1a07a0b6c448be7df9c4089e7553184dbb25e89b644b5f258b8bbcbe05450c4d42305d30d5e6c01afb41f81198df8fd87309f933d891cd2e507ba0ef94ffa032f3b9b54d3f2c80b2932f35e316275dc2a9dca6091376734ec442dd3501df4ae36aa8bbe237bab7fd1719af161579a89206c4afbcb2f85443d9298843eb7c40ef1a6ca1ab0de6f515e0852dd837781d88194b376fabb69521c35f953966299e10e256c953e03e21bb78586dd6f37675ed11140380dfbdabbd83bbdfc0f2e99bb8fcd0e864311db9de5f2940a93b978db345a7dd5b2c4a015b93efa6a7ac564a86360160af17d20ab03eda0e837bed30e5389bcb4c0d0b0a762af1f1a8d0a26cdc25793fde15067dd1fd0156c800fdce902dd1f0d73794953f7f717367147e40db47cae16346af365fbf9810c41a891b4a570e4471477e2f9147d295087bcc0cdae5d7288c63e16f89c307f8e9d97a66ea9cd18115d07b426b15b069cacc0fd7aed48092ba23753de69fd555db6fdda490a8e352d92c9eee9495fb0369449a739017761fb0e4be7c1a4e61da6f8b7e7f53f10d17cd48dc0ec0e9697094ce031b5d929b30aac71c5e596201d5af4c6190a963918bc69e403c8f2d50c22c7fe9df675d8a95b802604141b88b3720b65ea94a7ab20ce0f80a90c8d7a4895c33c9285c812235abab552aed31e6e786566f6ef4866fbe931db08cf52aa9bdf8381f410362c6c2dbd3dbdafdd5b648b5fcb8d755a2cec850813311bd7439e7372fbc4a45c67b6d01c2fd80f4b8abfa2ffb9c4273bec7ab918ad84e7ec65312fbc2a82be4cfefb1162ce917f30764a9e6ded2a3ec78ec3e707410e1330c1de24b003f8d4318a9ad18b212bb331253a69d23a845e31cc4274b7ce145163b4e91bf048e808cce6d80a3700e511832ff1c204a5a62d0a4434e050aa45cff62a3d677965f126df426b15fb650cc0ce52e5d6519321f801ce3bb0408b6f053f5827736519610149fd96cbd41ed6e04a00bbd51b2f536785725f91e16e7f87aecf9d2b8eb947535817538eee8bd84f0ee8a7228f821bd2264e867133aae60fb0a198c84241994280e28c2065a4a0ab19e762beb5cfa21c50a05df10bfc188adb298e48713a56a919aa0fe2919e215b078b6b5110beab0006f77d1b3bebd8725a05e96a3ab2a388e5cc42e46cb6612de7123afdba198b04609cf89e8af3045385c005be8f88d19d97008cb04a8b53763cea4edca713e848e647c0135e911650fe2af14d1929c66cadddb31f14c238ed9bda028e17cdf163ad50068a3428dd2484ddc98c87d677ccbff1823071bdb75b9966d82066bc78c60b35a4c3b62d9ba38decaa5cd90bc090a330c71ef29bacff0cd28f09a2af52f4befcdbdf68e4cd125e51ba58473bf912c360364fa4e075d8c80ca335280f92e5f4b457104d012f4e0ef90e126322e52a085dd6bd37ed71aac14b32890a7bf0eaee5d4e01391d2bf844b7e3e4ff304e3597a85a80ba16d728bb25037f2a5c896b2e2ea6e2d5a7ad86597843ca4dfd97500002de65bcfa98e530fc8ecde0ad992a092e32da11e54d2ed0c9a0d2181f56305491749e58ca400ddfa5e6a68287a8298b037d5e4f229ee8dd4446fc00faf0fda871e9741ed9f90f3179e3e545b9a748e7be5d536de108ba8f20fc58e3e2046fa0df50f8939aa86a9cfc510e963fadb15ff51ba4d31c2137ebb59ec83e012e8864f5c2c9ca8b30ca4ce1d12be3e6a238ac3741a4534668c236d37d438cbb559b1f9f8851c81133c628a294ca25975bbe77e75ee2c7d2b899162d81fdabb6831481d7461d7dfd3c9f39e68996bad3e93a1daed92597a566feb0811c24677d989fa35ce798bdad21a55f48b2ed15dae8bd8b46d88ef7d25bb5c96fa075caf331ce23286385307e7886b0315f2c157012233f4d20ece0b72e2a8ed1aa91abc602bcc8ee8b5dff1a8345208ea63110f9e103b9a15424196733438932ead97319be0e039a8d0cd828547ea43fb76e53bfd59c51de1f274877e3bf130b9607868775ffb4160cf975366bd0ba40f7c0fefbac15b09d5f89bdb7f4a6743daba29f48c555daf7e1aacc82e7ceab205ceefa72594958de252412ca218ecd382da8fd3a0c33b0cb85edde3489371b2abcdd9876b038277f8da692e262c87fb9a2646c95282ce409a5d1bd34d3f4617ad0d0569f27e750b367c3c14b37aadc6365643661fecef1124f46cecb7262a8467c699be43a192289d2d4ad472a1292311078bf1c05f00d0c9dbd12530a83b78cb301debbabc7062ca6012305305bfafcde516a306e44b52dfd1fe1c39a2cf530ac0229bd49e7f2954ae29fa3cf09da06daeef751c9d664a17b1502dd7535d37129272eabdabfea4667f278c7359ef2135ad4bc1a4e6edac00edcddeec341bd2cfd22803b163c10520793c1e1cdcaa0033b4418f2f9ec2b233a8088eed08efb51f01b20c5ee3025394e62ce297ab4fb7c2f796d9b3de7a0121b3a9f2911d9d4933bcf0a6433a4fa687c4f01f14624396bfceda3bd50ebe67cc7c4b461b27fba48e19528bf9431a499e8bf0b1ce22633dd426be8e74d79052fb494d704399072e09e83e6be7afb8ab43541f6ab1f54c2edeee3d039ef91ef0b96a25d847c321fc60c89e47c5ee4c05c2e837e0f39104f0b7b5043854c1e56c55c1255f6b1ca648e76937234805735c1c85e1040e7040bad27a49b149bba4dd013d4b3f56a43a53b9a88d909b6d9a5516e04f612145b17a8eff3ce96bddccab761fc7991ba9581a77fb6e6248ca46c2cfb19aeaa4533a9f8573c148c593b7647b44a7829a6cc11b0c3a8b61ca2dbfa3534b1ce30c4b94e65ec488fefa60329603f47efdef635b3b39971d8fbae987832cab9bc77458811ee0a56b0768c8ca54c560b70a19381fe30ee1c42a50b8eb71dcfe24b10292cb0b1ca9f4432fc903749cb88e07851465c0faeae88f662c9f1b5e5b416cd6b2339949d0a1ed926564de2697b65e09e32b0cc16bc3a990b61067312e154baa1d7158df437d7e4cec82032dc74bfdc4d382a80cb0edb53b4394e3c53dbe3041a9dae9ee7335af058070e3c8dfab5a679a0b3bbc45dcf6ebb07555257a0ede2f8e0fb8f9dbfc2d1befcbdd093efd9c3385de3f3e727021a6196159ba454dd8de52cbfc126b7c757b9c9d09458b17872f19b06b42dd5f277c5c9f17fdbfe6dbaa1caa81353a4b758fdf5c1d245bf5d437c3a76e79ef5b07b3c91c47cb9524ceb85a4927303e96988246f210bd5d3135d5273efdfaabe320841dba761e44b18aae7613c4ab50f5419a1a22dc43b4366eaea90dd5760084d426fbd7d09c95de4701d0c5bc566f995498fa7dd67ac338d6674ece88616338239162840eca08af0ca5a9fdc99d24fde143596c5c5417caba154217d1bf1175a757e84942649e92ef1a00d231a95235498d3dda9ce5d314b19df4900a8270a08e9355f96bf4bb228513488df757b3be862ef350b1027b05b1573f1b53c719313803617d49095e1bd77b601bf1c17bb657bae54a1fc6c24e0882675a89df0d21632786851ee682adc13e601b96e8e9db07c5f88f4c65f5ffa6cbe3c939d72f2dcba9cf99555ade99f0a7d8e81ddb9b6280b6875b7b396ea9b8770b1b66946e5f938c68155e6df33b157ef3d1d725462b946dc06b69713a22ef699090c9ef025f808973117a7cec3bb7a7d9f7df14c464d9670e8101079eaec854a3ae5a89ebcdd24b74f0ba954f9b7cd745656d7aa0eaf2123b5dfac968fa8f90567e5df2717ae810b91e4df1f2ff9b7c6b4c3cded087e1387e32b4da77a14e8ffe4bb2b9b9052cf3a8264883e9aed7d03bf9bf23fc658b344365a3946d501a48c4092267815a0ed48437e675a88c3727e024ce058684061bd8cfd0946cccd88277dbeb8f5044a84997904858d92e15f91cb2bfbbd346d2bfa874be086e9627a0e823de981afac8b1320b6d39c97dedae00d2de3a32ce0bfc2042bad949b92e835044614808e8b491189bad129e39f415569c4e8069b54296859b897f3ab165151c97523e521281975a64c9c57515b18f628b0e779638813849a36d36bdbcae016309b4f150569806ac1ae6b23c8f014ac4b1e06b1ba129b9f5fe1a1d3ab50e1b45a485ac4ff0a46f83f4f7bb8284d4800d0995b3b9c03e4130369673bb49f496c018817c9f922a8f76e7d1d825e61a6f3a18d65751a289429e5fc36b991cace554a73c79f9bbbb21d3f334eb5ebca8b458eb8882d6a9085287906ec5f1702d917624b113b3c7b9a9336534502d77c508dde378279cbbd4737c8eece5146dc2a9b3db869fec9296ed7c33d9a7d772b5691774e05ae14c59e91cb40a2a209f4dc050e50dfe4c0d4079a102d387f293cff84be5f565267fb888fef0011adbb4dcc3ca8be22246403ba2c62b6c1aa13bcae1a2b17fe50aaeaa88972be731aae354cb9928ded7625aeddc9ba5d9d4a9eb5b8aeaae5831b80e8d7c014a954406434578c2151359ee0059376bd8fad675dafcb6f12e9fd8e2d107be2db2448e58cb6cc59336c3d1a6fe9e8eed28dd82fd97769aa76c8d611dd4b9dca34d8e1fe8c1ee80199f68af2510e1cd752bd09de8ef7e33b8522c2a9d322c9556fdd1f676b7e1e3583d15e65a1b61691d1f8647997ee7925c5deec0f216b0bd219a5fd60ccdef5382d9a6612855f257895c3d7aa984304b2d948c9f648acae944783dac02875433cd0fa7028f7106e4368fe9b68c2f0b634ad8b33998bdce151b0e8d1a1663d8354510b45239e82f1350c814b4fa6a0a4381ba98e97e5ec1d062a820c93af18aa56fdfac46326ca36834a7b77b2ee79de6944cec65a55f1fef34cec3dee68a8ff0a442020c9f36c6924626fe3800afdd8a3a7464be0f65824b3b36b731059da0783e7d7df1b096bc84135a3d6e37aafccbea30d56d9f06d90b414b8ee85c63fa2f3637ce8123a544eaeddffbf6f98b3493038b6874cc25e0592c362ca610ca5ba9af2ec877094556dfdf4adb1ee1e5e5b28eec7409086268d50215355f0a276d9cd5925da2a8e2742a0205662f127d24ae5cda0715187043ec6e535fe9f1afe179d74c0a36187564ae3262c2d41e0307470b9634bc9e9acc944c802f1b5a9f6b02709d8da13ab86663642242a03fdb78841f8e198115ee649de078fb8b5e9f89c0ef466d2ce8eb291bb320404947e7e369c33c02c2c80ee8f7bd513b45e04ae3d2fa4b6a64f80943c85209310b5abd38db4133bc0a2707c267b512a305a13e4abc69416f521c8ffbad85b05557ecbaed6da8326caec8235cec872e08be74cb83afdd9da13abdfaa15767aaa1e4af1b04d6f4fbdd4442b1e321cecb2d51ca7020fbcdbf9bc6913fa368e28177b4376d35970f74c3e55469aebab280cf7bf2873cca32dc16a3718cac5f80ede6dfe03e8f7b2dc2f680f5ff8cb0d54a6d77a2e81b57dab11bca90dabc474bbe8052cc9176edc089c32c4190cb51f2ffe070f5a5de965750e771367bc2d8ab62a652185a92cee44d9ee697099a7d2f3f093813fd80f51a9ca62caa3d903adbc398b7eae62d4a2ffd2ca34cd089f01155514a885ad5ea5e448586dbfa6d1013bf99a25e5adda415b70b61e2fdc2873d766be876e12d24ddf66d3767599fe4c2efa751f7d18205e364b9897ee595a69bc975a36ae6d1615939d9e343312911e8efc5c5a160987578011e5c69f339e96634989cc6b993383962b6fdd88b5434b8870244f9b81fe6d3650b5e55081d341752ef13ee6209699eee33c052075aa6a1c471466f3d5d1d84c1aab5b26d3caf32ba97c746c3eca513cbb30a072cc537eff82b9c8f37f830cd177676c3a3014944d6ff0aadb8ef20a8b6f021e770b86422a70e2239ec514f4591143749db9aa8c58ae8d7eece4d38e2139f82ab89063eabed7e5882ec77c46d8b9ca542714d3b0702938f61bf178be15916b401f2873393346931b07b1e5d0eea40cf2b2f7391e5494b0a4417a21a5d30ec472e9ddaf994bfac7c89de55b4884a9b8887a2d649189ebfcf4b00e7fe72ed2732a6f6e6e32874d26c1fd19b69a9cdc542517681a763f0f2bc216f9b84fc2f794ece265d6305b8d2c795e8a9f27ca32579c945742868b7e9d1d273690e537af3c354007cb8d0b8afeb040bfe866c00d3829dd5166dc3bd9e32ebd63067cd2a11d21696dbecc8a71e59fe17e0cd905ed625466eac4850133c9c9461dffabee82efd4a2e32edcd773380e32369af0a54669ec74b7a3d5293dd25f7ad03955c0a628457d97e7c8be1272362331ca114963d484d396dc4f973b2f7d477cb7446660281d665ba3504701fc92f85679ba7dfa30e7bcfc9b712947e467ce37d079eff4ba587286325cbd4c4201c944a5ef3e58ccf751fcb4e7eef90b76857887bf5cb221e1cf4b90775f7e061a740e28cd03e7609c4bf976336865a04766ce439e73a14f46d8b7645b703b8787b1cf997f891a4caba0c61e7b78eef08a8941d58c4e0864989d62e6236af9c6c2a11b85db0898904ff7f64191078033fd89400fb761fcfbd48943235f9866e6eedf5dbf48446ab75540a22962ad2a8adc37210b4923dbab951ed2c23a2fa177e884738a4b5a25c8eced8e879550142ac0d63d8b631733d1ef1af0fd33474803caa2babef7dc596a75a96a266e808fd5a5ab023482cdca43c59179e458d9aeb7b3542c88487a95163bac2abb18181c417aaeff78351e39c2af42e2946320ddf6295cb58c29d24c2349ec6b98161dedb36b09c5e3999e20fcd627927d13621af9c2a3a105c237691ffdcb7a9312c6d98bac4e72017002eb334a3a9c5cee9e14decf6dbc4c57d9f176f47cd3fecb9fec92b8f82b457a36230a7ba777b60707e3a6e3947e124399b8b97956923bb6d57989b5ee1526574ce23ca886baa92766168531dd61f3db5c2989ef4db3a513f77636d9824c08bcc8903cc913cf93009d434571c293d5ab33dea1aa59dbe3150a66a9b4e487199a25ad947258cd471f9077c94ac95db83effb475f6f6cd5e0b073ff68f956c4893fc29e76a6ec9bb4bf4f888638ee342a3201f6d63d76dc3e47bf5c966db877a9ddf6ad63b2e5c43b44680997f89fa80e6fdeb5ce3c0e05ef0a31db770ed3085929132b952ddad27811f6ee5bb236fed7c6ab9c87103537d25f3229550095ceec36bbd4ed3348ae04dd5ac55482aff303da20152ef2ff866bd83df31ef2fe292737f6ffc56530baf28a1b6ab9c8685f84b4556aac9282e7f60a4a0cd6f56a4df5197bce30926c949ab01e0f42b13217bb7e9c474013125328ed18cec33275ae13b665757987a00ba5567e4117b176f16ee3eb29916849e6f58e675b793a884899cc06edcd36a1ef41469069effde5929791c562612e467853389af5d31f79be35d136976a9749d96a1744adc328103a600a309dc3b7ce624a820979e7c60a116600c75569c1b741c7628da5e7ff301ffcf8a6d369c00ee98930aef44bdef368fd18d77d8f4d3d520c3d22d12b5810df280c12d0f30308c85cdeca7f6a140359f0adbf2c837a6b09403450c93bb7dffd7f844d5a6bfd4e82be570b4a807bbb55d27777f92fd599b7a1af10b31b86864f0c81272bbae7b4240fc41062e22100a33a85737d3bdcb4b7d10a325001c3e9d6140c3532559962840175bc5f7478dc7ebc6138ee9dd8cc5b2caa336d86a01920f33428999105f92167131d9dac08c292d21e9d160464e6245a95b8c9899967ae4a14a87629c5560381a3cae99da911e63a231dd79091e0291b3b5b418ba130d6869c4bda42606c17be35b6f1a3960f4b19537f3e160f54c26a4c62f7933820b101b34eacedd5417e830ec2bb5864de3c657d52853f2d835e9b25211803727fb68d5e256bbfd480488b9c87b56b7a276d98dd1978c47de3a7153ada51e5b21797c200ab60c26d4101f3de10292c7b0618ed4bd3c3ca70ce1beb94ef8056a6e73e228e0697affcd0da4f10ac40f8c8646a248a2f38289ad0452d119bd569ac3220f0754d3b5192dd138895b85e35ccbd0ea74a104d2d8d9b25d98c973ea8a1c8de8267eeba0614395d26d103e55313d7ee4e03affaa784c070fdc3d408c9e35f1e7ccee292f72d786510a9947c24d10c582b1af0e06bfad380fc0eea769811479af041acc8ec7e9be560339e6c80e3c372a4cff93af4c9e02dfa38694af5fef7b27a878a503172d5d0fa347f64b948a2013504a220c111852b14d983a6d76606e8998f5c811dea5dd3a17d13527aa92e7e6d1d2d4805e4c37f799620f80e35b24def7a815adbb92362c235abb147208b34a536da7d56aabe95b23958363e9aa88dd9480fb103009ae75aadf3e7b3b596392150f47a8a7a24aaa234af0c5015278424874671f54a1c2d21c308e3c2a749d20cf2c6d6dc7a5ad1f524572390fadc0a0db3794cda2fcc77997395789cbc9e14502aae0cd2b4e81e74613c1ce122bde9032ad75adb5f78171f23e4c070e8b3a71cf6d69a0af79efa8e20475a64c1ffc09a3925e11398dc243e96b3fbae6f79d9ef6eab9edb50cd3ab494bfec865555686d6c00993c5d3242ab8e30f5df510189a377d6d2ce05c1bea516d08a1fabe7d4b3e5f58b5f51c4b62090123d7b283508486feb4b3a47e522a40a3904e0ee546accaa077c28552f38d018608c4757be5cdf84dffba31686af7f01ba084ae6e3a65485399ea60dcfae51d3e3b62beacec9f3e9a2e92e2652c2df58e1aec6ef60d2093be38fa86e92dfb9e4367b42a4aaa41b5d765d633b77b75f34f0312705de95a1bb74becd280b2cf2416e04b9342a53b5c72db3351c952e7942f6986eb2e027e5ba02f4eb3b15b766a2b3e65c7a70613e8930d53d32e47e0856412cd72c55e094cffc9021f903d2e66b4c4a0ec30937763c99f732aeb03ad0d143e20703935c9b891f4a8617c0f94409be97ec429f1be8fd5bfdb03c7a1fe47473a73d619acfe2b3cbb4cb96c8ed40067f719356da58dadeb935abbb958f90337886fda74a50ddc15659cefee9cd28aaa829c2377d7e37e6f6c6b6a1a1c43b29fe111d3c4d1af99a0ae11cf5d33532b95a81ac4614caea4f57c9b48bef87a17a26bf582ccef313345b9c113eeee8a584dbe4ebf8b6f3c3a930d9583c591a0daac278949dbd984c1e18742959e08d9bcabe016ab98b4473cb5cf4fffc3e22630727404293f310438812e97e0b813a9aede6dde7bc6526c1f878d90b09dcc7668a8fb04b642647f18c8b06a8eff6257ee91aaf05801624187603f7bf440f30b36bdf6b2c4d9a632a8d56b6fc9b81f196cc314063d858b72ce6c68e42719e234cf5c98689a2ed28116b6cffcde057fcd07f6814e99e9a2e8cba23f654926cecf3815940eee212f68fba50aca51f4a662ea1bdbfecc1bc458a555ce96f1c2688e8fbb3d9d4d83b91487c2dbc0d07a2ec479f059823dd5b5fc79f7554194d787fbc0bcd394bd930681c08146d351c6c61b1b2ba75a383ecd9c1c1da86663c08e744518743c55f65dde1827fa46947346cd1de69c1dd9a3c7fa780885e70239abca2de1cabf777c8550b1d632585a319e60817905a640062cb691766836c982d4851dd2fe9250627fba658107bdbc273d2f4f53215e7d9f63954b4e718ced70553ccb087c2df9fe740dff6204d53371aa45fd73a5918f84dfce0208faf9859e641da040a560aa4074611d9e02fa2cf6fc27209e2f6b931f821026f569667543b7f22fdbe27d8717458a7b6398f4be3a2caa024af1f10b9d98a87157bdab6a4d742e5a22f251d46824d88c8debc973fbc62872d34fe265514913a7aa20366091f29d8f1e4b33d47f333712d83ea41212bbaecf6a21fa71efabf08bc82322df307d25fd8e381595dc91c006bd0d853cf66ce4d2d113be671c419840294adcc41a57ea578d8bd1e6d4d2c719a3041f38e5c157252929df4c95159a679429c1be78410d4c392a68b025ec142e1275696da27259b87665d90f457348973613425b8dac85d5142730cae5ca627faa9d104e3350204eaecb5f1d909426e2bfc58fa1d296c88d2004f19b3bde54f06ce61a75e10c29d0c520907990f01da11aa10ec39104740cac876827c24ad9c568b9c2974e9e7b0e109a91da5028b318cbcda25eb5483c83d1ea37bd92b27428e9d304da3bfdad9baafeca6373167dbb7b056ec029937f9bce1b56963199f580c61258b666300a04c8933f72474b3dbb6b53d1deb25d0f8b6fdcc0c745f126855ec91420d81401b54b8e4d0804b82deeca0ad297fb0f94fd6c720773d6e82feb7c317167dfc95b13272e086c32e65f99f55dc7e42b723974efa89282eb2222244b7e1f0a94b2ddd067807b8a775abbfac80274f9a6707fa62e7d2763055f5ada266f5bf3c07e4e9c8920e1decdbd12e5b9e123a79c9314c1fd40e0e1c512997fc828d431795f6a7a601fa99b380148b43d76d57b1909db0b94e323ff985c6cc565541216fc4e55c53c87b1169b98a2e46c50113aa557963b0d7a216b0c7c10bcc26d9fd84828be601db3951c5b6d474c2944dae051d744a30b36b701d015bd0014b3db0e16f87dcc0105d373150674d8fb32ba6561db3f5b3a80476efbe9ca41128b10f37e58366fd7e9b77f190dfb90b08f47ef3e6751593e6fe22dc9257c86213b223c95a46b4ca9293528e8b6219be426019323cc79b89be846871f58eae26ac467dd773ba14a64edacb21af4807760c10fe1c2059ec96554a6cef3287d66cce53a8a752df5fa7efeab1882b313c4627c2130487d5837d6a7d6210f439c329cf4d92215663c52095600d79299b80d1d9f02d88ef5564e829c673f2e161eec71834e33edae27abfa3e6d0c8ac333b21caceab2dcd8ab89dcc04751ad7881b898a1e002c8d68e7e5394b346c2c97d77adc2d4e2197087cb32cae4eac5d406705dbecd832c077c0de59e797b3bf7c6d578bdb2bff01571467b93b8f634b8e3c1a820ca9f028b96e5499d61463d7ec917677addd743409f35e54687e24cb9f6e5b1ee8bd0bebaf916f80844035385933aaab89eaf42a1a5ad381eb1e47117e2a37568d971e9036f7ce0cccf415c2e20f4e142fb7b0de01518aba8c0e5514bcb4a4c7c3f3c28d1e2f134029107e787402f0a467c74587ad47a4b0b9e1bf71667fb668df8d836291e9b5bd23faef28d0909f97e2703d1e7ad120e19f80c7214dd8ed966207fd842d59e2cbe22a204945d2b6159adbf562e7ec2a9ede9c9be60b55f874d72d3e7685ba6bb865361c8b3e4cf79ae64bfaa626fa48af27e4d56e406ba1341358cd014032397ee6a941c8aa577f7bd6e1d5e78fa5d39b8de4f7f9b95fd470bcf89133cd6ad33d780fcb239efeff7a3cfb42a949cdaf6e6333076625a70c903174c7d2c9f5e2f62316ffdd7767c690cc2843e8a67c57880405e2b2f62050214e746dbe2db8d5aaf8beda66f4ad1d0b33994700816da2efdedd94e48fc0df8f38bdb44ee0f97155e9a56482947149f28d0c1d91c8283340c5d42d3bf008fb8660d3ae10a1f574f233c8010fde36c9e9f133e8186c9821c09175e20a9f5f86517b68b28e3104da88a9641a57a7b3df82404a4462030879ed082ad4d29c82d1f8153f77ef916c3eed425659010aad3d73795aaf10e63f859e6c24d25dcb3e28f678df04ee40b51bab413e30fb8cd1d800793531cd4960490cd440aabc846d4ed60083ce8e0b8245602ee8c1feefabc8981e634228ee794bb9b73370424af7349df20aefc1ed06d038284d6435ed0fc3fe1ab919335c193db6e9f2da2b998464073a644e111350cc844779f99388bcf9bf0c23187786fa283a4b4dce7d4a8263d1f51f7fb3312102ceb4c2247be07fa0484977f1ddb9a04aa1acb21e137362a8f342fad40d541b9a6e609019e006587117690ad8091e126de733f9347a5887194e8f815460efd25ea41a72ecb6690479a35cac8d3b2ece0c7f1a8790ea1257cff449805b92cba36d30fb4cb9ab3feb90eb0d8925573551433e673e55e6509d5204ed64f2a14da4d7fc2ad6317e240211ce29b0edc79a69698eb02e276175c8fc54e35a968d44c1b7cc7dd23a8b426c6fb09d341fc40ae4ca79ba119646a6ef5a0ccb18d7da93c70fac4b19b8f91b8726639d9fdd0aa165eee4238751f9c14e40525ccb83e25efce921223203408257b9be254b82bd8e201e8125e0606ca46bad2ed68ad1d636120cae9b9bc7dd7840df7cf896ee590ed8fa77a51cfd56e4cac90d62b05c693bc5834b3037ab6909903d75c2d9adf140635bf8d0055b4011e053f4d0e0137f6822927bdca97ae0c1a4b3922ae29a3e644e8b620b5a3aa74634853017c613b0d8a1bd2bd982ffe6470877b53a5b1d830f90009d1202f99098c49bd4375e3e1eedd0d4ae7e2fdfc2499af3c9f531286af140726980c634da455efd3b840e41bee227f7407d46ff42be0181cd6b38c8dbd7ff29ddf7cd6d97ef68ccc8b2fc9222e6a1e367cc76dc7385c983ac74b814ca833101c63dd24a8ef2a956e77cff4d0f97d3df464aa76f21748eb88b194156ba4ad5537c0157c0ee4a2286f7028084a2351fb1add334d5aaad152a9875598928c42081d10e82fa37f129ba388fcedcc29077c5a2e7194732cd698255136dfc856a8ef351b62152beb41f7adcc3f0828e4a2b489538be7766db769ae016126b09819f6e4b25baf2bc89984e98ea96c9e3bb382b5de505fb4efa82e95edb6989e2703dec8ad63eb1c73ce908fa85b68266a7a669592ca5396beebdcf6b155d1f0c75f4695477a7af7d0adc13fbb17a5c871a0e75d1ae4ef18d71408f6afbd3f27e5fb209ad8a1a4275c23c5d3f794f66e4d4a7fa0ea89991ff2a4345d1f054d01bbb2c01912ce19ace4dc88fc80a9bc4ec9fa67cebae5c73e14262de19e13efe3446b9917f850c60dacf147317f8bd2eb09c9a891f1b077c8bbe45126498f8bfd2fbb02dd0fe4f9727d584cf790ad4d3674d6c9a19d8c0ca27e09abb6b6524b5093d2bd0789f65285c6ecee88fc2aa69a6d6348d7cec2493623cb356659d0a32baa52da6499a88ec92972eefc792b3a4bcfb3554a7a6698bc104990cdf429552bcd9d993d6b12bfff9849dae460c7975add5d5d3ef4645b01465647fc81db54b22a69b14b61b09b2","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
