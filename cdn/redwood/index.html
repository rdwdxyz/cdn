<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"31725fed98a82f2cd4e110a3ee712cfa5daf4321794b092520f40eb61860efdc176fa5721b33a8e768c2210023f2cb25fb40eb02f8dfe18c4af5b28021c771db2da08a94ada2ddf3b987aab1bf383e89d6785a680b2e32330239a2c107ae78b5e06ae9b9255da15695a9479824f050e44ca033840f738e1979a8a0c289a82e17d6159aee5d57a358361dd157f84593db8a3d1f72b02808656c771e3203c8d814dce270e81e5b6210519127e1ceeefbe9d5e1f195414f7b7cbb9802a5de21853e524ce5dae872f81f5df9cd6ceee648d348d287f222a426dcf755a137eb5871122d747d40d05553f70870c5a8a32d32a8945e9cb8383ec24059f7dc6b1cab74f5b9152d31893a2465b0e4b3a0772b5eb21d6d3e024ae78868ba26610670bb8fb2a87f480f3c688c4b3973ddd911f727e81a2c644f6f209e8c9fcab4142ed1de1e6cc5665922565353d889766153fee534948011f5c084b8ae7ad653bf15e39d9111324bca5fa79295037bd0491340520e7ab5b4c3d4529599e16f0c50225b7ad9c5115e885bd4ae4a15a431655eed4382bad8b2d30d6547a9e94de637d5dbbf0b428c2811a4dd6a71db9b3da37445ac630a46e6271b9e58a6ab629a79cb6a985a545d3d52bf10473c1be9d2c152087c96895615ef8e9eb962164873510d77c6d723c058f21500a716d409f8a0276961808691d306bdf8119eab252b79ea12c079c08926afa7b490defba77fc129c7874435d74569ac3c39d0ed4456701a78d15280f1760d327ef306a31fb6cc83fa8a6d2769c141d7167cf8a5a138e652719a369489a83dd5bab1eaf958d90fa8e6581bb28b793fb2f56499ed9697a8d8b67fdfd1797bc5a581f4f6f8e2f821e3597830b49df0a54bab8139c4de0b4d93d869d270541238ba12cb00edca959c02b8bf0654a6043ad848a4a4313f724648f3870c2c49f2f684c63cd478b503b72ee974ec58d251a773834ca85679324d0d85150974d17fc90ca0d30b3c3b7dd7e53f13e851354174bef8f67f64f794de0f2095f526542d9304fc877ef4bd0b65154004ac86992f8643563ef6e4b4d046264cca8b1a2a4f7dc7b5328e0a2478815a9a7bb0aef25d5b357f72d4c70535896ac5cdcca671135b608ba89e1cee1b8224a9ed2f872b11432a63fbca00787997b6bc9932d033a4a6da343f54560d5df41810dc147e892d312f8158f5c3b62e77fa44d6e2fa739da6e1dd7c888332068725511bcccf6580c481574a618aae1518ae409f413028133bef073e0d3544522fcbcd835d11d1f026a4af336dc654d81c942f304f8d35f642c53b5699d2d4545d9ef213f06fbd3b02566f42601ac769aa80c402edb188b5db3e85f9d2e5644a89e1442e6c44b7e5c6531a21ac4a6c5fade5da8359aaf3ed1f3067b07a4c164621c69b4f668e87a474ee3bc576799f88b442b1fc08f3f1ad706469f3c1537af5befc973763f44a61f8c0eb614126d040fe2173682edf5c4b1be3fabe82bd6c9b2fc6f65fdd9368e82430a8f0941d673b0868ee492240a040325c6d7ff4a567cc1db19bdcbbe3b43619538112ff044fbd6d23a0db0b3c7418d693fae7fff04743da9f380fe66f4f1885d600e0426f51572f75edb36cc64aea5627a2dd35a49824c692e8f2c10275542697a6c8139c548f1009e318cbef25ff112015be7ea1291fb666b6c17de75d2fc670ab2b1b0303acccf6d18b6fed9f3726abfa1c2821047d644a8f635eb4ef3ab72a6e673fa48b6d98b507b75244d30078bdf05dbd1932ee334a2b3a46de6f8f4a128e3253ecd79903c711667054e6d1d3cf0bcc90d2786586ed900f78e747548efc726b60d5c3556cf584585d1da19d718413663ff83e0070762e2dab2fe9b9885ff661b78e3bc57fd58326bb1e46bddb76b48b6ce9df724e9b337454a6a4c9214e6e552bcc7d9c1071202d8d1771a9c793f2e86af64b648ac028ad9d65c27fd9cf133c8b5c5ba07050781e4218479ff2c995de86486a465d76c3e3cbb7c2fca42614a1a2125da71159d19d16b261147d5a74d60800bd748caa5226fb4dc8372647c52472066ed2a408cebcf92840e56fd73ad96d6d46e8dc499d2da9c57440786e5f627fe22070244bd03113a7a63031f8f0573687b878af749061d66f2de4d268d94e7285d1294ec8eaf280d4bc99b485c22aed394622681153ff63996bc6f088c94e75d315d6a623ad5eddb4dd7398b6423dca50946b74596df71ce98ba7c4968d86b4fd82f9be15433c93f423254bf470defde7da9d42007118a735b9f62501b52a6d4a14d400c434bf84b664d29294e0f03f93aa1be3f73ac4b0153356670d7788f0c1bc882b1462a68429047b2810758633b3d661546a0eb6022bbd99a895f23b05ddeceebd9914aea7e5824192ea318fa17ef61567100a5d324fe93014d1bc435c810e494c3a0e113d97fb384aa64aa666d0667bf8c43d1eb6b9928bd2492d6a86fbf75637da921ce1aba21ebe1129a03813bb7bd8192bf134571a830cdc9406e95672fe81006bcbae24c4150804ec33cc133406e41177d6642ffe1c519f05d44a5ff567e18c53ee90894449bc53bfbe602c6bd0d1378b9827e1313f28f78454cd43744c84cc127b13c3cc2c60914ae4c03e259ddeaf036c57678d684530075d4260ee110effe565400e0a951a03e917c9e58126fc2a77e993e3100231a13e0ad0f2865376c35fc7bc134e9bd063652a12549080a7f11c4958b166f0b3857769fc9f41ed3336e8dc2d707f228fd64a5a24e46e501fca43c81ce5fb24fe6f997e1fe75b75b9d680b9a4306daa52e5a781f6e5d4162749b416bf048bbff23e8104e892692877f97a7d37be007b33b004c5cd9fdd4bb0463451b31095a1a020f353f45ce8f6f954617955c317145fc1096e7a75bfffbbd0a74ab22cea28d07d6d89bd8720bd4100ca9c3701f73bd0aa05454c1fe5155834c7b0595ad4b874508f9d420ca2946938da45497ed0597e97848c5d033407da8ab30659704c4d6b29feee85444d6744cdd210f5725ca340576a09ff6ddd2aca42f7005a2c447a7bc5b077b8e4e8082861d80b37ba68242dd616e1a6c24a0e915b65c6a730308894309a43b3b374844b0de5170e42ec2b53b5d30f648e7bbe4317267d2a4c9af71f46653adaf732944668bad196e2fd0c43cec169963384400e1b2dc08f86307c58b823048b20a083314712ed39dccb29fad6c2ee76b9f1d850a37e4852c340b2b97240552772382c4511cf476e7bda1ab50c96a420d0391899d360b4026d002762da2f83056e82ead44f7e1ff1ac83ec8bfd148eddf2bda18b328d596d7751ce6f3faae2c7dbb670520bd1a6f231be992a7dbd344a123cfd4ae0bfc041500efe42145e11174a96f7f6d55d8e39eff78910c49de59aeb987e5cbe433dcb3821e0c5c1a75d26853a3367bd57f9edf13a2b7585ec0a26493a87fb16ee242e4ce7ae099ca3ee44cba6b35afba1fdc3a44a699ba1b0dc2fa3082d7183b03a1df2fbdc86e68a97dc8a36c6378aa1a3d5d957ab070280b2d0b861e6ca70fbbe6425503b7bc5f87690e9f738f95e36418874618b0f9d5528ab792158e03cd0879f1c34ff681aebfb59b4bcf98749d8385f7ab75092485fbf3387a4ab042d66c214c5725002e575e3a27decfe0ba28c603aeb8c4b54b3d34695c7cf1e92ea8c37f2cd61fb8146335561e4d360b8fc832b68c215e1f88487e65db4d2e42ff9b8ea09e950b8976dd60388ee30ca524e4130665375c42ab6aea1390947fd269c3436949fe1f798cfed063b5cbd80671fa1e526a708ead3f2101d6e9da9563423bb8662853f388aded19919ab5475159371ab21c5d3b9aca50da7a048c22a3593e33d4b1c9e3e6d51d3ed971f0bbbfa3331a38c8c67f51b263babecf866f20eb3329161b06a7db0dc3fe38631b1696ef3314acf2f806f0a3aedda03101adc3ca43b4e048092c58e4977a39492ec3df9793dd28b43cb7470c8613a6ade60c6dd19c4f15db5f4ba882bf1193e82ad198dbae7998524d3302177b87632db611507d73f8ecd14493ba26034244f2f2e639530b1d0e8fff99364fa6c4959a2d16d5556b111241456f3425b9d15997fb3a6096148026751f5faec54654e16cda7b1a6e50de68b0e723de2a1c1c5283c2bb360b6191eb69eb769db3968e90a1a35e591abb43d87b583e5075d66c9fd6632eccb03456849f2913f2221459c1d8b2b672de447dc75e92170dc5c48883c5c33e3ad337f32d5fb22335885e1f396cca5418405f2c542b50ae96ba0721a3b0d5e8ec59ae14687f4007ab767b4c9425ce50623ccc5fe5ebe1d6da7368407ce93a09524a0c1ce5b551c360be7d80b6e681e7390eb329ffc487b2d6ebea8ce5e49e272b3d8d9d62e2b1e3fef5af6cbb28009dfa87060701d08272b86b4c1c0c90e4c9e46c8c7a5a20a2d91f7608c042830c4e01b84c35cf66055a743f0dedfd1b0fb7ac7a2bf6a7286e361ffb671da16bee0a94ed8634f7d676bfd2f4b008b51225792dcfad1971b416c111505fe53646593260cca4527b63b79707503ada228b5e34ac7622cd359205ab8a590a745c41040e1d6c179374b0da024be54c5425f9dffa6a47a1be40dc011e83a9200cc576c7bb7d83f4c92ecd3ea07630ad268995c738715701ae9d1f149b4d5548d7561e6c43cd15127f96294573517670b1f90e870bc01ed1f842f20ff4db0d250278ac77f40719f62524247144759d37d62171a7c38c8f8b8adb24f857912233fddb0ff8ef2de3134b6c2aca606599653d072c6e5d93529ff59975b5f988d0e723006da0a1d76127ab21144189b8148355d089cf3115f1fbea473bbd70286de4d338e9473907a5de5a49d4344bb06f9f10b952287c57be9a3c926c017a31010d1cc085788daba18bd8841276ab6050947375092abd17378026cb4a3a936245cd8aa8a18b3b343182094fe70e50ddf57b82a85869e72838c0e6dd0e8c5737b97f5800751728cc1b91f65154b1e3cb502a2e5370c97aea8a87ec15862ce3678c2072239203b4b70cb7b16edb4a8ce37a04a572a239d47a65ba8085fd505d188323a9686b8942bdb76e2d03dd91b5f861953246ce5783d0deeeb0282d7d61e1cf77818899e4e50a41f646231a38f6ce75941a9f680bb3d83d434bf86e6eeb84debabe4d84a17242b3c56c262f29932b73995a4c3dcb642cc4e5053770dada83424796096097686063e3a0e4d3a6cc0896ae914738e55bf43dd0b20697c8e2cddc66d019eb6560cc06b612c902b66ef13197535fc5806756ce09dfe30f91dfb92fef10a623c201ba56d7cf03253d33bc00c96e543f8f4addb94a7e2e9da8d8a1019eca0a9e0f4afa176de7ae31b27d1ed6d4f2c35c3e7591227d22b2c58170a5e9686db8c45580f2d677e52d5b2ebcecb787825a6d39dd471f720617013569d23ecc34197c37e440dc1fca40b64fecbabe4b726bc1a2dcc7cfd7a2bc742ec2532ec31aaf5b19eb86d43ca66cb3f9f0ec44f04a7fea9382adf4df20b05bda8d859a390e45b8491ca14efdf3bb9c86a9e8fd551dac7f5c12e9e6522ae09c30156da3bc0fc906a7972240b374cfda6ce13e36281ca79d4d421322ecd3367fdd98ac86ce7073c5299e04eec902691458b233081254278c628f55b5a078d8eb3f23f280f4d3f6c81f774c7ce8927bca6f51f590122b8e8a61205821a9cd2ab5661384af413ed518c24983a17a7eca0eeb069555550d6553c786a24138eb032199b3bfacc7d06678cdcb0751f55048a5e1b0e360f2dd1464af4750094a62e272b73a35b297b3bdc83ab646f8982290808d636ba8ac4c39eef05d98d132d9dc4136309e1a38a35411f5dcaa4d4ec459670746acb4b20ec5aaa419b7458fba7c777e040da33199b227c79214a3a3aefc20a3dde0bfc9e57a7099e080165e5c6ab905084e2af31495445245d635a9bb95c45895a49ffd5d6f7e6ebc8036093d19840b53ac64a8192cb610a934fa4484dd5f8c8e99a3783161fe417c1a5236f4f8a6af6f4b9c41d82d694e5ab7b99b4de06b316889f4e17d9bec6af356b14fa69ad3b25556a114742816e3fe528b46074507c0170486cfbfe85f4f0be6ea0913e202a9f6452f429b669295f3d96227dc90b53e3c8c403d8cba0ae1f0d476f322b164400504539ae3e2929f327141944d5823f6f333ad62f313d6b030ed355b75df4bc31b775e671a1e91520964254365e41c158f87f777f885bf0f6b46f0844e742b4535869df3a2c9adde19bd09d3edc2cc8be7f7c4d19f269b46c04d8a807657923056ec1374a056a1fe3be04ea6c0d1cf114fd6851364cd9099e286c539ac454197dc3ed47db2e9e824511dc520c639ab48d315a1cbf0305c5d7279a614e357f49197f3b1b75157a090209d5417becabbc84803b96fc2712f4a8f727fbcc3806e9f596620bfe4cf483cc23f74b6fb12c64bbc56edec02c040b349f4bbe73c977928d2d0b214b9d4c07af3d3ffcdc48abfda4bc8afe88083a2b42aa4dc140e8ceb36633023a3405de69dbd5038374d87cd56a216b02350865f35f2abf79f8bcadc787ac3d03423986ca273f5048d48a41b12bc9ebcd00b5d5542c11622395302fee799d5854a77da1992ee3644ab11fb7e0d6b6da4529430c1049aa2b8e21963a15f7b707e531b1fb5cfd5ba8e7dc214fc0e1a245210fc791a78f64bc75d732a2b7c26a2b4bf0169912847f84ff892db8cd5cc0b02ab59148171d0da2cf515b0d96a787b27af918e3eb930586a367d1f914506414160ad84e22ae8f9295394488ac4ba103b83f9984ff39d28d2d1d7ba2020cd865d50fdea8dfdc1b14821dc4537d43c117332943a2bdfe84458b13b377e3e78054495dc49a85d28945b016c00ce9e8a7dd5e0118751c7c76319c6aa0054372fa224799d96169ffe71f9160d67bd9ca8504bb63d710ccca572008c56cf83fd903a19721875598dd3e819f8ce849fc8866725a22eb75ade0e8c9470f35aa50a087f014ba80db66ad65cbd62d75e35e653c4a58c32d738423a90ac32629d5c5d7d419482561b91ddf21573b4cb9d6c6d83260ac2fcb69c3e50871e2ac5699f1a614c60447ab0726155f138989533ecb01a00c05f921203406c6edec871c67769e8fd900e958dcecbc6737b1d8e9b792c17f54e3297debf67d5c5fe0b5d2c84cd96a6ba16278afc89e936899a40ca82cb5b3d2f485c7064a5023bf1002e4b1fed530fc006178b47a87badbf8f0530acb55aa3c7c034ce931c43bc38f369c6516a3c8c8ff06436817603d1b5df604bcc93ff4c9934dc4159a8120cb7744b2fb0e2fd476a4ea81b5b982c6684d616a57270acd7fe38ca31cc3b732f79855e3a01323b12c9a7e66105d9e9ae83903a88a6a3a09980d6d7c2cf22428de4cede2f15a97d16d32474595e9813848c4ae1ddf10400e243cf56bb330a1b60b6811a0b75930b0e8e9ee57a611c0ce22d26c6faf45aeaba5c27a1286a9945948bb0abceea8c2dc24e7411cdcc8c27a1597fc9e5270b9720740d3b09ecf4f9de1d25d5ed1907fd203bbd78c66e1951506defcc4194084c71351fedc4ef87211bfc4bd3b98771e4ffbdf419a9db5db06db56ce17326bb124467873a66de6742e4bc9de53d696369fca18428633ef1b411f79eec42e89a764f00d4adf68b3bbc1597e4ba54bc22f99c22f42f59dce857830b8a3e7e6d58c8a21da6c83555a3e97991700614cdbf743832880e30be577cf449a2d1fc58a203f73d6de6a9dbc26a90ca2f19f743b3cee0f7bdc49beb5d7b503a1437cc6b9aeabdcf3e8060f848d0b4f431ce91243384acab8cb171606727f23b55ef9b5eb7f86c6770da76f8c542e464abedde9223f0c1e0bb44fc30772f983b533b6522bd0f4385c2974cedbf5099810e7030131876d1712fdc1f7d2fd77d29a549cfa0507e48b0b660762cb80173306c00dff8a22be4677463deecdca6f33a062b9d4c9708b847df030d8324a970318207dda80776601b214df1faceacf9fb6e9b3e1439eb62d0c10722ee7ea9eb7f09793161e65a91cfc7c67f17e05a3ef23079c065563a15a2e4168b8745d5766e82c02bca652823eabd638ef4e5c9cc5b8528b4b45e6814fac791a11d30b3f572a1f2e86d911bdcb3951a8415a7ff73cffff404561ef9ef5d87d30b47d10b6601d67d5c980f6da0959c5ffafdbd68460708feef0ac37293c572eff2d5982419e85dcbac798dd9619243304fe8d1ba7f6b84a3485f13e38be259dee4c3168a3794566c899c6a63e4d6dd42207dc361a73b391810cd57a2e77faf300add27f9a0fe251b8287b5ca04d949797f80bf9144583a8528b86005d42ea600079fdf15635890f5a04b75c24557f824b74addb0a17d625ab8398fac25563270ab2cca9bf404cbdc85012947f5bd7b17244d11ad158402f338aef6921b8fb8b42999eb064c2b5de6fdd483851ce82f32069ae39bc3768a3db6b87e864386d8e0bb1f5bf1b9a4e6accb0be42ff955c6ad4b41de41ac33046847331b7ebf8e6c5d57551509da33a209c6eab44ebd2125619da38ba4e2a65e69b7ec1ccd6b6de09b91a062db3cfde552e53e935226347883edf04b0a798b61db103e4f6a0d91f1271777db1b4f64d2624435e2dee96f3dcd1f284991adf5940bc7b3f8d4880cbaa2dbfcff48985acd1f56a09c7a2648c93ae26ff6addd647c93dbedbfeba3f0f05c85ada727f10b0f0af63aa860bc81adc6f1030e5d41d355b6e0c1a0288e2021287f57d71e3100025461da7d9f2320051a32f6e7a59b63093a0569a25ce9eb528fe50d0b5b68eeab75b2ebf533e809d3fe4969c58f19334a1779aec742b6135150c59f8355b69b3c583c10efdc26157d24069a1c8da89e8108f1a0a80fb314ec16fd23c138a987e3138a644a1d073a3c156621363ebd4391403362ff219354e31a88124fb0b484b875ec55961ddacfe888dda85cba748961d7dfe131301ed8af3e59d95a2c20d580a31bbd66bfeeafbac829d63545fcc86053d7e47abc86fb30b9a7fa0ec0d2865631487c2527450a335ee571f7178aa9d71f50471760e99060066509fa4c9aeeea4f6247a6e61f197f89b34b4d61440c2a5d242f4c1bb11208039c9e9084d6458429ece4f7bfde601ef3245514967dfaf33538f814b4160c57b564d03ec2f51b5763a54c8f3a341a76887ab6cc312873598cdfc560d512b2f3c6cb5e7924b28fbbdb30257254509ee6bb955836352480c8b37ac36156fb2e0c92c9798da19235bf5a55bfff0fe4fe9926c60239ab28eb2ac558562b3c7d364c82805b2cd71a3804b30f8ad1420845bbd3fb41ccdd161c8a1081ff8db9d2eb16efce9f59931285d3449482c62df4563fea31b43dfe679950fe17782034096e658a175ca15bd58aa1f0e61be60d1a87daee18011205384c6a76b0facbaa52e6371010ec10374df6d7ae6fe7275b3a7dddaeee613addeaf035e554ff27bd0a3b5c1f0c4c1d5956fe352b48c13760f132a7f197d86dbca9c78beaefd4906fcbc84ea61d2d7bff5ef117ff45bffd57b93f671d88224db5d37d8c50a756234d5be120b6ef1ebdb74c4a38162077b469f1fd93affa49ca5f20e939138b1bf54d0956b0b9136403347d9d365ca9fae5612e15127aab4ce38a3f7728a843bd1a074017ca0f588f77dcde5ff8f189af707adb1b088097a05a24d785ada222661cd52e210abc14f1ea53a70f677c362a56dd126408b0ad62b382b57a7986148ca3caa176b18c7a78f5edb3d798b817139b9fde6af74082ebfff6cb46f4aa411d620c36336bbf6ed2159223242fe6a9d69bdd48f4bc8127e5bbc2260625d38b1fbe4ae50f0c55417b041e6d2b1e3259e871d0a418f92ab3187c9e03c0f634f1c9415ac419e9da19c95411d823989eaeaa7c28683a300f0c09d89eb33446161839d163b30e23d5364dd54236d8152c814f5c9dab382443c440f846f2b5e72b84ae9dd46c5f10b36c7f3f044b8d6f3f2fc5914115e71c4af1f2364f4f49aa0ed8fb5d4042f7ff939255e135e9d18fe6fe79966de61ff5df06fb1763caf0884dd1dd0d023235f13863654756e846aaa230596a3c878d81978775d0218b9a3de58b5ead3bb27c47b0280619d3b4d1bfa718dc9510a8a683eea4a3bc0cd069463a6b67465cd00d0f6fd449ccd32d13c6312b4db07c10ad87416c3901e54f958082ffcb207b5d38cc7e6f32195f152027787ccd9718f361d251c9fc57559c1f0f5c9f9215d16e4b2ec5b86bf23ec1092eec5b2f676d929d21d964c01cdecd1705ed0143f63a9fb4afec3f3ea3393d5858af167ef34ddcf6f77266a0ffcf7e67ecfa4524e2b1e09cb7959ab0c5593c046360f20bd352e7718a73a222684d79f76aca68982d6682fb46e6be39c6637ea425426457503bb35b921add7b12a8763b2751e9576425b52c96ef12f0030e095f65b66c09771ce231aa59080127ea490ac5d75933634f9ad0655efdbd26cd4eb0cd03cd955bcea236c2e719971825dfebd7d16b454b77b70d30ffa3be7663887b160a6a98366265f47e66f434138b07e60e09a9c2aa5e43a12f4bd65b764e263a59d446e92ee5c297007368e67b1e55a4eaa64b62ef0680a2bf6da0d247ca7613a9609039705e05ebc19d9d3ea84ab82a5a38c94c6930a9df07b0480951795ac8c373da647273c3bc1312402d7519db5d7ef94c29157de229c5ca6955f186d354203a073cb8cec997281ff117f666b4a97a447bd5c5238499c4a25ccab57ddfe6dc011dc391495aff89746281c7d6f996203b37818e57bf7f9f98694c2865b221ccb9af9b894b4b52171f033c31c25980cfba1da28c0ca91b6ea59ef3e87fb80c19cb1ba727171e651cdf44da8f1a3452710dba59ac9e84bc7c39458f490737ebc531154c7a56ecfe872a8b25b184dd9a3a3f8ceeb15aece3d84ca66d191cc458d73020a76c354db9f86fbe0f9f2395423974c386d544dd14b7005e4db5cf2f7ad38f57342fe3bd11e20874a1096c3d1fb3db70ae7a19d7cb5931f6f71c265ce8532db862025f7ccbfa8d63c7b2d415db0cc350adb330ed5c5f45f37e796893b9f0d29c0b38ef899e79bccfd43ecccdf217e262c4925109dbbf186ec6bd8703608758976132dbee7fa8d7b2426172040cf5b7d4743812cf52924edbe7d7b805434a3b0b5618a67179591a88944608ad8af5dc619e2431df1a0c1d5cd8a9d5533ee6e20178167a2a0a931c7993040979e9e80b0ff940282d76a459ad9ef72ba521d16ceb7d6321c6d625f2bb59c21fe18ca163a2f911b6af8b11e536037622a56c492f5d953014b9224a1e8f4f245ede501599303f7c32a23730a8da6d1d020fabf50835f96f76454486c4a8b7d4e3bf6a13db25eb1bdbfb4749bd64a28f9003a2f7910d11a2a16167fccc9720bfe6a95ef64ab2256888b6b83785b5cd629c8da6bfe655c4efd8ec3d96dc2c21b798503085fd6ead5cc8917552b3eee9ccc735c9e84fd59954ee3724df1302c54a0ef4936a2b1e12d337b5d66a3f54461306104ac5c2c70c312f34d7749b9d989c82deb7bb43c066e2414b0b5a53c8793e93593f1dfba8a887be858ce8dedc46ba6abfc75590d9244306669e46163beb844ec6dffe7716406fdb485e3b6617e82e3a33c55cb2cec11e054d399e0b368b87cb776be9f33749155353ec5ff9211f097f23fc8fc719254248960c5e1e657f79e82da2b5c9586e43050b45fa1ef235396d710763a7085f4fca4256ba251bcc717b5e8304cfed7a9c0450c2c1ee7007a056051aec9ac0ac95e64eb3ef930fc955292cd4f4ea8be57b8886fd67122b3ffe5c075cd86f384f59f10ec03fae67b6ad74c4be2a9bbfd9a598e1065f54125d25cb6248eb7607efe7a25831c0481da0698266ee1cfd085b3d6b76ba300092a3d9d15a6a879457c978f6b4d51c90b039a19abf42f25a4712deed7c6101bf46c4fb9550811a1d94e13638a40d4e7a7d78ec30c74d7361f93a3373c1c7fe8ebcbc18f0699f6abbfc7f5635ca1c7ca5c95bcc3ba834e256defd52f8541904254dff7fae8a188f788bc67e283b14614e23a946468d79d4be48badb9b45e5032979b96ecab0fecbe4cba23ca470683e2d996f15fbcbd5c5c0334835e51ea04efac7b100f7cd68a4848041119e66036a0bed4c49e179423135496bc405c2f91fe6bec4147ba3008fd1164a73b61c51d3b634e5ff245297b5eaaacd85a78f5e48991557539e0b5427968c624e728471f4a2f9da3c03b34d5b7809e8e68a8d6c97d3440c215def52bff17a554e14cc07f484074d06a0293093fed78e1c61f6e74e222e574fd3f6664fceb00864b6eacae528f34bfd2bd34900d8e0c0c0142234214efc2515a17d9f38d3e11c175886b9bad4d33219055686d2e7e4d7830dbb35584141b63b5fa38b4e6adee65bc670ba88a9be6ceb577d600d20d9066a615e67a12fda3c1283b35614beab22c99c9074eec64c4190943d70a18a26c52dae75b61af4d351714b88ef4f44526be76517c7b9ce731b3b29516b01d893249cd640fa9809205b866e2a9eb8f0f7499a52f66e8a9521160e5abce08e09e4cfffcc1303e682dd10f95ef9fc72a0274e5c7e24a8f9455d0e7640ac61483dc6e9c7180d7958d7757c8463f38b29e731762aaa4e430bc9528ce77dea6954455f82b694c41743dbbd76d1f82a2fa594b1e60576dedd4a797b798203109796ee88e03437646fcc4dd98d87e928e928824a79d3aea4b73105d41683162bbcf26a75857ff6d20ff1ea3755153bfc242705c3fb888c867f9bc4ba355a3cf5f4faeb728489e23f15bcb00fdc3d07e79af3baa58bc42a2d433893febabfb544820c5f9cc4b3de5f4c5e2bcaeb0b68a76936ab05c87d585996d38acdcc71ef1ac29f9cdbc0fff9b536b9156236bb0197e0a878d389bf038b468aeda23af10bb72ab805a8f68368891ccf03f00064975f51b28e0a8b33bcb5beef8ead370d66cb27bf37b6b4e3727d60ee518602da33958660d509682ae706170e8793f55b16ae9bbb41c48ea1997caf253e3eefc26a1dd52a4ed6c565cb6cd9143cd37921c80b3473083f0e9e3ba5022bc3237a234fa7ee2ed5bf0bdc80e77063f39056dba9c4c1d882e608f1632065662bd2a95d61eb8d65ff6366face0a14e8ad22162649bff49c5025d70c671c5c2fca2d88f6e30c7ccf2161ce4ae09bd1f45b1b035be76966def6f7f6e9c8febd5314a58db6f56f42364b0a30b1306dfae6179dec81c9baade62cef7ee857b4d5ad0859ec14eb982260db08b237d1c1446e3a24cee011ec7ec8509ec090655ece769c195305576a8a19b3d55c2ad88c308585d6367243c09247bcb0a818b3903091a77109d8042ecc09a357da5295c1ca3881710e8a1994d480d4038f8f58b63e5fe73a67fb92f9d6c707265071005e5b1e63ba0a288e8c8c4e174a1965cbc11337a8fd27a6328c72a74e54cea773bbb8e46e62dc89e7eedbbc5cd91921b3b494956794fb43be76bec3d09dc978f99464f81d2926ceda2c78ea9c7e5d76cb5d00f5c372f28cb0261c249458ee4d3dba6928d378d94558a786a152ef9b55b853b6698b977dbb9bd9852c56f228116bc2877c23511b0d9321ec62c4f3bca2c6861f36f56d403c85f239c77ddf43bb786b6aabcd3585642ef56ef5890b22f96954bd3cc44977f40606bfbc959e89e9074bf4e74e0d6ad565d28d67e84d369ca1bd9862d1386ec9e7fe7a53901f5201ad0183889eb2b8f13705757fe3fe42dea8eb604c3063c90091f70b619feafd43c37192ba402d671bf5e522fcc74e846df41cd59917f092da46fc7338f62a8afdd6aa53e70b9bacae6bc68f0d85dda2cae7ea366b95d6f95c7279d128acbf916ad429b0e38621a25a11d4c0a579c8d65ecd4951ab8627324155fcbdac9605ccaa949aa9f967b678f859722d52885930dba96c1bc31e074c36782b88263e77c5231caea2570644977db702202f1e0bdc838c4eab46acbd4a5e982d500b020549b3244b28adfab58ee1e5a773d675784f25ed9e46574ef62ceabaec98941e90f4dbcd10824bbad8f24f933750b83d35f3c942a08920a967cd5be752fd99e5e896e66503f314b5dccdef4a8b95a6815dcfddd9fcc73475362dd5e87eec1759a57d26530022df1fbc0b98d675c73ba444a9d7d6dd6c39279c8b84fd12f844238ace8b9d620b44921db33819642c2fd112a194c5d39233372004fb1204e7e4df1cca1e91933383550ff2de2556faa8f13e2765cc561427c282cd13cb9d7e78bf60dc32c741d2a98dd5498a18f38c5ded67b944dd21552e82d79c0ac06e5fd3369e806a68ae34ab2e082a2b10978954fcec121c0800b52c8dc413a55e03909689af784ca57674d1374a3da8cf1fddcea2f07918cdaa22c7fe46114d8091f56ea315bf719dee8edb26476c143a311b55a5e90b75b24801a65a1c9ad085de373ae79bb0bed308f06a759422b1f994108abca090eda9875f1c26965a50ef0959c35aed00a2427d80a852c46384e3c592d1b1b19ebf0bb6ed8e459f158a892d524fe21f0ee412c2e51522d211f0e97190c27cf48eb306640b15f734bd3b49c3f0e1519831ea417c467bb44d768469879e0fbedbc5d80c769d647480601c72e4b65c759ba8e06be3635120c04c5cd37ef4f5c9e4b00de13178110a67fa6296d5afb438e9b5e1a8c257c445b0511d660c63b6cc38ba679d22924b9c2de8f12c2c66589b1f287192f69790b404d860174adae583cba4bfcc969c8a4c5a6236a265a9c09cdb76bff4844f41f0f5da4b20b6ab34db7dd9e6d7209003225c9c0a1f84c22733f9466ebf7dd55e44e77c7289816a37c8b4a0dba6117a75d2560f03cde3f9e198aa76f8a83b3fbc72f98d10063fc600538d0585983037a058cacbd311798ad1a57d8ebc89090df85592de2982af43285f768e69393e7f49f6bd7544d3a4f9f090a3f1e0b3dfc7110f43481e356d2be71427146fba6a5800259d4c2f7e7dc6b71f2b39705dda71a301575c60ea621e73e4ed87c39cc0455fe7b9a1c23d75c88895bd5a8455e9f812d6802bccd0f10e1486d280f9ce79da191904d55d8260d1a47577f3031f626171a8f8ae69de16cdc9ac422094365479aa26c3f11dc5487259bb5dc2e2b141aa37d06b983c68b5f5d9193258d4b04bd544d2823e4f01a5c80d02e5abae5e5ab7954b28274d1c7b295a9d8595d683ce2b18a8f5e8cadbb5f9847f509207be08963de7aa5b21515b217f620ed9980492a21193c3fea8e34e15f9fc83eff493a6c03b5d8c0287aaf657e7f5e159b97f4e4e019b9bc3d85113aab9354629233672718353714a940df77dce81eaaacfd2c370df613a61e26092aa02326958a572385cd9bba67f4502023c58b5523c141df13873f4213aa5740d4f6eabaa6c61e8c661758780b0b272d114935b4f05305eff492c575af4464a2118f6b33c93d4a13571d45e86f6e3b3ce185616d4bbc4af4d9bcb113175d6a05f6159f36c9fedc2825a05ecc6ebee346dc03592f9d2e49cacad2e40d524d8503544e2f722cc1fabd8254842ea81c449715dabd9c5aa7034a2ed4af266859505aad72182b1661bf89dc5b1c2c0f7fdb2433a557cdf17337dac6484a05c235c9c03c7401cbfa9cae597cf25b2de2385ac00c9c96567b20833ba2eea84edbad2d61d340a0b2e5cb9901b0e79b11220cddcf32381a0e571b1ac51303ebb8f7e6515e4c1705a256dc81e98f650cfb5f6f73937cfd7cb2726e3893ff750274178159ea744f615c56cbab8aaacaa75ad2eef50820ea9b0fb113672331d26f91d13cbfbacdd9967e49acb9df0582dc4a69bcdacf3327481b70f0b0e7358b5fae6ee8737ee4064ef2a236a9f7fa30f41676ef26329bd81197a8f6b144d4a09a48a2171ddb15bf0e72c8f84cd54b26ffd362284c033e668a57374dfefe5610a07f7ba1cba7fd55946207b1642e70459c35b5fb84a34cb2a526c47b5d396ac475f550d73ab8444d8b01b7b17f0e99dbf46dd60d6f879f03cfa4d2f991312dcaca5089dfd954d0779ca7acc7a9ca99ab39a2f510317dad7ec90a9c266c17c26acd7142315d373aec63ee963ba0936b39d68d91e095209f12907f2a484be783a7b83c310f8b2e02eed04a2c42d1d0fc18be39182d0662918802117294f501b2568da140c5ff5a8a5fdc86219dbca508d992ff94f19ac2010d6135c1ddca6f187dc5f1567e79ccb98271e2ebfb51c738342aa7df029c6b977c6f0aad2ef74ef7b1c54c5e0413a400c8e4a38f3eb7323a741e56ca01523fa3e2f50095143bb157fb4a796210a094a0e92ded5eb72acbe3e0492e4b766d2aeba7a0d9fad182f035944c97ce2c8f8256d239815103439229460c995c67212c24a74e895e0f9ed0b664ed0fe30104c963dacc70514868c0abb7897207d2084b54feeb4bdc28af0210679bec198d36de93d2bd0994cf31ec40440fd60b9dfe697a076e53edccdca89b202e97ab3f95075fcbe9a23bef1312995f2baeee1123d4488399cd8582fb78b89e180ddd1eb1c39ffbbc9570c1fe24038b90e29ff98c7577ba1bb2ab386be6a4172a02bd9e4b40a330077b9ba676c2b7bd834937caa1a983c5dcdfedb4e6bcd35935da98134853f6b050369e4ae5fb333141fc13f617ecee4d93d4b105eb42a3dd1fcae72d44ca68d08c06e3fce58fe67e183d25becb9520c772d1bd28bc51fa95ce3aa746dc2fdb197e9cb0e979b12da4776391bb16ee97d7daffb1f46c716736c3b44b25df25e98ff99da343cf1b0c6ed295636c785c381d394d0131642bb8f2806d63896b1ea42bc0e99d8142ee6e4bc8d5c1e30b3c22513936499cecf5b997c7d6ddbcb0779c4618eb53c15766a5bb6967f7287d6a78c7e042100c22a8bf57758fdd64afad2a2a6d05094c4f30980f286c4fdfdbb7d76ba596ce7db894013b196462ab786c2488ffe6f59809728f52f5469a107a71eb6552ec2efeabcb59fb7904bb6019b7bd50c964afb724b002371ad28e89417bdf80888387d87355f038623d5b9237b12439f072a4e85a6f9844948ad359c00dd300faf09272b97c0ac56cc9cc5ff7678b425d54efe9484d5ead00f3304e479cafeb9e21fe2a04e6129e04336ba1e676a888087b1da508f696f9dd06531f357350ec2b53532e37e58867182a99aa1234313c7e1c9a8b611e1e2333cad8665521aa06e659c0b7f90cb16bc52cae30cc27d3488b42726dd8640f07987242beacfc87662235f815f92eaa55962533ba5077e7e618ef25182eaf3e51b28c68124baf2b6d669180c4c1298ad11f215f25d1f8cdabceda66ebf13867eb73f9677e4efaa2712e4579cc5a58354869a975e72ab327db2994fd4a841dcb22499c19ea8fbbd787bddd1b11c3ad3ee9a9acb21c38302a25aa3431f87421e78df82a97090afb8a8f3c94cfdf3c71e145b5e3ebee0ab37baaa19d40ce8ee8c44a6a58a337cf30b2f0b38d5211bf786c7c1f03c700c8c91c2c50c0603344ebdcc90a5ccdd81753460648cd319cf4dda195c6b9b19110e8f35b67443b8e569e4a2085bd21a7ec783c9d380ea9ddd902911be81a8ddf6e97070e4d840a7a683c7f302bf6b8da33e47427266b96f3bdd7007f7b710fd12aa065c57b5f5d05a6a31965142741ae64b5855f8403a974a0244256d109069e9ffcd51b4ed5e0c4d12e0426c2391f6c8a41a0aeea7a7f260af43e14d6f3c44d2f307023000a7e6c2c1fc7fea2e0ba874e38f568f2f4d7ca926dbc71de46ab607d94cd051f11b231802628f3b22ed5975611f239d9e918ba63d043e294eb770f047175c7211368849e0aaf51d5dd0aeed03497ba4fa94b96f707756a73ce1a723b4fa37b1cc7ea53cf15b6640c1424450c64f5af921feed5703e98e09f93e1a028540e19f95d0bc5c668b3f378bec228b4534ac421a15f12ace98ee536df68a10e5453a5dad58859a5de252d3d40501f95cfd30d16b815c6fa385a633b2f09ea3c8f2ac7399dc8c13cb6a556828b3df4f15a9b380e3d60f78d0220a2a2f74a980bd6904f9a4a1b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
