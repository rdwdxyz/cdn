<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"91fbbfec944212d899ec3e8d02e37d4b94ebaa193787f73aaeae4771090b9d05eb3c834892bf2bf7cecb06fbfb5660a22663ce380af06a24bb4047623b39619eb6cdb98b115898d1aa751f2c8d0ccdedc0d8bd497615d7bd2546f31492aff504b9b84ecaccc68831ecb4592e2d82c41fa1c0a5ed893df6ca62caecbab916989dab4aeac065b4a33dd8a47c17a76ca49311d7473a4b2476a935d43f8bc50d5d46b4f45405268ab5ef6d1af3d35727cd1fb5958094af25f2335c5e19e022a0b53029bc2b7fbf6a6caf3d72cd7911b39a700c965f05a837924cc68131cdbd6393e83d53d65f8d41fc0feb4b1c706ae9a96fc8f3aaec1180453e6820e5a10a143ebbbeff1ab3baa4010e6d0f438266ba2144a3ff331198c73c1be060e63a41fef87437830b5b6d8da3d1c046b1b2041a5a6dd0a7e01521798a9f769b7dc68f39708cbcad7f583170bb03ded052f3c7103ebbbc666667c721b295175c2603b0b9b79efeb5fbac4deea019039b0be34241b6cfb6551e7a36a6a347360e1b5c1b853aab206646faa89d5af1fa1bba2f5c37fba20882c6dfab452e6cd4d1e6ba156ab3d4390e2feaa8fbe458a050504768c5caa728556a1b70a4fb82bec2cf30e26324e8c16d5e0ee4f67f6bc550efd98372196f29c0f48f55650b2ea6cf0a85eae73105b5abb6269d8aeffeccc0154898deda226c90e6c28aaffe1f1d7c9e77eb0ac5397b614a611ed1e333a4aec7452ee4ce0f6ea2639e5715c84706e19c2f59ae1f4c8778503fe81f9691438c98cacf9747c78b056790943950aff00798fee40be0d766480d460346071a51151b2da71182a450077fb1fbef2fd36ddc833a9695ac3d09bb1ffce93a7e9f41b17b3d806c9ceba0881eef465f7c2169ad959dc0437f8fd817900f540e7cfd6bd2898c4172989ee2019f2ac61566d4a43ab328c827d140b24f1347b66424cc2d82be5ba1b878fee5d3e8560dfc8a683000917ed23c93c676999b23daba085539e7f091979e088800094360936f0cc828faac660e1f269ffdb0175080965f307080ce2cb36fc6dbb26d76195dedc71d7ce2e4fd5fbb4f3749d55941c21d2c6b230650d087b6c13f482dd66938ba083bf71c603bd068b421d25afb0b642ee473963ccbbfa20c33804c9ae522aa05e27f5b7be7b2be428ef25b597d8ee7170096a6fa7c7870fb1575dafd3cdaa6e41ff449a742d9064861dbbb47561b1901a0f36c16c9c7306e20de3be6f21efe014cd51a2db3eccfbf851a2e546bfac0ab5621f481b1842a766ab99c1cef582128709355ab964279a683929044cf408cf1c18f04cac943cbf589c029709ede374348447ab57cc24e77bca48f097ef5b113b7615a29c0c8ee1b5f1ad6c01f7aea9167a957fd1aab58d9781b9114ce01bda47214ed699c394cd1dc47495fe4510b8c4d0f405d7380be541a7b61eac11dc1f17aa7097f8db07e4670e41d49732632bca27797326120915b2570180456d0c48570d627769460d18cf7c4655a208ad6b9187acf31b9b8f2c0d3f4a50f97d8b8b53248fd114e2f1fef0c62328dc1fe8d0e9cc8d243e7311b125ca1092d4aeac0f966603eb64b020c98207a04c23f33e245056e23ee61623fd25691ef1a10da36cbeee5e09014d57718f12fd73ab385b2406a72db96b7a3bd7efd2066524ef56e4702d19468b7a61dcc180b862900bab97024d1423e2fa8e98c86541f3ae687696a6c386ccdd26dd0a2c57e85791a4e324933223bc2136fef70d55ed57365596b3046e5418276fdd0b02eaa186f3a6247f2dece1ab9ee061ce85c472efe179e9e4c35bc6d8904b0e5a7086e38c5fa7bc960df44425d4d40a52027646fd6a85f264f07122147c27d220a30a9574df8b292394515ea0238009da7261655608b84a0036ac117697d5bd197537a6ac47090f64c83f91b04207c00c563515c49519ed4ec43e93e93c95cfd222dc7c36b1009a9e559f639402b94398a96ea0c83185fc0bc85bc531373c7e45489c187f496609f96825d1957531e3832b406cec77b7392c9815771e645104bca60ff44f6d28d53e500c2d44fe49c56249009a4dae6607490bede0e452bacd9a4cc3be134932aa9575be6cb323437cd406c85901d19155d8c7e116506c3c7bd0bf6db1e4c4f172489ec9aff9e0bb0bfb0945b7e63b9333de825029301687f923cfd287f63227c72ff542baa64767b93c4b5f9f6376783b34d101fb9f849b2b5c453838908038bf3d28fa69826d0c00e83e3d2d358b00777269a6b2c96e097c3f3e3a9fcd02c79684e64096bfb33c35dca92bacb637bffbce7f8525e55d34095e868f3b2677170271c3015c7faa8059dcce93e1ddfefaff3d9cc5c895964aa0b10ce38cb8a17b946bf044bbe9047ef305286dd8b3ab7f60aa314e2ecd933dae931cfe445ac6afa3fe4c9135987996904f9460859606abda7434cc6538daf3cc113f79c6e5921a55c2c2f8e2838c854dcaff85b8ec1fa1f87edff39f68bddaca3f7466e2c7d0fea3206232e6022e8de8e76040128e45fbff3afdbbc5445fb8e75fadc7ad7347717e8db51498af95157941aa9f8032f045648027d07aa64c4b019ec25c59c46e5995ce1fee13ddccbee8f26391051504d1d4f8bc8d3bdca4ec00e43834de8c97526e37e51cef2a6b819616907ee4f5db4d9e4ffe1e5a3d35ca168e94f02dc080a192ffdd4a83252100186bd3ee8bc72434867c7357491c48c93034e4905200105c3a90dcfa3b36018a953f375663963b6d43da9ea0dde20fc4e2630348e28f10e9a6ac505491b19c7c229a5bd7b7f7617d3cafcf4a1b8ae29467fbf6e215522ab5b68f14a444ab627e7a705f8825eefc2ba4ba81d48d41ca863ef58b5a641ec799763f1e03313414c21f5659c2b1b5b5485e3b901c48d9c6fc24d03e47e935d32159371fc68860722712056d69b8bce13bff323b1ae52cc93a4620d8da15b8094338f355a6b60d4ae403336834b0594e3b35b6ad20e08553ed79631512bf0c020e24f2bbe9e0b4c9f13d60436cc3ecb6acae0363e3da2e0ba36bcc3e01fe7a30adba46ca5e6da7ddbc12d8efbf6e237fe1082cb5c0a2fc0ec28c7a0860f3c7c1a417b24d619b9f4b948654b2c71f137e1feceabae4aa5c0ab2b5a5f9b4c657e169ffed6b9d9422aeaf02216bb4695c1e064783e5250a06d213b8f0e0d81b40b44276326a98c5e37b06f2b7d4b855da8e353a0c8467103d04c3accf1304a368d60c8a420aa2679f047789eb8f03858c88f7cbf31d20525a6117a4104af3b73dfa238c811f59c32f2661f62fe33b2361be88f08e56c53102751755a896bb2c8eff4bee48a2d64215632d7684c821bb0b191b0d856718a586c48c4fe661d970c69d75f4af8bea645e29230667c214a8aac9459b413437fea72d7d9d49a2502255b28ee9720e7940e6a3d812e10a56811c4e305c30114c9273676957d6c0c08b9a089528feb66aff63f7ce031332cfc0f9fcd091412eb589986f79cc9d986ce07687adefc952e579da6fe1c169393f48bbf5fac4b7f539e2b6572d593b981831208bde8b96ca9417fb677bc9a64eeaa484b287a7dc23ba27d5a8cae3d4e167c816f658eebd3f2fd13a3eb614cb0c6dc56ae60cbc93d749ea435ed156b3006fac13b74fc2d3c0dcca2c305b16658d30f0f1640cff630f50f853a8cfa319c34505a10b3e315e3f3b66153d61fc920d7ba758ccacddfe85f419b7fda3f98362cd4f15eb64b62c18b87e49beb684b6482773b26762a51a8686f3331063a03cf00397f350e5d9a3638736824cffdd1d370b487cb7800c6646724456cd4468277db0585065b2c195b34e0316ef7efa4b385d23e952b5a4e88474dcd757e088ca82051a61e9869295f536f5b194fa6bbbcc2a9a35741d2e6ce0940aefed83c18615a2ff9e8c1a886cecac9a8da41ac370233289d7e5dff1428c579e785583eea87e20988d35dfee7879389b15db9ddb61fb3b0ae058eccaacc3f0733523dfc224f1554c26fe0fbff4b3b3ce440bdc7547ae448fa067a93aff80b7f16abd1857fe28f550d0bf3aa3ce3f6d5b1d789df493685090663f839840c947383ad69b90e3a553136c230ab0c10a0efdc459546f45d151db6850b5b2cca85017a78af42ec41657e53a2b581a1a030359d7430575e3671cee99c1bb82c5ad14039a549253c0884add2df3568a91e85bfc9885e3001b6ff7fad6da262b9759dd07d6a104cc7e5074e462c10a4f159ef915579562b34a55dbc2cd571cb25bdafa2e8b1bf369e783969ee142416757026da902896dba4879253a511c7090a1893d04fa7ebc05a28da419a162db86bd8e658150e391e82b02eebb6dffac1f3b87c2b7c71c6d3031791762da9a8f237bea5baf2389afc8b0f02ebc16826f8522edb0a64b9e62fe31a8015e054761bbb09285129b5ee31d75164785a251083db63f0c1938d11d06e0eeb72601911caaefd36bb9d17a0d0633f9a11fb643375949c369391f72e464d85a8aad6fca99f00bf3dea3e9d4fd6a4087e30c0e4ecc53d7f5dd4655bdae7e2d15e0ab524b79cba8d3b6fb6d3ad8c0c12ac34ab4718d2e1327bc349ebda296634ff77fb5d83a8ccbbbd2597a41082d4486f7cf3d6bb9842ddcf53db45e9b5ad9e05f28a24a546d24f872a109bb0462d27e61321f701648e1cd772b9ea10bffb5559d18fcc9b63dc84eacd5117ccde0630b2ad1417e31fc578e169d736915b948143733bc93c056aac3d23b7f2f0c2aa1ae2a9d24e51ada2b44f1935c931993ffe371af336ee21965746280c813057fd8699ed9e5f017543c63fb7b84d8f3395c6bc07d123d74c51b3bcbc1a40eebd87461fe33cbe880e0ea2a69468a9e515eefe196a71e82491fb6c65e4d1e116225e64d4f2215f4e21ec87ce598417ac74c3a5dd6bc5b2d14d478fdd8526a00abde6e4b39869e309e448f7ff080584eca4549ebd3d39788034433584970860794020da15c31cbd47cb71624918ebb3bea3715e90ffa591a3a5e7884d44c1173d2545d89386bae30a62c255f39e2594beae7eb9c415b107ae3e3fd915d0b8bbc26c09b19aa788b1a10045c1946224f7701dca0a56bdbafb9722b35df8d5d289abb4baf6dbee0ad3d5c1eeac1c1d8095fe898088218aaa8ce3f104378f3fc05347e4b9c782c4f068f4715b4ae9456c769739dff13d6725de780cf954221b833dfb3642d29546a1f33cc82fdfad69f06b7354705746334a3525365ca171a17cf8948e8ebdc02d667dfd43b005755b86302b100cbdeaadf4dc65613b55b3f85bd290f36463ebb999f1f4fb382b4f36a4efd8cc455496c1710f4a0608002fe1c925fef266f35782d697c34da91eb810770359b5e5c09da197ee579a01829c05cd745ca23903c732866b8bd440088170ae2ed64d4936a9515e778fa552ccbc230f0cf2d368932897de9f16b233a8ea03ce155a014c59431755ab21ea5f9c2b8fec41ba3850b4a937bc619932bb0666f955b5ddb4a5a3feca490ee5a5a7f68b834fd4570ac8fb3c6ed94dcc8a1715b5798ace69fb30379b06de3b7585ab53f0980e36c7aab75ae980b1e6a4ea7e5064ba765d62c861bd4c4d3775b2d2a0a717793ac94b2514c1d6f9faba41e3979a8fa87c14085d6f1b5f2986433b9b2ef8b62c5334246c53ead87e68c9550ed8d1f0868dc603b2ef7af1a9cebab24d769a927aa5f248697587eccb814b421bccfd6599d34202ce0eb7e8814f4073476d087c797074a3512b17abc25e319ac24a70b7d6eab5d6edc88955a96b59cb721df52f76aecc5b3d7bf7acee9e462968ba283d6e513f6866cdb5a888d00df65e97bb34e9a332d64249c0895b7ddc396543fab8e2436a3ab91ae4c022b327e4c5aab3d432f87dc4a09a172b6700122c5dcbc4ce6020623efc31df17228c1917848a539393e1453743ffc5c1b74202424b06552d053644af5087b029bb129a083597ce965e6c9d3486d2e4b407bd2faae9e925435c58e4409d6851deea879bfebcbd971bee21e7ee82dbfce8f163bb0f36bd827bb922a2ca26d6c6738fc943ac8427f311161a8184dfe53de1c331ec9f32f1ae6af8ac70bf40d5d4cbfd670ee10a673eb2f371858bb24669d9377978178cb8d968ab52ba4c7787b778c5e041bf598ea3648756907a74894cffc52faa72ea4a8e5dbf7f1f5b3450edc977eda9d6b5cab4a97dd7fd9cd8a6b846c43af551a0a06a983ebc739c12c38a43f531878347f0c87cac28d9431bc771d0ee8548caa567d082487aef627a9c705b06dd087044894d0fa32911f19d5ec5af8e6e166a90b58f3ee0e51dac00b390281c6d0c57be2cff909b7fe4e80be505ecb2a869b8be2d626195d50d53c38abd2271608c77cc59dad81b633acaaa13d93580c925530c51ae42aa44a4aa56fda7c1b3c9ae46300220baec4a7f0eba00db84d38092825985cb3ec37703c13e04e082bc4af1014210c406bc81e3fd7de0f05b0541741f2ab2cba774d24603ae8505feb7537ff1bc292d426bffbd338f5e38ed34cbed6320ae2425b24e8238841f8d8f9dbc62c94918264750d19eafecc2191b728b4d65696850e43fed70cadb0924dc9e4c003fb37908487d3038559a6b37577c873c26d39fcbcf222b62351ba4223c45f2793aa5dbef1b5545436f25777c03667ca59621475c5406cf3956cc1854d76cacc995c67af7d31674cd03e142e628592680889606363c5857c3ba4d50d6f6dab4aceea6e8a4ccfb57499e6bce9b904a9b308aed91e56e15ffa8f91a48d2713e23562f1ae36028b78aac49e749102c60a45005c480bcb6ce2371a5ebfd7c9015363a024eb9ab76c711106f2f66f0ce20499913df95c0886c1df38656408c656ffbf2236fdd305765846c7aabf1eb77e575c7fce5ba87f10619b74a9876fc2d2be46d2000d82d2879993924a0f1408b0b180414c94ef248fbde342cea2c952a52cd06ce5958a8fc06ea27ef4493e80b6faced50ceb8637f57ae11d3543de7da617776c158e0b54c4ef3920af5d7a1b094ffe2d96175f5021b3188f3cede2c93f8ebed27ba7ac608435247a15071c5aef37b70e37fbf58494c087bcf004db5629b967dd982292d9770147e149fba3ac06b18d4b95efd829da1a209308aaec48531cd3f170dbeef2aafcc6e007d6ba9f1ea65538c038e9575c5a6dc0e8e9365d1341756bb66646415b336c65cc46e810374fb350e2d83764814d62e0d629b9633d27f0b0908afdf0e493e955675edb8833f1111227253158a95216f820ceb5ec366e3015dda66487c0a5ebfdd0d4d9f1b7f4eb3f1931c040d295e0855da5bf3cdd44f9070be08c8d304eaa8776a359d08e9cdd14757acefb28a57b1298692bd2d0660d3ed05b3e278c55b6f4cfc1a53f5d04b05a80ff9ba6e42601f434d5de5bf157c555778ae3873a29026ede6d5c06f0f10ce71546b8bdb86261b8c0c2738f31ff1bd4cb9c697476131428bd48dc33811e5be01597884667d96624a3c000f36f7d01df38e8ec690ded80a77a7dfe41575af386412fd3ecc5b0c442c35206036f432996bfa7b61bb9ef3739ab390472fa383b51ce767e772c7ad06eafcf85dae175d99faa9c9b027c32ca731cdd6c6689b4b8eb1a1bab281330c202ee1f55932b0a4156a3938747f63ebb4d709060370bc421c060f7c72cfd8b559a6b0dd826ab1f59b078056e7b8ededc3272e980fe4e0140116f4cab0dec1b7d10f734519d99647ec563da4cc0cc2e19ca6578571f1c3a238be117a99f3b8b14bde5a8d558caa455201a047f9603e0eaa2bb27349a382343f5e22e14b6fbb6b3859ae03878e73b0c0099df0125d2bb74d3f1e87188350abeba1154add750cf9c15ebb3a64c7049c624aaaeea733938469d94ce817a84e0db07c074d2528126d03e0126884a4be62c703603bf15ae5cff98d2327b0e64461b3052214825c0f39ddd718a4d4d1b6d01d1b478166ad7242dcf4628dfccff3a24a0096bb3405e59034dd16a47d425c6643515af0af61f606053a570df0b6eeaea084ba3e57e52a2812b2c4f1324721d0a1710e71fef3f0d2e3b80f7812b684c6d0a4c5f80dcab0d0e992c87d7babd35897caa1d47c0d653b992d28a4c3f0e14238495cbc04efc4bfbd0d6cd1a1e5db261813df1c86e8b4552f9c453dea8a80fc45372968a7a6cd9c823f3b15a9eaf951cb48d3222fe14d5c29ab2e2523110e538669cafd63dc43289c1d20d0e5e8899c14f4ce9e8f4c0c6041308ffd8a4505f84cd3c124b779e9f26f2aaf6a58bf5f57cab72a9005af50da2d51d7655a56463bd24385206cd646785e3ea8724afa1c1bb61bed2b80bb033b40a58a62b6d867060bbd595b0e8ac8d96f71c1d36ab3e053e848005bf51c3d732ec30276fa07926b9937bf15712b580563a7cd777e5bfc2bfd03051685f25c64b5248a6bb4666d46666fad6fa49c884f300a628593bfdc113b3c9ed0f7dada8eec8a0d454f5eb5c1fe268f801ecbc4204d29e261a384ff05f7a94419d0bbe3c88dd812e1d5f56ab85c73bdfb0036900af9ee37044360386918feebaad9a7307d1a3a5715630e1de026d50794ea137468f6a4bd7d34051f8ebe8b037a75be529479c2abfa7416256a8d39096efa39013ef44e0b3fba29c47ad0a23b174e57fa187e09bc5f7c25bb94a9164213f3639b20a6a2a071410ac5b2791d98c38425c721e6436ca5e5a53bfb3501fe70faa5d55dd3705afb2d61bc2f5ad93ce0c1c3c00de5cce75346e8a6bb94b3926e246501e3b506c80a1ecc25b2c69bb87363caa938e6832df56c6e33435dd786c929a3b004e152afaab5e259548900fc5a6a661215e25bfac47f6cc0fa58534ffcb539d3daa22eebb27a03d44e08e7df37cedcdf960b52c61da8481894898645c9b01f633943ffa5d6e8fb20dbd819b88e5123bf4a86b02536c2a6ba278374d5b2789731cdd933605e137dae9564a51475db77b9ff7f4c6eb2022ea4d3a063bef5037a0fa4e81e990f8bd52752de5e85ccc50c2cd9d46009f05e2d55b3a32643d45282972b0e0ec62149f7c8d31006db7649e0727c99bff89d291580b7b3f7297c4cd4cd358a3154061da150ed7d1e1f885ea30541b1dc3831f65ebaa7ab998d2468bb61427160d5e432c6022191760b7f7ce5e8bc83807276ada262d31b20b5c92c85768093f3deb37f367c6f9420d372bfa50997900065884dea0092c9103bf299da0c37b772caee072b47083900a6dd58c192e51ecb046de718845aa521630b92d85b814daafc860c6f8f1c76cccb47197129249abb99dffca99c904496ceeb00df7630b3e56b71d706478b582431f53e4b6ab3bda2d321b215646e638eeb3953a2018d2705c1dc8c89701fb87a0ee28bb4b876f97521194d52617ae4bb9c87a29b45d3cab35b3c9250a54385e0f85941e4490629d0de5ad023d12e6ef305d9a22de9c6f49cbc35a1d039e5590cd2048fc12149c7eebb5f563f1aba30570893a117293742571147ce9b6f7f08d2aaf28e64d80a966ebe53d3bfa1b3c46d58fb623b90961c34a7e51171e3a652d6b707cfe82f332bdf7c20b51e3f24159af0cc06c3537a2fa9bd1eadda0df4c352b5182ccccf45b5c847ed5cbb6ed7742aca05ed46fd70fe8846dba0eb612f86f566918d682523b49d376d1f95c1bb2f80c170a719be159fe9401d68edc1e2222d487ad11f445f4c32f77f9a199c2ba94f203985f95d3e6f580289bfe059991e82faccba93072896f72ebc7cc69da74a4fba61061bf4c0b9beb3d1b8c868078079f82e02c4eca53dea9fe4e2bfcaf513bf53e75d70ddc119ccb4219d5882286c850fa9b921970722f50938d1066757074f1bd6d793bcca9e4337d06fbda1a980ec4728a5c6f9c94e882c96f33a5f9192f7cabc9dc5ad480852fb61882bce4cffa5ca8c01adbfc4014e372140260cb99e7b71cf8e16376dd1e71805748873b6575677c7a1c24c3324dbc352e5cfa767fee79b3a2902103941da992081b19ab2dcd6737bc5e1222166180231e3bc390d79bf3790671fcc01e261cac1970a3b2a3f335d5f024cb2fdd22b280a39c62335200cfbcda313ca81b896b5f7886168c94e17fa375d7f98c89c976d72be25ec4a760fc515ecb604c901f78baf57c139f5e0ed903adf7c664483d6848322f874e6dd6b24e13418946b89e6a951197926de8480a3cd07ff3c56c746aff00fe3f4909a5276c26305c4902d6459b1db4950fff8416fca2ea558f4e3370b4d9ac1ec3d1a66c9a5485873b3f21d606f159918532328a031a63d53fd3c73e9c5be83c6ec57e1a1529abbfaf2d53f354a7bb96167da98a991662f7169821a4ddad63fb1855c2e265ec88aa8a514f30e2fc6e156ad922a6797c51e977e7733844a97b3ef3c20a8ed27485495cded9072bdd36dbe6d2f5dc11f382a5470f1bc9d5041fbf9ab9891bad2462ccb443f1897c71c53c1657bff7e6a02fedc918f1e9002494e8511ee4d291d1f84bb2353a1db4f2bf76ba83ef5bef94a35845ec23f70b06b6b4626a0de5a381b77f8d35ef99f9a745f3639bbdb3e2afb6c1483e7fb0a14884f4c4c109f47f491af1178383437114ec62962f59886789218c3fa2832b87c35260bb445579b0a0f628004f84b99babf6be6a0b1e4ba06b3115f4ac09aff90054fac3aca84debf2f5123fcc40fa2b1bd873b71f4e581992b57bb191718a1f2ed0c8a8fcede0a45954cc469bbdc0df03e8f974a70d62efeed67cc12efc2a988a147ee9403ee62546b44d7aea34a4b7a80047273ae00018422d3ac9953f0adbb88334b31d99e9b7c5e2035afbdcd54dd86a1e514cb8a99a0ba21042d1015845dfa17e0371db681254c3cf4f5af1a205433a5ba71275275908be38a8c6300faa1c48a69feb9652af6d81456f1fa37b99aa022e3927d6ce75a29c5f982ec22e568708b58b2475d24a86597467a08c87e2fdc1674907e8fcb466ccd7ec824673c2b494eeab360af2b43bf823b22765ac5b353a5eac5f684be91f48b9aa7265166fcfe9ec81bc63510da7d66407ae1186ebcb5fe48b19de4684407e579e28bddcec8e9c883fe385a0f5dfead21e8ab7cd3b50f432541f099b6ee6fb1c83702a5b49660d4ed0c322796103987a33292ca593ca90c3038b742b87fbdb680a884df6f199b89f37aa701f361c56e5e7b1d8458ede7adaef7df646edc20977fce8960306fc1bf75e8e76820956187eec5b9521623909196a3f45602d9a50378e44b5c7608026be1f8ebb7f3339f1893ed30b5928e5097ed9e39f7c91f330a6baf7d6125a43bf6df5281c99d1a49170bc8d53728b8f88d73edcb4ca5fe5903684713594fa66e120e9815d50d5ae231f78fbf437ac440876511c7958b5b5e7dd8f25dc7d8cdcc1a9f93b57d2863b9c7b137142675bf3db2954e30af39ff22ca19ff4c9e1d8c45ac8ea2a54cb0d9880e99fdb23aa61181874e87bf0a09c7afb427c86cec287e63953689875a7a3c5d6580a6984c09ac6caaeda4d0b0680197951cbe7dbcd3e9a25c5b845bcc82a567ed2d7d76bf3cc67163cd343b02d4e5eefe5ba36435e5813c8dbc747a04165cbd278e49bcff4f5c4e9b1aeaca511419ad2c906c434bccfa9e86c7bb9ac83ee1c0e3614ba7e83d6ae99ea0be01a9e1cef01c68d16435b35ac6ff437a571812ecd33e0fa76a46ab49db371f4fcb35f1d79895825a0268a07d6ea868db01ecce0cabfb5d64a8f7858be0522808b897436d97cc7514945d5ceb59d86b8b1b7149f3a2477b8f43f20526fd2dd2a494f0fd611fff31d8c9cc518a054902f10cedba4cb1b5fe44ec4bc13b3883fde3fff1fad93f51bbd7268ca168cc9d7b1dcd714a2a5fe71da5e649d1966f5220e98e1cf3fba3b58ecf8143beceecb5b9d3ed762d295cff6a6c8d13425d58ab06bfe21b23855ff9cda5cf61f446d47bd2acf28024e45067981ea961864afd66b695acd656eec73ec8e333b833d5237e2664b720ccb2a719610f9f3e106648843194af5f27e461ae77297d0ffd35f5036b8b254e68b99c448d9aea1a42a0b732c065b9731a6c6df32577bd53596ca592a13849ec98742565a26b5128a07e4b2972b29231c7796870034c3bb30085424206e1b947f5452e48d1617a760da101fc157628e2cc361e07b31ba87a9183cc5019aae416ee27e1cd4448656459b5b74016bf7831520500884fb02832fee82409c02938da352c6a498e264de7a3941940332cccb4f6925faba7682926c5cd8e7f282f561c43c817d9556e41cb8fefcefbf2a80e1c300c5e7c36c94f6ebc464b4f087fda344365512c30bc8a35b7f18b2a47beefe115ee657ea43f151c4f6171ee89d5036d52813d4185764b62f431e4a2d14bad3dbfd0d761435f31442cd7bba3731e6b978472a06c9cb1bef34815119686c32c0e9f80a6fabf616994f6b7cb38747c2f91fc7d3c7ec303c2795408f27fa8fa710811563ae9e4a2daa19deac015cbd23041ebd0bd118631d6b3441bc1f0aaa0a41fa3678965b6ec1d175f1ee76197e7914efacfd571936224ff295ade54b6d5b7f81a8d20c6f9a467a5ee868fff5acf1bbd4c128463b683f36b11ca2b7a2c57cfc466e5cea3bb2d52fb2a70c0b22468540c8b9c265fa3383ebfa9d790d354e923a6d8743c9351f813fd7f3ccc306b1f6dffd7cd39e52c08817a5afafaa37d8d56e15eeaa5c8d9a3cc4aad8678e9c7414d54d15da18d73822961623a52de7172396959ca67b641290753d06f577cd7d1a56057f3437475f78a6a3062dc380f3ae30db8a2c8b7032ae6346812376454a0e20bdeac339f4f4106fbd6d35cc6ec4c43e24cab41c1a2e4afc13916f9e88bb9da5d84c2f80e931ddbc661a95773ca6429e010543b8728f61ca184375921901bdaa7d876c31bbf66390302cc6b8ffb6c1f00305acdcdcbaf517c4b7c0b85e588d264cf2f354b8d2aac58fb09a2ab2e6c7169f3ae0c4e7358ab3a9c83ec91e2ab425bd7e631c246a332156041f63d44dd4fbce57b944fa43285b17d862472295b4c5ee512c35158a8b75f48be09987b5df6295815fd07c79fb987590a22165a5e310a26fca283d76abd0ad2a00757056ae83629fcd67c2ee108cbc42e810d5e05d4021bb223c95f5ee9bd6153073d175469f2a57b8afbed06906cadd47c0a87b31359c5bdc84b2060ab816ac234c3c1655f56ba9e1722b7cc2e0685199d1572084f7680ecc54d753846277182fb2dd54759c60cee119da8f9f817350f55684560983384949e0661e94a1bc04bee0de86b6e6f681864eaff0b4370cf4ed2bd85beceb04cae4092ebd9c93cfee39ff796e17d95197c71ea05c73c9d21e7ed4e92f35b6114f425aaa7be1ad21011dc4f12396ecbd8f1fd8b4a06217ec8cc07720ebc985d8a0668f03af463449f944f4b67a15489e1201595c9928ec65fee4e2ff4c47683a53f8ebeb14d291511ef9d59be6298d5917c49fc596ba7e570200b77a764bb291ce46efecfdbac479e68a304a3a22b82858fd164ac3ce1e382359ed3d174780461513de1a4abac044d364086c9ec0bfd08a7174d72b927d80d315af756ea378a2d464c569cc23e79bafb509e6fd2c71b55384299e6646030bc0eee16fe6b4892dd5744e8ab034907907c79e49c1daa4243c798ba4e50baa420663e28ab78019579b3b29a005aafa05e039fde7f3bb31c6c858a56d63cd219dc0434eab5f04f5cf9dcecda5ca94a178ac472e396371b2b60948a0e71cd747da2ddd068837eebdaec07c1493bba3ae7a0b16fffafac050f81d27f803200dc2a658f549f8186b86c91cfd0d39d9158e38f35496b6019ae49cf07ce7ea47252256f90dac149e65276c07aedce999504a10479118ba50c73a083d7f7f3837febc3d3af4e8fb4d898d7e99205b5620d225691e3b03542daa90d6a66a7523a24d9530b7e95a46a7bce79e95f955c94a8ab498812f0abef75146b4542cbce9160844e06912343ebc2363815b044c7bdf94ba1eddd840fbf7dec19be4bcfe79daf35f059fe49f3cace2ecaca5de58945db6c32742c4774523ace55c6338d28c92ebf413aa0b9e9e6904c313ab73bab14bea703da6c3b77d5e65eac0081f71fee5d30a4de3c079e3923c7ffdfee3f0cf8440664f195369580dbb3a3a3c59f5c4ab86f77bb80b644c2e785484359a43b36a1a13471d46f5cc6ac3f0ff5e27a742453fc9cf4d26551c964f500b27faf38b0f557fdaacb9ada2f770c4a6ec65463bca9fe0f99f82b78dd47bb62d8b2ca3931831e4d602813e0983ab30587d2f731a53d95c559bea8c32db6cf309d58bd5d12f60192bb7a760259018baaa83b8f2566d3012134f378ada68c5dac54f2d40b3eaa3caa6b42fb20364ad65183405cb82ebffca13320545cb1817b36175be83cc557241bd7c49104c25742980be9c034eb1e380c9b7d172e1c77bb1468e819d71d3cdd4ee64472efb79cc263902c96d6669a572e8d155f3198e0a5ec9d97ad69db46144cf2798d85cacbb44651db7b8f74b43f08c97671a7d2c7a68d3eea064a034193e97ad9db2b6be7b782c6e1b00d221cdda04e4642b60da1ec69f6fb3329435453c496b4062b295ba9b88b48ba4103759fd4dbee9a5814933d2d615e0ec2c1e3f3e0cafe2e226839ace12f62cb755439a31000dd993aaab306ebec8fab5fd025708a4913d46ed0538ce48ae39d198f1f1b5f19f3651d5d5b3f48da277d287488f86211ff9beefa61defaf48c8873bb0ece4177314ba8688b80937fb5a43d63d4e54c81d4c82cf09ad63b53e22f165c488d807c7952e418be8d13311ce78fd0b9d7a5a3047f7c948ee5c337d8c1f210886af0ff9bd066c50a24cb5cef335e83ed7663f8bbd9265ee88cf84783442413ccaf274ea8cf7b5822d5ec9699b3b7ca1df7a94e0ab67894b94a95950ba46e1dd795e920b773a87366900cf4a5ad911535c5450b5b13a0e46e6b5bff7c1e5f6a04148238122985fa0b6aa8508fb95df628c1fb7480a56b97f34077c23d56587298d86305bbe2d062e826a3414c4a18b0c3182c1c3c708e0d09926a744fb2471b27f16430e3da4fcfe8aa12cd15f56f9b3af7e3d79828f558358deca900f46eeff4b361cfe55d5343777b690aaea4fdf12282329605c589141eef59dc682647dda5f92d2381119b268f3ffe095aafc4933fd79fc1a716f06e760e467d42c600f37f7eff8e46a406a3d2f67092293042597c7dd9ae4b9bc1378ba4db07fcaf88d31f73584da83cffbaee71c782e2a4498a3082586dbe6056fb31b77cd6342b8f6562f6fe219cd1d113fb58e85e7eb71acc0e453a3039f6bfca26c3a63e344fb0e35ba13b24a0d86ef755d352527299734d803ff0f0f0bced50b436157b5b2c10099e1a0e20acd616117d04b89e988097affcae9c85aa5d3aec68ac781446003f19d2ffd248081dc601dd221ccd979bd0a797b6fba15e1277e2ea055c78075dbdef048153bef659e773acfcd2c36aaf3737acc1842ff9baaecc16b97bd2aa930bc8ba78473df990f3b55532e8951885900b765d6f133134287a41cc20cf2fe8fb6155e8df3567e3ba167bdec92d66dc6e9ef416a453a217dc8f2f79082eac93bbeffa25126b57cfb957fc869bbfeb92ee8274c11df6db235c15fdb4c65f45bacdaca267940d45d491e1a11d87156b44058420d675e67fa0f4db4ddcbe70eaccb18de16ada5c6347dbab8257c6f4058bdd897b74f99ed16a28fe3ae12dd2aa5498d68edc08bcc16103f08748df03951238c6b35264d50391a2945b5eb0ca31b961ac4194e26e34a5bbba4a5629e4fa486834fe80857c57c663834c17b74373f9b57e9b44f3824c78628f82357d6ed72aa2404285c62e171daa0c9ac7d75c30ff9f1f412474dd00b5ee3d25e364f7803e69d4f0bfc3269956b76f0c4e755d5ecd749d6b6bc106d9a05e3ba2b135878ba564b389356439a477351955936040c1e1d623d4fee475edb6fad09c5c7cd7c0794cd7d15bf7d516a932e68bf4337912ad85f2725e309cfe944901b185220a7e06b1892d37af741704f03778b96a0d44697bfe2d613bbfe33542a7e353cf9a7c4b3102d85bb0a9afef52e7e7168368d70b33551047d79efd66f7d9124dc59558412f97813f4ccc8927cf2a213d805eea8223db475977e10ac352fb44f55666abfa34671476f81476a407e525bd97eaa1cf5f445bbff22656fd99c9c580d1b28cea7eeedee7c18251963da70f6168099b1e920c896de17038aa80fc9b3f3f0ba385a21085e61580426bbded404d8ac9d62490cbb93dbf87401e0d73bb3f31cfbdb857eaf41ad850af3b8423234f7f4380a10e871d523baa017365803f4816dce1da28da958cc92d12b543dc0b7963367e0d809f2782a6ba1390603a9d5be51f89fa1f8695fdddc84fa0bf80cf0bbb6ef3a892e05c4c1488c9d8c7da15e2726e264d97dffde67bce1ad9b43785589302778b283171af28544341856345b40ffc63b31cf285dcb7dea8f25a9acd000ac11e1ef51b9aea8fb34637a0247ac7fa88ba34c53519a8a6d9aaba0e4fa7c6ed86a773bdc984d8ae00bf3b9c7cbabdb4c9bbfdbbdf0102f27ef73fb1c6762138e3dde020e59bd04732ef87623f93a9ded38618b27b968f84432c570c27a58ec577758fb992b39799b660fcc7b4fc94ef56bf96c2a110b3708ec17cae049fc55e0f18be23b8b34abb16c45ad851b0a1f50765ad17d11f545dfa85fd0293d7468ef3494924d399da8dc5ccbdf880e8c8cd56d8c04b1e4d0a7b7a8235482d7e616e40cba0d07d868185a29130d326a7279ac46557e8cdccaa0ea69d881f923b2043bbdb08dd1b399cf7ae21abbf54c6c479673522bb7e8be348174ea4028c78687257db32dd50b1d47e92cdad0406bd2d997350274dd0417b79b90286ec3bce628f1a1a3d03cf9fbb64f7608208ba8b5c8dd50daa6ea8eb2368c9c0c61afc6b8e47314c011e054675313c72d05c8e9d021e3ec2aeb2e42bbf66b8ba9702973b7f50d20d11e03345a99af91b035fd928974dedfde5d455099e139ca28c3f6fc599a1b0b821fdcc3d85ba033fe24359fef1c7b68a80b41263cdc5ada5d3d5279cc68096ff77e31afc67ca180dd8631db3ae6b6e6f1b900f363ff39875b69c01dc365b3ef23b0fd7583cbb899fba87a408304c7556f08605c0c1db717e43cb3559cdcc97174531552de988114e2d7dd3b504c983a578d04ed97168aed794acedd7ec5e481dc2def33ccd43f0175ab39abe59b5da8c0d467aef9da96980f981788d1984c58f926b28db6e1936370c523cfccddfd16e2e36a66ecb8423c79b26d011248dcef04fb6171816e9a24d5b2cb78e8877cd6478b4af74419c029e7c9a11e6c78ce4142f75dd5da33300e97c01114dea4ed4a5474c6e706be81eaba71d9b253e6cadafc7fb63be675b80c0c2314e604b3069a50f0ded4881ca7afaebad4f9293f61b61a18b6014e93c304f027a07e8fede47d9abb2c55dcaa006b4cba8b2ccbd0724eefc126b9cd629dee86292b4608a14864ecf3314de21b549a8c02fed4446b68e99aab355212dda76b8f7c1ec347720bb0ed0ecbe2480f75795fde5df3fc0dab0109116c3259b831ada6479b624e7f54d0587b1412635eb91e769c6f5dd6aa86fdf8813da8ab9a1b5a4f004ab8f0078ff6a5e5aef915c10f27be1ffcbd681b93d4774a5c54ebe5d1512f0aa46b9b944e5c243c47a403a181165174fd76ca581ba4cff547341c8ef96169c4fe6601236a2e13c2463355c6dd9383fab57438443b46193e5d5dddde0de90ad8a4478dc3157173682818dc69bd334d5c6ab31db1e6bc2ca0502d67361e9f51368c706ec103205b61f8699ae79fb6e31cd7686d81221e64f0b32902eec46418ec32ee543d15e26f5285dd5d24b3aeb50c55938cee0acf7c247ffb51626b5fa0be1941c5be867e3294ac02348f2ca21829e13e677268767eb945daafdb8b76dec0126bf6f0db6e6b3502af28ed3a5c25d6825a0f8804cf4ae8a6f44329e6b4904b36f473a0e3b48b1bd7ca249d48ca5f8d70a58f964ce7be44df595de9e047c7c47cd","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
