<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ff4991d7b8e49e7a605bb6a21fc1bb0f5d082ba2d66f74bedf641067235be1c9f36264cf1977de2e6052ca754c13c12b5113a68f24f0047d3acc64beda92946441c972ff03094b819ed6004477a1f5cde75dc26766b008f255302b3e07015d172184f0fd10cea92ef152116b370377a0c6194fa1c04d450aaf530a56dec4bb8d78ffb541f6cd9656e18162d88c5719b73ab4cb276b8e167d31d441234f28814b58b2b15c560722e30450131ac62e6ae0e81bca8f394a65a9b70258aeffd5e14e8148143f3ee31e2cfc13fda45a643d2caee219a3174b836e3e8cb7d2341d55f59ff2aac7c7f59a32a8c57fbd40ae8ec0c08b7cdb1e557de0b5e9b932d30e7d2bf61407a6325fbd3d994c4186b0a07ced1bfc0edc7e6f65991f3b5f12cdcd97ee7e5b00d2fb69495a34bbc5716bfed20a4a1cd66b85bff09ac51647b121c2cd15eeff6def1af100c370dadfc42aedd094114881ef8627a5ee1c72fcd55bbb1a435aa09f32a5f4207d272b71061a6d08bf0a66d618465e2cc888e8c7b238df8c312254a96ae4d14e8bba83947b7aad0af456c071bcf1d823edb9c017fe5343586540bb802bc417f0418bdf4b950e73bfb0b40cbd6898c411ce761228934a081b6305da741fffb2b9fcfb3e10dcf7c0c57260be1cb48a9100fd387cf5c9c00f1c9aa6c05dc492d870cb367e3451b935417e16436222cece51f67a9dee0e200b4160b8d7e6cd59c2fdf1f17b698fce8c189bfab555d744d4108da05d43b68e0b2e85cab493792eaa34c6b05fcc2bc5c4ca03b4b1813d815409fe3e1f4e1b6ee3773b1809888678193187f0e471a5803c6ca264df02b94f8f116a4549fd010487a58d965abdc6d4321328d2ef9c35f2790c82c014d4c83e6895a5529dfc40a7a3d2862bec4273d747d43bbc98f67f9676c225b9486829be11e6224cf7099129c124040003aa5434f07b8560891d24d81e0d6dd538274df4c1fb60c42ac2724f6da0a83340576c3ae20c597afd27ef1a1b505aad51a9daf1c251ea3dabedf9dbae838685093a99f0deffb334edfb1696cc5958d9a2d446d0561c087669a15d7d6d123d8f986d88a77acc978963d712d9b533e45d10d63dedbffd8bcc1bf550249cf15a4a18c9849a5539b77cecfc4603f29086584623c0e16b734f1e0a3c17549a5f64f505a1fb005273103641a8acf10de39dd56b2aa2788f98c203a4da5c10596cde7a046775b946a62665c041d2f61634ea5ea4962f338531b36a424ceecd4a3b3640bae8d9acc1b0330587ebf762d85a2f94142d97780c21bcedc0e371f7218ef1f1919ece8a5a60cc42e283d889c1324319d3373dc5b07302696b702b7f81b1796bd1712daba485d6ef76034e70a89aaa51f7715f46a7b1312805fe58e36ed7933676698b2240f7e3ca18aa4bce6831be5fd4005861351d92f0d8376bb6c26e55b55a6c9113b244744ecea4d263137465ed6f5f227270d8b89c0d5982b8b2b4078bba6f22f29a8f9c45b422a7b7056b8dd18ed5bf1a53ede0c638b5829902e48a05d06ddcdff097f594310f067749a643d4e7a439f5d2da2659a827511126152ddc00dbc533a1ad468f306a32e3c52ec2689284b264a6e16a41e0cd7f450777fbb528c3ef57543508a5e734aabe19743e9308f27362741c64a8232935578db607c082f9d1e6edff1623e326633b65fbfc3b1356e1941ea06e68517afd48772c380841dca5ad036bd6382303d40757b1561aae790c4cb3bb64a6bfa0755210e488a99a112b85a80c4e17c72bec144f8b11009f3795c7de8ea0b89688d6462783fff24138becd4a2d754896a8724a7d43f111a1ed22eb91c34d04263340db7b3a4918fbeee649c6b2accf104f41f1cf085d7fac932838fefe1b316a1bfa6102a9321db143c5ff33fcc0535fe60fdc872d0bfb6625998ebe6d9cda478fede91d7e9a05d13af9fd04810da686641a1629254aded586b0669632742b32353752ab6d7f68210f674bc8381ce2b8f8d0eb693631fc8f9c7846ffd0d13b9e0733be6d937b5595c4ce019e37b49a59597e6eeb437cc5715ad889e480752285ef178c62f5a31995830fc59b6448043460424b6ddbe7f7f902ee5da627fb4518a143f83e42433bc48e0449ed56bd6013821872c423af6e28292e2d2106689f923b926595f6cad8773dd4f0cbbae667507042ae3b5afbcd5d79e58f2d9340ee39ca78aaebe5ae0f030c2f94a196d0afb6ba3a6a99c804349f1b4f39f59e9977e036dbd18562501cf2fcb83c64304453576f9b4f5332ebaa10419c3ece7319aa7d5b3ef4a23728803048a83469407b6735468f9562151d452c8443ea36e116ed25f38d35283b47b7c651a09ccb3c647c0dd2aca038d0b437fe47e1a61e59d4055407972d27c67b2dcee3baad9f765da9c44e130c1bffd361851eec6d6886ce692ac7717358fd35feee324747118036339b42061fa2e541136730e0ea5ecbaabdc647c4bcb03bb4d84e38988083ecc8e94fb580eb23056c0464662fd87e037f9d480e61eb9e26c4fb74d862bab0fd87e82facb44b760b58da63d7d7a29e1acbef4665f160f1841f6ad75e459dd95832a48170d5f590087f5f5fd4850fa4dd335688bab1c1095c606887f97cd90767e938f161408044608beaa46fd40c14c3cee8fefb93afcafa752fe2896008eb67fc6e1f42baf61cd1ce0d52fd5e92a2ada4996c123f0005c10a200be65183a22300377a34e4cff5e32a115cbda451d4d796709de89bfa5cfd1605b436149b725678bd17d91b1507a82f3cdff1e4cdba508089b356bc25e65c470f28a3c69f0547e614aa192b48a176ec5dc29fc87b9a01e8e9b68fe4eab11e3e325ef2c030723a14c73d0069de17cd28844be09cc55df0ad01b3c4bad16b300612efc93cdfda37a66a057a4fd9ca8ad79646f446dd4906be03e930c31b5158e6073fc84d9916a16c7ce56b873576f0258af16d646958e2c1e9f196132ca7a9678f5a0fa47a253a9f2078ddc1a93d8c3bb32af9bc8f067163aa1957f8704bcce4e082995eead474ca1090014472dc66d25e7c7b4a90b733ea95df8ee6b9722a1d03e8798b445dfec6a859a22b789f4adad55fc66f88dfb8b0e739e18de3b6f9eb69f518c94d3e35e74b60de4a29606dff5ed6479a87c698eccdffe24e55160ab08023c616e168df70481d0ca6ee81a7eabfc4e37bb8a45f9c097f8612c66f2d5ad91a900a0dea1b563fea644f1e6e33fa7d22e65e527d15d539982d6933b96b0548e720560c97c501198caa5d15aef22798a9962eab6bd93cbe39a3577c200b88da08360c1276b2eb438ea0c5cf4cf8da37ee39c62582ffac116d74f0f3470f29c27e88ba6b164d5bd9297c040bddcfabcae6f4c5c30b3f08ec370301ce854f557313c788b3632d0c1c058de4e8d3dfd5b8a6b8edf44291ca928591cb917fe519679603417dd21d44012e40413b21d7f80101e956a8af74d62cd9527ff57b467102cc73e1134da636a958492ecfb68803bc563657a7a811f2e0ea6c31d672a085011a512eae9606749e4898fa42006c3026c0e729408f9de37a94ae7c5a37b0cbd7c5b56f096a6f1513a1e92477556bed3ab048532364f090ab17beb4efc2bb0435509ed7e7a585d7d775277c9c1ff596db8c07cd4025c2ee1db2292208615b0732e762634f63c70e3abee09ed6fd8fd417bb07e776d90d1da6d962bc369a3b6026fdbdc425513c149ffe68c5d51455352677bf2b5ed3f13aad27d02a1ff988f104c79a2376d86b1eca5eaa96998b920c36b22fa0a047044b8fc950217459e61a452c0805f17839d007dfff2fb11e88f39833685a105384ffa22d0f6fb861609fbff92a9c0d8f799b927ec6c3a749e4e6b4b5459961475af788e50ab726b3cd2cc3f91f2b5e94cda59c8428af0a3d37329f107d9fd4942d5cffed4835e579b50725d9971bd6e01477bd601a7f78ff28bcb1284da1f6bd638619afe88f27852f4a0805a61902931f6fda4775b5f8ec76dc78c75ff12165df9d44146f17950eb4e86edb88c1cf0dc99689db53946064661cb2119aad446cd89e568ce8e324ec30a9d408af8ba4d820d5136f4ce4d3152d7dc5d9c18f8cadb90b122d2ed9c2efef020e375b1649d5e1596ed66b266f6132744dad8fe8623d8d4336b592b7715791feb6d9585c784f9b8ebe80de6e8ce045eb3f2366dfb0dd714154011f6d967273df50999b2047d6f8b072a7000bcc147758407375b840809b35ad05517376f41af1e3a306a43dd7ce5e334987dce78c8b58697efbbea516f265fb10b626ddb2a774858c430551b829d8b288661293c1c66dca2a0f721cb040104e39d6101bfe8b2f9d35a0f77162cbef3e4e9831a47fbc0cfd37b49bf034a6f093d57cf672c816cb62200683ce6f2101020e294b5e519e8c4c04447d01e28f08455c0b0d9742185e385a0345e27b4b736d9eaa9b50683ce053fd5fc77bf6232ebba341077e1f847cf9b35593f48b8c011bfb6e6db1b68c890ef4f2ac48e2b97452709b4569f14067fa6162ece6a7a9c046a707380b4cd9b43f40cc7b391dffab02e7ea66293cca1c0d4514ccb514bb8892fd93419751bea8fc1e48437c4a0be71d78dc95fdf3adb91d040b2e56e84fd805693610cc4a7e7bc8e9aee63dd0321457be411f43ca70cb2a016dbdb8c1eae294894270c1cfd2e36ae091c87db3b4023d896f7d9408c772d894df4d61111d7362b9fd7f2c7eae53d026d0d21c04c0c90b88a2a0f5e1a09afb03e55a76b04f39bab52d1ed69bf13b9bdf18206305e87a433adade7a4f4d4e318dacee78b8546daa296fa217fd077c77a150f5644679a4b7a6d4f5476f221fea9024c936591044b6f682dfc3d9cbb1579b068f03a03621c0fe409ebfe79aa643e15477c43a1def3a508c508a9e23e9cbd4c424d5b8c474595306382337cb07f064d45848d2c20ec7321cf59aeb262e091eff8524dfae4e142c26f3a1320dfa0682fefbfe2b59405e8ecec0dd343ad1b7dd0c70c25130afb40f09c98ba42080a5b1aabc92736bf7b62bb739ece45f997dc9a3f0eb8c28c85827ff4a79252511aef38526f069d32e0d3bf761efb2356da13f705fd468edcd442bdfd6b6b1994ade36b9c6810b5153adf31ef05a19d5a7435f2212e816c7e850560df7511970445d8a27e571ebc54b663cab4a436685c7296fdcc096d7070a1c8b351e2bbb420e1bdd309705f0f81e5cfa91f4590f65256264eef849d1f8b56011eef740020739df1b9892fcdf0050516a6c6361300b824167d73945e7ed48879ffdeaa6f8e9fd52f883ec37a774621ee2fd1be85d9e614d165e38306a4fb251306f941b17dee1b0d0b7da2e45d66edc3540997a7e345be5a68c533b30f60d1f623c1e12e854a34c9868e6add1ee7d239527dfcbd9b52f9bc86d67766bd2ac433eeaa0343cb08422203c2aace62946c1f15cb1404e9d67d54344f6d50f39c3216075c85f82ea35c406d59676005193b1150bd78492ec8ba2b36d28114a0e1c65218b59deacf4288b603ba501c4594cc2c924ccbaebd96920fb218c54dc8f3179b79c4821fbb32c8bc33de09b737bb8772f92bbba145e40bcde368f97865e435009708549aebd805f352e209aecd10fc5c3344cde32ace3c79274346abacfe7bb2415d77c0a706dc20eb3b662d699449103abef951b8299ca4656374ff4a8968d6cce4e1c93d258f8a6d45f59ead0ff8d95db5c8881f94b55344a92ae800e3c5a6f205e62a98cdc2b9e3410e08a08c6a08761946ab905734e26a10dde327c03154876b547f486eacc2df4a7c1a654d4f1b474dd0fce5457f4df63f3e10c5f3d704007a39b3bcf910d7504a3706c64f29865ff3bc8f6d93f832db5ff62a1fb6af1e6aaf0a94def7c5d3a22dbfd51e95bcf87658def43d9ab445cede509434f1c749406c024ff7792fa65654e786568f5063248054c0747aea0e7bf1c6e9f616b65763629b4aa7c3e4ae95b4c8c3160899190cc49bf858ebba8475ef83c16ef38b8510d904ee0184f06f8dd7b5a484a9b3d1ef18b399b0c1f514a48bc4a4959684e8d7608ea47bdce53bc4f7ec8d8f63b2b1bb70f6da438f6caa846697ef3ea9e383968ac4a9a2a098ca03d0dca3f813453c72ff7f7e3e4ab4da5a187c91e431124dfb8085eced7c141c35665c834e646bd79652ee25ecb8c6a3ff74d8a12c52608b5a28651001de3a851a69950e1801878ad41360dbaedf72b57f7a7df2509e6c0326f54f05f5e0414944ba486cf0cc018644af5839384413ad8d9b23163d7e6aa7abd3ab115222fd10156ec02b906b02565c02207bc0291de19e9fa22284035f32953c01f0a5cd3455ca1536a421f2c3aca2673fa4b3f6dee4e2d84578f6575b45c88f32c116550914776c1bb7b48ee0c5243058a058ed28f1ff642a627b8ac3e42e12892dadb5fceb614885ce0d3820c2cc2d6065f6bac25692cff38a68c754006bbf3111a4c553fabab1f11fda983e160c345637b9dc78449f9d51ca8db9e58c3fb50f009f296a0b8cddb012f861f0786429cbf0d4f5263936a0348fc8098ebf4856ddf25ea8f6e6aff74387edb743957ba144e900f799fe0d1464a98e8ae4a2193fa2e614164343703aeb375564ad24caf40cb4a380a75058c5d6a1c5c89c67ad0b5b49a940ef4638adb4e1cb0825a2aae005657ebe79205ff5e3cd7a8ba90e3cb22db851827f4e9bc7f563631aa4f223782aa5aa80a8759af640eedf67470b5abf757593d1442743dc7109ec91c3b57c512c727cffce69d65aae36e0f9a99c59f75f64c87166ebbb0557cd51ba7d810897088f5a2643da4bfde744daa94630aff71ebb8b2e76ce944302c23129f1358bc9bcc73fef1255ce9c2bb42d326272d047f4a9a0db27ad524dfb395274652682d7192c08a25cccb1fc81c0ed37a7071ca51adece8ba39791ea287480f49434d43202717dd59be87c2da585331dc52da838ebe646fcbfb14718921d4947a61e8b697f83302f9dafcba568435ba91c3f9d9ea8951c477584701f2a1802259d6067f460dd5d2f4954d6872ed21ac0d99b7cd65e0ef471c426a4b0a28d7975912be46393f5390822942b2507eba263c9cbd498f3ba29f78f7ec1a4f73af5c024e4b8be092c7b48a826f7f7567ae74569d5b6e0948e00a9aa5b17c3174ebe57d3b9eab84a57cc2688b7ebfb2ec239b2f707341cd4f0843b0d669078aa004d2f8e37742d7e42e225368b59eb2cbddbb5a0444498c98d3c453ac19095cbb2d0950defc954f7cb45e5a49139dc888ef2447d6a0ede0a10ec26b48c97813312fce46c5730ab3ec7aa2b0a301b528e2dd7c0040aee93343c272c7bda616a673aa5d4dc23bb0c5816ee34a74b2821f84709a7fd764633b87f3270e6755166fc2643f49afd2a96879b04c58bf41d7c465e4b76816b633c4157b089757911b74f3481ecc41ff69d48134438c1b153a0a6e104ffad24f90ef162c1d45fc0fc1ddb0cc958de1080fc6066868ba6abee8d6b43979fe92a5a06251be8665647705be41f2db9dbc7b875c5e39509f97e3494bd9e0b8048c355655b0f9983b3f0bc18f000d5cb64c0fe70930743bbd5f492426194b90ad8c43847d07a0456c0d0391477a9e054ea4d1325b77607b6a41571adf25349fb57c5cf209dfcc77699078ad7be164ec84554bc4870d46d2e776b21bc957ed90ad9e6452ce32604ebf64318573e38f3829def4fc66d9947227890e16d217447f17168da4e0a4b9d02e1779ce0d7956a1abf0bb46249642d0acae554bf2ac9573367cbef64757a1cb16c5c53d8a422b1c49171c343d90b2a349c401733ceb9f85b83f7120100616936c1cda1ac9ef65edb81707bfd67998cf08d735255e37325d781f9ffb552c76b6f91684021eb3ca5794834827e78c047ee9a51cb449354e4d6d48df084636650a5cb31c95dce3242b1b3ea8b5efd0f38fef612802823d326efb05ecbec34e91a954e61993774fe0481c18ac13c7c8bc089553bbeaf82c0ad0713ab98074e8743ac62e0d4db82db14685b27b62af217c689b6b0e29beb225a82ba0cc1d262a6af58e75119ce5a18100a60f346e1ec44f209e11bc0b9abec44161b08874bf95932550d60aaa129cfcd8db691af3a600459a32937ef3720e40a339f4f7e603c9d922fb56cbd63bc816d1cdb32724efda7c362792a8fe9e70938cc961f86ed102d9027b48d05fa6fefeaccb7de264760a25a8138c01c2c6116ac97d7613d7382f20061621936abc203e97c6107b82cfe17da3cd4213981cf091433f152235406a37e86ee815de6d6bed3f0bc6cfcda26811c59beafb5f818f19e1d4179029bab98696fe17f51e114f80e4ea5e3ea260abe6ebd8722ea9d01b840a0204bc4f3dc8ef2966d7f778b657ac9bd7a252391a87b48d70e801a1cebdbf465ff79f2d1813d8a6e0a1fb87367b4e045e9a17fab09e0c9b37b23c8943180006536e8ed76ec702f4d87c24127b6e7d63a366eb3843ffdf718d55a6ad43c4c85519bddb6ceafd50a4ac5158d3d7e3dbf3d5b856919707036d0bc91ea8f00d40ae8cab489585f6d16ed7147f77dbfdbbbc1323ee5815beebbf40724b706573e12a8ea379b37eb9e1c823e4f219511fd376ba2f29facf4242bc4720597d8fb6229cc718e7de0b0875fd73287462bcdccdb3ed7e249054f967a2e346ad73e147f28926b6a7365b9c2af50ddd910bd12b50b2bf3b569bb6a5c772d57bb57116cead982f87198346e82f03f720dba3b5a01c30a524a28b8c1c01acb7295e1a23604c4f72356e071d1ee5d2c7fffeab2fc563fac527cddde836268d38301f85f487e47498d831e4f8ddc5ac3c764a51017c1e75dcf8a989a2ded91b8cd2960f1eb536dad011df404b0258c65e3fa59f2e7861936c772f659cdd7c9226cfe87b6a484dfa80a3f11995718400e6bb79d7d0fc1977ccce9ec44fb173890a91983df490b4ef3ece703576d71c1f1831be8c6890d0928edd7bf568264b750c391f94f6265b824a2ca1923fd346117b6f1475a0fa56bf4d4febf25535d399dade0f0a8f1b577bc03843aca9eeb60c79dd7074fc8b7c0b0e4fef154eeab247ba5fdbe4f6cf50c175e6eab7e7abacadb38528b5811ece96b4346357e85ae7567e0e8daa061763bb82234656b52f9bb96d6ac368e86858cf8668e51ca8c88ea3f96b33589ffecf9af133f93c401a818c4cfd912ba9dedaaf4efc22403fe53f6a6253f4da8167222b47298e8c72c89e21f0c2bb790bc34a9268b2324efb0aaf6e4ab8158c6e9ba907d6bdf9d10a6790738e5850b7c70cd9e9104e00f5f8473893e3f31b607aa3ac06f808d46da088f0b207ea4b56fd38a4549d859698b96463569f638809a8a0e1e41b3a0fea6b6866da54bb06f211524051860170118de7df6092d2a4dceed18b8ca727f05ca16d3614c17f96861d339761e05fd1ff5a44a24d12606851895803c34eca677aa3d15b2aba0ea0bb7bd193889cd0723e0352acf951141beaa5c01ae5177e18384892fc250c98a40dc6c0d7b20b524937fa5d27fa1f27fec49fe1dadaa0f9729de65c1ce8e2f84a8845f669386aa7189a67e5ac3fdd2407bd66360389455dc762cc24e22b86024e84e42a524fe49347b634441085cf194ba94e21bf9b5268f6c2ff7135d67f03e013a9f3994cdc8b045251a6ff89b147ec7c39585d2eff4a28e915262aed3cd41185116f602e85c016a6b28c3b2b402080aed34aabfef41c470713174c008306f080466515fae8d686749ce4ce091b680486d81be2c6043ef81eab5e3e84031bfba48236afe482f7c7cd6eb496629668ec24982c30b6526f1a9cec3c8df410e4a2c87dca455888de72a114791def35a2e5aada7dd5009f36163396664301778d54c9b15325fd40d04efdd51755a19eb9aed5826d683dc96774469a30fbd68166f055a6a4e314041892cbc30e706a883dbd8cfef61fbaa44836a6c5bdfe0cc6fa08c1ee0e2542123db33aa5a5d914577e46fc25057e4378eb24dd8834f9590a75f84d9f2f807d687e0fd08750c43dfa78436d8607646051dddbbc45fbec2f0c46919a34360dcdc412b2d6833e3f04f35b1d6757aded49f6a05bedd6bdb87123055c949398be86e67e756cd05a769030ddcc1f4d17d21d31b777fc8b1f9d3fbb04a05187032172b17f6616a37417edead3c90956d8f09be29476eecd138ec6dbe8d4685943f2c17e0b5763df67aab8c08754b89a3c36ec52b2cf9b6912cad125df9d29d01f6a21910922219958c9aee0d0f74b594ff328adc6553854a10167b23d90511ba74ca7e0261ff5aadd5d36c1ba12fbdb0bb9f99b211575cd69f00cc1a36c89b914033dd50ee6a10f7c586ce58aa22e05eae75379e44d9a1058391ed1f469a592ca806025f326e3a5bc3a3349c7c80cd9018eba08e231e40295020470e8900f8b91348e8b872c1f42565ea499732f0d87fb45af55c820d66c8c7ac6b505e4b90a0c085e52846cca542769a038a6fc8b48577a1fc41a83f7c36e4f17b942b8c0962c3d20dad7e6b06c69efcac763e0dbae06d2fe62d2ce923b580719567b338d755a53abfa456aac183987e27513d5d70bb874276f396380fea1de9d32e77c657b8d2056389500d8944d9e0ccd09b76d7a0be5a6ca5229824de521fea2265ae91fb9c710d93a529a7d40bb894e130252f9b8d08d04f13296f765a165c1d7622f998ea8472a7a88f3cf1315594fd50e06aade469e4b1b9c35c5f5737d95f29b71cc78aa8d5e3f1fda7f70cfd54787cb9ffce158db82f92e24a45a18b58d1bbb767a413b1dc7918529575e210a7b51c4da7d111ae634d5337a793e615d0691977cfbb5cdc7938081205301043fe5aa4ed70ffd7ccf35832c73792c6951ca6020936348e005e2035dfb4bcaad38f796b5910b489669038d3cb7738b32ec972d05a02aef73d819a800ebcd7237bfb2cf54464bab1a227f5cd42f4e3b1083354eecc022ecdd8a58ac8546ce324c6620aeee2351931bae37bc2a22c238b737d3521e84ed18728bbfe24e323463749d064aad3ac6f5576a7346f6eeae425c2d0c279c034ab62603e505485ff000f25d27b11ba39e9438116f8127feee7ac3ce45acacfb5cb2272933113fcb64d4cc0cda37ae11721a6d0dd0d741e29ddb7779d9914ee4fb467af68e99a12dc22901f20105a740ab2f75e2750e4c28f95179811630da5db21b1f60f9ae1b0ce7a61c56fd0410f4c112b0bf25b3e6126d6d0e3a2882c689f2677b103da7c211434166e4fd376b08f7f8c89a58f9a623bec43e0a241354ee554c8fc457c3579fdca10ac089dae212b1729cd2e9fc988b5c0a178fc9d98b389c4693d247d306a61010d8651a74bb0971f9fcd3b06ac8f0f77cc4b48cec6b783d57f612a3c0a2b387b4523dbf25e5c7f599d12dd89d023d4f5989ab769e7d57a86947fcf74cde6af918fe030dd756727d12c2e50b2c68b54952dbbc17c3726b2f2ce7543443e95d09c32a3173cbeff2891d4762fab9f22d169a8a9a9d840e60a249bc94c42c61546179ec672376a0ae4725f852eeedc90c4a51bfd0c978a93b8b4ef918997f4f262f1a6a63012d95474a8649a586a7f41866dcd714920c42cecb68ebb13fa56a22b1dbe09d81ec588d56904c1d61e94fe04bdbb637bd293a8baf905ec4c3e934e371557960685a78b130c09a70cbbab2b809e50aa79fc69227383bab003cf8e4f12b01b3151df64ab16578e8e844c6c5f3fc0e6a7995897a9b6b44ade2a5c19d989403dba61205892f9d0a2abbe50899d8ea44c5e71f439afa11dd88989e9b76adcd791008f66819e2d68a07e8c8d534adeb4dbe53e48e7620c886274147adc53f7dc02ff1ec972d12bd2791962ee24404578083fdcc2d158c8b383555e4672b64ec38ec62c801d9416066418fc3850111fce49fa3e53a5a135f63adb9078f72b72b45feb747bca0688bf5fb71defbe022f67dff39e09304b5b4146c425b8e937d0553ed9b43e2a0845ce1a88042f451323e305670268444757022c01a27158d92d6df1627aa5b280e904ec40d7db2d3bce1ef6e226845d055755d5dca5c04f740cb57992cdcbe0f6585de59cbb51b0da24a8ac845d2891b9f94f6e49ab28fbb79c042c54dd96d4ec0e7ada5f339a62ac444dee7a677869fdb32a70994798c08a78ff2b6e48a0ba5768e2c048c4c1f1715c47357e62dea24d671bc4fe2d6ec3ece468abb286677f4366101499420482515a2226eb6cca0d1e850889738fc6bc653e00a62d90e72649bd617c79463c4ae342fdad5c0f34b6edb3260f642a93579d6fdce387eacb454bf095ec78e9479b0f944c3fe889b5c418cf5f5cff189696e825978301084f715e18a6e65e8e5e9ba7dae012ae176603da686d845716523bc521d85f3d0ec0c5c36f164cbc80213cefca6c7c82146f4ba39b9bddfd2160784dfad0278e377ca392cef3cf05a78520002990700eced0860986c94ec32cfc8b2fa07c75d764f39eb7578e8613321d8f0015a208e797e3cef6f50b06c7c9b53e01259d7af738db658dc6366b9712981fc9508256487f5cfa637f329293876a9cd00dd9ed4a45e7b15f9abd5a68b7e96a8e48c67863e26357777b057e34d39db2e26c3458f0b7941b20ed6fbe2c32c7c906f80e4cbb6fec7fa680b802c2d4a3da763ad6ed0cff39ed8192b9c019d9677622f6460aa5b680b28ae01ffc32a9072eeb74422311966d2c41d34ba809e7023f969ba4481860b685927e490492434cffdcb43be791bf744a0fae4c03e2d6461e035431b1becb2a0213c53fb7345ca724f75ca1d53ae7241867d88f003ba5402a285e71215f193b424c60ec50d56cf1fe5e24b267fe52a6953485d8f3bde3c03b77108ef5a82e4b7dea97ddc4ca627d2bf6b81a74534a2cb1a52d2ca9cc204901b3df487e68786df5008db428af20781504b2a40227ce3ec397ea246dd1548a35d00019ea053a2dd837e8359cbf6d948650ae8c5608bee087a90cb7055631d50cf9b02ae1f5777afda9d0162e2d7e501c52ba33a4faddb65b986e3b76fe03a80cb96dbf731e24bdaf434ce6475810fd9d3ead91ad78ab30f04fe8f2497c79af77525b5f3d4ca71b4f3d5d45341b2b119dfec4699b973286ee957f9279b7d209fbb481dc7367b2fbd7f98d916c2988be602231ec3e42b1d142efd9c00fc26d9dcfa8c17f895e41286352179751b4cc378894ed9f34589defa1591e8986fb9fdd680c1523a7cdb8dee9bcee8967ad7a78665000e7c0403c934a0af542d141fdf2d487764496a37071612597bbf7445fd3a7773954e671982a95f0faf0434ed925c31cfd589dd6eac8d7ad793875281563298e5e92d78f32a71a9b7746211d2c3b08cecf3ad3688639d3f6ab2c387e4779971044b1dc8d1566c3f7456de475f7e904ed718c5358425e2446e0265d94de02698cacb346b2f14a21b698b85e628ba90a40708ec641ebe0fbf4a9bbdee2c4da37e6a09da6c9f5f22f00edd8557ce9c9e4c2d949c209d4801ddfa6a3b8058c9dc01993dbe27bd844087c1cbd90472e745043693efea444131d1b508cba12c0b628a1966aff4ca617c45682f5e969e1b6445ff36a1c71398c0681fa3795c89deb89c005586fb0a4c2cddc3d51c4160fb4affcb6ad9a739d31d700c4df12f586368211a6b1b32d3b7a1f4574cae08ad6b3569cae9c94bdc5dc634c17752bfa73960a8a4ca219a450131f962472017e2234cc2ffbb505da03d59fa701ee19386aaaf60ca509fc03cdf5c12b6bed5bee2033e3391c51e508825db9c4a8e890cf9ea3c9f3dc2f3e514564c9b5b39683cf14e3968b6a247748d25b0391a1d032438b456aa301ddf9258993d2e7f51e87ab1d8b99581c0cb70392ce2bf30906d51fc976729edb7e5e4b2c2e29190e90d1cb6967c8151504ded8de64449b59b77e3b99c57dd8e9dbc72cc109df99526d9eea8860fc16a46fe1f02a33160b5392a0890b9f8c4ec90069266b0c7a08182bdf5f3b991f691a6a1726e9cc7ad3fb0819bec5a964bb5f69e936c59bd836f09567d4b39c156313d017f87d191384a0c120dd1d1659c214b7f1996d275919c2e13b71b26aad689fd136346224e9b89e55df744d54ca4fb1024ffd1f06bae0c91f022c459988e478d5d24e77df767451f3807e21c7a8f761c7c72af96289265c9522d3dad44e0583a6924cd258a95cb8663a89c7c67f5892f57faa9dc870cd0f88f4fb78de4c53c8f189447bf6dc72b8d2dd424e6d2f3526254c0683c41b68d37eae055998c758e7e7b847e802e7a862dda7a646fe34637b17e926eb334bc9676e19c4c66ab6e585969ac79f38c69f3b779770dcef9291ca3076be9b52b7e757ba17fabd79933c48155403e9491bda088180bc174ee1649c28fe4cda511ffffbf576d0f7b6f827bf6274b44d8ff2793c25d2aa960c20a84e2e69ef433f95411b1444e7e1903f3b081fb6d0721831a67f84d0f29e6252db73ea11bd53fc433ce578330563d775e9026e01ccf2353b6b6f5dd0276ac4b2108187e9c32f8337bd87640f193ae80fbcc86f003b022aac28e2dad41dd081f2ee22fe5c0b07f6a21952bf856b39226116a70ecdd7bce563c9b63d9e74dbe58c3de2ea56e20cfa652bf8cf4d693bed839308bbb66c83bb14fe930e61807130a39d9dffc99adeafba3756fbf4ec43d43b0977d4f1cd90b628ce82470977acb6852e88f68a76f2a43b5776c9e2cf2e7a0c28b2e61cd73c01af82b176a65d9cfb843e7598feba4468113517f5c8fb0b3722e9184bc5ce5701524505b84174bfdc9c261be6a5b93c259a851fe980bcfcdeb87274670260674ed35605ea4da73d3fad2cd02674d46195fc9ebb361aaf3aebecca7d79ecac18b39f64a9a711fc41d54102a7c03988706c2e47408bd215196ef7196438d6481dfa616054420a8aef233b836fed533a5024a32b04a1455119d46da2a071a20c6e0d4e6f27024fedbd275bf28c5d34f864657844aec9639296554325ea7f2703f2f30c7bfce703d4be2612dfaa092d55a3644e22e0f1b771dcab7ea842d8994b03b095e3ac90c7978182b9bbe865822ccb1ea1cdbfb912d31ff022e25356723a93c808a91fefe0982ec242be24230fd352ad5297dce227378e5593c28868a7ac2f6c2a7df7cc3219340610d25db49d8067fac577794221bdb0ba7987a80aa9b87855ec6075122a9faf7a00ca73e33ce84f870c8946a0b9d3a586fed44feb3970f8cf1b2bd267df6bbfe0cfa756cf371801d93d14de9f19d4144fa4633544a9573d898e680603c28a17345ece29e040bdd84fba4e50c22b52c52891ab1a1a242c1935f9613bb7abc8ced6072a9401bb94f2706f51824424a4c0e559582e08081e5cf8a635a81cb813454a0742e5459ada10584bf73d1aa932b3dfaadde18131d9ffc81ff4df99486954e9745a6cfffc82c01ee156918f0052149ffb5e5c817e28fc449a303b3b19f7e1d92bf5f9f9f2cedfcb6c72b9fd6727fae5a096762397d815c6f1c7c16a528bab1b2281f865607a3f37c5f1d7c05319417577ac77867f0d85710a8282fd00366c13c045ba515f83675bf74d84ceca207a874c9479c5c4ea2c58efec66389c9fa88e7e2b970ec3355ee71b013f3940af66ffb3f552a84a903ae79bb019ddab9d270f4c7945b2efef4ffad35539d5695016d266ed77fc3ffe47329de148b49edf4500fea7b1ab0675e1949e74a4e33d5d2c1a35d6af511df45ab269062c55fc22ebbae01aaa4977e92bd73ea979de7aadb52c82c57f7eabacab666e498c849052eec82f5328dcb272409b28d46e06c77db6467b759373bbedbd1c6eaec4f11bb7ed3c64a4d0980b59ac54ae71c77afe8b3123f01335afbb5ac328fa9448f9ce1fa64088ace8be721ae339f8eb247ff9fc1b6b822e36956fe4aaef58913991cf1b69b2ca7d29bc09e5bbbb29431b3c90672af954dd20b99d060f99d0a68fe5bae56c9db07ecaa94695de1f3a122b4e373ef2a6160021dddc89e728da04af0f63da8586706c37689eb2be9a4320724d4f138b415fcd84463f25bfb4d2a399716df5c246167c8c7a95482a2eb202d2b9c6dcfaf039d62e8463b151131e5fd7f49cd98b0ca9c2c77711162890015fadecf9ef5be5928c621423372f2b6eeb4c95f13f9737c1fc2cbdae6d49939b469a8258f58c29af9254a61d939654fbecab0ddbc18a80eb3fa6791832df35cd606fc94ea3918e97967467f9169c9bb8beb947754144005121c49007b764cff49996c635aa685a668ddbb4d3142c0f52599efe7637febff79eca976c1cd572e86dab68c0589798c3c5862f086232c62ce90088a5a1924a92c2ad274e01f617b4fe740f213140b34e968e039f3f448b8ec2026eabd72d37d2b1edd1f4f5ab0bafa63b3dbf3c86b3f1e10433edd51b31011dd3f7a8af3af4ac5dd63ba4658ca13175a0d285adb69ee8ff27449b5d2044abc28081495372b6734b74d1b07f68c54d25ea06578d544f6b505189d88c094416b95591eab2438114a8c679b07d1f90551f4f8c487225c8144f9ea8d379570ffcd19cc50b4c5b05e4cbaf1f2e453bf675d1076225ae6907bae545b4f45dbccca9c4d62755585cd63e1b87cea66e80df4e021ce0452fd33718b442f8ce66c9c5234b2f624ceb508a8909cf9e3014cbb4e02520c29b7731da8f89fc9303125b1f5dab7ef1aaef434b786271c0837535d05e9bec051e9f5ff578e6d6ad544758548945fe52566c2905fb179d04cc4094bef1bcdd37348a492dc5be2a34de5e6e4e1b8ff46357ae4a6bb8ad05ccc55840557b418c85fbdc41dc5d71c7591a712ecaa3276d72ae9f8c745f2c0be80233ed7130da8815d84439583ec873e08de9a8f83ba77b58fba0af9c3df7e5df3637df1992fe2e7f33ef899ccca33e9a56050967df1fb227c85297ce53634bd6b307a01ae8b2ec3eef9766a46d4d2b0c527686363c7d674ca3f55b78ce3279df38e465559419c7ef0889071fd7f1914de589e09716debcc6dbfd4aebe4cb678e8f69e17dfca8d0855fd13d5b28569eddd7c08da03e7c462b1d6cff8a417adea39a6a095e4f3ed94a1021357e924d2c83a5641324be32dd54f715c547d650433ac1e6e1ef20ae64bbe6c769c9d53658df82c221b73b688b5b1a62e9bc48faf79aaa33825cab4d4d33cd76c40159aa326d53068b30ba922a976ba570b69ae4616cfac50048f6a182a3ca274eddb180feb6700c5081141fd31524df2c985f7df01960a63e3d05fe6384aceeb9aed984c148bdc11cc1570a858b217702948b83c474de8e636a669c10c18ecea94c738bdc44a15aa00e700baf36909975bcb78757ec01ef1261387e6c118669a22419ae426366f6716e98003ceecc2bd016c03f03bb327ab0a42eed09eed7c9aea7d0b4149c52dda75957e2b659b9ddd0da4b69bf93fe3d0d6c78ed21ef49ab753f4e4d1cefafbb84daa8b47aeacf9d9e97594166a1dbe1028fcb1538cac871f861a61071b85cffeb0dffc59b1ce4dcef7b673869849c1352520d38da0ef4c67cdb96feaa8b8b0b70f5b3200d398ab0ca770f71b83d046205d640e855d41e0c03687612b9de9cddc8f1ae362e53ca17be89f334aaf498d306af9071abc1564ecf486cfcf41bda44720176b2e9fc2c02acf74a77d3d56f5b92c237fb592328b0b83c079fbe533a730244784fec22a3c4188955d9724191dbb8cecd21f22de62cf1d3128f05857230cbb19b10b40995271fb5a1fbc4280b64cad24f2703ab6054417d40be2b98f72f9b125dc34ca28aac88f9f57c8310103b98af1f6a3cced60582efe7c609ae75d498c887a6206a1244636ffe3b2fef828adf5a8ff66faaf841734f017bd818ad4417255099c8b7ddc4004ae2b491006218332a6fbc6e61eafb1e2e68339d178956afff25ef6bd278438010c23535f33e27a40464f71292e5fcde1af83c9fd91b4ad23bf1a6675a69c882e5b28da20f9f5aa2a85e9dbbbbacbc6f52a560819d2e0f3942bfc87d70b9373790ab5776c59d8c21018d25fbfff30de62c522466dbb96253d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
