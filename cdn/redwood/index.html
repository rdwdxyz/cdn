<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a65a8b2671d5750363b4ab8c6c220f39ce0a89fed10b6930123bf42320b66066564eca33d0ec38cfbad158a765ff81dda795c3051380eab705859dd1aa3e90f9388bbad8735febc5b5dd045c9e517eadaeb97df31c3e70d015065c3913c3309e2eb955e44a11417742b20d009696a17156cdbf8ae116277fcac22f45b602636f98c49e9316da3577b81c48d13788fe66d0e16b75e948a7edc189e377cd5191a7274aa120d2a701663a724a357975528355c6022c754e4dc80d7c7ab84a3c1d9b383e12289e3f8978e7ced61e5bb77678dec839fd9a6130d62c16ef03b4454506425e3847a0ac4ec836774cf4cf54c20e5f02b80c25ffedbf472777d95b4194d3e138ec801783642b427e8cb272ca748c23662b6534a21619873a2054e1043bad596d7aa315a56c400a3c171422dc8301730e418f5015d17bc0dfd4f1b4bacc4cdd21d4cf45815631e8ece989c1713aec906082022b1d7765c71a6c3e22f245d9bdd2b18043035f672c0fde0894fb5235f90b9b35334009976026fd516a00c54d71e0b22c5362fcf2c90596cdfeee158c966da77ece4efae4472268074f510fb9385fe1c44bdb409090e666ee880bdb6b1587545808cb687c5302ea5dc19c591b63ecb488bdf345036cf10103298c5e68d2a1e97bb8b7cf7323b832c3af45237c5c7c3d4cb20350b50ba1b9f2732b9e1d9de3c506a9522e9f652d8b822ae8b2b9b89d288c9ab207627ee87b7a393da0e4efd7df5844b4d2e9ceca36d05fe91147515c239139e6a4a14ec6a95ce3edaab0b53dfa4afd5b4dab4a45c949ac4d3a9f7a0b6fc48b6b9e091d30bb499619b5fccf736a6db2085d5efac8dc90087b8e3a10054c4856afebd5a6ea379a23fe6739d44018f49d3be43a4e6ad1539b9b38242fcb1fc01850b9ceaf4996bde22aadec0744e047c9b43aa9f9caddb771a2dd9bf51050b9a920066b7474825189063962c645a5d63deb2d8d12fc7350b042959dac51cf71aede2b5b6498266b85a850342e279b77b53dd16ae57d43add925cec57dd9d89fcfd3a398024fe16aed37ce6e224cea0174c9985d0dd49e7063627efce3d7d1434a03b57f45705eb89ac2225354e860b9531a01ba484bc2d5963090a6a166b9a6e93099eb943b180edde0d14a5e5a059c63acec6945919bcf1755d4319f435d1c710800ded1009ea249b60c88568189ffb6496800bbb78088a85a9cd6af7ab8ee23a4c7e3f19cd02385807e987003b08cd1c28e08201775413ca5c75f8eabe8a9dde2b96ebf68f6f0904b051ffa902e4b33f4876ff93d8de74ff6d0b5200a90c60432d60cfb975408a1bfee0b25d6b28963049253d28fdfae8be8de32f0a9044f754b3836689a0287d852e5055c5333ec967a8c52c72cf1b5e32aa3c60a6735bd9f4c01315e5940480edd89f68e6f6fa395269b5a8ec82a5e6b0ac0ab155069fd742e562bc7bdddf3adf115676b2d2e1673fd95e6132ddf8e74091957aac1883dc567d8549d685c0f3aee0d5066e734339c568375e2866d87b41c2b8f4966cebb00347111dc4647e32f745a1e9551765bd417abb9bcb135318774477c1f8f535c915463e5c0b17f2341a53408ca49c26676d4155cad59869c080d684f6b871fd51165d119dfb8d29dea12982b7e7aa11cbe939fe8846e04355b065c12c4691cddb30056275096beed1ade5e183ce2acea8d6ec747bbf408fbf53bbf35777290deb224b6b85b3474eff0dfd37e0354907cd18c31fa29d14351ff53aa5f85fc7104a2527742e8effc7f14cee70bdb62aa254f8463f4c835e3fdb331eae18abfde633eb78487174d94e8045639477fdc580c5e29d12d9e850131aac70dc0bce9e85a9e9fcc0c3bfad9291a9dd63674cdce948f9fa07db3fde61778f6e5d5d7f3f004ba89b9955add763361a2abdc70f90dbff63c4a82a08ef417ec9050bc075f0de40f5cebd6dd9177b8cec724b5355f690b886c371b75557eb9946dce854e9901a9ac872d775516fffaf19c8a45834e95978fe9db2a4c9a1b03f88ec6450224cdba9c1e2003192f43384e294cbbcfcf495fe01d9f0d31281ef3eee619cbdae0e592fcb7a79b84054c99cd39b12e2917965150fabc15d705b4228ee0cf39e2b3d6b46dea1ad374dda7d43c5e1c927671b31fbdda16941232389f1b6393a97ba45d0c35d823ee41c4fe0aba4a45a2b2d8276615f0cb1a22c4cd7434e9588536b9ca41c91c049aab985f510e0b0a37ebef7b80737f75b3e1138e42392a36eefd46684687634c36017cb68b02fdf9e352a2ebe17e73e793447b0a94d4661ee4a91792802b65656a7dbd943e84a3ef8b97654b2ecf570d9f741a6c433d766a01090d99add9fe7eeb7ddd7490feac6eb4d26e1c987cdfe94f4e0ae8452d1b34ee5794f5500c19b2984c7c22d4a8006a99e68bdfa335097f727f9559e8f2c5a2a14722436b5807eca8fe7b9beb3c6c75c97fb0a50b75412ad07da97b09e450c1a250a7b5018da094057adc54b1cddd80206f88007fc3d33a573517be30b9010d5a2605229c3916381eab128a16be9474770e2aa3083f0b830e7f98f26c8529a0ffe242a19b991adf1958a493aaab922c4692da9cabef1dc244061c9711dc3d17b132acce5ea688dbec659d8d43e654893011d89a96c1be620cac25ce048085ebe4d49190ef9613791b9ebd5f8acd1d08316c3c5eb7a540427bc2534351cbba06e77970fee24258aceb8bb0af03d2e4918f51b3539fa1c1d4464de58d83a5963a75687d656751505793ed1fcac2e0146ab88951af10a011f65533bf976cd99586222ba2310dd4d1d7052b00aa2740e2ecd5a39c59cacc25b59b2d80b519eaf9813aa6654d9ffe155069b950f6f30c853a38a2bbee01d97fd6c5af791f88c11b5946ae72bdb2ac16b15457cfd90c320c5881b42964cbb18cbc540fc305a0f5545c2fa9835d77a06e9fd37e521810ab7ca195c0939603e001b4210b88c2bffa72a4c65344af2b610b2871c04a5a818bc9bfacb2089c12972f80fdf19547cbdfe695d3af124c91a368fdd80067dbd02049aedbadb23fb0557b68fd924741d827dd66d57a99fd41741b96849d5dac22399d48144b5064cedcfd21ee54797cdd5e58fc5f605860b3b07758a5e037148092d70ffafba8632a27fdce22f7b868eca5cd7f5c26f438714f86faa68cee99a61d8f2e22f4eedf6ba7fef1bd15e07d19b9b0234a0dd9bd19f06709e08f9a9cf4748268fdc186a6deab50bbd647cf481a848ac31ea6f120ea4221d0ec3e22822aaca00ef9500259d64815246aa677e6bf4cc5fbe710a0698ad0f48b271f57977043c75dfe130e8701667e0d0272c8fe587986f7cf670f669a9b1a75b4504b58640c2ff80a2dbf1649f28525be62344393be31f0d2cc486647c8d68859002caf694b10e8f84752a5ec099f56fc9916f229982802b2305b58b4b02f4f4cabf7639d62e9b7e79e962a00e60f6371678ffc7d59db29969e490c3ae977bbf822e3e3ec0c924d8915add10d618e991eb5d294e9534ca408c15070d9a87a92c9e2f9f93b91a614ecb1aeaae7b5fcffe72b65b8611b3ff9f89149fccc202634f9aa195b9b6839c17a0d8cf54579242c17b723f847590ee1001ff42d89216fd67663d04dc5d32e3f046342d61d45d54404d0186f0468fc3a81b64f33dcf5a1a36739ee444bad703a8e5138c6993193627196ee8198bb14e9dd6157233f2d6924cd14eaaa21b9dfece70ba050e5ad0480e4521df67291631fc7a46dde7b5bd849f70d0c05c5454df4120f65f77dcfac54d73b27a06026deae576d80804a96a042992c9e116c249954da5d1167083847174fb2a0af0ecb3e6cf4d59a574a3eabeac55727972b0de36af169797c975c7974ed36951303820b59220f268bfce11d22c9ad0b087f433f9cbd3598109332f99b41b8b08fd7035dd24fda11b2781351e2186eaccbcf7941e735ec2e073cc5304240c4e80cb0de43dfd977aa8f559d5008d70e738acdf06250ae10dda17028f41a2803459fa875dc46a44e4a32540fc1bb1a736b7354a41700136ec79daebc750e6618ec3452b4b0b8a8c1c26c35e110d79241fa2dfd6d47835e5a1981cea3c86b803bff1298b6b9a6e9963d3ca16f7e85a909d7879d1bbb3d53698481334ad681e5860bdeaffba70f027af3859c9fcbebe827efc9b399639a1b4150eb7476ac0cb633869e39396a1ef4a201dae6fb1ca5f3225f7549c4dd9cb9ac5a88119b984fa656ddf6ddc6c173bf177b68a4c709873a5c4dcb6cf5a0e67dca20b236d153e71d900425cfcc0397a1698266d38e63e4767574b3f60329828ab9954ac57fe0684a7754f1f6e284e7098105c0e3064805399d852b81e7e414f2b34e29c06cc65ed7996dbbe11bd38204a8b24a7b24473ee684bae623ac1ebd370619089d4c60199df1af706027b5eb82cd364caf0e11491fb0c9d5813dd6a8819fcdd62170f580510c46401a369fac7ce5bffca5ab9f1a90c106ed479d2708971a20c9f3f3b81f427d3601570f87e370e83e27a5e19c9fbedbe6e881920a8f45234e97e589b127e14e457662aee1a4d2a293ee44d84f31c0f183377ee8bff45f8f9b065b41e4a2aa31dd054b12986b3813e2d05b35e3ffdc699a3b8227f6489a2c63f1ee4bc425f1c1ccf4c94d129854bdad26cc9e5b8e94cfe0a79cf9b499c6f323e2e83867b913696ece60fa7bf4289a08e5e96571858094bf0ad913eebac8dc8278a19655d987e8279d80b8bc2e87bf1d142f3e4d9ccf5fe9d0f8356226f33bb9f5b35006ab355faf7716d0492fdf8b40406f5eef69b5b7fe14cdf4411f9712f365d15c5b5c2f8fe7a7b8c2c62d1cd52195341fe0d5b77979e8a4522990c1a8f896595da6275fcf173d9719002a1554e6b7eecd6ddfcde4cf3c24bc85f77ee46038250302925775368d80a9a28c3c80da4eb01d384e8854339501d6dbc30f230f3d523f6b29b3f03d24413e7dad922e2286f18bfef1ea2f23b3da9aa2c153957e8f33915c8bb677f1c0f0826d698c9bb262a5cfde5e228ed7eed7542a888f4a08c501080c4493ac2cff19f2b04d187bca246f30c58f5d4117e0614b479d8005947274ba19d52a200438fa39c848e1f55c3548b3907a7facad3db1c1d51b71e96debed9a3e47679bc1d812a9d5df46c248e6e6d5221f8d9af757f08f5e0ee4fbefa0f20e095986376e2c9b2feb8280a7e4dc0b011f8b12fa60c13f1e9b5e678a6203623fa0685dd43a2e6312a9e47e912bcc332d886ece6e627bcbfac9cb423e5e69d61f6561d621b6ea3c49c2cc4662bedd9d58217fb11656db0f6fb9eba1dee779f3c02d3dafe8a7c37317f283f107b01d51e74a7e14773cbb02a01cfa60a3cdf70172ccea4c1090ade7ed877865443dc81d2f3bc605f4aea43495844c7332cb5d82df35f290e285dac87588fc528b9c893cd70031655daf228df87aa70684fcec0b84f6ead764a8cfef929a6c2fc31e0c6725ed908e457f6251d6a69e8155312a9d8a150583d16daaa02494a2592945dded3c800ecf5ec4c7c08a68dc795ff426e433cdcb8a04fc42347811050cc98d78ceaf056c75e4b327f3fba4c64f1e10a086f7f6dbe52c1efdf40bdbbbfe6844c3d7bca1de90c2af5d23301660a1f52d53bc40c8ec5fe6eb0c49f18923c5231b760f4e8e68e213c41eb5f6dbe66670e20fe51bf3d41a092ad1def9f94ad5edd97129fa1ae14f7f43c327405b8ddb0b24605a2b0ca725130153fdd2692c18c475764c800feeeba58eff0e59f703b0aab4cc758f08b3b2cc9b67d946ed58daacf49c08b10c9d6c8700b45cdfd64c91f6a31b7a0338ec04d5983689a50f608a65c02ad7848c65f307a59c15c7bf21fd00c74bfddcbb082835fd7a238f1a17229a1b0a499207fb4f32a9ed9d0ff751346eb492d60e0f5c2af5fa629af85aa7861611e32111a1c4cdcec971e1f90934823dfbf8e96421606d28e45dc5e6367965b4e8b6f39a13ec55174ae40448c29478a542ca52ea5fefbb0af07aff8329255f332d42d5444c452013b024cae6c2827fd90b7efc1ee13b31eeb19f1c70dba6f72b4aefe5909a4a36d87b3620c76a731354e7be2b74803f626de3b347b160d52b27a08de57182764df0868acc379c98bcf3f3ecaf2ae22affa39017e826d05f21c9d849c61d585f78fa39a7ebf0c822d7a972216116e32d6ec277b5eb6c7f350e4f9217fe4d62312c6a0d3ab9710cb913f5f32c9f3df03ce48cbd6f80892c1b6e887d9398bdddfa23bec65d3dfaf49fedf72d9f292af9d919c4571f33e0e533a34ed320286e3c3de40c167066a67d43ae64a795ed74f4e3b6c370043c5190fb4c1b4d12c981d6abed7bf3bad8b6d5e6d8ad5a26a8d75e006bd4d73596ed914a91b41b4d3e7bd6c596dcc44fe020de24569b18a870e8aef2269d92259abe72495bb85db3758c5b5fe688c5c95c387bfb2bd261fef913fb3d560ba97f24b27c3d5b41c1797a1dbee6cf11f6fa9a3886e8d51269b4ed9d62b38451edf3f0a3c9d974fef80a5901c5de88a77368cc78075937c780e0d30773ad3cd22095d5dda7c57ab1a6937892cff2f2c7d5e25210102ab777777429873c07e20d4905e7f2df9944fa5a8c7a43bf4b833d6ad48a7cabb819e5aab68da4e7226690fad253786549100ad7874e0aba422f09264d6346ecc43d87fbd7714659e0dde6a78a988fb880565ef729162d412009eee3ef370b178990989b72348b6ca547fa23c322ed8c646a3e4cc955ce3df158c2fe905898fbbf9468c2e63b6c66a1f0b2ff43d0462b0b06541d467f603b4b10d7bbea46f90e0f8278c1f9c0f8b7f752ac4ad29f154e3af6d339da598c3fb0ab4d677754c8baa7f0f2fca61ab1566f6628d059a4d07460139cfdfde655fec943c1531c0a12ef679c617f31c85ac141aadb09099363320e71cbd9e6fe1a4b97175aa6cd2fa3124d99ef1cdcb6bfa81c1281027dd4ea02215499af7489cde70e3195a823c575005924cd9895227793303d811bf0eec20a5eb7e172e1a8e39f168b691ea564eab5961340503c5167d30ef44b068ae2254d83307d413fea2c7a4de2d5e88d40e13faf963a4dc72cdc1832a90e1ce7849b9ec012e3ddc9cb456a5c083a217ae210bde0f426e218a34e87fbe3688577392cc14af553a0252d0d585b748c8dc1db6ce8019510704d100c1d6d65b4a93cbcbcb6d16e47cc84d3274a854bc5b13cc67e9274ff9455ee42563a7668743c21b601b4a9bcb0f4428e725cc3bd186541ebbc9879c8e0cdceeb3dc499b9211a831126b145b48870a0efb7ddbf965d0a9a54dcbaf016f69f9de89e1dc45ccb2ae9ae8ca8a88009d40044da700d80f333caf371fd7a6523f0c6a769cb0f7842bc87a4804af92104c558f9631691950aca3d8a57bc4610ff61b3c3edafab9268e5d83e173f52ec933b77c4fc6d618e0c90e5459a158e2422155ce9def00b5f0eb890898ee3b267c9898fdc73e0da593c3df25d210de934ab54dcf29be5dbbe0e2bef8d236d3dec264d6ece1d44f3e038ed3ff87d1409e3c65738c9f596e40d37682915355f06b568476853958f3d04b24c7e9ec4fdf4558d676c5bf467232fd38bf0bea301096bb91bc5bdc3442f0f84c3c498c41e3a786d42cda77e8b1a2a1a490e80bac059f8c1a4edabf296aa8ab76391267eab9e463a644ff2204994312b53e9d2e2660204ff0070d442f79231de886074954ffe19087993c023197c0742547f17616ad7824eac47bba941f12226d1c6c5bd8cf76089f386d1f86751860894ef19664b2a29f785a4d2f9136bdd711f3e21975f26d7fa00e0abd9af636003bca76a00cb4554fc0e40513b70be65d913f05a1a17a5949808d5bb3d4d60e283b4f9378a6b541e08b75235b4315bec38e139b1c197c7305655755b9beee62137f7277e84cdddd1300e5541ab8495d4796ddc8f82794c4e0c66db039bfca0bf3e46a1ec5a24706e8b2e376cd6d436e92faa040ba765cfcb6f21d2a08e265de48f2bcb1f5d122e4905676b0e270f2e0761140daad7bb53fdec0e8161b1e70d85a5b5b92b96e7ee091a4ad2278f92bcc0a3abeca394e5efec3f8e74bfab131d42cadb5c8f31ae415337cf6695d06577257b109bfad47379c44b3dce701a0a129cbb819964529ff70343db13feaab5c5c339081d1d50e837926085d1e9df54edb36bd0546026dc3974f91b070295666e76c5b85ed2d6214c7b31492c8566fadf22deea7fd368ba26c5c30c36b5f03dc28f92e991a4448c1dff96911fae3042816fbc5117354d19e01c1dbff59a9a740a3cff2818b426b0cde50e4fc3a969f7cfa6ec6ac60050d45b9ae11b4e5ed73a44ecebde19e39be90315b951c0868b60aec61d09112705330a4bacd0ecba801b6c7967bb878c14c5db3f5dca51299e3038ea4f782deee967d3318b04a8ff1eded0b3649cf8a08153d2c1e2972804ddc670d524fd05d187bf12e12e1eacb38fe482f7540b3568d2cad48216d268a0aad22f336b11feeeaa8c92792e4c926ab64c4e16c8d4655cd697f4feddf94b59e02e84ab821000d07a05e53d79566a5637fc88a9b6cbe7a4b5163d19aba1bab3d1cf057ef99f11206dcee987abb90c0e967c6c757508da372ee56649fe59c63a4a3bf46368cc52b672eac7d96d78175733bdad90d187a5e4b8baf7d82e6d6456e6307b5dda71378aee11285a47791b04d9e571992a3c6597fb525819767d0548265c4e65d1c25e4afb24a0df9fa87771c872b9aa7166cf0b42020d09431e03c87f3734958af62e95f8fa99e09834e0c0a493aa636dc6c08fd799e38dc3662ba047f1ae45480d07afd08773917006e173944f3aeb33343111a17c39b675e0b25247bd153c42191c0b10ffb9ccff6276ab3ae8e73609222e5fabaefaaa53ce75e56ce4bb2ddf58d663574167cb2c8c5cfb3c4643bac932f9ac4dff8d22c80e02612055d35fa532855f50fc367f16aa9d181f97cda2c498452f2bbb38e8677b6368ed5efe39e92d530dbd79e3b1cef4000fa33e9a13744483a2e568d1f9a9e1d22bc4651515850490a5c9b4aaa69f7a893de04a798eca48072a62f8b34dd1e2cb4330b8c2ae8d379c1af8e38166a50a0a02b1515f2b77752b1ca3eb0e182e6ce0fbabfae16560ca277afa14cc5a78456152ad7cab52cb4b546abef4427a1a4cc64c818a57800cc03316f9d57735315294156d861b48f560531a6e2f751c78032bcee87c1e90d1e356fa809fd61755af5472cec9fed532e05cfc2c38eaf731c84f00ea71126b2b41a64869bc8ffc404fa1727e96fb6ccd607dd56076f3338450659129c8a4986ab39d86fcf6d0d42004a4502b4895df7b0aedff878bdd37a888fdef33c435d9907e35e324de352e487c9203c64870a227625d607c9402089b6458184f07a0f2452aa31eabf88f996617e239e19de20e612c75fd5f30b650327a4a6d941c1bf5d04699de8beeabd4fe183bee61a698a58c26c73e3bc4e0bd1874cb7a3db37521cc623e797f00f5cedbf1c7ab77d16de79fcf150f2f1237422678ffd93da0c2644cb7ab2e085f3a7c327885b33672b22388eba28600a1c0e546afb94d28ba630d9da5056d03aa30ce64b1985dc01168109de186333c11e8f66ad23488dbe335cd771d04ac3e7e9883b104ba67d8080e67a663d190fc4e4e02bb2ba151c2803cde78a50e2b5532723f3ad68ae190b219ea75ae1ed977e0ccd7d519f86521d41c3e80e5f2804b7529ba23e6d984b1ce33eb48e6db3354c2493176c16607d09857fbe7cf4942745c626e0a61d099e4c29ff4e34a73a4cffb8a7097d646b559a05db2eea9633d1aed9b70e9f3284b700c99b974f4c5bb4e70a682252d0401bc2e622018fdabf6caa29e6839575e792faf1e23be428d70ce48c6d8e6fa54e08e7913ca6a9d1f17c93ad591ccd52c82e03328ecaa654949bdf17ceecfef3d2fc13b03ad1925cf3ee4930c86a614d61e8855ae66b6a115d751383ec96192ec40a3c955651654026d7810f401f3b5b94e4afe3aa58a51a6b85172e6985124fec68497e25e03a15c12e753715d61fa9796feb8102e5ceb9666265569bafaafa23fcde79511ea6e3a7085e8e2e065e29d11ccfcdcae4216c0b1f2eb03d3b8f625e760d197eeb90ef868749710fb2d67839615b847207e5e8a258654ef3fff2310e75de9b05f1515149b92ed3c880329bb27e2fc9e322a40af096ffae8a8d8ff55682cd8c629e5404b1bebc4ed3bbc19e7ec507c2b84e77e17724265f53b19291a15f1d2b04943a4027ea06a5b2a4ab03843837b22249102c94c473e074f4e2b7dc33074156020ba4f4275df72c73e9f5af7e8f37216b278e27e5c2f20a3ca8abf45cba24c6e7dd1fdb23db3f456c16f629aa8d46c9b06c6566c26be60c391a71ac6e19f99200d148ea1cc071749cc320648739109a99f5e5b60296fe18681b3b596757c21eb6e747fc05ec804a9202bc4dbeebba8a7c190538edd061f11889ebf0a7f751cd1ab2992db7a7160ce292a0c0e215426a6d1bc430a5b172ccb1d077f8f66a837111dcdc883721139ee17118e0ae052b957f65f5610362a903a98fff6045c417f915bfd737531d697655fcdb8a0711a43ab7a1a9601b61fbcd1341b1d09c0fab8b0d9f83b804713299f146ac95af9683815011b7b8c116574722847ab33f5c10291903ec1357fc0bfa33a7422b279edd6fea96700f3ca3fa89c15e5e95bec327ffc35b9b4950e891d70db896e41fed11712888870c898fb9ca46ee6b62621a737a8cc668d6f860eadf3aa16a57fda5a393190f79b001d329ca732c9744d4f6954008f558541df4685b17d612648cc17c9219fe18f977221f2437401f83aeec2b2cf2d91845f60ab49d56dc24bd79288876ff39465fc9452ec4febed05ffb8ba02948d3083ebb6e2101050f5bf2db42b232949971f1f23513ea4a51e159d2324946291a6eae755876f0bb2a6217085eef60cc701f3dfbbfa82efb0fd47358d718fbf7dfcede4f6cbf49b60f225795af27adb4cb52052b102cebcdfc6b6925a0589bd8754a937d141d077eccb2a3c56f7eca33d998917171275e912422523521cf268547d94bb9955ab2c4e7ebcff5d177d74fe7ec2c3bf1a2187cd3a6f020d5e61ac649bf2ba1d310f392098395eb1bc59fd41a0490d60d166e2e96ed309b7561b16b867d4347e6e7ebe7c85a69bcbcf29ba7993866cde5f8fbd573508bb6812a079d8b38f712f34387f7afe4395a5a5b65b02911ef47d14db9a721d7c02661df349969b58880f1efe0e13c31f3a0c1e4b9761f7954660bc1aa0191eba766979cbd6d5fe560c50335651eeee4f645136a03936f50867e3f75829363f40e104649f56b482c7ad7bc752b271bf6b29068ff45533a3a2eaa93a1ff16253a1ab9f868a6b4daaf57beb13643ed7ac9f9640f9ed6c28607ded0de2e38bd56e2d12ae9d33e61077397cf2b0eb36a340e03a95f9fc8f47e51f93e483039a60bc7e493302c0131015357165e285e876adc8ced80ca89f58941738a57674df0e54c460ee34da86949984d06894affdf53c41082e32f920418e169cb60f9a1162fbfef790c5305298f230599e536575387e6a1477cfa9fbdbfec2fbd5cbed46412d008683f39fb6d393698229826e3e1238b78f6261160145204e7cfcc72f950da5419a6f3b8e1ee9ebcbd7ea592ffac4d9223bf638866ceee5db60c588ade7f053f01ba5be0c95ed7d3c309d948c7fc41ebfbfb68226a9370c9f633af8b19bdaa3ae096eedfb38b4f5fc6e6ac587669263d23c8b79da1581727ad1745a23d1f80be58e62887f2e287de3b310a032d016639e27a233708dcbe929725014b1423f2d088a4b8b9a1ecf8227789b683a4aba3afccbe8a97f2536391179d9eea6907ca2e8cb86cb5b40e7cc72c941ab168a1d0719d7ebcef85459969225f134d83b8dec250d3bd6d76b227c38fbff3dc57be9b5fca535b8092044986e54011a8e27882c172c8d8e5a878a43f698e50c955623898101ea07bcef45b2d31d0e328dac8b1014c7320b80153394d264a517ebb2a04460a09e59caa3a6feb48152c39208b6c8a062c7ed17b3129a223c31fe3fd9c7e47cc116d540503818f29e8b209346fff1458091b8d8bb2ac5f0f46a51bb85ca371929b46983bbc05d802950a097fa59b2122af83a9b4bf5887df2c93c2f14461d9dadd6ebc30238a47cedea3c5f037569b2992d3ea366c4692a043650889189b6dabd6d44e374e9d1372ef746c20126d30db62b74c4694ce9782a5e16684a2dc248c9d64e21ee95c69facca79a94f848dfac321b63ccdd82db3f8335b090c2af142bd3925508118a72090d18d84d577dcdb59dc79ec034bc192ba460b33b8f761bdb428357430d568dfd9136727a69de2004c8ed4724352a2ba007749b7b2411ef3af6ad97f196346bd63bb53b5b950976896e3719fa63faa6a50eda5513a67282692ead944d0589a1c340a93786ee97ca20f253c99fef9f742bad4623e54fb0976344fe9f5ac0fb628664726ba4019168ac1a6078f8d5e0e2532004db22ebce543fa437300267596416c0561b5ce1a4aa6b468958abecb787fb6fbf60e2a50d016d512eceeef62a493fc5ff2a6610a1d6aa2a91794a4fde384d30b9ab6bc569bf3afcad095d7285e37c40d2206e47e217b6e3548a628139f7b7190770608b4fd1193a978880268717c5ecd775cdc30d76fbbe0c7813407449c8ace917487f4788fa75027094583d21d40a466217d584f540e240a88744b2274eaf5ca6167f563b5c03bfb20e51519e01770e4a9556b1478cb8a9c08f6361d46e246483a94939176578583e20a8cd6241a3fb3633bba00f1b8a640fc86a77694e24a237acd170b2f9eb0f87918bab8f41b1c0e333eb62677dd3de61eecbf0d79c43ec2be4a8a31b2440c041bf7c3a9726479342f10565036e795bf337f4c52bdc4da232fd5eb4cd299f900853cd35846aaedf36edb15d1bcda827b53a8d7ce67cd6f465412b0d02d9ed18c051ab34941de2ba18a3fd1dd13600526a62522cb1dc9d173bc0a2387b782dc1c26dccd206cdf43025fccb35ca35b0fc0cfb8986a463c161d3be13d80e9e915724760349ef8250295bd7d72ae263c87bd4c9f27e65260221e5871f4d6b8f51f5102c06357a3a3139b66ce1893a5804bf1331dbd2c949a40ce9675465a185852c01989b073b931d8dd41396a7ed479555e11136ff9b32d57a6a3f2c3bb518ddcadc27def9e40ac6737d059240e735c4c19c45fb79444e227baac9adeb3ecd9579f99e4796c446963c7c96ab9c47932ecfda7850015de4323ab67f319d8951eee5356a43f59517d92b24134929b9cc8e6b0417d5a015bfe356e42b6b4a91bce94aa4109ca456b6e4c494a33e8163a0aed3b6327c141d9fe9a07d635bef451253600ba1f0b562cbdab0785d0eea856a6f4e9e1f3a071b4323f14577b47ec649e1faaa2c2226722449dcb2592a6ff9b3feeb90714f16360056b832fb54090397abe70374b42d51658a21e970e87be1f4034811a8ed9bcb3014ba20045edcbb6fd19b050f8112ca437a65794f47f66b994f730377578e6af25ca1d1fdc23e59c3b915ef91fc2850fd20dcf6e70dddc7d051597e5bb376986b364b43c11a64158c8403b424621022aa49f3bbfefdfd101733d34f8860348c0a6c2d2db93de4438457f945a9220a8e10e1e992e7b4da8c53aaf82914352c68c66287e47c3c6fef857992c8ef9c46466cdbc2aea75c603c37517fa93b60cab31b4b0d0f9f86f593731a0cef81e284c2c9420119c798d588251306a63586c3de4421bfc63e6c3093bdc5fbed543810b02f1264e5d25037c67d5863f36aa8e80c2ec1b702d273ec239652e20462490f45c8e387f5a6baeafbdb3b732bb8a453ed50b3cd5c9eabd89fa4c897e6fd3c6f3830802402f65c9f260adeae7d9a34e9e15bbe0903f1200d47a90ebedeb5353a733b2529be7f4b52f90afe503d3ed2a397ad6303a42d1dbbbdf2c7a4629fb798ed94948c079a454d1cbd0d0d62614e3ca558fe99a0600889cd12b8cd2f2bf21f226bc39a26783c5d9d31749bf30da8747a7fa53327f9293a0596de0d2d85caec044932db0f71ccca3cbdf490d22e5870b9d13221303c491ec52d9285e75011fb6d2185705fb2d00436e943588d00b597cdab876cdb633fcb7a5a5239e432a89721bfc4f6a97af613ca0313187b66940d2d83d89f8e95f2839be0b5fda0cbbebdb8365f54a83e6e7d1bdf2428413538a08d88bbacaa9fcbfe2dc08340708527d4eb02ccff11a96d3e96dce03914542c3ab17dc84fb466bd7d449923a823c1415f18fc4333375f1ac8de144359bf023be8ca2a1fe14402e8c2083ecbdc8fc0c56d191eed673ccad240774c4ad087e5171f7a5c9dd67b015b52f10ff9fb7b31e5de66eca326ab3d77366853f1e8901aeb0d78151f4667adb2038cc7981e867070a553aedefd07a0e46e514ae76c2e54e19449e2aeae140cd99cb49cd57f7ffbd3552b2704214e8128797cb7ca940d39d96bd19f3305a5b152f6b91b4d484dc940bcb6bef0e80e35d1f70ce858ceea5504cad9f955b57d01d41e900910b8d2d00afb262bb855048dbd1278fc6bea7060e68a2688a0711b71fcc3607495b060a5df845b3e182475ce219353938f12ef407d53d167f1341d20a0884013f4898594a88f24b17209ffdde21185dc9c71b0de4dc79619c8a5d1d23814c004503cc6f3c44e828cd63d71c2ce16a986e81cb1cb9292106e30e8a7e93f03f847a11ca88ec9d0e8ebeed6403118e0b2dc9e37619c6271499004a542aac86d0cadb98a7666feeb096abfca87ce3821f021378dcb3a6268ea32043b5f39803aacfcd75561ef05cc7870537d14690e16872264e1755fd12eefb939edf924219fb10b88e3b247f79c2f5075a141939c066c7d402166bcd5184ace852246c37ad1f5ced98260e2d5c70b53126a4532c098dfa10c5caedb23a2f47fddbbd59032b9ed7b00a76377cfd9f9335bd30f1019b9a88b13ec12a946e9ddd8a700d5cb131da7309e7b0879ba6ce9f10a6a1146dfed9a33a5bc46c94fb01334837908746e9a4c019bed2fe720909f2a7dfa4f07ca35189b33fdbbcec0d4beb88773125d56d60d8fa21b8f3ccf5a195b4ea3299d3e5b9c57fbb493fbf00f48d799fc2f930407b929b61c4484f97e9149b930f48cb97711b1c57c67ac5d5ebfb2736686a11606200f23041e921bad468f9c4cbc448e5d389bde76855e42fc4b73fc91bb039d347007cbd1569bce6f5045d717999c3435736339a98b9e3e3b68553cc8a32f6899e6b7189259bd5a1b4b336ae03cae3d6fcad72ca16b1601a7df0a3a3f9fbbfe4e09046826acd2eb709300ce802e551fe19906e284280ab6b08993e429a20d7d1c7a5795e33c241099e6a577de3be8cc007a374d90e0089acdb0271bfaf5fcbfb04028773cdfb9b61300fcb0e4bbf69f84c25b6275490b9feb37423eacb0235c24e6c24e84ef07a88a160a33f39effa816cce0733910bd8f3a3a022bf267e76f7e90a7f0ae7111b60b8e0c54159ea8e7c97ae0f07b8aa5e62d750dbade2e7fa9fe01d78e81c0658723c97e09c5d4862a585b7b7ed46bfa55d09d1402df65c30eb44c4e1c071d8b29e8791d55c9c2348698e4561edaa3fe8fe437ea05b6f98a3652a5fbcb4df78e2e16dffa806ddbb3b025e85d3506572fe29d41dadcddfb95cd720518befc289a50187ec91223074b31ecd193564bc3bf64c3360e70d152b7a72677a26d26934319bd4d6d19e01d9f8f2a07fba9c161f66cc988ffc1a67596a91585f58e76d4a69ad56fe1b6ea6d097a7286f61c776b9e1bd56c00bcc68c6edb48abdeade2c587af971078bea909fdc9b15dbd2305dd9853f229ca9763496457641da92657c6663471cf87515263d3b040f967b059dab388eca4cce2808ca883f85088393ca0eca863b9de9ee994ee3cdb15a18d8b6233c3a00f34171443eb906bd41dfacf371eebd3564a0c16847bd4836aa5d2c3a66d86d911f1e9b881a185d9865dc9e9ecccecc3eddfecf8c2580bf25e046dc7bc748ee18de4d51f65f5530289d435899f914f2604fe0ec1c9a43d1389a90a01138fa18ae038de5fa30d8e0d0ec8b9dbed547f622111f8a758c3d3621ad0c9425a56fe109edc76cfb478d7e801fda4698c4a74caad2701954cf1f52df82102bbd54271cae95a0dacdc12e9d4a4e076c3443f95ac1e2151e0b619574d64825f34b43b7ff931bfb611de75a39cb47d7c980bc9d4e45d55a6d760886f8d0b4afadbed1715d4697fcffa5638668696bd89f641f0c80c9273fea5835d732ecb3cc37702378d9ff079e10ae90f033bac7f8b43650697cc75bbbd7d86a2476e81a7234dde6ef527ed1e081fa0051e170455278b09b5eeeaab7227578e9cb08a40c07e0eb218f68aa615d79e19931d2264e1f23db21f637026fba5ec406ccfd0756f58cb0db252f3cb9276cf66706728bc17b0c9b06f5e647c6f2f9e08e08059131e5543392f171a276a9fb63f71ee68392f6369676c3793c351d803e540bb12f6f1a0d95750369d5adbf017009e51a5e5c0d5d74a83ce75984f57975cf279d84fd16dea7267c891f32e29579593339ee0f4c4f7acfc1d452698642e3b019f543c2a7085b1ff58f9661d4aee1f1163fd5ad6e3c1a20a189f4a4d0549e733a5b5fa177b651617387cb1274df5c9d8a7e2b6c0a254a39eb8022670f3e4db419cbee8698f76bc88dd203d172c1d933c1ecbf7e476b5c801e52254f068335454a286e26994a7a4412de8dbd13d6b7478b47e303f472c4da7b3fcfa879cfd2c4cd1e97793af11f8d2f68ef6c091b4ba680dd36addfde89e52be79486905a314dab2c7f1b4ed518ec418966ad7f8601111aaa8b7edca3b5b38e9bf7bfc93a2f97d723c24b71169cae7309a8f8e278febbbc5a748ab6f084ee7dfc846d5114fdf0bd12d99beeb1c363b2934cff89dc787941ca4015cda7cfa96355df1e5d6c8e457c187d5e1794c4c30404a092c386dde794291b61baad3493003f9bc390665988e7db7fc0afee32ac1e9cbffa8a66d56f9b4dc5efdfad6ad2b9b8ad01abd2f22a5b19a776f29cfa073ff6ff443a9bac948db574b849037f857430170a166fcc9547fdde77bdc9cfcd41f376b1033c6a316f0ba68119e6e6a9eaf146ced6bc605294cbd771572a6a770d45842513169272ae556acc403ae296191d84b37bcc595391cae76b043d1e6fbf7fd81fc9e7cd8314f858b4dc78d19d72661f72f2ee04088a8f75958d72616bf3ebb97af940d84931f8258ff9013afbc13b8daa779c95b3b175596ab2e704c0d6d75cb3af1be0fd4e47c972107a778ceb36f53b67c8d6b3e89432bf180aef5a75e48656ff96a2295a895b661cbe957b09015b7d1f5293abb91c487ed092a14ca65ff489471cb8572d69dc6173644f1e051b3cee59e994f69b836f59fd82e47f6006adc138b99f21e650af3ab106c925a14cda11605d63e159362afb7c2ffcf1057d5eb33ea3b4df7b0ebf17c65b8f6825c28dd37ba6c51e250b9c131410afdc618e6600cecaecaa83e077a2d613bad112b7c5e35b124aa1142aee9bfc3572b73f1fb7e9e12e1f1d80d4f7bcb43e0f8accdf1583cee8f41df0264404adf732269883c4d989f5393fcb1c5dfe9b2662dbaa49b5ef969b0d4f016c9858071ca97843fa6f854625e96f4e5d73583cca029631598bfc9dcd50bce9833d0c32c75ab689007f31f6a438e40e7af4c2c3ddf887b6ab4dae852d244c487c6c6353faba7086831ae36e0dfb02b6c786fccb73250775e7b548cea56067268e73f84615ff37c1adff2caefabed1df4fc9ec94ba1ebd6875a501fbe6526d420950f37eb0354d31c89f59d2cdc37b8ff895e89411342cb239c22ef11d15a8cc3c6327d4d81a37ab1cb4657f444bf253d597921a031261cac074434e6025eae2f6af10f8c8985bcfb9fd9895a3fe2c7d56a0c31c2842b16d4812663869ff2347808ddd717d996976c5a1001bd1295d76","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
