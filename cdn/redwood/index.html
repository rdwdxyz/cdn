<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"222b54c47742a01d520c979b64b7cb584a24215877611b87efb95640ce8e1afa565c3758cde784b0692e383c6e8c0895aa319ef59fc4d0f5b14f16f350d2c87ddd1d0d28f1fb46c4b90fb1ef60548aa2a3117caff23519f13c4d384d8a2359ccf5ad7154d5a3c1fd2954090639f95f67d6b0256d12608b2cfabe7f7b906d98b49f9a8af9aa43de589e35f6ac76816033f7515193b517f80266e785569634625632377ff3dde52b9f87e55ee2dbabcdb4c70eb876a2f8de8a0e6e25cd324723ce33c42befe48ce0dcf6533bd16e938ada5e2c4bf5f8df5ce319214eb9f3c35e80bf639be52043bd6edd8a08e09048ff6a898ac3bdd6d8c67041c307018adac19b69e38a4417977b70d61e22a35969c72847823c935bab367e0816eb5b6bb38986c6cd942c57e3b3d96ea508b24271f8423ee85f621b4032dc912e8bd3f6d3eac43f41b052dab4ba303b50cfa2081024388894d3b48fa091aea41b446f576db37038e7fc340b6ede92b760dfa54bab8a1302e2987169e66c1261773d13fd3de67c3ee365bd9c8926ae6eb7ad1b3d6762573c1c5d08cc0f2c16991ac633cb88be4899e6175515d39560914c1de6f99054c657f7032852087373f1513ba469c00928d1a6b9753af5f0146fbbd2c7ad7e200e41775bc3ca55adf24469d7fa8577bff4a233b31cde22c35a15d7d2c2554b5bb525915ee7bb37e4326eedf4eeb711c73661aaaa7fe78c1751ee9725d2a7433c24fb90bbdae3af8aab8a2695a14e586820709fc488c11dd8baef006d4b9d35ca8d175eb9b3f00f37f5893da70dda56bdab1ab92f34da99f1a88c11e67036a95a62af10538e731c4cd4c811cff072162147a3d2b4b703298a3bd852ce5306c9352392e98b6a676da1e0295ff2b4eb63b3d38ad2f038b81fa82e952e3d8dd348d727a392da2c14e79985c2a62c39cc5186cd06af22da75e4addd10ade7ee33e2bb28b69130ffe2de9a24402908e5f929df8553f2c7349cee24225f41588bf43fc4e1bb3718f335ab7815fdf1ea854ce57039ed06d0e667a9a6116d196b4a86ae7ad3e995125391e8e046137c9e9b9d4f7ec9835a27fecf5270211d2014289839cd1cc15cd62d81e09759f0f6bc5bcf3cca356dd68382838ca36fd0c8b571140c9ae1526c2757a7a7730b5fa3ccbe900e48e585baa6481e1265d40e4439047376361f60751fb77e19c43f717a81bb4bbdeea8bd06cade4331642151e197e5401aa90a4e88ea10b980a9d6d3cda3ac07388928734a28005807bf1923423734d54fa5810f9dd31bed81814cc25fcea7c6e62bbb7def6a421e3568d9221390e33ab7242d9046d85c5ce263a7dd1e5152052352f325040ab89d35f18af4065d71adc89f50b18cfb3b6d8adce35f7efb01a349ebc7bf8e34294485f6790933632eea75c1dfbd58056de3477897d624f30328d52fdcaea73aa4d2b25722d557ee63612a6eb9988c3bea1539c82f883a947395b5a28c75283566f2e2ab9b697d9aa583ec29febaea29b1b8c0e25829c84890189608b173c96d2090315fa39351212f5f550debb0c66dcf0ed93d7f499ff47affac07e11e90a5d786ff8efbbfac0684f229e39a956f8919eaf994b9ae59d55716ac55f6cbfca54ab4b6f34f450f3a9dba380b02dbda75aafd7dcff4b9fabb402b1735213ab10585c64602eb4a861eec928446656d3eb0445aa8d8f55487cb8023dbf046c3570fce3e0874812eb6a5224271fc6267d9b2e3816a6199ca2383827683cd046c2463109c8c46a676f02cb500222881af857448e62a1b99787952b29666587c15a9e29c0afc7f277e751caad9c466eb8a2d74bc9f0ea64d4d9fb4dd14c47ef2b727af131ae3e29fe7988f0125dfef08b3b2e1f27b6b1dfcbe5bdf1c57b8970e3cda8203aef170760974516bf7800104db03f683f97c34a6df7ce0a9da3281b141204c06bbb88a6b37944803433d54d6ee59c303d96b70aa19952c07e6863bc7d94827c57ecf17421dae34b26232a5721665c7eb4b36038bf598226e2a09e8d930389b505e184380aea1cb04b5370b4a04a0a4f876f3f002ad5a2614e18b96ba562cfc5c1181d9da1f9d0270e2dd34d3065a59878a45b79208d6e65d662608ad435a47aab1026697c20c80ccaab3bda68478aff86a6f0679ef391127c4abd67b99ac5283695914c8f714970c67e4d5637688db2c7dc32d21c7b3f59173b2edf6ae11c15e3186199ca6cf850be1a4ee37f48c37a301ae543148f5439e5389d441f860524794bad37fa515c0e76243f0d0cbe5852d5a2d22dbb3cbe594a41a4ac8ab602f74da6d6df8cef18da26ff4bad260d5d6322384c976e5cad9eb943d514eee3bf944c22777cdf7a417b8ba1b34a9d4fa6cbf37c0c444caca1cfc8251ba59843294755a486e8181bc9faa1aebfb1579e6e03f152e21ee6a1687e3d22178158ede2c1830adedb2c5e3473f774691c02ce7d0b1eca1231d4212fb60d482fe021efdc916f68fd7fbc8f6275fb2878656c81165461a75458cf437d04ede747be68dbc2ae9003e13f68c4ef871b8cccca0240707b6f3dc8170b99c7e31da7094ababc3cc0948bc73c2831d4cc12c56a0ca784953c075aebdfc9daaa9e9185b5e561b3b420abd1429a89f30a6ce148256bd72622cdebcf7ef0212b63a87fa63ca098ebeaaab2924390d5c5f898272a4b360e7be6cadf158cefcc27c15a01e37ca5c34facb8838969faf1833124e69e90836c690b40273d392b5f930a35b16ed7e7d91c8ba99d6b29aad12f4291478061eef3a2e4744d9dd581588b63f6d641024f190e29db2bc86b54d3026d6d2ca9aa5fc97267a849db6db98b2c81ad370474d32217d282788b6b1c68541315bb02312a4fa8d44fcd4436381d6c97a5016d7e8575145165cf2db9523310add36e5b1dd439925a4b9fcbf63ed00c494ed677525cd189d2353d9e2182e47648be7de229fb9b54831d849548b1b4827fc3d7b03e0451f33d336c85b6753759150f3679f8aa185eb45ed84fc264e0e6c6fba1eb8d78b6d068f5f1ff0e056b6c7d4f3325611ab31a6e6a79e4b40ee43f27d91a251fb11317f86e7337c03b861bd848eef2479eb2261338473225dd162effad1803869a0b7fcb86800cf48ec933ac96f2f580b681cc3a3ac33c660ca9bb9ec4531b9f904e19cc267f6acc3a5a2dfe70399e00c1097c4a5f14421cea2a0d05e178fd37e31aca9a6059e557b2095369386b8ce15f7c4bdfbaf5596e40728abc791aea279acbeba1ee2cf13ed1dca2941e36e2f00291736c4a7d260512a35e56380b2d7ff2737f364fd5913bdb13ec15ebf4c6dbcd97a268549728b3ddb7c057e3cee8b4b11d75b6fe6765b7280b9116225689c979eb787d9fda7bd4b61cc321dcfb16203eeb8fea24fe9faef95c0be432c833f9927407edfcbaa5d1996ecf66fe46a597ce343e70e58ec08dfa69080a69d029326910830997629f033b49a0182e369fed63d1aecee1a831ea8b975af9e664928f2f20beccc27cfe90d39eb40e6e9ef85c0cd623097ce8aa822f16621f3befb9007b83f9ae61b033ea2eb18435dba4ed2f6ba2a1bec9cc008b0dbceebf2bfc6592ee77d61a6dd5ceb6a4bcdb9bd294caf4c1c844c39914ee8a0a161e9bda1d300dd45b1f4b2f263eb7b8fdb78802fae82f32ba589b03324e922aaf3cca1dec39973c366c66d5659383f44e54595f2f146a4bb8d897b0abe51f52eaa4f829a1ab4fee25c09364a039ec19f8f99550901d18fecb62b212df853bbde1b7a09c4268189cd0c5bbc12c8914595a11ba5572ccef0aebcbf98d8a5b560daef100ee2635bd9011e67afcaacfacb38aed91754cf207fd98f99d32b48c1f1cae4921567656e0acebd302377f229f9df87da9d33f16dbd5eb2ff3d9522c9648b64ea15e72e39b6e5d41cb9913b88a2fb005f9d37300ea7e174064d4af28475b4253bde4af744c55100039df62df748f7d44f61c16160ac0b23462fc9254d07f9145a86571c6d6e9a3504b46af4d6a4aa5e5ad1762feae509ad2c3ca151f89fde6aebe7d3ee6dfd8ec18d15ffbb92141a617bd79a40610dd2467fc48edafcf09fcbb9e540226dc90374216a251e0424dee2c427dfbc8e58fc641aaf34bbde846db49f02a47cb9998ad78848f9b3e102ac053a7b3703f3aaaf1bfdee9439c2033adf1bf0db8890222008069993e5943e3d1b443d66fcdbd3ba45b85df7be5598acd0335aa7268fa5b4a3ae765b0c2f8277d0753c407f9a88a3fb81b3d573a4fb51dcbb68f47488f80ba1ecf0ca09c0d1c434eed3bdf0397e23ef3c37bdd8c3d664d65403d44600015f9cc7ef46d85bdfce62c9adfd8f94edfdc1429f03885cd04a9c8fd21c16fabe0571b38de8470f5fe7ed24a058d37f1578a54b13d250ab6bdb93b8e486eab30353707295c9f654ee40bc2eb10624f1eaaa438265319364e4432362fd05106eb8d4073e03a3ba4bcc027f9b8625fe6a626005a4f99a844d6fed0caf3b7b6c2e8b5669d63c2846c04405a2ecf98316a424085658dd29b20aaff3ea9c505bb2aa965821899b4e1088c8851b8b0f73fa8c8944fc4a950f955a9a0f113179b186e59c3ba7b00e00d374a48550ca67a08a203e33e739c9b11618f41f37697713cfe472d20485389e1a7df4c32e87dc031691e3c741d87642ac34249caec65d84c9d3df72b2af0c589c166e278098c0b139aaf26defa02303694e865e16b60f72948ee5d0155568e790e93852b9ad33952fadfb6f2ca4ffa78a5af72a27c12f4f98da866c127fca695d0f7b6d22af9472a7cfe9cd42933cccf075c058dde542b1cc364b8efc1836100686165680ab1e85c3238944ff1538b424d6f966406151636a6cd3aedc9cabae1126eb728d312625eedd46d37f136b707f80c060614417d09b41451a123b9bdc5be4e82093d3f384af2f14eaec7614fa29f099748215a2d117533d58ea8106a8f8524b404d94ff9465c6d78d8e19fb14b85fdf22b5be1e27c05969d6c2273bacd9f94f5dac71eb2de0ad75f5c2cc0f2bda4095c1ac94cce28f868f91472bcbd55abf520df84c1622e964cf0529b98201dc39b679275b8abab7fb6aebeb41a933064e74026ff9d7fd607169edb1314b11a658a8e834785631f3186ba58c6bfc8aeac1ed8c93d8c64f033ec1017d8ae5c77a82b92ad21a366a2d096c40cd2fa9fa239d4d7079925ed9b7ac46a97a178b6f7ac6f00e95f690d915f9d7b0e041fda870da2abe150a3084ea6092cfbed68306078c3c2e3ad41118adb815202c5f9e8e4fe665ffd1cdd59d79b39cb4005bec254420f94492f257db9bbd6ac02d358df8ff6ce9851ecc58aa3b3249ce47f65bf1a8d9eb3b9cf136859fda2ee20f0fd4b3e152e5206877c7c8ee5efc28578c5a2dd3a0d71eba792fe4691be309ccb62c3d13ee400d1cb50b31297edd63e69a53c1feb29df6fea4fdbf8af17d124d7bdd71d10a5a588136691d330e12e46ecec549791d0f72b2406b2160987028abe1f93d137be5fa3a96897c599796f94755037ef6bcf05821ff45cb723af30f7f29aace9519f6bcbc78e64944c20e5f249ec9bdf8dece7aab8c0bded99f470704435d475f3af95b27c87f0dee0278fec2bbd491b4e807a18e2d0c581da4cdfd5c282f64db00c4439e84cd4b6ef3b9b128bd64779c4bbb0ccea54cceafcdddc15355b2a79c84ac96dab71618dbace071550a0ee8164ea9342813612b78af132fb556f3514a4ad37f3be04120cb12c58ab43027d4d07fa95657ba1a2b7ec15dca2d59bf61fb358624b0bb424faa8ce5a9970874607c9fbb66fdd2d4c54a077c9c39991ac2fc2cb90bc01aa381b7067989b3a4df79d063b8f763ae67716156f95c88ce31a2f30f1821d3ad54191514bb8e8dbd449da915c111f1abb9c5c2d1ff2fa5348870c1a02309afb7a33718f735c15b8065050bcc5ab3760aacd77a3d49d969f83a4b5a6e37776b429e30259445e9f953569e1508827f6ca7f24f1759543df9df70d386152801c13d1edebcf36b1a97807b475ef93e436d968f4572f4e8deb955ffe06588f13bb600bafa8fc566ade59516b52a9c16e29dc3767cd7b40925279b480aafdeb77a992a17e7686cad840de084d7678f37ecd0337f441a2cb5758b9947d2491ef94956b666da4513b57ff6f9c050f99231d6428889d55e135c0adcb8fbc2e4f05e1bb50234172ee2be180365ebddaba80c3ba0e01be99beb2fa6d2eca8b2124bcc6584fc589243904b1a056119b221a7613de3a0f7923c79cd216040ea42f8a88619aa01b7028372e0d238d928d95decb16bc242860c0ffa08827748b5c1c3eee3edd4ba0b278df83845410d09332d0b792bd11156996807f99cb2771be3a620697b5c26daf33808eabac364a916f671a26c53e00b683b8b98ac881a42d6c63161dc9c0bbbff3f1b5ceea982e5018ac0c9576c5eed75062ed49d239708602909fbd722161ea876a535a751486863841dfdf148aa1b18b251cace9073988ace060ee1d52025f059d0a9d6fa7922669dea9a534e85202bc3bf4a2b5a1dd579847b97527946e3a78bd2645108c296ca6d64cffffbb0c91b870c308fb6f5882fc216495b20f45a6544dd81aa9edcd711ea106b9c40fd434b764ec04fbb7701500139b2ca727df87a5a62f483933e966bd421d3692e91028286bc2d23fbe9cc4c9a854a135c3e6e445a6e173bf87aa79241432fc6e6c56ae20b4fbc19a855f13ddbbb43f2edf08d565f8e7c95bcc03af3368116280e00d5644faf77cddafd03e1cd194b60c7b2002292d269a704ec962768bd15d6d0989bb9ade88a0e12b190bcee24c5cbd2425ae9f0d8b288947e6ec865c9449f4e92df1af4e2cab0a7bf6c5df354f6b039694dfe6899e8daa9d344b9ef44fbf6657423b5e5d2ba97b44dadcaca53d1463e2955ddcafa7b09eb74d8585890e0af29ee08b1b0a25642b844fa275b7b025735f9069ae2b24e212c33ea38a0eff302f7fb221d6692f608fb117fcfbc1d3c8dc316108e449fd1ab2e77d7e52618671fae599999a7b2e1bc8269f4cf3f665486c6a7d4312e80ac26a29ca1fd13b33049f7912aeb81969ab7289c16c2a22ab8fbfe1328cac6c2835280b954d80d8fd59e3da222e3cda5891cede4245c4f253aa652cba9fb0e7f579336c8e3fb76d20f4095469d0b9f0c97496da80bf4270d2989b1fb652bdf362342a9dc65a65798d39235637b38eeeb19093e87808ab5d56c67de2505200895083dda10f24b41ef009f8e99ad97e0467fb566c7fbda5d719cae67638198c58cd7ce74dcde1d2a0cd0c10832618443c32d60b191ef86793e8b68c6cd8ffc257b9e594816054c6ab2560cc9feb981e13a561d4072ca2832921aa8fc54e040e73d46f313e9d2061bb7f047883e173d7d9319387cd94abdbc4193a7bdd7e3b53a1d1dc01e89b7c20e9b28d5b2b8d290b8f667dfb3a3d61cd83dde888c413d42a2b47118cea03cf984f5f08463e98a104625a6672ab5700bd80c86c61054c0cfdd8b9c51c82c0c68c0acaedbad1a0fbfc6e823aa355be92d27d5cb13963230820d59dd96ebaef439a196908251387264611c609178e24e0f346de292c655ff1e0e67a68af3bfc6ed114dd11f90c11945974439f9949b2ed0a30c330e9189f8360898f23595a083b24a573f173f14f27560e6ea4cc86da0c53c700922aacdddf427395769441eeaf570bf6a828d9b8b412aec747e385cd14b8333c2e8c4903984c80d006d2286553ee780b914548e345f1de1ab682390bc9116a048a9831f12bb1edc5bb4b79b0405fd49a54ce50f22a6f8723522dc963235e68bb13fffc5db08837106c734d41ac9e9ed954cafb466c68d52e216f15c900b53682c0c3e934beb9b41c51a80d3effb74d86a38120fed42176217c0d4bae7e89bce303996bcc004f01b73caad10cf0dd3190d008712645cc5ae4c1be0d2ee8722c5cae872512283313ba31adeb0e77c859460df60edc56c94565343b27496c473ca88bc582c13f66d0f6f4e252eb567b43704088a8ce139269d2f48a6f6207f3478973ccbc975e417ccf6264c3754072558f45bc5a793ac931304fff51c42db3c368cdb48ec1019e4403ba8f1c14412f429c3e4d28d40ff0d29fe5fc10e83345c6e1014f3ab5f0e955794caffd242b9b81ac5db2f71ba61926ff87fa0f06de760eb68b31035acddf4a1176221cee849d9be783ede1b1dec6b4395917b0a2569f12b3c5a161f0ba1340698e6a487c039d4bc31a06001a7618e7118f696708a2b56ee55664865e71d9340c9325c1ac12efd0f9eb2ea44bd17a276d7173b27a4950efff74a2bf323e0b49b5cc0ff000e46ffd9806535a92a22b858f600fdcbf06735b06ec81e687007f5e5b4cdea1261d6099c9dff1110677aad525353fe60f71c22510a4abaef93405d597179f8a42cf3a288066e59b360c4882a4c2fd738ec991bb73b37a0cc3e725b9f18d00c8c1df81290c2014e58b4bb340e67e8c3c949dca4f85f4f20a8389bbc53d6106697369a638fdfcf1bb4bb3628031b6f193384bb76356fecab064477391f0effeebc8ce0b765d82c434cb5efbac426b899c98c3b7d6d64c5443585b982c2d35eca2e7cb0f3a22c06a4a6c5623967e4cf910606da441c92c64442a3e6f8236ae09d290b1286d7f55c8c66a558b84cc8edb0932f82befe1e0cea9e1dc004ee4cc2fc661e48c7ce8865f4f27b34e6a4792d76e7137cc327ff1b0b241883b5f610592e61902734805199b781938af4e3ce792a3982611ff26cd232925e3410cda691a6fc56fb3c1cb3217125143b5c2cfa4d7237afe098f5aef11202f0203bf055817bb9a3671181a9c700800e097abcd08db0f5e26e0c4dbbde68a6ffc75f200e94cca68371a8ae2e71b3a6968aa24972e163320ba57190a0e73b28c0ae3be46be8f8d5ce3d5d97cf5edba2fc842a33116e520b0223d34db404c14adc4bab252cf98f1664082311b87625d10e4f7cc0964698a99f0bd45ddfc1b76a33a2b2edb618404e6aa93e02892c1e7f6203adbee3804038094e8fac6903c840d13542fac63ca9966a2531fb83aa6b59558269ddb43e507343c747b741eb49e847e454589755c7a4fd6e6ac098b9c37e99e89297b2083d0620a56e009beb6f6993f039e0d19c0de8a4d6ac6737935229fe4b83a1fecc369f500a38af169a33fe346da9cbc76d01ca63434b813af6cc872a6ed16637cceaabbee26ff42ddfd2afb8e1317332befc95c523ac162d839e42be7f6c42bf53fa7db4fad4aee8c777093ede95204dc19cd6659572c4040d58504f46cbbc2476a1c742c6bdc70f7419b80f8ded7636e5112ad99b1def5d9e7f4733a255ad7d509ac134b3824f1f09ad08eef3c3d66d0d685d2ec22dfb8bf68ca2269ddaa982057a056f7f7cca57837953797bf3cc61a652caaf4ee9589695c4a011ea31fb8d8124eb4e4ecca551872f4a452dc0fefbdc7e50d57cba56cc8399f8f012c19728d9f6d90af838a1779550e2bd22ca275e8f08f0fdd477b9a9e24a282d16dda79d1d58b71a2e11cf36445f0762700b2b0a265f6def989051b892c40627e6f4358938e6ba14df4b722c77a7beb857b4dd5c2a980574dde75ec92017ee3f2e3ecc6b1e6b709cc6d84eeb6216f8246e024604a1c77cf17f2b4c7c7189f04cb9a5454cb034cad343aedcb1f584fa735f8c4efe25fbd48a6830c0699007d6edceaedf26ebfffa6057916988b60e273918fd21c915a5a48cd6209477a0ab60ab1a385f49a279bcaa1c99362c608955f84b853a5437679708c8530a96d97080f2658f2ddb3c7e525a6e8632f58309a7dc81e0f77d01014112799bbf7910296c30d717ad1faa917a565190b99df95b9d7ba39be57956ef5b4b38f57c110cb97f7949a09d17534eb306f9085a18a977fc8ab23eb1d78749140e7f0c76f8522a8f924a0bb4f24ea2491cbccba6acc59f4d39133b84219e19d88a604ec78a9a16888a8f44d6385eeea3aa7f5fbdb536ecbab5b83692bdd9fbeb17eb46d116a67e07a93dab7f0d31619ecc51346cba38916286310d5ea00cdac25a5e112a4075a076c8651b7f58945af8dbd695fe97e0e287fd9c262b2d93d382095f7bcda4ab3dd5cb8902fe83252cdbde4c7fb9cd0a9a9c3184497470ccff39c10e00c868ac25cda6f9c00c9c34d1a1ff63f836e259002dd2e1ce9843606fce527930487e423719b17f5a1babcee3c06e7df2f55fe3a2abdbd5e61a31e3ac36c69adf579e2e52742da4292ac77fe2a2a2addf1812b5684c73d659c1b062a0c7c8fc94f66f572880a7370c9301e1231aa6e7ddb40997b29ead2d35835f6499674699a088fbb3c4d744a30749657eddd85c897734d4a8fd01402fb09ed982b72f8e762d4622c9750561e0f147602a4dd066281e70fba12f2f1b2145d5732f9ab95c507d9917d656a4637bd4f44ef86b7948803956a23f53f6166f6495257943acd039178d393e8027c5ea0a37086c82bdb00dcb1c2cd703993cbbe6a40bafbbccec344081f7d29582f69b0cf67cfec2a415ac5f40500d77600f824ca8b0878ad119866bf88bb33dc805fc975f02cd791aade3cd498cc5fe51fc44af6affebee587fd7bca6f59f6199a9459a8e26f26d0540d681361155924b9329b36ed045d2c36eaf8405687953388b4758bc5c5b5e0294d67fd9ed066c12bd8aa63c6a136834bcb3c48a088688529a8a6602c9c2adcdbfe5defae7e138c41d609eed7e1aadce86c97225007d658a3c5d864827d8378b1a2c0f17341c5b710bd2c57090aad8e89367e1d48358df2374436967b48e6e8c8e78dab4037ffda68cb7dfa61e8739adbf9990776db58e21b60fab2ea920798382927d0952b04a819482dd290b160bfe1162e4fde568949140c68a9af95bb1712acb0a9cd3671f403a39c3b4065322f6b5edcca6a04a4ec34763f6b4d35d10ffd424a22764c39dd50f0541b249c7d0dd0cfb9a3969c1dc21901c6818c811488d7326dfad14aad00ca07e60a7a0134c586cccf8dd005ab9ca5688b514bb756f84b555b632a8c7eded5844cd2da59143237e3cc3a22b5b28977853c6c361c19362492048d2d2c31979c09b468cfcb6e13f4d30383d7d0964c6a49e7b5326740cb4a649073596311a221d6e548c12dd01c2bedb9b421790545d327e6a06568e32a5479f9427505c1aa6bce6abf6f996a4e5c2213111f062a517238ee6a0fac18b824f0bec2d9e4127136d46205de299f33f1badce9ac29d73a44d7f0657ee6e84a4209f68df35a94e7a5f8e4a32b270b3a8a931a63e9f76412d0baedb83d67c754f4990c20e1896ef7d190a15ed34ba44f47a317418b668859575a7f1f16ab1a8400dbb8b0a1e6e3cb1d5fea31c8509e519ce3b792e5ff5213b319f1cbdc51479a193655a393ebeae239f0cadf488d1ffc18c6ac5fed6979b3df0688c8ac972ba7f1eecb1c7309cf311189e40a266db68e935fac45a2b4272d0110d70c02a8eebeb125e484bc526c780620b21642bfb8948e0ff729c1b092e15fc5f60f0b194b1c6b65c5faec846eeea56acb51fffd1751633a2f8273402eafb199a9005dab38b43b761dcf0e7b0971a64ccdef3cf2954425018e66becda1ddd007cefa2f45c90c0e6ddbe59d559722e49c6cc9e6c6be94a4415744d4233b3ef849bea200bd93d0bd089ef948a528789f8bce23457a3ed2042ca75254f7ca637b00bfc99d6ea5709109f424aef5957430531aaccbddf355b5fd4667e4da78862276111463102d41bce61c1a52cad6710f55d61f5430d8ff9a34454f3b5cba5f2a231272da84e4ca4eee7130534d1ff0279f12559d1c358e3296897589153bbac4241112cf1db4b6942dfa2262fec9d8e3064d25da88b117d8509a3472c09cfb4c55f5341b8be4ec8f858b95289fa284722bfffaac95c89085b2e414cf02f35bef898c6f0a172eab4811fbf695e8c6e70028ab5ee5169f5dd6cecfb3b71870cd90d0f9897452aa197903efb9a1dd598fbbeab6bf2e471fa4ff9102ef89bbfcb08a9785377b9b37f7c2dea9164cdc03ac856bd6c7fc23a02d6c40e263966bb7d9dbc0762133c99126612eed76184d43bbe48269be00d4ccd81b679dc2b476112824fa7cb4f6c68b304539be9cdbc628dfb99154637d7a8d4f63d886df252a33351a8906ff3ae56197f4827890d730c2dc9d9d03264698ea00756380393df4359ecf992009e768298d2e97365cc61817bc66810267228bc4225b384b9e7cb72342b02d8d95a49e9b2f8f4929269582ad32758efe1675767c22ceadf3527c82990c7655060522770de7ebdb7907089ff31eb0e71b3d17f009c142e03daec5a6a9baaf7f8039b503daa9f356df0fa76c9db87e207238ea06f4cd89c4571d23cfd55302c36f613422b0fa676ccc02a44c7fd0bea62c689f8b1b94f7429d264e6f13c266fbaea103c38c8104cec3b1d3d39497f9081d052884ce2fd1927cc9f13055d36f06121838f1584cca0e001fa5219e1932feeea1edc8fdbaa2baf39dd16be5ffbffa4afbe66dd3d17c65897342f247f046ef459092266232b51d851b650ed8d8d81ad81834115f43147f6dac22452e04ba3e71cbb04c60619ed3ac65234cdc6d70384e35d47b7b7bc152ddbbc9cc101fcf3f057eb98dfeace7b988de64b82f5b6060567b9b0ce3332de67ee6a6e95fd45709628246b56c53f3012b1c8df215b3d28592675bb9fe652644e06bb14e8dcde25cbe8310f6abdbf7e6efc51496b99943246c0de006bc9e2be8c8b6338ea9364e72c76777dc34d7131feaebfff294d983429b559c6fb1903dbe3b294341ff63298407a9b36b514a774e49e55e173c477104f3c4e7657cbc591acd3126b2ddfd7f881553ea8ae2d9d0c42f1e5c1fb0d1afc83f97900c9417957d89c3d8d4335baa25943a802e595f59d3234c75ca1636e4d3e1d47e20165e9824ffe25e9dfab045a8a6cc6d02777ff30093c178483d5902187cb553620ebfd97863b8db4d900d648656feb0ae0289b185f2f768b9638e31a8600e89f5e52544b144875d484366b3d09c918d2d6b5c1644a3c23f1fc9db3faaf95c3985dba23cbb63fa36245b01fa19b035ace12beaef7282ee675ecbe02d60367071e630334df77492df2dc509d61f49a29a9abb4db4375711539a536cd673ed76187519e5433d4391a80160d1bbe4381569ba67b54725ad526489ddcf7976de831e08b363c255fb517b9214f71fa5cbee0094a171a314eb47cd766478f37517f0f82d7bf0d2cd61afe197706779e8791a2fbcff77586c80159fdccd38ab919730aa3e6755b755c19735c858ce568301cb529777404508da7a968de2b6be7e50ceb32357d5975b942776bc4765802d9f78d704ae7e17a93b3913e24d9f79c3440c0799ce5e33eef106c3d7e502a73836b07535a1b10b834fdb846626cdfde1054be189872ead9dc255822208dd8587fb59db02d5d950392870da7a4e225cc548948c4fba637b4534a5c77a59ebdddbe1f01b7c5f4b37409a20a040457e3a9943e52bf6aeb5f839a16317d1b4700d5b599c255a0027fa74c7ccd45b7d2aa4ed34474ac71dfc0deee2d2586e04e4ef500f81ec926059b4654dde2db50b41bce3e46007c11c35e33982c782b82dcd7901efa0d9a3e0bb4acf9f608e8440b61b65abbd1df8ad412c4e5e82be674463348f8bbece51901f7e04a71aa0b74e0c8526a974fa6c148de43820a9c0cfebb4fc58c8b91b3f3ab852e1f1c4a01ed3c51403b5bda5f6c55c5f6684071dc4c0b14865308d35013ec2d4529b10b40cf9cec1ba1d51292fe47182d6fe646533df8b2f6059d1e7ee582b359ad069b751796d6460723ed82f7a38aea1b126c8869d0eea9de11b914a2afdb9e989ef6f4e5af9fbb83e41eed8c84f48c003e194bc57f0f9536c66f9631559484307414acacf764ae73c67108b24c433c823218876dcd23c387c99e94a3bf0a23dd78a9bbe7124353fbc5ee6ee12702b3e2c36df8c40813a13c23f6800db81e34922a0a70d7f2090fc848fdda4b49eb6112febf7e87a031234ab8072efc8dfc0aa71d7b0e9c460be1329f920ae6a66b26d7336e46bdbd1013a9f7742ab1d41a409c05f88311ad15e6f94307cf86cf8d2e8cf76a7d00324bbee457f1debb0b04560b42e5d022e7363799efef3058104a49c89eddb895a6b8e0dcd75548f967e105ef135765f827f8965ad50981f1a4afbcf00ddf2e00c4b3b4f25cf75769f41ded2beb696d188e7d3abe21024dffbe909bf2373ce372cf98af111ad087e829d1bf3a487ab7f389c9d0d4aa5aa73b5ed4e0c33d3611c36cd5208ad8b7301e323381f71d1ac9a7692df4a46330163e721b722328b19c2f5c8d69b768e02093cf7afb4cab1eb015f70144e8d78fdc8e7e0d7004919f1c8598d2afb2fb90896839c86b9ee95cefcb16f8b47cbb223fcdc1c5765bc9806a36dba7e356026d48e8d2826cbf28e3571d08bca19bb5c11cc93f393ce132c6876ffe5d50bb36d7758fc6994c36895c3a06874197dfafffea104b5e8b5ea969ea065caece3dba6e38a107200d3fa9ae712c43c540a6f8f99f5dadad92b59cd5d52f33e2cdab3db7691949ec25102dd179b64a35ce856659336638d290c6ca5347675574702a8f270c3769eca48ab8291f50560ce36ac4340c54707b235150e00e1c52b5b3a06cf298f4ead95bfd128fcb1a6f13c32e2764ea20113367d7028b7e80f38e9a99d34f779d73786d2f96db0c9a9c54e6ed4d03a52b127df418bc9cc48cee09b9b82d1cc30be5a19af78b66e5bca8c58190e50ad33376784cb93eabd85d71b0bb0ff3c18b2eae756db8ad38e70d4f20701d0e2f06acbe0e50b4b84bf512669813a1a5b0244eeec9811ba458f7102618688ad12a955ea5999e472decbe0c38474c037f6df0cf5ea3452c113e8c788a40b1558d6d7ea0d3176a5f84a4d3d95f3cd10dd9421ebca1f296a0d5d1e96a7dbc9e7f183379fecb22b23255138e358255763e3f2a822aaee459a73ccc0bd7d12e894f31c8c8e0ec4f01a596b11feb0feac81c742e725887f87f9bda8b7408b8e2f85a84c1e2f56c5e51ecc5fed8404266e04064a46cbbc41c5540e5ad3a76f1e50becde2b2dbb802040d0db2bf9359356d6500f712e98b058487002cd69c6ff36e53a5735d88b00b490db727bdc11f92aa7386d4c24934426a5cbb5f565fdea6779040948731704e4dc549f9cc3536e620571e738e167740b045aacaabb8d427a56a2b5b3125fbfb285e41c1a86734c3a56d2ad05b744374427c5bb23d4df11b1cabce791c5a7b95ab5d0625b903aeb523f0193ae5fccbf34d1081782882e4f40a96b68ea01367416af130c5d845a2fc30b87a1bb14ef9d374c39a0c3c06b38dbe4e5b10d3e216c5b8c1e3eef2a8ad6e8878158a6726033f600890382fc81df50a97a5dba1cd495c12133a3ee155ce076c078b913d409b0730be861f9e20564486fb1c0259fcd695f5169ee7b3e9bdcce8c2ba97640f97cf26f01b26722c4f67070f24abf938bf91d2ce465cc2a77645bb17e44aca592d46538f405f4fb655c622eb79ecb4e0bf29f3a35266fc3a3e73f36b270816750b1a040612ca81eaf6345af64ca318494df88cb57115408c05931ab0fc1649c8a7743663ec6c70a2000b9824741fd07b8141d736c83b3444ddd3b8ab26aee50c350b96b41f3662ee3432d821f6d2e87de2e5362c874678374ca7ecc7fe958f2884dcbdc5f89fe127e61fa4fee50b420997b30fb08c740343ed6d86f68f900cbe84a55798a524f173ae4babe15ccf0da2a0b8d2ae224dc889c721cceb1a4d19841b898abebc340329698a361c10ab267bbf420479d4047fc779e1791335b07c48907f845da60b7f86ece95d07c13fd26e7542efc4b283713fc58de1683ac6a82f6fddb10ed4fcceccb71fb3ec9735b835a0e0287bbe1779aa669f76ee065d8fa07990870da81da6533f4e6a60e8fd4385f6983e1a851af943cb8ce0f356364359afeed3e680e8b2bdc7dde4664b43795ccf0fdbe7310116300e3e09a47dc592f2db018579480084f9e964ec3278e268c2d6090d9a65c4be3801c26db40b4634c338370a89abafcbe2f128bb27f4db53fd6ea35a6bc7fae40efca49c72b832c6d407a3c9027fd883653d7a05845aadfe597ca179e4303f5ac72faf86a03121b7e32a8925164874534223c33d351854f7cf6317b48a5250a52de3d23b4044ab08acbcc1a428178fadc683bfb8991345d2bb4a7f4bed1bc62146d16c04be01be803938bcdcdeb91294f56cee0186958c6462833ffd3ccf760e04314e0192de7bd350433c4db29757f7156c7b8c4e6be2b60d4ae3926397b2fbd883670f04cd4b1270f779386136e797b8b852a563d8eb021aacd3c5a1cfe058a3c7f3ae20a8c71dbe17cb1e3db82c34489af631d630b0f252ccf8212f96dbab1dd6a91e9f73aaf247be073e872f1f4f7c82dfd3a79b450221045d93c421128fb3f77cf60622c9433a4f654e7e7cc18b4b03095ec40444e53b4605e4ab514606bb00a7b289836ef31e4a31f8229af28dd691a2a98a5f2ca5cad45c45b9eec304dbb280d23119bef919528996f006ed8bac4474e574dd70b1e5b3df5c192214675a624726a79e7002ffc9876271ee4eeb2b78d0fd678d87cc863a79e02a5363ac9cd26fe54b6ccbd2b7459f3ff6d8f46922fca3e0d3a7125a17cb38d02e9c36d559e16397c1afec129ddae1ea7768c54a462e186239d42e2c56f16f621e0e8e841511851657f4eb9a0222b2da232811f1186b46b1d5b2039b4b71e2fd264d26bcf92b8951e726c7ecd9749125c8d652c0882e4f4d7ccf43e962714e2a7852147982829e6c05a6fdc84475eeb07236c451d2a384080ac821f3e2d71ab45358beeb7602082d93e764bb7db4a10dda46c3a9326a23ca2599851a94281eb2a692943f5e4faf26b6794d78fe8be603f05a82b29d023d2d8d26f7212fa7ead2d6bede79632d7e0d1ce45670c1978c3df0cb0c2cb89e936587486d11940b193aecc8ba21bbd08d718fc89e595804352f70de0fd5b63273054728c94df77b19797dac1604063022107c4552f8915878931c791bffef2f11872c20d94bac4f714c4e41429cc82ab50494a8bf681536efd141df034cc8448f79308d46426c0560e1cc1ff34d2250aad7f8784c16eb6a7e295daf9b1eee85c89726d69d92b42669cd89e3843e37bc1d32934a8dbd0b8d6ec7581522d928898f023a5cd0e06dc9ff58e9439779731151ebeb39a37317afabab62457c74ef565ddfb0571a9cb5da1ac778f2b9e618c52b4edf9bd29043e6306aeac265c73891b9d7db908ebf0718cbecff7d175a03298f79080309e884e52d8eba93e1c4e5cfc6bc6a080cef7f402e309eafebf26c2e1b8a0c5d5aaf92a4314f9b0b91f955c64292409cfe7c97b0de39eabf10e415ffd6f70480eaff309e53bc9ea472d6596038e4dcac3f1f5bca3bd94ec121a248c5d96bf324c73f471bcdd9737759f556627ad996b9aaa6ba04d12a69b2575d737167548cf5d2b101e6b9ded9af43141ae140bd38ba046604056fd283ca2687e97101891793e2ef4032143e300e3edba75b28e69dc06327365e48b03e87514fcd0c100b3986645bedcfb3e6afcaed518515d254cae98406dc7ab2534c282bdebc171a646406b76a43582c9af891432c65702e21cdd7e6be28c33b8259e5166cdc72060f0968acbcf5ee8980d0b22484225f62de752047c11126410e048ae4947022e14150fc713042e9aed0deedc920c305d3747f027acb4d75a306c548ad421382fa12eab9125cb6f15d30ddf3cdd2fcefd4959beb6e5714f41d93d248272a68e0f5752283ac0246ae2c687359c84633248128bf97f25c4337f4ebe8a818828bfc8ba82b9952f65404b089f77f51e27ac7dbc136df074726ff8da3193d3e9cac98bf2ad103e8dd4d6093ee2b9fb1a09ef213ecf993384556c15c4b652399d41d9cec7c3ad760189e0f41604609e7233167532babea451c2f14eafd217fcd77f771542ecea17ed2f90","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
