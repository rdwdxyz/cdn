<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b0d00c3dd73ff7db2f22ba2096e992e5af5b5dacd0ffa083f8dd15a9c8611f7084de898b572b6331fc86f06aa7d2f35851b797bdace12e975d3e6c85fd35867607518e5622cd80d65aecb19d056a374caa37c0b3129db4ad9ed759ba119216f5d1dec9e98285a346afb8d9dc1e00a57cbf92b8b9385bffc567e672ca42864248596bac0ca001ac2912d6c10381cf54ed59c051196d43e59e4941f8d3a2a174eabf0cdc21bc40a5309c6968247d372144f50605cf251978f9e979485bd9ceac1ecdfe4a12c1fe0c11d6c48d4032c9500863927249fb775cd7dc0cea06292bb4114c38d518eb8bb268f8afd7a84e7392395745082faf4a1e7f0998525ad87aeecfeedf63db29fbe9ecb8e23c2cebf94678241411c0d6088a50953251a4c9ba731eff016e3f37e6a5c1cd2fe5ba5f5a14dff7ef92667297f8e70aae84847fe6f640f24387b15f3ea6dd8aa6fc6fc4a9fa96f0e256e75c1bd41848a110ff3e73bee6b9c92eca3f6324c80c4552152f2502272eec32b444f105672076746c9c4ef015cafce5cac2cdb42ccbf6d2f2771fe9ba7910460a93dfc54f23828ccc1e869cfaee4acd31cb16f42a097b0332426dd13c1e6a1e86cbef349aecfee3d744deb7a0c261d4455dcb5eb9816625c4ccd685565a946a496486c2a055910b6d1311e2f4ef940a522e6f2b0d7778700d97b4b9ead20a08dd81cbfa76ceda0860ea04e5f3eede4c08dee4a3f332e2253d6941e46e5694bd207306bc8a9bccf6d584ccf6f14d3aadf264b87aaa134011c0bbc7a78de0938baed5bc980e6eef8a525ca7c95ec33d8a89f74ed93741fbe127429b2b7d8e1f7bf8ee36206684548056ca4da9da23516c644218915f237ec643171e40d28393a4abad0aa4266191edd01af384347f95d011dc14932c91dcd656b90fc7e8d0a181b801f5e0698f13a1c38e9146a78bb90e981dfa0cdd224442ba10f4f878dd3d4708240221833ea17f11650ecbe733c286be303d85ac656b002d8f0f0b3e19cb2e55857f6424956bb5fa1dceac27d1f789617a4dfe4b7fb2e6d73c28d9bbb3b0a8a97b2999ef749e5a18ed02dfab888955b752b7c0efa1139c73be1842772007ffa37134aa45576f3c87065d003b18a3c8fd8d810fdecb9e39e03075fb3ca7940cfa259ff7188957b03e34ea9444dd9cacbc401eafb0218eb24b731249ab463ae15440d2d8c687635fdabdc070b26dee19cbaf8a2efa4786bd2f1bcd394bf95c37eb85effc9b40050a57d25fed07b16403aab5d6e72a4df09b62488cc4ad65dbccf30daa3baa9647567e05ab57682119e47cb1ba5e089ad12dbfe5d700cce77926c071e58afe35ca9b21640d85692c0613fffb39e57b50eb12ea64febf758e142e54b23a5aed601ea696f0734ead2ef9540d13846063d2f27a8fdb29d114c852af65d266933304db5e1ce67772bdcd7eb813d26e81ca68358fed9fcea69060b295386c8cc44cd78911264e2c99e95873752c955a9bd8b2b544c4fdf912d140d6c5a31d4a26281bc7c511b4ae06c32fc868d37befcab75e8586620a91beabe31afeff5f17e6ef0cf32f35715766341d666a0a5cce4d86668d96efe959e243cbdb9088b271f8933129e5d45d7b21337423cc3865b820f9b5794159d3c388b088135fe4f5c43be1f0717a434ca065ed33a726f5cb2471b167528da600a03acc65b80c7979e6622f5ec97e21c5d94310afb703eba1f6f40272b1ab1b77d772cf04ef9479619a950d872f0d33012018b18a892bd9b4c860de238e95051b8d9feeb5c6507d43ba8921abef1b8b5532b5a643e0b8470dffd8376d529ba9bf9e7eb9501acca25fa71c0de4a7c4cc845fd0e09c835dd43d75521fcc077326d871884c25c78149adae70c379b2988bba58cffe598dc6f7f50feeb373c967dd7c4597ee5232d4419783a0b862b603df954ab15557d8b8dd7d79b04ddc0f82c4f0a088a5a8d98b6af45d4ab9263ea0b266587f102708f72807a41c7fb13c8d0bad0d94281cb2218d7597a2cf4e0c0490cf5b96c24d13e22329cb330f410cd316511c910fc0062bbd345c4d30d56469bea9cafd6a0b9e324a7071a6c153f9b3f1e06482ba01344892776ac823f9ea3b7c365d7c1be4f04cd48c9ba3bbe67d37c0c518dcf1200be74e446cb877c3c5907300928428b1c77eb201156aa73415ea897ebe8b96d845eeefb0845631d983d6d565e707cf74fdab4f734e682a49312775c54cb6d35219e5125580b42017e4d011b7b3249acaec05bf4b9a08860998a6f3f3f808ff6aa109e95d549483b6c318926adf4b639ec202194e5a69ddff14a01364b82381440838f6179431cbc6c111e5efb0f6dc1e4742376fc2ccbc382463413de5fd8256077d9bf66b5d401ee132b42585de9d98f84f3631d61ef90fb98902dc1667dc4d11bf1c9de28c964e6d9648011408e6d38d71f92b8c9398abcd8c484e458354c7116eae4380cf0356cf0a273b634b858b1f74e924f3d9faf2ee282217c578cbe02e45f57152b4814c81139b9e456af45d79ccf6b6554e03fb1c7c79d8faf0e83597ff06434d4d3af2e80f6fce1c8097012c6ccec92d224f754149c4a50332adaf465a7c13bf33be0b6e44b416f6a7b3d82339a2e61e80b80dfbeb5871b94da483b484e17b02799d151f5d7075079fc1cf2d33b610d7b2c745c789495676383da527e4471cffa8b8088525d9e9a1c6cd5c68db775499199fca2ec067eeae1a04d0c7b5ae3a934e1eb49372f9d59b21fe158ccd39742544dece1dde8af42873791dd0d0b18075955c645f371c44464119128eab9b9b36020b68acb2387a7c9921b616138b66a196b6cdb3f597322a25c4502810aed93657c24b9260fcd89a0b9febb6bc9415d641a3ed459744f414dbf32900d901c1d26f900dc721fe209436656adc37df98b741adc162f710cbc877808a414b3287a261cbdc0f06e1d44d2439f4fac00e870bfee5d44f7c059de7b726d7bb3e5d1dd1e03e06e902fedddfb0dfa0ee58c4e65cc25d71da0556c946a392b714d83c7d3c17ae6b99cf9cbd6b833a758f4c1b204618e53a5d916eabe391ec620020372e92cab71d99c46f8cf1d97831fa08220a3e1722786db9ef9a9a8d491e91842b836453778f6f65cd41f52df552dff0c8e9645feed5f8247cb7aafc39d943ef6f71d4b6642c7abf59b70d283945d4dc9e72a7d2d70bf29c75ee6872fcf0e2078d90ce5058bd374ca5b1771be5a45a7c2f28709967f3097aa1ddf30824727189b0c4cbf5e1c1586a7aba74b62d6ff25011689bbc8bee64263b7ce1ec876df5cf9f6f7cec75ed02a6c7433883d87198962626472b7e055c108fcc9f65464be22fade4787327490692d0a460f4c2e033b0f4581fc8cc56500fe87e0c64691fc77f02ac1e0c3d6b4b939bbc9f6e62117ba4df141a37e8cc8e4fdcfc25e2ee5051e78d69dd3e1aec39b1ee935be9d756b52cc47a459f89b3d8e57d1eaa5221fcf7c8be22382a65d2a5d4fcfc3cfdeb4e6c5b405344f56e5bb2ffcd6aacd8f5603b6c43d6a1e024a0aa8315808439e13f34f1f06f8517a04792521949f5d5b06c44f7e58450790f47974c06c3746df087cef9700cd821f594120eb1359cb35caa794538ffa02fc546b1e30119f76e40d9bc1f22446d743160b7bf5fb53035b4260cce8b89838269abe54f104f09e814c4f81ede36cd51cb92f2da7067b89f700fcabd80f23d166bf08ba3e732a0a1635560a4034204ae1354d3e11202879a3937ba74233123bcadf6b1d7dbb0a443c0b353e51e1bce9c28c33c9e15df1c58a6e4bf4ded2f7cc3aa51f930c866e340e89aed365a2f5c74d7685bb6c03ffbf495a89227db4dcbcbba9dec8b6653d93f9ee0dbc1cb3c38fbd5f53fb0f5d84e9675beac101ada4fa5cf0c88df28e8ba30039bfc8120f0da518f8e70753477d5a3e6d2deecf07d51ab8b3fd8103216bbde9058e36b20bd743fc15cefa2e7587ec58de71eb692c3ba8bfc15952e8cdbe8584924349d6cc572afb95583d27f78bafd6558e2f7e08721aa64617b674e1a288563def27224d4dc5a62c7baf004c29acb60216e4fe6eb10b5551543284e686ebffc1f0c99880ac40084aa3fb7393a432babc041317d960bf7a9724daa19cddb4414469db240c5b42b1ea355be80ebcb7ff289da0bc66d99f8a95eab111f0c8216e0372894aa34df977384169c661f6b1c5c506c2447be03b89cea571c83c4fbb117db74950728f7fdcf83bc0e179dedab52bcae6c38e01f906e06a27bb6aa29ab748a1c210986e71dc472fb2f0de30493f3a7c25c6626e434880233749534546b9d4ba65cd7202e0f17f1b23123d8c4e4dab8e608c7e067cb2f59ed09010b1e88299447eba6377be7274f9b5b45f12714966cdec604af945c62de0aae4a9e3b3372f071d5507a154fb38aea61067c27da2b6324eee833f040cdee92e750313947294eeecbe1aec9d798e371d228872bfa06b076845505f2c4146d5979ef4dbb39a0b6e3619a88404501d521fb05a2432b63e8dda91d4a56dfce74d0514a6f581fd1b5780bd0790ca6e2375481e3daf5b7890853f752ee5f6128704eecbd8e7fb70be98b890881409667e0a59ff61648bb972063b45059f7104222d7101e89d1c6e22a6a1e39162a82f2a581ef2ee25b01d3f68ac414915bbb23f2eecce280e5e6538b58c603225b22ced0fe56103eab03994aad434b69479128b4cc6a88873bce60390efdc41d6e24a55a906ae0fae19285b8fe5b073ddedbe6f8344b81650092ba94db1a5cf6bc9f355b5a465adcefda722c80ecb331a91684e0b30799b43cf56ea8b683e7f736d15876137a92bd5b62463a08632fa06ac06c1bfbaf68e8d31871df7976abccb424ac933bcd22121f16470b58411342faa5449897079d93fc0e4682acfba5778be32e408536d4d95ae717e804d7d367cb479ce96ef422abd568a3fa27eb669e713159378f20b6b3a0da915029bff34022852550e1955a7d88e39546dd909cbde23a3f850fb9d28d66d2d361a59886f3ddd3e889127694414b0e1b1713aee53084dfa8db8bf411fd5f77eb9d88f8347ee255ec67d07c42e2d96801f865cf05f0413536e6e03afcdad6246380f868efb1df353964f2bf195e7e76dd25f9ca876075ec82fd2faa7708912923421176ec02d6868158bbd31e0fd229ae4e955f9d83f2712d175d60433ba02b04746e5fc17fd892837f013f945862961791da50d3d7a389beb1594da48a3b7d8fe85cfc006d143e54c40f06246b0ee007d1bdf3e277807987e1ab4d6abc9ed7e39aa49a93bdae7b94c33a1e1bf7bb3f33295708f12f60dc159c250dfdc499576fad2b48c50e7864cce65b2b9c68b3e4f7464ba5906e5c0105f321a9ddbf60457713b434cf054c421859fa31ff28a77dd0aa5922f1ad151b4ea6dacfff8969e57aad7e934113bf8789b1afc118dcfe68218c278d802333a4e6bf2633c4cedd07370fa0283713454d258143ed78360c55481644331077e5a7b7429d13570062604c42fc68caaeb88510f35057cb0576c899a8c8e4ff98f201f63614e44602ec98d31180c155c2c495c4c1207c50fca1fd1d612eeb0ba8a2e4b16864e5d0f105db254a9939b0acab09d7499c58c3452d1c6adc29e8d3f16828951c302a01ea402129b2d6e8a19233bf43a94e67a01d128f1a3d57f01941120ee33cc5a6d3db4489c6eb933dd120cb8276259efeb70d5285f64c6b4a2293da2b0db988d83f5dae9396d64885aa7bd00bc84ba259b48aeff4383d1e4cc8898c7a26b5643bfc1d9f2974c7217cfb2efdb8d50755a7b6df88787ad990cc6500836b84e5a7dc3d55324bee0915c151156d20ba1e982441845323ed088be7428f80dd0dbc20773c37d9ca711d0c65481e808448396e2cc1731891e919ea0ec6c09e3ae179ac97f1e06bd76504044677244857abd19f4d960fdc2b7f3ae43a5c7c310979692fac0998c86ea21333f04a9bff381a315734777f82fabf1c5a81376835dc0c9d3957225b07de6900d126713cc0645f44afe8b7e86386199a302effd3f490d28a2f75b85c262af9eca414e1527c866d9b67d1df9c5dec4d53caa745ba5107dc2427e4508be6d38a5e5c21b0f15c00842851c0ab87a1e589273d6681a866db839b600233d4d52b6d423290bf7b5d9485aa90bdd33807100b9de902909c86f6bf076beccc9bb373168ff7265b2d3ccfbd6c2d4c5cd6a4c26e52a81d347871ea8abff5b75ec141ede8ce8577f0810ed812c45d2fdcb46dba0878b5fa138139f84823034de4823e5e40508e0d7fa89e8751c0c173107398d0bfcb7c3b6a458bc921186dc227fd379ba7b6d407e6303d0e6908406f9c01f8cba2a4bdfb27e5547be0bff3bc9b17a5633a4285a0a150f1ef539297166b899656f6f06cb4a4536129df1dc4a83ccaf7a3b035bc8fee6081f7148379a4d4ffc074b0164a4f0916836a2bc2e443a89f43f51598250815072ee0308b57c1733974146c388230c92e639c51a4459ccf97c48a479e773ba9c56b22c064505ae6a607464d09857e4f615991fb0320114302eef13fc300dac4999daf8b1f84022a0b1274532810ff12a3021c5ffd2ba5c4a0c604517aa6e6dd0bad0cd10cd3f76e9cb1ee565d709111a92675c6d6ee2a81a0a1050f7b1abbab81a8dde2f3a8f1d12521e86a55dce0d76fe3213a89ab14f689edd1329095ff98034c9b33071f8d1f58193770d65fcf84c1dbe966184ec182e675b80d406cf41bff1c77051a07568cfc7f71f4193d846de0703ea350bf5f84fbf895b04701e691793e9400378087b31b3b76d5b87b5e21445b317df3d07c39e38b6caf3f52c8ea7585aa82331c209ffe45383faa8d467a05c2b01feb6af379b13e2bc59b70e634e59f214a03d68d7fe9d8b1c0fd4084403e23537084c2e0185cf6a03ce57d9f1fc19fefdbf685171ead28e4b3a02a90f0e686769d8ed9c1342e0a99cc3dc74405896f33ae91ae9533f07b71e05f1fbc02a2980fa3484f53e5197de302bfbb7d8842e244911fca858b52b683523ec620c088212c4134411bb2c14eabd1ac161748c703b30fe168c0431a95fec3e3d8fe10f7012e98fe9a65ce3a2d287dc617d4e867ec1a929b7d8c4642df6e299248d31b323d628599c20bd5596dfac2280400646e44efe094ff8b0c7d594cc0a09248ed5d2cd30bcd794769e54d61f7586c0fac6b58ad2833bb985359046306846b69b5b9a40cdd9884d582a5b02ee51111c946a20f8703eda8a4cc40d82fd31a7927a57e39903e797b58a94b6dad9390defd269a1cd41906160cf221f1eb901365d608e146838740959b87e0e6b5b0ddc8f85037fcde53c78663b3e017a338435a7b9a48bc58e8e7e89fd6881f5055e8d4722a99daeaabf762cf48deff6daf3bc53a46e7d1156ebce147e268c9e896017af9c7db7edbe1817cc123978b772d24e7891db77724c706a30f1e594469625d6b97dcd2a58fe406b855b329541b0604c986ecf762812381c869fb0ab127c2756fefdca623306bf31249e011de74b11f973c5a1aead8b000009370480719a43eba8bc265cce7d3d9d53156affd000e3a95dc83a5f37964e7f716888ddd5317bcc55302c06aeb26cae15c3cb78351575592e987b4efd59e9226d6b9d0be59d60c9bcf044be1bd29f666f38b49adbca9844c783f188881b5b7912334cf6e652c9a3338954f3566a4efd1fdbb1d8d6abc197c30dc9b1d59de17596724fa84c38fe6a307bc177090d54d3861d50fa94bdeb7b46a975100a7eaf44285e94d1df539250bf8004637602e7049ca632e7bf3e3b55b43704613b46789695fc33b5271cb0f2ecc946998582540fd29da179e3cf3560d98f96d902d1c47bb4c57657e0d7b9fbab871148106b5161fd8fed0c11e4d166da970181fb7987a28d9f458d096695eab5955858d2103436d754ada6ddb11a86f163e97cb4c07b88ed29e6b1b1feeccc4202c8bc4697c70e1f765a979230ba1e49b53d9d124532ccf73877f4e243290261a3f01c5dc684f46440b19e88de99219b65ecf34130aee18c195fa93e36e7f09ff1820c68bbe03bdac246634f172ae5974576923ed503ae234abd207b3400d317883b5b1f5d53f21e4cf485a51611d36df7af57a452333e5bc5b19efffbffaee6de93b74a9a1f878674703c2a5f686b6df8d0793c7c2c986406b2fb4e5fa21b70b29bc3c74f72a36e6b06ba8dc5120f669fe42f03a3b4c6b4e9b41f40d4d862744473c84cb32834de0b80c2f8884e5359b8cb8f213336dfc978a7398241a2b84466fdef3c8382ed47e1856dd28ad0e5cee818a1fa38d7789d748dc7feac8734cd9d218cf1bf7f12b200cb93f9fd40c91fa070b0d5175bf610103542e863cff3121a8c52169c814ad06bb8ff688bb55cdf472a0b306ceb42fb16acbf1191de406bc45f7d911164324bc176adf52039ccd78b1aa781204beaee6531ceff7faf51b50b58593d5ec2486a196ba7cbaf2f04af0e150f8b2bf551dbb3da5a35147f8915c0cc53e36baa5cb98b070906f3c61e549dc540308e0d2bb308b6cada5ef7559b797327bb9034c46abe2a6031698ba9728bf8b1fa02887c02600534fe9acaa828f88b98e73f3a2023e0986dd4d773c5481b62e8ac2c2e230ec1063c964dd95dd07e9c6dff9c23d153a52a8f1a64c40a172f92eae6155639307f694bc0c39af4e2a13c861d6e4f04bc0d7ad4d3948a0b5db64531f27f5964b1e954b39a2417f3a3f83f85b0b59fcf6cfe02f9dc2ee44e93177150519d630eee5028f3f569bdb847a3b243d5ea7b501219eef45ab286f13f9f575b52bdde53f8853f7cc5ab459b68a096e91e5befa90e9d23c45486629e9b6ad80d581e75356db8fb9b5d91ae1368333b9e23b6555b849ba0ad1467809468c2f5b4b0f8b48c1b03ba60dde23f64d256ae5c4f00c475a0105dffc534ad840d549c3fb6260a92a0268a32428fab07720e248712bd48a5b8eeb6d6657d91ebe773e63c40ac207bbb2fed1120b3f855e51a4d72f7cb7ad4da4d7b494cf4c56b5b2a39c199879566fec4716ce1b1a198da72f33f1236001bd47966db5cf58f76d9f1ae2c0123f972194c14972a6e04f7e8fab3c893edc8f499246086e40d66177b5833d21e3acd27485f7d5ce54fc527b227d15e7ff0fbe3508f6e41997893041bec8e00cf046520e02c657cc7c9814733c3c7d6db814886c846f8b903c94f2b327e32d1902debcd6fe60f55ef5427d0770225edc4f8a8170e42e30a51f6873f55ee2d48dcb79ed72495851bbd56b41435b829e441aa579bd27c25d2ebbfe2ec2f51543895976161317527f69208254fecfc002af322b0a2249a51ec7e0c95bbd10f31f11b89508dc723d14c18038060b88ad56cf3b0ae39fc9da2d8de8cb068f0a2fbbb12934ed37c0a83e81300956656d7754e24435473c4aacda202f7569c56bd0b692fc7eaf366d1823094fd1646f2f42abf41dd459f51cfb78ed04a33408cfdff7a9d5576623832ed1a6e8bd0ee6eee91c3f9aec0c597b19d5c3ac5407b71ea723f2b442e22031861e59bfbbf1cd30e27797323d9e84fc72e5041df4c366c9a278549835b5264692cadb5d110ddfa39a2fa21f6732fd969bbefaf99a5c9e4ca78a7fb59c04b1f17b04bb4b00c4bd93f6e91c41298d0cd9334574744da370d7d9e951e5f8763b69f0c6fda891bf229bdcdef3cf1ebf3870b43dbdd0fc45cc00ce234df328d524f9c36cfa883209ea24f3a6edd954d62c93836e2be3ce387f0708136c56869b61fcd521be52fd6b721e5221d9e06477c71d972a29420bacbc7bf28e1cf073fd4c1111a2be4cf3635e2345fabc6f462c4b2bbc29fab32e984ac936b754d25f52fe7839501b5c0bc1b58b7f7397bd2345f94ed51a2561183cc0b1e130fef92f2e33c04c9d8f75646b6171ff4bf171f6b8c43dd435a240b3fcdf54334c42f9bf0a43e9eed263c7f24cca3131a4bfb5963832234901a80b62a6e1e1d0d186aba252647708ea5bea32831154e423742adca13b493246ff7739ec82edcd2c771da6d31ee7f3371eda4d94e86aeefcdf3aaffe7bc51eea57fc426c13e0f95b322736a8213e381f0a89ae8a9e2cc3e5ec5786683f77e328a1de51c007aeefc306c1d4afaf17f86a50e59f8905aca2f86ed69e772d4476615694946d181a12e2e4dbc86c37b91eeeb44d23679f3b048aa4bc0a348d0a4e99477db9db82994d53f1c79847fa09ced47c5e673dfe170dc9cd88adde04c35f46b98a0c5613f99efa7afabc452a8f3860f4da5c16ea2e3b6541743f80ad05842f19ad35f87278db7c24e1a3230e3c897cf9c8b1199778cf74983667f15cc9dd523bc6760c57e89cccf60e84cd031ec02a0f1262","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
