<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ad93a7bbc62a70de96da33fc3398480762e74fce194f03f3f3c4989e52529b1f8215c3fad351c02f5a7dd54e92ef6d6cd7cf800ed1260be07347a40b5667c04f26b3afede1f9094df8dcab4db36c3cc6234fa410f8594b779947176ed6f220d95d9e3e7a42a8ba8f108f912277e6e7d9ab69dea170f31ffb1c418eed6cf85e38292de3e0e439ade73291b47b9605f4c4c906cda55f657154203512e139a81aa05aa16bf70edbe1da5b1afd4a595ba43f8b060f6e9f55c33246910e0d0a2511af458ec5605ec0c28ba3f8c5917e1c8e4d77e2f4c90c7df0336a9276411b6acf20701f08b96d9a52d9df14a421ebf68f0ad9554e00ad25e053f62bc3094aa80062132331949615b198d7b447711b5ca30eb24e5d82a7612868a827784e84a5ffeef4fc6e596cf4949271120a53d63e43310ccb46699758d29e13aafb3c129d214ef8183a6df8d0eae1341ecbb74ce1a71326047c0349ba1b2190300ee3933fb8c03be5d14f7afefdb8fa3cfcc95fc15366148d7f071137b0ff2a3c1b245ac77f04d2658770f31cc3fe475844bcd5b268f61f8f04fd2bb58b934bcb08a2c038c857012c94759b6d516eda101d39d6ce271bb68eb55fc8d75dcbed796726457ca952fb3ab2a7e3d7215309f30bdbddcaa409864761c8031882a86d1d6decd2fb16da3e029156564f64e97d59268ec31c7995ab16cc3e209a230bf34ca546c0f99eeddbd8e4e4b268aad1063a1ae937633f61c20cf6150c35ad2e87cacdcf6b1aa680dcfce58fbcd6a88d828183aafd7c97463adab4cc395d508dd7a0aa7c04f1c33f416b51d7cd430d122c80883bec105450d1433c64521b879f4313b9c50fe500bee50a3ccbf82c673b27d7f17be02fc0ab1b5860530827492181cc6a4840eb6deb4ad61a9f13e97d628dd7892964563a9a008f1b33fb606d09f195e396c78dbc4e0924ab446e5776d8f761925316cd9a63c66aa2e33e778541d2e9697a058f0f7b4c7370d03c899f9747ec8458d120c5cc6802b05c8e0a353a1b179a266c2e3ceeab3c8207367cee4acc21a9947e33b6c6dbd83cc07a68005d1e818d2f7eef9a217b4fb788ad11bf42b61daf01e418b87f664d87b04ef09bc5a3f619303d80cb2cafa062f32dea1022246d24085e6df6b22eb164cdf84686e8560d172490bd1ec83e61d75a28809b114eba8658e87a871c2a7f4d8579b8c291252a427aa0b389fc0b89b317f6d2631b5f04bd84d28ebdf942933df02681f3dd74120ae780717c7c5abaa061deba60bce47d35acfaa7ba0981654dae59242c4b1aebf41fab0545dc5866587c9b3d9f88f334ec1e9d0c2d58483ff77718d4c5a340626c0a55533d62e927e28fae00a722a5a4d3a3638eeaf0e6d962082aae388c68190b1440234c9971b24f59734eec3d806ae99b45853f5c88ccee7e78331c63bb26bf759e1a9375b75e33b495e33cde7936cc85763208d0a71072a6d7215f06916ef11f0cdaa6fae4e39e7e73ea6e90fc7426dfddba9412f864ff12c1239437249032af8552a60664445267e15bbdf4f5f7f530c16f7929e9eef90b180965521c43dc28caa29d3aed5fb6887a5ac01a5e4c3985c83d829c2017255868c787bfb8dab5dcb164af61ecfd44cd726f0065dccb3cd3e47fa817a10b99c59ac48433d490c3fafedf1d8efcd12b8c7ae2de131fcc7be46a24c421856e24e3002e972f461d4bdfd09e0fc62eb6111834cc9e51f8bc5549ffe56c0e436bb58cd26e63c273589323772c01e83c0e518dfbdadfb5f100138f609d46f669c7a3dfefd866575c71c34763bcfdf22c8c65df7725815a6cda37402f8d828f138a7fe27a3db08d4df84bc1c5f9ea47ed550791d4b12a265b1af97e1384989efbf572fa57dc22d9546e26f3d5ad72b7c517384c2e84f5761a00d2a8045c97377d27d768e53815b060dff66d03fa771a06e354a05c42a76c429f5ca0e0d6bcc4b082e966d34f73a2924c73890b7a5a79456679c64f5d5c39cdfd22dc0b6d92a05a43baa4c2afd84eadd5556ab13b0a9a85211909400883c96af95cc8707f46fab4141b57caf0c827cc05b090303a7da7d8a6448f0490f7c0c549855734bdd3c5defd17308600ae289369c339be1dab8957bd108a8d7c10f83bb3a39d3efe4d24ec1eaee40d5f6fe96582777182fd019316cddabe09035117d4cf1b4899f40fa58caa77fb93b8b02aec688729934c629e3d2b6375cc2157ee995049cee460dcbfcc0ca1895ffcc57e68d25b11bb11107eacf95a6065fce894bb8b5e60e018eb102ea128b5cc72c2046b7493c8c75d2fb480119a66af2d72ecc780c7481bf707d53a71a949b0e10d359eb0aadac57093e02f046289fff0ecd6d050066cc31e2a37f569cc9e770838791e64f742be346426a0c43721d16910ced1190edee1d0aaa31e916fcafc499a9856ea699c8c6d096fb0d76125a6b4200711ccca1d9397e86bf8c660303bc9b44cd4a6809557371ccb4767e269a55f6db0370752e2e7d4f9ac216b66885b3c4da78afc96d3aed55cc4823f1b31c65abb9771a1f7bc920b5d2a3a1c1ea0534760b377da1c539257d64aed0ed5c1b96fead8f3d5ae0207a6ab3dd8e4f9a02dbe3e73546477ee45e2457abde7b18650eb70b15fbbfd7faa5cff2901f0eaee68cca59272edd211979a7965809e1e6b2af7c422636da3c724f0d1b5d7275611bc8db340db1e8be20defb039f5a54a28cc0c8420311e72c7ffe21ffbb394a66ecaa2666c41fb2b39e22d51149b3991ee72954c025057b2e0589d4ca10cf0b5d57a685a12c345abc9c1f413edc5c643dc794430bfda89dc4639719b294115f05805bb6fe329f7cb5fcb2d694fe7214ab341d619e61aec69d02a1ad2818fe9e24553222325035aeb24acbaabc9e0f8e203ab9de3824790a57f3e342a82a2cc5b149d1a0b83ab0f5bf24d65b22b9f800093c74fdafd68fdeaa7b374bf273b0ba18946aad34d7c8c85a4d215cb9a5dc6af64cefacf13816557521d91d13fba0249e2d2f98c70cba3edc95a343d2ddbaae57c9a54a148991e09ee5fb5f19f15421613e18d6b9eafddb726d6ded7ebf2c360da6bb3ef2d185d9d054a46455c26d66bcb0e104c8a4049485c0d2656435da110c335d3a31e64e0c04fd3bcb83a8c413990d53b0e8d66c5085ee257a268aa26a873b29cf6b985c761ef9cf744221f2d676f73aa293858916dcd0af886d93a186eb50d658ace289af0de792c1d908d3fda76687ddbd34a1029432ad32a4b883f183595642df1222e1259913e3958f91986bd6fb20a87217db84b2e9cb41ade2e14711ba5d17d9f2f8a940ccf4c57ad6e2507799c32beefb240be4e5dbd9b3fb829e9a9d8743aff53d0a231e9ee6a344b08ef5f18c2d2f33467ba08cfac358366f6354b20a8cb3519f82ef0a4fca9f02f1a81938a8656f3ad801fa8a23752f6f2f2d435aab0b76521a590042b9b11a6d54a54aea9fc0f40ba58221971752aa24dd0aa35bbe81216450c1dd945ecfbdbb00b888cda0eabb9508e1c5e148cb60052264e6ee45fbd7ac81be9ac6fc3ef2f10e37ef71396a0e5ed2ea014c1499361850f763b4a7212db18cc53fc5f58a228c01b3c581962fee1f1f053213e431f28d102de23864794fd596d00dccd26c79032f74e5c399997333e0030838da7022bc68147b489bf2bcbc67250ea8c783364aff1a333a2890782a0c9a7e9c0b434f995e55fc874e67a114b2d000addb032b5572a7752f60d0eeb518e934d6ee140a9e04644bc627ffa1930173939e62e90de02bc42c59596fb9697f00fb1f2c25ec85f107d8c92be385472bfd4493b85cacef194abb4bb2c5c93b0e2d3a7eb9c43408143a6eb03db5a206ee8b26200ea76047038340d2b858875c1615570f44a31a21975b1da89ee8595e3f5c6a3ebe44ac5639d96220756493bcdd7fff1db987a7d42edebbb203e817501578f4c9f9ba2b95b697d01a5cbea29fff4b52fabe50cd402a4ef3c59f712a9081909a38d4d3238ead6523c531eb32b8ba01738ce5d135e8abd98027619b21a111c149225a7c44ea88946e837783dc30243772498fa80f75a0347e12f3afd952bb25c32ce1d9b833acf0d66d5d67d7677bfaec70a9dbb9c3c9a85146e2074834b7b641e242aeba18afd639f27280c8495d8f99c1e5cb99d60467b6af726153631d0291826e5cd14b01cac510dfd20c86b29d290afd23cc7f609058365201932b0ec24abac350126a456519502f0159b7fc72cfef116cd6a4a6ad3ee5dce9f794487e3a4639e56454b32e2c4a09ed3a2ce5fb4a6c67a90aff239022670445a10ee6e484cf3e7e96c7f405be8bc899ee3b641c262810676b1b91e93bc82b2f409a0619abbdce1d504382107cb2cc8b644fc5aa1eafde9c12bdf31763ac352c5c96c81c60cb73f2f241bb22badd7d0745f045516c6fc8e04cfa40bf046ddd0c1265a191a47a832b44d8e4f5f8323c90e3b1f97893c8e0980aa604f06184ed14d80a1ce5d0a1d6b68e73a800ed62532dc5a28b72f053a84bf43cee66aa23883da9bd973d8435339b589b8f57209843a5c4bc0a3251a40c23e8018c46f81735a344a553def1e06759b8ae51509d432c48dc17628415c27abefe1a8b903a94f39a19dc65c851d76b20296dd3519b8e0ca2b5b56f4ad1b7d937d8352e1810f8406ad29bc5895f8cb4024db32b82af3d4fa1c13cbbd54dc98e417b419b37f95ca22ff54a3073ed3f4c7e3515701115e0ed1826689088d9d5eb36b13eeb4b1f5ee67cc02de33916443d2ffd15d242a4fb21c46226c387e4c02f1b9bcb87344ae2ce7a6f84db2ddaae85333a404e70eeb7389bff8ee8e7034f7abcff1c8c1c456565c29dff6831f06acef485445c8600d51a44220e6df7338fb8980d53e8052711ea7d5aba811d81f417535cb93d0463d2006133ac0b5b2ac935c49736a7db6d1b2bf58caaef9d0c15f5f2e15a927d8bebc699299af32f63ce482e716736b30326eaff068f73637cbd94af309267d3f061dbc65e3d8582132d36348ab806d2704c2004573854c730204c07b578075e0bd4a69cac8645ac9cf95b88f047be1a15de5f96ce1bc2a0180691dff76b6ba65a4277aca0120cca4ca69b8f4a5b103c8840dc9a5fbba9ca7f0f3824bee422e190fa917353c5778fcb1f4929e5225b22d12bd8e61371108cccd1aba2d4d04ea68a99106f02d6de3e784b8a1af03edf10cf6c8b8dbd00026aadaff7b14e8be9e7478ba12d70a860d31251ec2bfa20d901a7f753e3899b08e9729b2ce658dc1a560d236c88473d71c62d3a209587e73f54d3ed891aabd2672032ee76f9954d6612019e969234831afa45809a31713186b6277c5968a81040a0cb4f6e8aa4424474f8b9e19521ac05227f17ab33abb2bc1729c4cae99f0baaeaee46fa7bd60f55b418f192ec8275c02ed123783de157f0ad59278bd942d0b1cca9e84dc5e3dff524c3a9960001c1f9b5cdaabe9c3d58519d71b3203bb6088f77086aaecf5253327f251aae57407ddd25371ac7ea09b42ea63b87293b4d6c53e8b07dd9e8a1f4cb5c806f08ff78b8ee95d615d2af2bf689c9c9fa9abc4acd579635206144df58af01e98e96fcbb83ba961cc6d77ab1ef438c674a6f7673dbe755a7ac92c6b91dae7a5020a267ad89cfa6e55b079bd4b74801aaf18ddaccc41a63a69ca8b0e4d2eba282552d655366b87f637e743567afd865877f1b77317e70fed1d8845aab1eb6d0ae14c116c3204d22f0f54c71a009a3c760fe7437386778ddec2ef6631892cd2b34e22889244a42825ed33ea43511d672e8bf0f95db826cb2ed62ce13f15a120bb1726a6d1fbb5b979c82041cb6ccfcc99ec4233352508ff7f99626cc7fd3447f2cbc99b04ebfb797a6e9c905ce14bb149237e96434eaca3bbfad17c8b009ca51893f54d34ea7606d71c3ece4b0f9d761898d1d1e9cdf90242c243930e09a1caf70ca3c7897d4a1aa21692b25d7cd9b183e68f1e6d790436ff44aefebe1f35931e965a0b7408dba1badadc2dfad8e15ef5d710d0cadaf2e1ca53fd792aebd7a04e14671f27e3900a26f89dab438d09ec12de300643e436d228e235ae992ee44d967bf41f8e37403b043c655a6cd3c82074374f8a237de233458d4fac278ac3f72bc6e119b0545d321f67ff6855dfb451def3e42facb4e027daf5a051f1755f9ccac3b2f42eeab5cb342af24c79a7ff9e64019c2f920ea5ded42096cf88400041dffe843a09b867e4fb243da9cd8916a4cf4316721cd8c9d6f2ec36ed95a6156d91f6865f238b9e73c00ff7ddf5c0e9bc102026dfa05fc959380a120c128b8d68915a44fed273b2deb85af65db4b67041e8459f42dd09e7ed461dfd4c0ce6837dceceb9c2caa25c5c18b109c11cd5c6e1bdd7702558b03f20b61b428b4d9e54fccb13887a11516b76de156e79487319a662c85cd9d1ee797669e26a0ab4952200ffe3a49a09bee14521a286588e4983c39d09265a78fe4fbe2fc0ef332013654d73efd471ee93c5edf55da4842ef447d1cc2da85870db475f80cf14df1b741a0c721ed87e45986b50d22ae73e9a5d1b6db78ca6a72752464d7cfd4f5f26d89e570aceab5053fc9f66dcc6bb9f2f8fb6f0ed4f296ddcd24676205e25e134e851275f42eeecbc9ae095c86d4e76c3a6b58918e5997f0b188871a74ded5c60b0384150404f55baf144def484a4a28771dcbb32010bba5736db499a6809686d24c9b33bc95e9175de1d48aefaf0a140ec9895e08fa8d61b66e9228dbd3aeff694a89505299dc79f95674eee4362b2bfd676a8c1e0ea31e56525e5939e9712e27e93581b8ef86ae3cf221c1c05c3de5740f3a17695db93e247112a270bb20043df553a2d15e370b9152e6585b709148702ba25e3a40183e7b51a20ce768dab5a8cdb171454758a31c4cf0338f0ac07d7e8fd746a0b467b27650b296d02bb5bf8603104638e5724d8bd4e974afa7f6f24ca50e8e143149634144252f45d35d26584dd6fdc320316cf93a3ecd4583d0fcceeba5355280b1e9834ca440e5478dab7a694e39cf406ff755b57e38067111acbd282bedbc457c88f7bd249d6e8962391147a39dc8ba2869e54d9a88bcb308cba2c4cc2285985858bc62af14c5dab042bc88be2768aa06ca991e5565359af62de3b31db7cf880382b050e20926c0df2e39c5560bfe0e786be3e9a7e712b922626c8d1c9aa0d219811d03991f6148f8aefd2d7f787a03603a235a8eefa1b72fe34b79160c3552350a66941c02d47160e648f437922cd22fa969175f1ceb8005495ee957f22d42fb987174a1b60c3f9ce03c0439f288d5570efdfa7f586ba555b065c3b77650d607829f2da845365c7de7bc62790612a162d61cdb97ee17f1cc62751c752058a12b2577dd789d358623072ec687b801429c36d3b9081a430a0eaf808869ed66d6af9e553f58fe9e4485707747890c2f508970d249264e7d8a2b854d644744daf373cdc26fa9e066e1fdc127f18df6849c662da3ebaddf27b2f7ed744ea19ab92fa7196a3d3281c88c6e75ccdf3dab7d1b2805d13016667713502ee39bbc4c5e042f5ceb06d2cda081f1d2e682634a15f857906f1851c643ad589fcc81822057df57d44e6e99c0b18b5f780fd51b616770805fa69330211eae89582f427507a0db710a4a92c1598b04b02e3e76f3f7b1e3b269b5ef23d5c9f6371a034d6584f3d0dd1077e62720d2335f3f2b481ca9974a5b12af231dda8669fefa6b552990054e6224630fdff634a50d122cf6b1c09a34ea8bef26c1898dd099b73a0c9e7d15acb680b466eac7808b6e3c20eb40ff5ac14e98f2ea67194dc207c2bacd197081ea6b7628a414fa69722fd02428a9f40870360726f19fdabdcab8594b3c0bb7d420ada261bcdb81c14d8f5588298323e51b67c18c74cee301290b22f3951ae40b4e87654a657e0ce3bd8c4df0fc410238e5339ec122bda745a33a0b645d579ab96d8ba8bb20e6b8a51ab696df0d68f523e764a252d9b3915dce67c0536bd61d31a0022003f4c87594cc26c2e0dc2b611fb35f1715feb0dc69e6691045233ed938abbcccd97aada342961bd15673ed76111b01ab75abbc6c24547e55db4db4d465653fce5ea867d5dceff6966c54afea9ffe6b00b4c8706f614b0bdb2a462f7b6485e337176640c83e13f6935af45413f3c38a009371b57f1f39bb6d235c943ca75e91e549aa007c158f793de3218ac0e43d237cc305cc3c09744888c6d742ff14a0d8badb7c77e8de4cbe796ba2eeff4ef23254f23f990e57d572b59208afa7b0df1bf7d74add9c93d9f6df97f482b686d5205837cfad2cc88e2f39aa8b69dcda5a3cef51d1e6a0b443d13debf7fa8ede886aede6fd1473bcfda62786e82a2d763b0852c491c8bf3eb057c0ad438ea295eec6979ef0b08499a0d14295d50e7aa24c642fba21169101c31537cc95b3953d2332a1eedbbff7042f8b191a875afd56f07cf7547ac3d8d6023abe6c15a6dfd1640845e991bfe92ed8e890f84dcd11f22b4057962346e39663215f1997cfa6d87250007f73bdbd4aa540d2aab4585caab8749350f51eee0f425fc27294fbb8f5d227e2ac830216d09678624614d7e6cd18b134696608ea4ec3007f8d49567200113b0082a6226e85b16b7fe0797cc5541f21992153e50840179160641708d8bd79b0275c35d2e33c5afb918d3ad811dc81b1a5b78c18d62a2132dc44fe10d83822d3fe3a001881e79b5a9592982a323845bc0d1341bd48705accc0e41726b08b0f73210ea2e6e25f0a51b510a4f3a5fa5600dcec6bebac988db3af89e42dd1c7fcff5843ba6358d75f44ed116229d9696333ffcddf9fa163e02c131965104707f702fc4a5e128bd75b2f5fec9bb8eeedd59428b537bc6e93f504fad16f01a77d56555b3fede81cd133778d4255441a112966ce219df6660fa2e171c26ae98f785b7a1274c82b18b4a92826b132172c5d945555ea64ee20b77b7e7d22f86d1653cc6e12cf6572f2b6324456f4532810e837ff079d1259a665cc143fae085bb47690d6b6a5d4beebf0188281e43060c55c9430648362da92db6ec9a985d289ae2773a7296a3110001ba454f5af709e758816a881b800db17f5426048c48d1318d28bafb1fa8bbd1423002910e5c58fa4c02ebc7930b1a8da98059a64a4cda07d16b258b9243597954b86dfdc7e4bacb5499adb321c9494acb1c476e9345421d664ebbca1bbafd46d393099af51997def650ceeb9df1a07d3cfd3e1bc664484d44c2712911eea3ae49b97941598426ceccf64c8a8416b6ed8ced12fd7c6d0aadf48c8354748dab3ba59c2546269210442c3dc76cce4d67f44c27ccad834e80cf8f90465ec2acee8b63465001e23be353d9be8c32f6f0ff8860fb3871fb283dcbfcd765be9e376ddeaab094ba38219686b6f7899c3db38c87a5fbcd3de48719c28eaf63ca0947b87e7ad0f7d13beaa7947b7797d3dbb96c9b3f8d69501e5b48b38341ffe683b2e93cdcd38563c364f5c814467e5e5a4f6f2ad7aaf3996e2f69a0427875d532517e1600a4933463898892788fbf93e966a8fa1903a25afb56c08920a4378a4996fe11d8158d4cdabe2a54eebdd9f4c88a5b23fda251bad06335cd27d1bbeb343bd59d19199e14ddee5ac3ab1d9be137e5c0300a29683f0611844ee51b5178f7fba00cd5678065a6712ad6c997461768e511fdc986f407de1fd12160fe24eba4ed7116503101017a9171d35c4461921732c3fc34cdedaaaf63aa5ea099d27bfe397a09e5206b998b9a99b3ab07c66a50124c15ddeca57e9828828ae2fd76dfe0da46c199ef60097a50c32b03c1b5fbe0806739f14b1344d08127aae92d7a62c3cc781a830333136f1d93e4ce6925bac0f3e4e2a6d02cab10ce9dd7ac01355a0cdb95fa3ccdab2f14b75e89714c8860aabd0dc3670f97ef06981e2080426229791fb3b6a354b17423f91ef8f22c343a0c0f52f2ec87f41fad469949c9b2b2fd669dddb730c4f6c26bbd25c736901b73d604741d2327f31cab81976ed2d50d2760264765c05c947af943837400b06718cc75173f9d2185dd1b0454582ac64cfb11c2ed18876144f840a8788cb8ab225f0eeb66c7a141158cd59587b854e6c6d1db77cefe9671d81958eb251a1271f5430441248bc14056e828d18c6148a70d0bc9226072003a25bc1533502c17cbf98e9832fae1447870ccdaee43898dae86cf158a30a299ce0de197bcbbf8fec2789226f365c04e74c8b56980b4e99c405306cbcd3a9e5a2a01cdf5b7843f965b0a1c21034d700e738185e367533710046d8785c738a0cd5ffd107c5774e3eb03cfc479ae7855708b3a8c3e7ac2b09018497bfe9d9d6468417f5f687ef9a289b4ca4b9e4d47186824cc422637ba1a9fc3063391d28c615a4da8edfd502b8baf85a50cb7d05fef9ff81165b3e4c9b3ab16a63490d9d11d42a452d419b74b54de6a5a38bac2201044953925b11723202d466ae30de5f6b2c8cc23e3d8b09aa6e218aae051e6d2f4e4eb9d3c9d996f80099f0f9f0b7e5db82587276655e048690e48e1cb46c609160789998f899992a3ed2ba7eb687b4166b205286688a5df607194bd536db5b2fd04a17644faf6f7971bc1f3b480c1a55c13b91fdbbda8b49903556b46f35f848da9f20ce4ab8db2d312884f27936ec18e49a126d4c3bb23b89413c9b3821229ea25e0289be438069a048760b8262ba7a12899975fa83166df548d533fa0737cd106b066acd918ef225118f2028e85df02a209401d4c3eca82648d53c081ea5edb3e099e049bf4e1a7be1d4b027ab5ad2a82646d5893963ddeb37cddd8c0446eafe253d8224d17e4de625e330cc2199817f607d5081c36435fd6941eb647b9298d09541dab1b9f82525d30e0ad9deb450ef77a6707ca7ec110bb89753bfeea6796fb861c497879ac5b7abf5186d47d97b524a2f6089263d8d2fafb7a6573fb2a9d7aca9d9182a19c56a7019a9d3d3a5c50504b2be4ea9e1ab2438d6fb503011e3eb4b196f7b004c861284fb525b8c162321fca1b87154ed9bec01a60960ff99aec73154c0aaa0c17ec8c1634db4b0e3df054c01b2c5d19e7aa2d515e737b29b969cd03ee6d41ee487b4d52ea2db6dc460297f393b34d618a3a9c5fffc943ed9e410fb0441de66e173e999c5e196cbc25f2e2954c8ab1632027f295ad5cf0ae91b055ede683009639ea5f82fa2dee2f1a6b4188f99791d7f0e756e5be410d7021fabc0af1cfe4c5c6a35a3ff75b9ee53376f7e8a4b082b4ba3245098b149509fd2541259505648effa07e920027e42f5868b51a246f902df7e773b89d5a18af970cfc6aeee45c35306819cb0079b75756b295d36c0cecc036d073b344e63cb46c97465e23940997b36b185e442d0c4ef105773595b470c3ee293cd9b6ea420a26e3ec8a5a425243a7a0cd76967c20555bcf7385beb3bb2b99746f773dd48879236c9b9fbf9a7d89dad64404e24e4cf7c47b2a6d86fedf7f497f67ff2389bd0122667af14e57f5895a9452f05f089230ec775f2967cba91418fe5b8dcf0ce5bd89eec55c5eb0fbd7d3440d09997f59027c6a2f4856722c4dd319a0ca856026fdf2bcbd05561beb3978cdff8f4800c7afe7e0badc7bc4530534a52363726d2387ea4f3f74aa5972dbb54c9a26770b58f1caf343843b83c89d66446f0d092bfe9802ae6ae1d5e545fa0c82e6a9fd561395b0dd9689f11b3a201ef93fa93742d639968ee6ceba4f4ae559559fe46a8ff9daab460d1460589ba81a78c343b23737bc03d9a919f272f87946c4a66ac5e53ef74c072a950d60d3f68540c7a4f7b0d670b23db1178999d8cc808862ed6a581e92cc8332a30a50ad7e4920f1e1282dd33e1699d0ea702f456f2ca2feb6cb1d07ada83467bf7c05e1601db713599558b654d11172ead9127ca38437371dd090f377459f4c46ef19d5ab391477f293c1d69e020f727eb47a44e5ca1dd38f836e609bc5478197866b863bfa7771acd9028b806f5605b81847adc418a2521a597e527a8416c254b65328a30771b5168ef771a58ff57ffc820ae37832a8d907f4e04cad0a1640a7411d36e960e81cb0d60dd2dea22e8266edc13e7f78dc314a0059bac1f31551dcedb8ebcd577aa5427ba3085fd48a901500f851b77f6a58a68fc7d731d92d262474b539ab31d64910cdfb5924b4e10a9991789ffa03cd7084f3b10f9c0ef2d2fced21dd25b0a429ef570907264c66935df12dc9d23bd51e38ea1d67746437ec9c853cfeca07d3f9c3fb9837cc92c470aceaff946acb35cb67ac943c2611e42622bded1bb6542dd87ba383223c9df696320d2853886abbac5125114b7773fb88ca25b4ace726899e6961c2872b6119991d5cd25f3c41b35107292a6d555abb7082fe8ee1c12d4b220b4ffb1ee16378ef555f8672389a27d6a9b7cc29d18a0c6f166ee1ad4021e23507115755293f42855d3890285e19293aab1f141378ad08db56728ae5473932c573c49f3e977ce345c0e9a2366abb05ef9d7a5eeb33100b58b1c15f3b93455666ebe569cd10c156508c9553b5d28bcdd5ca1f177c96dbff92e4c7989c3cdbc1566289804ec6ab1b9a8695e21a6c0b11d38195bb50c58f944bcfdf6ce95c9fd7e916fb144ebab4fc70659d41dd6411ea5ebc6bdc8fc199068e4a3624d587bcba3b4821e0dd1588908f333687f50d85fb13e0d54c5922cd582d022a3d549b4485776aca932514e3edc7e31e44003f9f902d62f17c3e63c694b030bdf451a9f2776ec49964d16286df699aee27e63a11aee2c589caea2c40f2a06daa46e55c6d28ebd766e1feda9ef8a9689dda239880f25120905f3db402a6ebf531fb7ac93b4daf7f813d29e3d732e423d51a07d4ce5bf40ebca958f0ee9e513a50126723fd5c826ab9940d1e753cb17041c7a94e87ecdeb7a866d588472a9c86a8fcbd3ae1af6189dbf08f35487a56dc2dd8fd3ad3a9d2ffd71c403e289add68f2b624e5a2c24c69e9c6bba5317766c39a2fcbb8905c94de83f53f69c8e93341bc80daeaf4017be6b913ee125113def5f788da86dc800dc1868518141018094a943bfb716b38fd5f69d526bcabd55b310b2a2e09b0ae7fa351175b23825676439ef76a1505ccaf84b5080243acb052cd3407b6fa7cec2d9a919d89c14caa0079c9de0969b2bac1228bbf3d63147b9747af143a698a2999b99c041822f3d102051d82e48221ffa0044906058f68415af9dfba947db29acf0de6588a26206fa35ab53394f3fee68161e4f57c9b106e02c6773e769ad1794ca84d7f046b0291fec3d0daf86d63a6e82aaf38954bf468ecafbc615b55545ef0b8b2f15ebb300a4a013b123b68cfb26d53ddf001319b64a935ddf05c2e463390bec74ff51f4095104573faa4e4ae52f86d8c26b63fea44b805316bf5cab136fe41b4b0292183a5f135b3560069b761b86a179d4bb17cfbbfd5c4872cacabc693800d74a03e506a0ba5e53cdf02d9ba7e20fd8f4600deadff879ceb1db5f0c2f7eecd9089961393e324205960430786c49441bf73be91421497e14f73f0b6ce493fa57ab233a3027ce790c6e1824bdea0d7881f5aade156ef8e9dc68939ae598dde33f5624c715bf830466f21580c86ffb3bc998b372d7b9171674175e506d9dcacc1e849270896e827a3048ec9fba0dc04310d838482c649eab860e60ca8fc3e97bddc16be621e9a11f985245b0e2bab0cffdd4210a3c66ce951ac8be7c02899d5e88843f76d1b211fd49efe67bbd5fbefa25da820ae4cab7fb445e84cdda05307fce48bbd75f510c0e7b45f7d7c232f0024ac99a8daf7abcd970cf6fbf947e99b008b8e1731c88b8c7c6df0048ba250ebaba9cad9cf4550844480b169cdc40fc89aa9607643c1d3f3f441e370d62ff9013ebe242aba79993f017231286fa43ca5c2e657cfdcff2b3c7a4370bcbda6fc06f53a1ec15c1ea15e2723d6edf15237901e62a0715c2a68639ffbd41d8692a775e18651a86e01ec1b698d0341ac0618d8c89f77eccfbf0bf82d0f083d2294cac4abdbd9a38bd2b97f8f2a61296bd0308b5ecfdad4dfac20787a42b7c1a5bb90d2359d241d490b096d8260e8a99d5cc9343ff4167277c366f058574e907ae783bdaf0e83e835ce1f6fa1763e22db44a5c191792a3d1d5a739e54aa855696c5372f2abb981fffec71d9e8c6152bd9f17c40d024f21b10fe3927328657f9cc5b62205f9a48eb9111c0cbacaee69f14a40b98c04bea8617f89add2025231c725df8b3926af25b4e55d5521add944169469d2e183930cf7021a7808ed39b2ccef9193254b826671700d12e1391fdbdd8c8a026b6ceffd2968c6ce99868c9b6ea7ddda02f74b184472b975413fadc1e1c6f4e62f661638218206117d1a3c5f9e361edd7156ffcdd819736fa246b9163b96bc8952c23719ffecc4f07489c3645661126334609ba1b1a9273c38fd99e1304ee76c0f912e8e790ead1e5f1c7d94eed7ba19e84f0ba30366e75d2aff5830f1e89a712d90cd67b72732ab3535bef2d901a08a3f995b4c0bf6faa997d6d247ee5dd7b5cbe99bfba02896328f83ed9d5a49912f61c32debf7971b75732e19f9332d4335731e0d5503f0f0113bc678716e87656ed60c7d734c285b7360e20fd344a3aa7657172b42c419f55851b6786e5899aea9915f16b64bbd1b4cf728bed2ba1e38d5590478d3da0dab226b09d351288d0b16909b3f5b856250fb2109d371155673eeda940c5b7e2ddf39be524ac64636bc0357150ab1b15df0c03cc53aacebaed32013f76a96129f998470b92e8036a99a5d631434e2d430257f148430e162335fb56067f2a41380d938e7b78e620ee58b8677da6b6ea11cf590a2a737a0b39ea234e009d48f5df49adabe8caa25c37696b75b222d701d2994801801a28516ca4f03e0bd431dfe99b7a365fbbe3ce83218e4cc414fb406e9e117334dc81f6dfc21ea6544dc2cc9723202e02bf0a8c65be60a3c10915a42f69f1573dbc4d5629f1be702f5608866b5fcf3a7f6f0637a1d518f491714f514cbd1bf6a559135d6734dc2069c84e2d9d1bb526d32d37d5a7cc591e85bc206796b06b33a31bb957628094e89e802cadbbcdd77e98230b46c09a3f73c3c508fd57b68f371cdc285e694b45d8a7ea9f2da47562e29772844554b43866c79154f78711504a1e0a48e27b94e4bc55a80e401135716140f6d42d4e8c4476c3729c14d706ed4256dab5daa1a985dd1423b9fea1196fcd68c066f335d148bc2a050df4e3028567ac9ace40c4918c0c422bf52f6e7311c07eba589f81c3af90c758c52735cdfe0876d1ba150463d50569c5629431bc6b3fbec481c9f4c5eb14cb14a26515b9171ecfc7ef1c66b03137063edfd82b2663e38b2606bfb5b5e0514fa4350732ccd90b29ac5dce63b6193e0e14735c97288fddadd639293420fbf3986085d98f64fd8aee6c2826ccc95d635083bf35f81a12e5a5b9ece942716dbf14e2fd45f8046cadcce03add4b26e337c438ca0eb8c9c4cfcb6ef4c5a9b0741c315aee56e104168a750e5b7a36dad5066f54d5b2fcd76a1470566dbfc0bd72d13277ad03603551de34e703ca96dab9ad5e4d27f86c0211502a44cc2e5d94948734f62a691c88f6f5a36fdc42a05c91ce185df641441c96520c24aba6b86461eda51ebf75ef85ba0ec945fd04726eb6960c72ff7d08d487472f56d29de329f6fce871a12b043e0682e098bd1c106ca680ad720bec166c74ac4ffc049043a3320e5db9ee8b917b2aaf34392b138cf1f5492ccf8b6df108ce70937314de888bb97989c0b415155e2ee03e324fd1072da274bd902a2114d7a816c6638ee43460cfda3d5ce8c64902b1f6cd4a982ee92ebe3ae116211137087f1b22811043297a9283d7f2bc7224c0f95ac685c87ef2c58a3a2f016f4935e59453585ea7983ec5976f48c46a9d84ed552abcb7959a8e6e0f18960fea40cea2b658dbd8a4ee4c01026a04cd9c35a02b019556739dc094c6bebccaa3bf01560251315f02c175f40e88cfd418271d761e107914de7d4c40aa05d56ee2323d489055d1478f3ab12744977fd1be59020073e853ce17f3a8f06bab8017acf13a0e857cd02214eb32e81835d7f25313e74095cc120296495ff71d76667a35c2357bdcf1b752df5ef273f0d465c6a0bb5a75b79148687af9473f56b1c2d480ae1d583ecbb8a3f2cb3489f5d62e2427590aac25aef3239f9de58c20087867ef8f24bd74ad1cfe8f70d49f62d269a2b0b2a6a6d50e298a00ed0b707d321837b7eadee19571414f66bf9591cd8860134fa1b10bc45db82171a73c98245a05312b316a6d43c7d96ffe6ac5991de7d118368597b0e2625b01415eff86a352921ecf7591f2dcd124ec14e65afcd8b9f8272d24f348faccdbac497d0f200115e409c8bb85dfd15b49705ee91135ce87072d1a0647749f51103b21ce2ba41ba081352a9dc12476e806ca9e323d01242bc45349f2d71aedf6c600eb6e72f35843665f83cb07f3c0c8bb1488a230ab493406d01a59e18e9f731f69d844cf1214b76e2d981ed02702457d4ff1d73b5689c9499f16874a85d216fbc3a016312bd61226ee618cc7a913fa88abb70dd5e6918d353a89b03d873c5e899f7b6bf1e2d87dcdb00e5455a74fe7846b0a63751be693ef6cd5acaefe7cfae1d9dcc604eeb7b205134373e9c48937ce98a862260dbdc40a0767c29a346c73f3630ec06ee233175fa26cb7896816b395f6b8ef070cd5193e1b6d83ec934fb6b6939982880e5e5087aac8a6fbfe922951d0da201af817786c04bc831acf6abe6e8181111111d6c62857a8b9dfea81b063c8a7fdbfd0412bed7a75e87603432525a2d55298a07429b1ec818e86f985fe448898133a4382c1f2c032855dc5fb417f50f12359f5dfb67ae1303476c78f4baaa9355eac0ce7f257dd0643f6c977fdd380ce208af544b458ed0780252da1b542b2a398cdd43a7a13ef3aa66ba965e2801a0ffedaffaf094aef019a7d5cca76a58fe3dddda749f94444fb527ac40ffae636f217275b24cfd3cfc0f603596b29b38500caf92ef55b4b2209940c4b63216d298b217d94fe1690feb29694d3fea46cf338d64b00b50bc15cb6699c731c0366e5259f2d8ced9d181bd5b53ee374e6863537081e4925566c2a411ab71cca66d664dcf128d79385f807ac7ccfd61cd4db6d1c97d98bad95553b15463453583eec02f3dc4d314a869aebc64d6d5d560734be2b3c87010deac8b30510693ed2112f6d3bdb239c8a768c049d2171b93b1a5e1aad4c630d823e06451b2b8659114623061e5dc077fc277f980a35b8b7f244b1362ca4bafc655c17bef314d64c95ce49059a7c4bdac699c927dc4a1fabb590e069137d11214b4c75c150f6f890eda24acae1d322727dd31804288c61c24c5ff313f38c8c5b34a62779f2891596c78e2f77eae88f2f478f2dd99db96217b71e00a04d45f39ac7c67cc77b675a3572a4a1089e1b4f73906c40e6d8d39e3168415b10dd69ae1d2a51493a9b94db316264a4cbf9449e3d3c33cede1f041c92ec32d2898bf98d7f5079a97e1b9fe67acd41b7b0fe66c1872dcfe9b77b52d36229d1f64d2860394901aece7f3f4741328212ccffbeb1ec0281a116bc2c3bf57c17b19fc8b747685b9b1d1c1a913bebf0988caae380ea27995de036546feed2a57fc8c41c628919f4498d95ef321ab7b61e4c7973af13b377bd447757355e84ea492c42a758eb4fe54027939ad69985e5d08b1298c4e478be16ba45755af5b2b23e1507e6d7118a2f749bb88a85d8ec6fda1029047659758d0278d99fe2bdc9052b9b453e8b7a78edd7acf2718d37e265583cafcaf55127e736d8f09aa72c46a1cf7aadf553f12ec78d123ba17e5e29f77dc24d629d60946302e2eaf8385d5cb928c3040c0848300fe7ae730726791d065034217ac5865fca3c2c3f41480a91ac02def0bcb188b2cb80702d0e6e40aad517980ded5c6b4677e4c249f0ead91df7e89f58c3aa7b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
