<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a7b4a371400c82e7a07c50ebd29f501c868ae02280a177f29cbc31ecad8bbffa1873c4a5e0842c4c934519e5c91f35fcf315c5d87fa2ad0bc5c6aa1b5905821755997e30a0cb2949d34de283c73cd885faf77465377154b4c0ee89adc3a2d0ec99af09d45c0508eb5256cceef6e6da0efa7fb7388d7dccaf25cbd3348b7d20a4405c8df126cc6b9e8cefccfaae4dd9f69466e6b45c710211ddaf06fbde4439527394d8259f414bdd303bd07e0bd20afa3c98b95dfcb2747b295a076dd57fcc15b6cfb526ca4aa63e69c307e911d09462ae67ad73833c1ef6bf59ea5180f70d4dc32ae8e23228eb7cc72951cc5095a8dd4586387b46b49a15e221e78a476bfc3219efd869e4c8d14222ae75242d0612fb95b856f71cce1d4a6fe73e104a921a0d2757aedb43daf19e48869b0845324adb32e96402c9925123fa006ed80129756dcd3b757a9e7e9fe8606a77cafe005b560ba09719af2ed15ff857a66e8b6b811e40bd9bc546b51ccb780320898c22cfdc0ae2701e6c7fc1329ddaf2e443e7258728f4d63bbf31709c30421f23eb2e4145804909de545547b3d0649597c2d9465fc7bf1e13447f0e9aa6b92d49efa9993ef9385a476c624a64bd43ea162b15376d21e80a0db1228c2aa8d98f5bcca5bf5a001b866e49728d682e3077b5af1ec24605614f7f7fefc54400ac69117dafc55adbda0f3a4996e4bc6cd486c5dcac16308ef85b9e10e167678845d5e5c9853bd555cf7e4883da475f70dd504be199e2d6d4f9189ac32f56e2dc479f2ee89f627a19538607d8a06fa7bdcf91ca1080ff9104cf9894beb0bca93df743ec00e6e8f490fa670c35904253ab20ad418393682b553ee0d0ec48433353a0a3d70463f83c999eea2e1bca6d6d584cd11d8d32a47ba15b28499b8b64c700608edd94ea720416f9bb3671ed8f89b3667ac18fbc7b9b3f9c7435c328af36dc0e418a9b71ed0fa4cdf3d77b7687dd0a75d4fe39e506a9325ff4c509dba57e8ccf218db26873f53be787147da0e8e396effc2d609c4e71be708df572e49799b58af1456b0c8b8e4054a9f39d4142c9d50f983c204c6e02e90116e6c281c4708ae355ac2f0a475b0f5c69126b57d6d18c23f4ac80c6095346bf772d33df23a3ad91a4f8509775f4a3caf21a1e9a6abf9309339aed502f85a009df83f77ad913b2d28ac508974c6cabdf22ea96e353c0cecef34dd9e06e592216cca9c3de85121ecdca71f18c1fb93d032f6669755b759223aefa34d076d20f76bba96c66ee9450a0812d8e629df825842e23cfc936c9db79dadc4904bdbcd8a74aba9a871f60c779802882ec87dd9c29217a5f432dd4e8f9f3ae18535f6317153b8c469a53841ae63e86404ab294fc68fe34c7cc06033865f8cdb7253746100a57080cb8ea85b8f7a2b297597e539b536f8597fd3d3a5971ff00b9f572b8ce357d194e4da0d492658507d18664137344f67f1095917c6be01ef1e948db40fc33a9cddf7c62b1e9816e4613b258e7827e103748dfad6ef226c637c137ddee3399beb59b93bc1725e84957330cb8ec5ea1f8f6121478bba2530380a59b7a01e1e5ed91f2b8d81614e8387516c43e0712d32fcc272ee9f404ce8ad1b1dca04e6c71a38870739666ca0fcd32a9114d30eede6a4450c08edf0c9fc83bd05269054a1bc7ea4625889c4bd21e872bf24005ba8c59d790a24c2ed6265eab62f7348bb55cca078501dfff2e3d23bf5a11ed66ca2f5844c9696d3b315a4f3d916ffa3d3b8cb32eab651231fb643adb6b97257892cf7f41473f88b1d1e5d55f10e8d7771823f1baaba6696a518997571997c349b0ad6fa819417763aee6f10f6d38707c921a4a8b1c3d86c89c35b71b72bc4428940430ece783c8e819e52404bd6eecacabdd148a0367bfeccaaf2d93d7208f5d0090f40baca9c1e1fb90095041f3b9038d9c3ef9e251cd27327c5cb5609b38b589e0bb29c0a4136e3376903e36ba1b168ff1899e8ea4edca2c49c5da85395063179b8abbf8b06d9f45929bec399069a96b13bee7134874bfbb74182d072385084904a5afa6db9e6bd6c2b083e6631c94849f4a1cd3274cb06c132659d9d162a648b8fa5dc565058ce3a6a7b04f034801fc2860be6eceb8d2e97a741bac93a863186892e8c4c9de0ab8a7aedc9890a4d60069ef856f9f055bdd9c2e8f41b5772b0d927e2705617222c919a47cba4a5732c62b30d06d6c7a22688eda334839b531cb1134e4e7d8356497b9cbc8ab91fda965c455aa3a47fa122ea36d083d0c8294fcad421ed20699e1495e95feaa76cefaf79db2f0031506ccca1e0dc5ca0a0ff8bc9cea36560ebad0cb5c959aaef20cb0802cfeddefae268d0bf53d1682ae13133e6d7627dcb3edc0d8996cf71119f4b7f0d374d16a2c8a4da5fcb2a4bd0a0067af7330ffb366b17e28d91883e3c34a63e405c67211941d2d490f8027d0f66e5a3dd833823a1de858d73db083626016047633be6fa8fba8d511e61ef7f77ff0b8644e50decc04405132297c95558af3a29515956481fcf8403af8e7a19ceaca110da4be4fb73f814c892eb8140c80a66af093017b50d3e93b1eca7005eefe1fa6762a01264eab7f33b5f234aad6b929fdb52064f7e6602c962d29c75984df8817924a74b2f5147c5b1c9a44d847e5449af02ba3104b292f31076efbd8a24da412899bbfa0151b070af11cd088e9cd6f72ce1b5714683c4a3eed2fec789f582614151a9004a39bad6e1f8fb36c7df235d575217e9f9ab46089bf7437b1a6cbda3e3f56ae48895e935475bdc20626fad5724e59d2dc049310da30dedf72dd7ee362da84e0f876fa050a0edf3cfd01bad74c5fbd651fcaded0999404cb5d6db0d77b01165df38282d2ead8f440395bb8591fc87680c721f7525792a80b73a4917d464f2fdd62f1e2675d19fca0cbc7272695d5490e372f37077cd6422dfe28c6e70327422eaa2db94e4a7bce5e1137109f18d8a566421179a547368c7f124d77bf1f2ae3625027d20385bd0a396f55190a29bd84da91f938a25b6aa040b2f3cf93b2325264e1b6e70118b8b0777693f37168bcef4f56c42b01f06a3125de738927f4fa9a45b73c37adbe742a3ec1bf2c8423ee55aabe4665b44dc85b6da4675da75acad2b9c2222af30cb482d56adf2080372bf6fad3092c26e4a352cedb1bfffe77965f1ca55562487b979ddcc0a5576f9e2bfcff37355395019212a77ad4ec9cf3cfacff666b466d4d9ad8597b44a9b02dc023d6d09d480fb790d6eb8faca9a275a4f3888d77d83194c03a564b12783a147e9584063a3b4e27daed673efe2bf89dc20d5e28bd31bc2eaec5443e9b06a53a97480288b2896a4ce2d6489ba7d530d9bbe54514a04953cacdcbf9838966718cb7dd5618e53d8fc0294a419f69aeba7a3502a85ae4f8be14cc914ed26981b9b7709a128d738fe6d7c8044f1bd2727c5b21d590ee8271d65f62da9b536389d5be0a8beda1f8bb74082f8c4ccf18854c3c0c42b4b6f8efa02ae88f5b73b3dd85a14737a5843def98016447538fe7b131bf3a71d3220818121fd5958cdaaf45495febf892f724ff95f6d802b7aeacb3fd1e1017e35dda6c013443abf563bed25a9e17d97f01eecb0c70a468bb7f5cbc4b117a839aeb42d713906e41974c4a14409a47d038fb05aade44688531512d77de6d8355a9ae44c158d45773dc4c2872d7194cc301f6d6eb618cffcc725a5bd96037d783b5e9373eca6c9fc4322b9cc3a98b01d5d92533d462a71b894e61c663f63a6e70922b8b9046f5e0262a9491b0a377242949c83f8bfa3cfcdc396df6206ae43d466eac79bfebb591f1380ab2caf61c5053650dc129c3b8e0fd193d164b8c2af4fd75e476f4c987545da731b8727021abad8606c249dd531a2bc52ca2d087d09685ab872e83d8222abf12cc4b0c8b3652b463eec8edf3f391472d2903c69843dc255aa0d814d7faf6f943d38651127f3283244dc1c549918464c29f8aca1f2e08acc0233c1a143bbfc2c414706a3a3f7d1ce89f94a579d8b223784ce88b3a00457f0b7133bcd8200da44591489de4e652c33716ddc1f24ea82cac12c07f919e7625d98d453fdc37d604ac9c10c7b0bf9c6820468fbe185540ca120d9e08979320b12e6e9f15d381e6196f152169e8053f65e9f8d2ebfd9bb43a34821c164822ac50fa59d25d1f6c7a83f43fe25ade7fed44ff18de663a4685b3772ff9e5522ec991cb09fe897c896254cd74b0861e875885c4bd5d0f912181152aa797e951012ebede5cd44b246e08165a672712fc5be024fee3919d8d2b3d5fe0822ed7eff768bbd95b44302b7f87102d26f3eb1fddfbc6a9533c6c99402c8e405ac604dc32ca1ac0e18ae80e4608acca6b52186e5ff924b4fda39eac8de38ff6e824f59f910f345ae822fc0d7749a80c35204f4c12a3f959544da2dea06be36be090168b96adafddc14385903e42112df5ad6e0b50e7744bffed184069f7c45403d7004cf768053b74cc5d608cf84c10a539876b51f8a0ff5614be79dd2a399f5ea9020d91cb98401744b2598290ca2ea6d790a25a4ed73eff15668a10f3915d26ae9a8d3db8fcbb5759342eae9b142c14a493e11aece607b73279a8276e04c43466b2269bd0617f6a9e115d62d7283b15abeee23979cb6f99677eaa73f73da4c31268b9107f2dcf72f08e26bcc84c2278afe403c8691e926edc2c480278099bc08eb503f10e31c0911870e81a705bf4e560c99e2e6503009125feae2ede5068e4b6b5f63bcb863852420ef53fec609fc85e2137e0bf40982dba823167af5cee49d78673158d52083e486548b023e11955404f2e105f5a02b503527a60ae4ccd2aac7d4ca3a9f4d8ea237d075fb9a3483fce751dba67cb1597a1be2f0a2b88b43954231580d67f1af39eeaf9d3f025de7e9bedbee6119d5ab8511f8cbb09e6ac63d1a25ff64d34c729df149ec3c04c09d2c257f2aa2380f8ea039d0a8aa41b6bf46d7554c16702f9c679239421ba05e184e6b72344328efa71bcf6af43236d8c620463d40f75a257cc0f7d0a9074766db7d2029c22b8dec2507c945e0c629c4fa34ec300fbf41f4271da8b8fdd52ad98aecaceff1da777f8200b1735438073f07cb2eb141cc374cdefadb2f3a699ef63ba2f1e2feb4826ffa018f998e7998923529364693d985caf5fcfe969490c2d4d74015348b9322874c9a56ef504a64365a3d7bf60768529bf7c0c4a07dc7650a369f15992d44fd6e0e3e3e2c27d14154fb8af10aeb8536c809f36692dbfaaf6c7b6f38b7932c8ba93b4e8df214796a7d96334bafdd202b1d4ad8be82580f028e8669b2a6cf5aaeab0375e980ddd488567370bd528d06af75992436f245bafc135f7d85c40275ff8494fb7a359de04fa1dbaa623ccf3b36e74d243067d4fb3f38cf62fa93fcae58bac28240ee9976146ef3cbcb54754661a6f7666861f8d3a3566239e8709fb5eada15b3217dee00614001eb52ed6c5ca9dd6fda7ab9e4fc200ffb67a49e7efd93855e45896bde1cebbb6b17e60739f23c2aff174936a268421fed20feee5119c0d578f09065bd9c522f12395582ee3cf291923d5fa7e5f5b98b71be054286d0074d53ff07f6f93a12a7ec5bac79cb447a2bdaa029c22174d28c66305de5cdb69d8f93ccbbaf6100bd8828fa48f6278938ab512b9febb9d40787139c441ecdf70dca3bf8b03f62a416f33f87f361b265b9a5885642fbea07b268532dd6f34649abe0acdd04c27b0eb6b2e6a31d72116bdd8e1ea1f7c86dcf182d8fd1526d309f063fbb7db5585c8114d8756bc126c58c00b07312895ff57bf2c4364a7f6cce17247d9ff1bafe5ac5246aa01bfb8f2d2773a8bc4374a91bd42254850f849933d17bdf2412a1bf9d6062758d203fc5c3a6c994e00c98f01171f7331e73a4f9edc8a4978b0c4a5b6a0e3e2aa477ce3697f5c9f338b0fda1e18b5a871bf5b32566b4fff1167e0683108f38e30f1a8b6f16ca6665c261d1c6a8d6bfb39f7e0ca0e74ff0bf2817ac88fb3635335c635a754aa8b15c40b7c566f0da7dc1dc0ba814601b18ecb6c245c5550fb4b50c79bbd434c4537d30aa6f08e7fea0b87745b6fb7af8c1bc51fae03a9bed10740c0c4e486a0bc0809f9867e7abcaffbfe2f28413e1534cfc6dbef611b4e2274f3540a9fc56160b87b4d934de39b84751cd3aeae63adad848b5584b2929d8a725dace33d12c50904863e64c337d2a85abe0fa6ae28fdc2e374275f9c41ecf36ba41ed9f854d0ee4b008801ae840f206782279abf0b25b085cfb9b2a11c9afe497359f30cdbc50707fbafd8fff0154758544891f384c48ec1747aeb245ee85c303949e39d5e2497241b1b18261f8b7833b1549c4baeeaaca0304d747e843b198b0733c929cf4e6f98adc9a80991bbc27ffc72712c389c1df0e2d5ca728e6f1fe0afb0402ed57006dc45fe38c693a9083b79f1dd6f2a44e668a48e9dbf648c08f69074b7cee2a1f5d1d10f37b6cfa394e1ccb9cc6c1999588b660f9e09ca508c4fcfd9e08d257b8ea4bc37cab606e5a89009e4a6c35baf6e8948e0141af1bde7d03398622fc520ff1ae846b79d6b128616eb3d4fb88aad307e764b67e27ee553e2196308f45e82eeda9151dc3941933ea1c9d8565fed549d00f1019e2c65b1dba05c8389f4e3009cba2370af956c439951b63cfb1527d53d62c99b0c07b1e010310d9fbea1b8944571ac658d786313c71ffe1357a6156b88591fc0985adf16e82435981030951b9748f02cd33d30a64b8b3aaf52b93e2badbe32ca4c66b2281b3d6a3c9dd55f45108e0331f61a1fcc8133956b1d81c98a0a3d0f23f812369400d9e02c78ccc4067aa32d95868de084177812cf3279b72a0bf91de3a4b2e72d64729149d9a8898f51c826d50100cc22424130fd0dfff951dce6eb4c9314ef9f1270024397991f5b46b92d425144690657db6c9488f8f0491c7100f4cde70f8cfbbdd5b34d146612df5960a4d9c8040d7f32e19aaba0f120f068a4015749452b11dec4704630cc8d2c6299acdb92ad16d2bbabc91c1c6567ae00b98147b04b8fb5e486ce494ff9344d5045ea977ea5363d0cc2f33c079166e59711b1e01f611a00db601d8f4d1bf988b15c64cce48f2cf370c355adbb01068f6e60c862ce94310f13b8a05279258cc2694476d47c211652cae5af03f0515a00661c84f415170b7f015919b1aab3ee951f65c994880f8a10ee2e136555753c07ea342ec81e901679ca58ded254435bc730818fcf884a93d928d37c5737f5e636005ed198f6f131e95dbe6c04c9ed483249409fb199d1ccaaa083c0635cf64a3e55e86731577c9517aafc1f48862785be7b82a048974ea5e937c0406c3625d9d07cb04f7e2030a08075002c7c0e3e7463083c01a58d69dbf68e6548dfde2d2df3371de04db84470328e070162c77b075d1c6b7181901d4e897d7944b7af28e2cb96d94d9be2a935f6c8be958a0e4c949d7529bdf2bae7ac8452fa4b326f89c35c5c5b7195a0e1e8ba8dd8ccf07aebd8d4bdbf1da790c9fc23d4226865d729216b24f9542d01b29768fb1801b51ad31522f869e81f9668626a3b8305b73f105e8d0fd1836aceff112aef0f966e17de2042094403a681abdc34ef3ffc76464dc762512ec3390d32a0a2cc0f2de6529105e77d03ae779ba35029dd65dd46461d451fed7d19603a7fe8cb520389634bd13566745df3a225454832a8d4202c055dbfa4b20e7436b80abf338e057ed9dbad43aa7326c57d68427f8db061389cae4839e24f04a59ef31bd4db5ef852d596bb33de505ddad6ff97f82f8f5f0fc62c23b179c53822139cc21baaf9a133fdb471ad8479ae2f5f5b188f39565aef0bfcf09365f9c784bb0f6c6cc10462ebcbd96dedd24d60da68c3263bde07ca2594cb40316116a11f5b10512e5adcbcdb034850ac715794c662613c5fd604c1061119becf5a187b9fbf814f7ea8757fb39a2dab13330e527fdeca354f61cd86b20dd3ed60557c10d7369b3e1dc71cca2749c571da1d98283d41ece0380d901dd73d3250a9c35966d2c8185ce8190cb494d145dcb943343a10039580964ae490662708d7d41047da6c75785748b539164af71d254dbc59e42d73a317d9c10b81c5cff1475b5eb0558c92477dde85b2b690c9e86f70ff3bac9317df97eefb401871d8ad961f0d096279c6cbfbeb264af9ed32b66d2e43a6eaae3042f69d0ee0d0efa2ab2d75408e93ac225423c24ef29dd2aaf42e74c583f5bdd2ae4d7f67d504caf431ff962fe6af98be6078ebe7870b6c522ecd2e2d5b84c4e960e6e0480fdddc5b82417920082e2cbd7be9bfdf2bd65ce888912ae1dcfcc8b7889fc30f8d277028f04ac83f8bf876648cdc6a44edb42a8235b78315659f89de9d23fe5b4205d0465051caae6f75d5a69d50f0076b5c03a6845e5ad9a0aeb60ce0fed7350a025cb511e50664b9c183782113052bdc3e9392c77b3558719fc39933f1cb9695375c37a1ea8a1196f890d143da0c229ff1283c00f01b872251a5452a0409ca3e8acac221be82b497c1c3ad4b62489953a6720ecfc63058263c9638df6e9a66b522630c55ea556f38bd682a02e12ae3056ac06817bf4e209bd19b9db7f8143aa78ee14ec5b8daf6368c74cbcf1ef238d034c2ba3d2c232898dee6a56f70ad0809331c3dff28eccf9af42f85b3140bc40056034136735252e171792a2f7e2ce02ca81e0e1c7624062155eff97bc901b5e6c7306e14b1ef093e507a3b838bd82fcbf9958685a250b091857eb0f6c148d4e9164f9d2e07326d27c2295566f1586ea017fc8e5016e0cd38b53c9603d140f80b774dd22072c6c276e59d5115c031db52b67282752f24178699ff270ec87628fc593efe77dcd9d70018d6e781ef29434c571ae08f9f68c9a98dbf4cb4225bcb73c0d25fcb80f95a0cdc38e1657780774343a6171029d056e0fefa3f34654eb493664648f17fb97bd94ef3ba23039a0aecee75f0521cfd2c7396423672cf47e3d5a1c3218c2624575fd91a960a97fcac3f1af960f0d2bb0c2ff44340a52b55f7f0f6853991942d8dfc1ef7ca36d59d1b9a35c92a98b36366ee92c16f7afdd3c397c08e50f2cc0924d6899941cd6774ed5b51456b3e42ffbd408032b13da8feea0c2bc8aa48ee8a5d294d92fe40b8df06adca093bae723049ef356bf68b7215508a53f1954c5c19bd322870063143d4adfd7c1174b94c8c3b59b6cedb5d7d3f03209cb7cde975d8a06ccbb83190e97f78a3ccbe9b323c38ea3a18ea8f1e3ebffb92090e6b009d230983522306ed20ec9c76e83abd154d815c2dbed8fd59fb2bbc6c41d5db50a789b6256838e3b9d709654a9d915cd76ea9856713f82e71f408e592495b0a328f104bc21a71853eb69b14e758bcdb7579832a3a2a9c72d522abdc89b41f3933265031f542e267efd2e600151c0112478e375e2e1ffc7c8caa7143052cc3baeb6afd878fab7e2634c449faf20f446bf98c72166a0a55175b2d892ea585ff41227c8be585f43e01c25298ff5e7173b831b7e883a80209aa45d0608707a92a0daef06ea74ff8f0acbfc75ce448ac86b03dcaa9de986dea96572055f383c6c701439b17995aa4decc8aa332461cbbfb34ae9fcfee973b0e8b161e71b7681329da5c1dc7733c3193571692814ec7f9f97499e02bec95ef44827047b26bc8ab255f7cd1a8d2049adcd45b4e9e284677f0840c00519bca45eb302930543826e2c29e0a41719d92251b22bc50c991231cd6289df5f3c2de62819bda425425848f11ac885c7303f1d531cc19feccf6b1e79aa7c6f6a08b5759086239ad909ed0dde61c86883ad48c0168b3f7e4e58d311a509a4e3c7d9028fc7f24ef4057da6cf58c732d9a6abf3398fc435b1514c86d55ffeafd42b8a1d29a95e80ab536a68c84a58461a1c14ddf61f32874dc2a20de1b57eb60a6f0d36a9523e6bafa978157b08786b703c900d855cb42e5aa818baaa2271de3be04a51f85f5f888496422926239a6168ed4e7bf5994ec5e218801ad9cdde75c26174b2c9bcdb9d03e47c22697a3cd8482e91cc28e4f616774b2bf5735fc9db3a2ce8806865e4d4e37ab751077b2781ba5bd86976aa322f4d51e4a669fb60785f5b979346db2d70b310af9187990662cf6b7d2cf3965cd6dc8da807406b06902823cb15c963e59ad01c9512a2b84526d29064b4b06a693131e8618cfc152e674ae8d9ca2ddfcc4c18f948464462478d6a18e382caa3d2943046e6d28c66bb7240330642d4eccfe21e738110bfb2c42bab2e37d5ffa58ab869457eafae6e835c0b4ff74fdc2d51d2ac0e64ebbd11c80c295c0be9a86a8f7cf1f3cc3d7e2661b9b1b5177bfe769b6e663cbff83bf787cb8f46658c84ee6ab7359319d6d34da7040fe836f79d092e730e14fa41b884d66bb2b7662517d88b04dfbd852786c04b5a949e53c4a0eeeaa4466167766d82c90f0d0225ddc795877f5f3370640b4705b7cf640337249936ea98e142bb5b5bd5fc56e54a5572ab5ebf39da58c626920ddd90d111469480f6bbd01d63c1938d2282119b0014264aaccec373ed7212aa06647dd8cfad4aa76756c0f381db0e5935f04049a992a7a9b411cc1fb76108cecaa24d4248eddbb88199866cc4997ff7effc38ee133d6c3f5e45694e7b930a34b086e52f91210b3e28879f616ef29b047770e2c8740af5c31946580629bff6a4c120621e0839a45b68b0a8ebe034b1e389e53cdddcac9c38d1a915c4d08524e91ec1d4fdf4b03b4223a1f36a25e115bc794d2a7eb4cff226c0c14eaeaa8c55bffe508369d71e071813fb53522e7e5f5b699d35a7fd1e682ad4ca4198f72458d5ab35942e972ab12b337044bc69cd3a3abf5ccdfb16644624bae0214fbda54b6b8835714ef64e0396c7f27fe9b1e8b0bec19360cf0eaefe23d794b5802228c2d2aed7de66f3e4dcad8583145786a59e6c67658e673bec6aa2f8317f10a76c3f8b6efd6f6a5cc914f096a8baedea1453b67b0780d32e0c64277d3cea5cde5a3ed01f770a0d88564f34dd40587298e2a82e2f6c137aaec271b039e12e2f0e22b33fc79a4271d31a89a0f8a94dc6efa2f6e123162525800d81f71057bca567992d3fbb10d659a45fb92c4e7a003d6f4e139140402c5234355460ddf07f59632bd06340ccafe835ff485d8a4ddf785051aed71f11c8bd749bde49ee754333543f8af360598fbd0b1a753e9d6d75f84cd83edc79dc6bc5a32ae1ca2838bda3056973e3d43c92006afa21a35b65c524a462a1f7acf1f5ed096340c08fd6b7a8d24e4f0077ac1daffec2c536de7764af713c4437342a3a296ab1eaa1de563741e315e8f6349a065b54fdec5ffb0460ae2fa78fa8ffd0fc7f7d254e96d1eb48e6bc077a004e1ffbff983d283333062d92d371ab258e484408e605458a547513e44dc7f7ff5009d71c66d400f5dd345fd4dba695558d276d46ce3107d21201846be2ee9cd83f8e475aa837c7ea1420088aebcbaf3ca1f876c7d5f566d03843531fcf227ffcba93e30ddb3f261d9e580c812f5704c61f6f32adc87797b01b778cc2dabfce742cc69bcc299f62ed1dd2493a13621840125e86e0e7c028853b08ce8f05cb088fc135797271a709be0141ec234c213a4cf8a7cefa8007edbaa07f35cc4dc8f83c27efa4811816c838d679cbb47fc58ad707c059c51e37f95aab8b7882f4c7b699280303f867a6c4b252d743f55efedf67b67896f2f3c0a6dffb27ae25c44fb9e591bbf0e3528ea67777ab268b7cd45604a34a7547585dffe7b8f6f01703ab36e254fb2cb59699bb4a0c63ebb946d85fe4a8bf41990ea347601a09be03451292ab2c964ad19adf61635e4f7b61f007a6718f2d06af3cb72ee2595ba1c305d2220aff703c28a9067b954580790979cdc395dd16a7a162107ebedbfeaf5cf48b490160fd57309ca9a0e088ebe5fa28f8c0a72d9e14a0821ccf614259fc3732964e7583220de55fd010d9bcd06c130a30d522def8f377630a0c47e8ec3643337c7f2f6bdc2321055a289d842c8a58564cece97bd649292a6ddf85acf42b2ace3b3d8f38c284e52d7896e745489ecdd20fc1dabc34bf5280026364d60f9e56195ac6e1fac8c0d7ceb2e37644cad4a834227254dfc1395f0657702b68ee8abac0f81342501bab7616896e60c5a4ad0fc2bc712ca231ca67ddce40c09156a4789c54f0e3c4d1dfa6845fc767fa8f6f39d3fc82e1f8ad10a2a3a569a0a88eb924884c3cb106755c1cf399b293e318f58bc0dc41fee1a24ff6fb8325c4268263ec1754008290cf4efaa3b79ef7084bd4e0499bac3c11be633434734bb02558c659c0fb0f5ccb54f65a9e35fede7ca57fbb80dcd98ab4593f9704ed6593af0fb20c07cf80caff0e010bed9fe7e7b205ed36b46aecf66fe043c426ceac5050d1377782e99269b4fdcaec1139400777b294899131759010016b7a81d5f5eb60adb7a6488c6d8249793b97ee5e7905a61d91bc4532687ae7ed36ac74e0b2e10c0b13928d5b7a3d2c428475349cff645a12b2747a41f0e9e8b874e77190d64ba6b341f4c2ef16f9cf7e3ed676288f08c3fea8176b74526f9bdd27873d0524f0ec13a29aafa61b83a43bb52fd52f4c569aa0a9635c4061dce3ae749d4f24922c7e2cc147f3981a47ecf069f2dd35e4471368fd70526b9a34b8cbd8d56fc4f54063ef22f3d46d2bae090ce653802439237e8a7dbc8846629b12d5b91223fb7146320911db8c88c21620715148b2c8ed4b50d209c704954cf1835c7f43ba480f0b475979d8ef0e519caa10a60b2a2aa1a9fb81bdf343985fde86f9220b33a8b4ba596c28b65feda4d35b9e7331966bf6246af9652c16dc973e15fb33105664bb5470437cc59fe3a32ae90cb906b8a4fe6aaacae16726fa3b6d8b274fc3f89f6b12f9229803e109169debcb3c1213ca0431559c5653dbd7960f6f22a76dff9290fa79c1fdfb68e16d30f676d09c08fbf9e685ab6ee1e49c22345166bc1587529264ec057eb0fcd53e1a8fa3983a751e84e8f95b5e48d60e891ba26debd1054483e4755436e7213795b85f9f1bab598988a1d099f9800fb556d8631cbd44a35d742eed9e4fd5748e0474ee2a512634ad5e662158a2a424126cf8c756d246e44ed71ba2304c429ff054bcae824c48485898a1d90c1be3f33d8fa99b58c2b32bfb6ea1a39d9b3cd64cf9e7e16946483e3c3b483f06ad72267286ab3c513909c27c0a891a54bc18ffedf8f76610840d89cc48359589104cf3c559e5ca52a9a73db3210460354f1dc3755f50e74ab58d47678645c89e4c65edfa15bb43ff3063c151ef428223d95c9d7eff2637b14d75acfaae5c2c6f6f8ab57d40c09c3da144b66b85aa21efcd0bc38c9af4f1c72231ba9af8fbeda9123220d398d6e9a7b18567ee91e314351ac7ac8213a7b69da255e2ce84e499e957f4390f745ff2c5eef12db981fc663cee451567dac15a1003b61014e0b5867006ea7d80a6f61ad74d08d6e10218ab6a2c98878827d6e2edb2178bdf910118ebf105dba3bda8cf10a6cd8d2a2c609272096fef5d97ec74005f6adbf2cc440a797991ddb456ee108cc636477b4661cc7ac14ef02501874f1ae4e3a3697f5c4691cd77c6e5b69049a07e96c042a86e90a020e6784999004e198e733e414d96b98e7e49864bf9d8d2d53fe5875009483ad0d7bfc13779aeffea85971b0ac4b061bf082ca85be3d6b2f2ce22ca27d9fc421f610f926f96ad14d61b0a68ff79ed992579dc6bb54223099df8e3c097f0bf9addfeb1a135b1e759c04e78a421213ffa2c33b1974379c757604fdcfb23f0586307e13e24e42901ee62627f0f8a41b45b68a624d46632388c8793e03214334d3a1a1f1f98540601641c1d488e79478459a75e068b22842b03b3db118e679cbe4a975199641d3e45aecb815685277196e851de5e5dd3c9ab1bdf55c01c351c027df235cdb613ac2bf6b6c36f56d3afa2f248205d0f4f3d8821fc1b8063f2ec38653f2b327826aa09b89575c0d517ad0d237145c3ab58880d3e75255f19e92a572963defc826834ca4ad0feab0e1b1b5f20716e9a59fd86dbc2fcb892dbfb49b72f9b09b8d82f07b3730f9229eaf162c17a3730dd0cd40d0404866ca355604aba1719af70b490a7eedde0c15e6f711193142c4f586812604bc4a10d4ef2caa3cd385d1681385ddd96aaa3d77abf3d21be3aa9eebd8fe0446bdb750a8390a7e244287e844c759c768fb596c3cc24bc925e9f661c74808a56880572f5ac474b25a6f56b5aa83c30098efab831df215e2810b4b6f7321bb1c9b116bc890b808554df2cf0b0f219b1002e5194db00922a2f7467c73530a9806e93ff9635fbaacf4e03b79b8d26556253a1930885926e8d2861cbd19ece8a4724b2abc90ed45585ce4bde37a21f7f011ddb39f71fad8770d7224d2f6d951fb9856662dc8b38cafb0e07a78eb49eb322c3ff556b6a6833b8a20b9e1bcde09e6ab32e09b3dce2208d8ac235db6a0385a9b31e34af1c6e2e436ba1fda7f53f34fc49221f5716507af9b63dc9e00b3c05661252b414e85afc08524bd3b86f05b35f3edf0a39460111d94c0397152b0bd7f5ae60cfc70d04c9d9cb1d2efe9d28ec0dc6875c3f18885c5c52ccc00aaa50d3d4559e89400eba52db994719bc11c152720147355fa6ac8abd5da905c19e7caf3b000e134e0d3a05a387e70df8e7e14ab42a286e1f0fa193a0fbe4d0334f4a44c71395f1b57eb7934ea0f5413b454deced48f9e83c4dac48fbd58d2e3eead28bdb60eab10101227bc8145f8270f296593234db0ce9451b0a8c988dea8c24eda4599850a8a8134266d76880d6f0417273feb83f7422166dda21d90e4b36788a0f2cdea817083d589e1c5e8e518d5e3b636dacb5118a75622ec2c7cc9bc5797accc0cb93491c7d840bbf1fb03ce9614271d5f7af4d8ae1a6f55f3430864c880d6f011f18abf6b25efd76ec015cba8b46965d95f52033311568e170be536eda13086863d0039bc71d9492294b471e08b36a6e0142e17cb92f00152bca553130070d4100a68aaeb1621b20a1d8a189a3774df9dafa2913b6e58fb6f870d4a9dc46c4ba97a072430ed452492c9c792b55326dc98aa8e360f8da4d37315c17b0baed576c50b1466e9b3bc53be2e05ad7176ef513c0ad8a8e73811acf81b8e1a6493d2afcccae1b611428eec50afde9b7c1f951ce93cbc89015e7f15ca8ddde66e8bda3d0eeaa2ce1c6b254f182904ca9a276a553c04f3d1b8658051c7c03bd8822363bc9ddaa723bfd082d65995724462114d9f3a4a8b52907528e017dc6cdefe7ec8c792c7fa16ddee50eaab4ab35c0408b929f2181dee50630f2ef96ad95f39556dde8981ec6136b14b89b211a17d69cebc3cbd8dbe7b520c72d00f895e38687100b2f6332fa2c618dc8dc891ff393086f8e7c58c0681aae1b6a80966e5bab5e7f686142e9dc1265f246ef8ea4cc9db0ae50e31b00e01539b327031d8bc29b7866c59920eacd4285876e58132e0295d5e0fc40bdc5693c46f1319e9179fd5056ab3d8dd37aa389f38b76f056b191c71c4f39e974cb1e5d88762eb896e909e148fd98a870cd3dd33e055491ca5d558876528bb400c82393e053ca407995b6e3b81b5991445f2bb180459bc8c78925ad079d248e146a606d2e53a7c29d21f96fd9d7ef967d47cba89cbea8606e22224f4d7ae04128833c75a4a78f0812f1351397bd0423e89940d282e5477172d7538ae565b45ed55646d360b0fe648ce5334eb2b15e813b56ead32736b41e694c68bb09fc4d76b1e59fec5a4b7315d8af27d4d40c07f68dd8ef355779424f64f157b58542bf6d70240ff6b40b1087a051d5718a222f1d9e258a2ffe6c024eca974141214890d4040230f6bde8e8138a836eaccaf8b30b4bf19eebc8b57090da9d106f7c7d6a473368186f1550a20a989b4ea30946cfb306de1bb129adbc03286d3dfa3a69789dc505ecffab0a6eb047a06b4cf77a9ba49b3fa15f4d3e87045d5479afa4e1c1202660146015da6e5bced737749b6248a58dac04f659929276d3d6b5dd2897ad9a687d1e1d7f7010a12b8fbe6fa0bb4a707a386b716b4bf9fb65624012bc4178371cdae2ff70f3045b8d9582eabe8c3d9b79c292a897fa397aad906c63c5051fd26eef1950a8a0e6c8f5e77766f515efb212cc0da781ff2fdb00984f5f90c5f83d9b2942d3a6a60d4730279700fe5db762f2f18c1be5a1d83fdcec69037fe00c4f874f22adfd6a78d8a25b8d8f251ee7ec954731bae0b4cbfbaf7642677818491cc382aa254b55bad92dc8982f64fe402c6f9eee9b7b7df8ee8eabc52352481214057a24035d096b5e11c19f42b35232f77afee3cd80435f92acff999af20c40c854e5c40abc7e9271db16b9c7a8c0058f9a1b354138a45ec8bce49c105d08bcff65c6c4f900c37a40de80359faa10a40983ad15a0dd67bf52daf284cd4abb40e6d45ae752ca6af5b02d84602679066d0acfe10fd672501c7c9c6b5b64cd8cd51067599a7ea4813e893f847190ff257e70988dfadda011e6dc8c43dd22f524a3d547b5cbefc5449a7f37b7c97e274ec7563f994c83dc66b5dc87f305aae0fba53cd00653fb8afbcc13e799cac5c27384386652d3cd244815eea315c00e51a76c4a687a36ae90210b88cf9f390fe039bc35cfbb09832dac89c614138a30d14fc9ee4d2e3bee63f98d8d14e338dc224509205f13fa8ebbbe12baacf87ac9b9539c3e5bfdb305783e8fa3b244ba0cdabcc3a2277c41a622b5ee4d8a0e95e3a277cc5680cdfdabd6bd7c89f30f59a005ca3a81a29138450b6312a0da507aa7fe3cea0562f949ca41376cffc8247a1c348a768800f94ae1b7a4061ab926489b77ef6481c448e12803191959686f59d7a67da6fbb3aaf01e1b1b4d2d80683a562c84f83a551ccf40f1f7eabe0bd0daba5842d8e16803d88044ca314c518f5c940cbaa318b30bb39dc31cc87dfd0bc696552cb88f7bec748c7ec6cf62add6aa055593cd539e206ec72301db11ad24d7446509b9d1cd5c0e8eb39917d867e16a7043f3bda5da829cb19b6b5679054e52e1aa98dbf61ca38135dfa7e088feb6000b6c395cbb208f92705b490c639d4b8d567bb11ca7b995185c39d8cd0a4342fc6129eb9019dd92a8b037454d9e80b968fd45eec4156b3d852d6d78e8f78bdd37fe468071eda161c44de297867bf85bb45d042219a2b2d4614f99c5f7331825549161a707ee442f579515dd6a46fd518449544da1d80688366676422a397a7e0260a84afd40fc506e6f916d75a55c5794e3d3dc072c7e56d09a097b9b91f72359d0e9d325f95ad83a0d2353e150a81b5e5ecdcb6bf82e0e9186e646ca48c58cf73e8db1e42038001d76e3419b9adfbcd21547a9d8870f76e3cdab9915f5821fd22e9212f70dc020f7d9ed708a2dbec6d8cf166650d9603129ee1bbf47e6210c909db31e8c76ea2925ceb7c4d1f226376d2b591bacabba16bec78992da91805f9b0461b52bbc04c83fe923418e68a511b2e242e4ec38cc715936b8bce3c38df7334b25e47e9ae6513642b3b021e9c1f996582f0a34f643f41a96510f78ac1d98963ea90446bf12706a23de771b1f6d4a0ea527dd9f1201be4bb7fc4f0e286fdf4b35c2eec4cbf15b71bcd8043eed2e4206bdb82cb3d4d51092ffda52470beb08522a5facbfb42490a9a21949dcd2c4d080668c5b0cd1f64aa18d2238f0f194b038ac64449dcf4031bcaada416a4512609fc34ca361a9d68290cc0a3bbf9f5881d32261d3b22222c933833b3238799cae10fa976eeaf3b665d3c643c628c943ac586bd6efab21c35534c3d539603d2827891730ab9a8237fe18d441c5ffc4c72929ddbf811be93a17a5714491f3d15877352479d8d24cca611b3e9ac9c979a66d5a16451a28488d6bb87bfac4c44baef2aec1646ec52282d03a2106ee5d0946688dc980494c061e3caa96e15f984124aa9cd70c9c8b1a0598f00605d32","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
