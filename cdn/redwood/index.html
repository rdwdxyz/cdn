<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"4b98ef328f25fac35f8c844936d0bec7b63bd085e0f8de2847fbeee8d61ec26e0f60f1a02950fc788e6fe99404cafee1feefdf0891d4f1d41ba8fa90f157253361f2752d593cf9b6f0397142ad09ff953fa6f965bb72bc4d8f3043565c461e3dddb5740fa70b233e043685d79a6d0bfb289e04d3942c6359aa518475808d7495228c1521ed18da726831692b8ab1db463c002e83d5178bd62ac843ca0f03a9f914ecbada537593c669c4893927cf55f244738bf8c7f94b291aaa2c2cb21c55b46745047bcc0ce2de35749eb25ea1eea2ced5f8f661fedfa138006aa8e577f610e7bed7d565d25821466694a511a83574e734dd5288eab6a7f0d1a55ca6798bb619a668bc87fd8192e05984731d26ffdd0ae96faaa08d20d74db8cf5655f68b1925bd509ca3641992c19fa907006fde307afae0d3156c96b1de9e824b6feb820c26679e0a9cd8864397202a86243c6d900ba527e1b033a182a901f5f9fcd1445b6553167db9d4094a4c394fdbd82753ab5ecbf5344f826a173772df84da00542d7f18927c61b31c025d82c2d78d857c4f222746c59b0893ca0fa1fa0978f5703f6647cf1990e35520050470557bf4da0a7cf7c52059db5eb71a08d357d52d7a55f1f74f05bbd5319a474e8627c24108a0adb39ebd59094a284755f3a35b47b78f40780f7e2998cbd0534ddeb0acffef3da1b853264e3fdb8ede3e222aa248e197e5dc9ae5da942364abb737a945036a8bb569822bc079b238e189c88610feba05e19ee6735825436014151f3ebb4cdfa867be18fab146a76569753b079e8ec619a8e276459def8e05900e716aadf09ec8ccfdaef890fe15e44497b6fe589fe5e60143122960dfceebbdb2a33e573076cb23ffbd137642d9c1fcd1f600b0daac464aa1424c704b9696c9be7eeffafcb7ca46c17fd4ca22bee3a547e27f01bbd9330432528fb7a3e06ba57320389ca4557315b2a405cbc8bab35f43992b77de565e508196f2c36389398da5bdc9f38a166d24bc2a3997c1b0bbb951cd6c9da0314d2ba06f0623d4e4b7f92724da4f99fb065a9937b2ad2f0512a70a6eec799fac1db850958b155caeefd3dcbba58dc9a79de56a55d73d953a76ddd0ce5684563001659a954aabab3fc9ed17ce1f66f7dc6a15ec251dfb21d7850f3e74f0ab1bd253ef8f5afb7f80980329113958ad2ddbc8fd1bff08dc9724f5740e22c8eb8ed8d51ac0ae903be6f9d5770630a31b0cafb90d038201d120d37840e3a7ff0540af591ec554df0422d4ebbb450ff49c2677977c26f36e4449c4c77884b30ff2da011db35f6a0ba70a4bc69b05c42b89807a05d4ec2523102c0df516bba11cf3306cf51010416310fde81307b7f78942cbb62f348be137f8236603b9d5e2a37612160fc3ed041cc3f25f914674e95f346dfc6438c91d5d136b9719fa24870993338b37920266ad0f06ff3022294bd59a6f924c204117e7b6c4dbc11e4419220e2a4d71338ea4c2d6932c13ead7fee6f9665e6282a05c8efce5dc4e86f2debcaccd1b081fec325965af3465f49aa6666602b13e1bc6bad0a6b994af5eff54a33cd8d98db41a0496caf3aa9545f26c4b5dfa02767662123e5b96c37651277615d2fb21eebc11a07b70851e98568527fa88d1e290facae38085c93e241d690117dc4ad4bf864838d36f72ff51a3eebf0583a64a02381484fcd0037fdf82eaa8f695b65cf223ca222df0b710d4b7537d9fc74630c248cd9534bccf7b00fac736ed22c596cbb3fca39d83ec403266c95549f675e3476f6954dd4ac72ba81fa20b5643378ee45ff7c36522ca6f5624ff16151400567f4e6c83196de488482859e9da7d6ab06e6438a967f4e458f1cd7f00d278b0a8ca71a23d0302f8f059945c075c11864c7d075aabbc0cee963dc98e8f07313369c0e21f09a436bf2e3c7c882e37c257a34f9333e09fdde0476bbf6342a857d6ab229ef941fcf81de8e868584f9f144ea452bc99a25858b528bd3e1b859d74889189859102383ddb6e262a57c582b4afa21064d176832897aec0c6be3c902201835bed7b5cebd806a17d779cd451a39841cf04ccb9b8825f3e23cf97c925680d564c7d84cfd359a10405f7d4814dd7518eadd5530a9be73633f800a0fbf9ce9d114c7e060c9eb7794146848aff32fca4fbca173edeb431db614dcc91bae40a700e20364b480a951350bb6e2e5b0956f06cf598b76c794f08ff895f38d3206620e14b9570abff0bc04332a251b5d9fddf701ad291237ba8de1628dc51115076d5c9fbdeeb65d9dfc436ae5765623f8d7b4b6988332277cde7d640c722386c13ea8b01a8238b6c09af9ec1bf51755fac990ca382d3ce4baed38142a18ed64c759592fc68bd957042b2fefaf3f90895e12253051da3eb5fde7fd648c547f83200bb1a6b76f540c6ec85d6f82af03926ef6ad75e70def8384660ba481ce9fbf895c58061661fb31f62dbb3ad40bdba16523c55f1d7e011ec4157550d78faceec4451076b0f4bcfe4f4d4cd2f95c8dc76b3866d9be266b91810686288f58e608d911e59ef91a0199d3323d67f761729fe53714faffe0772d6e220c1e711076bc35176a4011e21728a793dcc1bc92ec34f1782beb163fdfa4d327cafe6e063b883e6a3da5b2b58d40f80b62af45af58f010fd6e43660b6a2c9ef587b6bbcb7a5c70dd2d892f2948a3171860c33cb3b9a2660d8790b3b4618b376cdb1a4af1dc440be7a751cecdc6a0cd7ff58121f52c53c17a68b28a38796ec4ecc522086ad5e37203cebda110ad8b0730f208d792579aa36e7d1beffdd2ec6b828d2a6c7a4863294b504a3092df203b9efbc99387fc0519ff8657c4a4b7b9aed024b4e801b56e9c70c05a2a017aa6eb01ba2243a251a13042b36aeeb042984d1d37210778758246326023b11a0860636793dcf71b691a9ea4562517384c3ff8562b428c4a0d2380cf5642deac87b14d1a0d3e0adbb9ddca9eca02021b5f240e0f749dc00a424cbc37bf1b75bfda180f27b05047b1ea0a009137f65dfb9bd686871d89504eac93a678b884955961821c120e21ad1a239203af2728cfa6f95e098536929f0e3ba8546df5e7a16e6e6452192ded89127d32e7aa1d81673105ed2a22fb7a8b6696c3a1f85ad0ff21882dc62314056cae111305749ab1a6197e355a286252df8efa0360f04bcbf7c81ce6de81e9b0c96286a05c3de6594b576dae5ec6b266a796ccfe645213f797c26cf1bf6ddaafa47531d00c475c61fca61c877a84cf2604e91d923dbd1635d9b597af76da8611c496a53bec303a6d76cd3dc501b45bb57a5bc70fffe2caf7ea79461f929923e94b59e657243a15cde77ff8494dc50b864b3f52ab6dae5d9f4a5c7ace5ffea00397fd0151db558bf16e281621cab4050c5936701c154fcce7610f3f51f423d0d4a4acb03b17617f0b52e7ee57ee0944fd413871346754c24be06a35d85c0c52a769053437054f4143b34235f85342320b7fcb201a3188e7666fbbed6f6534f63ed01c08326290cc73392090e7ef7aed196974b60f6ccf6b710bc47039391179c42fc7173426f2de164c6f3d92a3c6fe0604e2a3249563b206591c61fceee334421715bc8f5e777e7fdd6cd2a47944b7e3453ef73af5dfe8ca2dbabd898913baa274542cac4487c6e231c34c27fa140f69143492212ed4d2266c0f4477d55462c77cd3e03b0e0b55631cda4233c8bfc475a50e5692814ea5e2f4ca389135112e8f6769ef4bb0e91c1ac62bddebb8c653b91c8b79fe0e6d3c17303bbe63ebeabfbaeaf366f77bf605a58a13b72462fa1f52fef6cf0010c4fd32dad1d113e48af5283a9a136a063b8379559726a530cae74d68ea9ef52c554118013409063d91eecf59a83242be5443fae277c07c12433e7befc1b09ffd812162bf1fe38a6a762fa211fcee505df1018cb16729bd9c78c2abfdae046a6f5ed320daee12250f8e95762d20db4232a13fdfad819147fdcbc24263346d98482fb2b972b5c537dc0bed4cdc9b2667ef99939968ac49c7fd2876d25a3f0206dbe283ac584fea489caa66f9769b88a43046822ec418d61740de16d5962d644698ae90b414941d908aa5c16d2d2df6f43df1640ae6105d73f86fe7c99ca79a38c734496e398c29c6b9bd5a7d2b51c70a3712882ced65a6447131201eb6996a7b89097000e055ec2ac7dd30efc1c97e78a899b97c97556335dab3ed0599559e00674c86dccde14663e87d161d7a2e076b03268ea6b74485eba17fddb0afda70341d35960bc417e6a04e71aa9fbdeb2360dec44a1b1a091b040da4a3d771a70182d6bc869c9eba02e18d74c66f34ba15c69ee1abae229d640d4aa00ee3d2773b5ba08286581d335642ee40ce4dfa99dfd3616123eb3c0b746456e5b9a3f99e9e776226dc1b8eb39ece4e71540d70ac3b112ff9cdff74e7084525167879942d8cbb21e4b06ee5ba2053effd48164e58db2545e4fcbc310f4a462e9c22bdb5f6bc104f078274f6845b035dc7e86e53d8d46dc41dc57296a5c4d0ef98895af80e5cd85eecd17714d0799550efb049e4a6e25647793430b8a97a1b79083a93f463925c45dc5f2c3e9f8f7001f03f362de1dac7a151a40197d5c6bf0d783d43533ab2ddd1008284278c01955c0b0267591351a9638fcbb6c437b0fc385b0361dc84094b0837ac88ee9b9edc32dda280b68fb09a70a163f822fdd883f2afd3dd76e6acf569ab9f9beb2d48729c8be429141f1f906ce4bd1967ef52c758105a816baf0567cb4820d76994a60f87b1bc99bb0a6a7d75ef059434b3107a2e9bf9f59e31c6c82ca4928cbb284512887270227588ab7686e98f45116ba23abbbaa6332472c3fa2167ca2aa119b4642405389c6a99c0f1121bd629e0a9877abc730858c44876cbd0904cc36d63b3ecd2b1634395c70362be47ceb192c8952fd59615171fa80ebf3735cdd562b295659b050f910c928a2a3a8ff5e5f06317acc0ece3930e7fbc5140b90e51780d34df162c24acaa6283675047d7c85df9319d0ca3065e2c8c701050921b65dae2470949fca183177d3ad29a36266160b01001159c612645e61a5133d228bb892fcea93bc09b113a44315e5d68b1dcb0684663420147dfdd280baa9beb3d06afe34b81941597c1865587ceb99417727f44a6b63b995330f173a2ebd3dffad396db47bb1d69f37def8eef8442eb344808e25edc68a0b3042eb6e2f6dbaecc58eaea98bd765a2cd86ff6bc2d451020a45ed59dbbb6e7ca1038bce7c686d8c5b4c5c0af4bf4c5648b44e219e71e774bf01f701e32e355cb6f1f41a861a7d1e912ed585de8c54ee4e728f221b717c42ecaad0918fe52c2a4de4e0673bcc773c48e568a401fadef1919a4c45394b2b986caa6c1d913e5141b7539d87f14592a02e73c5f313943782a634c84f4c95ddefef5b25dbee938e1a821be17bac7713751ab56b35189ecef5a8466c3c7cd5a9b86a0175c1d4303ee5f5537cc0799e52f8a9547db790852abbf84a2625f090c1bbff4c98fbbfcffbf95b7e7223c83a5e43273a131813ac1372dfb46477d20f8e21f37d282ef4af293b9de3dc2687427070f916363674d06cbaf44b9f9707507dbe696e0e6a55ceaf94197bb58997d2be72b422cd7764f050f38dfcbefd0c2ac98156efa6f7777d2b38bd1bd42c33bdd5e240ca04600be0a7619c4751eccaa585354ff1bdfa9854db188a192378e001aae7f9150830fc3fbfe082cdc9d6fddaa6033d1c8a6d8a8bd672b6d8e6d6ee02bf402d6a02fa92dea905340103654f611d9edc432e094e1b2a362437f3d11fca6f2cabe4698d63934542ca786d2114893a4470b7a9dcecdc74e1bed8ec88de388f90acfe18ecaa75ecc3ca04f952fe0363fc77f628520c289b8db17ef6910b1c90942a18cb9473012ea51ece0969b14dacdd467fc54bd3128fcce2f01ce85f97e7bb88e012b83c61aaf7b555ba47625e1c85e3bf5b8306a9acdccdc8629b2fccc11ee45b6e4eaba6642a2aa39b6944d1079a998657cb7b9cdc301378ba68b036b680ca68091bfea1d316a8f901f9e3d4343cc53b63549a45f85dd61f9786c8e195d7fef1209d010c083b05cdf63fb5598d05871517e8c8c36b6ab3182467e0739e3df9988a55c5915a9f686f3f937fdb616ea0d613a164fd0fb321c324d153b9e28dc59f7068222bd637b3e80564e736a339156ca2793c310a7fefa9c42fc9fffe743ef97a3404a82d1f5ca68ce304197ccb1dea5f68a7b7390b5e8a11447dcab4a08d76da4acfdbdad22d7e4a9386228ad9f1cfd3a600d7552fb4c06cf9e8fd09d783eebffe3150191bcb13369d49cb20037c3a78f281e682a6f0d491fe5f30bcdce4e1fcdf8e70f6c6a4299d13bd59d6d384eb4a420d9e400a6500600224a00b3c9aca9ba3b005808d7b26fad1dffeb1a624bc0bddf0f399747444681b7f7d229c0326216e5a6d629964c74e7b266ee97937dba6ed498ae9c2b09e654ac154a57f823297834ddf58f5a6fafde5ec8ad101357f8558907d9792863f3e97a9eec215d6836bbcacc1ce781d5f179e283d784b4a176fdf5fd9692b4d43f18461a3bcadf8c60ed798f98955e9feed631e5f7301f3a5d2940622b63985cbd6afaeec575c1b23562cf6bc7fd9f5d3dc4a1e6e29298d7f2fb30c1e0eb540b3f26ecf7d815a38e1530057fa0bdceb53bff3b4ad8c2157ec1d4a44ea8e057f79f2d034114e7a569240a2ece3a000c5b623459d8067edfa45708de59f61ae57a556e741c2d07b6f1c865d9e6c09a39a601b29fd92bb6bd2d7e1fd329ac499ed1b8fd8525b3903b66d127e62a9c6f9330054e503ad8fa13ab3ce7e109350a2911633a07ca0333c0207886b12253cc946779f034aa66ac82bae0d480e5adfe2a0339cf9f74e6a3b9651dfa13eaf6a967245628dc6da7dacd0765d09543f614348acceef58645887df92fd794c614333bf6e273c224395d5144d736fd71e58081e6d54ad1945702c4717a7d42bcd90922920a7d81182ac3c963ae247c7c445bc23a96cd255d31bc39efdba28de6fd3b9019fec6167922081bf174f556ccbbb7738d350e1a558d2aacfe6ff4459af3b4e912bc442e7caab22787e4162bce7a306dbdf85a99409603d6b3f7e4e4ad47c6166805cd3a9d9f3b8bdbb4b7f357ef83feeca8fb0f3a4da81c3777c6eabdf07f94e79c0e367e59efb368c33081f39ce0b14d4fcfd04f3301ba9480270305f9a3e459b53ee6834e1f7b94ab4d7626a5f36c937302ad3b992541e5d77c9e242583677efa6bb86685fac50d1f9746f5d0cd88ea9ba873342549623f6015c068b28784aee1d0fc5e04cecf3365569d6ab761b2aaed35f857d824b07f2bc26e88820b1452bf0cc0e69fe54fa1c97eba3f7d0311ff3228bef8d7631e5622d9829c5fe640e4a95d1b5bf8ca4e625dc063b09a5703502c72ff36128cfd7d83f64ed32b7023c3ac4467645d71471ffb9eb8adf432e606af6c9f9d2d2b8e7985b893bfd5a7646ebc52991afb45b7864d20956f4b81c4a533625d3c15138fde29dd4e939d50cdba6e801ede7ca806afad9752e73df4bb1d0f26f8ae550105fee45e391822c47ec778ae86bf62109528f8ccb00c2c630f97ef8bc8d438b62715dc682380d709f04e8f680c4b31a7b0e1d09e5df5d0b3c2d6611d73205df3e5bbdd6699c1bf82ded5c0f034bc13059f4c4ae7ad8e65a1d29a7c6d29dadaf2905be1b78776c1c935a2c29f0b5f65ac172c79e5e68798f3a052a494d929a2406c7202283e91d64454f24eb7e6cd858d3eb1dce7ac5f3021549ba964ac4ed28e307f9bf9c11dec2efcd7f8b511e130a232fb84c778dd37828460732f9f5eeab35b1264966a4dce6256bb1944a3b98aaf621f0ad5a8e04059298789e7dde0f1ac2e95dc8e4679443c9cfdd116df015a8381d78dc75a566f469b7bfc919976cd6f6f32c539f0fa5dabf8a423cd7d3b776830a8e6105a9b4471612a64589044d55183cc24d457986053f265dbdf8591d6c10c43d26fa1d860077c0e488e97fd26f594e9401eb9b4df61982d5cc3f81ff7dfd72d517add5a158a643f853c395becfe7c39c660424221420fcfd2b1b4d7d79dc9dac283ac1aa3e4a8566b85f876f227ceaf50383152b3ad58b77d958d426b395ea9c87d0ddf582d0292fa699c708d614da72fa13e48209c1e1ab9951c8ef1fdc2d42ddee3d1b6ab94c741ef496771974de08693db098ca20d72e3eb3d84d7828c4f01560fcce969199f6bd07f5e3c4558df7dac1229037b0082dd11b27127acd80a30e84223d99db6c5a187562bf2b66180f973509619ce04c08af011afc1e034a5ab4070b8537e1760e3ef89be97127da253be116548a72264dcb794a701d766d4732f01f703fe8cd16fdde4172ca7acc902ec0f2bd5e0411fa7ff9b6c578d290775235f845261f8c9678156682415cf16c8a77134dcc5049ea5b73684d738cca81588cdaeff26b640bacdb9eb0b750e25d0cf9577193fddc5c763d1d442fb31ffc96e3a7fe5042f79576a4077fa94ac2a4bbd3d137c22ff6497a6a5787165fc8a5f4779687ca1dc57a68e37d4b9343e2320a1bf7eeaf73ce1e370c950594bc8ea4070930fd04eccb330e4330a76f8cb434fec44913a0b0a19b47f443dee34b421c8a42e15f2dc1efb0b94033c5b674bcf70c917743e194100d09df29bf7e14f7f380f7073e49c022be2c4b65bb73d22727b6e9b541750fd7e21103d97df2ae1f16f45e4e908dccfe0ce0baf190a4c629aa2a81e99aa39b9a1b30da675454e5ef80f6e8c95fac7379f185d19212f8ac72e0f7354c2b465a84fecf54d24cde58a91d69a32a0703809a27254ca762d4fa38eed88248521c104e8dcb3a0befb210c86aa89e6bbf9e9ae5256b597c3da3850c0425e2567f46d2e17a92c27d95304801d1497ce8826397c52cd576bdc2cbb636bfdbdb4d951a3a9c96b3a7882424c68f6422a5434e921c7e301ff025bf6b378da8ed1c97527b6195b424f998a22f326dc6cde2e31d3d965a52c19cb69afe9534a06ac4e1cc22bf19b1fb33097deacdb7ebea27f72480292a0aef7dcff070b12536cd4003e3f76bf510a46de7b3816f4fc33d124d68faff33c25fa81197f62469299e5cdb70ee0107f2ecbf177b9cd55c0c1a987bbfd93c1878c4a855dd96d2c6c83b12afca75d06147312753dd0d9c291257e907612a33945efa08af20a950938eed0b5698b8eeebb9793058b61b9f7f09461f44637b834bb65591ca47d09480fa281f1f13f9e6c50053a8085b21f131d4b040a4149c33274333ca7da5dbc214906e474a244eddaa1ac3b9622ba2044097b7cf8144f40041242be5f67c1d44e8d6a45dedb10e17df20d11d59e761a75386cafa3b143d088822fba4949b3e9df78f76d655bbc05942f0447c2d17692092ca81e2163eb906d367ebd8f35167dba31735f6ea3df610fe1bfe1caaa0b4bd70dbfef629f1024296c5f5c216c866de4ef810298c1b2ec37dfaae41f97757de392b9f28833b4dacef6b46a52ac2b7c36bd74574a8d4a0dae2d4dad0f29cf5da5cdfd76085d42c6ded2ab327c9a26245960b41950f6fb7e8ea6e99662038f343b264a1ba4c493e30dfd19a99624232a8e44747b1211356363a2fa823c956a492da57d1f315211e4f8f92be63589989c57e6c88beba98d961312077197b07685141660d839735b6966d2d9d1d95dabbb8548e1f9bb740b4fb2690ba23735aca9e75373b5fdbbb57b653ad5e7bde2ebb53125534bf2eabe56c18ac8043e6275aa9a147fc9d64c9290cb632be2791b5a2a2d733e92e5b5a5dd555826d9d843efa53a403b2aefdc2cc6f174847448c295c45bf99076479ea5ad039df15433b10303f9f6db3e096b3c69f2320f8b9f6231d4d6e15a745de845f3eb411406045930e18f604fbc3d93a1470cd7f27a7ecf87426c1928df18379662f3682ff3861b5d60bb8c6b81fb7bdeeb273f8dceaffcf8df5fb681363ec65afb1558b4d39beb15b100cb835bb4424d7ed854370fb0885a2fbc64f8008591bcfa6b6d5b67ec6e0dbcdd964d2e758fdc5392aa57f0cdd86c2d3aba84ea39bf9d721f1caef4e3e104d68ee71e43cefd56a27daabd43e84479dace03ccebea34bf68ea73c27b66f2b044f33b6279d99086f6b6a6f80b3679279a0a8487113056fe95b956b57dc69e8febf2654fe3ddc424d128563723b93855f198b11198ec88fe073a5dc86357f733e5c189594a3bd29787e33b46078a091a93263e3a03887bb2e29cb39e61a53980f70524f0abc428566537e333404ec0f9c932bc1b6a61d38da006abb4cd453da03fb903795118e0fd90b16b0212c15275ef62577c86d20053a27070054066e67ffc61241ca1430dd34e0d0c2d652592661ba0ab5993f6a61f7d2893adbdecdc808bbe1d0039e297d61f3a13ccaabb5165b87f9fa62582029f130c9f1a3d55331e82f70ebeb08e0adf5b2c8c96aa1e5caa30e1249bde05514c708eb907a73b56fd05f95569e41f465d4526d062feb5834dc58cb9efd798c6598e67889d11ccca076391e634b9843a69c71d211042606a03e899f72830b3b71fd5820b7cf4107d8682dfd04d7d8cb6acaefedd3e96d2fcdcbdb33490663d42039b7bfde4d76ec2319999a3209999e0955678830e4965447ee078458a77a7aa78ffca569ffc9325e21874245d5b3f171092d72bd43713c0985d188939db580ecec033e5f4daf8778549398662951ea8eb4f3b0f9ed119845c969e7c1f787ec9223e271204ee0d5f1a74f1ec6e19f80c96828a3fba57d83ab1b825d580832c249c4f5f49d5c1df8c1967e3dd24fa1658f4650a28caa25ed100be506c307059783b6d1d22112dc7b1ac697f648000b1e545be8a5e3fe84442b21f1596060157daf68cee32fb2de2a8a170d124538cc740ecb583a38049b04a41e662824688d6bb89e7c11eb0aa42faed07f8e1503a839da15140971016c6e569319305f1a9b6554152c537b2796657d2c6a5bf94a7dfc0acb5795aff54b00771c4966b2209e80e1caf871658875a3551b10f0fcb12daa2217f4e3624a8ae34a5fb19059e6a71f41dc1eda86fd7b8648898e8c967644be0a17b1f824faf716050b04366264411f302415cc7bb1ab0d1779c5df9ed177abee7dc08f4360b0bce0962428771cc5a209d46a0fd208a28aeaa10320153036eb3aff1604d7b17c0ac4203c6cfb18432528cd40dbd52fee253d51730fcf78dbebc76ca8a6e8f63b3b2cedf85fe3cc6560863c11a7b8b6a7c93a01a1492e7ba58f1ae82931d6afba203ed8ac88fc2d155d325f1c7a4298f450d62c730ee5fe90ceb6260c131b54e369fed661d338e3900df8f386edecfcc7a7d28aaa00559d737c5088ecf2c8e1c52ab8440c116cb815d0a2f834377b189c3895848920b719a1dc48a1cf7395d454c8073d554d3fd09b35aeca44252ee766851eb13011e0eb3d98307aff098690ecaa1f15bb37546b03477d47adc02925d60ad2d54f798c44b490211e2788a57da2780875e0d5afbc40b257ce1922114fa9fb2ee675831297e8ea046b22ddefb2d980429432758abdc99a2c8df1eb93bd8dce7f770d52475889337e8ee512ccb4a5e557f834d44a8e6dbbc79544736a9de679a5b51191d740a1e647aabe31ef88c473c14f001a4a8400bf1e4e98f8be91448b6ccb3cbf9ad18f5bc506b57c424fdd971c8497b398772d7a2f9787e3b23aeee07d8ea33129aa1c5b438148df7d560f74ded2a62f39ce2c4c441a9f20688f9caada53369cf81ba135eee4600debe9d442d64531682e711f61f29cfed120f96454fb990a2724647695526768aaa7db04cb65cebc329defdeeaf8a77340859c67a003366687e94a42e0fd5750a17d6eb66a59cb791854dacfeb09c159d11ffabb087801a6ce71ae59c32f52521b2845175f2207725c6cd34af2e3a2c32287789d1845535ffa4c065f8d347602a338ceb41555b0181a5987db51bb03dffcd6d06e45b91aca840eec5a43436cebb0c47c10a7356e732321f8f7f3c310f886ecb3a68729a823def6457f21bfb31994e4a1c69471385b2c17e203a09f8c57f2ca3e46a7af654e1551429f779907aa48579fdb70e33ddd5241cfde2f11e99376dce4d56328fd93922c63bc270a4f4f3f07e9591d52650ee046e6a3d7d266c6888db592ee4b62fc1462688cb1a160b4ab0cc5811c49089d64bf0b30d03dc6b465b2d2cacbd52779779a179f9df2279938722e21a25c3175e0b48a8668e8c2d9e71728b80e20660473077cb535f6b2fc72e36c8ea53edb1dab0eaab9d1e327abd04d67bbc85b4af5f2097ff196a37f05e5da64cd945b409bd4c823dc1d03af762fc40e8cbf04103aad0be69d9d2495aba4d6f42f04d9222689c493146ca0933d036ea9533e737196a05212be139d38b2a1a990df4323d7bf428857f5307fd162a1bf2bb4faa922ac08dbbb496f80718ea16cd742da76e938e3e34029269a4f87618c87f76e694bd568ba3d1ef0a619479e679c34e45eb693753c37c7406a76aca1db2865e95f829b45721b10140503e261140b9734c0a7ba4029b97425ca54c6563624525d626b67a359b3ca24f52db538ef6a9591c16ccf5d4aefac0840e9e7648eed1e67c6119cd3b25493dd96466960d0b4ed2831c4a1fbd24a862b7721b83e36feaa368ad9fc07b9b93488aefd319b118296b5485af1339db7309f1876e565fa1a86367bac8ed9428463427dd95be340fa2a7d8a987bbe9768826532588d37e9ada57578d180185c7a266dd9301587e40a35cd8fed8c11fe872f0139c25ccdac8929fd7a679756652835fb0069058ea76a5dab22bf6406cbee6d2432cffcdff169b31267733d3def749fd642e58f289df27483364dbfbfac6d9a448dc7e6765e46b244f3a56336f080b191d76763a899e23a414584509f7e8fed60e4d62df8452910711dde7a9868e3b35f0cad52841194aa8c19fd7dfb88e5ec22a56a73208dba6c5a6b34cfc38f090cbc423173c18285ddf023287888443cedb58771259ef1b5b559180b1f07f7e78873c9b6ea53e34cde451a52784a36d723c651f80db0b224b4328eb8a0034ba22c653639cca5821ffdfbbfa383cc6d2290ae038393b7c2fb0b3613cab3ac2d503be9f2015dbb6551185168ca287dc15a5f1034b9ddbc6d9aa3798aef70e4c36c8533fbdca198904d9de173a5a8f43b69497686c9e34e3d9c941a3c6f4b0f3206a03cf73062236f4536b4884f2885709baf6ba91e15a0e19cd6b853599a1612fadc86ae498b77f07e29f06f41b46783637c54f267fc2b5f649472b77680af587ac7429c025e21d1184be64f4240ca7b13f5ef02d06e0c284f5ed7179b0d698db02d63ac2c74b63f6d5bd9b73601954ef0947ad743324742895f62a2f6347075a6ddf10c7c1fea60732c1643681d92e2ce9fa84a9c47b53fd623d4d09e200aa5f13835f38ce25fd45d6f66ea82c5bdc5044355d4215c83968994030953671ff6b076e45a1736e828c578b9383893a5c56c0246d3a91391beb8b696b38e0751989ac3b25f5219054f4abd7d276aa55a953655e6beaf1cb99ffbcdda65f7e62499673db53ebdffec12d62cab8e7e1f54b43dd0b6a6ba0edd6724beffbf8da922436b93f9d3cbddfc5c3809e038f494f60c88c0042171c5f0e2c970fdfcc517451c373512054e65e8e752be4f0553d49075434d13db91dffb91af4bff1af44b0102264e48a6552d820f87cbcce877dfde675d90ae1634f3464f764be3e82c7588fcd02d1e4a5277a9da0864951aa9c1c8bb9bf7b6d292ff1ab666b25a0d1e9f365889870ddbec410520c27bd9f47d3aa8b008a8fd9eb3b7348fad37a0d08db476de7c548a763d4c819b491f784a2501e3f8619068ae518061d28716abff3816975b5987cfdc9b162032caf18aa1d1ab846a853f27f30b2cd3e4301a9787fe4a79d7cc4880f992cab16ec6e0af7a3a862615f6407ea4fe883cfcbcced9d7251fd281f1a6d780613303c29d6536910a19f8c883ecd0d1b66eb5d081f3ce987540f97489f5d1c245c94d7234c16007bb1d6cd9e38493d0e540e425a292c05d69dff9630ee4a31babbc266d737786dd4ba2bc87b9d481309528bd2fe50389397b8b2f751ab6710a5a13936d91346c73197986c091df28df3b8bc70b8a6432094a9c1df7a653ad8b0d78a0cb09c70eadd257c37565dfc56810f4353c9f559c9b304782664b9d7e2f0a68f33e7ba18ee830d32bf0ba3788346c2d5731fc245cc8f1cc3f66d40c2c95c58a23b5730f22f32e7ef0d8e608d54396bf16d4d3b9f6be8ddedf63d778f4b3474598e6870190a14afa510724615bd2095ed6944d8b440f83cd59855b84623bdb342a7e54e6b8395c2bc778ab45b8ec6409be5bc664e9a5c0b2cd23b81f179822771e7fcaef6c273900f8bf9f2a02ea329d962288361495998ef248186a7e769123d265bd9b9942a9689c4cb4faf106048b7572fdd5e1c40c2cd1825130a114b1e69b5a5d513ea22d5fbe22c9bcb98ab638124755f8a17d008eae64c98a982761f16fc27e93306651b8ebab8e3caaccbe8b250102498ce3503339301c58e018faa5baa44b839205d9d7e17462b3b1f705444abdd8685114b466faf1de7ca998d036dd0001847ec27073dbfbb1024ea36e6ca30f7142c6c13a8cf29125ff5021dc8af6c4a94073187b02b9a69e700e18ad0296570a6ce410140004e5d7c357c59de8e9b045fa9d7b662e72897f5d2fd2748c40e3216fcb856c0bd9e81253f026d5f21dee01af26815c9d4fe721a61c6d791896d5a8b51ff05035e591831cf6f4f74e5e903e65b6dfab4b8e5590b8b52a362bc0d5e87eaedf8c29c185df7c7e16aae86b4a44fa4b0d95a56da64d44503982e563ff389b49afe561e9768eef6a2c13377178769568c9767096d5b60c63f76fcbdd668f6b2e959563dd18d0df77987ffeb23548ffecd468e3db1b1b5ab88b94e434751033e3cbd314910458d44a0c0a60eb8cc7b6b1f51c134a3e1853fd511a1f753422290ab43610d6f676745d0840a9cac5c95ac0345999a58fc59f5456d53d6b7bd2e98405552f7af9f641f18f36724b2a3f6969aaeb807b2c","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
