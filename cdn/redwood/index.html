<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"542311ca33901870fa24135b3ae3ab3bf6cc6fdb7352088a0f23c9391591bc192aab233f0eb23ea6eb3f88182ffb8caa1f25c9e39cec9d923f06cb3c4f5aaea1ad0988b0e419257ae2c8ad15fb4f90a7a624c0e4cac3818625b91c005f6930cca2ac9decc34623b0b279de8aa01fc692a6315c7e26f7773187cf1d57a8ceaa86a4445eed1b72326a32e0eb8e7513dff4941d7958522123ab8e29c88bdfe974749772aff7209c5bb95e173273ddcf8f531ad3b11b8988fafab9c1af36a3e3387da6550626f67d576608d290005390cc13fdd9961fdac6ffc5a68ff3d6fdddfb4ed22f0695b514eb50a7faed15f593579cc398f10ef140934e9a19d1cacb95aa3329118454a661bfc9b59fd17da13aa38cdb04f57aca618c33c292d43328042ce5f9aa95baa2418d79685f2fac98ff986d13cf93e1dbda300c4dc9f3746efc6cf0219bba7702e1615b51483acae0aa0cd9b71e9b6e099b769c8508d5cbc8b3cf23657c5d6a37c3f8089d4578a3823666d3215cc950e72e27d79a9865a30f1773a32ba49008b3caea7c2cf80d075d7d8917ba4ef5f016c01c66ddf10a104880c444ee3e65139f6c4c0b1e217f68514d7ebc92c0ce0afa91b5ed326e7789ee30e66f4c641b5b3ce09c1010033591d5fed9720bb0a3acabd0f9f40f9c365404cb6f78a1f118c1c3a440a2a7360fb3680aab20a6b83a26615985920810a430582ecbbf6e81365561859c7d92ab8eff1fb03856cf1807c6959f3af78955df70fc85fe39706d7f276af03843318d7d539049c63363caa065bc01f7f1e97351a7a49cc5d4cb9ebec1dacfbda8230375414a2bc87c5d33371c26bc87e1213a92eb31ab3a7ec8253eb8bfe8e37bc1364ede22d6d8b55426f00f9fa66cce3d9be12d4c01ff6282c9e77d4c2a89a70e2eb33a14601d65aea4ccf38b988256579ba7928451c252b97ca64b5d26b879d765ffbb3426fbe8094b033642f035f465880261bd00d078c6bff6492e8bdeeef41a4e6fbfa12a8ead1d0c5be8668435c873a6091d2d0a35aba1e09e5d7c5a27fb4d809129486bd9eebfe611d2e2c60ffd16507aa93bd46d3c4735d62198bbc600bfaaa8e0eeecfc6f9d9fede9ecbfdaa66b8965c084cbd89e1560ac5f5c021c4e8c1b50535fb027e7bdd19fa71725832cc2c509705c5a39e86990119b1523ebc53156d7e14fd6551ab066cf050c040bbaca1228bae476919343d489c54d9e47d379e5664a4402dc487bfa4f18f83a4b0e9cb85ccfe81f1459422cb1556ede79e8165a67000cb3becf06ba2fff96a9a0841a00c84583288999ee843047103ecaeb304514b26c7dab5d1093af46749951d7dbb4d309d4d9b29ddaf2eef7b5e29ba43873f2b619d6ece347f7b74ff4d4662fe708c58ed9ea33a75697e73d88738a853a18fabd57cb153d37f383edc6b5bdca1ae6b3e6519c608394d10a15c017c70c947f190abf87f31e8a381a873d4b9f0e292d3789007a5bacd46e285a9517cda303275b6c252428feea7abdf92a4591c9487bdd906ab53f5753bf93d3549f3d6a0371ec2a1b2c3e695d496e5a4028c7a7b15f971199797a6cf1c5bf455404f617e7373dd04d65b2b5843e4e58f9fff6f8f6d33325520c9fbda1c8cafd6e983cb47a7ed6285809e0bcbb364ccfe8f0010032fee93bc845e265e93a8e8bf632fe9665a824f13f4514d448787fb034759ba8c7398ba17143c925f7a1a9d4a6c2d35a9ac411be8e3987ed714390559494735520943ced4305b308ae5eca91b7feb801b17319d894b63367b556d7000aa452ee100a517bba1d498ecc948210ed5fd9e207531a29bfb79fedd4ae8d632c0f6f542c7ef8ba1001479a49b6d07c3dbe2e0cc61f56e3a51f4c362dcf259831f6ace5476ca8d9c7ea2de959a2dca3a92213a0be7d030710ef2e2e2ef3278e8c0b204821c794c27ff4d53846b0778c13ad9f678c011020bd430bc6863d7c8a11fbed01e3e864cb96cad9b61ab74417479a61efcb9ec93589a105c7fa9fe60d72069e34c092df1cb7fb6e81c5b878b4b224f1306ab8a16624c99cfeedf0674465638328e16907c6f54f7185b07430590c273166319aaa356c3cdcee0a238b5832d3d9425c28d049f16f215a8a0ddab91d514e82a53bc25376610bad6f9561254cf099bd1d955e8dd0e44be1e20d434ee830b91f29c6031d4b3c5c6ca80ad32113a5f377975e6ba62cfd5fb96673ed6ccad39aae224a554d48a6e34f14f0977aeb86434dad226329e5d162641f0c810f84e07c53f9616119fa0ad88ef05be4007563e160887f7367251427eccc32d2a98398799e6b2e4494c2b5173846a213e48d951b563952f0333e5e7306a95f09a2aa40039659260eee3b6c6347fceb3f0f56ada6f948927185d9f77d10f7ce4e0b0481075d6fb6cf3461027255c93e8fd5512159523a0730b05edf22133091100a9550c102ed2b03523d1b8630b9ec675ea7aede4f9e838f52dc4e55a196855912a0d645455ff84b282526e428ee94d43371e07aae4b71598afce74480a91455899e832f92eab50b41b7892043a815e02996b15d8a747bef9c03af152ffbf452bb1567a2fee117a1f37149660a0db25778da00b677a41eab3b2029e3d1db828886d03f3d59d7cfef835f3a8f35c1d19669825b39aeffdcdfeea7cd5529c6725c40466fd358feb99f661e1ccb643731155463e47244300d47a68694a2eb1818c2da9b1600a7d0887c38fba6b56c61adc702707a792297996ed2c7b0f6e755d7be6c8a9fed8d37d1c93d159bcb08099f6a0d17f70472c78a89e206037ba4e17aaf2a7c3b249d6ded0a5c6d09f6d5459096ca1e1099dd1b81ccd9e679db68921b2674ba575ff1f0cc3b96d9d48ee145c63df10fdf55a288d5fd1edf7f13b36b7a67784fde329788ec9f3466b9e763edfa979e9d45b6613d07b2db390ac71f5c6af9be871dee4dde2588b3fbc2d6c4ea4ccee8c8d4d43f6d425d7f18c4a87fa8cefb38064ecc4805b86c57580bc71573fad18fe5de7499d8b8c2dea42e795a8c69ce5ee6988de80ce2a744f984fce1bf6a6d24cd8d9a6ba0a7d321e634e603ee1a390cf13b7b1c3ee97bcd54835053a84395e8b15905b29437ce5c05875015206dbaeff5e4168f377e909fb25cebb915e9155b600920a9519e07687c8bc502d9e6984adfeaed34909520656bd2b390e9b67cf63dd34e6286e8ec91c120684b9c7c65505e40fa2b4e4e2e2460459e182e53769a91fce750666acb09a38a07862d612f65f474e14014106e7b7ec2df7d43213e89a15a90fe57229008fdbc7d4393a934fed38b10532371bd6f7516d6dcbd46700cc2ca4b71fc65b22e614fb936994efbe9b0462991c6355630d0cd47209758050b40520df7158f6518ee3fcb0c5557ee0fe919cf66825a34dfc6a6d364f9d0351efdb28a3383fb4c046afea91d50eb47e2e7f394d6cbd39d6b5a8698abac137cc9eedb957e8488f0cdd9121ea05e16c4699cccc20ad331f99bb3f0763c094872ed131b8305af09623ccb7452cb28344d23614c08a8d7b2266728eb58a62cbe854b1c4cd00076a7982e488c0310985ed60f8f389425d53c343637565c96cf54d58e6f4809094a80f3b799e91f5f049884b28fe3a74e936d13321e34db25cc7f0e007cea3868668a561f49146d17a505652ff7b16ac737daf23b56365742fa1b5b869bb15a2c2691ddf46e24518e090fdabb1bc38031cec53f9378a40bd67522669dc2850e417ce0549fedae363f449ebe7f08290814f8aad48e9c72da523c756c10ab34e4875bcfd45bb4710750e6b3ee86605a03ffa24222cf9b3532601ad6c1a6978f0b1436a85e5c3c08e81dd3f75063de93c9c2dd6e836d9e344e123b5db66b871914f97377dfb49ba7b809c15aa6747927559eebf9156fd258da4b3f1ade6eb5deda0d6e39082db5f3344f50a3f06d9c0bd12e7f5c13d22cffe62eab33a55527ea49584d8717c6281a1703c50d4c411e0c5a660f4484d373b16bf35b09f2db589068063184b567a3724bd0f3288981df33c84ad1d55aa1f23e07da9151fae07bcf45119238e05b9a30a14eb437ee9c84d9caa2e6740e5feb6bd961074d67b4e02446bc1a7ba4107a0003788be9359597301c9be389b8684a9664387f761b31bfd2953cbfcd48f07d4771c19dd945ecd05cfac5fcae1421d5ade790b0c8e44a38356048f726660c008c1751e27e50ba5215995a7ac756c9e669da1e08e54052b73d92cbe8389d972099405b3c548099bcc9cc374ed36b9455fd344034f7cfc558dd325cf11fa95530b06d37f9ef6ec34935ef649f3c1aa807bad673c2e659554bd7e74aa5e984a3a73b3b5f9981788cbebbdc6b117caf18611e77d895ef0e7df8c2f4f378920f9996213019f07d73f561a44f9835c5c4f1e27240d338471a0a4a97bcd576c7b2ed06792a5f16512b53b7d6644798118b6bc14320b43474f2f27a4e43263534690652c9ada9d5f56a95ae4c5e5ab0bf6124820b2aa46b223dfcd37627395230353e1b327e601894b035f51ca7fd52f8015021fb67bef692c8f6e9a92833d5be570e43c537da8d63a428c609a678c69acd226ca5ec632dcb16fa58a8e59f0853c690c2e206d6d73b1a3193e187783381af7baa4f85e74bf02158a46008361a20c2b1c11d3a506b745b4407ff31e59bd3794a8d9488bbfbee0fd1c362a900d09ebcc52218ca15155dcb7d267bb086749e7dfe0c37efee2949270791ef7f08824baa9cd4b7b048cb483b3e71a7831be544bae26909dc05c6203db54698f510f18b4704184380e0318e8987c4dbfbe07839df9a119b53cc80acb53319bfa5206f144c25005a26986725f2c93a3f80b06f656ce3d23373148b83a7a3298a3c89ee85b0444432c6c8360adfb3d3f52874dc20da5bebae41ec76504f4364543cdfe13ed9aef0d5a3da9723cb5f78822a92921d2e4da81b3c8688c85a3520d774ad4a0af50ab5d79945efd8fb6466f24a8ef6bc0e0c1195b3baf8eb3f742c5244917327adff802b8ed530288a2c9e765504506bfa33a8a6c089abeb76c616a4bdb609ea6d85504101b4ed5a0b17b07c4720f5d5bbad0af2583c031790adac31d2b5b058cbe8288f524ae34164727bce6830d855b8cc25731636aa9f19918e6d66ecdaa388feda58564b3b92c43978d2be0a87506f06301a29067ac760c19aaa729e82ab86315c48b2a193e905dfd4de5dbae5868a8d7dd44145a492239d9d84cabc9f6ceadc0f2b13b844b79f04c9782cd026643ca1b3b11d2df908b741c4625ab31f5a47f711f2366f8108f814fdfb65ebffd7dde70a61d397d8f96d83465393c903cfb3d68967dea7ea82fae2ab1b8c1d5a6bfa851ccccd973f72dc5e9ed66d226c13d18827b27fc9f0f46148a2416050b866615f079cd0647b6274885ba060d1824d36050a1eeaa91d3d1c638b42316b8a2549a563ba871fb7ac3c9a239d94bfda7d6741937e2c400b11c0f87ddd53276474926221a4f2e59bc6a8e7aa0ae1fcef89aa71367e4995a3d060e7166f2f582368ddc9fc4f8c55af01acc9f078a7a0826b6316a2d54188a373de93fc63882800652c98dc14df089c9e9116e18a8d69eb70376194a8c5bd40d956b71df3aef424abfca0495f5dd3ff9cbac7878982b7f76643cad1a967f512115e3ad3637e720321bf2b43a60e2e332a4336c7fe2fb666cda0e1701e9bee5aeb016aa676327b8e932bcaf7fc65f399c7bd5ee200a5fad2defabc45d5a3ffe33da5e83cf17403a6e4957d24fb1069fdd96b174ace78aa76677ccdf226ed4f204341c4937ad1a50ddc1d2dc51f5a255778cb0920afa0a2dd4c0006de3e56be0c4b04c2a55340339e656165a0b92b635468513148e38a4c2ce5390b78d58f64c8bc031a510649ae1222a258fcf2f6e8910eb7c9bb2c3c8181ae37d5bb61bd3dd6a0244b6992c4d42447edf2d9fc4bc4a7c3ab380fe741da4e1f46d3a0cf053d9f16a110bc2b0e16c18f12fad767e1331945ce4a118b5fb8e861e87895ae0f1a5778e3677509e328f1745747550a100ec51315ccdd399354ff45de42972743c7153742e4964a4c045780df960513a6407f6224d0dcc716a86d1f9a323399f7b906f714071578dd6dd17a1ffb70976a7322080494ad0d5aee0d291bcb335c867cd24762c8ff00e2ba1a44329571b462905f2f739f93f8b51a6f39ad53e70268783fff9ff81dfe86199108501a22f44618d331ccc0521c76a2a3c3ba83d1d508ae914655320146b416fb58c9a1be59101b7d0e240b361abf7f880a39d35823e2b7b65e845b5bea85f90067b5952763a398f1bedcccec209dc41ad5b3b727ebb0231d13b4b65312683092af4bf88a0abdc0e67068aa27662ecbe8da39263ef391cc6ceb998318f7038773e08a7b30c1262648bcdc875795a59f4ec960cf0e91a7cb3684f46cb03e07c8f73bf3479fce2978cb1c95d27d2111a58c51270b8a8a74f8a4d71856f27e49e107dab4263f5f695f6753c1d72d3fc7583f6c5acbdbc215182616780f73ec7fb1cb00aeda43d3cd977ef2442f57a066e6f948ff2456e6d14095704cc978d5e04729c6d0c64a73fcfb6c1b63c929aeafd7bccedd6130c0e7490a75c35814d762f192079ddc372b14efffb13ee91e3c347db00320a75e0d7698fdbf14ac4a71da65726312e3e2671744422bf64131682aac80182b4db098c7752bd028f455d04c1fea58c7e1b1425154dbd3ab0bb7e29065951c05f893445488e5acc53dd7988ea4f4a480f2c2df9f810bc54a77c3feb17cb14dfabc8782c4cdc4b82a7761b7974e10d4350be31d99b28ad962d4ace2d96ef538a412009077090864e2a3ff82c050fcd6522922b6b84798f6c216ad80d51f5d089c19f6f522e00036968d2f3080c6a6981a67be5d796b0a574e8a98c64df066501845c4220c9b3ff6fcaf19e038e03ee516467f114347ff595b178338d1bf5b2680ecb65e52ad03c9f9d2a358404d169bcf18af85f9aff43fa62ebe513562fa5fe480224f17976acae93bd57233c75cf15ffe5b30a58c6a81eb5dc2bfd10704fa730ff7e1c5e65e5d26a0e7bf25ffecc10b7ec73f3b47f2f2e3aa687052d7521598b6f833b75d2aa9dd7fab9efb6b21bd123ec82f5e806633a286fd4baaa3d1031fb6f3009781299341b288ad9e18d1857048e44693cf74e996a9ab735337bb1916746f7fec45cb13a6672f048e982c578acd3bf73e8d610a70b4ea0bac81146c9d7bf0e426b8e5aaba14e6fae4f2be8fc414daf853c5729bfc27b2e2c8e4e560e80f35cfcc8ad0de99135c2d575cbdb055cd8110e3afd7fcbbedd528deb6a6b2187480be310e1e0c5ec6f636532beae1fc28df08f2cadf935701fe4db85444f5d1988c32187fb2f14847f41b8f8f96d64af2b8cae61c67ff09b969f57257e92df541a2a1b41b8c25ae251e515e1c4d332848399be8934bfe4d83b14a5e8b0c21bde679f206eba63fc475dcf7a9b6701b69ab4e2489f7782e6498e4ef5ea1b7f4e47d49f95d38eb6512f4967135a3f8edcb4c678168ea4160a29aaf5bce708c74a642260ca850089f5d96a442662ecc07e2fa9405c02664545a36b798dbe5abf9dba2c47e40d333ab5d8ad26e6eb84e94a8d291e18bc4b0cfce13574817f653cc3fe25826dc01b77c025a4289d2cf8f10af84faf02ff6025f12e1fa7ab7642d01516f688444b642f7e8083afb7023af5a89f9f9271854b11549c5995a3726a5716bf17af616b0dccb4b8f12098d6723a8190a983fa0a487362166408700b6ffd5c5817a8f9d75dd223a58244eab8b2ae9b5ccd0b1e64842a5acd55c6211e552e8d8444607bda938184b478e8f45d80b95d607e7126a1c41a65042b50167d5456ec5c8f11ccc7c93d7aab561239e75a6c8fc533f21ace5573499cf90fde0c5578203cc349cfcddd046e0adc5633874353a430428a16da0be7afe5119f39816c4c03c6377d1d379358be006357b3c331304afababee32b673904702e1abf18a06b727c067c8862ca944cd2d504ed69346690b6a318f00261c78a9d8978ba14c702cee74f70779fd3a64b1643bb65aa06c29f276f384f21b87fc60aba88d617fa2d6f2cc182ed107c226016bf3997466587d54692aeaffd26827052d855c347a8178a622707521dcaf2dc21cff94aa7678ffb084329f39bb45ca1881bfca1be8168055b65de2f2515996e67c261dd671229056e76932bf7ab7b0ceb50891e29914d48afb934f4b807e9d3d3810e1e17da570104fff3850acee07a1996e587fb6ac5e0a6b68cfe7ed9d64325bf45db6d2d715e872aac2f4ab67bb17c7cc01d571cc55e4092fd6a7baca8721e7d019c5066e6a632a7a3aa29f77f70a036529ee6fcbaf7b3107bc6689d0f27dfba789222267937fe2a186054626e727684b9b4266d98f767b281e85638282c70b3a04e33b85062cada942daf1edbed3d5a564d310ca8be6859858d1fb0ad2f9a389c7d5558bbec89704a5bb8996e2b67515239b8980974c164a1347b9783cdf3cc8c16f66f5fbd155206f144ff5ffafe7f4f81653a6e109f742e449670ec0d7222b36cae83c2d6d76e7e2a033f18db74da412aa425e5592eb7481c70edb9afc09b0c6bac9842c389e8251b93d2b6abdd57288a2b2faa701c45892e50ac45df770041e5fd03ca6fcdb31a75ced3d144d3d366d0a328173c38be006382835df1865d814fc0b5e9f364ada7da18ec73d85cba8b95f930521dd9c0e16a1e32606484426c1668b378492927b68ab54c9ea703d0c5e5fc7fc2e1ec3dcdbb7265f7f49c1fe3bc592f313efd631d6fc295e1168bb46058b49f70bfb873292a241a45b883058d1652b977a0fecf2d3bb71edb9b8893bc58d6bcf2f3e18542a188e5f9c150b35da9b56275f4d5d7ee1de3cd15b47b547c3cd753a086f1081df640df25ea0ae885d3984c1b120214124ca611f35ed69b9f44be5d490faed9086b70c01e72ca6a409961e88a9d8b57ff9a4826e3fd94844065cb7e88be79291eaf9052cb20c31478a26d1d5370ecf8ed63dd83908e9c1263c4fac60ecedf917319d1730b664fe1c51195a92543bfc0ec9b95ed5214f29ec48cc3e4d6c995b2780ad880d466903c72fee5b85715a5950b3e3bbfd60ecbda7cf39b5dca32c0ebc9afec00149929615693c6a224a0d1caba4eb1cbe849530aff8fcdf6ac6766ce70365fe0b265b5075db47a5f95ff8c166fd87b60d842c81640de717b6c81f0c5e7bd88e0a148cd87da82a0130cec962c435a25ee58dbf815b9bde4d8735bfc87631589f17df413bbff971dad7e6092038925e69437d5f32bdd60148fd6e3c19f5866a06f29241f87dd435e501c1c85f5fd127a60d76b95c52ce7352eada6108cbf1f67f35a1949ef744d191a94345ee07aedf220647bf2fbcef2d19a9bfb29f46a57b7fea27d36e8714f729f8f24c1b7e31bcda8bbef1f85d3ffc1d76a999fa3fd68130065cdfe876aa29f09e85dc30c7bef7176b69c6e8a66bd328789d60a94572081a8d762df8a58f99883769c47bf991ed9c5898a4d44a36ef454fdfb9ba7fea612ae8c94a01c50016a430876fb22be17108f1bb2b77820af998d46ba6432a5443148c3da2ed952723dbd2843c93abe579c602d58803d9163aabad264e50d2a7e894e8f269bb73d08f7a8e0b2e1240ba64f1c12e9c80b3e517572a1d120c56d4165d395a019ff79ef20a90e1e4b3b918d53ab2df5c63ed83cfd5589c25f0634826c127360199dca2cbe6246bb501fa54a122d983a1081044cda5026bb4a64f812039c6b604a9b08fb812e493ec57a2aa26d3005929310f99d47ef4ccb0f243f3a546f28d9244687f2611bd3cdab769249b1f567e9b7ed650911bafc62f15974b2945cb4d3b7fe939bda54087bddab40cb6fc9c5b48626c6852c71537f31a27a0e71d051d8763f201576e3549e4e391a412b7c885d6c82819129a1beee0b084622b54a948ea6a499f456a46b0df074eef940e0065eed13ffff769f5260a4914e0ae993552b2279c34189c4d44887d67e9e668573b4f0b8b90421f167f7be15550c405e10a5c41033c19735da6ca31ebe512f3922264195254831be873395c06a77ec61acc2905c2d2ab1e39731812ea3cebe95ca9b6380f553ad8b33cf13064217856bf818814cabc5ae5f76890286a8db94ac7532f997c0f847c6b1c68e1fe90092fc882910970256531a6bcfa015524c585d3d7871abd7033ac953c33e0d9eea82c92e13839f0765efc4bb4cd06de360a3d08d64cec53927595b3a12f3f4b709ae28699205b47fecf034726fd4bfd319a4de260d3ae98719533df5468c63ab54733de70e6b3aef6572acb9925542025ea28920b752449b185f08afefd5e1bc2de9cd41f8377c96463b07f91a17a9085c23998386855ccd6785b316c8e2f64caba10d60e4e938f8bb12e36055dc85ad0c0bd7fe3d42ffcf2a27fc2b369136985c2ad89ffb80d8647d49a1dd97e4e03777c3847d0a3458139ccd5bead202b1faafef2b845d261bf8a97e7beeffc7928281bb737af045d6daaaeae02815685628db358c3c798cf32c91aad6a779715304a283f36e142e76448a4614f06cf566eb2e2c2c0e3d8af989b2800047447914b5b107c990efa5c85c26e5824c049dfb83dfda402393c66fb7276d17ab1a0b95f42fbfe5da19b772639305cbdb092b774241a4064298ce1c841e8c54f35a4fd7f7b3e353d2b0b43f6443e2f0adab9940163658b1920b949b6d7405671e434e52ed2603db46726e5976618c7162af1d724c3e018f26d7880c2da953e3c298f8421fa1279a017704bd197d5c7f83e835e03913e47f302cebcd0f969ed7a481be1f86ffffbce98644bb83b4b374577e2f1b69a2b9f4aec0054b2dbef42b1afc1cc10942350f5f44af676e3af1f051783a9371fc07010fc60165dbbe364937abad310aaa1d8c0c85342eacda9cded19beb309a32d4e83581359b9360518a221e8356e56536ea414c2d8f1c5554c90da707842f44fe3b4bfe54942f8188adbe6a0a88e84f0de606eb3303b15806ad202ee97a4ead386f53bae367ab4a2d7ee78c724263aa64dc9f25c741971698805237d38452e49df79738c2fb2e9288b42b691951ea716e13ee611d599f0ec4dfc964ce7cf4b4b8144ebd1c02665fd658f4209af0088ff5f8fc1e13c22bd1dfa7b04a5c21b8408f4ae2aab4f2e42ef023291ba85f82f67236dd6fa0042e1a388b31b71b54ebf0bcfcf87323c12cfc9702d332c782e711a4457e279493524e088ad04274f60beaefbb4abf97c137b9abf068ff5aa1dd090d4f55eeac7530640dd3b6c0336ff34d73115f8a8fc4d06e7ccbdf8afc6953ffc3d4d1c95b16279ba50e56802fe7bc1e1925483f823b2315279a269f4a27cb9d5c0a1d8fb12c0905450d7ab491189406bca6925c99f72c2cc70f7ed1d8e477eca2a2cf70857e67849944da084d9ce55532d77e225e4ea086d784ae9b16227a73479b7063fc96087d5d2c899e38d8b2472911f86bf08325816b268d707f1fe013b3e91f40b9ba966f39ec070cb88df7824e7de4fd43016d19d7d77839b591491f60e2cfdc1bfc2b7a15cc0a1a013aab3bf5e69f84f3fb20e005be0dd16bd3fd868f5ab09c0cd7a513ece2347199f6d39dca3d34919c5f3c25c7bcdef77ad70eac16e25cb8f2fada06d1da36263ee94732a38f2843b824ce1c179b80388efaa15de2f32bc18c7273837b879338a128bcde4279e82e8219039577fbe6d37de3c7a86dbf8f91c9f4f5c54f61524064a33a08536ba046bd61c548a8b51c77869a6573e05f60d9af81171eeb51c59ea28e6af879cbe9c83b2285ed1eb62c662c0ea5488f7d9c6fe8fc35c53b09d48abfec216e217b7542aa5dbbee56a93647eba96575b0328cc4b9afd2ea7462d6c50ec8cf8fa202b5d0b9b4220cb3ee3ded40052abf1f04e639824f2945157b44b3431ae481edc8e1307211826ce07a768b05190d7175311609186dfc20e5183c859c8a61c27eb82838f9351b1e9513f8412b857a48c49a047dc00c2688a495231c27af35d8a1c89e430ea70f9de753db17050bd05f5334d6f9b94cc5f21c74fd611f72b39d87c0d203a7d7c74aedfda673a87a94da6e067e5a910b0b0c379d11bc503f51177f3ac4410af4ec05ed45a4b9ca04b1b112e04b040200e6f031d41397877e2aeeac886527c504d62b98c44de5682287234e9537921e30ca0c31d1518652593a98ef90084abb8cc048d2b3c750aaf7d742b10e7408f8d941f71a2a822432bfd0bcfa65b54719a37347aae5fcc8e25da367909e0af1df78c8139db340634217ed90766293f59c30c4f3d84642a04309743e6a255bb94512c7097bcdf59f7f74fa0b38c9abb9db409e62d01e834d5e7b08ab4fd4f8ed6a3475e493ba3cd341290837dbf3a7d38895a37519e2421de69b1081812014f96c84ae431702bc383f94197daa95fed20021302b800cb6fb6c718af8a81fe1eb8117e10874100f7cc0e0c3a50f84f949d3317986eefa6ec0dcd25dbee90916e321799eb0363ce5ee985b226f61a181d42ef0e2b7e7c09a9175a299dec0b3b0d04da4775a3c744fd59ff8919086cacd9f0c92ac9768464342ea8311303615aa7afcb060171863b6c7e89eec75cc4de2f1356d2c68c3236bceb562b96ee53f50b62a5c7b673ee1d389f7b1b0f078647019e1670573d50e074038636d41f1621ca8460d1bf6ed988063e7d999174418da3ad1de2f2f7f1b8d60e8cbc8ea3aaf6365cd06f1de0fa8def2a557e3aafa109911cb7bddca6c7b202a9f2fd2415ef9493af332f66b06920053844eb3ae82c57265084a0431bc43f5da5c43b1b5d401d915aed23acb95e28a14163606f08d2425fd580796efd8bf68445ee7c0b392c67b22d074619d7a348856144d4d7a2fd3cb7dc2ad315cc5ae6d12ae6269ae58db6d6dd7d82ef654c394ec7f19e051d9d152a227191c293e29a8d9eb2225a98fb256fdf22d3697178b8b45551320d64269a5a1f98d47288f17720951befa66af92182d2ddb8c3ff983062b5425d4e8d27e180d6ce527dd5531c6650f49c71feb1e263f192a9acfc00a18c44d5d99370ad6cf27b50f67a57a7debf6f44bf7d54e203446c878d98e347f84f7c0fb5bde64e27dcfb1388cfe66ab91ea5eebcdea78b9c7395eeb1295cc720cf4b058dd643995a68f8b8b384c80b0f4ec7bd1dcabacba2c6a25300c7b02d208f2361ac9a861f7c601f15fdef693e14bf9f9440b291d1f789207358f418b1b24cbed419f748f62184e354760497565dae9bdeea8d8191c90c5c6d5138aaec3c5c24eb75a8ba25db46bf3aacdbd566fd4ff88693dcf39ccfe4dc34f0197584db7522ccee925461c18e24aeddf8b29bc6bc29e67826ee9b0f4ddd36843515f0e5a6eda22791a22cd4b8a7704635ffc016098f48b97f24c020a98353bde44e4a360ceae82daca25e0a81f2e83ba90ef1452c324bf1642894b3d70c1a430e08818c3afe1fc9b91eed9d818d23ff97d13a05dba0935c9e9cd55d7dc79dd5037477aa2ea3cf3b83f07485733e4e5ba2e0e76477df623d61dadc407c358964d9e4f09baaccc1713beef91cfa13ad576fa675ca24f85f29b79fd69ec9963d89f9a475f03534c3096193fa6cbd06849af357ce43f38d32b36acc68a196c95b0013fdabb10f7bfdbf90666b5a569e6355bd8e5604536cc7226c68ad0b26ab324c161fdb77f910d986b0e3592d084f5d5f9cfd8cc9a550d3707f322bfddac38661714cc612a8cf82b8fc28e1e33c6bb7d85b0aa49244c6a2ea8afce136245009b055eca2c288c6dc7cbfa0750a5f182e2b12608fddf4739b8eede4a7e0fe06383e2f6f869f2957e6700a3e332a77b8aa310694b3de3e8572dc7b60d3817af615c70e12ea44a38888b4e0695e0e9cbb317c1e72db8d38fffbb4ef519926a2b51887e874d5cf645fef75c4cfa78bb8a8a8fe966b458871e7b3ed54a9667821e59a12f7811a69e007cfd28e3b8431ad7e0fbe8f5c273f00f1980a13cf97655bd1e45b6c8b951383764c5ca2c9c30c9dd77c99e13ad57bc4b47065d52cf27a37f0e336b4b0b6b488279066ab0d43b667461f9dd16b290c2584ca13db9022455ae37589b5e6e484936996600e667597ec8df72e06b9b121fd2be3eae0f2f8a099db659fccbe033a8db8b8c7553c3b6120f9636d61384b5199ec611432768becc46a40b5499d8a674c919de548bf3250e2860db60bf4317976a3e31846224ab48b2ccb03b0f68069118c4f7023751a0a7765db0f8d75b8a158821fd59294a3d5b17255eaefc758ba40d2923b2c08fd1804d71d88884a001d724df0ba47c127c7cef63d2f2aa23045e5bbf5a8fe79033eb7a9ef015a117aec42e92f1251ec18870b96e6a64582497156069ffca50823c376d1ecb6ec491d5c0a11c508d7d59dc0cc607b10d139d45125fedc9ee6918a3f14069377d1303ad4759db1d5d3a5503c7252c8dc419c5cfa0549248a2b1c7adf7c9d395fe6f3fd150ece373e59d2f83164a63aed261f5604254daf869477c60365fd03a302a30c0b88248552f617f822ff66a052dd8f089c9f246b87c8979a9b1e4c9b338804b9d8f4e71bcd11f7abb2f5352baeaebfa345e5ba289b709f2c12bfd43d00b842ef32bd4337284eba220543a1791a075dfa426d960c4440fb25ccc5712c9d800deab5596f9ca2d965d035b07422f9d72a8c53509dd4cce1be568c440f6116347b480929331a7e1b83f6c7ca41414dd78bc2ed56cc713635734146e3625e29e5bc9f491684f301162a2334e1f205bef64b821e0a0cafea76e57fc6ec70e635a08d5fa2ab21d776b47eb328191128272c85cee499df652876db5d071fea653f0f0159c49a548e0419df066195088dd7c08a7faf58f4e5e004617d43a292008759d50c354c214041619f02bbba4f2af52479a48f6c97364d332729195c326bb578eb53d9d346bc75b2521df69e6d35ff5ac16a898c8d2fbc563afb86b9ed9a0669767cfd69e4ab4d0a6d46e8b9013ada53c23f4a63b6f3601dcc43982542a580a9753692e2c70f49e0f9a523f61875b73ac43ca963f94cb2368b17f4a01bb20fec41ce4d71fffd5ab05b6073ef8ee9ec7283e0f81b6726401c08a9611a6675665c647e84b54c06b48527f7dd8e9de550a995e127b6ad15de282303b1e107cad01749fe9138937ee5dcbc45f7f7dd0011b7b2e732144799e3d5c0dcc35fd428da25572a57a0c63ee33c323e2c4286d84c4999403f38b7d77a32c8e1aaf574e9c6df82468ccec4f5e70c5a6411c0b429b420ec1e48a0965766a8ec6705151cc951330100e3445a276c9cb2ff892472af8d9df24e4c6d07aaa27f43a4bf4c8a91632c782e6646bfc47401256279dad5ecfd6edf7c54e9a599b88262926f8c76f8356fbccb4d7c5480dc107b2d6b4543fd79f7bc42ee40e1daf8a0893a3c9b26c4131bcbb65d11640738ea3b97e620e1408c92ce53fffc9f6c13cdd7020870e4cefdc35b5699b9d1fe37cb48b28e045a7acc4a0dac78b6cecca05a054a22ccbc3d7089ac3d7296923379afd1fbb0ec1b77e9a2d32bfa0a753edbac3bf30e17c0552e20bb82d13bb682799fb47560dce9f4e73e7034278404be168c3d01bc4b12cd8cb085f62fc7d5ea39088c21e6e43919b83463010c7ac4f59d09f0e378425ddf0b218104f77f0a0162112a8352ca2d8dc69aceeaaf41e7b28f9e1dd384f9d64049725ed0e25b48648faf323b655311b87e58fa805ab38ebef7455ce60ca254607a27ad01dac7acda7e74f2d1fce8a424b7457f069ee7d0c8bef87c35741a7fa577dbb885f6c8e4adea16e3eb1344556d3516859af1baa1565b85ec86dea23187249d52b23fb5e88979ecfd230de04f47ac52f076ddd834c0e28edefe24224f4bf78f56704f08b13059ae4f2d7d2986344f5c9c47680a3780c98740aee3a41709716640a6e353780d4de2bf703b37e20db53dd27d0d895be2ac417b3008b034ccc5bf3597f895e4c3d1b07e9f500647712184b43dab2659cffebfb963314594db35657c89421ec9311dab4aed53819af23bcf4999474c0a09d54409107dd533fb118f04f115e2d8c329596ba0401c6cd7f852184b1b1cd5abdba88dbb4dd1ee0cfd646698c30993609d078f05efc5920b4261899445de213a675658386d8fbec574af9266bd4917ca38142c2f46b5205a68ef63446c67d9736f9a5b17af1a8f34230c7bedcabc1e0debe173f39d60f2a12d5528cc71c249cdd443cd18b2351b33ecdee3bbab4c503550ea1c279501a7c29dc9c985fd48df31ff64120eff989b49df12660826793a2f7959fed3979c68786095f04e0ebab22dfe4f0ac4d7622a7eba696a74387298b611946afe2d735f462d10f7a699ab8a0d030d4b6bced871c092baa0bacc94d07eae5c11bc2508336502674763bc1e21b6f76db5acf3894670c78ab6b2f1f2d76a233fb1982bce88273d4f6c9502128cca5d04d3d518994f0875e39ad02c1cc1dea52eccd5246c77b2fd0d26d61a186fb1404bc92eb65298e28a97fe8b74dd7b4ee5786c79bc6b35d6255f96b25be5901806960b5e70ea2d13c45c709c6f1429928337c5020336cd99d57e83ab5a006a453312e9c5aa9b313b9b04c3507cfab2423020dea2b95f48cab3b6d544699e1b161341dbcc914c3ad06982fbe433011946f9ce1965d6b77acd6501296b88520390e5ad5ff7cb4f3593a25fccbc09fb535a3e1bf696f35250e68ca2ef3eb93ddc7dbb3a4ca27593de8c06930e4fc9aa70416b09bcada268641a0991c4cac4fc3c8db58e68382715f6292b87b8e778cc1d09971d2e6e807ed8d11e9af4663ed6ce34f906f0661d61f07decc1c7b69169b9380e552511426ca4c9121fed351c6855406e68b221bd520f9782669ac4cf7f22e798e4074e1415ae8d5897ed23477b8d9b087b7f85ab5856eb281ab278ea2faed5f085f1397d26e9f6dbcf0834f575f8ad0814b137848cf21cc5566ac9a5df2fc662b0818f7307064352571337302f0ecf2d64ffd9a6d3c35708a108303d7b3e496918c3d95286e9e5bafa2dba9e41c63d5076c89902d5b191325b7916f8ea5584dd21c7a2f80a8f80a833746eb3c95971d0c5dd6b3361edd69910241a9452b13372b5b3c4e01684646a8172b45ae247a39ac341d9f5c67ec7b9da54449d247601de7c13043171bc225f5ed7fddfbbf87445326de8f3aea33e9b7b06569888a7d0986dd752e1bb0022395eeb2d71e1d63a5cf0b1eca1ffce051b52b1963057ee862d8f15a6bccbb78e79aca26c58196fce35221e4558ab4cbc7ac79523b0e17705148b62b7e7e7af15735cd9da0250d4f52ea1a93b5145b11cb8fd467205d77f11b04270bda2cf546ed64aad362b1962d2dff402651a4ece874ff450defc9751fcc364053aa02dc54ff2afdbf01f23a5f99c2f7229495c9d44130220aa53cd5c8f6e9159df97d7022a706111c074c7c32d7297b1bc89b7f341fec9007cfa40acc47d69bb272c7d1fe15e864772ae52a701399b6d3cd344daf2470af7c9225ce40c06dd2f2078c0a42e93b2fa75d4793cb2a82f48ea373480341fb6c20771eb0990337cf71db4168af94d05db58d6117dd71ba3ac9648a9c15e25e3e5234fcdb3b0277002be0d56e4f5d6262cfce06bc36eae14b4d02fe4e7ef3efd608f5bc06aa1e1988a8ac997c4d650e3a98e05dda6a5cf8cf974920ca544db9809efd8f861b5fc3f63fd35924c2246060cc4d10c6a1dad3d7dc0099d6218fa7b5b31b1c181f1dffb07d2ef6908bdaa17531e83263943c62a6899009efdd45ef28cd8085045b2054267c26656a2542e77c99fecbacbd9da68587ede1128760e0fe122cb1e1cfd2c96a53ebadd59993beaa56649d47af7eda46f7fba6e464d537ec3df2eaa57069c04ba745a89dd5285fd7be7697f4b5091346a2ee7969f1ca2948da17177807e8a191803e2c29275317fa729046b4870446855bc14677e6a4d4a6c1f0dc34fd54aac893bc81d8720a8b337b90d6ef84028bf8d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
