<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1f56e953964fe19a914b59b29e62cffc17b9c321603eeb8ec539e8a4b5071565d95000a22aaf21e917ed1bcbbc77c7909fd3184d8a54775a749a048603b17a9aaa0ca768838706fc5e58e8b34ffb29ccb4934318ee93cf9585c99775d15b648d448fe0f99824fe795249ba1a149a5968308521cb322cd644e32ddc699b4223ec8b804d9986b7fe9c1fdba812936705714e515fee3211954a51c8666a243124bc4db90ee011e4fadfadd3164429a12cd0682f469d6e29fb6260d16ff6e220f60cc25b9bde88a5c334f5ebdbded89f4014a99004431154f054962cc6cfa9fa77285b5470808852961e270a9748cbf020e8ec5b0a9a1518baeaaae3b7c548d023cf46e342d2ac779e53ed203d10573f6374bd39c32126aaa2db7882dc382f139b4c6ee08e56adbb967ddaf4c5250c92f94e30b93d269ed6f37f6d4e275fe879956fd17a6ded0f381024b5c18caa6f90404946969b11cf66469cee7f33902f0a443c4baeac0838d5f4e2713fac2d5d46da5ffe7b1c28b47fbe981311d36fe7dee35c5d9141bbc67faf902401be8bab2d016f157b4f15c5f10655d3719e1f874e91d2ccdc4ac0e47499fecc8ae8cf68b26108d562ae45c3844a8d6d1f833169c4631eab435c5ca400aff14be0e3d1304b8c208b14bcaf002d34523880fa360467a34bb421d72cb7a76ac39ede5adf122c72932207992a316049ab0bcdafd8f5a2820d37827a438ef184060b1c94d218f5cba7d6664a31af7969486afb2f221f4a5d51b51104da8bf36cea7ac40eb5e02f26a12b137b5c751c7a9dc05f2b77e7ce6c1504f052e170c7dab7a6430ea0e83031d734072a5987dd2f6d79d3662cd591160d7b5215b17c4a57149ccbcc17275b2d159f8f0386eb895e2cb158b41102ccfa73acaa30c61e92277e34573b0d95c85bf321b9e4e7f45435a9cb88a6965250331ad81b0491423688983b9fd43f69023e498d61d1a8a334a90732955a2b80c15a9e85762ce5da43b6049648606ff09220dbe6d6b02e1cbed8091396128368da191ffef9d05661709aa0a49fbb0bc7db02e28fbc52be33d919ac567b406cd0f5ae1bcfe0b7ffe1bb3f98abbc0b9e7fd9906c4a7cc06e902314149e42e2f29143e734e0436ead6c11c098264c406cc54b4205e775a46d2f2dc4d07fbd7967ea9b85ccbffc0ab69205755df26390da01f2af89ec68b6a96ca4c08d26a0109376807231b77851839062e234cc3c682eeb8793e3e1f0f196dde55c56b096d4988fbbe45938823682f59af2bc185a21f57ad49d594436ee3500d8dc47996add4923619d590023bc0605ac0efe477ad865d226b9ee106ce56a91c525087f619c3b522de91d17f0e9e35e94f35f92c9a3f85709f7b9c7432e3516edc901efd2fe59ba70d52b0e8d9de568e9dbeada19c020bf0e2e37dc39b7a873533426ee0cf95d19fbaeb5c5619e9a9e4926c89a4f5ea73415cee02716697b4601a14a3cab7bbbd93952bf82af98bafc8abc11b0890c388d4549de873c9943d462d53ca74755a0a8591b6cdff07b069a6f04b2217ad88e0fdd76182b0a28b1d13218cf3262d5476297cfd64b63ad06185dc84f7fa4962b5952a6492ef37089629e6bfebfda8c3f8a6f18354b4fbabf08332ec590500f3e0a326687bf95dd8fa54753acd6ad89159c98ae87094ebdd73358677042d25835d9558d440a656ea68981ae7a78dad96e70a4353378a66a6df456089e5f9c2bcc4f7c5ff88a8f43dd17f8a92bd662cbf3c68084dd1321064ec92cf333a0d993c432d8e7e1a09cfb7a72a43a1fa2c27aaf01b8059358023e310f42590d37540d37241039eac599d7cb05e733bd230ee43207e96d8d90c65d62c91e73b7de507542b8b70b14ea8cafc62a935cc877c40d551d3bcfeac1cf34428558e2696318eade3d02630607bb730d9df6153d7f9e9b5ec42fd6244a1d344699cbd3da3c2f1f093245e0222e5c612af1f6bc75cca3c2273f7fedc68e4c382cd98d38ab9cb30d10347f804cd0e662aac789acaf06892cd789657ad36016a9a5dafdf238278b6f8e637ef0df77032da9181a09dc46662bad6ee65c80e2df418bb9fa57b4274497189a4d6525f4f7a75698db1170a52bf2e44d2612e7d48c28fc0203a377cecdb3b4d8102dce6063ac8262633c4293b185f201eff125f06b79cefc3c7a6ac4bafc97b607bfc678783766d1f51540c778b68421ab467e7554058020c613887613b160860c88e687c8abac0427ee2276b879a10fce79068008d03a191a2baabdfd1bde02695864527d8721146175b527690fa799d20a8c71525d0163fd8a01939433ff3f2294701eb59b7e9704c93e376eadfadd42749e9300587051ff40f4bd80af339b25238543890c3b3897fc4912b8fb278abc6ae546ad85a4b157c3838ec45e458573e8633ca4d9dd2ac8db6b8dfa5c1110b4428bb66ffe8fe0a230cb09f2d33fb110ad6edda15e6b8fe281805bed6653033e989901bcdf627a744d3fb9acb5d9c0da273e2fffb9b4683d308d808dbcd14baaedb5abf34fbd01403cc8f5fce64cbe8caefcfd8f66e4b39ec0cc64db75f7fe0a7419173f59cb3d49bae80b1a4c114de1158116aa68926a28c533800d0ab2c2865a41097a6a60f9a5717f06c0897cc002a97c793738413e5d1b0e88fb60c12ba0feb1f00dc74329892172ae840f27ccf7b62f77d2aea3907fa73b3ed843f32272e054a833341f9ce461c55390392900d653ee3f445fe728cff4262220bf40e54d5e36e7221ad8de408d22b5ec09d5d57c45d1e252e2d8f4320082f65561b434276519292037769ef191c91fbc140a1a802be112e138fc19e27585d5e41691ff6bf7222a0f6a82b4f356e2c161dbf0ac9898c5cd01975f136a8ede8a73614c82a279892815ade1e9f522ced83720ecfd895983247967a875195fd84313a7dcba9da513e175692aa1e154e524f595249caa810a9d5400e9f4c9aedfccd696bf3f658ebad2c7591ab50803c5f46aea84240a6870f6ac31ea56e61cb485cc47d97684d9eb7e45eda5dac40df443bd3206400dea425ae9eee85fb108dbba0a5b9d396477e6b2eea2c90e71d7d32826a54a31c085eec7816e38cabd6acca8f5cc42dfc08036531a4c19b144ae4d493e35ec2dd07ed881b995c893868111975d638b13518a0ff109695ab9e8bd0f19050c59c795cb32717fb8930e00b7f41eda04dd3cee1927265c9b1fb1f97037fc65d70301492aefc2b833cf1e1cf42a1f1908aa6e7c449a5cd09bdab36b98c62e31be36737a2bbc83a2d7b71349e99825782a04c0953bab5049090ae27d041e76d7f3606f671ecef872ba6606b58de2914f11cce3db50e739d2853fc7e8ed444e78e04935bdf54d5655e6c35f93b60316de3d74768bcc273163055fc878cca0e482cca464c137261a36a8d531b98ab31e5f488935cbc098135c792ab4180b79c95fd10d41801c10ffca2a6e39bb2d1654b977d4bc099a99823359c01591db8f2aa72573e19b2078264607623051141aea8fbf02e37cb1f196c99dbbde968012420b85f62f7c66aeffaed621130e33c037a40404ab4be6c662705763b7832fe7461a8a722c174860bf8254ae497c5d48b1ef861cfdbd187ad1a173f3084b50a6c7d51bc4e3cdb5e67ac3127009542a2bfec69413eeed4d77ab4479773f01dd268b5d6c40c9b5359a531eb484b04abccf3b6d5b8bb6f2f6b93c2d840b75694b309465a440936ee2f6bde1f89236abeb6c1d222efa39eaa01ca42e6c6bf88a2b78e3b2e6302a029805243605272f2325bc83e8b1a3f90f1f4a72d4e28734f4d2459683d9d826e023b39ab34b5e7233bc61256266ee6fe3ca9ff09f1bc26233408c18b0a48cd42346d6b13f30b3b28e8e3e907b502f6e891b0fddf8015f1da6d35c7b15775f9ee8465afe1b06eb6e65f395aa95b928ed90824eee75b846804be7c20fa74e9a9262edff91c437f40c07c840412de9baf9a39b2285f3f89753d70d861bc9138840ed693aefb7da20b9fd6be69ba4950002db9cd8278567bb1dc6f09cad5130db2f7f7ca10ce1977e991cd9ecce9c55f7c1972f72b802a2b16d3add0e4c75ddbb0354f3651df923c23fd5d7ea019e56dbbb442142a67e73d3fa060940bc5459c36707ab5d28e77a253fc9722a0eb6351a6d6aaf9d40935e7f49519f30ba44c0ae4550231a3f06a548ce0361e7a6badf01946c35cdb216f8b950b7abb36cf8c952564e3f56c5ea552808357392bde392415cbb33b67c6d66443dd8f353415a847a5e3972fe617b5544a45337c6c0f5bc174573f26bff6428efe7a6873618f8daffcf67ac955b381a4e06f0aca9abb77b391b6109b43dca24667510c7bb2733d69b97563c5ced046bc439f331bcf8331aa1f5b24b07e7002f0b96bdd243b2859c3bff9c32c6c6a368689a4aa4001ad13bb10e264f4f73126e9abf3e8e653287898a81b2d5acd908f55bd9f92b3629e9ce145da495e1f0a2add5af19ba3e4693d2f975356c26ba6e0787bca0cef8e0454fdcfb347d171d2bee2db4159f6eea6f2b8019c9d1b0e2f3cae7d77334a5860d0c121e85f5eaf98d6060c4d68a8e44e95fed0ae1458b4da3107ebddd7ffd0bde1bdc1db9f38f4bc6115e97e76c27995e01a7176174c8603aa619aa764745ac380838e8e97cda0f6a8686478f9c72f9e9728cabc001cce6caf4252f2b275e4bbc9273c34f0d5d19303498d0d7852dee9451cc8fb76dfb4f36fd5b18f10b326370dfa05c1727cbbd311d40353157149119674e7b6f65426b4fb4199fbe3b8a123940761517201dcc61f3c70f0a03e3f45c1b2d3a2ece891f8c3d3731a6f3cd5ca9f18bc6bc402a377ddccfb00a923c729383376529a342268a429d15f317e69659dfc20e8523aa2cb15758683002b1b33a1304af605f6d78303cc807c92d77f117097181a6f079b1c3121cbc312d9a257ef9970367396a5f3eb89f5997a9c4f9dccc68437643c8fe4ac2d785f7d67b103a5c7e73e3276f49f62d65b5320445c7aee8bfb40c0c0045157f3b6bca03219220b9b1a4eb9067a6e38ad0609cf4ad4620e90393185ea35814db9c87e4d8daeb1fff4a571f276026511568ce085653eaa189d0a4de553c4598da4c55b1bc4342306174a18e6ae2047c73b610430a86fac680719c00f8fcd6c8a03b0635f5c7eb019ad8a78ea5c989b0b5a71a0c8074026cb9c57e3b91824fc21f0a99212ec1afcf701d895ac51d342792a49cf9eb72e8a7e636ac6e2bf4240b8fd02d73b937a960f5b095d01deab2b3e0c446f2ee0a32b4642f2981d0661cc6eb6c4061ae20adacffe00e70858bc36851fba2b43a4fd3d88fa06a50de238438644b803b19f778ad8eb35311299dd9c274fb440f02dd092ff034a921d640e63924b77d42edd0647717bf677c858ffdc57f83f301d25e6d85a4e17f4cab70cfe5e5f9d948727a4d48197bd4c2a68f0da6ea038898b862a92ac439518dbff0648f07c9583b51bc4ddd4a0b6d8f3476fbe1497d271048d36bb108b32b3b44a644ab919436d079b64279c04269e9371d3d81d22bd5b9d2896a68037c3a4e47137679badcd13de7591f76c8735fd8867b697193762b7ff139d075e861d123780841477db1173eaba8e358b169c8f6672ce007ce876f9ce1e779fc4433a0963129df08d1831c7dfc7d048acf9fdee2c5af132dabbda2a9a24ac4a5bb649bbe7192a18f57e4a31de115f4d1d6b5feb7278464bff05f8b69d2d7bdf3eb55448279738e9b51e990b383c5073420e55535e71472337bffdfe51e1c626e8d369000ed90fb7a0e9f1ce6317d9649286d82025c6e0528a35c7dd68ce18bc603f60fc8ee80132f3844ead026c934a6800270781d5241eb09d8c11fa0efe8b51b68b25b6e65bf442b95245a6cec89b937fda454168652a66625f8755500630d77044c2b4177f5c7b43a4640e9aade5a6fac0a85b6fa1bf6c8f1496733116b37d8461cb8feea5ac986386b0a65cd8fe633fc1c5b1f91ef07d4036b8b597ee79e950140a35410af36b79de7bab80cea5d46955d92014ffc1c976b249f9fcf524ed11026a55edf388dcacb869b0ad124d5fe2e288b8a52a5ff2ac991b6b5e08126005b900b35e58f76a9e6df0808a834cfb17b55ad9a2002f9543a8cbbd6246674c334a113c742bd321c3b849a756b9662c2a824b3d3014ee854e477c229a4a77a92f0925d0c4f9a409bf6040536d91d80385ffda7a1e09f89ae44b988c7adcc7f5ba0c29bea91aff1cb8021468db86f241fb43ac35f49888a695aa24231a42c99cf1a894d9415144c8b26e44f49b479679f3c90eef935d6ed0fab9202e25b6e9380dc48c86f1a70f19297cd493ee1f7c0092ede3ef8fc6a5218e4e9b38990b7ef988100e47719f24eec2ab72199fbe10e25967264d5efa7b91a1ee4089a6034af018d51353c0d18df5b726bf9dea917a8ab04264bab8a2ac1a43dccf9b2ef2ab9795bc42c52cfa6774df48802c7fae6195f41de22f853921f0908e92946bff51747b9df34623d6405dffd7c2299adf2bb69f58241f13aa84ecc95a2958fa5e583ca4cdcf2405ca7f9f29c7ae7e70c24ff182695bb5e543174b915e6f9479f5d9597b8109fde10b0160fe3a4e2ea724c6b1cde3545e557bf93045be65f5d8c2a124282e4ab0afa18dd41b28371a31a3648f95d1d9ee841fbc402f3146fd3ae1932ef2d62393783f66fcfb6ff858fa2668c69470ae1c4a28ffb92ec60101dfe6181650b24439f045689e487c4c7d31161415f918f0d2fd880ecf64c21c84069ea58b49cd678bc5237ddeb2201292c9c64ac7fe40f71f73caded803ab4d2a18b16d925c4b90a53f72d269ad08c53e2ea6c1cf077b11aa15423aac10f8eb48c20504ae14ac0a319c1e2ca73ead671ca242c65d69e847e088c686bf8edbb6dad4dba4ac6c6b27f080e1ecae4bca0b982e45684ab52445631a50afa31468cc6e1d81ad3bbb3139a0437a429f3d0ded4016c9384cd510d11eb458ceb6c984fb9004cbfa4291a7bec69c78a7daa8c0d8d3b3dbec04df852f618251ceacb40d79c93974211ec5f00dad47045ffd92011b337eeca2adfbb7a0e16af233ff2da78a6719e970ffe2dde001f0962d029e45f389507205faf64192533bc13744170410329a99b7ae50e3d2ca0996acfffaae2a85ffabe16d7295c9f197940d170c046bee9649d9786542987d75fa0dfa2459e52bd30ec9465376d46a6c12521c3f5ff79fad39ce7d976947636df150e85b113350f0251858c7a5b62485c6c799f09f6e9819e16808e0d7e7f5d5cf87ef82381cb03e4445177a2f10e3cb51076bf0932ce5bf9cdab5a65f99ec2b5fbb03c7d09357c16b3af3c5ac860235f65035709a632e470653e1e004fb82a4119505dc0a717de4dcd21092467004c74d1c8d948745b16b267922beea2730fbb31975e5305086e24268a9607b87086b31ed2c333b764de06a50204beeebe65d245cd95d0f70b55eb62f29460a8b6529a57361581495b3d89f13560535c00d86e2c3e35ae42f11694e6b264a72019ea52c02df83546d5c4b0da67db07a6803c05308c4f060ef40163a550d874eb9fac4463c7661cff6aed8f6965ff0b82629a22c6a8a061d41ccb0acbf0af03eb8d34f4597ed056f05f6fcb22b09b40f1b92330cd2e7389788cd4f521c365f09918084c1a9095e6c32a9b578a3e7cbaa27e21384c80e10be173eb2829c5483d21b16910b932bf23e9ebd0a2d2953272aac44c5f21a13dea3a604b8ac821a39aa5077a76193b38ac318fecee93564a3f4a5f1902f5c0e2dd203edd76b93f0c083b1763c1cd621bcf5b8eaf2e1a7c01e967fc24ea012a86c61516ed779b02ec40c5c0141ed6852414512a1afa2b9c47fd8eb3f7998b8914a12b9ae9ce2ae6200d607ce78c1c814fbcfe3803ac87b4fba06676f6963e3deebd8e11e52fec2da9271d05883ab5b494b2fc0ec6d7d893b379a35a6087aee9bb5a1e10d198993c0a7b02488296de18e87c9bbe3a5c08378d53d00ad8b5348487c0f2d90f1757af0328791604ce3d434e36e8d0f72e243c5b33d355a4a7f5935f01bf6e18f0366860fde3d7f4d47a5791d8c157f47303edb8cc75598a0711388aa47b4fb0c92cbf1ee9530ef825fa11af24d5190520ed971c9fcca2579c724698559f255d6d4f3f8c44751bbf1a3d043435ed534786c8d20850baf8270e41823229bd1870274f38682280db4603202f4be452e737e72c0790af1b5e8b1dedf0c37f9c4d6ddc6921562f089711819d4f7e6360d49bd08214b3fe6f6f28400c7d10da0723072e3fd28ee4dd2f43f5707c79ae13e55022c06832c22ad8e0d5bb86169394a51d127ee4102e2329a52ae7092a71d0a54f19a778d6830918e46ef67a0d3400ce721f6df0e19eeffd62aff362e683e9bf7155aa2c16568b2342e26b0774ee30102be31bd1e68b4a97fa4d21753c8b79dcad21154ad64beb34ec5008e939bc041d9c1c0465592ade01096aa7af9d81b8f83211adbbe6adaa80932949d28ed947eabfa34a6b5f7b5c67cb76e8f76dee92d975ea39db914be0ab1ddb495718ee0497472a45caca068a4d6ed7d44dd42faf6bf1e060ef65d60de042be1287effa86aa308ea1d3a0bce98c72e69cdcf8fad465de0eb3c100a88b5e3d048db6d84a1b74ca42143ef3bbe6d35fe823d8f1c9a42a1e9aecf682f0253e6b4133db648edf1755f63cf14c2c25b1cb1d5da8272a9489f0bde24e6b33fec39bea1a3ddf5800bc3809604a069abc238d7146ac08afd35ece893d999449b619b2383a4a8e89f3476b882e47fb158773ccde700c48f79c06473982240ef7b290e2cb1d74bb6016d9ea231a9441b6a70ba209702181de157984f1d4e4bc597e364e7b32ebf0fd146223a112dab334052de016ecbac387af01415b673cb6fd39602c30ed4f53700baae0143c9ca620ee90a7aea30cd9970df3caf46fd117f5679bbfefb86d8444c6cae58a855239b32a84df8ecc649af62c99f4c40f5c33c45a8202a1311f89f8eeb72911b4b4e733148e4d41d0493ace687cc74608d0a9492b9ef355c79e5c5d330bf4689fdf57762bd76017c422bf94c80474a1310985081c1f16de4c3c167a84e17534db062ab23d2a0ab4efc234db00e4af9fb03a8ee91460ca00a40b8850fef004acbd71a7e0c33c8f267af23cf64bcab8cc958055216e33a6a4f127c101f52d7a68f36c5f1c0fca4af28dabd733bc9c056af8ea085e171186206c7616b91317f527e06d4ac0a0dd137208c7e0f69e2133074aaae55277120d78edeaa23755e2aae06f3a3683086a689f63e5cbfd254beb694389a8a0403b55ca5c9f6f0306d64a6266712daca58f6f251e35722cc5d6435dd5fc82bd6802a7be8aa37799c0fa68bc703b45d9bd623dd8f383898bb28f08da5340c37f701d884b4d8c9b9d38f45355527b36a7cb2d34fd7553aac98db3a30dae0d688b1fa3689299518ff2f6165cc0effb1b294874157d1087a448902d1b4325ac5e45939d0552fd1c8af30c0f830003f24dc443f5bc2e1285614fecff617fda1cff5f82e55c2676e109c5b42ef84b8c59d4c2e7853c753483a3601772dd0972aa7166de366847a0c1811215637f94bb873c41979b04f0551bb96d1a81237074272c706e8c644e717d217db1dfe7120495e24eadd9676d5a0eb538177032923b05b68fd61bfa1e99ad329ab0c687686b4f257fd21ec9e0b8e8956655a74d55a5361f9e2dd92c46bda7303c9807e1feaade82a1173038c72d033a5402dcb3132e60ce6c0e5ef6c694a4c71671ce20169191fc7d367979cae56adb4ac0c55f009d3651b99cd8efd84590be76aeb6e064e057546f1d2fc437c5546415c42bd942635211f906603e38cd23ee3ba4b0504abb9938e67200a494af57fc5491f9a89aee5089452e67e16f7805a1104cd0dae515dad8a4087423a0a4ec6e9552f6b830f68e98d3950bdb82a26ed71c67e490417bf3df1d1f38f8aa51417282b716f82d68f92ceaf784eea51eeff990fc9788aca57e2fb562fdcab3c6ef47a16a4499f4166f814a7b4414e171a05bd1a4df09bd87bb3b7565ecb282b4f997ea7d0ac8023a540bcf99e36d8c816df718a4b499b2fbd6873cdb9064a3ebf1b1cc800128ada18bd1664de6f276ba84f2e1b620aa7252894fba3b5973e8e650b2dc4073910365c62c2f5bf53117f97843603e2b813ae16e233f5ec1ca60b85f6fb1a2214871894e3f073289fff96141f39fca6b4b5b2dff5e6d48777d156f2d1b00d9fc382d4f6bd670b51844b80f8e5449923713bce1fed7d12b6c19cac6cd8a2c2483620b0890727f7b16ae394a56bc1f92c64155712893fb52bdd615add2a86d10a4872f8e12e62a361ba9b3bac10e163a449dff2c12c9e8bc66e1106f8162d2d4171ff1671e45c0a577973e62c34889eea41edb74474be4da388c8eda848757e10f345382e0248a8d17a34c46d89dffc6c35a609ff88de52e0d55958de88eb0a87d1a43c456792dce1767fd8d4edeb6f1db15bafd42b9c77b3d52491b54381e5716ceaaf462a4b66ee77375b5e3c0467fc08b64438976e4b01ea52c8c431f417f338e7427a570917491d5fecc25ae40e1407c05300d90ffe3dcbdf4323ba67d163b23681aea54b5744422d302b671a53da9f182f4610a0317d97c63d7fb0a745101c8158f65aee9dbf89084ced3e33900dadf542b80b867934f6c640f001fa93dbc239a06b01975e38023e5f5c00385b296ce40f432ec3227c0ce6f7c19dfd7b3ae240e216865f6b6fdcb4b06432072f03b1783dfdad75ff8b866fef2edbf9b4688aab702c490cdaa057c0a5b96246967956830b450192e67ac6ae7168a51cd7fca894e3b3e6f69221c0752542965df410f36fe9006e375d13fa18295b27aa46c8f47d616f3428e50207bd5a8b6d0414d27f317fac78110674ce317f5b95717f7879410188f44b4ee2f962d17fc6a76f026f6a406ada871a3c87e71b9f155f86521ae5cb005f33861974b36d2b0c9c564cf455f48934e08bc179ce65ee2181500b16bf9e7a6ff36cf880c4475a9738025bc28ed6ebb8d55167648aab9aaa75dcfd3fdd4a0ea3e971087d1d832eb7d3fbe23f1f48713d362df7388ad4d6ae58478905e2ff3d08cf39a3446b50f0cfb7bcb8fe0fe5ac4e28a18a30a199d93bb40c65746f805ee1cae6205f5cdf36ebb76084eac5145425ff48e240be025cb48c97cae091c9945791c8d147098251687fca33828c827e7fed83dbd5f0065550d0476de0ef1da5b3ef12976e68084f613826b0028abce014726a191acd35dfddf7cb55f0e12f2f00627357aeffa63d64920453316548f6aaa0e07dc0494fcf1748f37b2b174d035ade4a6e674c9c8de374932a12655719d75552345d306196f20ab34afdac8e3d97dcf553653c600402b8735f88b06ce8c17992e6b7133428bf966009df3a15b6b5dec5267091d18efaa69f02db6c2e8539f8b71add9273952e7e71a0e75c36adbd74584b5e425bef6e43f6e6b10c74330cefff6bd2aa4d675ad84aa203721703c5d8364853fb4a7b45d257ac35f4959cd3c93a78467bef8943a342cdfe41f7d2449fe87dcad63ee7082e13a5f7eca5615564463f4f53b12efc518160da4bc430e579892cf829e9e9f43f85a4f8178928923bb6ff902646148941b9449692cee6888ad678996fe80b7d36ce0213c0b16688c1e2f8057cfb670fc41d736e0b4a8f9e558cfb6f3dc365860fc37fe5dd74571a073d8f4651019af877ea6dc5841c45d42b6272a9e29121889f191f85325834096adf000405eed6b29eca1b1bca6d6371b811776752f91edd55fa4cd6a7dec8589f48ee56d56e0589db3a6aabf1acac7fbd0adf1ae25d3ffbe528204a3368ef1a8874ed7b41186865c630ed209ebdd07f9a410b0a182e06e6f84ecd81547e3d3f8323f104407a10f893f6d804c11c49651b061df0041d842d532d9e0c112d02f6566ffd7c5f04cb8a6662f3f5b82b7b831a5ebdc47ea9f05f13cbca9edab826dc275cc782f4a8f90cdf623c48a4a676682480179cbe58fe113a014cdc21a07bd9ce1131f7087861d131bc771e5dc5b63af8749325332dae692cf9434ae9c94d117af6e29ef1b4cc8ebd3541ce3a0381e5aeec9708828c9791dce3bbfc3ad983f102061b76b61c1a117946c5500a6ddd7f5e038c6af59ff48f88643f57a9938a306a921931c75f285de8b7da6331961595b0b2d77d1135d166283edfc65c6d44ac1b53fcec0fd9d9fa15f8c84a5120ac5d883d126c74dbb962ebc64a6d8d11e86e5c319a41f2d8c0982b2664f589575c83ee9dcb9f44a5b993e4423f90671415074d2e016ef991168d06f7e5221d91445e6d23ecd226ebf516ef524860b22a7943e26dd50ae395ed315fe669dad692e70d1ba7142e4a334218ccd67899bb8c54c3fadab199085660718e61295ed44ab18a412ac08998cf6832c31bb0874892c313c842738e59042eee041584e0e1529563602f9d0de81b2b94281a293ec4569010bc5ddbf3bc3a030554956073a8694f229889a0cfb1505e41fe8ab9df77f30fbeaf2361a2a428cf283d30b86b7b9f5da15c08dbd7bea3f641107e32d84d84396dad31a367810eb471ede3fbfbe634c92f846fc1d9fa3eb4a3a48546675aee377cdb81b0c62ea725efc4c2dad7252113d8a95730713a1e72f6cd3046390d58e7cfe213c02f7aee13564a8706da3786d9e82b3210e908b8b98329b077ce10c382c3849a024b7aba5005f23a6c64dd7f944481fbda01108aabe6ad92a67a914d6db997f62b4496e944fca5ab3cca533f9666c282e4a4512ad2250106b61cfc2370bf2f563eb18471fa95f4bcbf953a6d4160f11c71f14dafa137aca961ad8ee1b771d83d756b97ad9e985c8a08c31d2600ed89a520e83744e6983c0023354ffc63b415a6359286cac758c4155875358947de8343b9e4a5f7edb0c0b09ceb3a50f1d6f79b462b5e34791a3558c922027e9fae930e10e8b0d97430d4a010ca81d8e40e46d116027b16d3b2c8490757239f252de7a7a7b10bf02380d8c36103514f46926387cc98d7c6844320b5f9429d26742f45d10067899a690701bb6dd1582714b70b216f045a491366ea848fa3e043764fd0a0193198f9ab4c5515cfca205764368e153b34ab96e2cdf86b9c41703aef7dae6ee7ccc285d304eff8936e2765bab5d79f043094b384c4a4eb1eca0dd32a64807db17babda1d13838328eab0bfb19e290f59274fcc05059000250303b7124f91f43f4f41b647ed766622c3ef4d79a6da81f9d3726c4875b2a2e5eb02227d87ab6c84ea660e686488249383ba8986ee992c436a817a023e9a28b41e76679eee0d5381a55649e80dab16b8bf1a7040067dabed48096e4f6c7066363e8246d5a6ad13a950c60be1b2202f97bff8901a4305e99d8d984d8546c4f733cb0cb7ed51e8e600f780cfcbc7e2f01ceb2c4896e7da9042d3866c0bae431b33d1354e5e08dd824abe9fd6362d44d212ad73300d4beb1d34f7271cba5b6e050564901f270683c99689d05f8a0f36af9f0697abb5d0d6196232be821e4e51311e7e781a56d23c25785c71055fe067c2e405d5dfa8b09474fffc3f0902258c363ec1ebda689e0c8f1e9348c02817110872b7721c52c2e1539be9e93b47eff9f0b0a3cdee89c07a59b858e3a3c71735979e4909863c2fa8b878131017557828cb09f0f034cba80f6b4fea2ae6775ef038469311316a5a6e007ae98f6853f599aff99066de50c95c394c7f607e84073ac00c9eb17d5f4a9d60e0f3461c9c555fd848e46f7c5855a6ffe17dba23aaa79a41cb96d36d53c83836e0499e833206f16e0ce5dd16eb7fd8fa249dd0a158406f6669cdbf19154635ce66b3f6cd03b5c21ea032c65851af24a27a0c6c344826aac746fb5e8bc394cbc81486de970b2ee24c8034b1d165df940bf6ac10a8ef84163f9c96ad906476cb327179e87fec32134bf2429e9b5bf448f433bfe2197ed2096175db6361c0b665e511bb94372fbfc72f4edace394e34d6c4b00a7dc32b507ffb3190bd60b3c49ce8e3a80c86da93c6b35c38798f26bddcce22be61ba382d2788b19d6838c001c70f5893b14b6e43fd19e8772d9c35ebb10983cb6362ce5186c81aa0b9efcb9453058bf7e147528328cd2600182ae3faa3511fc42a5667026469d4c3a85b87e402c7806793d72226796cb7ee858145bde06e54f7e386d54d9b7d5e94e83f9422b95eef38b3f380b9789a2068a15239d70e276bcfe9c84e3dc283d4fe53118afea00c6efe92a5c677705427a73ddf3b7588bdea37de615340b32e936975fb33fa2c615b647b4d646a2bd761ad5ce2757baa1c4769812c79b6a31bcabc24a97882999dccba95ef822d0cbbd9214ca60a8b5325c148c513e3b4eb7d848a8a9983c977f9e416caad3930ff90dabab4eb19c239a360769355ccb1d79b3bdcd0b25ff2d653fc6937d4b99dd20657e99f7c571caf950f1317e35ad5adc473ff4649fbab71993484a0338d9bac295b1833db083da0a306d3ff534d84e9de38d5e1c071f0d5eb5c5bda428e51171a2bfdabf0dcb7291ab3451a9d4860b0b9211c45948a297810550f449e8a036990e0b22270ce279c9e7d5d324acde98c4773e80ac1c19b5a23d76e6160cf7a73ac998c18bfc8d5da80d660b0df1e8726f57e916cc63cb23cddd16180e79de6c7b2bc57b76112dd236242086bdbf8609743bd7519c58f203c599c0af3204ba9463df4347e640e1d43a84019b0ccf26d0d81dd8ecff5c7988fe2f0213194dcf93194472e7a36ce1fea9c43df6aad12e66a77335429c49ac98caf002a5d1f4d39898df53720018f6522e9ccc9d0c942bf093ff8f4133e9bb57b81c2a85b461b8972efa9b189dd497f0c4c7b78f6e2cfed38b9e963f5bdcd9a1080e25c231222d9cbbd4420cf50057a065a5587a73d96570d151326fd0fdae3dc0c93d1c53bb8ca0d3b5c9b267d24f93abb387de7dcfd3f5ce180f8157e158af1a69efe6ab6a75f3a0e23f1bb672061d3ffddb452c31a500d4e2df7e4b11e4a3a171e248a12bd1148e47deb6a06af3dbd5e3fdfa8bd51571fff1f41bc2bdf09121210bde9422e6f8b5c3ae94466016638caf5b893fa2ce69cdb068f0ccc8eed51e6df28a42e34fd297e5fdcfc44ec7d270ddf508f08269dbb745ac616e05fa874c5c371906fce4ca8e47afd473ebf18ff81f0b4a3688fe07430c6c52307a18c404942af89cba29b5eea7717e07b3d61cdcd73baddd560dc78bb9546041686cb4d7a1395a9787f7e7d4762cc55871bb48376f8eb947a11f9be6ebde780ecb97eac8b3108b858ecdfd759ad65708413dd5e50dfe1876db5e962762ae9f4876b4129821831e3fe1e040cb395a1ed8d920b796d13aa6c21949a45ea71e0c04460c9cd31fb4a1aa3c03a827fe2be29483936288a426eb65fc3479b2c6100f152403d5b127a87733262b38069b14d4133398f02aa15ec962594fe5db44c2fffc739b210397d8d402bab05f14177689f3301a58149174423f5a32fbbfad33dc675f6e7d165464caf6d4ca319eac21cc4ffd22a90f8d06eaecdd807ab747e13fd7e16e24a74c64cbcd14c28173175966e5b7e1fa98743122d7d520154ac5b1d6bf0fc846171faef773463bd5ff3eab2e245d122cbbe96f9a10f77ff376fd1f949519f0902e06a52094ef18c8d5ce45eb3bdc27d1f1b025ec44ab9fe9f09251a91d22d03b038f0e97e0b0017280b620f2b12aeb61688ccf3e31ba6980784ac78e0dcf528e018c8dd32ea7f0fc69b5c2101d8bf676618a1e7e3e1aee2fea5203e96c8380dae6282bd7ec2c3e4709bcb7192493bfb0f5ccd32e75dd513c62a3e219d8792ba571c5bb5b31d9f300ad573a024d66f2ccac1219bb293d9010a757261d14980ca1fcda885c8c17497734672ed6980d927b6f474354d4da95591282b63abb9c0605257f310678de788bb10e833f665f9f61e7eda89f878287b42f083eee5ac4b0f78df22a4046e8f243d5123ad204221b07938e39a2fc34a012800145288a00fc450ffbdda510f8006669985065ab2e29b53fcea510dca1af91b226d9101324db53df0836cd776f8552331286c457963328018ef86c39e686e481b3802a44de532dba46bb237fd57800c4f80ae74b3bdd11beebc445b2f4e0e1f07497756a3fe8ebfaa5555b87bb7f6a35c3a788ea53f0854cb687ff6f7b2f256903c4f09f20830962c4dbfdcee29f85f37801172d8f6d48249b3095e8b6f69e2f30f4fff6cff44a1a403ca0c5d7ef5b116d47418bb809a190f1bdc048e15cac0aef523f00d4f0d87b718392fc624b24b6cfcded1fd8e549e39a0f069c838f0d3ea9e3f60e639cec491262055cddb6ae768b76243ec932e5db0229a1abe034eb3db4c857d5c87da9091b812a4b7a15fc89e5426c7b622670c8ee36db337524a3d7c7e2df4a48d01d74e77ef3a8ff987e3662e56ecea5b7a844360b5d1be5b3e953a25dbba173e3d56121f87bc288ba3f3d8e32832e737dcc524c375eac547356c793dd2b27420a773ddb6ad8ce96ea5b2153e224e913134770f7389aa16eadacd92c437d5a8c0978aa147784396ec304c690f2293412c5323b861558e6445a3891ebde3cc40ea7b815686080b39e90d646282e2d5ef3c865941df7580e8ccb648b032e35e50ee36dddb3094d92d93cbabac1ae037a4ae5380176a19085495d9632dd65fc5ed9db4d2b23b20b93d06db3a131e068063b2dd9ed709649bc78b5e08f3dca4240284bcecb949817639cf0d36e3ddac07c6043123b5bd12eccd4f8dcaae9e39d0465aade5d91e4fabc5244aff5c14c029a3d8fd09847e7e7ec1e0c84ef93c5c7c71d69e5c71af5255b02a55082c6dd8e4a13dc70e09efb08af8fa0681640818d6cb5c796d54dfb4bfd005107db5371e3db4b9bc725e68f9484285bcbe60d7b9c42508b3eda1890a6f02ae9166766a299319041e5f3840521d0a4af97895c3bb68262998545772185a274820b8d1dd4256ad57bd37aa3d755f2c7228b38d2032e288b724cdb7fb971873b68af49da378d46ff7c7dfd14b96f217a9e41aae3704e7fba8666490966d290f5d632ca6de79e59b0368f64f06e14a17081dd790f9e9775c384ad753acd278fe71c521233c751a9a714b7bce9ad68041d70195dc747f7726977a27f96d98d30d1c8156a5a1c288e538723c111c26b006ae151ea574cfc66f1c880e2349abe972137c5c0ffd5da72cdc31b40b6c50445b3ff4f9ed7241ddfcf498d2f1ceb4d7234620267f47f07368be7ec5ca3ada0358b93563eb7300d63c14448db6f90fed4f0493100212c5b17d1070ae64b6bc63a6e84dba22db8a90f49964e11006df22fc8813eb6b8c4e8657946b000dca637efbda3ace2bbc847c953a0de4f79b32e99e18828fe668855575e3f5ffea92983be707c3b8e12f17803ebfdcaaff4140173a5e220563190b056f8fecff3322695058fedb66e64b125c153d16f81c0ad6b5729d112515fcfa1513142355cc43548c1bdf143d5617c1e84c0bb27307ab6b1dc3d02282679ea281ff8bf554a79bfaaf571ebba16cac808aa14d20cb9bfa4e5ade1cba7f23e309cbb6740b2343f3ebe7f6ea59b625b362f7d6bb32f513c50063edee32cd3937e87884605008345faffc75b781fd6218605f6866cc754280750155822f67d47832936299a1f2aa6d7f5cb32e84ef6600d4445ea170b6b549b1edc44083ccc6c2e4fa91dcca2689b30ddb6d5cbe540c96830bb1c50a8fd64d0d034debb86adbc0787c2667ff29258af5df46329848554d174a888beaf7e1fa5a2ef8eaad56d4b1386e8100cfe3ac6ba0dbbf2c2e1454b5950db0ec805b52aa95e481b811b69280e394a23e14565c4a041da997db7e7efe65b2fea84b7745aeadac4b631b76e5bbbf6e4b075a2736ac870062f1a8346da1a9c8b9d449578573e3e173ede9635cc1f22f531f1f544e04140e4a51b3784637080929fe0b4d6ca07583690e1f0287b155acd886fbdb97ebed59d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
