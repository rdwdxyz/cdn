<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"3c1145ea6e689677ae759f61e8075bc93ad4518a11ead6a979d4de46a5ff65da42dd3605df132153147703f8d46b187601e1b40eec13f0e5d7b5548552147182c7625e8d63b562600b30043fcab9e2c47630c6dc036564ffab28e39f8347e04a257de71ceca0ebe47c6545f7b4f80034dba329b89721e205b8ca4cd763400c26e7647200f63455796f7aa88d486e5778e701ac9dcb76f2ee4ba8429aef2c5c1fd6648e0382ae5c32f8ec232407fab36a1bcb5241e011b83442fed9aa998afd03d14709873bdcf6a6ce0c4b0450d0913db9355343011b6afa9148fdad201ec2659888c325c9629d5551d1b8a991c376d7c371e80d1563adf591ba4e6748cf3368746cee2e4c81cab1688c5219c6948d03f5b274eef4024ceb9e58d80da7b19632d71b33ccb4a2bff61ead88ea35eb5475af96c2b57f7f9cdd5b732172976ebdce378ae9a38eda203bb1d5f839866422c6fce1674d370f1d8c38ca8148224a229084495a927e4b93be3bbfef70ff43c2f0918b9c6644717b75c480ac7d505b73a900a098a11606277e33b6e0ff0fb44a020a86fdf827c97db58872361158a4ee4b05e257d04828243d4329a1ec7d76240819d3117a657070efe3b0ceec2446210de80e055386674225d4c69206d6ef802373a96572163fb14b360bc8fbc911809c3b16c6df0f69cae183654fb582795271d5c7f80fafa74e61516ff9375a7b501c6ba1e8216988cee58a2ae4c155d98d4d0a35bb9fb6245e6a956ffdd4b890fcd4ad9dba1a81c2fd2641c3e107afd4e48936a148cf65206eb4f8dce9f098acb52505316655adc2e1dd2bb6d2586c936a0e8f123fea95d14888639aa0f7836558159fd51ff191aa1cab44227ca978573a1f540df22b2f0f1a3ec05e68c49292a70a1a5a99eb1a52a7d598162b67ccb4c3b26e19093bc69e5329561ee872f7e1f1356bb3b2d8995053c2bdfbb091b92468313817a1948c79e2150d49664e8addb0699e35ede2278c256668e5f4ad2d9df1ae1acd628b9c28ae478949301bc2bb95ccd9a2092576c412287c6416170054b75164ce3012db9daf415c6e671819bcb3078ebc18563e578b52133d1162e8aafe9fbd2aadc04807fb1119349d0410963b880f9306088b21453d4885e16d5c8187c0ccbec9813f8f5a2ca48be7ddc13dc8f4d7618c2d28612675381ab6ddc1ea05e98fa5eb0a3669688482161368cb0715d1a153a42e0c35e7272df5893e29a8e11b1895c511fa3c906624b7391206f358540c55e6df846252d4cc61f9de19ef1c75ecba721587cb1a11de2a8e71e6530909af94b8202f8585dc532117523e6d09a5ecf82fc9e6320c95a05c5fae895093fd1b1b727327c90b6a7828650c89d565339eaf2ceaa8a71fca249ec13eaa427e6cb62998224bcc88476986d18d4e66e759d8b7a57edbb1a034362a5b5e3563f537401858717890d88d9defc6aba1c4d60b4c7da5e9762e82b1dd08327884ac3a7fad44f5123ea2aef54929c4894b80731f8a5576777fedbb46d19fef6b4291c153942f7d566a1aab46b397eee1999e14f7180a650ebc5837fc37bb851b23b53ba6cf298c08451484b19af1a1516faf43e41632dbea6d10e91204c441579cf1b0146fc55b3ae124728630e28bcc47f5f90598f8690826dba72bb1d22104249cb4da9b70ca2396bccd5ca7c85921be61eca7d037ef09e3ee059483f1bcdd8751dd4e541aeb0d23507d70b747a50697ec928dc2ae5cb7dee659a20fa9fb11f10d21c3bf3fda7dfd1a1d8366e1d29d5786516c4bbc6a2ffdf18dd1979fe5494a6bc2574446370937e3101cf49f920e8daecadc6bfe8d054cf4d3d36e7401079fe8841ccd7ad54c5a740f9ff6b4bdf9530b2d946ce14cef9565e74ff2fa67129eb4e9b26e67d92c21be7d4d799158ca7ec1ce7059a5609d4a735790ecf376ec54d0deda41b54bbea561f4e159a058cdf98f5ae74ca1675610735e713c2660c30473b28324bdc709d1b541d5b8d37e66db575422e2cc625fe678b9e282982e532337f18e007d9186fee0ca77045d5dc922bdb08bc2af367c5ebc49e88e8bf9a9968c2ffeb9efa79322a25bdc88bf3af64158c9b95e31dc892291d836d687e9d6d290d5c51a3bd1d3eda8cddf6e0b1f193b830bea5284ca5976562954e91dcd54df6937b5ce9bbbfe91dae996a2456bfa3a9c75a27caa40db30f76530bc83647ce615a1cba71a0c538fc29cfbc6273acea1d5bca38648ed3293210219ca56cfe8e7655439b9a524b63387651e3cac51a5ecdce60493ac680437b0e8bee242453d492d7115435ecd1b6c9569fd50e044dbae9ca1b968a74d4d88fbe03b39060d12177d73b8651fdb60e7c1727345c1bc1e3b3751fd2de59ef37a6d681a5d6e5a0bc1788b396a596552b8659b19aab80121bb5078e17c395eecb7555a32ab3893d766a4356451e5585e4aef0e3afe8c4ac4fef037683b8f48623bf0fe45dda8a7304bd1bd02cc7ec1a2122e18c71d1bfdb76f99d02a1a75ffc5b549e0d9bb32a61aacf561c265480002c683abc5bdaee21389ac6d81daf6555c61cdd434564c11d68ef8dee88e14498f25d5a0fbeaef92cfd2941d916dd9b4d4f9cf826e0f78839be9572028911cf7894fafbf6a86cca555d9c4bf63c4582630f98326e3af4be65cdbeca2b0f32c05507ad87e7b5d8f5b2751f95b72f692371276bbe61600fea5e1779e6ae58bf2e2a35780864e9e7db8a9b39175af902276c166eba26f3f625756c965dd56bca144036eba6c6523ea6d069804b0b23bb42d43046a3d9f064eaa900e68502963819aa321ef11812dd7abfa3b2abfed2ba2415acfaa2d6b6a35b9155c7ec8e77563235da2b7e94475083746ebedbb67080c7532ab93a578e06d57c1adbef57a936d91aaa1447a78077773f6d57b229fd2e944685ae8f0e94a43de05038b4756e770b1c0ef7930a5fda1c18fb5db1c9210f902f7f486ee7e2992faa2ca21c4d0442e5db92613961473a0c2a214716202a71e63c8ac9024b00c22973ffa0c767059b2cdd49b1857af07ca069e58056e56a06cedf78a885c6962b069b1e02ac096274dff55f7875167e9dd69784aee2c67e2ff16232a726d69f415b299f35511daeff553eca790865e6fa1c5c5cf316c419f0e41fc1eede0afb2580b570999e8e047ab3785ac96a4cfa940a8b6a14f769c1cf43eff599d1113b17212eacbe9e8e58cdac0bcd0215afd1f4277d74db4cb61c12c9940cd658eb5cd3ded1b5fef84bb7a7e93bec6ad673f84cd5d1e83f7eae64cc398b38cf977e09023b18ee9196ec06b0689026f664664ef5816596a6090e2d725cd90dec47f62a9dee6e78d4b1edddf7c06dbafe95f4f890381a0cc8ef3ce4263dfefd5f61c7ab1545514bf2975567f497858f43d8e9d9c02f552b59757570b104a4e9be2079f50994d5b1f925b93785828d710a7c5b02e6b5f388d3b260864c2eb64a8dbed883bad5ba3b07f0c94bae7f02d7546f36ad2d3f9fe669f7e9a0b9f7ac2c2f6fc2052ba4916378a575b5c549baf7e00dd553fb4d17d188d85a9286eb64d81342796d1b9e6c7a3c293dcf688c5548c9f67a465d0d539176e1aeed857acd8893c2a42c3ef23190645ba9cbd210b947a71f4a3681ec6dc2de0a420568a97ca9864c1de48c7d403e0d9cf7c55dc1a329788bbec5ae54c2a2e84df6faadee3af1dfc2c74b30b580ed58b5c5e2d1fee10e367718d9f0f4cd5b996aa3bdf9ec84ccd3276e3eb7c79fc5b08f8e93180beacf7a556dc47047b7b6931a7b2924c722b834036fa4a26e5e6f778066a9ad01befe4d9c3f04eefe0d427a4ed2fc973cc2095a7aee62308c9029c11795fb6ac36795d594c5dd837a9ddabec72ecb188aec25b5ec281677606d92d45db6003a305c6bad63464024ebd448d3359ac58e6af58cb6516b56bd8bfe4c2942c941e61feaa7aa5bd3154c00544a22a3dcab522bc9a0336a3cdcc3775a1db70543814aa6a02967aeecd4556346bda3bc84dabb799b3b0cad4a301f358a45c667ba5454b599cbfdce253f2e25a08f7611303a0e2998a0f2a0c2a7e9523d78984d9c93425a0192dcdfccffab4170c4040504f53b666314287fb9ad1130e51b4841bb9c1e8c7c718f880fa25c29e335f5f5ec8e576fc296fe9d24b16fc306828730db438df6ef736d57826450a9702244a1dbaa8a91b0728a31d39ee642718f634cc5a04b940b198bc5ec021a2f4606b80984aa0f5b43e8457480cf20e37b7bd5cd83011864286cc46135708751846f8f147b6a6eb78349e6e50e5a2097074a74f2788d8b576baab9873812890ce8eac540fef9e8d9e05abaa94cd90fc890252a7a1a86fac0ae90872c66ea81f185ec19925f52392780fb1ce8313cc1a8fa118f2c8047e1f88549dd16a144afa3b4c133589e2cfbd0c102768453104ba0ef1121e8f5d5137f19157db6ba6d11a1db685ac1681447edca93cfa1676643e287bf6e0b305197da9b064d2e910f6462a8df18fe99bf44a5efc5a6881e5bcc36e76917f38df6bacfde0190c65d342356b20fdbe218b6b2b600da4ca788c7eb5ec3ed1ea5c09a302b78a780ea8eb0514857ad4d931719c1a9dd84d52497ca097a9d485a81be7ce414bba635b2528a06682c502b68336b20fe5f0678ca6dd150e3bd3d4fe3e35f009807c73659a0bba5d32089f062aacd388bdcab84ebb46f9f483dca88ed6b3c07dbe5245164cc32a42e4795949acd7d78adad69fd165bf0033f61205060066c6b81a454c8d2a6c934f6212ff05b73ad0475d45949ad9a0204e252fad6d545823d988c58020132ac546b1352cb8283347fa82ff280ec62ef9334121baba950a20c0fafc5970d5a3e8d32808898deed85772734668f60f8e2b4e3ba724035f439587957e41e2c80f308a6e4d2ec5f87bc7e080d462c5765a5a3ef2628477acb69fd27bd85ebbfd75ba8ba628e4695b8afe4bb22f29d56a0fb8735115116169534837f90f8e35b8a9fe684a39488fe56d9c0aef92a60dc5f34bf7d551148032791db9d387576807605ae5c28de069a12b1c8e8087d9a6c48e6630ccbe4e7d14393b508773f8f4e71346450639a78750724c559e8804b1e9b4218354e52f24eb7e57314b5a6f1f67f4b55335ab58a9c557c2f04d23826d87a6583c50a7c50fe1407517cca1554b6cbf53fb23afc4c15473286a5058cc9a933af4ee31547f5f81735966fadf0470cd139870fe0fee765cb9a35c07320bdba9f17190bd57483b818805bd445fa5a8e4c6935646547a7fc53abd7c49cfea8c886fb60e799871e21f96747406cc815b4d860dc61b758b98b1f5026686dd9b3714116cc12df77e628e278e085ad119f41997cf5438c2868bb65176967c8b4b6c7a6d2f7367f5508f4019a430b0338fc1853d6fd71e4fcfbb14992513bccd393d6f41d3c82ecb6a5b97e344dac023c3a9f3302aa31e1e049914e36459b3924c494620820ddf70292b4f6d14b3220b7362b79661648acc5a75aa31f8d7b2e6bc2ade81bb47a2aa24b5faf04cb1e4e73e0eaa5c98a5a993d44e17a4e42b6bc26c65667bc2444a5c9d520c30511d82c0901597554d610feda5da23b244c7bda2a6251b60d824680dcbaa7bd168116c5734db515e64ef5c6ef7b4bb6c70d4b3ed0ae00a91eb47dd95bf898a3aca26594cd1c9851e5b80b145c4234f0e24ec645f9018d07ffe6cb3d0deebe27ae8b9cfe7ad10ca62663a8f1cad780131559095af11432254465b823975d3e9841623e6a5e59330b5e918a151ce3af834c48efcd32a54a191af5dbdd8b71aead50ea3869b74ec045acf23a4057866c44909a949cd908cfbf2b80578b6de92661dd0a0bd8451244f6de7a5ee4a849d3c4366b52406413c87bdc1edc54253d17ce7288bc2915a4888a4c215a0dedaa4f2e9bdc3df8d8a8cca17fa77a9de6a4539346532c1894213fb78dfeba4807e69442eb015fc5b106aae62d91c2bb31ef65bea6a9d0f834ae62ce64b863881bd8dc430d1da260fb6208ea675b3017c25c4d581a06d4d838a4ab765e86e06e6a7de4d0606553dc3f5f2fc077535c05087a1c1f1dd4272284f04fb0f6317be4db13657b449a0a4d8bf2dc1f6dc7ff3a9f538ca58b599db696e5948de2cbf33e14c336443f900136f8097a3e495ad3a72d51c54730c84dd305c59c33e8dee0a43af80359cabad50c7f9d413d270f8be79c2c1ed8dc2e6245f7bda7c71046b2b581242b68c9baedc765b83c4510fe3ba6258e45914e1ae4816dfd2d2b368c861a2d8b16d69efe17866e14b87e018ac4048c39a063c959d92db283892dd591dfc1e7b6a1ca2546756d033b5f7854771222629f07cfbc5889d90b2ea338dcc252533ae09b87a10285ae51887973ddebd4fa8fa3fa5d7f1c071dfe640602cc416a2b0826750752ea72331c1c10c7842739fc5b832d234d2fde5d2e55a99b759a65007b12de306e12d43ce7024d1ba137b7b6e29f9545b1188379ce1f941aa3aa3eef332b2d0bae69daefab84f93e0766b36360b200be92c0e169732c386c19d1148bf679190ba1a3aa62966444d4cd38074e68cb2c073f53a360daeb3828c2aed0e8041029cab9f99127fa564e13b50c2211b0b55b73c0dea8272f6893620216930e6aa2c508b5af35f0d869856132ffc4c36f6371ad5b6e4f1ff6a89c84e20b835ec90c1fa146efd1395b41c8f0792fdc4669ca748384305c8c5a23695c32fe824a0478945fdf2bd42d10e91c09598557bcc37cd6c16b5b0e4db4fb3c81b432a3eb7ba693e1093d4cf5c396fcddd0e0d88ebb0142eb2cb20fdc2b828d1a26d853393f5c968418c06115b369c865bdd03b8f1d7ffee534a1ac3ff118050e207af15abef0579396c0616a80302343b9d1073b1badcfda6437bbeb08330966ff79df994d8b02222ff97a571ff11ee55cbe0bcda28a54314f212a5da42291f3a66d2c792d2418f827580ba0454dc9409048eefa7f1c72a6d815d8cd98ead29bbad35106ba18d3eefd8f3be2cf1c7a84ff69c659320ed704faedfd1d42fef47f4ab3d8aab44cc55ae1d3c1f08719d37d358a3b0297514ab07868be17be9263ea380f43e940cd019ffd68badfe600a97e4430aacfcf58534e832d8dbe8a7f1a6b221c08b5fd17cce656c58d23e2262ffe1bb97c1a47026c0e71cae2383ec30bd237b0053a5aea426fc767c83b3862cf16a61606c735a3891cb2a08d2798e20a802d292b9b416a6ea25fadf92389004cc928b7caf0dadd102a12e02eca77cdebc20be742ef0288d960cd4cfc3bcfb5c06d5e871c4faeb10c66af6d4aa640167bdf89aebc3dde8c5180da3a807c2892dc89748b5b411c05e154a59827bba5ec0624471fd525a5418d93f7e6fa363bd02f9ff9b77b4792b23e8ed7f855a4268927b92770803152ea30420e2e81f62562f508b87d8e60a2a9c29b477723e4e219d0548dc0608ad54f17bf0052cf8c432213cab8f9b4f19b66c61056aa3e8a30f0edb14f1de3dc03e116fd2d951c3329dc893841e9b80a59ed5a33b3b760439a88192a02d991b1de5028d9bb7c64fbc746034e56092a0d027837d4797cc4c2acd1fb57b57052223ce3132ebe746e5c9889232fdcaeb9097d53a1cc695aa31267a050ea6fd80c23f9767e93455990e983195248fd1ea4eb116a9a27c89d27ddcdd639717b0acebdbfb6109036e46e68b1a63290ce11770c62bd98aff71edc91daa610c5272463b1040650dc04dedb6aa5d51eadfa4966304bba94b9d6ebdb0742c5434d0e4437d3045bfe83a4e3f081b74999e4052844aad9cbc02009b79e544745ea4cddad6404a9ab6f4d344754c0467c1a616b13cb1283c74a01844866cfc4d7fdc3c0887f8f03de6c4d92145344140433cebc3d3b1abcd2504dbff8a3e43eabf908816cd5ca0f4fc6a6722c43d03642dd818faeee31224300f88a2121e7a5d36c0fa3e16066902e1a647dc2e02b3ef6a6014ba5fbf2351cb58af17356150c21ff6b8138f05543409a68d77b1657a6137511b85d6c9213982a8865745d640a1c2881880d68f225e3cbf8ca72ed798d36e70d2a9fbc8b4a20f32fa7f1e4cf40e79cea1ee5a96f9098bc27809131724be8efeab58a47f98926ffda7f41a9f2fd247c008b4438d0abc58e55a0195b31964b1456f4c52571e8034a56cd8d75fb5183e77c51c6cb29acb787a2057ffac3ad4cf050efde61b31b8840f8442e2dde5843fd5418faf57d3f4a5facd2fb7e18aaf56b2dbd903361d439f1ef641b715634a786f993d93e4abdb768b7cbd0919020f15f350480f4508ed738832ced8cf9f36c7bd09b811fafef6b6716ed572669fd791202801d357c3067318acd9756a3c0db8268354cda8c061a2d5be732de7b3de5f79e3171b9a7bf2dfa03f998c6ab5125c67053bfca908c653c339f494aafba29528a177afbad0a5497a7a9130f4908a1e1e387b8ca923c4d94712ac8f73420ee7aedb121561645173016cbe6da96a3e5b1e57892802a0fe8ec02af775dc818705f30cb3a7219c47dde2b3a4dbf490ca1305fbb2d57260f09b7b59dbbe8030f5ee0d06f63644359c00015e9b3cf6a3f7fd9c507a363e2aa70fb30c7ef50279687282ba6cc50d05fc1ea874364ffdab8943dd2b9e50ea7b32a2128706dd41335c0b0a30ed456035785aeec2e1f73b5e7aad95864e1d8c7eed03e8f41c62a36ed31fdf308ebbea6094eb3c4e01f3e2ec160e65582b1c770d8575ca113a740cd0b1f0e9af77e7a9667903af49c38dcddc189a8595fd8e7ddb3e12d94dc013b36cb623ce08817c831eddb3db53d07e21320b11e4e8702b1b5a897f03eeb55abf92ed9dd0a68c9d96e4f85bdef31d08c5b03497feac7e35b969e0edf81bfad3e309c2b24c0a100b6acd9759526b01fe3f9fbc54c24be11a4c5f881467165014de23fd1104108142141e7e0cb6ecbf088ce009b840af0ecc53e8318f50d3493a75115d508063bafcbaf703f199bc2e92941192adb153c44b8a08624141234699ebc70136ceb1adbfabe20a909b122954f6c0921b0f6c91a7dfb541f7914510e9496701fd493a9fd067adf58087136c36f6f1a13953279f1e701d9b45fe458caf5a27e0e920517f729329d1374d950bd11b8a2ddd1eebe31f5b78f5bf2ac5dd6d2c5b8e8eef009b3b44a0e632b694d96a5b51638762b8a4d666b3139302a24556edbe02f3a40a6765c10f8b474e73af8f015a8479356ae26e0a1f39c4622f5613e62ae1289c93169a6ab551c5fa8f70aa865511a3a683f40717a71b29e6e50f52485e6e161fde0e4196a9c44611c25a03cf294e8757b4f04bda4e828d8ca9472491d98acade28900727b7cdfd86fce12b5b1f67c3a0da7054eb07dc75166ca51b7c833d5c507054f78288c10d50290f337066038e8755f250a3918ae2dd23dff7a15d609f046b33eeb89ce8701605f4a57080d207e5a676dca4cf0836f34f5a0be6d1620613ce2182db34a7973109f6cee6219bf8b2db97060780fbb1a29708240a456b5c1d406d078c5f284f0662636bc0a69ceac1eb56d484b2152c072cb153ba81414fe7365e6a296ffb7124a1abee59c7c1a66d9a375f1b8cd9b48c41808cd9ce6822e3fc700b6f79a84a9bcfaaeaddce382a611c27ba762cbe7872458130b44999fed4715202d3d601a2e87b06b6ec8cf58288334d7c670a56fb73dcc1f0b3e5bb59d36b7f4e86b8f6d6763fc4d9b7adcd7223d499e8cd6b83bea0c181bfbd68ec4c2e795d227c5297f718b6bb77bb793c5cf85b8d4e8f2b5382f7da587a0364e17c2583f970e0db6847c7c911ad7f94b96d187e629fcf59677f653681016f7b07630f9d7cd0975ead41705b3074a7b3a3a29fa7ac2ce156cea7fceffb1b9cd41de01528d5a6900af32c75944f884d4ea966fa0590b20cdd9ae7aee5cfc7bc5dad4c2ab1c57af582ea96a68867b5b3d22dcfa77b54c4325586b71043b9bbc9a11b9c9960b310293250643b67ac28542cdb832a02930cb502e8347807923ba2d5cb94d55c82b554f46f189f6f8feac7c06fcbf4f12b5c543a00fcc162a93df890822a80487ca8b83c4bfc4a6a251200c8a34a70244b6d43dfdf895a919a508d78f39ef2b0122e37fcc7665fe1277ade299262f1c4a0044ce39e4b583d0591292c66eb9c512bb25966b4da6215549edea54627b38f92546791762846084292f9887de198d694245d680a1d4d57c0acca7234cb504df684eeda27bd8943cebc078f05576cfed6a10326daf584757fb5286d29fbe1dd13be32c1ed2047f425b7e1d6c5ce086ace0b0eec2f74b10e65ae16b106bce6905d9f3fcdc1feba6b019793c24d8d2f3e2455ae43f8788cd351f60f573ee87eb57f200a382adfe9707fc4ad49d91ed7e832e4964a9e6ce8df732769dcd1a1f7258007dec35112c1ffbfca95d5c5770e476c3a247cfc03bb23ccf2a8391b64476b2ba3fd3006f1050e37ed3c786805729354ace3eab3d8af91e99c321af167ce5946f79152ebdeb05ba26d84de7885620ef087b505e29b0fd7589183412919f3795faa16b7c20eedacedb9146fa80207d8930a1e55845b8f37e673cd7bdd8c98e96c2d0bec7b4623603787d5e810a6cbf81fcdb94f89662186d4440ca50e976b5e6d81bba5d6ff32d3e530d2910e8dda771ffa3675dd613312b31188160ed98d45bd587cf5ca803960fcc010546fbc82e4ae24ecbb35c638c8c166e7fbf110f42b90669787536d38142a84d6c89a2f7d9ebd7fe5572b7caf9ecda71c4c056ffb4cf7d949b76ee134cb645f5d243e37c9d3cebb6163e4590de0bbe6fb366f2d872c6f34144cc908a7e02a6312cfc78a643b8114aabdbb6fe869d918b0170c861b6198353a7441eba31cda9cb284215e85d82b59f1bb57fcde143b1846f73b2db1b3ccb1fd4b3013c8aae10aa9c2313bbec6e810e032fc80bf935a1bb92a15e1cdc6ef5af7930ce6cbb3174b177175f6d959c390d4f67ed4b2433b4b963c11423fc3b3adcf40fb7f8c929565b47674806dba345bffd110697d89b8e55615e2eb41cd69c8b70c89331fa8011cf7488f62009710ed675a29d42112f88db936dce30275fd8ef5f9cfd47fd3df65dff69f04884cc5c3c6ee780db7fc2f681231055d5a55dcc9096cc1d15ebb4d3ac3df664f2bfba27779df6191cad1c07cc1a5d93c6a3858dc5790bfc14c59ed6728b2d002d293a115494dbfaaa08d5f129dad6bff0dba25b471f182feedd702f1217ed188af5c55ed4ef6c9f42531c04705dcffb9a2a2e69148f7a324c6c7dca422b89e9ed1b7a92ae551fa8d00ac8edfec17a96c3aa8dc15ca1539885c0f9c5ddc58c332d11fe2cd75b330fbc826db7550c04f028d2942fe521a998c6b415a3eb9f298e8b9c02da544cb225c5f576d628644270723428571742bbb396ee3b4cf4d50dbb93138076051117ca5d0e4f324f8728fe84801ae7e8e0e25c04c5afbd1ea307f9823a83472f72e56f2c2cc4fe4ce1a880677e0cd42e8a90881cae75f3a8f1631886fe6bb6942782603630dc17a8f6869ac80ec3c53616a907324d235161f2aef7c37e28f9867123a7e1ceff970d2f3d35d88c3482628d754278509f5e1cfbe8d1516d3f429d8b2f28a426bc9c4147a93f8863c2ebd8359701880734cd7b70334173ab2a888c83854ca418961d0c56287b825d4aab811afcd88ff97d9759ad155daca8aab36332649d837a7ce9de1c1b5c91c21f5e7e87cb2f938af156ffd759ef9faaf313625592e30205bb6d654838540474c8e8d74a1f9cd6aa62a51fa1607d54aa50469f299ad4b14a8cbd7a88eaa7c8a01783939944324bb97422b7afd65980a22578e448b4ae349bfb79e9862ee786a44b398da5fc7e54bf73625cf0faed304b00fb24d2cb85b59428f99d0472fbb0368e8adaa1097fa13ed21a395593d3aca72ee53c0e3ae35479380917872f2c145a45e2ce04353878caaf730b24db0f1e102b5d238508ddff812377ca42fc3db03af014d305e01f7f47eb80c2fc482230a38133adff1725cdcb06996d7e9324fc050506851696c8a68e00ab3f181166c23866e4c668b633226550500fc47bbb44ee0237a2490d534ad40986bac63e4b323f7f173532bdeedb14ff5863c4ff4d4b324aee7573d0df6d468d88a7381f433331044994e373619f077d0e182b738bee69837a2679372e443081652c7509f68cc09048110b58a8e2dee43a0e1a466c046a65006b34f80a872c95832a997441a1c05102fcfd41fdcee2a9d542f39b35040e5935b7fc402e7a39d145ab2db01a726d6a7400a488e8cb89cf33987fb40dd41f283faee2e4100e56a05c6ac6709e51129a2f2bb8f9ba569800c97f54178c1df1e346c71d8066bdc236d57642e36c1ab7dc0bafbcbf6827519cd4c5377945aabcb020b1702ada029cad6d3d9fb10aa0bcf5e6333f2659bb12589e692528eb44062ab2c67e825df2583f5dcfe801cdf6ea68eb56d1b19d5542acd6e86a93dd0dd1f8a43e4988d9ce96262cf06d135ada34c232b1e24598f3fc3a132e96b9aac980de12f0a0b6f704692a0f9890690af7990dac5ce76d83d96d0eeb966a07f5cbbc8149ab043ea93d4ff008c90fdfd99ead7d35902a099a10000e577494592d8d31c88d42d18b5e83806d3064ea22a4abcee32a855d66cc21a8545fe754958a614ecf5b86be072575397e86764361219ca9eacfeb446e8bb01dd3a6675f3c0efba792ebcc0cd7cf1735eb9c6b7ae50c83932b1247de821dbd2dfa5ac7dffad3cea5eb905e9c183092625b2b827d72cce12e3cb016bde3283c0d93227631b06bda719c5acc5232e46c453d31ba826266602cfafddad9038a056d739dc0baab84cc8c2bd66a438d65ed876121ce909d9a2688ea160d789f0cfe32564f96b4e4d3b8bd546dd8ff4c0ee58ccb241e6497933a26c8df03d628ef1874a9718fe95a6ee4f91a416c876c8687d9d70c3eb0ca44f7dd97838933f276ec2d7e377031d8388a3090fb317a6c74b10039cad4744a26eb957d31f14bf6c7615c6217354851732285283422eb39292054f84b9aa71cc296da6656a73479fbbe6aa54cc4bfe9f6fa09bdc484d5f3d5d912990eb9f6abf9cc7d8f6eec0af598661c5b3800f5b7cbe526c2c6c78e501d001e1361ab0d3b0d791cf6153551aeb89e70dd23a6c69ab190ace79f275bf78569cf23a80ab3676764ab2f758bb74da7ffebe7f7a97905bc139bf02670bda43c5b3a4d039a9423fd1e6b186f7d72bf11f325baf25249c62d1353de5b80a82aa74c77a606c2cb04c22ec70ac5fe1d1afc4325dc24f10d21e600beca1caf15c29f904e77d18ae8ada2550df5dd5855e6149113924b7aeb1c6496f338d6fb5ae91108ff642c81f3e55f296e4a9848117f40ea991717f74ff95ee6af4266af40ce24e790e5bd7b09e49721c8b186876cb29b7c1e89d426a247a3b64b27ea3025c5d47487c03cb578b5c0851d02f6bb224db81e840d90d322280fa7103c2c5d056b0b1f3dd84e50d578dc3b480c958f370660af103c4447c85a1ccbd1d4012a2627b61cafbe5cfe7608e9a512159b3006f0929aa6355a3008b9950fd5af60473ba1ae7750c066a00a443d1b2248c4681139763af5a65cc1731d93c3ca17979c88ed893a7b88480d8d3f709a74861bad7223b0574d01d7d772733dfb3e334642c453f33f3d9421c91d6380ff5754560e85754d15dd4a5040b03e4cf205ad3849eee43012c7b6d778688cb46b1549c21dddb902e1760e37ef0d6a594f8319f8b44966a7f478728a38ab32411f9f6814c1eb04db0c5fe2d0c55af02355f31901fb94a7cc31a85714c79922a017fff2f75b0dc38a2ff83edd15590f2e60a17157a1aade62f02c29f3e867391fcad3cdfde3f868f64e3dc9a1571fe45452fe1156eb3ac8bcd7367f1212c6e48256034511cf42d1efdd183fc2c210d12cb1b510e4c8db52ac8953a612122a956f636c9e4390ff0dc48d183bf14ab1cd6ba44655a0652b28ad5d8290824abc034ea7f868451873ac33905b293989797d295feb4691e418f217f7155b2282c57f40cb0e2a415ba582b47214a6431a700aad775537e38d2eba53305a96eee89aa46c1fe931a421f237cd3360dbdd0e0a7db4fbee469145a9318ba4b55cff517f8a3599a24810e5935c1f6f5decd35773159f361bec57f5e032a52992f847ea1d620838f4bdc6ecfebf000b9ab96a925f3e38ceeae646c67893af99c9f547f6b8d3d62c7b0fe4f123782935d02995216dcbfc8cd2a70fb93974ff93e03aa5e85574f14d78c5140e644135e5a642b30518d9d327f3c9c85a3594ac0428c42d537bb31b7f5f2b0175df979ba21242277939e7a0599410124a6ac8ca79112f64caa88ddddad42c39b749255049990fc087c0ffc74f580f066cb3fa2797a979224b80f39e38500ad71e7ea24628b9c8a6962a51f5ab3e680d288ba28b1cc667937017ef25181fa25e05244c551b400329a092889c466aa6996954f4faa1b05399cbf9587b2121dff6aaa06f9c58eff3ef17eed28351eca144d32c7fd4fe6e06c5f8fe8682e840d464a0d3cd78053cff0203426dfba772535700b2ff12bbbf7f8269fb9477ea21e876697b5e7c7592774889f1961c53276e5cbb0c9425220d4fa10a7ecab5fba0114b998741ea84e62b89349aea25c336842ac512c1eaa78c1e726ade20dc27dfd75d526caa2a00ed3b87db3365ac0e5040e75f4f00d5f3582e2b4c55aad4be42c7291a31f79545ea54f22b6eaa09affe0057a558e28368978736554d576c33189f4f1eb3c7b05982c19c4c04225822e10ff7b363f4ab3329a0248227eb715f5061b0baf5dcae1c75a1ff63684dce76ddf555763087f9704d43b9a77ede1f954a668f588cdf50f3ad1cc39bd167b2063778d01b4e7b78f6bb98231bb9a3e68f98c3f8e227f011615cf46b73b71ce203630547037b0f495058cc0453e2581d57013b8677a35c5f2ec394ab1644f1eb7fb375bce46fdf005d4c3eb92bc5b96fd0ed6ef2262b191677ff811916310d7a6b9319af7427381085a5f2f8519247267dc0db67a81b37dbf869c4dc0f0174cda694df3bb1f52f0e82ad7f661792b0b480fbdf9266a8d410a962c67be2deadeceab2162eb88a56cf3b5e8838fe800f0893d6ba04a819442057e0ee0b7859559e7f17807a505dd8f33c60e2fa36ae418a08e84657e3591e7740713b8453f4b9324c3a2db649a07b92124e0acee13e998d091dd8f4b8808fa1512faa26cf85b2d4829220fd14044ff3ae5fed30e8ea79297df0fb1adaebf1f6459e6c376fa42fa2fed6798af21bdb15a99eec35ca74a7c7eb3364de22df06b0de998c5fe395ab7ba5642a82a8beb711b187b2b6f7aa512a28062b4f000a68cccba7eee0bc5cac59a21a6f5193d6dcc3bee2ce53f073a26396f5dc2fe7bbe18d2bf62b4524e2bbe624bbf64b2ccfe6337ec2798b56b42e14e202e389b2eb3b94f6a970608136daa02eafa81788446c661e85c5752e25d05325568ff5c91c98d2465e0befa287666e2a47fef7a4de96379846c13a554fd94a2e692b917a46caa14eb3b3c4ddeb58bb8dc3ab3dc18f886fd35ee71062d29ac1bd9da9b8360076127dbaff3026db061aadea50d933840b2fcfb8900ad4390bc21156404abc439aa360be7deb28c87b43c0e526c327ac493a55b8fc1ca456135d216646ed31a46a77d14f84791998f3a575d3959818293b3ba855831b5882fb2f1b128f85bcb72481780bf596c148bb835ed48bea766c44cb864b68414b489c778475e1a79af5a3a4a9d078d1820c16e878bb5138c2bb4d381c79876d7c0e5c3cd3e77177e05572d73521e3044de1d2e448c4417ae081b147c1b88f11741caac7ebcec0509a56758b008e22f44bba0a77b5dfc0a8dbe622abac2cb12b4db7b4a9f19cffae55451f74d53fe223ee610d79959e584e911b6893332b96f8baa3b4fa505ee7dd00527f592595be5020031d9dd63f7adaf100ebd25f363a75fc919362e5931bfd11b08f24ceb4e0dba3b6a1b7b036ed46f5ac6b56735ad05e22f141a8f1f0bb55150b10a84ac815b984fd4529a3d15bcaada02372ed73bfa5e747260515e0ba060d438e0a0916b3922ffe9dd9f91a4e66a7930501d4f49dc1ff2c4deb607040a4599bbf992442d0e34868217f75b585a8b5de031b999c0b38f7ce39538196edd998ab1f136f26ac5ab3030dd45ac0583f959dcac723bd605c8b62f466027e78133ba17676d4b76029edfb430018b5797c60c1401a8d5170627fcc0bb5ac36b13948d06b95c9842967f11131f9d54d0cc1824a37e023f8e34ce8ae50f1e2da7e5b6ceca2478aba2a1ec80937b0216cdc6edfa892416dea46f9cda13e6412b3261867f3c0e0e11862787c4818a3effbaeaf3746dd193a0d1eb95261a5b11606c1922d45f72390b172f59370718bb33765e7c7a3dcfcdaa9e0d458cf47019afc897a11b0356df49f3fa573e445ea6a9fbb2f162d0fa6bd7a5aa7700da2508d4efc7e98ffaef8e43bc4fe403fc7da2e17d87b4fc880d519f5c02342fa6ce388359a34bb9cbefef41c12548279997ff5d4a339bee5effe0a6d6bd479294f9b905d816de3c31df3d17bd95879d10ebd59ade426a1aafdd5c61029f1bb8db75488ca858c7dca6d18c70676006cfdcf6bfbfba795264c506807bb9c40513884c4334156c8124f165012ce048558a88dffe13ce12a5b4ce8109c4d4d3dc0b32aaef4a5ae3bb0a2adcd206a32e085a67c2d0e347842e1d508aa19c5886accf09830cbf9caf28dfbf16b7e8b402fe3fba0c5529d74aa40f5ccd8a68d3abbfdd34eeb3b2bc25b6d71217022a3121d727fd28ab2af58b7d6e8cea4aed1af669bd089f6e93f706bac5c8b7058c7eec4843ac9d676a537cfd79f57f5d7a026b2caf47e2a16849427141f2349d54ef46a2f49cd90556d78bc98845b1211ed504ea38dc2a1bfee317bebf7b64b33afd13c337b52be1838433313f586c5b9e47a25049affe66998e4c27a58d054ddce7b00dc091693e2e101270885664cf604575361683ff8cf0e4ceec5583483ae33e2f1b1475c1402f548e3181aad1acffc4eac3f1ec116a2853eb292a4ab7e0a08bb6bf659e19352ccc62176095b999d48aef4ad99d6a5924bcb7348bad115ff7f2b69cd13a8260bbea75e3012e0ba4fc17374a341ce0c29a0ae84669eaba9722965297ff46182398b01b05f7388da0ebdba7ea064259673b690eccd44ccd5b34fcc2048266143fbd7fe51e6e560d418eabe51b428cb81142074283dcdfc35b60e93330bd1188759f232f979be421d2a199e6ce60acde883fa46185e27f2cb436252d9e8e1b0826247322abdb449cbccda412c0327210b94da7adf759d84f4566f99b27e7f719a8cd6f611894b69d937fd6043c2d115add6901e12196304a309ca0f7dd1e2772d6b1886e33e16c9ce620ab7a0ade4bd2d25934c5929daf47bf0b2c4fa81f064e33564e241b8ab36c49bed9f49cefe6d334def4ef48e265f6b6c34cd2e62c3eabe12fca1f9c295347b253c54a46ddb078ab30bf84fb3beb1e7e626022b3443bbc55f24226d59ad0a6aeb17ccdbae079ecd0e02e1cd70e1fbdd1b0013865576cded2713a8bdc530df04157d71a90f293ad5d8164c27e11915fe4c166181972b312fde43a0b3814f11ed034f29f9590ac99ad34d87f1326cc0309e8f07e69bfdad541b6d96b811f84d5789899a441af612371f613b2926445598ccc66790e9588e78940a13e5cb84805f2093a84c5988204e9dc53a26546fbb715aad0247ae7c469ae6ec4d0bd0faa265f6e0807dded3337dd9d59b1c7656f34c52c92b58d60be01ea24de1b23cbe71ad3594694b4539b77641c60f46438f8e251b04786f1bdc02cd38889532bbdb91d28e41ff2d40b027d0a72774edc0c35700348a54ac77861ecfc1708b069536942da5d034489fb83757d1486483179eb70db21d9fbb99a731991e3b63e2ecd2e0434307e90432bf73d8aaaf51fe4a992acf1b14fffad59153da6a096b78c12dd5b0871a329f6168ad45ca7764b9103cf35651b71","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
