<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2696aef02fd730b74ca7c133a537089e32cdccdd0c13ccf2dd2a4970c94d73711994776bfcb292382466f596c6eb1f0458d62f765ba966b75590196a63b48076fa4b412e991ac17268fc89aab0e26fbe4c8b42426624c4a750147659779ba0107d0d54ca9ef6a47dd4c1a7e6069bcc779baaacb2c8538523d1e94e8d69bdf586974cc32dd135acf67e279f1345ada9a01b9c8a7907519765378a029a8e736f3d7a64e951c1c6b83c0df580e53ea59a28ed5892c839cf7e007326bf694f515ccd7014df5a1db1a18386b785a87a8b774835fa7031178d1eecdb8de861d44d18cd60837622a5589688d8d5a24591228571a0cb626f08ee987fc8caab861dc5e1f82b60be88428451d389dff03eaef2e1a6dca81a2a674f0162695ca111ac54c941eb00430ab66b6a824515ff05f31e287fed6981a6202c026a3eee165696e061c6964fe611f7b42aaf14083d082ed5c037e312f78623dc3045b6858e214da4b8673f75de5e7888c7ebf663c182cc27aa3eb2ef15b24736dadc76c6108d100a0047d9f1847b8bb9ae82b01c84b31ab6be994b0d6cb3571e8d2dccdc176edeb86828fdb72faa21cfb3733a6da9ad41ce5acef77dc55267a73e897dfa20f70d54204b54d067b284b56ee525eacfec19b270ed5f26c4677e14388350c92e82ae6b1153ed2335ccb8972a2a3bab73360082ef497ea98c05676ed3359ac12261115cd5e21c11a54f9811ba5e1dadbd8fb78c248aa53eea2af7ffacc9d2154ccb18d5baf8f4865d15db6ba3c273262a31b9e6c1134c6ebaf2469842c65c843568d63ca0b61f33e37aba2a15a0fd68856d597b8fe3d9716efc7a8e03316f38d709193909b600b40647a6f7c40ffd0b58fe50ceb84a4f5848a17420949af943fad3d838752d320e5aa435d836a7a1533e2fa321e7d9ae8bcdcf614f1c189c4fbc6a9e7cec098c1e45f0ce24796bd436b415ecd944a897314871c278130b310079c80dcb657d3252cbe6bc549010459224a892f924fb29924d6931fa789cdbe68572e0a926a319689d324bbfe68c4899bdd7ca5669dff57f3432ea7543b61e976f3017500a67ef4f1f5d28e95f2efbdc65e369b41a77669957dce3b02e1884c07c47a39dab36de2599e2c5f54176d82444e0f715d10d057676fe5dcc5a77d93ec414b3a0541f240c9d8b564c16182ae3bbc59cb9f7f2555688fcde53f6bcea8296b107418df611f594cbb01348cf09b6c888d283e955f40201c08c14f315700dba243abeb3370a0741aa0a58c4d12306d3a8201c0e32c0430d110c7929092f51ab6cd2c12e4d40bb3c363c0ba9a4cdf00f666af43f8f5a8407643b520776b730dc58fc19341a665c6c2ac0765536db9ddc1595c0bb1ece0ffc59a316d4d9506e90cf085988f06c7e4e3bb536fd8606beffdec099751b719ea809d2ed54f25a47626d06713599f6fbe80a0e2b4ed418690d9d1a1137a83c5af334318f3322a78c1f24959864128e038d59dece5255d6a138467938deaebf113fce20bcce83737d83ef6dc7405f722936917efffca0509ab65fc1ac45e507397df794b64fcaf08d89afdaf1e36f7b32e1981bc904c1aae99e2d633f662d6118360d002fa50babf6e458096ebb92f5345e76f8932e8d2cb1af3dd7b352a0d0012056a248eb6ec9dbedf56ee780422cb851bb8ecf4c2ecdb0b3824f89c809417824ebd5b0e3064e6b95ae11a44a65163a25acb606ee599b7cf5ad98e7670602cfb9bbcd770ccf7aefb558b9f5ecf0671885df428292c9bbae398e6723475d540c31d5b2340694423ae37ee93f99be052cfa1484fbf7a9728c840571ff58de991d68132fc751a2b00a54057fc80c3a5e562e4f27c38f19939b71ee707eea87a654f3778904aa31c624e8015ad217f90bcee0c18a5a4cee5a835283fa0d63d0a81da982d27fb14c09e73aa68c748c7318d615d0284702a44ae13fa0ef8632d6c7a21f0492cbfe8fca8cdec30df5704c7013cf54a89ac83a02e5e85e287fff2bb60217dd323fdefef937d5c3eeec1b1c4e1316689cfd240b406a7332944ca32a05f951145d8c4523647a5e0c4e35b749bb1efa8cb2a5042d58b40f4320ed733847ffdfb7de3054c71ada79a717d2d891c7f67f1fca62058338f40039c702aaa1b8e6a982c98b75e51c01feb048ed3ff585311871f35228a62b706dcb56f632e46f33dd7684aeef7931944d69c084469fd0adf4ca1bcc2746d88dee494d7afbb6d18040e532e0b4ddc1579063d0c2a46a1d49c0ad4b7835200198f5d34441268d9c28036eede798427fea6a21efb4d740e00b3aca9f58c2edec729f78cceac0c65ccfe0cde5cad86025e0cc3aaeac05d70e4632d38d909685d94d5cf1368175f8b8a82ce31a657020cab2796d7b8857353316e68fd1e43bd55f95ece0fdc3443a524d4a8d25777703e205c07e320c4fd2b6f7da4888abbacb95b89ff566c0a722bbf82d308a0b9bce1b161813e420043659735fd98ff87692e6063a5d4d9d5be2a714abc7ac871f1a70d4d1c564db563ad302d0174f5f2a6cd704bba102162b96781440d41a112bf60d8303a320c5e0a8120448792ce95bdea17ceb9afc361c66b3370d14d7bd57fbed42a60c611cdbb4269ed0d2aad70e3059c177976f03a6c1afc4b931164408f1f9725aac16cadfe09ace30f88c0a133950cadaa1f7cce4455985e6294121f8fed1e55a1e19a2447a3e1561fe492ef8aa2061f5a79725c9b521048980b81c36ce4cf38b63f4cc9e3edd8a7bf00b8b1991ec6874e4e4388caa7cbd11447d4d40bb611e636be7926821cb2b7f445c16e4f961a1814eb0d7fb123f7631f98ffed485123ad8fe3c724283bf316ad47c38ec191ec6ec193a47793102a85e56c547a474c03de1bb6874d1814b9c12034037ce0b8981eb09b4e6ff2667c8da86ee8b6dfb9793f1ced0a5e143e5fdfe1df18170d31d00e0223fa881e9360833aa6a0e7d46680a9e15d64c25f6b782c12a9439804a3f6acae3f723c8fb77deaad43c30dd4d217624435226277dfdbd7f7d2b53c3c6e2bc08cd76b8258e2b63ebb50f6ac542012ff659af429e7b6bc4974e2058e84da7005edce3ab26758cf49e9284db1c7066005d69d48e95ed1263b515b8fe7f57a340c76dfaecf29f1132ce80eb3484bb6430cab594656c7d46f2cfeeff7904f112ca061054750f7edd1232dda5e92b937ac7a3ac5612c91ac02ecfeda2bbf71ba95eecdc4f103e4ad7c3f49976ae06af1ec1a1293dce0cb60b0ae5c66e655b196bcd4bd3785c18c13702e21e5c6de068cf42408e847487e56ddd8792f510ca83caf99fbd6f5f4093ecc1db4394945a273cfc2967efab2f4cbdc576a52d6f63444e848c679d6535380e0efe2414d5d0700793f9cfc576fbb0bea866699564872e8fbaa63b4e3fcff93a5e70f678d879044dc352a86b4e9df3ef6787969ac918b414450d1e916d3b814852ede30b8d8b38e46f05c42f12daa2a9906f8718a561cc09f7539207700474c705467754b31998bdadbd353715e80db105744c4fbea281cf0e100ec4b23f2c7a4e3c2835082123b8f6ac83b9822174ccb0711a0e2af4122ed576642f92312cc575983407560ac1918a2f4b5149f55d2e4045f86c475da65d490e7c00607811da061d7d64b21780fbf5680e1dc21785afb94a6bf6e186f5770585e419ed72a749f0424fd0f416a8e9659cc376990c4728224d125e4c8ca1d4247e0d8ff24ee2291d4b9e958a95cabc1262821f388f62d7e4202c3e2caa5ef1b6ac012e222e013767da2a64a8c8033b16a568e501ea3c17e277fa8b63fbfeac4aef6809685e1c35a69d71fe2b93ac7a33fffee92de2290acc1c8075cc313b956f6a64a861d259a10a55df2b7434c2cfea7d6a0b0d9301f31775dfef6497984eb2ba1c035dd159c3f460905245383f71826409fd8407cb310911cc7a4c3e7a61de3b00d98db7a511796c7687a5504bd79ed88a706b76ff65ac4a2dab6101fe3875a8d5a240ec74f241ada5bd3e6e617b8ecedb7ba2a2f264dfa7f87c547719acf8ee3c02ff1c1108fd50d7951af2e7b15eadc9d16924f62aab80f874723bf527931ee7f26d62df906d87caf641061060d571f728a8f3aded57abff616acafa4b60db42e43ccc7c8533ecbd43abc4a083bcdd38bf8a0aa3af0df706d72e2930c47aaee7a638362d1f5f48b31065606c3d28723b85e3f57253c61964354bb69ddba20149c8783bc2fcd6b36c15efdb52d58bb2b60518194d94c43ad035bde22e3c1bcae039d3edef493b019abd3cebad879cb2b9c27c3fdd1e8049e691e5987ee6c3cfd3f9ec5229f6765bc75a9e8ac5d0e0db115c911890a25921787dbd61739191df147f613109fe09a52b8613e0139217cd7da53966c6ed4cc24a420dce4851f8960e5fcf1b997ab6dd51dee972e1b4c7d34c6fd3df6e70f3b9c36b4d0ba2feda2f96d3e3baecebd063d29d9762f143138f74cda50016407122ea5597b9a67a7a0c392392a7d98daf62d1b292cf2cf10c6168b81014b9eb59c3a3aaba6ee59cb0552aa4fc68437d54b4edeff91c4f3934ac38015694b708dc1ace9805629d14edd37c45dd0630cf92f3c3e9e861fefcea1a82134d812fc072607220d6c406632f49fe5383fabcdd3ef1f02d6854c489221e43033c2b427410f826b81c64b12670736d2aa8536215b446739386f7da9363de3ebf843aa68cf7da603757b96ff841407f9c6889c1f5c54d4daa9a71fb9090cea4905c305c80a040c84a69c6af05ad09179dd13ff53971c48d539ac2f14f485efe13140466013141ecdfd0778b5585d3e2112a941deb769f956191a5935cdfa02b22045f404d69141fa8b279381ab53492f6b5683815d1948b7b61c02f4e856e44727c8adc6163b94f7cd6c5df3b3289b3d029ba8001d949bd3f6f56df1212ae5f17535ee31f9c94714c6a0845dc4349daf5b9653f1252a77a630e9f7765f54e9e5ab5c7f3643676a240bc82c2c28fb15e2bdaa00c292372d09b9cf6f5dcc585513bc333c4f2a99df94448343eefe9ac61c0be4555ae9722d4d511bfc32e0f2951ca6530aee70b3210e7a67b42848fa7d7967ac385a791f403a97c86c638dba26be9c9570c85de06c8bec078eba1e4bb794cab1de73961786c4930d743c357277fdfd3f1afb23086d7e2763f0965482b97402ecb4982dd2904e1ba0563a16890c8d61758ffaed8f895f17a50136171f0c4bce92545ad4a4faca081adf3b3980b6be899442a04348b26317745cab527159e0c155b5177f8026f894d535e6f62dc7317fc020a4a66f041fea68fe18ebc0ab33cacbc3861ebe8caea55f40e7197bba741a13f4f7d0195e52c41151f6477f17828686b26fc01b2e9651e53249476b6323f6e599c7f54f0a35a6520f8bccf17d8f02459719c74ade6f4a8223f577ff3aaf4d1e10da5f0c78ff855a72971d5fbc42d7f98563daa5e6a14eafcf66f7c80ae580241fd6db561133eac60d322ac6c6b383c0bbfb0c56bee7a8b1eead0647988e7e2ff26bfc01ce41da32601a957235025e37b5510243ecf05879f49e33d8868e4df26119f107316a624bedb7edc1cef425fac53d9adbfb68c5b2e3a01ed8ea81ffac6aac67101819ab08cd0da510239cdd747510c9a03af02d7f2b04dc61462ec1ca81a76cd2a71e316181ddc835a008914e447bc677b1eb28e48f054866cf7834d470a7ef562a03d93e31b9d22ddbfff4a4c7aaa828b84618d0355dc9fe743b99f89fed87955e69a63fcbf9a53f9bd2088e5cd5bf86a822dbc4cd50703c6c690963ff9d92155974bad1bc1b4f418282e64105e815f6568187728fd39544376bf2f2c72b1dff47f305ac22289aa42be35d1aca587379a8a55aadf08dbd3cef08765baed081471d6aaad45984600c6973ac84c02b7132eba7e08a7d54b6a212cf4949c791e5674879534e0589b9df1f574897e517b160c8db5e4f6b6274989c1827a8f538e03bc23daa381fb5eb0cdf13f7c51a9700f87c51d074096c154c77a358d68cf4a4d6ac630058df014f04239931cce94f91bdbf064761adc98b94850421539d1a83fa339385bce6e5e3a4d9ffa998cb3f1a70efd0475019816c2f8f089c4ed383a88ec11cc41f37ccd6d9731b784300e37703e60d72a09eb7e26f118d5ac8d0550195e000f5959e62b835fa73a695cf2521398699e98fc57fe77580a1caecdc1ad381ccd6c22006bba9b2eed79272b4387a08763b549e866bc3d15ba9982bd9d1afd09e52f4657ef61f00e94c53b01125ff1c20980f7194a05522b0941b979da31731b6c0e7402b614ece8a48735d0babce3ffc0e7ee0039bb0c1118133e72fb49bbe8ca64d93864198584c907c994676709d28efdd88ec6c0c42c4d17885e1372e2974428200934ffe8186862fa8e4f83b9efd363631ead030aab058081f2f482e545f8b4cb8a04c20957a3f24345fe0b6fa0cad3f5fc79e983fc775bcb6103134fbc6929732c235168d7cfad9c47e4dc4ce58b7262c7a7699a50e02394c9bcf601ecc98d828674ac4939c4edf853ae575f583fd38e272b10ca54ade196d7a1993825f8236a214b5147106a8853bc57c663fb9eef0a8eac33ae6d1e1a80df58afe3363ba09aa654c033d5d6627f80672ca8e20b0f13747c4f0077518a03a8b20a1c76164dba92eb8b681b1fbd82b8a336a47d40fc943adcf9923e916d5eaa33e35915723b6906b95d112866323dc3a263fce161c66bb1a446ec9c82f1b887954ac71e53affd5acd15b8522265a6da80fcbd2b74206a8d8717944dc9a371b8a145f5da60d2ab5f2036f322fce14539041e0464cbf46e66cba5996e80659ff03a9b41718b1ef7e4b50d6bd053520cf9b06160996ef0142875d460ad3c5ddc4d131e319f9c81454f659c3362963fd49dd21d40edb4c9866f4ab7247bd05520e6acdcb65928ce4dfab7e996343b45957dc180970a6c1be018aaa6ac9f74f8e96878eb4d2e7a1c52c2e5902072d93f6a8587fc6929d3512f256dfd76a65a4411e198cf1209b7a06bde1715e7682c49ae27194d4fb9fdc4356e767f92151312157e24530d563cd4b80dca5998d8cc30d4d07e19d8dc8d11b5afcae051efd30ad2edb07e327971706c2d008fe5b6ca71fc63afbf65dbe1d3b383af1627e2a543b40c4508e6dae3b9f71e71eefa12af9edab5f6c8b587f8b8b19ff69135bde5a6a391e40ab48ac89851aca75a6e48981fbb9d1cb77c37d78b9ec6fdb00404bf3c14dc9f4f38900fbc0679fcf55dacde2ee9df0e5c0f369d86412549e1dd99f94513a297df0ab41b7fb0cff4ba548d47aff021e8e87c1c865eb9eecadf57da1b7893b9b8c46abdb4165d426cac2740c747ef9bd586acebc887e891fe0a32d1af70e2f33b6045f9c0b361f5944aae751aa9b6663818681873406cda3a8f28c7e55929239ec815b5a630d14088eb454ebfc268a6056c6360e2c5517ef1a7847a5b1d05d7ee007c5380e898b0621776992d710abe821e7d4ecd82f3139fd64391e31cc32de1f83296d66c8a2efb87c07809574dd1921869f003372467c8c1920b39abc17a3b89d6c06eb4098fd6bf2f96e5761d2cc032d958cd8d330de161540084e59e1a1fdbe586ac5cef8c084b24bce41a58c73e33f4a83eadbd23d1ab3a24519138afb9eed4ca91cf16a1c5eca5d7aa4dd9514413008add40a1b143f208db6054a4991f8158d3c8fff30f69ad8e6a84c92127ef536b0f08125cd89f95e589ac41b8273c24cb65f2fd01fddeb49fb3e88d3ecac489f0632dcd53a6f7ec701f6e5fdd5cc117025f22c4c1d1618ed762ef3483a104bb9a321d2b72dea33367821bdc023b2bc7fa6ad7acb09964bc133fea6fad2840f6b0537ffbc1f60cb333cd7f392e2186db288c0e21bba9fae272e4c701c242f839c0cabaab4f05883ddeb6abca00890127aa8b5070754cd6f015708b642cb103c1dc1e58b1c8e100a273f8eda8faf4fdeec051724b065bcca4ee1eac6d0fd518f37fb767663910a8a0da730fd5048dae10201e817945924a554ceeba290179bb0f083421addc9b360f2e6ffb1da2ef7dcd53f3f40ac53f264beda44a5fec67d7eb66b7472d91af1af34350582255b866f9c9d9d840d71538cda860f6d41553d56818f14449c2901a6aaae71a9d6b3dbe0777b1737845cba75b356a32283335e494f0bc501a767266353788a010c674b65a2430963512a44b94647086294638cd38d599f80ce916c868c08ee3a0c2977447a9db3fa495e3d08c9306bf802910d8eb6d2d5adc46edbb81a82c6a1ad4ba87a292aa9ccd2a523bc22a14360abfc5e2a41b217377958fc4c53f8f3360085b26e920c4f8bc4db1410f6c9eb6ebd166f4041a0e560e3c2cf9b57006e1bb2ac515d605247c5fbc974be83ede36c875dae46e21b6226391f0d1bef18933957300fe9f0d0a70a6b24d0d8b43b9a2e6f49abad3e298fe47a45d38ddea7d67659b792029f836d4714b86e4f36a046eb699aa59089c6ebb0bc8fcb90b05d71d62825d7650b714ed06e46c196d1f601175bb6b54ebce76ea3fee95cd29f2065ea4563dc7176497da29f208ca95c38847fa394bc6f7bf719850366d1f01912946f3f9f10d3e21d0797d463829618edc4f436765e0ca669c24d7c3bfbb480f302f0984b1fe6e3d4d23ac3ada005083c6bebea24ed1407ecaf904a357c1fcb434347201437a7c4a402b3769575b1b27c417e8040e0c9a69a56ed55ac203e08e784b5dc7855ff64a1c93f63fddc4edfc2e73e0c9615a1accca05354ca56d9b5faf5104b5fd1791ab9ffeebb5915793880861602df0bef7b296517d1f6b74c98da6128b9a6e9698ee69fd11caeecef119b660a8c9a1b8cd89711f3b5c772e4294958a257cb5acbe4d1a2e126271c7cd8a2bc85ebdf4f6a8a8b38470995547119b92143b63d3983dd3b2db57e7b697f32b01c5898f29e6fabdf16008d52851d8577ea68a22c4cc58eddab41062409568f5192d0934436986706005b8c8b0c0883629eccf83a884642c80c71f5b5f2aa211cf5c08cde9380c46402119851f1d65619cb3b97bdbae39b2dd124ce2087d0b2b9487c9e17f8903abfdd6062c6a6614f56f1ab71e7297da647f61869186a3dd93711b445675c4fb322975c18b255f0faccc2e11fa19326d9e6bf91277d57d12b6740e4ffdc85812305549175a5dd7a750461997fb8d8febad30ec7f4c05a4c5c9ee3496ecb3c67c89740190e4a818aedcf8abee970476a41facdb5a49e17cf78724c3e3625ae70834138dc18a16143beb3b3aded36602c1d4321f55a45a24031a0342386961cbaaee790ca4970f9aad801c9626372171dbe825a84b7faa4b167581c2d845361ac5efbb108a8ead81276cd49f1bc8b0eb1fea399773b5bc13160f3a4087e88b138b24acca6b1fb02e1b7b66ed8c84a12339d39b4b3dd2c24fa1094bc03f8a4a3548ff201ff10513b0f6e56ad9381cc56bf220b01b9f5ee7555674dd9605b60f600361220c4b4b8f6d1d1b6f7aa9dd274d4f52c89262b6460c4c56e6f73e881df193ef24175737f39ac3fe5ee11fbad9ec69fcb42d1452623fb5cb2f793af112cab574daae0ca359d940902a41adf66fbfc896f691f8af4fa3dbfb96c3e5cf578eda52f19deba7a50df374125e6d401d8ff36f0c6359842c1ce67dc829bbbb7f43540913699128c32e0411bb95db83e4f43e868bfe96572280d12d2f5c52d2f479955ea385d1c47980aad734718d47e06f3b14e58fa6cd85aba7b74039a6539de4d0b9aae8f5f7a116f92ab03fd9f50c5a9da7deb3fb623576e2376ee913e5ff60135af857c15e5b456193ab0f71375d6a85efcc34e75c9db07691586937dc358d7f1844f0cbdc35da4324d34a714b902d97e11fcc30d30a2f58bc5307adc019a741d97e09d90ad4c12e0560b594fb211c2c53d49f7d991b73da6b451f243963084cfb2e2fb54bf71b33ff0711670338267bec96929d40d6d34fe9bbfb1c1a0e4eebeb00a5c3320ebb0634d4d58256dbe5761f81177a8621f8e023d238d20990a74bd5a1d63247e362e110e4328985cf5fd0f45b72fcc69766211e43670a4b1b9a2890d93d2ee60c9bfd379c88f8e414602daae346dfffa9c8a61db6fa9db4e950dfb602bf48fc79d4318259a46dc6d68b76f33f0dfbd3e4b57e0c8bc451895654084ea02846460e7986c91eeac1b2193f17ada407ece565fe59364087646e20f880bc0d258ce2bbdeb2c70e923fccc58f2d961d80acb5cfa2a7df0682f2aa7cac51c77d34ebe409787c136fc17b772b3751ab2a74b8c3cefc9da949a37c5aa4600a195c712008c3035b62f036cece2d2985559fa64530a117a835187363b19f744fff395979a8f320b7a62e6c1ee63401fdab2d4bde92b26d523e3dfe31830d9426d77283abf8dd5008b6aa136746f4f80f8a93794638c11bdae581670ae68c1dc57b3f1017855919e2444e8fdb376f475d001df398ca363b8cb4ad79639f5b887aee7bf95e8fabb10b63bf455976a91e179cdd10a37b2f6650e33eab35e7333d8ebd92767142f1663cec8feb82e29522280e1257266454282f39969140a588b4fdb4e05d0326c4f902ca9daf0a84f5eec67823e062ca3a1420734a56b867de78b41506bec1356cba4336cc97664675d4af528a05ac69696197d094c190db6cd07ba7505bf516030051099c0d613065f38f9ee8d526b2560f6e944209cbb77e14a5a4f18a500dea871ae254d6b102460c166b826b2258c41848c40385fdf2ff33675d15938cd6252ac79d8d4e13ff178b6876028955b6d95d8f6ebdcd309967d990dfa59c12bcc2574504ed7d0a31630058473439584dc839ca2556fd688910c792a0de3c3904aafad2de887f35fd52f473676c9f52b66396a2b783490c506597d34860c6d327e52239cfb13ff496aa0a119e505bbb0745024397286c96e2fd62353e3f36556b275b0465329a1ce2c9f5bb349f84b7d3829eb5ed7feed76c431b71ee8127bba4c97f6be3929dc34f935707db361ee3317dc695059ef1ee7375038dc8f4bbea5127fc756cc23555ef30449ccec3d371e99122d38b7cd91b34f7bc5c8198cd6c3727dbeaa0abfb6099f2a23e83828180652f30878cebd50433713b4827a9e39910ae053cabc75143c5a3b3c48bfd9714205a805ee8e71c7c91df4722331ecdef45eab427da96e65fb8afe2b50a5d1b60cfa1782039a628825c78dca34d2e72849f29a63eeb674bd7a2da5da3c0612e6b0fdb5887a58ce8d68cef703132ff9edc1c0417ff578a5a916421dd439c4b0a5ebfc2882ef76b95adf7a90f9257dbde43eddb3ba3b14174ff8393c31ac9d2c0024ef0b5fd6f98ae46f65e2512a3999d0fd8fbd4b07353ad207e4709091cff0fcefc0ad3c0d636dc370d583d3999cfec087417a17c064ea812e3fd4afd916280d9369c49250aba862ca8c76c30d842b7bd6979d69de79fdbe65beaaf1d573347152fb98cfa30cf7262dfac2f60c83d97c48eefda0c942e58e3cc6f4c2de16f4a07716058d53e7cb75e2b63648f75c3ab111926099f78c3d3d4eb1f87695a30fd15a7bc0c4075852b8489da62ebb384ae5141d0011e38bd2b18766f370e9ddd32e468c3ca23a8f2ae5b09cb291d20166301306e63ae92b0955565501ea8188dd2580f36cf8a5e136458e488c741fdb05ea74936bdec6a9c8633b98280ed131cee5357832707f5adbaa6c05cc198e59de9d281b16087c7c64cb9aa2c984dddc6d7e0e6a1690143e39a8a12de1a3cf4791a2257972ecac96c9f6886e5142eff7885134649659819416faa51070b0d3ea5be01a77cab386b32195b88d5463fbfdfe70065b116dad400f3e39127b8b8e278a2f87dc5ddf64a94443b7dea02ccc8740165e3f7c3d079ab5dc4f8a5af1c08af9bcd4ed43c43c01b01d3831b49a5fd4e366cc79d1e75081c7646803ea6416aaf21e526a0b9f6a6d2c0f744b07caa666abad675aef2f5925092476e8dc610f935f15ce17cbc15b5b37b0f9f55d629165db8139ced751271a6671b492f349f1a22b404ffb00edff39c76b69ff1c373e68001ecb639be29cd2194e105a71fd4377be79b22c61849efbcd8cd61fd8056ca5344997a4b832937e24d603463a09b75e14074f5eb584e67dead86c4474f678cd1762e26a06e886a9fb3f8b31a1f887bdf5a16e9fbf9554c084379999ba4154f1cd750ce0baff72a4a8f1f558f8d96b8c15009ea7c3ed7fb5c5af4f40483f51e2f2290603d7e321d074280821c4f3ad44af52d4d4d886f1ecb2684d62c1f22448b92977bba9779b6c4c610a0705ec04551d94ad1bc9142581abb5eb5380f32dee3616afa858f4208e95696b54336728e23fd6fe23796ee615eff5aa7014463967d42a56181b30848853e4d4de59bfce2c0d0a8e7ce15f48803336096f6c04624b2388ba99f86453ba6bc0323a0853f5c1774671c67fc49ca840cef863f3d83f7260203ba57582fa451bd9cf2e9df926d9d1b060263073e3200889eac2c2f0388753d1b9c4c91ee312faf9fb7c8fb5f85f9a3eb18ecf35095766d7ba1613042b7129b0a6b935eb6bdfda1770f84d0389ec80d3e65b0984989ed359a43b43e668cc4cf9da53e4d847f31db676a60849e787ba41967bdc80e7706b96a4334d7655d8a5f3fdedcebd99c751b73fa26a54da77e7b78c572a572e6ab48f475aa73f44049bdbf8e9a294eae3d259540a830a7e02a417b4879caa1be1fd3b2f77ef9115b2028a9475c1d321047b4aa0ad6450e0469a5eea9777384a3c38c0681f238834a9fe0eac77190830221e2f12f745ad363f881fac5c4c32c3cd516446f220fa69544a88bda9aa227462291b6b77326b3a06a0a93e78199f52868db4e414368e3af714b487f97fd53fad867c8693fd0b0140cd1ac935b6724e6850d470c0ff39aaa435238750f093e935701a7343d5de954e3b228b85705437123038d2d53d46c9162217f8e6324ea6d737e539b3681bb8db496eb993df8f13cee342775de6acb4240354fe12be63afbfc5ab323046c95523dfb3a27d3cdd9d2cd7e04377e05f80ecb8ff5b6650aa7139529e68248360ff2091e3cf922eaa09b20f19eeddbcbd6d6f006b53e89f79fb0e02bc9f2cbdda1644612ee884fd4a62565f0899758bcb6c792eba19a8523af7168418ac7ae63bc280fdf82616f734c031b51f9bf9eea25c2e3aca7f23221845768823635b352dc6f426a049a2a27b01a6cb66ede1063f7e74fae0beea9e3d2b1d0c41f3bc054895564c220f20fbfc9be74911592b5a1c03d41c3296a4d25f53c1eb0483774072556cddbe8c4f65800fa588cab2005ddadd6aeb54cb82596ef20fe27eaac3f198fb8b7c044c5da9197bc28fa5414fd56db5ae19689aec93e7f689d2dbe847dad12c1f09507075fc18b9e5b891440da8dd4041cbcb60767729196695c29468b766e07933926c48ed92af735ba41500f6e1d9fe819f35438be25788caa6f1526017bb82c121cd47e3b7da82321cf10af431584110bdb1b581a952e17fdb9973e0e5dc9a3486a300f49b5e780ce0a5db9bdc7712427f81ef960c9f833c49ca8997a8976270d179770eb84b4399ed5a0bcbdbe5277af2cb3c6b0d75ff9eb0dd3c89f5528146cf3ac102e6021e5884d43f43c20264cedac82e30e9ebf64d371e7c1e8f98667e88b2af0fa49eb6146e2c4ee87f05aa0853052e046fd517d3d8a962ba5e6557c8698bcef8e4fdbb382147dd76e7ec84928eadc093904bfc60a5cc987569ad8e801536b8cd18ced44b529fb37ab41e3a6c0308024148967e4d662262cd9810cbc57e8c9212bb92964d03b7d8bdfcc0380a4b8b0e153c863a18aa03d5b2707d4c3e133283b9c5d0960f6f03090a894f07c150781485ebd6f3e146d538913a0682493769c5ac2a039aa899f88c931ad5afc85774b7762dc782bb7cf48b81ce4d9597955fd04bf2cb0926112e04f0be9fa9e8e8883ad050cadcc8d5a1044e80fc4fab176c49b00b7c908872cd01645dfbd8f9330e4fb496e0cfbb432a5ec86e361e3e5889f485210a55f6e85ab24266baf3cdc71e9d2826601692ddc65402ba9fed606b9e0254aa18f193d968bbe53b8e7564f4b3b8eab4812bc022cfec3b48cdf0dbfc1f3e8795aa0a2b482bf125cf0b6ea869f188b0e3e94d47370e18391eaf15fdc3bfa6f543d3784b2579e4f835f7f8348313ede46af7833998b1e40704514d7067bca818283958eb532bb0f5ef9a2edb2abc7b3c068986f24d356570704f6c17c01fb9b0ab386d22ccb0275a7ebd002ab48b2045793499c963ccd5aa1a9bb9cae86c0985954d82a156bd9caba1a1d3cc7b9e318f7e34205eb4a604ce8c33f249d84807acb4ab69ab0b040d7fa930145e43127f9628755eba30bdb2319fa0cb2b319854c0137a8741be112b4e8a3e8f9f348f4af9526374644d844c5ec111390ca2d6a33b9f4903e6b3cdb3d572e671a8808fca8f0d417bd7a3501f02e2c3ccaf699d1859c75f1730916b99b0c557a2b43013bc4edb3163e5c9e080ca818e24fba855ac283593d06cdcd09c11b9c0027f78c896eecf8dc918a1256c232563547348c26fa65fc2569015cc0e2f5171772fd7a42cb2804c456e47fb4c62f39d541e1e9dd7e29c233bb96694a108526fb1454399690ab4dca6a547ad49edbf1634a111d2d117794131a7eec09db865cd6d72eef72a03e2921e77d1830e5446e24c5113a18a0442bd5482bc5d542de4570ce5ed03687d197418bb33d318124fb8d898a0e5d931ddaa8fd6a66552dd0aebf69c5aca951e52478666879301c2aad21626db14afb5903a7ce252a65dd9f2134f3449e2e68db95b5ce8469b14d3ba9452a9c1d0409c7b404b24eaed118caa77d816590129b5ef357157eef6ac8f64f5068304b5535538c0c8ccb711923893fcf6f9c1230af45338b91dce0baf09bb24c40af467053a3c9a2c0c66d386283c9403c29ff14c2e70d0c4f496be7d16cc922d56963222335aa2ef989d6145bebe35043ef1257f8247437ff8aeaa19b2789a06f59076aab6ee2112c309ba01ebb35ef206629766c87544d9871ce71e1a0900298750de65dbfc7054a53121e8d6a0f101437658fced9207e8b237d61fdee6d6cf0d20dbe60f0cba17279deed1734","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
