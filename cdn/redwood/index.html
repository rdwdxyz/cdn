<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f2b4c578f39fff80b5791a9b891fdcabcc37ddb86dc73e9b1985557ff53a2292575b275fa14cb5d46107f38c6f8b728ec2dee5917b49a10a862930d63324480a49d036f836921c021e563c7f79479d5b1867d2dad9f7f218a49051c03f90ccaa3397d2917e9d2c8212eb226709ad9bfd2a3d7d98a433d415167ef2113e2b3fe82f424bc6898bd516235c4722186298ff17ce4a5fbaa054e774a4a8f74ac62b84c9ed37715755e9b6ab89fe3c104befd3a43b42920232f89f701e5da325cc614a96ea8501623bfc2d4512acf3c1de73f759369cded32931a29c805b39e3d41db4b837cca69936fbd718e518ce0870c31d07fb1fce337ee1055277c2f129a722b6368885d340c2c47406ddca0ec06a0776c2a51cb5d871766f819d1205205d8f87551cfbed41a377b4fb5f419ce64aa6c21a807f6cb07abea8734be1d7443c608299afd6cfe9d824085aee450077ddd21f4211df3d19247f6b33ba3f48cf2e6350a4016cfd981247ced61c6e3e98511ca0aacbc59392e7af51bd82380ba0589700d30ee41c11c16da7224b742f26e679ac549ebc8d406d4178bd1e95e06bfe7914d9a9c7bfa62865d09036d966a4d53fc20d60f53f3db9140b0ff5348ab7eb741ef1e79991a5e4c68e92673ac0cc195be65bc5826d9812cec0ccb96ac063ba77cdfa52ac8c6e81f80a36a2999679f4580f8d9a2020e201741243dce7b2b1908fcbc975064d514118240c0d8ad629a871401cc79dfa2675f99d743626094e0e5d73f1e2ae5f28f7ada37c470e7d54f86281d4064f6f2eef8787a03783bcbb94bc9da04e47feddac50e728e66a3552b55a2fbf7d5c917c617a0a21d13e85943c0be2667ed9763b26711c99e3d9ec1af687d049b0a06b3254fb2388ab84c562d428432c440f9064c773a94261dc28ad20e5f86fdc0388e5eff9fb863a919f0825f1249f975e538f12c4dcc971fba76e10e5a76bb17195d0cb9110a676043277dfcc0d4b99aa397c63f5aa35e676100ee8578dc9a34143978729980924c01c7a219659b0bb763ef652f1d1b030a6ddcd19f4b4fdb404e612e666a17f74e80449a6f4b7fb2238157dbb7a530253351b2c21795205b34ad7d7c00777378492a75b39e46a9a947ef268930db7765463b841af7f485f2e219eb82984ce8f83c4fe219a283c1755c2db3f029a36dafae1d8a414b8fe3b8dc1103434405e724c3f49798273226769740dd39d9da2b6597cd6d32b9af42356b44384cdc6e0502162776a620b2b572dc7e0cc6efc8b5eabf6a163aaf87bc94144a11b9bd51d3205e0faa101fb7a976cade4c9938d496944e0e3dd3cabb9c0f5596b95c597e89873c09b26559fc5131b09e4f84675656320de6695b58d3811d1cc2a258f9d99e13730510c523e1099ba077c1e4a3cc06c118cae93a378fea9d783aa5e8f87c7d2fa2bb3ec3b2b185f7137340e40b695a29dca42b36569f34fe3e6776054a074e6bfa888c4dc26c8c2e18268d4709211d886446145c5d59b1fb774b7361bfb8b28b1b3d09f003bdd74c4ce6a3629932bd630bd687c4751a383ab22d424fe0bd073380004760b1dea22c1cba91967768f8530249cdf86ff89cbb984f1e183030b9f6e4f12d52fb1a79dcd15519ddbce80ec166aefaf67ac2b6e10637922f6322542dd2e6108a5c8e30df32cb2c3822598a9ce378950885f3652eb0f28214e656534d804ab66ab5719707bcb4d817343b21d53451c5723e26716bbb8ffc1d069233d02db417b99b27701970339f5a6f0f2b826e00751b5a478c6048aab07545eec32fd6f329b76589c34cd0dee462c3f7eb36752204b3d6f7432400e82ac9291664a14689ee37202760b0c434a4066bc51410d03e31e5b4fe698c503c2aa7bca5f68bc1c34a439550df5657806453ddaf88dfc772f0ce2bce53a2ea260d3b1525ec1ed0c467e5242dfbdcace149a146be3219ab19556e1ac05547dd1cdbba6477e8155bfbb0bd645b23ca5a89ba5a0583e6c2e106e6f2b28fba30e41516b0d245069ef7aa2f8dba2538b38ebd98c690dcf6bb3b1f4b288abc511020587fcb13fb448764c1f08471f1de704c82b71b69c8f0f7342935440bfd22ea2951ac25f2c1005ef9f9ac4f226a4c4a48ced3dd3b47893f1305af209127cb59a80fd21c3bf63ff1474656d44384ee5059629bf5ee117f2036b9bcea34cd0fa872e6876888bf823f25e74ee4aaecb1c79569dde65cb64ff51f17eff2b2b0390ebaf3cd3f1a30614f2487b94f6830a0927130ada80f2242403f51113c34e5dcc5e0d203d3382e7266b72b3f93de9c6d0a76eb16784ccde99f26dde7cda64776461e92929d16c5d2d809c8eb35693975d412bc91c03fe434baa1bec02c968712b6c1952567336a4b1b43000df6dd135093c74f3e2960a058ed0240f059ca5f7f26b0485a53b48aa450be58ba00b8fa63b84d2a09273fb2242a89af3a25b6149d2a70487ce0e656918409efc16031f4fd7fbf9a43a1d2072f43cb6d23c55d72f9a9e31bdb7583744e6ae0bd279f978ba17882db03e09b85c4d64c173331c2ac371bd271fc3cf180cfd7ca3717659a86afe0f6538616371d9b38e5bdee5c043b1c9062427e11bcf3ca561dd2b1e0d4a8117bccab73b707518cd5d85850a27feb3ba2a74bbdd4caf51b335e937050e68f1df01a978043e65f24ed3948fe9076f256d54b94d7b85562f7f425837e3373f3535d5995360b01aff7589da1aa91266ccce480d38fbfc217216c90bb9ae0b0a3c0c3c83ce027312743400423db32a0653e4c6b10cf7dff85ea87610dca35c4e8d9b5ed0bb2270f275650907fee37838515750b3f6b3d8a226242cf3899bc4f264ec6111ffd37829feb5bf7a7f68999e6ab6e1d4657c2ee8794523733073bbb2b37248763037e92d2e224f5d47cddb86a869229b03c0ed8c09ed578773100a17771a3cb63a781e1325f3df0385791bb7cf9c5a7a635c1dd03dd92ddbc85965b595fccaa352074c80df6ce0ec08ac08663a23ab0afe17761ea4caeaa407504dd36852f0844a6057c6ab0ab185b39f29f4fd6c35a26da26f39ff43532162d8b6bfcb007c59912cd357b2cf8127c77a7477a3472d71b6242047364eef5283a259fd1dc7d9df0ff1e7a1e356b06d24b2b9fdab9e3f84cf41f60bce717a83a025276c450440adcc0d7a02e894f5244e0159a588a58964a97ac0ecb5cdb2232837fe3d54ab45f7bf4b54215bbe3509e2ad0a3cbbffebf684833766000ac10e887cfa4eb24a6bcda32a0f50ea53f56934b5f6b4ed42858f1c4e3098a3a649aaa7f43b11fca54303a91a7082cccf532c66aba82e0c9c7a42fc2de2e59d11cef49f83a7de40dc415e2c6e3c1e818c6e51edbbcd2d4208acf5ab1931b4bf3fd2f33f89b2970ad7fc154832ba9c1050270cf713dbaade244ee6ade6ac93c858eeb2069256e48ea11b99294179ed2820194c5ca021a6d87c3e2f4ce0325f4bf2975825684ced47880ad4990bdafe21939b20caebccbf1d7cbbf046b1bf7add87fa7e038884cd063cec0bb3e11d10af94e38ef75bc001ede0a1d44fafe303007b87b16cca433f8d2425ff4536a9545d640b6a81000cdc524e00b7fd9bf7d159bf9129a8b87362d7aca8d907f199fb68733ba24769414de7a570a319aa31acedb0b3aadb02f28a6098e211b52f29b1ee79e7f164bd363fd084400d602731c713a716abdf3b4cee43392de082e204ddb0138fcc32fa02dbe6864735621e806a13ee71640f0af3323a5bc36c7fc82454a522aab93f54c02522cec810ba423a524b8fc5fce6d6d2a9ba5c46b53c73c7243308dc510e787a903cfc8b4f2ea1596968888e3adc3e9a70a21aa4b1fd508f54c2d654322afaf7048a4f3c8ff61c802cb4baebe81e7e67c5783a4661817a153ff13ddc7a4dc572e445ac52f03ec7dcdd7c480d592c8e970fbd91be3a8e0e752d80776ffcdaa6fa8077935f5d529af95b69caa49e55b9c613ac21211a1ef3b07d2991fede7fb12ae12c1273ec99673034392f427c300700e18d550565fd74579931c22f7f082fd4c7c137741f64619e3911520393bd339106fa91304aa1063133f330ffb50543a1e9ed178df001cdca9a0509f0b0e0e9350eec48c70244deb035dad92f0723d515c598131233cbe8f890d436aa651f0443c6e713a0a9816e3bc383b50c768299193e3ea2a5d8ee983e4d452f391066b8c57cac5b8192c3b26805195a361328c813e2a50b4b9453c9ba7c1feaa4bf8876b63c64b713c5ed0e4d976864392bfd62d06bc60c190d0d6d50a6b27791e45cf850b2e249f450f8b0b9aaaa1b79651b49660b984c9eaf3ca2340aacc02c9a3f49623e425da6ba02ac0e81c6982f6658c970bdcf252233221c8667570f0cfead95987d5b1106f2af94f07223f58d2f2ef9ef72fc8618e7a31fa571344c2b868c65626db274572a364d62cc75cd6d07bdae73a4e2a1da5a301176c567f4270ba5765329a582def0d20f6cd07ed7c5bc654dab16042abd854d9ed156621a8d6865f1682f539282a25042f5158c169301b9359f85ac9de9ca72bb02207c84d8795a3b1241db6afec7c2147273e01f26a2487619b947e101faa3cc8f1acde43be1d0d5bd137ed8c42c6539d951cda0680b979c58eb9ab033501cd62fade6eecd0a9c4916b26c616d3e919824056dc7a282e6d726aced6cbaa30a732328a9a7d3cb40e1f76f3b47b6d4a1455e31bffc45d6792c3ba4093562364059ba5d8b4bf4900a3f2d77c841f74accce8629241a7d62b848e9f196fd5818c7b9c734eb1fd81e1b972ad79fdb9e922e0fd912cb8c0336203efa8bee9d9207c2c5749f542ac1e0daf71072985590a33df3952b4d89387b49af39a9af27bcb8dadfba82b3767215f6b9ae87e982d1a99e1058667b1ca4e682ef42116b568453dfcc2bda0b51989294730c4efc850a319c062cdb96219eae419700a0c228aa4b752ef6d1cd8efabd5e997bf18622cd2e75d76a1d1f41d6e30dbac0bb64d554b768ced124e9debc614e6460b9ebd957c9949c4dd4ecdf730e1ce636f660223eabf69f32686332eae0179b86076e42192afa83fc9248d17651ca6ef155b7c0e5787e0d7f0c311ec1b81c010e713f82260899b1daec7432c8c837be09ae74e16f9c744ae412edf939dbc2e093b989f6acc1e0c036e62a2d752dcf39fb257b55e4fc1cbe9e46a30d2a3078d18f46c4cd5f480d5b6442ccc5744a7f68fb5492f9822b91d55638b94993475b112123b5c4625b9596671b0f3e62796b5440f94ac742946746c1fa049f0bf49161758aca51d976adfd85727548306d833309423912da36ca3c2c16b180806ae7d75883e11710161e9870161c8d93a155ff5635bc75c932df4352a26a4f71080c622da98a32b85f82605c0a3df437c9ac536b2567bef830491fe789b12b09c0d4744d42cbb55394c90a1ae7f001febc90c69fbabbde4b0e9b2bddcfc5a3224919b039aa3a4aec8e434ff144750609cca9fbfac65b19e78a0a4db2bc24381fc7c6532718addaee6f4e9ccaf73267e9b7dbc8ad190858a7e938e2331b0a720087b9287cf70be4abf9354412399ea8ba3336bdfd5d2cd6b85b50ec32241046d14dafd066e25908fb0f88adcae60089e3eff3d2687e170248a673d1d0eb307b14a0a25b597d7da0ae72894a83d6c6ba7b2dc8a48df297690502c3d5187f70a0174990c200b9179ebaf37bb556e411ec520a72f919770d1c4d1007e03be9dd7c0e8d1e4c49aa752db4b618623985ff6bb8c3755262a5c8234ba3b7b390d58be5d519e0671c4742971b4e9b495beafc39329261aec5df4df18300750732ac40c67d050eb75cb8fdd2ede930257b1296cf8be562a8e3ed2a8f05b5c2b8517c6e65330ce902b160a6c775edb0ce5baf731def441cde5c5252a0474e5b9b8c2bd907399c2e716ba8d77f38ee38e775f1cf8f0c19a206e5a5bfb2d6329d37ce1718efd64d61e972087262f917ef584a9ef156ad81949e0cdc8dac83f3b0314d29ced51dd89620f39ce6c505a80a62f8a8e510b6e53aca504f977a19755dbd3c561b44920e5e7a0098130d63b8bbf14fa799aa4ca3eac571a0af2a8e09da9d170166c1744fdf12c92745d7629dd036786f1c97f1bb9ba5ca748fb4537a134fd7aa6734f1e6014bd64cf6249a4a166c97af90cc465f5d93f78a84f9e945644f15914f29e9640be1a94b84b6cfb071cdca862d4038712b0219fef02a11399662a2b7a8c783a8d8bfd5e83aa22e23eedc9684da0a9af401deee13b8f260db2ee3441d9db0650113b22722657fb313b238c16144df19f7941c44845fc137590426c94ecf365774b2b6b5a5d06246824c50f315087cd0f8cad9a590c2ca7c41be6fb449289d587b0adebaadb80cbd44fda35567dc3fba9c7751fce02749741fc7180706cd399b87190ae390591b1a2e7bcf260f5b45872562b75a188ea836f5646bf8323172b60c0fb28a1400053533473ff84d3caeee9283ec20033419725c1d11615cf3485a24f171946228e7a5f7613c7c69c31f9feb8b78f78ddc4930de6f2495c8c3c87e10fa34da08a73b0f95d7235ffcb7846b8f48c295fbed28742ce89c7638e42d7d577ba0e50093831ec13e136ed10c6c07ca72807e4cd0b8a89dbe80ce510b6941c33926afdc4568fcfa95b2569945563239edc403057a7b4171f3d36a254e8c7892bbb38198a70354fc2dd3d4310cc4234aa53ef196a9cec2663ff3398c223c7b49c111df0bcb059aec20535d4061c74bf2e503c0a5ad3773100a2a124f9d753f28de26bd2a8aafcc972c84a2ebc802f3ddaa93cf5686ff175dd6c0a32652f0f1bed872f7275a470eb7a958391346a634f80fbb9d52935d2301eddda00c3f9ab1e7c9837c00ea2ba06c01260826a8a1f368ecc93a85bd3baa33bc8900e054ddbdb8925f894b99e7a99f3be878eaaaa65d30bf821c5c6c29658e30c283db8e78484961db395bef6f19815593484e407712bd558ff3a80a8d9001e5fb9a2b6d83f027c23b032ecee47e6c03e7299f245af5bdf6c46b45d0bf8f3da8ab0bcd77cce84199fdc363e4312e3ab2e3a65a639c6aaa0ff45da39b0e683593271460ffe5f12cab7bbab4c3eb897e25ddfb907f49ab64c889afa9ff80216a2e317aa8acf73fc52b5d119ac974321ea4d0d1e7ec3c644e3b3471b4fa488277fa74e6f4b8eec7651e98ce940ca5d1d4ec753f0398bc4b05e2b714910f0909a54b3eb64a51f3984f94dbd645fc2b98bd2fa115ed84b8e9e37f010307283059175efe84c103fa9ca5f4ed09cf0107e94b6902105a5b01749a09b229e0a94c10b3f580a81fe1273a58332c9ebc94a7177da53d9f55fc9b2075cac301c24871163e08316014eabeee61fcca1db427349bf247b232e499ff91aabb2d5a3813275ea935cf5e1f8d68265f1c9e56d0ada3c13b00d44433576be496e66a30406de44dce5e339dccb9c8af9d59a59c47db92977a9633f7df2ae18a12bd85843c37c5b397cb5398be9c73f2b620999ad3ff00ec53a29c4038808e6dc072a847097abd8e0f8c57056860840393bfe102ccbbb954f83c8d441a03bbdf2869bd7a61f55439fcc5d8885fe8c31c830fd65ee2a7bd3f5f83d491a41d10af5c613893c7f4c4dbaecb5a95751c51d4502d5a95788a53b2985b356991bb1bfa8d093b609ceca0ce8dd403bdaa0546b850675208ef68b4e1be2984e02be028199763d4e940ff9872c24316276c0473e0b9fe670b4f72f7aa2c181c8ec5990e6e3c28e920f5fbc090e67dbacfbd84205429cd11fb2f0fd5ad9f1cc3d2e90796354b3f14eeb63ed9c4cb72bf40d35e675db73c972d5dfba2389989ca3857d8f34d2429d639adb4fa0c673875a5ff7596c8275414e1a4ba372e6fb278abb0cb2b14532c1132fb8fb86a561bceecd27c087b9fc2777326eba812a1be07eac6619fb6f9991360a5f036c046eb6bd725e13de45d00b50871d91934e41e6b7a32798286a5ee405648d37f97313434a56470257a545adb0847cc27dcd4c0cd70be9eb7fff9f41dd8e00c17e5c55dfb5e64dc0ff2d96d6f2a246a554c63d468c27010c6da2b0ea94f2c97c5cf6f14830e74782810da7d2b3f6e45c21e4dfccbe58e99f6169a55a36c13b251059688707da4005881e16f423c8dabc91929506bf34da3d12ed10ca581f14748b8e4377a5f06229ad46c3890217da00db13998c32ce1c626d8aa95d55dfa29170426fc0380ac5a42d72a07077ced4c755974150c16aa1706b8fc106c9c12adba938f39609e3725ca0371f383756c3f967380272b4b23663a84c4ca28f8c76c77f0386004068bb818ebd99bfe84e739b1d38fa81fe88df7bdec66535c56c565601d0c94e9fc1f388a00e7d485a5355b4335ffa7d47a4c7c2f6e17dfec08831dad4c073fd01a38209f11211e3da10bbd3c8650ad7a1210cbfdc7739dd5080136611399c53689acbc94e3807deac2daf544b51be2ae2f8e3cc574eb49c77096fa9d96b49fae5dec1e5b8fcbc2d1eee205db56fca40f6d176b02fe626dd2b11060e03bff6e60da2fa110238efc1c937eafb66bcc56993965e0317f05f908343d8e4fe5a8e17898e7a105d1d3e4d54bd8b353b39b45d6af9088f80fae08b19e0f8d02e3232398982feb27803c39b6fabe08c30ce29ae8cc88402e74f70e77aaf9a4574f5227400ceac0a6b31d871f6bfb0c80075923f66cd61318b73ba1c028b4f5ccf2de9aacf75a8cc96f53b134829fe67a8d7acb8b75467d73e6298b1666b5e90e1dd9520e35ec9fa8ea14e99472f2546c26371f56b8e3dba4499a0bbc95e933951285e64af54c54b3a78f665c551c9509a6d817dcd668c0dbd931a81b805364c8f011a9b41232abb478e67fc849502fffb688abd5dc03e5d6f5183f8480a01e263dbb1f966c67c02e996003aa40784c22224f7829122098eb5933fee18cfb5bb9464dd26e1c819c6de528c014a7ed40cb9812439ba63520618f208bb62d6c366f8c8fafdbd9a706678b452ff198ca3c89c9ebcb56aacebcf11ab20416bb52d9ae92802fe560e51b86c6322c36afef367899bb35549fe51cbe011d59bc54fa2d74837eb3403e50eacdcdb0b1d30439b4a95a1522dbac7b7bafaaf6f8a9b468c22da9b47b2f0307a28fb9d7e1a5f05f3eff17c2e0b414c63f3c815b77ebf26fe31da28e7eef7333061157e32b3171851aa34b9f9686f034107e88aa223abd4f7e779940270f6ebe4960268c9dff4c19011e58aed8ceccc3e18d3323860d51d7226e37a4bce532baaa90ce47593f97ecf3785f546fa582696bcfb576783a125b6658110bbd2ca5c0fe072399d7e0f39365b9319f3adbf9bb798277ecb259751c623c0a20351daceb5eb219e3f4edf966cb5724c1d43dc1be0ee349b9bd9ae5a1d1f43937c673a10ffd0d3293d46b4cb0be49fda89507a7b045268c5fd199669efc1720f025590c1166e2d8824627838ebcc2b509b779a5872c784f0f53febc5366ade3c594d9c4dac854f49694661d694a1d898c4191e04c2c414b52f76b0f9287d7cabb2556d2cac7174d6a652f40a99e7a250087e9d493d6c55665748888cfddd26bcebdeefc77a3f33344c6226d7f8696567a2d26c5989f888139d4086bd6569f0acffd57e81826b83e2c31428927ced019e639417b82f272f1ef5d8717cd79d246db9a68bd63ce8a3b0295c1d7df6fd7d1d239c6f54105b95afa9c4fb96f022496bdccb3dfa2ba8662adf2270ec1990f30933775f671168792557d135ed865feba5f1d6da700be96e470c9c044332baec436c604493e4688a5dec1c32df4936e237d5db719b5b9e8e30a343a5e95efafe3bede3e60d9ec972f712e49c0bb311d38a66fac2c05111b7346637bfa953d475c396d25e429d2df74be0fbb5fa07bfe31af7612a8deb41e40ed8780ca859d4c28719f0e2c59b775c040018a363b5c26d462ac187eb9b0031fb57b42994f4d10aa6bbb68480e2fce169ad920a35bf27b97e06edd9e2cae806f9b568d1f50284dee50959660369890b92d5198e00fb7d23e72a2d4a0c0f42ffb6dd30363725d7c5a50b4e8c76df9e641ff91770a6328b99ec23011b9df996be582823672d18cd98e2cf50a4cec6c543865f56e515ddf9858d5d27aab742131069b81256c9e49c050c4aa16cead10f17f2c95d38ab0ad12b7ed126c86e46490c8cffcca45247263f9b31cdeff6ab922c7feb9c7969a1650831a778e1837f5815f5e4d781f12161059af7b0316521f4a2af840bb36ef5dd996b57c554a8973ee39cd53df5a60d6c91d94316547d306feab53f3249a017c6ca5db4f6570259f062e1e8945f9b22825ef2d6e5433317671dc9b070e601952a7193f9f38dcc3a2627d0bb28dbc8442","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
