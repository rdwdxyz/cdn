<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"74a942ea79e46b93db03235e14ec8a752c8168ffd1571a52280dbe9dbbe4cbe8957991da0f54ed373d9770b9bedf071fc3237f3300db17f134a7b54f088424b0ea07fa5d31fe2a3582e43da8ecf05ec77d7f2852bdd99f7d78f423caabbddd7371822a5e782b72e2c9baf42788911b2cf7604bd72df90e5defe2241869e08ae3a45465004acada8d4ac3221a26110aae9818bfed26109912195ec330ecc5da59743a9db67a3b1b738fb3817523a053929be9d2f788419533668daae86dc76ee9b009e29a68b9d5c19b5f9bbb2ad79de8c9b040e29f639a40e31c77c4a714f94da981cc52c0c3de22ca1fb2e12a85fdc31eabebab476c7400d57a7c720cd18eec7fe663f80240066dd46ae8ed79e296c1363b4c5ac81085214e1dc6436bb8e1edc80d7bb848a788d032345c05f09b2c7ac82f3695f63ceecc406e664605edcb8ceff68760a5bff7d7586091156561ff3afac646ffae093be40acbf4e8d7abcde8e8358466dd54c0bec59217156385070172cc0b5071b607af2ff52e306a37d2da774063f08b2e578f46634af698934b966a313dc4485e9e5e4d698beb867a2c0e6cf13d41225559ff2ac8311d6d658b2e0770c307aef777f52e2aa38156692cd0bb409f3d3d905bc6b7b29bb4490ea887ea7968f16872a79f2f4fb7c8acd19e8410ca733c34f27f9ca0aaf82041a1f9cacbd71aebaa8df0abfd99636efe69a2db1f06d6afe44ebfd7e4d279ac9b5fd4664d2fc72c60ca5f2186e4038542301f4ff8b4d9f30ecc100e37f542eea36b2a0fd9063717712f235d61744600079454f81c9ea8516d0d48fd73f72c82a09482f7711e2f2ffef7cfb048f819c615941d50c370285cf55583c199e415691f6f171052e36ac0c7b9d24ace34c0bbd6414865905fea7488e70ffc286dcc33f9d09b1bb31e9fb1ddd9228ebdeb4c660ea63d4ed56f920348b561005ce10ec55c6aa27e3122a04a3ad3a6ccbc13d2efea15bceec22630415941afe4bd17fd7c652ed0d979b5d47abca183dca7dc5bb9fb2bad27204db4df8824195d4044ca7e7272badca73894ae4a6b525d061bf8da0b5c9b7dc3b8a0bd0064e512d72efccbfd1893ebfe4db58df47e497b59f6e79fa87170775752ce610e9b529a04d786d412cb64f62d8bea607916c0e354114dfd512c293d40b88183ec76a78a499dcfd59ed40d3f21032117d55e345a9de4ae0edbb8b6facc099455e385a8087e5c969183c5a410e33b52840a3d4a85b53e312a9141ce7b69d59032bf81669fe70dc1de34990b3a06e877189cf3ca4e13ea9986bcc608ff5ad728495d296979cea96cded1411c8dfb5c44f4021060cff12f1beaa842cf6500efe10b5cd51b735cf687ecf594b17e1de23c85aeca93ded8dbc76c6198ee875831694a74c2543543993e4e69a17d768314cce73afa4ee2f9a51b293c8edcd289f25e99d5a9384f6498a9e11bca43ebb077687b556d95dd1b1f1a977d631d3db6e216e9b4570a780daf94c6fca514c9971c302d79cb5ff813c2fd380da7932089d3400d28cc17ac703c668074869fe24bc8b4c2cbec898a99bc6f11faaeda3bf45abdc703e2e22b0e2af2d1924838303ab0e88e5bf792f36092e1b2c5c8aa68b098c58eab43a62641edc59edb5c4c8eb57596c34afe992060be612647c720d4d4f4c0c22be57755ffd70e398cfbf9b2080ffae2de26b8d6c92b8b3e956b4fb0a0865a18cf1d7e7a2650c141a7cd08a17a9798a9121b7885b806b69257798b4a2a4506427c1f3eb59bd501604f93c95d24035a439906fa4b0f02aaa869b5e37c0a879ea384bdd9a9720c40f587168361f7d5b635f647d12909ed9cb933e36302cd09475715f0b42069d299a93a6de80b7e6c48928b929c52b9b99be630f3840a163b01c37ef501de423e9d1e31a0050a78c8a55c82c5e4fec30dc30da4a8094db84a521f5ccd172ee3ab2fa2f1c23400d16df291aa8bfa6ffbeb47e4d157b67bf5f1f1c31aa54597a503c6bec1dfb8fe8cb36f10d5d0943e5b5ca58e11827e9dac5b5eaeb21f5f6c8fe58260f2e327eb1cfd5b5057d36b58823869eb1710fac9cca362ae46c1d8413ae5ec82899cc485c75fccb7e614783b1c77bff0d8ccb547fb51f94f08277deac8c6bbdad5361a563e21fafc95701b47f3fe969d602869a916f77348ced59068f7ae9cd00567c39f4a1ea5e3fdcb74cac88a0a0989e52164dafd8b32c13e69e91510bc9e724e5a0936347f2e42cf9065fd2278ca8f1ded9420f01381ba0c17415304899eb3ba6c14a4443e6761e430a6b7d98ffdaff5fae7f18f339a5498b791a2fe8b0aa8fdf876e8bee5e1d5dd8b88e06aff8c23d75b4849ffd0ea809a8e37c9360b6e492e93d60d28ed56ebe3e67d8733bea58e114edfbbca3e4eecb170898c5b36d8e0dc28de6f39db287d1d9a857d5e09afb443c57592b3838c39ccacb1eb254befc624f6be41cbd866b5d83b6aae82853b0a0275f800e84c4ca067d357881f80f06babcac523effe338e90e9bd38a726aef415cfa4867693af04e64280238cc45326df922606b0b3547924045d08d7a917ca3293cd5451b67a0734f5e11f7165a86a0615bdac947c98808ce8ef9bd71084f5540dfb7168ff499299cd4d8c6d6135ae6a54cbfda25b17136a864425e7e83fe29e0e45570a15caf761928c86842633929688a7fd32a3c12afc43c0888746068afdd21671ef4cf060c974ecde5b59dcc0e352cb52d29db79b13e21d9e6a54a5a6c2a0850fe42ec75665fbdd332c5cf43f3fd62b867922c248d98040aa994060a2d527952f0772594886eb4bbba0408d8899e4c096cececef552f9d3071e0e3e1c8b20861fc08bb905a481dc6b75f70d701b8b17436bec20cf7d1739dd069e0d862120603b592017be5275e1741d5e11704ae4ed07b57ef93549a801c97eabbe6d1cd976a9f39169de4a9f9a3023965ad56467d13bde684db2f8a0ae2c806cf89a6bcfa71d24483345e085b093131164e525b422e50e5549818e334353a0c860ed197f15104b56b25bfba68a6a5c0e7d7b6f7420e27016c738da664c4bbd65accdde808fc0010ac55c423af715d6b99f48c6ed85d5e15f775c5eeeb161843cded048a1afdf6ef042d49bb75ad58b67fd06623ecf52267b94ecd1a1ea3a8662a487fc9559c636159b3f3399b22cc1df9c55d5355ac26a102674309e3244e1bbc36327c12944d967bd732855db2ca505206ecb31caf08c7c75e55f75348efa5947bf68ebb1f2d9ecb5771fed1f98a7268ca6b2e74ef949393d500c8cba57bc9758cf05f909cf208164bef6d5371940e68579f9089c7070dd10551e88ab7e9de898fb8788169a8241f521ef8ab2a1dc8b2573696ca028943e9b00638e7aaa3b3cb2910e0dd2574a26567e3251e5b119a142cb2944834809a226c26855bc99cbb937e9ea8a1761cb2938b6c87350fa57bb26d8c7ddb842a1780dd28745c3100792a438649a2124d7782ea54af13df33ea9b89a7c6fc0387c68fd433e1c5c8c37bec60fd1c913a77f3ef42edfa4d2f709fd42b528d99f688531643037fc849bb5ccc054319c45e8d5f8bab768515103626422eb87a7912f54476794d970d4d77ad7743c3dfba5806d084b8e329a84e7306fc142dd449c487a1c822587784d1398998f1a239f8ed6bf166935696df9188ea9e332aee702ce0caa0029e08c4ab34e503ba361d0c78034c5c9524c45936572d51ffee2081e350b6066e42e106212efa3796c13814c2e61ce6daf06163f12d51919a5bfdfed686b397ac1994a4a002b2429b04ffc38ea2dc62e7224d0659be7e4f8895d465e9522c3cd56cd32c4f5b625aad19cc10c976813a04febe9da99fb8cf62c467a8c5708f350e482499a22ee0e04467c91910449093995deda6383bc5ccc1a24ff1d3cc2b9473d800992b10b0da6ebdb7ac4f14ae4f925ebc3b4096f3f8a0483e0296a9fe77ea8801ff94a58d429517b187293092e84cc30f7fc82ab4b1c5e004a42abafd716cb58683793f19854002613f96d690c8a51e9c5ce87bd1a15b4d74dfee021697fcedb1fe27afad5fd5086f5491b46666e761a6f92fd27b9233784495ad0565e059c028d94b956c43065be1296269ba333e0459d4add76b404c0054247a881dc60ae39bebc38ffc3e08f2b11ec03d0110661b004444c9ffb4cec664f90882ecfd05f176054fefcc7927c2936863d86fe3d7300af6936c524d88e5c0f78ef90ec905a362f9a6a58d93526c5efb0490f785de49199e15910c1d649dedcd4c19cce567dc779ea263b8fe769c32a0918399979996c6a2c84b9907c1fd885d533ed6cf8f3d52201505d5f1b58a5e83ec1d76ba753894b1dd588c54c82c0deb15619b845e926d028685a7d0da022443e5fd4761e1e9f9549982160fff7cf0aa800fafd5f930b99397a85680521d80b48d8ae5b64edf9fb1edf08e77ebcd804937ea3c5ece85e8aaeeb183491f8228bac7613f11c17ef80c88fd92055d473cbd184133a8303bfb1c68d52e81baaca2e9753bbeceb7eab572fa5f569c290c470179961d4937006e02b671d04446f7d6cadd7dc3136c671edea65152fb21bee7c6244963800d8c77032fc87da0f2049b4696376825bb0a13915c11764234868f3b680095f9c2ec68b1c4eb46335b2fdbd4350908b48da24bdf942b839d618f94a57f303835a7848ad53e7f3d61fc2557763b69c1eb2117565e12aceefe6b57576e75aad93dd737ea1ea46812a64f3889445e77ff3320f1286dfda987b887cd07b8caa650f05f2b22be35a5fc22b3ffac191ff0f70680fb8c35fc459c396444c03d005115de4124aa9cc8b9d28e74b5bcbcef2ffde3d4c616d8b5a1b2bd530c0fc591f4134f4316417df6e81104deb86f28e17affaa8963d2018cab08f375a226b431d06ee5a71ff0787698cc9f05893813b7d9a1412e5a16fa72886dcdda775712216eea6fe530666b189b2324395dd85916f3230b8f7def85ad8008e70c70ce33fbe040cae195bbd6879cd54ae3cd039455d097d5c75144947147342d168c98acb0c02d5a566821c1bca2531021ad63af28a853738e4acc49842309901d6dd3c04af509f742aab83e33238c9be151cdf2621b809c234015d683c216a1371f9f08289d00b8a32958024f3ea386acfe278dcd4786ab4339c7ddada323c1568dd9a3def1f02042a9a1ef20bde7b773488e225a955844e80936a47fc952a46965ba9e69b03f7cc61068a88d0df39822f19fc21e6dd5d233f66a5891faff0b9ea9ec839bc7b33e1ff35a3f4d9c6cd11a1ddba6c45cbbdfea6501dea473c24b9345a17348cdb2f449512e9920a8e1a528715a63a0b5d1db2419427c7d70a6fa261f71292cfcf3edf1b0077a8c31b0dafba3f5b88d283fdca936886313e52c2d17533905b4c63f13bff0fd0cd0fbc6735c77fe49889f5cf3210ecb806929910a1d8276b36854d628b2a0f106bc82691f485339778e37a6788fee3e33ed6db5f25d09867d8c28b8685191d1d218b6c11b200996b1e8eed460163465942c660296d199ebfa1ee1db1d206cb1b2ff94b730606cb86eea744f44f73e1aa5ceabf80f5c9ca82ce922da4069c6b661b90bdb379e69bef0b0930e952ea6f48637df2ffd978fb3840c11439ccbdb3852e7e6844fe1e10c11c634ef212bd839aff7e2fa729d3cb05c5f0b245a91112f3d56fd25a226a368d1fbd9e4c54253dfed37f9f5349dad04f5af6c6c30065768b6da5dc330b186c35f8c093c3897755ff50c81b823e3dff6a8662a3dca284e710a330075f906f7e0bbd731eef12857c55067e2b5c6e90358bffacafc0dd5c96a05142581c94d89811c25e38a36819529b9f49d7baae96c2fe1390d23a98d94f3aef7423095bef8fccb54b4c273f52f4ec899d9ace9e428a4a42f86336bf564c7c50b99fdbfbb89a2403f6ef5ec8cdad402f9c0241480c4d9979e2d0d617bf34d4ba27ebac90f816f9ae4519787918e8a9ebafd2f5605bd5cca44396b575fc126655cfbdc30f21ea0efac8f3c2a3d4a3dc568093196b0fffe5ecf0670e3b7af4261b83788f503f55f94ed29b2695f542766823a93ac04443ad0277e6b97e42457eadad5148de167cfe20b568d8b0d07e0a8cf4c4953a0372b5521f5291ef2af7c9d6168e7aae7db4ef492107dc43185488338ec48e02b8020a3188e4c8fa54f2247f6e78417910fddfc5ce715cffa12b5a2ec0a916328ac05b70e416374a376ff50dfd1559f7fc5e29fcc407831492e9e752081ebdaacb0618244f80c8a6a5cf1743ea5bb30523a3845b3f4c9acdfee385f2e8437b0ad74665aaacc894d176e06a8a984a2a1ddce507737bc4398e311856056e6c7697d05ef489eac2cbd3d48c20d252dc4734da78431502a82839966516d8837d7cf4f2cc2fc935a63cb89431e061a6ee811b336c59598b5efb8d5b172e7da37b9d45b18b39b53982ff4349cae63a1c28d7c57f07748c17036bee9615223f2a86f34d663289716ad976f9f63947d85c1de3d0193be703e387bccb2c8cb506292b030ee335548a91abd7b443af6d3d03720c21e3a988bf015e38426e058944cdeb14c518a31701e718d0716a335d9c906d97ad6a52262b9bbc35c086ed2e1824fb4d4563ed7720f9094bbe02bec24eb3b62f1d6db2a42f2f7d91cf892ba71f7c2113503974161a11f0f2186f7b9404c092bdab1ab0a31c24acd0a5389bb74d82c970396aef0828277e146807323fed33d37f456a7cf1a2fd431eaf1a2faa4e86f337865a9ecb7480037030b5bf4f9cfb4a5e05447bd64f1aff865ed60114d33f676074070e48404d6dbdd4c54141056632801372f00ec2f3177962b9fd51fec1d0cba2317636eac1c8570c3f02b3c50be514ee707123058704d8c7f74dbf80e964ba7d1a2f3749be611de11ddda141d2a3f3517e424f9520353e703f6987826e4deb744fa485dd26baebb1997df337c21abfb7d2ac3d6d7b8f168c300a3faefe4054b71d68ca14939b83ffd08907d873b9007c05ba2a9b0d06fcafb5f74d2239f5af3f92da280f49cb6753aeba660d1968f8f168fd31a502f466ac6bf023342b5fe7c1b763b402779d5bc6fc75a3143f3d9109c8a0d8c9d8d43a37b5f764438e421f8f77e302ca9a8a5dd054c82ecdce3a23a6fef7163987d0a49bc61df6bd2a316ba9602808ed9e9bcf5a16707a8eaf32d7359f75747cdc189d4decc40cbde0225f625b9b7baf07e7d0c4df74ecb30f31935c03052a2393f4ca37a6bf8bc8886e560345bb20a35a20cc6d3b2590102dce9f3273cdec8a7009b08f03f09b4ea4c3b27e13a8d3a8a5df346510eb3c1fc8da0e03d4019b41c7dcaaa0048be70d8a6d7383f6af6e2115972dbd48004cd9a00c3ee9514a943107836e9b9ae3fbe30edd14d9dd45ccc2c63e872f252d557e5a753cc9fd629c7164b3f52ad1300a3fba9e1b870be5d6f507ecd2afd4c2a43525c88aaceec97d36d75349a4ad0a739820e7d2b4578702a36e11194ef64337f0e0f6f15b636365be985428286594671a84d9670bf850208d31fe7e827ce036e636e655643897bd328b60cc31b2dc99d34b48d7b57dd46dfc340dde62f6d910e47a7da787684700c5999864752e900cc12b2964bf7b4407567f0421454dbef48dcfa630e97f68fb3e6731fda6cd9a543bab8b50ef4db294ef346a3182cccb8f6b87938ab192e7c153e71db303c8cae94f29551a3969c27ee0a453b3303f061db0bd2b58efd1dbccef0fef0820e9ae350d41d922c3548fe021384718684bf28abd951fad6dd6ae05b247d915d844c5901bbc333a3225c8815fc8e4b5174433c7c5589774a941ab998e3a70ac73de7182ad31214070e78da28532b9f9434a746fd3de961a82c827c78d914aa18b256828ceaafb38c368342fc0d0439f87ca3e1ab7c1d3a7e7c24964fb5599c8b999450bff47f0516d70a065f9927cd6950808a6f39104ed296028c108bef845bdf96a08985076cdca30c286cae89345494810092647cbf4f7a54b29be22745679743900eaea7ddf2d7b81395d8a510f9bd3b6a7864679ad40b28e8484e4bab38e95812fdbfa9133dc5d87f4ef99293e103ab54f7d1078d246d1355242f33596c46f8025382540334ce68bdad9c0a57c6a7292abc871ea0af03d4d427ae46f5facf1f2364c1939c380348f18718449f203f151798c900e0b49c9cdb046e5abe3fa434bf7cbebbfbf87582c350b1dd3e0fcb889b83ca43c776115a30d6f9b99b817b1555b03be647503b6f66551a262b007bfb890e90e1ed9ec56a34704e22db4fc1874f35b0f001cac5a022f97401c35f8ff1ddbd44598b3b8a3ec879066f69a1148c31fceabeca3bf3cc4a151368ba6e32a42bff8d51f00b1252f339a3a0d5a5b4b4702af4059128c65c1d6eca16743ade0055cbf63fa71211a65c6c11f850714092e5c74f2655fefca843313a2dba058ddaf0b98ebafe0042021a0dd538a07b88e4db9720e17abe64ab5fd8f48f9e837b6f04c0785acf44ef2d59b75e363bc20b736b71b4c8260454a6523b602ba3e2078df133a528d6ddf7e8e2c287d308adb9c05b4911b99c071f9a22bdb27436d923399cdba1549d448fd199dee2e248b2ac2c46825606d10f0a8572ba95c24fa8615812554845c7deecc679c3ee9cb0e5db5c2857a719401d4eb01ba5daad178f049c6baa815b10a595870a415a14ce1e82dd9bb410e3b203d5cff94043026d10a1525e709a2741fbf5563e5d54b147d1a00b82c7259bd1a4996aff73c0224219662e7bfb0d0bdc6dcd04ad34cf8c8e027a30deff6626b75b72609c047a3665136acd6cd73774a9a8ab799384e3b816b78a3bbaa246b34bcb96d383bad4c26766571cf50962579a22a794d83f3e69b9b1f11e1492936c90206d9208cf3f764f5583aafff1abaeb32d0a49731253fa0b3e860f59ff684a6eab0b0ae7489c287327fd131e5ed8b73d48cb7c91175df9101e65433b97e192f4da43c495eb82463a86d47c7f678741bf1ddc217595e7bdc81da89ca7e48d01d639eb7d409edbbfe92cf5e78cd531dee2c35cd82eb47bca67778d0fa2a7049cbc5bb0b4fc14b8bcdebc44de7d123d5bb7744da57734defc572978d215c8210f2e3f7bd08f2a9bc2925f4754b739d6ebf9f2a6e9403ef0d49612ed890c87f1475b896ff110dab9141dff680d43b8f6eab536265b344860ab172aa63229db2d4e4b6f0c55ec551d810bf5ecb7e85557f03d348c8be16fcd35f392a29b5444ac360244f26aeec1cb73a43525305cae593f647b9ed373077c4cc0d608c2701e45eadc5b024941027686cd1903e114c340895294d39fd2a4afefc35efb3863d7cc96aafb651ce778deda1c75f02c3190dbd5063b0d5d92dff1ff222469d3e3214b959e3f7d5f8f9aeedffba1186b0806aa71e5692d8e547f149ad7c98626863764dd1fa4c083c1d09251c493c54377de3fa95c77461aeec3cc08a9ae27c3171bcfccad4042bb21804717fd0662ea55dcd5a9d2e85a293773db682bc7d8f8bbfb1ebeefefdda116e05cc872df6fc9628b5cc82780bb233e7dc5d6931b49244932faac7d88533cb4f41deb9f6af8db6ed6b56a921fc20cb57a4bae9cb8a099693e0038884bc78a69c34f507162b2234bc9bb29f69160b47576709178c089e92b3dcf0a7a1c15fd77758fc458b24cb1e679dbd6d46657bb2511446f48f64d857427acb79b67ef7904df3e957defe1fd8e47f0904bb89b58bf4dbb54d4b415eea5cb03466a8dccc83549dfc7cb6b6e48723c86ac7894456f92c3776237d65e7cefaca399cd16fb1183f7a9c432bc0f9e13c0690ff2d3da9c7784ff90356660f525ce2b4c8c2a2f52a4d4ba4c2476725b5149c8831bd403cacb671eaaedc9fe1c065a77a338184ebb2bc235a3e0b221fefa8ec9680b18579188a8f10004d5c1c1f08a89e52169041f7e05bd020511e8dccdbce00aa922cf3a423dd70f97b9c03f3ec3f8342a7cc7980aa22cc084baa7cd67900b0879a277ae2aef6943021b0f2770c6e5b83537c092481bca1df5ec61bcddf5ccc4de8a7ade6892b181a1699479ea26902a4358b2e1fcecdb7f591da1c776b54beda37a34107695d6100ab2e47db30042937f09101f277ef7b54812deeacc445f8a5c52bdb120c7fc6cccce4857d8b37b3a369b8a3facaa1947aa7c87f43dc0a4324b0de9f3c32f5cd5338a93fbc23876c07dfc0970b29eac680eed0eca6f3f5b0bcd578f86d63b079b9303d51a0b409f47ffa091cf46383f9d6e57260cfe92cac9d6ec6ddc390383d9818cc71c05bca6fea408724f203c88a9ab8b79529b1894fd1732d1a469337912d10dcac75dfae869ebf69e75de07b9d96033f2bfac1a9ed841d41b5a7d95ac7f3d8e8081e083a4514b9eb6c9e1fb8fefad663acee0b17af8e094d8bd9fc32f49675a47af266f3dc16a5ecdc64e8360a144abb4115dbc480967f22b409bd3a160536f564d5b6693c8627bbdca096de0bd8cdf33e79a80a75151e84b3c901b624c5d418f3d86f495bdf9bc87a95497a931af301c10ef493fec178dff56a871d996d2cce27b0d991d8667fcad2365b181e8e376287923462d9f7b4db5b4e0f3d763321a007f32a5494d12ab54abb85bdfee3b1386c97712021d28163b3c74f7852d7c878c3cf8fbafe12bef2ab7ebbbff9bd9f34ec3c2835e354ca5fe9c1b07f21144665f93420dfb70ca1e970440f1f59ede4bc2e446275c3c0494a19959c5e89fd54556d59322437e99908e07b7a97f34d1e09e5a81f572ec677855d3cbf95a4ca76fc78498df2809a54e6bb485b1a057a5d1439d7a3701fb41b57c71964f81c483935e0c070ee83c2e460037bd453328d3a50925aa310d85d31450b97c16ff32f2ef3b17b0ff5b1f6aeff6e1bab9d1f4d7c86152c1cb5a68265b35fd73f81aeef399f32b86f1ccfb9eeb1a36354eeea86c739c9dad20eea8e0e035f4862a7e5d9985ab0381e6047031a83b20a423873c92f6f633c8c0bdabbbef6b5de1f2c1a712713a541d3073222ff8a53af9a5811a7cf5480d7cb7760dbb06b89c013bff19be0da9b3b5147a4e10184e8713e643aaa6b4510021bb223bfa88d3035fc37a9f685657a7c3e1119e445f1f0934853255200dae9d0a2a57fbd2a7effe525863c967d2bbbe5d3c4aa14a5a1679c0dcc285c3b7f1b616783febcd0e31d20aa9fe42d463f8d58cacefca27358e1e18a97246641904fe2d75c3b596f45c09b40065f91f3ed559b5d1a85f8ed8521d83ce17e001c4f09fd2cc4c76f43bd22742c05ff982b80c50df86f94631a5c4ed038f3343e631ff7302fed5c343c4841d4aee93d0bf51100b70d07b1ccb9e9750a4194512d88d7ff3cc3f0452e83df4e3c6dd1b3ad86829a523cd8e0af1f36a004433cbd35facb20c3e95647cc4fd67c7c246eb8d0ec76127d64038a94fc103d09afb5f375d075d0ce2153bb8c1d7d473de29a36e2062b46506d178ef2b23b498130a4339dffe84dcd00e35937c136ec5474579401bc5a57eac60c5e3861a492d5bd5f5706b4bd9ef819075900cf59eedf064b71097f7ea814dfe13741939f500867c1820a524cbe8855a5c6a541f2cdc56a18a5214010c1794564ca8806b9a8750cd18e05558ba86efaedbbe7b6c4d5297bbd99667ac2da5ad3b3a8c145aaa7192a6224240a244fbaf249b62d6f067bb2b327a3edc4a4d7c71ca7cffc0e7c038fe67b2bd2f152caa7428129e8c7605ae4976a864556e73c768103193e4886f9e3ff191ca0d35d00fac6b57bfedeeded594c220443f53a3397a55d54d38b40b1e8a20efad5a125486145023c56ebea60905a563120c3c4aba8323499de0cad3fc27e7735d521b2443faa12beeb6a444d34babfbbe1102457bb7e3fba484fbf59feb94458b7a1257d28ac404a0ef540a29360bbd537badbfbf37f3281df1858cb398848ad805a606667aa55080b3f590f1464860b16a6fddd077d7f68c6c7a811ae22c81f2eeab301d2600d5c381fba677082a4bea227f2d6c057e4a1da35c9309086d92423b23f66020648a879ff245b01e68241e67db4c7ae070a1517f29dc917681352d6db55ce4ee193977e08faaba55d795dfd42c01724dc542ccf616b0e07de96ce9062548f6948f59ea5359dd1b12cb7dce2d08cb246dee9887470dabc35957f5d4593a95439f6ff73262518321f1c5ed26d89acf1eec65511ac70ca1d535f9916d1dcd5cf513d9fc6a631cfcc9a51da1eeb52c06a9525af096818961a0858744024de4d9d7cb7b0430b455681af63faf6069601130dd173401929bda6801e9490accadf60477fe3b7fb86f1f7849eb30b0df02b1c271c81a709060146432f4a1e496c2688c26e5229f6e75baa8122f138adb6e7562102e450feec7feeacd6754ddce39ef4754cadfbaa0bcf216de575aa18123bf13794c5a7be5af4b5cf9ee62aa9d7b50dbee7f6a44776f4e53ea1314158a18f17c4ba1883268ec40fee7a99a649a372d0fb8f559482214b4e5bd6b3ffc7dd4d985a8e6afa6623e47750f28a6a8dd17e3c3a4274460f8d014afd4eb0a4271eab96c6178b0294bd8855b94e0f90e5265808de83f775f9cee60a5fdaf6ba785b59cda51a3d005122cb1d072d377de1e1c0a93aa526d5266c7d4c747a54f20e29be8b312f52ab103e46630ba67fdd10bb12c6d642aadbe13cc1c242bf7a2cc8334c2f038f4a965142f50e665517834b74a8f7bf57a5438b0d8bf170d6a2a728ae4e3bb982c42c26dd824d952a970aa6633cfbc91bc086aae42189dd271ed0fbbad82349f589cf9932cfd1ec6d1089476c7d9277ba6d6761353d2aaa09cc9c5d356a622bd1232c89a96ec4746b03bdbfdf080bd42211216865ef60c1cfccdda170b6cf95a33141654b2e11cc6c153049e12315ee455269e6848d06e96bbf3b926846c2956c7a8adabb52990f797b9d97eaca81c98f7cfbaeb108bc1350ada7de0df3743fd8d1b9eb925d9e7ab932d7769971c2a3edf5a346af2c200a737bf83a12c5b444813af770445cd3fba03846ea80acd3bb5feabf0d15430659826b7c561f38ee8fd28e5848accbaa9553b6399dd949a2e2dd2d1e26925c0866e76042f07fe1d5fa60cb7a076ffed029ebc38a0ee57f0191f26a0d93dc2c3b4a6884cefd4227d83ea5c2ec37a65a559b45e4d3e0e336689d66cc63b9030c9ecedb2bdd61dac39fb436bf38efd92a3062a8ab7ae18ded7e1335036910f0f45631fba49acc5ab5f2423d8016ce573bf6ba5bd068bc0d24af9d02c16547fba3fe809c2bd17853c1c3dc856ff05bbe3209691eab2f94bedfca84e542457d44e2c0a85219a64bfade9e246607afcadedb9e16e4f51cbfc19c31f36341c47b32b6bed4bd52625f4ac4e2fd89c34df695ecc8bbfdbe775d03d089551214d17b633832725254361c61fef05a9841c5f6c680b95cebc1bcc4d1792ca97e7d13b2653a8602ffcc32c440037478b5faf309f36e46d9c12b13335c166e4f2fb700f736cb7a879bd16fc4e54081d21cc0f21bec6d06f53f357944fbc0521a87597418a65f44762925cf3e565ef06bccb012894dabcf6593d1b1d0682ba3ee88defe0a0ab29cbb2dbba6c5d6c846ae8d8ac2c93587b554fce24cee524401f1593cedd07ac55ef7b1af3af03ccec8e0643bbaf70fa39290ac70d0f5c6d2ef8cc0bda65f4d582f81d40ef23c1c1d2d44afb31c53a5a992bd6a1a76cff2d3a2fd109edf62e5f10e372525e013390fc453b840f5bd7d31b7df94fcb79dc3c5ad6422255fcf904f6767115537f57c97529fc1b277105fe56792b529b953ccbbb5e70127ef9851017064359a70727c8a32e70b1ad367ba5fa60046278fc8a6362879b26da31a066be22fc3f918fa7dcc58d90bdcc81c5d2d1d58e1928f9a5f014fca821a4498ccb91e7aca9808655eb3500490a68fa8bd41b336e6e8f1f148324b9c7f2fdfa6ce566aed102935ea4862573342093e8ef730a717194aba0910eebc8bd5971b4cef48c554aa59cbd000fb2ee809e1d33060bdd757f2c49a15e781df59805bad6aef6e71d7485993026ce83ecae60d6924099127c9e847bd69a0e9e4ef67d70d6fe12eec62e31eee64afa5602430f1d00259de92d48ec0382824f89a7c111984cfe21ca72615debc37431fceb9600450a83c9416ff265e79e628afe4995bbb0efc5e562dbdc0f8ca782d4f7b30bbc6d069a995ec92367360583b727942f464b956b8be476506fc0d72b5b5956ced480dca4ad168288268455bd9919f054f5394a3c1d869857be4af3dbcd6669438c364a152e97fd0469857f8cb86163cb7d0a01b665d363897fb8ce34c4d980252c2b2dd6c0adfe6a21106efdff2e6e3e4e1f85a3e4ae5da3bdc06839cfa1ee2d35184f6d2111b5fe64ca10afa883db48c5a056f562388ba4244ede13f283dc06d43515dd7bbee6489361e3ca4d0c5083e4671e11366b023224872deb74ad491e3d5f6995d1e3dc64bdf45bb705aaf270fefbd1ad933aab1bd598b353462410377a60fd7118daa466fe516ab4b7fb32aa60002f2389de880eaa2740b2b85535ca7014998d350717a17b366421758980bfdc8d34cebac57f2cad630399a730c91efecdddd8000c19fc91cb267c902d154330a8f6d69aaf5c38651620ace3cb3a43c91c71bb90f704e06c6046856eb8f816467ad9d4233655b82f534e87b23d0678a0d032a95dc24923978eb11df9708a6a4032bc244325ac8aae6808f603e86e064006ad1a65f176e62083f9c8693d9c97499bc9d1b894d1c47e60ffb39d9ae14423ab4a26433e2154d4525f3f09bc2f3beabbf1e6d91e438ae736c8d0276a13e3aa724bd0e755ec682717ff17f1a61ab62b8f3beaa000eb5400ca9eff2c86a72b7be8cea957d6ce83eafc60edf8728647ab8f714feca02ae2aa23888d02a7a6904485429cea8afca6d9f0bf4f143be8dce66c4a403e8688eac356c707ad2ae298b0f09781ec37dac8de08024d2190cce1e4fdcfa51e91d4a886adeff857ef8a53ae4c4d96146ac1ca22a027c96983505811d41ae79b3f67db734d4ce22600e56ff98e66b628e83ae1bbb2f672e22f48ddd67e6cc2e8690da5387ef708b6a32c1648fd6100ded3e572b8916a54853323d091610292288941e07930cfdd0ac85270c44f6bc5a776e03fd1833181e294bd8c01da1414dc2a278465f68d352a5d0c5a2935fc19320a9c8335e1b9488bd8c4b94214414a767269aad6fccfb8fb930513284b6c2656b164a5612ccaa45763057fd04d091c1b1e668a48d034ee8de1f05f16c56f16ac955b182136d192e396db50b95fd5936eff7b872a7f85021a02a63652a240cd8f2d1c7d0e1c2fdcea6b27cb4e1e9c322c56a15d0cd8dea68127c8ae34de2ec804fd2192bcccd2dfc629c760d069b23ba2e71da18f7f9f5e0df7cddcdce81c9ef918f13829cc4995d858634963714472b0e05296a2f78278e353956cd9b679c29e675cb7ca8029ab5a7cad8aad9e6716d21918474cd75ff7b865c06355256273a1d15507bfb552bd7a2b888f89042f8faecdc6bee506874ecd9aa9ea0d93e42b49900c2d0c2d1affd69294e94c843115d51f0f3bdd1d99ab9252342001d52afed98d26fcac2e699960e7dedae00a9b8577bcb05c33c9c53793d1289854445e3c2040766384eab2dd6f8025c1506aa54b17170ca6a54cc916d4a44811abe8af866f1419577f567ffcb091f3c06adb8a31ec14e00d8e02952888e9811ce12adb4c9debd9d39b26a9b9a99f5211596004d63182f27f92d312a32030b3e7b5677c5f4b651c02f1647a9af905857fa82905c9a91ef1d36fb72d89f262758a0deee61f318d7968b627a2451326b0ac249b8984d46eab608da982bae9478c53ea7a918344ee41dae30065064d0276d431369e10271ac729314a19ef6d8e14483608fcdb191ad26afad02098bda733073e0a9e4cb67a8954f25a5c8aa753f01c94fea269daa8ae51da72dcb3227815e03daca9308ff305db6bf003271cf83051ff5b47b6f4c88a25bff0dfb64b45c97a64a772979ea1be0f6f067c381096c35e677178af2b20181c4bdd74268533564f2873c548be15454809104e4b9731825b0ad59ebb9df9c71d927b65aa262df20318a01bcca8e15a3a49be5bec2ea69dd4fcaa9a4e2006be7b10d1a0d0dc81ee426d7765eb62ab2f13e0825487d585942791b328f3502efc75dd4a1568d8c8ae01d592e90102a3de732942ba7aefabceb119c64fc5bb8ca4a2bbd5b621fdc51c6396dc64f14f0adebc3c6d0b9624b2122beed273ca42b41274f7d43ee1ac42456282b22dcc8155e43925e1bfce30fc7e906e3591f1f8ab97187bb874d06def8df85fd999cb165772b3d10c680b3f9dda6a6468b8630aff38704caadff87915bf8cc8142ccb69b380900b5197a5697fbf86bd4c9f623ecdd0adbea7730ea492205bdf1535e2f16be83c9b98484d4b2e48913e3c22cde3d45d7ad473816df473c82296da3d3f221907f62d14414955ea26a6a4f6927d9c0803de09c3a0a348e4ae8091d6c57baf1490a28fd2048388866db2501325d8723b429d6454d225f30deeb5018028abc7aad074959f440d47885694892614d02d951508e21896a1f1fa0af35fdb35f0797151f9361bd088a18293592d3dffab896244db3a1e5df7aa888e9e61d72a22c4137dc95352d60d83e238fb16782a6e6d7083ab30a058cb25f0c897a97fac30f31199b4821b408ea3900b8a968d63f97683281d4237527446f254021e87e591452f0db96f4fb455d9cb8f8f8d1163de1854379e7b3b58d71ec0fba0ab149e37e7213f138a8205d641a4281fb191cd548c353c7cdbd23a8db4c172a9f05c8ffff7c803830a8ea78ed28dfe18687b2b3bef24cd0ab0485ca7c074d04eda912ae527ae2f57b5a372aa08be12db4473580406b88100a2f2f2bf76b7a39b2737a878b1692d95ce5b27b0f206da628cde3f40bc6a15ae1ef3199620c1bc479e99b6d5587f12c160c3eca69deb79bd12391d55fed3ce294786fe1d3594b81bccdb190c36515f029d176a157b14442c490c11301e8d22acbd84fc37df6f41f29158a23dd1ac585193d272b4fcf6301f5348c0ea55161ba6c6207245c97029d2212df6e60b9c1673c36693392d4b5fb154781bebb9343df990facf5552ce299f2922856b155b0a8e19a904cccc1357bcc678d3f15c4dab531fc3ee88415cf6896501d315b4cbb02cc6fc53b9ee373d57deb83cb168b8d0d66474924ae3b74085f4d2afbc595dd4715b7b3fd18fcbff81d08f18221c003389a7c64e6f50dcff1522bf9a620e2148f5d6ce1d8a83ccf3653d70be0814fe17dff170cef69ac42b849eec3995d0203c003835cb902c34ea1634029239a0db26b94000c5f91901eae0241288c8d72a6f780ace291e5d70b28e7a1b0a2e1f4526508b1322ef7e94574dc1bb8082e83e70613b455f8b5270d40ff9dc64fbaf726c864fdd45283af659f51b9bba8d7cae01e219d02f4c31a8cbe60bc03f9f99df6db8673f6a062761e595f8fbcb7c5eb4f29bb57b16f1884ea0b345543799a7b19407a193189260f8f0adfb86d3dba07a14097c7de6b6705c11f2bacc24fe3c375ac61de4bd88013cddf4c8b94c96089dd60c62ae23a4390cfffead2c60838895fd5ec4865d276c78f0a0e2c30b2d9cc02bd378efd234abcf09fcc4aea46113a336dfa7cb1079754c8b0ba3d2aae97cdf03d492dead04da20709473cdd7eb7e20b60f740ec0f4f38bdd332934ec02fb9ea75637cb02414a73b76a61214f29b3600dec67b355d6c497d5f7a931fcc3027a613b3310d1b23e89be59750f28d66e8d60f3cf4667a9078a0054fc99d8b7f711f4d33f363b3bd74e949bb839bc1d3769cadb98da384816841b1dc48947f4172135ae35c3a81407e6b45eac59fa8ca88a95ca2ba225262442eec942be2884e159687b3e88fff43136bf8ae5bd9abd19001f0feda9dd98c07e0de9602097cbb8d81ddbd6f777f5754be4fb9a1e427277971ab4c3cce6aa073af69d8285d25711980586a90","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
