<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d703ee047a22a9ad0061002a0f0f1dafd16d73dcd0d23419ced004d5f4355596a38f939868417942c46f833ce92a294b93d02f4a310846f346bebbe5beb0963c0f05922e69c6309d8c3a3d1c8ec77e36347a2341e5f6cee6ff8e401ae810d078acb974aefe1c180e4d1ce0af15744a87fd95e9989f374c79d286c536b438c41557ba581b5a3d568886ffe0c5ed7049669dd27ac466152757adb305cb35fea88404f67b90f0f31437a92c61b71859d7aa2e314979c45bee922564e4adedcbb9811f70dd48065dc4407eaea4e3dcae669125fa00cf4780fed1c7519dbbc99cdcfbd525841f3396bebed60c9fa8b457c25f106a1c40e2d9e5a209e768206f25ca3feae1ba5c39ceef735f5af4140630c295a0bc6427dfd5ca91adce1653632ab2c8e9651d468542f85e432337ccf9d554d0de3b12b7aa62f9df582b251f10c8965888a345c01a1add915c967a915739e6d4bc5dde66646aa6354851a69c4fe8e04a35c2f1528ce53b4d0a29795927873a0a4d25e9e3b32876d5887e3e355eecc34b995db40b1dbdc8cf2ffdb385551b803a2ef4e1063ab93c097bd40b5c79124d4f7b9898c10634465ffa5d9d4120635c8ae4feb4419454cc39131b4feb504151f2d5a54016b9531737cd34e24eefdf95e0a6002b9c23389e1a3bb8b8354bac847cff802e528a3b6f77c371972ca343c39b24ffdde6d4caa0e4c7474e9d308e96876f65acc8a8c98e8c74e22c3a1bca5424046d934bc9cb6e8357f060c5be0fa739556c683f5b2d5970150eeae863595090677fbc85d3257ac02ef86cdad2c04999fd8f2f876949fe084f398993ce8b1da40661253ff80f2221a5b3bfca3ba6dd25562b6d783194b1936dc9b8f5caba4f9cbd3c0652c1993b73f02f337c1f875742d7dc7d6827c739107d0dd3c8d1af829b47935e984819cc16c2a0e2702dabda47d034380f78094d6ea3afae1edd6e96e6070431bc807b3a75e4e1dad62036b86d8bf9cbc24c365e05dce967d46fe76324f788a68516d2e3dd708b91d6697ca6fd81486ae1dab663e8c76b42474e5f73bdc6042e8751dc16b74c2e944764e696056ffe9075b99a4ab62c5e9256ad19f60bf4384579e99d38cd7bb9064c273212e22909c0f58999b4de11f08358935fd6ce67eaaef8b643905b2d2982278f53015e616a121a48e5f20358ef55edb35020069e415e01ccacdac0e2f099213cf466cafcc462161011bddb9221bf38a045144d0dfe845ed98448b31220422828f218f52432bebf23a786dcbe90fb440f0a871280b5fd32e29766b777dc0c75802d134a4e5588afb6dc328ed4b7dd2169c299965a49fda9297d0dcec477fbb2446ae00424046cf6dddbbf2f2269bef1ebab54dbfdc336b95f696a7fbde3801726c253781ed02b92201d598cef44a64c8c56c009f898dbbaa4ad494efed960df44261945ae34f52556970b3aa398e09d43fb95acd86280ceee853233b1f5b105802d636eb2df7362c43390aa1c838e78bde11700efc3c066072519c33fd5c2f98fa5af0fd095df93fe17fe4b3a9030e9489ed8736d48f602a3137d9bf11d7deab5ab4143d9a657dda8ddb408ab1c98049a727987e3591cb4f74b27b53731fad79b1ccd18529ee392bd1eacece74f5226d94261f90c260852af691b3fdf893be9b4e43c168c471e306cb7bf69dd2978e4b90fa0d259dc3985444dc3937e551eae536fff975a8b956ebf5180b0435df4603b9e74795a90d89ec80c22574511542f1102e77d25c88adee00af2018df3715405eb6e0c4b9cd11869af991f38ee8f145315f6419067bd48db5db9f223d79b34f4b7f45d523b8e26e5ec2b8d8b50800739ee96e3fcaa5e9bf38e65f55ddc630e01db90ec43a10e2874de9008f47262dda981c4a8e9853cfe5ab30920e1b4e4d95dcac3fc85f2860a9d8667570c6dc239b51d1bb20e7b2c1c5c3b760e33677b903368bd0d1a230bc0d9beda2fa559033f0a217ea96a441dd72ab63479a61cd2140c31c1afec41277c00b41df2fe90e3e60a91853ffe0436eaea29f7ec9d89a6dfceb5757a184a823fb2b9667811b64425c144e53e3695428d7285f20ad5701fff032bba63499b386abc85d925d16513a11d7eddccffe251ca179b7ea9e33128e07641f65e03f7eb040649418e4b120dfef3733db162eddff5a8950d41f87b287cec37e63decffe07aa2729b338a7db433277f449919e029b50d974d7d29ce12f3807db4d9ad015233a0cce67dc3cd9b9f42cdfb6f27944bab2bdb9e162947e176d412a452940e7f8cf831a4249fbdf6ebffb2c7f713c0c5a95ba29a31cac86a0cb99ce30a9f806f876eb24fcca2a623968fbf63e61b963d3b72cc868aea089051901fbefbfa907de4204d83ea85ac0fee6669c5ed0ddf412ca7797e5daa0ec763aebabaddee090b344e05c5e20c8662bd419fcc7334b64dcffa7dc6f5a355ac1e01b4dbc6266f9bfec660cc6859f9d6bc7c7a08c180146b62f26ef69102063608842df856d5274e1af73c50ec142c45c4a9e756df482268e97b7f4842c8d771aaba3a4df70129d8b81c628d271aa0f85d8c622f62aff5a83b4d40b2c58cfb51b9cd1521913d17af7d3c80dfdff92040134b2d759d02df585afb5f9ea5774e5fe6e63e2cb6015a26bed10e641a0c4a4a114319f020d32f84476d1d898880d8a9f8ae972ef44eb9128b4cf6616f3993d5388eb4394b9d8164f0344219e534783b2c3fe674a8c5505ba8338cb6d7cc97afcfc16252852ae91f5ce3a9bbf95485b313d69f7b0160981fbbe3b4d9e6f5ecbaa54d6ef3b3b51adce6e67372b9333e037fcdd583ff3b16b338932f7acde1d523629d75a0ad45eac27b749f10e1dead74733c0edcdcef25168fb953507aaa1c641241991cbe06e77afb1dfbeebe26e43e7f7a755acd6475a8623f9e4ab886171325ddabaa6fcae8b10a288936c8bcfafb60838668bfb13c76203ac45db2ff74271dfcbbc9e037d4d7d96773fc43532b8b5cc4523df0592f381d28f23e3c6c4c42d03c3eaf2b293bd21e53e2949c54ebbbe564c47d2bf34a93dc8f1ae0f9b776abe10210606066361f217a61a59bf53600bb41bfd2deb76346b5fd8fbe0c36ecfe8322f2865fed610b1a14d6e9ea1ec13a420f5c8f7f7e3bfa3ccb073dad4573633dcbfa432d43a4b53fccd496dcc6018f40e93a023c29e679fef96138c3b4c6a4498dfb8088d1c785b7e6ea1a477e4d21971763e987815d1b22325b80b830628f538935bff095a04ab020acd610d58a7c4948bd84b94b9cfe53b4e8f10f373ab50acb1a3ae91fb94c627e3a9f3a57f70c921024c22c6bd29be4c9743109b788b9e124b4a05ab4602c58aa2f121e9e3daf988753dac14e20e50b3db13f015c77dfe7281c24dc26fa2362cd6d10195e20d3b2dd6b307628c38775ad35892b969d3fb17d69c8b7fa9c66370506152baa53ec52613ad3a01050861bf6f02e6a6341181070875b002f08e55f501d523bee321a42f9f8d7f348e57f4efff0f984fdbdb183311863aca8c65131f59e342ea2d2b76a4028ced66e83e04b8846c4adfce304804d633ec2bd3eec95d32c86c7198e5cc2e43a9f242a7618e89d91ed3b789a8242084814fe90201e46e0836c46ed41d272a944aa207bef09846a52ff200b68f0fb7fc1d18bd32882aed459b30f9bc213559c1ff663ba4aedd881f89ee24d52f22e4f25226f2612f66165c17cb0319e67b89dc9c401114c4eea9eabdd9763d3e37b468c2b0c71d7ffe414d327d9c26341f237579970bf3460d6534b85f29f23bd34557f3fca08c8106c08ec166d567a0582d8a2089cd468868d9def3ca83fd8e2fdfdc92f4d8a41540fa2eb1db4d21cbfb04d033612467a4f26d912fe459f7e0e1bd4b3f64f7559286be3e089ab2e0851ee347cac989c4b007c5c3b05b2000e4abc7099cc7b3eab80361a499e02e0963570c566b7a12595f69f153d1595f0006deaabc2265da354dc406487a94becd18e4116d3602e1b6c30a4d7a23f57abfce9ceb89ffb4f958b1f6c227aefb47de62f33baf056e893e5b95275e3c42efb06e3cac27cbadb02e71703be0b1b10e7d2302ddb82f4c8f56ae2cc5ee2e5e89e6520526f58519950527772e5732f3d34cd4c4858e7fdc88fe1b405bedf851d2fe98372882c5530ed2a3d84b1d1cc47b3aa8737e12631af0578a43932342a9c2f3e308e9cc466a9ad3294f31b04c1eac82fa839b807cd1d5b6087b3257cf4ebfe2a0f639433a299d9d420108d60d1374ba39b56ff9c2909df8a8daf1cbc22226674b7bdeba4bf3aed59bdfd91cf2f17f18949d2a68ec7a1305fd8fc96bc6bd959a3ee6e23c25e14e767698632734aa324db3a3ae5362397c1db1116ccb4eef51d1f7013ca5139d37ae3c0599517ae500c2aa74d9c56857175251dba22c31c9378481cec25b8114c349022aebb074cebc3a2c42ec35c1a1cf99a969742b09f8963a14e29fafa8407260be0debef1124c608f02435b335a7b899453df25ed54761b3870681e1c6ac5c49c385667f16e565f0473c28136525e3c4535691e5e1bff6ac2eff5669316f17c619db45a1dcaf8dc8f70249fb319f72f42b77b9553f04517b16d901b9fd12a7322e73fc41e3f6c179ce1b7d5e958cee8c9d415e8aa6d9e3b61e11d8c0a37a906be0871cb1ec2150915ad41bc93c63ac554c4cafef8e8597541c78eac367d6011d2b4a9c7eba3bd7197b7d9159ae26454892f9f2bbead29eb24d6ca69ae209982fccba186603ce4e7e9893b3327835d1c679873c3fcfc22c139403233a18bbf24e642f9d1fa4997a149884f043edd9d07d989abf70d8395481d2ef0640f9e85ae0e0b2b9b479f9191aac02a45a1a864621e29ee77c8e112eed5a14c760673dbf4226a8869ad230f1542842c0c40c1ba804838973d715f39e6ed908a94fade3ac49d6124e1d17d62b859c6aeb5dc135a5389b50112a889f7f84f08fd5a0d083228b16f38a50d364a491194dfec287ee7776982181d8f06e35e5b7678da1f4dc3d0d8bfedf601bc9fb37a2b1df194d86e60e83350adb83cc45c6b11d0fd9b0962eaca8c3a06f91477653cca76e17f23702a9cbe8a8144beb48f9b1d6213973fea872b3302d5a8f6ab459b504f1e42fdae98b5c8963f2994ca0c4c8dfc9d72211cc52f31c3df4e9ea524f65d93ccaf8093b200cb3ca06a5a8aa01718be268b045dd76ed4e427ae63e7d6fcaa9b3b7a5032bf08c5e0ba53a55ef09ca81635a314e07ec75d8644270d7c90ced0bff3f958da19a327f3be6f65d7e9bb488ae835b603a2745e5d5af9a67c0c39f8c50e105d6913c3b673325ff5f11555549a2ba440abbfcdc5c8329d99791220f88d54adf206d004785c0e8c66bb54983185c3fec906e0924b3ebaebe958b0bb73ec4a9b2b7e6b008b415763578e1bc74ffca543d5d422e59fd9b7e26842592fff7115d60a85f74740592e3be6ca87285c53d4fd0dba4e2753d09ca1b1f8b5ec6df8bc2152f90d5a78a76b511e39818304dcabd4d39c275d40317cb066c1dd75de060d367072b475899a5b2d05746a7fbf27b09cdaf1862a64ddc0e01dc4d4296dfd87f17e858d931e0cd5b06a0dab939e1af8329cba9595eb020f6ae765aa6a41dd1c2d57ebc98016749e8a9463c802fb715743ca0191362b035c2d344207c2bd4fb24cf461e49a33df81b1220025559baaf4709adab5946aab6b5ab9ef07c0cd4e0f7393a6efe011f6d57b7f23ceb44282c2c3712d98cbd2f5a6bda5154bdb5772a2ee0e3581263f7a2b458872f61b95fe0f8e62bae32cf68f9733d55ae6169c06fdd50254c049a233b7bc80e9bda84bb1b674130bc0cc24b22daff1baa6afcb2da9c679df7b82c80678447d9d3f6efbf0155303b1b5618d3587e4b88bacc58277ad9931751e0c189ffb903a64f5b94374ed7dc0efb36eca750235b4264b9d64b7bafe972d670fd1f8f1464cf3abbd7345efc877ab95f9d7b0e490d1b62bdd325eccc279cd88e518ba97206e60a8074da568f9568f16e0a42b309bde5f99a9c19d00ca5988edfb04abe81de64ffbc993d45180213199cf49cc751b7a752804ab9060bb5033f55e84bb08874093cd570e85e938e03c897e6317a79a40d2ba80b8cfa765300e06dd3d25ead075dffcd50eb2ca71a8edb56098cc93054e4d4f428ac0d40e03b01d5f7c32326e099197a0c3c592d388a2aaaf56480171f37a229ac4f2fe98b0a9cf8df210e34174e586ae3e5a2c19ae77809525fb83897aae3869dc9a3dce4442d5c02b341aaa0f2ad2b89fb81110a966b19fcbba556cbb85908d23158df6db0cd11311e0c9faf75e0a3de7768dff6b543f6380411c8d5d733f9c9706b04efb40782edbf9ab80064ea9c1fc1f65d87add4f4a689ff18941e7ce9a05f0a593b93571e6166f827209ccb17d206e428e8f88c82ab510ab345d3a777d77706d384848fa6d2ab96c85e16030e8ca430b32cfcdd5472ed7c8d0cf80780ecb952e8962e762d2f0e9d16b4e2d6ebe64006ebc74da5adad792d5069c5fb579e80afea221b06c21f9dc03ccb5f065f82bbc8de33962c38807383440ec5c369ea1f15147241411136b0fdf67b6b2f709c1ff96656272cc84f35dd914a3c49655cb5c95141850d7094e14741515c9b3bd14280f4ad247b8cad2a6ea5a756e32a8d2eecb63cae6650be44b039747bdb6576e7ebca16f2ea15b4d2b1602e723bcfcb697ad60df7835975b670cf99e97af5acec89a381cb7fffec3a72a72efbcee496188ded3104fd4707f0a197e7509c68d0ee44ce425576ff99de89912198e04853d79c07e73afe41b673a8dfb51ed7a76c9965349dc7c860d3865497a9d64067ed2234fd0d0cee17a5aa620c9b782dd2f7cf635739acdca7aeeb2982a049850ff381dc39d93c3d2a07a2b81af328d671e16c2bbd556882c7e756bc0d1a51bfb26ea6c1f22afc1675e126aea4d125cf21f2fc3f2525e95d0fe40e55b8c8e832cb20330dc2fda6c80dc704cee613c47501035d40403130cd5149048955d5abb0ba904bfca8cb527d116c1b68b285a58593aa35293433b5a619be9668830f899851af3cdf53a493977aa313ec16956585d9cbd2f2d366f0e1c7c1dcdee434b2152989f3482944ccced640bfec67948b6450397ef3e2ea5b49f8f801491af9d1f83ba131d53c91aba82cc3c47261810e6d71c42f64ad3bb503b376102a44e5973d81019a3e068ef5f29bfd0d8199f3ea5571a8b061c966ab863622baab67e713fb2d950ab5b10f579d10716fecfbff78095aeda8059a7c35998563d1920a3974e5715a384bd4c543d0acc48c3a436c882a82132d8bdd6eb58a354b20e5ce14b4b7d6b16e78a56aa01006db70aa0ca41ae9ba2548a3456750ff2dcedc49dbfbeed8cfc1699ee3e07eef2925c1c0caa8e4df3714b3062497eaf6e94c59ced9d4b0263941ec0a6dd0c456d959df7494e68289bd4186fa20e03f1ef48700cb5eb637c0c357a74bae527e7a8d73161dbe4bc510a469e2e3fdba0c352dcadbe875356e77eb46fba40d050bf5cc5a54b5fb5314f02a30ebae83eb75a30c7816d659eddfce1bd5eedc743d352195b86c72a3cf90bca7b1ce65fc77504cc6cf99da1b9002b8eb2d2d3909fe45d1a7c68e91bd72625fa409e05b99260123172424c8f17d96afa569b2ffdc60c0bc513475f496309eee4199839ca1b01212e174e6f14dfbd13acce84650214acc8ec54314426a01ce224dc28161901ec3c73d44ebf916a02b0ac96644d922ceca8f6aeefbf2b05296b1dc71d321e8ce631c10ea6ffaee92f1d9500fa4d8061dc4f03665e7630488821230ed86235de82e814f64952c19dcf660dd61c47139ce12e7e7ef0a415ff97256b55d72c99c334df92399a245f4b1c7dce107ec5044e83d2ea288f4d3dda4332ace515857e90edb208afcb2a0f311dfbf209521685e8114f9c27d28a981fddd797ab372c7d7146351f1e2a73e94261b73d2657cb60fb3ea5f4b9ff01c031a98770bfdffe7b3b2c7ebe9b881474ff34aef704c938554c3485756684fb7d5979d1bf7af093b8f5f1cae4302e5f8e9bc8ea5ace82d336c3035a2fa19fc7a9babd4ab3e659234bbf7a9bafd88a1096d7ac78b28b98a6e7e20eaafcc1db972cd366691d09d4718d1a04aea327e62b4aaa717292f8108f2debc8f124f0619e09c2f272440b2d9c548091c45fa9684a4a1f04f5d5ccdf13e1199a82359a79589c2f56f04b0407a41189a99cda088452885560d4aad4b41563e6d23f5e9a50394adfe600201b0d6e4aa3d14097d2283ea9bb873686797dd3bc38d13d2aab0c229a7b71a52bf64974fc79a377ad65ac001fb814c9bdafcd7836a5f107b1b4e785773a180e819f1e6a63f8ac0512befb08678cbbe25096fdd149c1d0b4f9bb296ec6581113d808439cb673dc751cbb5fda1019d7aae3123b2bba88bf2cff2e2885a01edba6bad728c5154a8e4477d68317f42cc3286845961acc00c9d14f12b9382db7d9b66fd27ab2aaf37b4cb6240779ef5ac10a7ba8720ecf0e24f19024c4b6450a5c843fdd46a4f0450233a5964b56f34a6f1140512f33237cf3011a75250940c4e067a3feef44bff98409ea40c4dd3e8a0507afbed75dbdbd766940dbbe369e350d1d3d78787b9143cb978fc5f0a9f6207f52630ae4f95fff893815a8b1d2f1b00042ed313fc34f496456aa255ba90b258f25cdf2b82b89fe5fc0e5fc40f1602dba4ed0a68f7f5df30436cae95f4f3b2155337b7f748a245e1590d77b1640fc87a36c8229dcaac33f30cb75c6236940815f61e77dbb7883c7ce6309a9b0f8b84776d59237f4eb0be49157c06e54458f00b849bf558a6e4862c5f022977ed88fb5005406e0838dac49750db81cc14410639df9be72915797c8ff02048c821688efb49397ecc2d9da54f708924a7cfef0a83522fc42b0fb148fe5efddd3fb2c803946db0ec928767811fe83fa5d51652cb6c419221c2a2689b95fcf716eccdc3e01d3acd6a3b31f7eea64b3e5291b57928332096bcfd76cccb3ab09fa145f28349464cc49d6effb8ed22458c801cfbb919cc79346f0d4ebf3750ab5dbca9c1876f9ff39305538f599b908cd172be8767f22ec25f0c69da77ad5275af533195b5bec6ca465d46030d1b93022e629683a7bbc5b689fb2959f48366f4292bcdf5bb80b46ff4c0080fce448e3c19877a0ce93d0a50fe692a0f55aa8e081610661dedb8e324eb7b387761acfab9740c2e82943dca3fe007c89e1a2f224f832659a9bbf4dfeed0c1b8080b81bd3090f54bb1ca8b37bff2158b4fc55482976e35785ee5fddc03cdda3cb419e5cf9ce8d83045f449ed6378490510a0980207310360afa3bb2066ffbd170057826542fdc5070415288fa1a64b084cc8ac45768615489b43ee435fc948be8a8bcdd37db45f8e550ec272c69efb25c10d04d9fae8b98693a8243ed3e3e6de6786d3ef31968dc441fbe7e9206f195db9c6d04f88dc56b4b78835a4e0613322b49117b70eb801132e6f3cc162c0b84ebfee789db8ca72f33611774bcc0dd9aae0e4c48c421ac7b6173ea26b5608501306dec4f7ee5eaf3e8f33e45d0a0534c86db1b6c51a10308abedb2ab0878deb127b9f7fd90638e0c25c0c7ac26fe9a540cbb49d70d3faa74e049c94a896f2e540ae871f524fee45e7e239e01a44b5b56c01d9e8d1c39c50ac41d469da8fe63881effd8f808d36fbc6fe6984f56efa232cab54aef9a33f47632d08dc1f9b02dbdd55d8d5f0e5ad1d17693fa515f0b0e15d4f7338cfe3f688953753e7a1524e33f93f2fa6830a991856589859675df5e430c0904863bc6f1e427edfca4a91736c5c6a443b5fe3e5871f928f06e0f0aa8363002c292491ab032ad71d26ddbaa9fc37643973da41fab32932dca63f23b713b6ec2c87726387881a8b03d0c4d8cd9be5223958ed719f86b3cb7ffaa0fb49f283f78bec683eb3796f3b7a6b9b2aa8c29b8178757501f6bc88db484b810559f67cdf18e1ed843eccb6e52472aa18b7a15db5f7953ad1a25a030c47bbff08be3800fe3ebb0df6c92f4a504fb461284cbab982a7e2a2b4d973a7ebc85659fcbee5a3129fca05399414714e12fd7059a8cbb845ac1ab170fc7c45b4b84b05a738058d5a0c103639b9498c9d8fdd1e1e3afb43318dfaf35f700ee86277a2ef9ce44ff83c2cf3148078d2c5c4d02ef53d44413cf39d9488ac1a4ba973df9c7834f08be5371a7f6f6d29712c057210d728bde0ba1a68226eb31eff360d50804e195f28abe4245c54134265d0da0380fdf4810dfe0127d98567e70f8942638e73a094f99d2fc088f6f5c89c512208264f9aa214a023444afe1ba46be280fc4e75744eb16fea3a723c711a268b106ab2919f88df0b2c998f15041b0aa53d3426affe76675a7c6ca4c1d0de332f8891b252ec610c9dd50bc17bc4207d5ab28f01540a9dcb2e06d6ffa33c8b0e405cc47b7a1d251a1e9cb4c4a6fb30f6a47f7078e1687b025393edfe2ce5487681ea90d9eb97e8cfefec0030ab76eec98f390ed34d0a955f177b4c884a671fcef19870f9978b9258080741e624dafbdf2047c33ebb274c103fe0c9c053929fb8826b3fce0795e7339c51c4563f4d3d2a7045cbb26678fa593a3e87e2fddac12fc05d42abcedcbf3b6dfef9fbb875dab356d34b9af94a6b9f565686716ff8552600849d2fb4a8d0e1b68a75e56c86341fe8de33f155fc929f00f0f2decba1be72d0111028601e463d18877e6665380bb6bdf28cb6ae3caed19077943a931c0b8f9a766d8ef3d8fd35a8e5e1f293adf16317bbdbdbd36e2bcb32017babab23559147482bfa4d251e2f7ee2a4e5cc554e2d6a6420aee3f4f2638556d5e92759d369e9ee05e0c176b9b82fcbe9c56701a7c8a117b919c105140412f424282617c207ceb6e5d9176b99ea6d9b047586c189780415a9561b4d4cd6df0d78c05299ee56aea17ee81fc1fbf90035ab2e4a8e899966c56cf0179d32afe37dc98839d25f135d0a16d616dfaa0ae1a6e36e4915b975605e027a7c37fce86412d8f8ba8730ed005dd8f37b049124653bc1e034624eaff1ad6abd92b1d28bf4b1e2dc6186f03e4a23b84925f4c6d042cf3c10424ba498420268e6d0a992e4ba3117d91ee9e2f8414c6081836efb0f280280dfc4b95e18bdbb6a6efd0c4142b98f0227ccc0d10eaa1e7db37d716433148368f9cab06fc5d1c2f94a616d45a4c8ebb73566584b4e128bc82ad727dc61c5ac27c492a25a17b692b812d63660e08ca18bdfda08c25ba274b8abeeb404be8bf38ba8d24b5e318daa7d42b205e0134aadcdca92a6bf06adef76999d2fdc9d5995f08b56ba396a9b73b639d1b4c84db69abddec1c8407116aae09fb1f7b2141b4a3e32b98a64a742c4d4510ba71bd69d968f487539529f62a334973dec3498451dfe2cb6bf7934f924e46d922726be523ead1d912c0a7d1183842137d05fe0817a90ae200c9084c4e49a9e83866c4c481ae088136e905dce7d4ca8842b988970c025948c341033d88b670fe24ad4ec80f1ca8486b1c837a7ba6afb4756e954d50f09750817680b8c2c7c461df7ee239e0724a92524b497b922258ca2424b0ac97009374371f927243bb89e0b568380dd260533e9c2eed617b26d9c7a220681a1cd4818bac39693ea3502fac1a7002342d429e5ba9441d0bc1111cd412e58844e157a7bce888c166d2a2bc528f6146922671e3111387e792a76911f4954699a02030fc1d0204f6949ee8c2903dc40c5a9eb3710aae558ec7656d260c6eb719d9a8483b1048e2bc5e56339e4c9fae59d7f9a257d4a7e81be5b828992a9307733786d300a4eff3ef806d9009dd0cbf997651648e590c843efd6e9ccdb1dd02c5eccd40c6346237df2b3eb1367ba54496aa4b38e9bd2c21b9ff704a654a3da334525b7f0c2d498e8439caf1912cb07c8ddaba9db6ee9ca55461c93d2c5825c985b47c7c1c37b47affb7a12d933c9a32c7ec20f8e0d918524cc72126c7985ecc8bf41ff01e3215a8bb93bd7612a7ba9d4676651e9d0491eb2f0e764895ebeafcebfd5fc1d26e6fdfe8d097a5d3396edd2f4f259ae84b9a43716bb0a85f8f40b6814faaf9748b94a1ad074ca2b806aff5f99761ea41b7f8ab25084608fc383ebe4ee4274d27b002bbb41b1c815379b26147d4d2328016d126ecf55edbffb576259ebbac0e5cb652492a782faef15b05ce42a2300ff47fe8d7340651cdda44024afe2624a86bf64968f74da24ba10acb6e7d545ccbde989577e09863787a25e17767de3f8546c3e561659f4580fa06b8d010eb219a514434ae03e374e6aca88d4e962af295f6edccf51e86309f4e2193c0b14e7a3292a6f166676a585b269f6b93ae54f8232ad632b489a612584c4738df12c5a6e4717b5a35ef2c14e1ece8129d2930193e36976f5b78975d217b1f3026fbda3941b86762478250f45412ede037308e128650240cd149d6bb76443481543533a4c0cc5ec5ceaf6321c5831900050c18e081a3a65df53e50de03eea839929498720ae6255844e2d36b364d676e77f44bb14f7665cac0a908ffa40c04f44bd00959a1d958eb400a251ebfb928e71d9c5739a7de275e1db195d20c0c49a6e2977f3cef4cd81c05117f3572ca5759d443b866a036a4aa668df80a9369e032b36ac048def44e6278abe1ce82dd725ac8f88a0dd1ca07071d5e1909705800471211d23c4af639459b5b99e88decbca376ed99c78ed2b30ce89b72c88f3be8636fd3b00e9d68c300bc797ab460b72d4fb39a4c3b3c39a96dcbac9e133f2dd5c7904bc11a764c9e043b774d7f4dd7604abb77f5b6d522779a9f593288cbde3ebf37a2c71aef3f21bdc66cbdf5d1f7a0acdbe7e635040b763ec4a1c3bd74edac343bb62f029c33a2fd3e6f220f2a8408f5445ab28f899303d4d4b8f9e8a4c2fbc0d6e02cbefd20853ab357801897ea2557985cf875c859c522edc8498bca02c6576327aa63c82c2b9edfc7f81418382bb5d5ed9408441b03befd3156748e0a249abe0dfdb849b5f01420f8b683e9460e62c3c5e6366c9fcf729c70fd005bb12f2e5e070951a7b1d7ea1e67da14e30cc4fb6034918ae29831ac3f8900ad1ce5699f359ac1a665f3555124d07986cfaf6aeade155d78cfb5cacdb6e14e02cfdeb6200fc98fc1b532022fc935d16932ceafdea23e15293e7b279ff67ba78af1f9cc2210cd3e52633e5cb565efe17f297af9025cd931cb5d8854eb3df5c2d8227bdabc2dc5d04d9d16ab02aba9be60c0a082d8133c2fa99a1cf8eb6a4d4e5e9dacfa20515a392796d1367625e6e3a79c68427ebaf93830a9a2128355db565d8ecd15f05ec9913532d5e8f31c6bdd98219ced835d3f1be225d12e509416363f9eec8aafee80a1eb9b9c8af9a0059ecfb26a61d76dd8135268e6b41a87bc813f847278a83f0767d55a21e53a88870c6395a6a63e954b019d032260e038152328ab7b2a4b788c0e85b473537d5ed81fa5fa219f507e5e2e140f69c18cf2f1b0e0cc17d2e5a08eaf49d4aecaf330d291324c6b20236617193665ae0756c8dff9b54baa6321edba37d7c51b0b7d776fe1c828ccf3de416346ab3ae83ba8dac0d555d5817203389993c69df27a460b1f2a3e8055da27b6ccf1dac965b01f890c3d62f17ee572a7a5c48b12340e21c5180da0db819c3a22cc57939bcf1b3e911db69b3c768bb6d843d11f30efe6ff3a886fab6b31f1fe615171f6dfa85c7ca666a22b79136c2646b38c926484cb94b7b8dd6d081c15ecbf2209e5316501113f64bc9e9ea949b4cfd14ffbeb985d8d44b84ed7327d7bd970ad737433242a164858d5296e09a4cfce7e634c9e778f085c268375491a9787c6743bec95bd8d1be3f9b3d483fff7c583d32b0deabd5548947340c01b200862867b79ff4ef73fabe0b9b5b203b19e39ba5f2805dd1d4fe96059d9126603b99f3403b9529325619d27b78722bc68816994cb5691af5b8d3cb2a483c27a2a4a055a930c9e9bcbc5d88e5700c7c5efdcabd6390fbcc4a9c9154fd8c8da14e9289e237f2c4cd8985d931e7b1ce2080e6b1c2e84a6009e911248db9731a5472ec350e4d322628c1c0aa0d1a7286c8690a14e477d99f27d26cdffa2486cf651984c139c48e5aab791bc0d32c7a88b95ceec3cc321a83632b2ef97f939794917d0a93e4460a93929429fe8e9f4dca7a7d3b1387faee0510cfd056aaa7f3ff390625308525f5326d167e60e38d0d06004734860c62b39ff205f35b4b25bc7727c1d6a9072525b32113a94bcffbeaf2eb0c14d96213b73430e7b9492798403a20cc974848566e3c5b1744c7935cf08d762c098033e00de9a31fd362db6b70bf8faf76b9d8bee22b0cf7b9317a56290b9d5d28f0bbaf7ba06fdc7816f6b7c7c9fa9610524d46aa2b88ec98d1c3c79c4342567ec4b41b55e1159a318ce4b499f24645333ccdb0b9e778c97c996c2d78d3ae57b49af01385ae424332229f99a8c0b05633bc41d1b2e0112c4ab4aaa5ebfa2030b97b639b65873180889af9de0ae9d82c816ae04f286c777850d0ec1fbe0ee574d3ff6291f401736194c9abb83d149d5f52ab90a44d59646da1c205594687cd64c31dcc8fa87456fb18a9a82adf73699dc75a8b4677b16ceaee274c2c39cd67fc57d572eaf735a39d894fec04a4dfba92f7cfc0f5e51e1688f9b0b7f33a2b9c8b687905c5a42aaaec46fae74f2e0a195fc5670f6c494152f8d08b7ffa9f26f836ce2eecc45f01077bad0d6193333f448b88619b4736647a7b8639df12e7d014da0e34d8f3f4058054026672f7367daffa6abd1b6316389e7478a38fa802573e05fd6272c98ad8f0b625198c36d1c834ed3fd6930530c6ac11f432acc815a03305a7786c9b2a232ae23a68549af4504475c437cb8342812b0c02e479b0200dbffb76f9d06233235267d76edf3b11df049aadf81b3610503ee05e844b95db66a2dcf79f4fe10d83e1f24f1ef5510a0ca4161ed3ec8b2dedd164a2e01a69675ebc744578c647fbe7485eb7055c22b10c643a5cf030655af0d7cd2c2a89ce114a74c6d016465be31497665eec4f3867ae867e9291c503e3d70c4172ec1bf59a6d71a7d299b8d142b14abf95b4157974a42b01715301168bf0ea063d4dbc6371b1b6930e6c3abd452c88b5f57de14b6acdad707ada47badac0f6fe598251e393cf7e7c4b78d769fb2b79673f85a1f782d5b8e9f6ccf6df474cb09c288d420557bc39d00d31a334cdc33e5e8e4bf0b621bfcbbe23381682dfc2a98f5cd96dc197cc006daf0b9beebde2384852d3f35063fd21b8d3b160233ba2c0521cd76848372fe23d5b40fce545c360f7e491dda205b4b9d349d8c4cde6bde583d6aeaa1a8fe35f7c6f5a1aea6e998687ba2ea933cac57b5c54a3dd970a4cd006e187ed2f0bb56ea178854804a276bb6db461abdb7b97683bdfe1a6ceb6e0d484c66e1afd12eaaafb957680ef90319a351362eb8eb2a5c4819605e612c786542e5b326cf571b581dee9a385e91dc28e04d65234060a6a9460a5aa16fda2cb3c016699108c60e6c9847e6720a62d1f936c57e11ba75ee07958cc46be693a623b1feb364282da262d27a9cf76f6606a882c2a784fc07b70198a100fef72bf4104c30cb3a793a50208e09d21d36cc4ad4b15713cddb38262dcb4de2041e67f1fec23913fb123fada7547d2d09294545bb3aada21db48469597a78abec025c0bb01470f6f2597e63508f90c55efebc7e510697ead1ff4cb3dcec4cc130a5065cf952148b855e68bb1b367f69d4b63165672654cde3b10879755d71c06a0047fb15c63f1134ec54d3da029bc013aca97a1971ce4c63c4a985cef3ce5d2f3f0fe697fac4a14683bc9c18b50a60816ff0c53f23fd6865e47d3fc0f4628c3ffbfd969b5069883f265ae26d5b28f554d4ba10e548038a5069115831ea5ae3f338fa2479682dbb60c6b0139e8dec7e1c74a4742708ee54257ed6c29c5258f50b7be2a3f30ef52a55287dd4a47511fdb400068bb1884a149046e423e15f0ffc400433b3b41c8076af28b38ace3955003ea0fccbfa1ecdefdf5b2444f6b23d7f7f1d455740cc270d71cf605b79c3a69898b828f54e7d97f768c29f45d4f130c167a24c1b1203ecbe8881d94a56f77801ec716a02a51c89f5637633c3e15c217eecc3f456af40921d4346e76c22eb5bf325497be5623a997f7c156b0b33f036e866769cf00082d6094118d13320fdc39b4365bb61f09344d05ec284e95e354abb2cbe8c99a4ce322395e835c5dd3de766e7dad42a298e14c090b0b112f5e741b3954ae3f4a232847f1309411c821894e8aa05964e6f6ea8e4a92fdfd104d8f8caf2e7c166ca3ce49de7b8adb58c3201829bb04770796b98e71396af9de941af6154b98e6d598b0c319f46f42dda5b6aa22256c14cd97c596ac42e2b4cae0bc660cc67a3ff41583419fbf5c10401bd0eb16b029a3c06ef7e50c3d68066c4e430bce9353624a36c6f70d6b4545cf3f5b31ed058dd0097601e4942fb3506f124c77f46d5dc87d28d10f40bb5f1fa84beb2c3cfbd49603f25dd3f1fe403cff5194c2b713bb03d2e944bbf7d7d313e5a300fc1d81b5a61d363685e0128e65e52b8939aaddcb5e274bc5dc7f328f91dde0a7b646f486df7c04bc1c5436d1e26654d498885a3f1f0780e3e862bc06eb5d590cdb2476c5a6ade33896c4dad32719cd87fdbf6a3a12ec9fdad017d38b815cca545cb0ba40f7939f72a92bf7f99cb0d5b1142d5a0913fb1483d461bbe40e4d513ab905229b7be5c169d34bb45e6fa92b082265801d6aca270af6860b749d146063718bc7eb88adec3643d8139481b4e2a37aab7a7d4ba5be0f7878bdb97f25e2ab885dfa8a4df98a3022199a1892c9fb0ff49e8ccdd5fb3c826cf754f6d9c61e74784835a768162e91c5249db621caa9f7c2af4e9db35aa80824fce6b16e589f16a0593b1f5f49a2f5eb38e1b4f13d53e5dd8c8bf7d56c37058d49e392ccfa014643efe38746470412d2a4ed35f96a12a6bc77ce116a3f09eb4886383574dcac6813623ee7097c9b8475b27c565afe0a0022713156a57888da0432c2f532124fa1e7a66286adc06db71e75c116105647dd78c2c6c9a99fbaebd3970eea4c2ef07b427d3663919760f6566c69d31e6494efab01249ef06b433018a725c01f75844c6ff786cbf486dd605e2f8620d3796687be287472d653219351ddaaa5643643a0a8ea1773118ea2419111d62ffc435b0c4955ba0d3237fe9b53f224f659e4603b8949bac4d450d98ded89e32cbbf8c12f5b9e88ce82d7b2ca10a4d39d3f0200ad281d48e198b3f9ec252e7b9bfee74e7d33dab7e3daba62bc0571b2d93f989174bf23e7329654ea1da893cdf5d9e12377459ae5d9ed5fc739718225b399e64c076a46589a8d81830eae51b399963085bb4a0c3d67669b64227b2e4ea5c0ec02c6078c8723a70fcc8f58126e73f0ed572cfd6ed92aee213b05775bcd5865b1b33dd43410a76eb8e8c5352ddfdd5064300e7ab3f3081b2c0729e5d42eecdd7a4de4e5db982e1c5704ca432e0775c76ecf50eab60958d80016216a862f755dd861d6ead09b5144cea62d38859a1d30f15b5714a1e9af382bf15d2bd8642e0a9e98a18d9cc554d7038deb27d85990f73788a0bb2f41be877579cb43e9c02baf4aaa8510f0028fc7e4130f63a536a14865ad1b6030d9c524ad3533d271fb1baf290d69f8da248d2ffbd3caefe5264595844eb5f25d6d5fb7b5dc2adbba0de28ca64358f981e6e8feac2a56f158e8143e35a53c4a8d2270e722b4e4281f110c561fc922254b91a9ee8fcee4953a0a25dd7b5869aa892f5c2960d96eb3cd770f2e87ded8f3073773de3b0b88a78d39b571ce26883c2d8cae4b1578a35f4d85c311d13706a5691b02b78f9e4768a66b2af07714177bc7383121c306d998c69127f4e20531ae5a55a230c588e52b34281127eefbacb92aad2fda34484180a1de5ffdf2447cea9fd0484b2e13082d346cd","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
