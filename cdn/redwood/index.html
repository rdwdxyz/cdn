<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2db6e4d7722502f6ebcd8cb722e463b86834fa0f50d565f9c5ebb786f9519e6c2e9a0c34ea7df0221bb6c9a0aeab79ea914cdbd374fbb76c39add236dfcf02b03e89d04c594e999a35cd2647c0d2aeacd2a402023623454b06e166d4087261be90d01a5761448e17d401d37b87d9660c7ea306d9fbfa522d9147dd8b9fde6afdbbe4c0d953587d8068c09b098936910a89907c2ffb4ddae2b1fec4aa5f67f3e888cf96fc72cdf2f023168ba34eee728df60ed8c2f5ab146d6fec481b43c114f48b5af52c95fc07c1dbdcdf309c7ccfa964556c1425f4416c202d69e34591e0ef10014e075734a6e6fa5d1cac754171b9f09db3b88075ecaa7d92066e8e0b0da9b89131c8fd4d0b2f5fd9fd6d93692e14f712fd0bc3d4fd9a36b5c6bfa82664e8c513bb5c04aa1244c21ce8ed02f8e8e60237b00ae02b4e522c1443ede7ad4cf854ee13f5de0ab7138495415a2577c0e10b969e4889aa52776ff4fc335ac3cda89a4a275fece2b69092a105386c358c4ac33dd36da79c463ef2d93d78a7519a960cff797a93a4673d68ad37fbbf3c76a4e1d57b9e143818201fc75dd1734e92fbcd60cc6e83f38114ef720851201c75a9919b944246456be4f19a104c282e6f97729925a3f601f64db2e028a83e2e197d15d41530cb361a819ab6f91a3ce78f2e794bce4d595d705f83be44ec34c6aa2e244af8b73687605879f6dc1b7df012f8fdae94ad2da5b9097c653bc80d0b777180b9957685379f81eaaad59b6ad49f23e1f738f5384ca983149f0ca038a583b4b400dd3382db7886a9c468d28da1c4c8ee82744d861a45632b1c85ad3ac56351cb073ca8532052593a92f4ef846fa82fc8c8fad85cc4762ca3e58b15988d9898b5deefcdc9390253a79b1b06ac5914b12f17e6fe3a1084f5623acd05977579f763c9de20afab81b2cc4c714fb84cf4bc4ad5f74f8d100f86e070cabd3dfa039df4e85f2ce1693ddd5bff21db5137f0663052c8d19563ca6a60903404554a46e6808ddff2448346d95dd59f1555bc09ab4cc1bed2b034ec751270076aa001b399163795aab6611eff9d8c0557345b185a4e9147e85f626e643645fd6b8e9e78a91ef4508507ae0fecc18a4b1316202cb3f5fd1af7d4daa757d164c81c25cfbbb84040a9f5d9fd43aa0f6751527143b18c27b5e3a6c18a3ea90e9cc6e17f32b46a85155e75021a532adb5ab9a73d3b00c5e9ff79fce6a0b39225d0af1c15181ca7f60d16a60ef1b66228b9590f728782e9f99f600b010cbdf420bca156f387f037337744dcaa7d3bb191f5464938a674e4a99f55644cf5a3e9791bcf19c7d3b7541c32509a0c3fdfa5abe3c1fdfc8c9f264de6009ced90b4b609a27667d93ab991c4ae416d4c949464590a6aac4a245cabdfab70749d6a9fb073851aa4761619c0cd1a43d84ae11bb85675110a1d6f54d4045ad9e1ab5952821beda8b669fc3e196c9c8a26d80ad5cc97b3fb53ffbca7466f52cf42519ce2e6a9842a54328d0fa23fcf1c2983a1f0e116b05360b0b71fcccffe239cbfbb459ec4d0d074745e5a893e44b1643fff8d40680b096138148d48db42aec0ecfc9dda863ded8779a3f7dfbe06794b389660e6b2d6b5671ff4f20b03771e8b2dc97abc28fdf8302c6d1ef1b77a3bcce4ec21e274d7976b88908d019aebc3b99edf4db48906ddf7a8984a26058aed6564eafaa7df25198fedff55245695fc86e9a5ff3bcad2effdb60429c1acfc9d9506d087e5ff5c118ee86d68843a0f58e75e027f76e06765d4773239cdf41983ade34cf0a60a4c46a3c667bf9eec3c20b369f3b2b5729d70b038453c9e2bdd523a6d499ef8eb97a8b9b75b9f1c7ca70878b8f481b730c41cb2112e0740f9ce8ad8adc16ccbf78a67a15bed57d87389eec12c34f09cb1c15e5e22fd0c83b54bd4f990f23f60e5981dc11c13353d52cc32b629086ef5a7d1a16995625546d78431d2659998a9c3c61391b48a63bb83bbb4a636db405f0494b0fe649d08ec0931e1149e79742bba2b128104a1f8fb87e912735eb57f410c94a62a6b93c317b84f1d3a984b5060a4803fab7e110682bb74ea759df814ac4912262060e2679921ff72b0bf286a3250056551935a459c2cadb79ac2d297fa227dedaf3f70c818f6032bb2949dfff24467b975104be45292a59578db586f044af8f0f57658a6b3073b83123d307b0cef482fabb5506c42d115ed7e143e44d04a0fc2e2d126bebe68cb7a010f89e34bb7879582a768bfe296d0579f5aed74720e02f4bd26f2d1ec475bd918dede572bcee890d1466491c640bca98ed5ce581b55cf027fadbeb1c0c2a42179d25f7c2ca1691bd74531e5d21af8516c81818c4e7c2f7a519a82adff46ef638bdaff1872921cd5d09130c85e93e0b71abbd73b21cd99c58d0fc7d367aebb0d4852d8822daba55ae7509acebf8f0c534100652d6e2663001afb75c29b6e3325c4198c7bfe887bd560d32ff0d13727b04a244f9072663769638fa800142423114fa5bed381423e83b0af7a20eeeed262adfd3f108db17f450500ea4b4a6f9ee27dee98d7c2702a56eb91f3fcf7e392c420d4bcf129b6e0ca949529c58c29cd469c2dd18045170315650875430e8ee0e528c3da575de9392170cb5a1ccafa9d693c3ca4e67ab31886bffcdfe4b842f8a16d49ca320eb8b9b0d20d81e8048176091cb885735fc7d75a647f3f6556f55d0fe2061d25f11ba94eb1d1b3bf1c1353c35fd2247b53972b0911fea2bca953cf7561de8360e3951d8dc96e23f310cfacbe991229f8896110e580a7f9239f2ac854f15f22fb327e592fcc60e18365f0254257ebbcce79295ce8f3129dfb92649aa2b6c6cfdfa1a415a18e45bc12333b8c73d17a2989e24101d65a18e0b24ff56af62d6c9841c93870c675766d1e7db68717090e51447c75856e63927b157e6f797c1eb5c4c7cac3fcfefc6ce4699a4b020c0a5fbf2afaaf86e7589954ee68f18da46eb63218dff036d1585fb6a0695d6c59e2c7f85e7f8a9cdc500f19c669750634cfbc9126264acc42219badc8c0f6dd2aeb3247cadaa061e4850d7aee3713192ddd9d70c9e6d2911f74406ca41b92dbeca17fcbc49b48e712afc71ecf4c3a37000dcd0b1e9b3e9a88d026dffd7e5fae6322d0d6ba3cf0282c6b2f4a6ddd0de683970b396670e76864d8462f77dfbca2bd7f1516e1c0e946b2ed1322e28acd4663d72f153276051f99b3d7a0399a701200b5f5f157981b3bb6f14dc88ad999d856ec2d162c845f4f5b08b9fde48320c2935d9e42600d1964366d550ae135f7d31d9062fb4be419ab0b1ff3da824744f0535c198865c87f19efc9597e15af89b23789a4c90fc38053fdac05aac0d9adc93b21597f94ed7bf3c269682acbd7ffcad94de52cb549dab8cc2d291a46d7990597331d702b908813815cd6af63f255fe33f9d8a4d5c9992f4767d61370e63ca7bb6798b0c2d9841860d99c2a9d4f5aed10d6a761e318aa9022e955d4e684fc475c327d250b77718c23aff5e51ce11ea93fa16a6bbabd6a17fcfc215a443809874cb72e23959fe4423243398c1ef5f4bf8adea3b81d46b766bc29604e0adbf1001fe936fe0486c046ef3f733876a7d7468605b1b64eb0d4adfa8b7a0eab09e3372339da6496a33eaab64bb89a6dda37e793952500866698a9065d521ae3521a2c81560cad4c90562b5e4f3a6df11f5691ad437fdb7c909c1fa3f0f57bbb76a55be186e97ae1b3ea6b5ec999c33d9f2b4f01f82fe5ee9431d0bf27b8eaace0a3ab5f09eb2156df7feef422273902cbedc3da1c73bd0afc3e8eee970e3134bb48343f3c483dadaa376dc20ebf914f15615421b479e6484c741a3ecb9c867f2eb4f8d5a5c7e28c4d81060bfe25b9e96728cf9dbde2c6682e782089d5432c8f9505a2bda935ff1fd3f7e0df86f7ccd80cf4b9de3869966af4df7ff72dbdf4b9ed8d021d30f63da76a3bfb790d20f7019f815f5c2f1faedc44f080a5c4856d5cf0b63e07db5cc5c7f9fa6a111c7005adb7f25d89e83c93b788c80994f1f4135250b6bd36905a6eb190d4cc70d2740c65da489e9b22d104b747c3be70fb4d553816394b2837695df27c8fda9bf842550a0c6ccda872f862f4bf922728201722063b74fe38b939fedfe53e7c95afbfb1cd070f9bcbbc8984b514cf42585c1839cb03d99b28000edb73a3070477fe20616ed8193230dd5b38831e897cf08a6e8fc2035992940a1f6798d3a8cdf8457b3f9daff9163f39f5f6d10bc73a88b63815f39e291f7bc8a8a12d5403cf045024833d697668cf1cfbb860e78e9ed17b023b22272b90e4a1436069f09e1d2165db475fa6a5c0f62f203d43336c0fd50d2a6f9573ff35c6a8c10d0558dfef1ec8323ea54c2d04919c8228eadc8a5deacb53a454d7eb01d4e2d54166e9864b2e287e2bdc18150b0910d5294df142cf6ba292b0d4d4a2f59b79fead4206b026d05ea7f0653e38310d28b4531daca6814c9ddcaa8b4d2aea0081d5e819f474c928d22edd5a78491103c9dc0ddfac9997b8ef904b64e8e9b1b3418f3048ef887e1ee288c7403e888b9cf9e74320dc4a5e26a5e496e2911b0fce197ce4e9e5f6eefcc5a1ef4d8707dfe070340fb5e4d8f5ada1b878f6ed42ad5a244706e80ce06db1b4ecd1c2edd3a3c608e36ccaaba563ffd4efe6e78e270d1a195cde9ac1c514c8e6d55a02c0a634e11e0ed1bcf99a11b78b9af76c8144da74c45c8b4e594e914d2ff152cc68329634c40d92a9b9bce789a31481986f787dadd23ea9d6025873d4d903064c61784b5a126bab68b7b2454030e4db4b48290c96b90922fb4ae8ff1549bb38319ae0ef884458eec8031b0cf360a8559069de8cf05013bf56ebe68f8168b325675649aa46c6b47256f8d8945e26556ee1663871db8dfbfd090b4cb4647bb0d41a4f844eae4b05bf51b887435763486b26a18b421670a0eb142781d10e24fa3380fde9b908ba18662454687231ec071ab0098fad1593589e193a312b6292ba4f59ef7b4f0c414fe30699cf538f42396aca5c898240fda6880c1bb590108c9ea7c566d8f7ab098554763463963c27ffb9f8891741ad1815eaf02a82fd672181c246698156b5b6b22af7269cc91cc543b04719b8fccfd72ca7add21b8086fee82998cd9db55a945ead0bbb629841a1689fe9f0926196f5c5526f08281a22476a2165af3fa54380316c465c584cb36e779bf01b79e349a53fa996a8bab322e6e6ae5f547f904d294f0ccdf19107a5b7c2fa528935b92c7ab3697f7e5aa9502cd54f747ad2146b320aa9fea9200dc6bee89f68f61f69ae8a0c2b3ecbb130233535dc9beb4213a2c5bfeafec3e79e877d39f8bc30d4d06a2a0e243a3146f371e40acd87672a1dbbc2d3364dc2c9668af702b8e3291ab907103e746b80751ae0e20ad2d51f34b1fbabfdeff2f541e14c4eec9a9d04b75e684448dffce180fc5f48441972af6e4fa6923f52da3a0d8de8ed2be3ce03d56086e368bd8e99ddb172ff9709c5eeae06afa034bb5a41ba8b3627dd95c736948feb7234f87048b92511f94e12c88a3fe409d3efaa83a7eaa5e89b9441424e25a441a0d7934b415ee2285494345b2e35b7dec4c7ff09180cf8a2431da92bc1d0142d111f85ca3006b9a066692c794221af5bb4a88a450434092151a4279ca187ce15d444792a9c097237d9aacafe46ba7fc6c0b20fee0626dad2f58270857394cee5af4df7efdcb239f327703512d042b5558d69665020d14d1ba7eb76ff5c9fa3896ad3d1e8f985ffb1be2702ee05faf5d6114111677b3003bff0867733bf2ab1b34789d1fcfacb000d585368eb813474495bc3c9e3d6d8a5a727a50c8b82d072be995e3b362ff2d122b791ca02f63996190712c332b8736939457e70806b06ddf3b676c7256f6a924cb59b0c326b18672ae64f48cbcb8198caab326b443ee6575c3bb0dca060303de6454b8664d2d9c32524105185eb267f2f73c65b702b70b1a34da920e733b3d2de6a437a41df825f5f251facf9099734130c3ee72fd227a33013c0a5aba58d5b213df89e40d1f5c13fa51bd52dc0d6a32ed72f181d8ceb69f703a8ec8b491a315194d18bcd8a9d4a55d59d696d33a3e23aa67eef87ab1952934e574818e5db6a3773540693ca471c7410e0635eabd4d809d6ccb4feb40ccbf51b267aec1955dc0df4d9e2e8cf913de6c5dbe07bb3c02c4ad51e0c29a65213c390299b8a04280125d5dbb24159b8cd4b984f08dbd7cdb94b6c8536e0bffa603777df5c4f08898dbb83e00d2487e4b2783e1cfe7ad151a80877aa3ed6c7f3c4874b36e811547638cac17b649154b33e82272e5d33969b646a1c8c46cf6f9cb48d6ee77ef2b9362b57d29ba4cbc365df03f2f0f5386769ca12ba3cab896d58ebc9893c250b12fc45934876496c37f5b44e03aa47f34513690408d38ca5174666379d2b67637daff951ec5ae29d224532dfde6e8c2a54d9b57e880b5d45f3275b428a223a2c500fce8fec95b8997e1a7cca404410e81636d385899a493406b31efdfa5dc27a6c69143697d533cc2cd3d7d2231ac0efd2100ea44e979a3483dcc30e3490257dc7501aad0bb468063705e5c7bbe5f070c775e7cd1a1f76c8e42921f6b08c18130006d478e8c52acafbeab4b1afb4f3d8483288c61ab06749152f0d7346a36d3655770617aabc494e4a5922d1379cebc481fb0ec0c4fcb52c966baaa8bdd3158d528650673d668dcfec26d81b947268810aabf935267e960d3d6609757b0309c1ef5faeb93298344399590253b4e4e1a6c2c40faad3da168feff34e232ebff8a90af2475416b2c029a849b840d6c8414f4cb6eae9fdf44c77ff1dd86b4d71fff3ae8458195555f1645f1983d0e23535ac194a09b9ab349d53191b6f102595f8e673033d7ceabdedaa3bffce57bd186369a2fa55d0b2173e9eff7ce77c81969e0f444c2a864d3fa02c6cd6e152fa741faaf461fd38223cb632139dbee4bf5596e66f024ef750e6162f21368743bccf549fabee8dfa9024aa1d65dcbec57f2fe9d54d8b014ce92e2c5855d2b522e45bf37434e2185342efe1e9b72ac7e98950fb59dc6d85db50d096eb22e5e142e4ad392f3f25a0bc35db044725397657e11c94242171a99eac172b41561254acf9efd02ff12b7773e607ee4aed043f047a69d3a6433a8ad5469f229718bccdf15b7fce5145e7241bd2015066a7070faf550221e708cbfcf1897b8e85bbd6590cd3767d3bf29268aa02287bcd020879d5c9d6d4d35efd0f1df112ea7a61c7b31b0e3629359879d362dc592a66780fbb70137140a7f6b84da86d71a11459c9f85ca521801a66c47b6248d50bd68bf37a4fdb72cebf5ea8b3b49bc1dba3efd2eb649c516e2394d375decf027b160db9687f29e36a344b5d25879fc269de879de733058b9117a74bae81cd21b281a86fe64905eab0781235fb00dc2ed8efc4a20153ee9e9beb14bd380653d9edb4d5bba70065fafc50e0a3f43f05b9dfd3ae82d49fde2ce043681f6dc92f8af474a1454c32a20aa0b5cff5883f6d9d48d9c6e39cf0b52f5634d3d33c6dc3dfe476b15a99e41de41a520250de711b650e92f9bee1e83ed54bcb7e07ce1557b085a3ed009ad61e6e6f6028d8892837bd42c9a9eea134d75093135b60a2e882362a0c5dc7731508da07746eda4771244fe4798bb870cf731bdb9e628c86369edf89e8c4ec7e302e086bc123e0abeef40889eb452180dfabd6944da65f6fa82f521eafdc7aa609b67791e59897ce313ce37fc70b6b1260da4befe0d3720b52d729989c1d106d6d355d7c3f12393b153361f0811679a28ce3959aaf034b1e4731b21cca20327d897ca66a9265b77c891816fcf943386851ba69b1f4bff95f99954df251db7012ec6ae7a81a42d235c234dfdebca8c621d4f10e1d2ec772b80e9af4ff1ee896ca2eadec453203433a80bc8bebf1c51dff4ec27d4fcc9a7af667645ccdf048f36d61fb2d5dfe300196413595594a5001c8a794f0ad43c61ea1b391b1a4db0b6ab862b2ab017fabbc33bed73e7a2f2ce98341d49d0911bb3e4bef27912dd1c9fc418e02d94fe346314a5e2b277efe30e98381e22cce74d58098dfec3758c6aee1ba5610ccecd828f9f1aef613394dd10f822aa1a1d248bb7a9f1682ff83d39870cd82e7d4741df9bcd251447c20ee37e49fca8af1c7175904e24cf5f56ccd2080d7df8550095213a91416aa193b24bbac18bdbaf0c538bc74fb8a281bbf18cb8cb4a2d0a996c7112e6b8a30aac00873aa64bc414012e2563ae7e1340214d49c99c9ee5bde80c46f8de41c12c64c772c2011c1820ec344f95cd3cd0984bea5825a4fafbf5fc7e7770f341dc8e811b6ba178302796fc5026e3e874f25eee905d5a7abc6a7301d6c493592dc0a0487576c39c9764cadd9944a3cebd8a6baa911edc7c815efffdfba770a570d6e6180489ef0a4eb0f075421e68ea1c08acc4a969a1d5155b85caf2890d6b19b2d06554e83234cec51b75940106c55b94dd81153f84f027775f07a43b067ffe66e60c2113f914cb5965fff21a20378daf4025324f1143d8aca5f67e035213b7386fab0a02eb8afe99392709f7874137ec33cc50f173ea158ad4654a455776c42e3683908d859222e919a3d78e9abb03e4a65445ed0ed6418bee1b92302d6f6ffdc38e69fa9b9bfc74957d65393fb9fe1d3d788a55d475fe68a75da02b4d10d1c1595273338012759f28065e8479fc8d826f2f71882efdcbae5154802f1ba3710c544ed9011747d8715896e9e4e9c6416eb49ef368500a0de7e983cd0e18d8d41adad9f7fb8ba24d6e7fabe803bb005cfb67bc4e45130ae586715640cfd63c9007fc8e0ae61f0cd91841f5fdd4ade37bb84bf9e8be57a0adf4ec6850a1c151cb8373d3aab8f349c5aa5efd492be687c7fd06ce362e7e98d492dd315020c2fa164d1eb2b4fc539ec2226b1c32e3fca3b04991433a8b5c2a2cffdca7a0146bac81c4511b6b8f835890037874f512cf9aa44ff925fe9c741ac8d0bb2fbe5f2029f106f6fe2edaa7023ed406499ba872acaafcd1badf1e10cfd5a5be6cfabb47952ae7f98e7dc0cfdc89b88748b6766f7607c104d8511e9d1d084a90b16905dd0ae2a1b7aeac0d2c3e9c8721ac8fd0c1e51c593da7a69b1a1fa2c5859d9eb0a526e2c833d8fb6aa5289c7c9b6a0691688da2aef8dc4b39a569e45d6477fe646c1d0156c5be27d946334e59db03069e6486e8578e365bf125b911249e02e001e00456a179c4f95a962d36cadf61fc8a65ffe0794ac0b6ca81750e1bfe2b5477f914577338443807a0530602b72ab709f3387d8cb5e03c71690802a0ceb5e21581834ce409f4369cbac6cf4f18ed243c63811a757d66276d73932e49f3c0b3b6f5ede7bc03b968c6da5628df62469981b0038566ed4da4f842d7682e2cbd38a9c54d057f837a8bdbb623277b2864f5cb58b6f1e2ff920020ae680a8cce400073e11f7b9ef2add515c746ede35bad459ad879a67ef1f98d42ab49274606f4b0fc511714d5231cbfa4d1443f7ef31e97d963f6cc346c09d708473e36a6702d6db096e05c46f2215046505502afd6dc9a1833c0b834b8550d04185e1be6a683ad5e3aad9160fe9e54c1f1bd0e07b924acffc5ef53e90d12c763d5b1aacfeca24dabde71b96606b2ecb5f30e745cfc24f2b3d5eb5c41c2ecc67e69d7f4782e5368ca1ba3a0af79f7bd470cb65ee5044f405202bda0b5088f567437d5b1101c9f384d767576e10979cdf037667e92cc53d70d84c8b131179a032e0eb470fdd6418b4f40f69c838a5499fd999c830ea751d7a54085f73cdb13307276007a3b0b8c5f7f0ab1791c12d2d81360c9a71e35eb2072e22ef7ed5ea8e1453cceb72df6af794eb3319a17254ae9440a96a0ab8bdb7f13216a1d8d7d74f4c533a273ee9d5bd8e2423681d2c859b1c96283bb30ad60f59eb2bc186eb9609d020cbd5d172263a0a19d6d1cdc275e6b77ad314971fba31080aa0cd8ba7e82ad80b5dce1dc6f0ecc18668a98337786efcf5cc9a42d958f170254bccf0edb46f5055077dedf42cefb9dd285f70dfa49c16c0397391539e3ecd06c9ce410a15959b6efd80d0055af098b77226b2e6995c9a7a51f3bc3a0fb439130f26c4ce781ac26234f5ffc392da0a5b0d31fef12fdda35789923002b6fba7f7641e796e2b7322825a3aa69af8ac72540a397529857ce67133ae11f4127bdabd1cf744d0e272b4759f546efc3029589f1c53971ff1f949798e0eb8e17ce36026440440e203911e63a749e6a2c9926718983f7c8bffb98cc6626428efc828502557f51e572caac15a161ed8ec45e6b7c1a50943de3a2346b95371ee110e04858a87751cf53ba353b346e36af884525045df639b2588452918531d35d0a5054e0e88a4054940fcdb099e6d0a575b5b48677481314e3a2c686e362f6477d674a8e4762187ba188fa1fc8a1543b585cb7a2fb10cd041334f62c08e8c3c66c3cc15616ef6f2c988f18095a82b9f09966bd633c592c3aea96c889ccf7a2896766f6d290edee72541876a9bc73f4e7451303a5a3a4e3548920d35060c3165a2c34b2b9c585ccee1648cb976f3ea0e8ed48f496ff394fba1dcdd05e820ac176228bf63982be8f4945270fed21657f5393e165d5f90102408ec6508823c5cc4d9e45c5d1a4906a8748d7b62fe31d6f19f31fd7fc63edc046bd0556d01581c7d51744efc2edbf9eaa1afd7a61dba8f3b760590cae1caebb0539e9eece0da6d53e1ef58c93c9551f9cd8d7a7167873e7ea66cc3236fad26f05f3f9ae3080f0eb2c1dc3a6d2db2b94a81397093197db5c75507234d99339728e73e5b6c6d63cd63f6ee697d7d346ea7a457d98360f0b78714a78ec1e02eebc99eb45a1f45043c65f8192e5893e6a5d2828c94b348105ee7b97ea3d3d005154babdbe86f77bd810db5fcc2759f2460ec16e990f41345322f0956f49c5d536d5b031f3ce757daf0663b0497972d23b9a52407ca1045e26adc5198cf79c63abc1acd086155cb2614ca42ad97140b7187a62a49fd2019592a2ea2b0eb2cba3c591c4a3d88d17946adb948fb0f52d0b6f0ca2f21ab804b77e6686157f333c39f2ed701cac009105702ab0ea53f09bea2b867d5298ea6244537095cbfc4bb3de26657c0d1c48f2760c4c66e717f88cee31a6df4fb8f95c1ba749a6164f3018d4558ef0c3e109d8409916c00a1a3a615b8851c71e2ea57b21c9aed3efc724ff638509e6a6ee50b6b460eaf27c6df5cf897758f68a4ef3e8238194c4587a4db073f895429b0c4fb03bd8f253b59f7fd7339e3f4cd97acb89b9e956df3da5ca4b8d961bffe51d998657f5b1a84b957c4ae14d6537272a1c8a51607bb68facd8b16b0c48e84d88e2f5effae4bc1490756672d7c6abfed3c1cdf7fe25e7766c7122b652fea4300dfd42b3dd61d32c1360c4a8a28272cd9e0b21308b8cab1b10c4c97e3804ba85fb19a4c3ddde146bb3e41459f080e56415fd562de015c66c05a5640e6737fd73e023688992528144405bb8935d6d08427f5825fb8729846df6f084053ab3be2084c1bc8cddfedccfafb04fb5052bf1e1cbb803df8f11e743d37a6ed5b5b9a01d41d79f893cd3cca640afb48653510ffe525cbfee8cd923895123603d2e8a3276251158246557c33a0c92dc993bc18346cb50a70797a3707cd132f0155c8582fa7d17e79f1f9541d2ee6e656f870e2bdc36c7d1217dbf431476717d56cdb743bd62f32e07a1548fd434e5eaad37f2b684f3ea6b700f20ea87078d097f88fde96150e51b845b4056a34084cdfb0b522acf60b7e94b36722e2d3a9592d435b5065459342c648def4b52b9f61b27bd54ad35ae30fd7a184ded993df8feab2f9c79637b40fec9eb63a51aea3804313e4d543b3cb5168e4ca31a28eb00e1a76f3d30a78a8a29c19ba13413eff7cc3f8bf377169cad7c066fa37050a941b6a29d4c8567577ce3fc55792799fa15d7a9f60736bedc92386153213a6789302e0dbd5a03a68e4b712c9c586f8b27175f5464e74384cc4c167e3c9bea6b0c1b0c777cd23a1b4818d7fa340df898b5651c5060038b7d2991ccbcfd9452de83788c4d4d5eaafb2209e269b9d224cdfc146ae921f49dcc062ff7750cf5234ea11539151ff65ca23ce8919a9258f01901e3cf98f12bb1d1e745f87ec1f4f2a8e11e7f64f406c10e2dfe1e0fd554ca296c22998a6e2e2c32dc95adc982115557e3e878d0f6c2ea29d6bf3f6401fd0ad5d993847f0db348a49c5fd4eab3f7948cdf54f2591d01be93afe816447718a1c145e38b9ed5134393c4ac250a2e8f611cf296968aa6022a7b91bd36d813bf33255a0bd7bd6ec7dde0a1edfb71d0aeff4a7a5c544ed6d2944d7b64dd7f74ccd9a549e3e30c19650e517b85f7f88275b981e3cbfbe48ba2412a749548f454f6f46d8dc99eb8d16b7093fdb85ecbb054eda04618f7ad8c360739c8be468119a041326153cdd32c17cd4c160448b46dc9b7c11bad19122ea3f30b2fef5431566e371bd973f54119470822bfcc5a80c55a79f6619eb11fe60ce7b92fddafb7a603d9e9ab8689bc63f737b030e849ae4c27bbc19872b115778c57f4bdfad3dcc315930bbc0387b58ae0ac4c5c07ca160bf33cb576a87a14b4eb2d92c4678fcdd589c5c2b5be8cd3dbc83abb0eaa0f3080367ca87eb49ef8dd5823237caeb50a0a4f29a1a4493107be64d370d15ae53bd47845ebf54be1d755b85431d64df9449f93b73f962dc33a937888313f6e1d2661c9bdde0f7db54839dec3fdf15e85deb82579b971fe9f8ee624f0bcc52f2f671c2b603eca18887ab3251fe1794390f9f132f00e47cc787cc77a5b8293a26cf1bf10eec22130e36b8c4bd0c8268f69eb71bcc5caab026ce0514b9b2d69058e09ba503d35726106ecabb7392c6ad33b3814dbcf1e5858c98a2eb74239eca97b2cce656fb949d6a9620332bb6f7a53427653f2de4b4c5eb6860d4cf06efec1dd513cdf32f3abcf3d301094b5df5b219200fc07d308b42591ee30ca4ef37f8530a89abe38e70a40ca47149ba5a6ebd598e8ddc1281d56654a9c8aee8cb7f108e9fb4ef968319f123d046137c2be03b0b041f48d073b9812cee56002df0ac6d0a7449e1a958d9b7063cf8150198886f4a626cccf577608b5a079aee0502e1a53cce489bbb0f9f45ba00a0fa4a7dbdc7ce3daff6a4dc5f4bfea795cb118e9dd04cf094d85aae8aad22c194382d92ce24912a8ba8b60ff84b5be3f6047ba92fb74a5328ca33635e3ba82a12be99a9bd71923effa51732bc81967215d9c74b7d7bf41d3fed9215e2b2247389842c487aa561331ab52bd5d17ccdbdcc3e3d102735fda6c02b52c50308154ab8497753a98d097092ff502ef12cfdba5a0a44e0905171b78d7c783bdf6ac4089759b3f192fb882e918e62fd7161a4b8c1788fde3b8a7a55b889c9ff60235853e60e49e8189e74bba5ea1929b36720f91530a00af480779ff1a67a50461a8e84be80a3e4abd61299c36e93070700897abbd1eead801a935ae0874c879a6510a4d26dc72eba441a4db470cfa03b26c5286ed7565664980ff5bb2b304ae083dc56d9e5655dc9fb09ffcfba5930d722a55a4a518725d152b73d2527773d0fdf9ced6872c507f98417012626044e7b8548e18891a4b179c3b3315b49491df240d05ffc9826c5d8f2deaa1e72c244c0c3e2435151031e47f61f9804cc4ef852015513de7dadf795bbdf0f2ae2cd77f287632db76ddb63d0100f26ae2ea9bba3fef56f173f3867ac66eb65e3428c46e9503fe7e9fdff67945db891711728c173f50d593d9440933e8dd509c96aaf542d660cfadf61ef9d9898aea93e4bb238c6cebdb569adb7d903d782935e075ddc3efc73aa9b04f2bc33024bd8d37112a7567e8965111ab58195a39043ff573618b702d0c5cd00dde32054972b20e8738f838fa983335a229c188c6b9da690823079a3b96a4a7b89745e00f8a31f4b96e49ffb4bd5f62e1b965badfff590576238debc7729766ddcd270a51a6cf1322b3bcf118a52258757b81069129950739f6153c19930a974940638f858889f41f43038b9c4a402e44e590d9cc036c17deac225cd0f936243162119a56b22c8552160117b326f11e9edd2868239d0d6341a696c5b78b9ac2f4021083a5728529e3d299280345e1f967b799bc734bd94c82e57b8d6949696918fa56481937a6fe69fadb62765a28a35c78e4ecebd4eafaef5eadbb939f84d0f974ff4883b3a85baf2d98b36dd4cea6cfad6ffe6a423e6810b73bc9adee68f4f9078d1918c00f1eb568e06309aa8ef039f3d4981557b738032ad26104e620149e8c729c575039a48c1d6c6d96ec203bf093704187287c64a07331793918846b18aafc15eaea087600b6486c208a7d81760ac8f00ba473eff6012180dccbacb41e9b68312e86e8855bde65fcd25b348c82dce66056067c3391548b17208d4871bd11651fb30e00f3fe17686112cb87274df0db124750c525c99e863d8a3f42bf2109268b953ed5f8bc97006ced42772da5ea630d1ddfdb07b1091cf18ac923ff3286967c1c7b16e9cf3a28916ea7b6b023a10f6ab9435aa79b49b2877694d3aeb458ddcd03f0cb207c5402091cf8a25578278eb14c6f378a3768280a78a4a1a3068966184d7541549c4e5070834e7a3e24bd60b44c908e957a68636431575cb31ebe46dcf35f71f80337b4775286bbb864dadfcf568e757185ba4c7a32bc234ffffcd805b00e085af3312a60d3f4d2cf405657dc39e0a6c945a23baa018511b47655b680f8ebf995b7023a0e0fc08d847cb408c8de3c680f2c87a0250d86fbcfca2afb9ee21a8472641f1890b4ba5284bb6883346f1e8738f051717801ecf5d10fda9d805a5346f26dbc14dd1126aa1cc070ee303d094746a7a5ac7fefe95ece06ffbece4cc68cef0b3a82985307d91880bc6a98a9361ac7607fec517d74860ce8ba8c6c87e4e014372ae9cb918b6d723978395beb9585788a6d22ffcf71e8977189309d3b755960066488eefe199f40e590b84c984e406dfc5332267a519e5f6462963da18b8069e5ee7de76ba7c6dbd221960fa941fe6911bcde78d7b67bb0c7eff215258122ed15095d1cd25ca2e872999026f109c5ae071df0d43d892adc900829812b93572408331e43aa3bec38257435c45766698db9e4a0ac032722c9939753e495817b8f0050ab24fb79c89c8f519587188adade2dc1f577596163ab74d115d1690cb8203f0cb26e6e279df019bdcac02d9aa6fa5ccc884975558b1573d134ead33de79a9ab582cf1f7e4507b9ecb6f8707ab861849e8828eb6257f4d54b80f5706d5ac501017a32d893dc0b08d89954f59875e70e2aee67f6316acd5160d7c6efacea721cfd89755b6ec164990ccece317fc29d49efd2e06bbe05929a60972cb7d9b075d7fad6bf462c4e50a61ea9c34c3ded9bdc7c93625b1ceeb3322b0db904ecae3e40a28b05df94cda5224dae9b87418d5cad7a0d73dad5386f21a231ed2e07da70d54ef2af39918fd63f2f3e9f4c358d39a9823eec18e977813eb88f30de0f0b32994d384a39aaa5e77e2497ff360c465b24ed1a1bae870c49d9c02e69f5b55269a032eec2f4dbec5c661c2f327d4da1ca4b74bfc24a0b1d0ce2e404f041e085065e2f36cd8d7c705845eb6807a136f8e01d79111464a8fc826b9b4104d6ed34934dbd470ba5af2552e8d4934bb4d652312e6d19b8e607a3a07c4ff42d2cb62c961215d0105ce27f84a7a5ac7ca8e6ce1625ebb6133ecf14dde8258761c66ccc3944e9f2d7becc8dd07d00511f6b85efd83a2c1975773d21ccbe212e123d497a5ef6b5cfda84da2cff5cbfbb1141258c8a7f37b1840ed2db6299726ccbb9b185a47d8bf114c89ebfa651d16f0e7ac5ac48bc2b80c7f502b57190e18007bf48485d74957aa2f3269f9f66f47a24348856f377ef8feffa358547b2e542739b937e521679bf80b60459398203cf1517f2b96bcd30c2d0e748386e74b27f04b841d1e5a0e4cc37844f7a8fab3f393a4ae5a63e0ac10a1324db5740eb715726fcff4ee9f3d01fd1aacf00507b6d7a38507ca4977c4eca872575aeb198287df9b9bc93396bde4a63a4ce17fc46ec89d94a3a50559b14c3ec6fa2b951b1f817214262d295e1240e424e86e1d024ba6debd18dbf705da19658d9e79b16d1df5e97c944f82f30800eae2014999712adc107e15886c89f481f4f927754d7297e7f96c01201dcccecc28b9e4335a2bcd29ba9e28871c0fc6ca73cbbac09fb6e5cc5a7989f19e4cc0068c430394c838900c60fd7eca9b80a83d2f6beaf4b79e8d8e2ba82f3f705155700f53fa8b7ec5ed0fcb63ab906f0e973b4fccc3638156f79c5c12b468fa5377335e695ffdfe76f169d29f5071f67f83c7b3e1e5093e76521f643047021765bc6d04a5008fa303aa81efeca58dfd2a4b4601f5922eaf471947cc6279d7ba8076f46ed2c536b24bfdfab0620f1cb5657c2807c8570e04ef2be6fa3c2b280dc66760f1fc67044e11947a022b31b30939a5e9e656f92e4eda38bc7048c88708b1834370436edf73b02ef9d861b664b0aa6e87f2913897444b72e14e7bdb2175c6bd78fc9b0cec46a65d49cf1fff3237e43ca85c7152b08d7f64d97fdecd5cf4616f625f3d059c5b45add92b525ae6b39f775ba29987283d6d008d1f4a254762b759841968ac65636d92d79c0346d1b479bb38edb19dc5959bf7691899fd35113894db1161126efeaa342c45017f51f50e5ba62f63785a8c4556c8c73215600f494de56921f3d9851f9086b8a61dafac70f5743b4f78d2bcfccb46d37ca6a1f0895ec36c204c50a113599b39d8b3ff03c304e5c095e50f3130409afc1ca39996412b9ba711fc8dbae54e46aaee1b13d4bc419ff813541b4530e5d1446cda903bb30e96201076cbeedcd452f1bbcc240a54c92f73f5285982cda9403ad6a310cb6a9d698028b70eb778f65ff22da50467b0197b09aa387a29ed26e615a86b7975f47b120a25d2307f3be518fea291d81d3cf45aa5d46793b0f8e481b38c754b61ea4d892464c924265d14eefbb1b62f4b0ea4b047afa9b808e65c5d03974ae10f25f927b6ee5da4defabcd73968a2388ce8c99e36fd989c3f093344623a7c5b96241cf064475c2bdaf3b808b50488d5878bce33ff2219ac16eab18b196a64d9689572000e69669d56842254fd45d40c026eef361186fcf193976d66630f6805157485c14bd18ff47f0ff806e38e69a0947c4ff363ca659f1c918ef579e0ea9da5f2d48c3ddeb4908a8b9e28486fb789ecbd24b1d5bece9091b983cf5430d698292d0c1795de1f7a34f0544e8dcd3658319b06315a08a19b1763d68ea55a3a99132046346ca9d850e938309a5feb0853ecad4ea45a941eedddc5987467ec22ce4bfce983ea8ab483fa4c8953bfbb5682ae7a795090167ca4eb512242b6392a74da34bf860406576833bd625a348adf3525c3485284e1af55a3cdd7491fe64432ca53e357f74ed48d99475d1346af76459a0030b9782b6668a0170b348b70f85570889bcfb4cf986b1f2174592e5b6e98088ee6cc5be1676276ed94b21a31812d13ccf3e3343e853bfcfee3f1085628c4eeab58e62f905a2305beb75768ea2143fdc95e1231af9c6c4693df2cee0526480115d24a51927e9b10e309f0ffdb5bb5648790ed8aa213b3e82b6eb09485bebb9932d184abe79cbd148d3dd8196c33a11877f9d7c16ffb36b7d185d291aaa748e9b5c1db85f5638689a883d738c8e46457afef2969ff5227149cc24e436f89864a952521075cdec14e3a521a2dba0c6586cc1d8fa406e47b59c849a8aea38d0a9aab10c4e189eadc12bf19a3d1a4174d16cc1a1620190a29292e7e55ae6b10c5ca74796aa4b6bbe38a420980ff755c149689c7c9add5307444aed48f83e7a456aff849b653dccf158413221ed69302a4688f4b994cc639d32f53fb8a47f640c2","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
