<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"3eff741cfebc38ef616ec5e6580488d038965acc9a345db325637839cefba664df609fa434715430d53fcd82ec1aa9946a74a90554e77eb8e26441ed54cae59064c8db31bb3f3098e7af2e1bbfed82ba2af880dcc273b3a42c63f81f228e99635387fb712b1e1f85f86b3eb17f1d0398c980cd6f59adc2a92de3a650e9a4b3cb583d18919d2aff7bf5325a9c2596411c4bc58256296cfbaecafd92cd5a9493675e4ca251eeca31dc0a5e8eca51c6eb3619ed64c1ab8ce4cb73d3608f6bdb2865eff3ae692340c66067a17bbfed254a9db82ca8d82ebfd5121f5e711493d2030e28cb314e14a4895357e20787acf2eea4f4e3a9241e00c298acce1979e94a8314f024ed604e1f285979ce22c29786a657abf0a85f4d0836f1eb573894b0239ecb634ba0e4c81199ac380fd22f724e5b7934134a1d031b266d4989461429349dcb5bdf50603c3ac93a6ca856fa7894d8815a7fe19332127a957d2cf0a3190b5566a3f43d5987982bb2dcc1bfcbad4415c8bed7c766424c18b8e5f3859e2fa18543678a12f254fe1431c986622421ed7ad3015a9941ad465cdabf0bd55551fdeb1db4bf0ca00693071e835362c0df036c7e05058b140dcb7aeca9c41aa901fcae70ab8a3f763d710381cceaa2fee69e75167241b5363aab660afcd8940577c7653f83872fdfdefb333131ba555234cf50909f230cdd619090c8c651b60cda18dc09a2132d72a156e3c4a574f44e5882b68b33fd041d1b2ddbe3018b4c4b9bcf666706845f947f257d3ef958bea115ba0d2a8b20f1a4423c1eb5c1c559e9ad56f700aa3b7a729c62dcb9c44e82c28450700aeb5a15229683f3f8cc07c0657c69d19176fe9829b64435bf4b6db831619a8a2d8dd8af28b396501671cc5480e4a73aa02327fadf514a6ca5b98a5e7578aa0f5f2f5942bb91ce9944a035c52dc544c147f5cff3b2a4888826878d451ab9df384e869bf6d454d9530157a81efe88153ed80ad2eab3bfe62db36143512270158e05e87f8060213735ecd3a62c0bc03fe5a34cb1004c7d015d8b56a84898c088eb5d539d6fdee938567e970eda5b5553ceb9664279ac6e1c92f8e805060c30e161175e134a105aa77d212cefaee8d4c61a160180c78e24a95447ef6731383f1816d8b8ed840e6db38517327fab6906be98d87c1e4e583ac35f627fa7bedc16a1f2110752ae97784fb60cdc9f6d241037ae68fbd9f20de58b47649a7dd455dd1f6bae51156acf6bc09eb55914ee847bcc56b05b2cff289873758f5844a68e1010116a8fd6fbfac157b8cd2940fd9b2a0de9632fd31bac73753447baa5558db6e9d41a36a4ebd9ff8f2d4b972d0e5846907c3735627737d7695a1829330d0381813807a4f132698cf125778e80452603012dc162c8439142f47f14ddad87197bbb6d1886e8efeced6808ae494619a9fa82d0a995284046cdc55c7f4f30256094c666cd37055da102d868016db9209f03236b4cbcbd9da9ac8313714d37f87c266dfe3cf0c64494cc866126d29125cfb907a9081c2ae75316c0112d2f239d5a95cbf0e9129ead69a7ec250b4cdf83a470fbed4cda10ed9e909d07a6fc7ec4dca285fa20605cd955f297bbdc3bc2828132a0b6f60bb5e062569c62b34080febc2d5994ac3d8473a50ec01a95cf7ae2a0c6ea1dd798adf4837e7594b13506ce63bd5d9350ed7cc3ffdbaad3e0bef8ce80733af5da54442a9592fa3d73adb6761971e12b0c103a48462f4b41dd74ce0f373c4d1e1b19e52c656058fe86ede4a4dc2386ec9752e932a294f6ecb39cad3b5c3d7e62402c0098395333bf84c965e805f9ca12058536cd177d2808301b22fc5d8a84ba3e26b4139b65ee297134433380885ead596a0ce967af2a83114984b21a5f2f54fc2beeae6dc9a00bdbd5644ed4f9a17324730717fea7f6986265bbf917ccaad5acfa794a261fb4b6b84bb5ae491b5ef3400a0373e14ff02d78538897879eaf10a404d24503924cc00e89e7ec2376aef20dceefdf9f74f39683619590cb8da571681334ad550f6b0fe583b1b923666db7138dd57f2511cd28165c0fa8d71e4eb2cb63f1f23392a15bbc235924dbf2d4daa93182676b9aa091478899df0b613be637ff7ee89d9d7479df6f67483e70df082b5311e7bd0e2fc4c98b1b71edb6bd660a8cb6238cb73fd04b125f9ff7022944e116bc0107ce7605e84f3c7a87525a0d1bf365841ac0d00bf95a1e63064730df06b3d3672040644d6b0bd18f8e2d0c821e614387b980eb9875135fc1adbdd3ab8dbd9d82ce40d49e2a6737f671c1c50353ca18fa037c9c0860d924a89be4f5b05164aae5a0642ea458b584b75728beaf9cb83e60ad10249c8565c4d11cb62749eb94c12ec366a2692d5cd5aaccbec27abec7b53aa0b6e44d590cd3e788bfc35444ea9186170f8a85e94b664840dce5b2abb3e6c8074ee8b3fb0ea09dbcd60ab17c5cccf38b821a2d9454db0741860c448e99591e9acabb59e7edf33ea3fa80909f76f3fa53dca9618c40e4503a22648dccedd29a46b02a408acde9d4b5ce0f2ea520dd171cb88388e6a65ba3855aa88633b0e2bb98e438092ec64a64c70b3195f24e9af311668f5b4b4361fcc6ef1cca2f7b711b598dff39c422d57d4078f81dd5786255d44518bd6412fa539eaa70da97b8f2ce1e046fd22dcf5db0dc3440df5ad102a8b8e94f9d2eede301c657e2c8e9fc2f349086d39acd5217f698b88c677886fc2d1f0cb383d7dd675d9f39eabf0ad16f336d02d4459944a101886692a95b55a8a3db1519eb0ff887b43d825969a115a4a0be47a1509ab45baa4897f4b2549f00a8f3e31bed4c79e27d3ab90f5a98dcaca8c2169c6991dd79edb3e0504f303241870cdc226d44120d8b3aa466c0b1e694f60c466ae0bc00db78a96a7072ac9965a13c0cd206e2fc397088ca284e44ff10152a87d730949ce8818be68238bdc55b51440db6cf3388b1f64194d4f908c81a1b632142c5f2e37c5779ad1ead8cb04fb56c619d231569958b11844a341a8f9a5c743dba725e34e4182a7405b80b320d0b6a3647c4378a0584cec8d522c37a3afcccca2d7a8eccec86acbc7760aabf9578f7b98d135f69b4cdee1056f84d9e9b19e7eb4b931ff47a492dc945214da33cc79e19ee015bb4ec4374250773eec0ac666f9e2de2e12fa2dd8f4a235081e7850b378848f20bbd7c9e680072528667385f8374020f4c20f0d7c7175ce0f36e7e1b0ef3d5bea802bc2dcc0bfa766240f3ab8fb4b61a5e4c03f1dd5b59a186aa9cb32c0578571e6539c3be616e4f5419eba2981b060335d700a702c1cfcedbef203deeee47c4164517a8c40dd76867df8bc7898872814e0a5d10ddfef15611779d9f3ec1da36420b7565ade9b7c7ed31904384e5bbde50c35dde946040ae97b8c33695bad5a033dae3f336e3e9b9103bc323c8d611a0d8f9f9560ba401077c9ec71e3cd7a53c200d4b544a56563a969bfc47a0a48ceca51c0714b4385951a6befd60a133e924140e745f20fddb8fd4311b5f3f7fd200bbbb373d7226e57f2aef8bd9ea855cae4c2f6a7bbd6665ae0972b9998ff5b91f638d9ada4317fcf66fd3065bd8cbca49308d14f362d4b912feb0ce5472593f60add57a0095d8c705e895008673a45c834aab83e70d419860caa6ae14f65bebc9af8ab5ac628eff3e648e04bc4afe7f745adbef31666e6f80d8ced7fe1f4db0be8c606150941ed56fe62b437aa9220e00454fb887b43fc0244b39cc4131e1064b955a6bde30f4457158f8eab3c5194debb3c4c4d8cb6182ee0f4ccf5393af20522e1fbf47dc45ef95adef2e0dcfdce3dc6b56a82946d5a0a6aca9ecf2ed899d330b14b55b44d4f090ef6ffdb2055cf3311f29d132986646422bbd4ff1077aece4178628e059966765cf08a6bb779701ec322fe41c461820e2f2c39417c4bb82b01fb9ec14c4feda15f9d1752d4758477253f0759b34fdac0b3b4fcec6eed8438709f2c4b36f8b8c3f304d77cbfb88bd21d6648d7aa814eb0041488fb9604b8ab6603e2be8067d45d4c68bd6b0a62ec4dbdcbf5efd4e015e347c8657c9b07ca58baaa4275e67f02d9b139b562ab489edd2623a258a5c9f88cd6a422c9282e170a212e80a9cab293f43dd94ae0899bbebee7e335c322f35fd91467024388de65b4adda6a1dfe11114f875e83474e09efb0468be29dfc38e53c05d973ad8aebd21e484e403f0f311d089e94686bd1326ec42fdcee84c1430197ce6f92b47a133a61fc52bd753a086f450dc94d0c4e6db7996f00b5d542cf40d70082066004f1f6b98576853fd9375b246a4ce19fb1a7d2ea46de2f05e150c6a559a6803ab5d5c0bd89480b9ed09b18ba8ffff217e3ca317c30a11d6371aa48577419aec6100cf684e49dce0fb29a694a8679542be7dd9236345c6056d71fd376858a884cb5cbd3b84618d583e5ab2f26efe927df899a22ca18e8a40012c4a62301ab28f5a879dbc6dae38d461503cdb53945d2878fee0c80b8df4bb49aa8c50dd7f0b8f53734c6519d8bc8da6d694f5eb534461a21dcaa9ac3308b2e05c5e0850fb9706fcd4060042f65784c40073f167842f15c1e7d3dc19fa0ff6621b59286e3236f6a7393c176e808ee2dd6660ae3c529a94c5566b50e96e46acef2e9f136ba6717b31d4af876f1d333b4f385762c0709875e440f93954454dfccd374dc004bbbf3094a307ca0765c04de88bfb572bd12c4bcb6820675963ec6f25ab1110808d5300af23ea5504504d6a50e17ed553022fb34d4143bb61ef0ed51367a908a5fb23f6cad3ee5c6a2499aa950728c6cd97de9330ca9dc115a56658cce419576e213ed2f6b64aae14b330f052d79017b84db370bda4c49b9737e82fbd67864b270bdb3149f55e466a3ee2ad8553eb7fa6cc6244a89e20aad2da290f55b08f0fde1e78975b5e53d16204e7ae74f3bd591ad55c1f5872e4d79e37566ecbebe8da90cc1586154dec99202a64cfde07dbc78efe6977e98f057dc6168f177f15daad7ef38caadc211319822aab2a748e73a212b03c90601f7cd0ac7980324a03841b285938583d807f70bd49f5a70378fe2e65430e64401a37b780c70d4ea531258493fd2b7a643c04851d335644f509861ed30cab996c79b983a2cfc2839b8e73ea1772707e6c812f7ec38b37933210dc7d8d8a4e94486b3488f51e3cab61d89defd6ac9240aeebc824f1e81d6d3e84c235bf9563e92715b175aafc3aab1e482f09f74c592476d66aff2150a6d48d03cb154873af2cfcf6d9c4127b09c4a2fd7f1d9f46680fb57855fa697f714b7c30f669e8b5a0d04c4e9ff9fde9ff59f2841e44b580519e1fe0873352f108d16dc5372de31be413465612bb99e825a13272460fb40d45935f6c33cebb97a3b5937b31f2826b4ad0381b31df165f255550abb3424f7badf7def07f169d34ee87540e678f3b1c04bc22f0c58b32e86dd2082df7b9c8c610a1238eabc7cf47503905d4544f60e96b2c768234d774f2c6062757c260faecd355db30ed044551561c22e0e04e965e65dac5807484af67a7bb5c099d9decb90cbb41d2c0cf627c5fd28a39264bfe0a3bd86a4b4b4014d1aa41fefb794ce1528849ad1a737e85459947bec15e0e1fec269f459863451c35410e24e3e407bf94d2c5c4236a621f487692de3e5f2aad6a46736ad9ab6f90db2c5e87fb4898dfae454d45e4f5f1d768dad00bb34258f5a5c19d921325245b3e56887c9b2fe367b728aa42426797ba3726ab03090edd80da66b7fc40c7a98c5091cf5b180fa0c6a58c218e4fd9a3a00fec160b0e6229dc1e6aa82c812a721022af5d843de5f0dacb5d07e9d9c4c71e9aff479e43b34586a09eec519535b4a4483cff32990ede824eb80d5f125c4a1bcf419f729cdd2981a576532bb3ccdbadeac0e308b2be59327a5b206058d51ea7e02a94260475801aee0521bc287f6c52c0d4390ea705408c98857f8557a66cdcf2608025631004933676a7a29b39dec919715a80b55466b71ef2b4ce3add9480d1b50476933c20cd420416cedc22cc07919b276062d300b439351c16e65c711e9e0711d774fb748fe30dce5d55fbc4c662754e92e5b5f71b81d2b02030e9f9c74ed40157b1f40c015f1e3f2b355451ce71222a380e974015a18199161c8d825152e01c12688d41fe26324d2513f1fa3cfe118b7a9541acb3b4b643c3a0809193bf897af36aa9bb959f92970d84c2978f6edc4b0d9de7d58e6b2c47ab195e02f662f0c07cd25bc42c6a1482219696f4978394f9613a2f1cc9e7ce5a12e8fac961995671985dbbd91e8d765c5220476f593e71ac151d6cf22f8e01d07ac220ef4f9233d6d56a18dd36c01cc5ab47145dbc5af31796f5d6f53e3a4c6f9c4cc1606e0bc55419865b0926400bea30e882b285e48bbe1e89004b848d3be286f2a79978576dc076ba41bf7e4601efe9fc88224c61253a5a0df582df50933a6a771704bf83ab8132f39433e6c56cd0a93eafaa51473d8e335c026cf81dd4f9345b4dbca2ab9e46f8e3d5a50344c61c7c1d8f420d25ff80a42f5d8a56ce219ad63eef831af2446c8e2ee8d51e275ccf2f3ddaa1f55182bf037310835969fb9af9734ead8232fd4a149f4bc98ff1233353b8e0199a3667eeaa0198dea2b073a5eb9f9370205181044c2e877be301539499d159a49770856a5318257386ce642825794136ac2a3638659437f1a5c7256450e5504954d3e00739b9c43caa9e32cd725db3329996a133957e1283eb4c233b3141d54cce32ad6b41183f57c48d045b5331fc1a00102df69e2d0b7f4765f08557ed6e24a24da1047f53a37d438ac1916ddeebeadeb0a18bb01c2b1179b53affb7a0a2051abce7419ca77861faf0f57b6749c80116d92f9014bfd3f029d6f7bc995e6c8621b769408c930e3af4200e3d76f27a3762068d052be4f6c53dbcb6a25e369183e658267142a2af783702736b47175d74e5c53f2aac007a71ddebe90f224a28c104f83d4e8b1b7b14df8478776af11f457be8a67491d9d4ce34281a178e926d2c3011c1eacf0d1e529bd025dbc626e8c29134ce3ec98a98cd4af163a009727d3f42bb7c6ec2062632a8112e4aea622db005e90855b6b3015b90befa66d6db5dbd40b8ef3409c26e21102110d52f8fe12e43fb382a3a98560b4ca74baa7679b1caf058b14bb49a9337fddab05f4e30c1734c2b60256a04c9f73ee6683da4f239e5503b3cac4d5d35221c8a4211bbcd55fb14e76e44bbd798882eae556a44c2101b83b5afc5f67d988390feb1229fc84cc9ce39337562a958687206f2015b9543fa93d1feb33fb04143ece9993a616a67c952466d7a34812a4886365e7afa89524f0141232427da423d4d7a656144784eeef5937f74429aba260939454b85ea15f7f4adf2f3699fc7ce9fa2c42d3f17a1782d6e7f7d9a9ec7f837bc9befd598118ce104e3f6a0ee6828e29e4e3484d0d301d765d5f68b53696a2be02c1e783326db464f06c4a9ff57491e0c45b6ed435b39f1dd30ff6673eb7f149c1150a3a263b2047851b7c7203b171468d7808569ab535b1eb7ff39cc2dfebde87aecfe1289b11b71bceac1c669b38b7e613b5ee5fadfc8d4f02985f3c81b7f9035627078d1b15bbb86c4ccc07bd935823a4b192c5fb94c22232e54a746c169d0b9693030857749352fe992aaf179609fb24c8092ce9c9721a2941fb3bfd6fa405a5ba3423c1b334651c1492daaf43707b9af506d352fea79b26d1eef2bf59b2bd899c719413b1010a16eb11bec6756c11ff028f55a0e0b4689821ba05d4dfc0e6687111e7c0ca4ec864c5b712a86aca0acada25669866ed08fd9dfa9b99aa98f4e61438c46a15c2dd510d6ff73b4e4e4725aedcaaabcf8caa7b49ac6fefe5d8cbb21bff7706123f80291b42429fb4c1adce428ecf675ff3f7616366881c6ce6762488b15955e160c04a46071f43844fe71cb52803f38449342e7955cfe114c70a0d04615a7f5222b23b1385895df1ff5a10960d5183b3434389a24ec2c43f463afedbeacf52bb66b64151576b43324bb1f0df8c9edcdf07b7519901a460969b3f771ba873ca9d55671f074d95b5c4454f578ac07fce36952b5e924000fa7dd3b8af82b24abd62293c087af48b580041c46688b3dc700f7d12cbd24f986410f2937beecd7d256f8466466ce7af4c87b0181819e8e64d4b94469fd5740cd3f209773013e16981043bbaf55911e12eb25921bc2a5c47c5e1a4a56a8bb0f471c66031c4544dc6b254225a5339ceaf67d784c0083c1296c754a13e4d628049ced0602b90093b8f0e1167990f90537a8d45e3dbe66260d95d1bafe0d76f5f0062b03eaaca83b1d3fb9873e464c50da3472451bdcb87dcb8ffbe36bad7fed5504e034bc1565d79eda14e2a8b442554d2ca92257618186f5c1b4e33a728b9036919f8df100c0254ab9f3d3df63d213b8efa892d5969e17dd7f8ae01a9ef2914f640762aff66727285311652e9461752623df08ff36ccd7911b36962641ed9b9dd7bb70ffe2f11d6e1bd7ef091fe2b71763fdc86c85db51795983ad6eedb566fd3a6a586e6eae17701fad25ab892a26be857cd859a9741da2989a0ff5423b69330a36c111fd372d67596cc31f784cb2749e88661dbec735c368329c0929f0fcc0d8cf6c2198a4c833766f632581457b2ffb86340a1cedc55bdf0a2d49ced9ea8ca66771e44f7b0ded4eabfde6b8c79babeb190e14a3750ab72828cf40a67e5e9f2faaa90f410b4f32e51311918dd1f4cf372c01895b6ade3e6bb60e7947e405e0da607ae71eb85c28ca1cfe0530db051347363151c271b8d39d38d51597b480d37ed3f753ce95e320b5f25d825c3207cd790f9ae91746d252d88d3e5886d9016c5bd489f9bb3ff4052658bf1dc7949e73a16aa17b8764ca983e27b4b2261d48b86824214f4e81ca8a1d3f6ff7ef3912f1e70cd1639aa8c366c7ad3f387ac5ed14bd8f7302cbdbcfbd04ecda4d4938ae080e3e7d7e04deb6fbefe82ae0333e982fb6625cb61043f31690569880dde31fb2a68278ec6805d0e808b9bf901dadf6d41b860d21f55ee1bc573cf19a4d486096d44a87ae455189b682391e94206b2280b8453cef63efe3114eb57d77f87b3f46f14fb45b3eafba2066d4bed9d840ea90edbf24b639bc4e319bc4a10314b73376c68cf9f40ab500b3c0a12446dc2b3683c0514ac3b46d16b297a6334cd9e16b34152f94cd432dfb6eceab10aa9740ce2f81f6517c41ed32fbc77f8c390a33f363c30ec08e23020aeb6cd230a75baef4658df54d01c500f824a326e8882d329b7748135f95a5d950580ae67619a00e02138e9d7cc723a23867d58b41882b71f7e060577144aea71aafbbbf32c35554d719a25c14b981dfc5e4b54a3322c6486c0cd3d80a6690dcd3b75770f4be46a7fa9f4bc254f860f34193842467324fdfe8b772ed14d7b0b34977b790749e95648c53347c0f8593d3209b9b8c81b60075508a267455a40cdfb2865ad8182e82addfd23fd28dcb18d8482738b071c55de0509a9dc1d62a6839440b851ed395d3395af865a1e3a2f6e22e1e088c820c5a530671cf492e24741d8eec682dffb55eab65647dbbe1f3275488affb7bb5f6f626f954e312edb8de5b4c3c009e309fd1e16cbd307c889a6d8b631a4d6a09d90e618bff42c651eac67efc5c5c37c600092881dfbebdbb68c170bb6e99fb2c189f061437f0de3597b6e7326a48df32c4ddc2e50800b0216aa594de4cd49fa7b4c42ac8ae2a7466ebc009df6b48af9d09e3a4ec90164a6c1b9860cc52bf1940291427675507cd3974f52c4732753eedb0a472caca61043b894879f456e4ee7d5cdf4ffde978194b43b8dd1546d5d3203ffcc9b0954690baad92b1b19c48903e251950ed94e94567ab868b77ad00443773c6be5cec854aabb3f3a329aa1ba52120ac21d46949f2f8274bf316b6c59f0bfa5a41b92bb672295d8d483ada0c3895cfd1996cd5b54b1cea43a1e9b76410aae057be7afdc15e80bf1b3473f06c316c627ee174131a8b7a16f1fcfcee5874ad247f6ee8fd9eac0f2b90fe05ea2858f71e6e9ff4dfddce4a2fe0409768164a23544e6f1eeaa66a9fc9d20114c5a0197124955fa16d0ec1b7eb47292405bff7a27ca1edf9beeb82ae9f0ac9cf644cb16575258600f25c1c3495e46d10fd6b1d0564698216eeaa9c13cccee16858a6ec78423617e1c5f0dce9f9a14f55d9e6117dfa111541022d8da016471910f285c54bd995e98766d3afe92dd97dfffe5ca8f23128648f56052b3321668457a4249ed0bd5e8c7c0a79766df8f04a4e286d43d096f92e8cf42ed528f31043745501d53c246dfbfaf7d293584499f9c414b9ca48e7661b9a952422ec5e940ec97ea205d24e826495ea3c6ecfb47daaeea5bfbff4d692cf5272c8d1419149cfb6896766a8b6cde207b08c6ca64019db12a1e4a3a1b3d29d71451ff3650f5bd34debca735675f13d59580986c7cdedaec7f34fce7cbcd3f9e55f58c9bebd5d32f1e5202265021751d64989de1c5adc6b85b52d9d10a13761650b9a7a8a234565a714447e943fd28c1b3d4f7f556ede2127526809422703a111581cf2902fb87e802a07af68c48f104902a0f5f8c0bfe21e293ed60b8cb2430dafef10853fd13a9c85a4208c484878841dad0c2bb1ee77affa302e5eb099022c3507a59ffaa86f1e81ae23d7aa8e358a8dcdc13ce356abe5aa9b33e7f60f136a09bfb081141c0dab7d6e09a66cbbc500c5543e2dcbba75f85de3db6e6dc3df0f8162d293649dd0db0d7662b3b873a7d91f1e032c9505572fef265b4c238be7c4a4a67e31fe40f474cecf585b2acf4be1d97b39212bf76882d338c53f1ee510fae5b6296163b865072d7f409d4b6ea7baf413ce7abfa347159c317be8b18a25207f5ddea655d56122bf6b8ff3a309d9ee04dcf81fa7a41cb20d115b13185fa392a528df8c472e293ad9862b283fbd73f20a57b67f64e8adead18a6d6e410ada39857595361e8fc0bc33c82ffd184b8d459567cb7b601f63fe903846de68b2bad0cbb81c5969ff5abe9f0a8bae94889fbdd9c55287573d56344b4da530bfafa5b228e41b5149188b80dc85de1ee78b0b3bdb965b43335cbcc3c9e7db052bc6528a88abd8150aa862947758e224a723a2b280e374bcc56ba9ff2aa43a2ef519ceac7900392925f0e6a29f72b15cf0c544b9feb1289f3db2b4296237f46ca4b6dec9887b13121f3d7536d943bcb24e30de0ef08c8a769755fc747b604b0b7f94ae37260034648f0ea9eb67bfba620c0eaf105db210c1a42630709f6858a77e0f7679c2ed164c658c5c653d2ecbf8090a1f01e955389641b56407e887ed5b0538ad52a0893fa349b2cf79430e797ad8e023d2d44ce08e2aa2a5e62bc3182cc2cfb8077275c7b1164aabfa8ece04c4fd0dd1d41996ef60e93fb2b15ac4ad6fb03f48357d442b524016199640561cc0602d275e358dc124d305615ab8be5ac720d6213ca1cbe7c2b12a55b9dac4b0919c0c99f1d11040f6174d8f3a551a5b518fdd74de6a5aebc0d852107ac321712c6d6b92d9851f2fe1add963e2a0ccf641458de17eeb0d2f070aee07840dd9f8b9212a8cfe99548a4d5c70b146a51a802dee6b338f4a56e093061422ad1e33f6b76c218dbe4bbe62f5e5527539d2b07c116514cb839f607f07dc190612cc4aca1bddba3310e6c178c15b610837feb23eea8f335e8f22d4e094b4685e0bfff27e338abc863d43f40330f1a6f65315938ab63573e7ff1a5791cc4c8a718f1cce92fa30a5dba2716342681f94ad5f1b4a8f1d136cdbf3b215b445205fb3f940f7a02db4cc91806d8435231600239cc91323e6af9c7ffe16d2f81efb237f4a481da5bdac69843bc3a9b37ce0efa660223e2424f1b399666fde6ebb8ed6b33de998d3bea657ed4771a0b7c228d188ec73e7488e19188cdd1d862cd2f5ce07999dab6b359421ec4dbf564b058a6adc53801ca65d7c9b35a2d6f94495e902b3fa84c47b515003dba9102c1496be0439792935d8a92b41472003cd990f00220aa0d60c1d10fa5ee48c1ff3f96f0b1b7b60cfe94edce8e0d1e7a91589663dfa1c6db76063a8e1b91d2b0d9def268731bd25ddd14dbe2c314b862556bc6b50e0dae61d27b80f1b730ebe5c56ff7ac16837f610607549ebdd57770053f6f66dce6a80980bfc69a2c0dc676c6454ca2eb9fdd30e612eab0e37c756052e126515a6eac6c8c7329ac388f685ba24f7756d2f005a9bfdebb643f9e4c47d1df0a17787d295c994da6a0a59eeb6de70522b3ce8393133c023a4b8441aeea92cf96429aad48cbd6adb57fa960e9ce2ba86e66030ac11dfa551c9e9b8b36142a859712068dbb8091ac89ce8acec67f579e2003901d08aa1550654b5cfa822a90e3fb417765b50de5fd9a571170e6be88e280cc2ad5c696bec4e668e4c184388b33ecdb0820f93186b21aa4c7b339b216ec6a4eed3ca998890fbfa6f00f554d07d3344b92086bd5099d5f7dfd219d7d6a64945bf8852bf2203fc932e6f595323d7d14ac51a04170893f275826e2faa40935e5b9b75a9dff796addc41f0e49c3fa36be5d2d38f64f07d8b9ec9438a869225bba59aeac68c7b853f644503be4b104fc8dabe0a6f2a42d0d63aa06d3ce4c1553aece1fb333fc530d33409f81b63cee3c97439ab1d24916871d2c884e4481e5d808df0a5dbd4c7c8c5a8711cf11ae291bde43f5301f15b9074ac91820c701c98d5611eb4fa49f256bb00701d510ce39dccbe937afe854e2788bb001baf68cc77b07ffa3e11326fa8d3d518b96b8c2284f4e87d89250d2675dc4776aeb7c2e9f19f7fe405c8f6a75e6b9d56c28ed2855a977904eff34a9dc9c9f5811da1347f556674370d07ee9d9507c00a6aa3ed3d2fcb22b68b74254f5914ce78a3f2b17ef2ba9dc26f5d18994b917be91498630b62cefa82b61e8e3b72494a44a1a2c160c81c28f9648dcc37bbd1bcfbabf0b59409e9fcd58d8a0f672e438fef6e72291a56f705754b24ab3652bc38ee171419fb99dcfbe46b4aff66507c31000c6838e52d19655d5e84e74027d84e1c12ceda5f2266e094d2bbbf4cd65c2a50473918b7e7bcf63faa1ceb1e9f23f73c86bca87b15eac38fd7c6f793c994ef8da587f730b94fc56b7b2f7928b71a62b6c380a9807301533520fc6168745640ad7c4d687931074de6943b6ef81ae595ed5c57f6dcca0be188f25b9eb43b612ae31a1b2d88a7e04b9bdad9c69e2ac56d20514acd045b5475622f121139e5819676d0eeb37c573f576bcaae3139480560146eae0f5b2ada94bdfab2e761defaf460668a47f3fe37590175a535b413270109af489bcf0aac957a12b294e4d9de5f73b42130d00e3403e93bd9f401e3517867891640b790b50522bf6bb7469f00fd63866487dd7096f6ac7d3d1676f07bd79d72b95288814266d813362cc45998ef516f347ee1778d8b50de8bcd99568b5e13f4edfe1b6bbe6cc84d636e6920ecc38cb372b3427f0cf184d8072e28246378d426d35af9a5dc121e6091e871f2bb9c7fcdbc9becd17465e31af9aefbc641ebfc5cb720f22d5683f4bfc6c59cc643b85bf928819c789dbdaad3b7c71fe96b4ad24a7dc96c7744785165e1b020aa5233095bfbd23cff48d52342b582e2e36597fa1188159ec81e92708ea953e887d2e0e9282269d1dae38cd6e43bce6f9deb451d24eb2ac4ea21075aae4dc4734c12ca79e068c46c829c972745651207bc5bb2b9576594669852a1889ada382d754fa1f91877e5832dc9db1f5b920327645f042060162ae10a27cd07b297a990fe0875f089eb69ce723df066821112e4ce24a5d5bdfe37564b1b5b3d0a767a72cf043abaa6473721334611cdd3b7982c87417acbfc25c87d8ce0ebfbeb33d304992cb5c78402e2c4098deee8cb46c7a65fe97cc63f9c7aa447f563de8239de23a8d1ae9b2018fc45bf1eb7eda43f4e035e40d3a93c0042e0f5d7a8f6807281314a2ba73737f01e5707b94f9d424a9b3cd475dd23abd47c940ec41984ec091d92d7752b0a9c0ba7b3f46144693864494e4af26e1d41f20675c9205d0037cfe1653b29f4044b39932be286319edef7859e2e0b670db3c9d01893bcbb139a3ee5a21e31b533074fbf4ff25934562695b8904fa46ab79393f62599a4fdd59a3944ae06fca58427a07c9b261e165788896dba7aa7769a630d40518ec962a60bc8bdc3502bd1d86d19942e901f9b1617c3f84d5651a060f18431dc76be494a9587d7a40119efaba187e3659330f993e5b69e24c9e17845136ca0fe39206f9c3c59fb539077d264d4bec7c9e5a085ef44dbef1f14f970e886495249a4f20ee9dba55ed352a36ef881c5c2031f16484d283ec91115a6ff0b5152e5986ebfa4fc257e751a031f60b5d4c04ebb73c78e9ce01809628c65424c95be18d38fb5290c80870a56d4226e61a8c16f8945a65fdaef39b9f834b3cb9c1b320a3560c7b35deb7dff362212ca31ea14939dd20cf7b6b048a5a606484c8adfbcf6fe3eaffebccb2a781f14bc5964b7862e8438a1385c4eb3e077cd7cf4c9c598277c3ca22355ebdebbd6014c88b29345fda6d1be3b4608977e17a515ff018427a295c01c2e7b5d25692674baaae1fb1d8e9256bcca46882653dc81c786f95bacfca29294e64e96ad1a12c649408a7197c917b2c2dae9e97ed794f6b7ef3a59e50495c2a8150f107d5402676cf3d71b732a1be4eaf6d60697f1f85c069bf1d73399ecd7e0b894a267a144485b5ff5d676df9d2ef7f1864278a8dfc8356ca0f91300abb549932d406f6d6623ae6e8f9c846961a620e70e09fed642fdc0d50fc7b15c8cc1205ef175055d1ee2c7b933cb06fbc9b8e73dc14bc9110dd4985dac6486a5b95f08278003f6a91ad712090712fe8ec384c41fabc16736c8c37e5f36028f0bfc44ed38675e8aaf7dd9a0eed9b7e0d250af9541ee23da7f5a38f097b597fa08c44efc5040416e8a36bcbf892ccebb0944d74742a3565396e1991239fad4a966eec9a9fdadf8c7a5100f6f65ad4115aba99bb251e6bdb8c3ead555933e695f77c6a76449175664f7c1e131e829918f243a37d75e5714d4c3b4ac60fc959bcdf4ad25fa950943a1c992fda9c3fdb940a16cfdb92157cd6ede6510963c82a1822fae150361191a31b3cffb02f016f682ec133d27b09b13653176550097763b2acc051eb8675a7cb9a61edd6e074afb55ec0af22b430e72dee91375be0f0dae0fa5ce29a3c9d89bef7cdcf9667e4077302124ee8274d8ff26c6e642ef9a41f2a686d8257e4598b9d789a99fdd41a124b65e4893117ad2abc9b1b8d41d9236933b0422bd6f3558fb2c9821bef86f8f2e79290ad616adad62ce7dfb5ae1d34ae14a22f76800f28ae06fa5ab0d4c3c9e6518a37e07cd88b6c99180d82046177582f84d0da2b355936a90dd8da702ad0d1a8af05a75d67363e4e94e9b2495812ea38c817b5102c1b65b1ee306c220fd3c865d60e99d95e1aaf1c1198ee663a70a2cf3cdc5e6b3d719bd17e84d3c93c3474bd40e7a3a12b49b0646c2e4d1d205a3793f021885987b63f17a35ae0340cc66593600c2611712661fc4950b0a047e695f951db74a8df2c24db09723461bf04babc0f388057eacf5c4b4e1768ccb273535cdf39184dc4d1542c2c0d3f9ec14a37df11f8e1b5c69fa058c1cdd8a48e0c6b5387c1656031db81360fd7e19d8a4520c57b2e0004a8f76c5bf2e8b8be5b34dfec05d32f8b241e70314725d4994f662e87c4ca3998adbfcbf2f62e10685b0603236602b192a1c4f9da21d9428d22e02345b26c40b1cacc0ac2d168fec6a623d33f5ea383cab3225dc9fd3a4615ae6abdd82c7be9f3b42a835fb33531f49487f80a26246050d61ab742ca120cc0f4f4af3dbdf2439c7386ded284df07d0379ad21afc908e6fe07729a7b52ba476a2a63780edec5c2f6bbea3aa9b3bb0b3a74dfb2dabe01f82d465340ad6735718b9989e7dde75b6c2a86ee9d3990ccaffa5bd9fb5ef7abad5427e7ba756566f8312eaaa2b57872a3c8f515d1792d3231bf40ead8bbf14af89a7d26e1277fb35f7abe70fda9f55de66a7944e7cd5fd10b33d717fc65a8d72772e8186444fe4919e3d45c2c4f4343218f55ec767b3b5e6bf532f2fa30ec480f62a7578820bcc754d8a1d51848c76bc40275967dd5648a8886aec9d95176fb11474ed9ae3fe2276ec5b45eb400597263982694d0ccba01579425bd7cffb08951f56e00a94e24ef7fc4d574026e583dee2e451d2e066cd9c6ac6f3254a269ac76f05ba2c9470d29cf43e6d32d76b802a9652c2dc1d4074b411be00a518fb15e68722761332d4c062455e9ee1aa8f6301ee96c79a09c925abdbc11dfd85382d89cb5ec321eee04d6c0fa2b9368459acee531b0ad932e96113cc2efcc8b4b10b272b506658070f980dfc1fb01f1455d2865cfcc10619e81d47fce9fd0c889b1b5bdfc48593d991ddf6ce7dfcf124f30de8b66c96dcafbe09f6bdcc466d293dd26c6d6fdce3c8f820941625b66f0ee724dfcbe2b59df820dcb62d759707ddcb3d678e502d66fc6f6637b8a03415214775be0f983ddb43bd9375ebc0f2fbca7123aef1ca5d35cceeb1fbbb69d3166ade7df874e94e1a5b02d7e03c45f751288ad14486517a7f84227e14737982cdb39d4efb327d94e8649c16085fd9c48542d1ab459db189f1d4f35ba5321c11553d92caf4cffd0e7ca11d59fa05f040090cb2e262add1835a30bb655ef1f5ad7ad86725cdcc891b9c6edf0de06e8e8da60efed360729bf3eefbca920c16d6f7b02424d4b2f4e374b2b7e795496a6784cea5807a91660e10978244724ab59328d473583f6863f13568d7c10c30a9be9bee27e1e317ea77dbb49599dbb2d147237ea0b9b8a67d9946a63bd039649a0b28870022695f5c5506aeff9d0808549d8bfb75a64120a53fdda8e0675a53a5270e423f147137ace3d685af0c25480c9cc25dfc34db17e2522c80640cf2dc4136ea95a81882b9efcc1b3997a7e0383d892d01467a44d3d7ed8ff97e1271b3465e6bcd3ba4a0429d1d72130092a61cb5636d14723f07c6de806b59526626cb61069e3c81a6624879e1876d56038a175776df56c970b87768789c3e6cee9028069a874a903b86449d039b1e27df687367b1f7e9d9ff5cf82c06367f03b5e5272b071a4789b3145e438a82ac84202e19cb21dc108a76e4d70ca8d04253e4564a1314105bd0e0af810ff740c30a6e7e093eb629b962e29c79cac57ae13a53ebb30a33ee491b7f41c42872f0af1252ccef7d1ce81138844e4df1c6de9831ec365d74b425cc20cbdef863840a6c62f768eedb48e4c76014c40a2b9132b568bbea055d2e4b65c249f534cbd15fa0225f96ed7feaf06b1e6dd92120dc9a93de59187297b039023e8b3882e40441e7108057277136b5ab6873900b73b5e8abb546054416b2e4838726a890b49547f847bf8d70591d58d8631c6dcf7dc584b6d3446e29ef611bc925c139734b6383e1dc8d550722746a6fe5b0c20b41a547699036c7ed8dcb65451fedb9b14e2e4665504b2676399a058180613de9ad9791374c20d5727d181d482f9c7a5496db578c28fd210213daa443c3f5e3a20499231c024e2c9dddf999e30f91b4df7577f51f9fdc44b3a3f44ff29d298f2763ccb09e10bfe5a0d190b73746aad48f94d48205820c0b261b037b11de3846445c96983cc356f5c5191548f78509c271d1459aef9cee13206618fe08d44f27ba7dea72fcc26c34143566aafc0c43892cb12a805c71ccd826af97ef921e80e6e5c3e92ae12cb958de50ca01a2d248acf3c0ca7e38f14cb22befe2cebec7af74e3dcc1940a304b3468dfac713749a7cb374fc1fe4c12f0ff83200029e38da0a5b8328e77f5d030f8bbae602d6f03a79f7926f11ab074fd4637ed61a5919600a4874aa53224d024ea16e088baeb3fd96a921518eef1f0b85d8bd81d357f19cc85782dc5db4","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
