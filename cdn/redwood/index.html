<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e3442718111e3db0d43a063f672d9639b2b045d7fc0a2d63a3f35fe2674be00d636cbe27390a9c1419cffab07bb9099e3cb256864857869fdc3d9df6a7d684f0a0f0d1c01eb2864a566d6d0e8900c5210242aef13d04902a50f5316412885eaad6bded4227479e01a9ea7fcaa52549dc0cdf7bbe0ea492578936ef3849d4bbdd11dc1f0c19f031975767f8881fed7d85c68452531ced75a93bfc27fbfc651ba9a67b55a30f60793e8c6d623b5879567956617691a376f75f0a51001e184f55372fc63c140149c61c222d795db89f44fee4daa6d646269df619f545317f43103a2469817f9315e904151230ee73b1e3b523587a92da2c7083bfcd244c8eb40f88b9a500051bbf3e7cee633f374a56a9e50532cdb6920e95fb9c71950c6e706ad695a3ac1bf82f3083b1c7bdd243bb634a7b20dcbd304dd00bef311699a3e8399809f4164b072541d122abc336beebf078c4c4975840c5f5816b1b3f4cc6a98175415c0bb594bfe9ef56130f6a5ba7330ce6b7b3488798956894fba8ff4ce5be034215549470591338ede8754bee357ea4bbc5f2c82a8ffd1f8c24443b74f004a3a509efcdc212370f5bf1b7f3ee45f328a856b6bbe044f561f98f9568ba8bb7d0d88d91ebaf48601c1961f30bcfd5fd17d814f6db1dcd381f07269f63f01077d7de6bcfa1d245e833f79b8a8deea8099d28da9fcad44ea68b8c35c7fcda4c15229bdfa77d6202f4fba09a04897ebff515e4e048e64c8a32a849b1bb5f868a8ffa69a0bf0407b72ddcd2ad992b36213cd54092f9790b9fe77b3bcd93e029667c3035e22873f00a1ca04334a11696d3a01e9a5e8b523769681c8420e2d347079dec69ca22214f89eb6674f9358cb105504e5f2064503c0b9f5de22c4d2dc58c1f5467b0b699feadfbf07f5826c64e71f7d5a80945b35f79e928b551dc986dabcd7a5dc81a7f9c33aa8ea7f642305a14d44d60cba0d2e1ce65d2c48f633facf13f4d20ca78a0e97c316aa5de3ce588bb21d4c640b924e689c5f5b56e3d1fcd381363008ec1a0249d8888e88c2f6d94244f5b93d5599a161c3d9bb9fb53acf3dae6a04f3e53c805353d4b74633dae28c5295480324d2b41c65328a1e6fad3f47adc13cf33bd36a84fce59df5974c3bba42e751d2a0921705ee14c8a54221772d600a99eb400dbf7b8adafd278a91310fd13fa28511d50130d038182da7964f000e94e587e768952c61db54ee177139d43a8b2e6199b456093f8fb5ba43cd7ed3db2b96f35877113af09c37eec43cd9bfa4c7456be1484152764a8fdaf38896497c5ca4b1ee523bea7d4dbd20fc86ce45c261daef65e7e826a095cb532072a3fd9ce452a443827e8772456ab2f8381f837417b5037c42404d8f63c10634669482b49e854d681e72fd131f584d3b864ae0ec2eb6d55feecde1724a1dddfdfd1f4c0d1eb0e690fb32e85bd07d675675fa555a13e9fdd6efe9eac13070342e1e19022d12ed75ae9f1477f35503cba21f9c885295474e84e4b9397c58347f4b85c811533613741c7d56cd4c2524c32d62536c28d5a2b94120c88bf6c329e14d8074ec5059c12437fb16f9eaec2bad9370a78992c7dcac9954904db80ac0bf190eae21d40826298494098fc8e356513d904c26aa551a2c1a29afadb3d14265d0fcc2c4b7cb8b4b0b5943bd071fcb7601d10815004dd994fdb5a8106a4bc70ce90193e11265062a92af962b65941cdd7b5c77ac0b677ddb52c366220b446dd380a73e7ae36249e0a69de1715e79e69ee20f3f577c6bcfe43c9faedee3aca9d4ef796a8971ff897eb7f4df0a4dbbd6d0043f9d3766d4ac730a46171463548fc4ab6d71886b6a9e15887a663ce3b8b6c7f6167cc6122dfbb6b9383e14d761ac967f66b6ba1a68755c0b63ac64352fe051e265c91adfcc52fee60b7bb1caa6975076bdec2a9248bd3e9e8baefcd9d98bb635f58336110fa34a56b8517f8483769daf7b344fbd51854b4a9a739add35ad0cddc3b81c0a71e9aa31adc08c604df8fc176422473b8e5243aad884199858e1a1168af49cc7369649cea63cbaaf32152006a14878666afd61723a2a1919ea2b0827d9f0e5530f7a43f8bbfd7756b87ac029d063032cbee01166bcf64dd9b40146c0b887d872be3e7eb8b69f4edc4f616e97904d84b6fc3a3bd70b36ae4845b60f93cc535f1d358a8d3383e60734c965bb69a888962bbb4318694dca6af5a58656a1d3e25a4b15592488296e4c0754c7fa44b13d23a2b29dae98fe220fb5ff76e756fcbf3d54ccf8e6f4be759863c2c35d407b17f7cab54ea4aa1af74ea9c86671b99b6dd5769281853fd3544aef0adb80c8440aed658bd1216f01f935eb45502a7f9690fbf1447cc03aa9c7b5ba65553bf9e3afba4a13aef07ea01b6118ee9309ca4dd11850b3fda1fb54e878ee1b551ee950f0473fc85fa7ac2f8c7d4ebd66cb78c35c28ea89f4b62cf3df3a23a5503028b9ef69a76bceeeb20f0560837f4f3b58aa59ed02d806e6a887899f26ec989d7c095c99b14542eafca66cd2ff4df71f0051d7547ed3455dd01cfc3a27e8212193bdf4c823573e15a045747312c7dab719c29742541a8339c73aa7d5e482a9b6ccf48dea30b0ffae9d64592a17359c6996beb54437b9263732c8e97f14d499d38494fc933cacf52f7ff899ba90c7a1d83762ecfea8f930da20099d9bd0ccdf9fb84118d6b6e092f5adda846d9d64a92c5b759f9d2d67fcd3485dab3de84acd3eaf6a3746c1f09f6ce1f3190b6370b84b7f18eca5eae31f8b0b46bf23d6e5481a041389377cca562e26269e66bbeba60deffaf941ba21ef5c228edf5dff51c5dea814ba8e3766fd54b4e9bb8b62760fc7092f8ac59a14781242491904106e39e40b10c148e89ee95dde6827e3b040cdcb19efedb3df10d349bf0b6017657a19889bb392231e2103009328559949a8337e135bc43ba37cb5d5f962172e529c957434fdb6721d15a0ed5d2f6e4534fa8c342abd69b17be9bad5262a53d52d49dd9199f7cfc44e0ea0b8305c199df3c3869a7deffabc8e854edb7492806608310d154e9d7dcdc6c741f6e81da37d1d11001851d5be942cb9ddcf49b710f0015bcea5b2fef5b1806ebe9e42d72ec02547cdd9ac03097229720df3515e1b450f6440322bb9968323400c578bccab2a987423fcfd02c165009caa2438004b6910256cdf1710fe9aba06de5985a85baa8cfa71e7cdb5b236e51083dc45f351cbe664398e98cfe4ec07843237e57fe6d30d6d81d04354358ad867b6f136083ae64c382b633b76f2f30156931c19f95b535433851e58e775368ed64baf92ac249b652374e575f39e63330ed5f25c55177d767c6e62a13b0b5dbd1ed72c9f7ee2dd175833bbba5de1d9f3e306ace01a8dd05ea72ad1f94c8a7d79324e12bde2c98b8c39c13f659f70b4f189484b857a2351ac470b882b0f753a5c9fdc88cced8b1aa3b49a6d34f3544e3da20f260642cb2f2e050f1bd759055d89e8cddaf66f083328ce96b78efa8690ab0536de090b3f4b9d5cc5935d859fce5afbc9dd01b0788f8940f9f8068bbe727aaac5ddba10c52db975d9b6bccfca2b3f8f24cf553047b5d804152b449a618adf1c3d9180cb77b634e661f3fedb91f841c97970b37a437e5a960b74ce09eb07ab9b6bfec232e31f296fa08d20a7d3ec6cf4c556f2f972005e8e1536644f39172d258cb104837c8347ff3fdc99bdb596d5ad5be05fe6d45e4a6dcbc71b987efda35232c8bda6421b03daf5b53b24bab4e72b5817d2f93562a69300fe664e5bd8314effe82b3dc80c2523053faec9a4b5f08dd8578e950e5c447115cef8691b8533b90e6b14187315ee537d026d294947eefa9a65aaa4dd14f636e0fa4783af0ab3997309f8ac6b6f50e4b48755843c874c1c6f7c71f012ffb78c9823b42ab4f2e9ae0d05ad373c5f1c2545ef985b8d6f9d5a1565e6cd356e99d5e6a1a980d06412c631e0149329e6b6e8ad71f927de03a854eabc4c83b35c88da202b0e3541257d22df9cca70b965cd26d69546446ba67e7a3d1a6744bdfc2b0fb8d4a7044838d850878912a2ba2d12a5b03c3e66cbd6f1492ca9ddb7b28463ec894bfe3c69700c55260a1cf8995f96d231726f5b905f4803b200c0c27dc206c0b5b627e6c8633eea8f9451b23d3913499c6683856e9f2d5dd173142b84e97fcf997f7061b720a067ef4bd2344f0b77619116f32d5282a538e6ec00d8505b5924f7404ba94125d185ca51fa91b72d4d5df09f7e710329605518d5a810f79a409d10b37dfee8ab35c105eac7f2bb7fdc531a66abe28d26f6d3453e9e32a99fe85144976868eb1a83ddccfceb90e7aa1422e5b03c1ca6d2e8619f528f476530122f3267058b7dd35e638558f91105c06e829e9b319a565f6d0c823ad0a478856d55f0e6aa850a6f23e416752699aa61b960d2a5351e154efdcf5d7957e2ef9b7b54e61b0ba0bfcf621a71ac9a6047bfb06e995c2df8eaf53a31e6bdf1f5234a97874fdfddce7bc5093fd8785493ed4e669aea3ba923677343f743fc5dc8c8da97db55fee31e79dec8683114aa47b46e9f336fdc959b550a0c7c66c471fac352dced3cbd32ab19ccd2c6146a21cb31cd492907922bfcb1f7845d560e49bf708ffd19fe1bb95c746821823a6f0a215ed951d46e9359b89f429a5f64e9ed9bd383a1c0fe050ba3283c6900054e971abfb4db6d9827df61487f64dddc9b1be2a0dd6abcf57b13701f01354eea6d8378dbae0405746fd32dc8ea17f6c19e1593ad95ad4fbcbecbeef6ea1c27168fdbdff3f17e004ee34e571f079db663e7e952d4048c5229ecc2a2e9cabf57033e3cfd783542321a261d2baa6da369465d9994718be070d9c0dda444483b4daa289a9f71c456eb99d2a0b33d6281fd2254f475fc6d2902b668bbf1650756b8e1e9cc19ccc8d4d47f5614b96f8ab710f702d434f2b2ff4f113554b1f5b01dc75ed8fb62eaab17dc3239b5d32c94ebc30f890b4039e9dee149b373acd1aeced4d9db095fdcfcc0d74b99ae33ac4ba8723ab4b08bd9e908e13422a78fae706d6871f5d14991b29e3866275f45ef1c246ff0f3a625d6b5e67fb336c9d067598f332181a2b52bef723bc35279a88cffdb697b2e6ce129f2682fefd8d38f1fce55ea2b667bdf92783bb403667cfe0281d108c1e6e1db779a5aaadd8b86fbd24600908bb65cbf44364507510f88913f5fcf2e77dfa7af137fedefb035d28efd76123e1b2b1e3eeb4fe7b2be1f3711783202503b3360bc8342855b854fde7048dee5a12adb297687c6e4a83a42f91da24ae01ac4e286f201be00f6a009db9c9dc90b033c93308b7fb53b28abb31728d09614618e55c4aee2823021ad5e3657bb8026dc44318dcccc0d64e9e57eca687c6f5a43b7a4f70766ff9578c817fd792b5e8f3b9c6cd031dd12e970f86d67963a65958330a9d04857969245692e5913fa8411070b5f2d58eb9a1b230854c2152fc86cb0cbca2c782db8ddafb5393c8064d49f4f7d6f0c90673dd3059f7fe22874416ee68e500d833fa0297e96fc2ffaeb3e42b6d004165c101382d5bbf798b0b4abf9b8a002a50803c992347e72d68fdd479decb28ee4919fed7c052bc167070c3eee355a40aef46ba8cd9969a41411a15cedad5bb7cec57276cc4c311ce4cc1898e134384a18ba97b70a2054b2b9164785f503853af1fe76f3e52c01ba72b0645cf38b1a7164308f59ea0765475b230d5985982001922eac728ba044208900145f1aee59d55f84d3d9dec760e5a95848d6a3c83c809fedf678901eee4ddb505e1d60e26d167c38dbcfea206c2bfb31f8b540fac2d72d5cf04533969ad1ff6dcaab6c9b4b72e4b7abed9fe0e1fa890885b313e46686efd182e8a55531180c9967d5246d83762a8b8d97e9fa1c0125e8f198c45fd094ea84e073cb9572ccee1858a1524388426b582288ed50e44951a43e217b50bf2a476c8c85e7cd88afdfb45d6e5b8f7f0904dbba54b8bd11663d9ca3f23199f2218fdcd9dcaf4ee281a89f49874140c9f5bb5c3f0f84e736b641e4946d18c053d4cd55eab237c39e99dfc1c14ec60055e5a3a1e16a03b58cb2b8c72509d3592c65224741acd4cdc676a6313bc4a5fbdc69f838066b04c28731a4a24e1d58968e737d6ccf3d6e4a4fb0977165b04c63ffbd0d98c7dfdfbdb769ee0fd87cb6939c188a1847e32585a38bf5bf994b3f5f073497726159c982d8a720cefed19a6e9386203fc6088c0f9031d2fbba7a41461dda9ab807c4830ac25c000d1bc86c5c6d1fcfbe706dbcc90f2c83073a33673604a61484158697ae93277cf355e2d449cfdc6639db6def7053579062e33e3237243c2ea5abb8b96f7b10fd577d2de561234792591ccb81c8e19fdc3d02eb7a2cfe89386bc63732ae0915b4833494407c3344b998b64e8f7d7d40e0350a13bf5767fecf553e24e180c2bc2cfbb6723c0c45ee688f94a7855ce1ce3818e17262b7ef82cb14af7432e03971291502e2e016e7e2c714c2015400104a4efc6fdc76dee52008eb5526a92d9c25bf39773af06a3a40d7a248e89ea626bad114f9ffea99befe727249026c196200ac6cc81e4d9dd64c7a6be6df8b341261bfae1f83a4ea39c834fc0aeea999d99980a3ce436c299989da7b3ebae9919e60f9db7c3c03a520e7ef71f1951afe1b1b9ecfba59fac2b156e61e172804d10dc060ab6c1c555a88632f00e8dc10a0ab20507c75b1afa87c73cef6e92d00d6510719671e453110fa0c6a5c4cd0f429432b20ed5376ae7da12866f28362e794ae4aa7eac50097e75be59e2693792d4839d01e3f707d47cd3836e2b64346217959cbad3e5a62210bc8c91473fac908632c1f3b96e0028ac8780c313c4ecd748cd834b35d2d791ac903cc86453b892e45906b9d5d590187dee4b7c50e1ca6d25daca1e1a295b200d94ffeb7c02caabefd5887acde6f36b29f072d97465fbb666bea936401c880db3ccf00f737e775136a73cd76ed88cb90426588867464f5a80c23621f8a710b1dd4c28b337a915859c8449c7713ef59d8e941700865e9b45f8b8b9bf15308914e042b1b96f28e0caf3622a1ec2de54a8c33f40f3d060fbcfdfb791c919b96643638cf7382e576141645e3a448c42c1ce4a9c58bd3b3c30a30d97fe7ca5cfdd1ba970521e3ac5fd0a00acc83aaa73b5650bfd4575da9fedd7fbfd0fd867691e208c875cef96c2cbdb59d5f1bd4d62184e966766f5dbf4dc28534f66073d002a5907b5cddcda92d330f4b2cd836817a888603b14b805393d43a17181181e736b08509fcf1e755159dfaf9c91636592c6e82d44170a51bc0ace77bde716f33dd61b358adf4d0fd10c4fe8b580cef96ef5ebce90636461055621a683c984af404476789840ec2b27fbedee1e31146a4fe6a123ef79fcebfee58d7d7ec6336295ed3a6dfe4dc86220fbf2e290c1f9551b46db24fdbfb9c3b565a34aae39f554ff23f9d4ab1ee4b0f64860dce3dfb9db8e1cfce568e48e76397f4bffde80a22bc7fbb0b4f0a857e41d1be9ebec9e5dc44b6ff871e2984f3e2f157d46aa7bd1e23fde7d81e8e760900ab86d0afe07bc0c981364ba6845cf436f5ac0ec40845baed06dd88859b2cdcb2332b52acfe3ae5b7bce60c9ddbbb54cb94fccfa9c47bb2ecb6a4a649e512f9efb6f7c86481535908d0f9e7244695b4ef1a3ca432dd560d36b9fe07ec22f622b7ca82649b20529fa974ad482c75d2e999d4bfe5e01dd49ab8b4c6ed8f1a85f58b7c0804e08f8b5369e6675d4f21d7a63892d523d1b2371f988cb704b77d2250f7fb64456ac3fe596629b31520c78ff9e5c5b3504c735482474197df2e64ec3961093ca57f4dd75400fb53e002b376034844bff7e4648f8c1a7d98bedc2e581c46c76ca5d8f5da4a53bc90934110035075aa1b9a5f8a0461ac560a32947b9418411bde468db19fc2768737b0da61780252e1bd68f3b7f0d4e6b6d65bc0cf9364e4c465549d5179d9c77db57fb6c337608aa553f458bfc438b07107aa6500c1bda93f617f7481293297a44a67f1d71087f5a6fc7a00aef4c40add447816cf734364b930cb3586da2499b85fe8c9a9815fcdae87541e9600f005fbb03f0407a66ee665820417a2c63ecb842fd77debc23ccc6ee7cc33b72313a653b40ea6f2234dec0eb0db51157269170c52b6afda3c1b79c567815c1c69d409d876c58058729980639909c216a208fdfa7feeefb6c53e737228b509e3dc88d7a9fce4348bae0c226fd85efa6dda33c96dd3c0844498a8b8bd1674f794d77c37d868560d57e636d4a41a0ac1934a6d1a03343a3ec30967ab3aee04f78cb3d7b2feb9bfc75315dde00d4c74cb68473b769b79ce787304fcfa2047425cbd63bacaa9df754ea570da734157469f579777cc851ea18e6c94b1d9cc3d0c7ee5385218a2cdbbb23bf293b20898fc8b456567b77ea7379b88a995b48d179b409dbf18ef5832df0435e8e092583ec4ea42d1443fd922fcda80441251421eff14fcbc1b5b7a50b68e768fa39898f9a95c2f3a73f3b03e31c7ddbae07313c2a53d125fd55d97b60bdb958bd5d732200865e5a2404e9c08f9c8aafd08aa92d3284fa5e7f1f8f4fd7932380cb6640b557fcd10619aefe467efd694935773fe048773d3b78a7a2352ed4c89f0f044f7e3e4c1df72584aa4ae96c1607e0a6234d25be6258180affa18bf6f33812035c5b4ffc4d54ec167ebfa74602351f8ae0a2074f6d9460c317fff116f2cc38e2f769359fe1e5851911952b674fbf0256c16b6fcae7aa05d684ec80ac064ec8cbd6d1233e428796580e4c44340f7b2613de18bb51f0f8e73a7cbafc3d27a4292e152510a7c6e2273e809e49190b1b62cf05cb344f42e26d4f4177366fe2961caf3fa354ba495fc1291227d0ef5f87d92628a336f4801ed5f37cf6d728327e1e725f0f4e212069cdd80a439ad0952df4b3b4be628c6432b96438b8369a1af09c3112f0843d0eef6ee41f9391d253e2186ebca1e33de919007f7525d5945779bd9879dbf2efa6e487a18b817466c930d936c626e263c57e957f10b83568c137726288dbf6d50ea22df52cba7f2381f567be2a27ec2bbcb70eeb82303d9127a90befe04f973b3cd61f677a4c66a7d049ffe870d4c8bbd37b6794d6201b5a82e0379b236bcb768728985d29fe6e15dc1549a1f73942f91cec4040b3a9e33e98d6193b0de21054bd3593ef2a8bbf4a81119fdadda29a8dc1fabafb0e2abc974294bacae75cdce2937e6e87ff3eabda58ec64910ed3a8ed431daf44a13b6dbffd1d1413f3bc5a114e4fadf2329cf66e936b2f46b9976a7c3659622003a194439fe693519f517b0a3ac5eebc1319a71c992f63affbce3fa197ea63eef857d87cc0ede13c3638710a175b3699d014b6539ed56d46b2c8f7750edf486ca7aef76d63faf23d30bb669434721bf6167c631a0e3165f93f9cc422f0f9821629a16a39235b2e589eb26e11cfff0dbf0e382a811d3faf603926217c076e5f73b0d4e212755530d32f759f7eb38015a03a90d2f95b7a4e359a17f91410ee945131ee66b2941c4ba85f895a209d8a1a46d288bbf2a1e3cbe2d0a3c4527cd4bb202a79371e7b4797c1375c34449bc3a036994a1a04ac4bcb83d0c79a6cfe5f3bea91b2a0e1f5be2471f13784454368bbe2cb55a4c45b50fd2655f17a2f328c4be978520ef081a37c595d533964248dc48897ddab20c1f5577c04739269453a1a23682aab89cfca1c4f3d64b66aba45f5e8998ec89643ae1d8eed4a1cc213b0dda5b581edab2f78fc346313a6f7b374b81f692a7b0c767008670512afed3670f77a963c9eaba269b67e69391c83b20b40d0b4edc806e3d2f8952ac0ac91693ac477278b3b480a472e37c8b4a0d0e1350a8c50b5193738c01917431dbb3ac413bd1d05c7c21a2193b29395e403c8ba624aa0e205e287f8343218f0a05f1540f21d70bf3d8c12637014597cb038f5c4b3a1e6175658895b57bab935e30845f75ca928fbba0cef19d4b76cf4bd488c402416f6d3b454fac11e535b5da75bbef90ad1715bea3c64490f4c712f5923d231ea973db45ac34bc0ae22186bcd92d95399d1706bfe67858f49f2ecec27c1f50f9d954619f52affbcd8b4a1fa0822e7aca6588f8682c3d2f7c83177824aca97f1502ef424a4195a809299a8264c964ccc7ea7fd6ca4e69deedb1f76e684a3aadb2ba9ca7d90cf5ef09da8d7aa709ef0be56e52b92a9fb90e2acecc3684ddcbd45c1f464087760fcc9b00c9f97b7983f77df0c4495e4acfa96741ccd800170c00c79836ce88617023488e380e7ee629aedc10723b8990b02810c12ac191e40071fc2b39158a49e06a1adfa9dcb417b870021ad65e8b933324a680d9c0a259a1a7d4050231504e36f71d8e6ac2a029c2a5b9f4f247664d74ae900690124ecbbef54a9adb4f5af73e859ad41b61420259effef088ab7fe88e41e03763d7eb8cff7fd35fca78ce3e50218ad7ec40d56b4f516b22f54b9cd7399ed6e92604984fa31e5fdaf6ba01a459c439676d76c38ee87401b1294dfdeaa9cb7bed0d39629383bd15ae788135735fb275218c308b44ab12998aeecf1924a742604c21ded44bbf3a30a79394c30ccfda1292d462b3874733fc446ac67aba0015e9b352b35055b5a2746160d8fbaf10f7fb03fc67d36394f5350e2c922c24091fb5ba5d82630959d34a387f6d0c28143e5d9ae0f50e940cbedb814e45ba706f33b96f91d18f3f9bb24a5f01d75df6e108e971559c7f07560c0b04b3964f22a9c5f9ac45c0e3f7dfee355a78e40364fac5321ce1ced4a6397e4599d8daa6739a1693839272c8446af8996650304e0cec73b01c4adef77a515da685e183844506da161de14ae29e1c19931ad49923c334d93cc0012f968644e07e0be851604aaef733152e4c2e07bc6371dc4037caf42edf243d54692bf622477a0f781f312b487f1cfa3620f2f4157fe079881d47d1de029e6a6dbe868f50ba1ead2bddabcb13f52ae3338c7df84b92c198fa5aaccfe539809ee3ee7a8d60f26d0748c589002d74b048cfa9a33a51264dcd8655cd228256bd99557a67ccffec1e06527b9f7f31b520d2559096d0e006131fd06464c75be0413fcfbd1597db5c8b57399a75c61236dbdb85d3157c538a8e47c217fa4176e80cccc87cfc038161086a654437ff10c67740002a6a56e1cdaee3a3d9276a63d82ba47504ee237b03512317df005fc7b5bb2244c5a992f6fd6e8916d9684ccb8c32f8d4c62a175f9c8883e930ca3f8f35d7592e235e44ff399cc95e7d5ac88396c88fea059e5254c18038ca311a81b73641f34eaea6bbf029639c6f523131877c863299afebd012c6b4ac71798cd82a522746040fcc0a2ca83f6aa0f3b04c493e9932f6ef8a07b4f24872ae64ab4a38724847138b4f5aff4a17607e28627f78d853bc0efa2f03ec6506239c3be0977a62aa76f6365718a1277e36c7f95717a97ff5f517e088aa72805c59828792ed4cc71d0677aaf69b7175cb1306519a7ef5e8101a0afb2efd122cbbde2b4ff56b4442dc17e6571678eba05f29e29ab8bb14bba9176e6265eba009a6c43fae7eb9182f57d1dd80d2c3c9f1ee12166ceb75d0bc3eb0ccce3a5278ca3e7e07ce2f6d9e7f792d50522445c22716421d815655056646a5e848abfb093f1f73227061bb4fb4ca81152e42f8980ec143f4ae4e2dca654cf81009c153517ef4cf4756b297048ee6780029453de2c5a17482e5155daa05b533bd9c7abf5f07c1b30499f30f19ede693f9299d56b87a5562077afd4060b3e7d6c43717f7b4098b0c5b8cff200347ec14623c8595ba2f0969a0e85139add18f7c16d65b1c781eb336c7b316a4a197eb448cfca3cb93bc7ea852b9a7f72c1743240e824e9bbbc0361383ce3e6da32e39b9307041af943cc203edd1164cbbb3e575cc7e718959ef7fa2d560b0d6512bbc5cf15528d6bcf5ea38acfad3dd46fb16b7fe944c6723094a248c15d0053842d55c94b60eb2807db7f9fc89913712a3307080bb639e3318b93f6f219235a5a5c72e4a182f0ea9edeb5e94c4beec6273ff85787e6b4bec0c20fc5fc85f66e5f2ea66e92a8b31576297ad6b369501ebc2bc1415e2f22edc746b8bfe73a2762a70ccd48d0d34912b2822e5ae3ed06e359834132f2e9e6f3e725b4e802f3453ba35a360e654928d510173a9ca197557e9d0281a5b42768aebcf79117953a9721e5d3b221073497afd45b318cac7c8cee10a2ed2bf40c9de3a83c986c50fddbe850d043642ea891be43e3a1f2f4495ebd073a20495f71634ba42d9db657bbd41c0780c261d8d4da6458f8e7e15364b42c67969248be1c93109766351b3b68656792d76e795871310ec35b98995136c42dfc12c1fdb650a48c2c010b0e24bf1f30996c6d4681c4c61bc8560a97578bffd767a63cb223ec9485420c0bece6500550c2be9d950d4dc8eef5d072c4a3cc87df300ca2384970e5e2d2b4aa67e7e3d207cf4852e4af61e6d8bcd72daed6c1c0555d74cf0b1e7212ccd5fc40aab1aaa42980785cb7f8f9cf2049c11ab60b0a9f64ef8f067f1e1dd09f651320f736173efa41e68121f6e32e67838e1d07afacd296417c1e14c2ed98e2019d0f9a42b6d39701bb01a214d5b43555c03668840d2333d3b6b76f876a1f800ed0b3965774ee29b810857d4f8b2277ecabfb0c706cdd96c783502311741d335c7ac8b41bfd587a99638b489f5bc19bc285f29ef027a49da3b4098387d5f8e539e3bccc3d80b57422d8cfea55ab8e3b3dbe1f2a1ab8de126e22e4eeed06b44da6a4e164b8a1ef6418bbe9b1b6ed41866d119a265c407662c2637faed71f282ec2cce1d03348c3a057631df385c13af123a20875765a989602b10c98e0fd2a7cea434bd08d2e32f92cc13beeb97efbb9689c3c8f04f29a9c2434596360c560cdff07dc7117957bcf70f47490ebf4d8b008e820a58641d44e83acd0d8ebc7f29695f664eedcc4d394b1bc24a6e818ca92ac29000cb19db5a2c9f3f96a699bf9752f241258b1e2040b4c8e7133c6cb574e67efba308513a67ef0f52744a45e6df3ebce3b59738e8bcd7a72d8502838ae477cc1c2610171b8ef5c81d073316c1d147f7139b2ceed29460e760ba705986d58322b892ab89c6f4eb94fe44122f4a694f1ba1442ea7da17b50a2ee7cba46dbd3c4eb38ede8a445486ce6c652056c6a87a3f3b45fbbd8bea5d7d38e6dd24ebbe0d1347db602aa40083e0e2d8122f6206ab94caba6f31403a901a3d41cee31b130259a5e8666271699e9a091e535c48ee1843dabdfab785bb918365fb86895f77ae0425608137cdf683fdfbd1e9d209f90ae7fe13bedfa3fc9702bff616c9c449d9ef8d0072dd89794f028c6fcccddc0544a2dd0bf367fb1de1e3dc0e047438e82b69bfb35c8e5128e5bb13f9fae3e519fb6e37f6535c57144e083b8782fc4f95aec8be81dd5863166d1b30b4e80af2833a3f7520fd3bb8487eadbf411bb23dcee8d63d900194244b820754cd83141687ec52edf95535cf142c2bc8f15d77d5294d6be809c9e1d97d40f2785695558e047db88af5e7cab67c8d421d8824acbfc225e6c1d124d147499a2491c8076aa554bcbc0f8f894333748eee95e68b334a7f35dc308b7b4d133fe615ab5d2a164c9da3584a8075dc68591dbbd1ef325dc9a5bf03fbf19596853d5569174737c423c7ef6c01808387799c09974b6f615a36ab800376abe7d9566e9ba0a3c120217fc0effd8554da30fe0c111c5c21cdcbc744fdc51c419aa8cf4e2114e2c24daf8394194e336c93c5571d95885f85540687c8b66dec541003b32c1e6ef1bcc9fc985ae0ae6895f5ec0ef1e2f1c3870747e688b3ccb22391d45fc775c52188829c621535c29be1b0abb95606c4e1d9c077f062074b388b893fa80df3dcd05b5db8ee5c80b76edb61db453a60f5b16afc0248dffa54d37905c806b9d76b67e0b3a3abfeacede161a57f7022e065fa1b7429de43dc5da31fceb160073f13dddadb3e56a0d5ee4fe380413f11e7b9e40f0bd9a86969f11ad39b84d80bb488761caa35d4ec31258dab473748d581549292292e9e47944be91178d553c2fd2c2463ac057570e2a4a54883adb84a9d9e75773601bf7aa383c336ded0efd5331175cbf9885a8255adf4965ad8daef4abe000ff685cdab56b693d200a2dc5fb2e6529065467537e177ffdc0788d3c6c928d17ddba4a26cc397759aaa1a8a08830e00780032963492b9e5b9be6368fd9e8100942bb6645003cd8554004cae8466a873001d56ed838742636bb33630b129ca04ec69e26c66c2d2a91ce282b8a2496e56951c6e582f9768e19b97da0c1bee566a98d72d0453cb81985e14881c183be09291910abf3cf364f5652c59fb5076a978872457e592c6e52216330ecbf9d0298faeafabf995e15a6b14ee9ae745758639cb2002129190c9709e43fd30fbed0d677d771be0c52a31e0bd2302c75844bdb73205a485be56ee48c2b0375097377f091508fe5e5720ccd800dfe4709fa3826d8ce42acbe2a960dec78062589da85511129bd9aaea08e2ea248a73b73a0420fded0b0020d21ea646634fc8161d787a3480297ba0cdc9f73aa8ff5c23659b523c88067e1d1d6aab309e986ca8ce0c2bada56f9589854d1e870072fb4307ce647efc0c7e353621851658fd704e8a0cfd3a62695054401f37698161559622d93eaa26dbb7d1ce5f890d775dec3987183967930f4b7405ca8ac7b405f43f45a3153f035a8533623814660b066a7ac93e7dfad3424504308c2673c8ee0fc1e7fe5e1f11ffdb4f8d05be41d23cebaa10954c21adf4d6f789478066252f9fdae23878ae1d240c73f830540e0c5587b65a53ab079acaf8bd3236a008f5241d35060af60a2bed91fe9e0542ef53307742f5e0e709dde0802f2c24fae56fc36d40f7984d8ee4eee395a014b82633b0e632b21743f57b5fb7d11442849fe5021edcfa370353d19749fb0414fa9e04e9e94f332545ae8038594f233abac001c01bc5d5989f80180d6adb1461f1b980c32994180557267f55f63afcee0c5bcaae736bd09e6e0f244d1fa0e2e0c4733e3e7ed75540f5f0ef866a3565db1a5dd8d0e9b0dcaef20a023a8638009a564a7637b44d3b97a3ab233ea0b52491b19431f5ef42cd6f838de04966c6e753cab6e1bc6526fb27ee52768167ca0ad58f1188b3d67da3f24260bcb3e0d1ab75d1fd9c2c80732ba5f9275376b8579902ac58cb0a6073034a04cdfc7207309a2b5bdc7d5eadd8c73b96c8da8bba2e394aa4bb6d87dfd1ed28a60c7a93b7a5d0145db01ff38b710b913d218b5695176d762833ba3c3a42f63657f61d3d30f1165e54757ae185206f4d166c3159374e649be6250c4e3e396f20bfc708200df98c150e22113342f8b0ca601d49006ec91019a8ea65fe50ba8b05b307f7918af4c024fdd0a8ffe4e1e9dece35e0569dce336b5d0805db2b05e98a47fdb8b1146a8972c659bbfb9f65c8981eec2069c656509d1f344b5d4431b7efc4003c3d2530414a98ae89fefa1d8d3a4379b07c469d1abe50017f325bbe910600e94c468a3ee573b058f90c181831dd2f13ded5a85579e96129fd03e175fb1c74c15aa474faf65cd24a79143e6bedc52d5535d958c163b2f7ce956191ec8798b8eeb736f5a91c132081da9ef037d4eca30dd8295e61a6ebd380842e0f43922232d5411c304a88706c2882757fd8d50d8fce6c9d501eef766d31bdaaf3f9a100e286dd3ca1134776fae75689b63565c3b687325442cc64848d531a5a31a3fddf18f740628752a8f9f4c518af3fc48e92c8e3923e914a6ef5d808c4985df7d04d8d144b3284973d81fede5093a659a529def364fca5ddcb51c5fcf82aac9b39978e3b4cbf77e8f5ecf6e3d401df69238771e2470c6988e9d689f8c9a4a0ce7e2fc747ecfd0770e4398f450dd17ea085841da26e1f2be50e66af2fecb4451e34c9603b114a1786b2452ccccb94075e984261499ae02a377696de8f66b0ac97947f9b7d7d651d57e0d47ccacdb3273afac82109416c8812013da1e0363816e449e006e38fbbc68ff705c81c26f29f79562170dde107a39244515e33552a04a6a5bf372d631406bd3119d41caa373e2bc159ebae9125312ff5adda13f949ee78668e80ef45f70b92f2f1abff7e2257c524ef44d58ce3dd96668f08ce0e9beb2bbb352089e25de56baf9d0ccdf8e9156cea4ad8ecd79bc7ab78c29a7a0d9ac31b53b59baccd8c4df26f3785db24d557f1852d23c12382f00b37afe31b8c0ea1477aba69dbbcf2b18fa766b980b05ef3a1a346641286856706e39b65930483001e06d6b7fd4574603d2906764dcdc3bd695ad4fcd8a1b0298e3906a994977f2591e779a765cb7b2047ebe350a3f0968cb2287ea7bf28a2c0031d667ea95f95e1e12788a081c82037bf0cfae5acc107e9e9b483661f0d98c9b13272158bedf59ab2b3065d858753b873b03361e3b8080274127a9c583d43f46c09a42deecdfafc5c8bd5fa799568316fc275a9ae0a450182e6de423b85d95ea154db5764e89bf2a0620cc90b0b2307f4d3267a0ef6acb69c35d0be995bcaa705c8827aa48cd9ec1f6b14ab892ef1b055a1029b1cd755b21ad0c191dd2e9a4c45818f228cd0285dc4b59e0bbe1d0de31e17107d9821699fda733ec0cfde7d13d4972e25e797dba32c2ce6c6e1c3c9325e7bc1f39647d33d832919a3308d7a915b80bd34a5d45104c4b6d0095eff6b94820f0ac3cc52550b07c38eaab455cad4328eca3a57b78fe24120b27db67b855a2120dbb0a1a54343df6cccfda9bf6ce70f6c9fffc8b0c88e4d26c908a6e8d8c9e9de6bedcb7129d59ab0b2641a6ed44efbfb5f420a627475c133d800f0c1fd292e1fb3c548c71ee66008668b8bb1dca9363c9eac0221cc8ad4c5b70ebfaac159a7fb5dc2682c554d4a616257845b210008a915e4b670c8a9e682e8d916cce3f3a6eab8872ac00a83bc9d724f9f70fc86c2db8554d3086d85b9f0c392a273497eb5215299383592f27cf16df0c5b0e56281a341bf1dd8b466e7c682659123fa078b1ee04cafcf02669684d0e548b6609b61a626174fa4470c5be1a5e0946b4e2820c20a177aa5e683fa258346365cf7bdfdd7bc3c7ade20f8dde704bc18734968a10f12cd1d9063988e1b59e22f57b53aa3e01a8260f96e1a2af6aa9aad7852f9992441b15af67f75b1dbdf6aaada1c2ce99add1b58b434f7a0dc37cd8676eca60e8852e0a8fa27d743560872be00b0f94a960fb3e0b5778faaf41d529b38d4c556746a43cd277eaaa44b8b8d0ae5383edb6b9203e2e185942ac0e38d419431d3ae541e6c2e8ecfa4a4b5fafd8a00746a78dfb41487261326fd02e72c587bd5fecaedf2424fe01bc197151c91c72bb3d4b15f99b2ab0a99277f1794867b4b47ed5267945f7767c8a4e9d6fca5bfe8d99061d5ad8ca44216d9d4732e3e90709b693aaa8526f9111ca843b85127f4fedebaf9dc54a98ea36d797146688823a095e9200aa6877471a19637169fefa0e105ea65fc72ffe76c05def5e1f1994c9fc50fdf367ce947ef29a2e5442fe9fa3bba3751ab10dbeb7ae4b47d1333836d5bacaa07d74a88e766b8fc8e9fd2f35155050129986d95bf828c3fb84b7e7db750de97cb7f2ee02a9109909484beb381ca51d66292ce9db8d21a03ea999e9dfa83b6525083195d2fe4163ac9c42f5491906ddd7beac1f9c20b1ec0e903b5f151cebbc2c9e1390359357fa2b0bc0840ea03738ed35a23e1caa9916691f9a6b9672df7d9ec531c140761a4f9d7002da62f3ef3e9a74b4893a8346828df874b8c7b0ac5a1fe55c9407d0c9ceebe05347b9183091a4a9f39810cd5ce398ec6f02aa8a9cbf521022238f3da9dd5b10d30f0b70c84fc5defe2a3802ea036e5064ef7f5da9d5b0e2877a260e9cabd6eeca1d378a38d406ab9b897e24b1c4ad1d93f91505aa5d509ab9a3b370e4997556041a9a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
