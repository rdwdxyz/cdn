<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"4f1efa07e005ffb651c8abcd2a25d5082d683765b46a7b1727ebfc1c4ef738c2a410f6d8ee76cc822fc40d4e38abaabadfde8653aa0637e89a29223b31a99d7479598fb75db538ec55147c5e0585ca2a215d6a2261f3e68249f72e80ec3805f61f309b42e9c68fc8fa58c5d2fdf27d63b1ee42e5b833168fc4ac9eb733b28006115e602b7e0b06519e16569c77b326dd1bc2cbf0df3ff4e082d4f15560c5dd9c9c62ee695ac55b1402fb2a01863738e330af333a9842bc9a9d39b882d98d09c1b906483b68dbe671249172e9e285ca7f52379f041784cf4e1cb0b067d02dc89b59d0dae2c991c667eedfa42ce3bbcbb80fc81830a2d53ef5fe3918d7c74f6f4cfb6709e8ef50ab85532170b97dfcb58adbee1aad8e5298db1321ddf6a32275311f765caef395018fc2703e16ceb6b761ae51c4f953af8a73e1dcd54e40c3899656d310307a779596e6cb2b82fe6bace1a49a55e2dc3998af845b6c5bb01b5b98bf685e1c6fff9b087876e6670b9bf6f3c9746719d686eb9127b208e6e5242c25baac5f9aebfcc92e91c28d7a5feeb5b995c2b20ff8ab2d873a3aa09da7aa9bdcd66352a6090897dda3f769c6898ee2ba0f3ee7bdab6734f44693dd7fa3196c087ea507d57f14720c01fb87ea2cbda2b55677aa7cf71028d805cd9bacb9d0072ef6ed7c7f3e2392efb64a3d4722021816a7a7c20f53c88099e6c8ea8d3060df533230ce1ef11c9a35fa161886cca8ac43bf5cf33ad943d047eb67f5c38327274780e7da8ab896e0ffe365db352a2e36752560256a4acfde43040d49033f9354094dfc55cb021851301badec5dcca38a9a229b86f08e7b16be304cc7a2f8ad2b3da94255637e6d24324bc334f71be43eb1d93f501db8e8b70aa5c15253ba8cec3eba4881d2d43be4198aeb2554e1dbbbcef558aca080b6f4540a7998fda75d17421a01a741b4e3659a5366518c206747e79ee2927f4c6735570ed01f0dea33a3f896b05230f4c5ee0f2589cee98192a8b137abd02a9cb40f354100eb1aa66330db4b732a334e55c11373b0a0a5e3d74b65c9496462ac2924f4f783a54c914bdbb8db1f71bc6f37518b0c3cb478b146c5df332075215183d34759fd3f2c0e7fb5a6d206eb66af2f35ecf63ef184bb716a6cbf54d1d8526f41aec3a822e7f84210573f888f0166cf9510e04a4b1f227de1f584fd24cb481d9ec4d008bb84346c0ae0753b314e0c9728154f4d51e2e2371c3a729d75eb5ffc3f76db0d583f06c3069b8f0ef748af7455d65dea9136a5530ca115f3429aa2d0204c5d5ed402a0329f33541e10959559718c821c8d92a3ef27c907b452a424d8022bc7d74c1e0b846c542abaa7a86b0fe26097efbd47d308bcfb9e659b997409d8d5bad9ad7bbf448551ad39a508847f1d55e2dbeeaf39234da1fc33145b8668380cd50c89dc6b7e0d32648b7b2875742e41447ce41f514178e1ecf45e7de6375d0fbf31c270bc9f641f5c8c59dfe65b5919311370e9d09a3ab1c98e8c7731b6d30d29b9d870218b75150abed7b2911eb36878c1edf56dc245dea605f2007b6952a80bc34128c07f0286b1208bae12cd91766663ca286ad8274ecf0bf247fb2db2997b08c2727dc03f43a368ca9a4f7a0c207803ed7ed45177b0d3e9c75d50ce29171eb9d55d751b77261cc8ea6262cf1c8acfb884fe22301f39582b317728e11f736729b80cd2111ab03c32853c99c89a192ba9cafc5f3c0f282fd95832ae05c07541db7e33fb28cefc934ec5077dfc9382ca1f1dc3551342b29bf1ed90ee240bac1a1799c24b42032a7db4c5b144e9dfd5b5f3379227e99b600370c1894a5b92adbdfab52a2e7427148b0005cc0d9e62948592e1e980ddb583f3cd00719b1f7b29cc689fcc47c31b68f26b7a6817f3d6a1bbcab794777e227e1890e99408b775893e64127c405670c894c4d803fb9332a3d08ca76d28a721fcaa9e747f5ce9966cbd45c667230cc4efd9f1eab3fdc636b35f47b1b306ad3b061ee40dd34ad8463f071c2504a758bfa227f592341bde614915e77dd67e8c030f9864ed60fdc524b75c9b5f4e18b5281c3dfe1e4d4a072ea4139916c163954939045b160fad92b15a3d1cf4dea8a001bcae6d83b3e50ef464558f361dcdb1b1947737d33bf4d1429bb5d27898a04db5d549cee719eca89ca9ecb107688ce8fbae006cc078e81f57ec5a6d1ea67f9e8dcbab71e49a608a14d7016f06b9b9d3590298560c8337e6a9b6175c64ec99db506dba01dc6c93b1cfef41cfd0d00b805bfca06352a53affe70535f65d75c8cd5757f8cd736bacf449fd062985fc2ec3000e0b64c8ceb9e0c414ad57d41868cc51fc1f542ecd25fafbf9e5dbd5dc5c7688cd408f253a162aada776b3d8660b69b7b2150ba566e9e856bd1939d104c6cf71982b27b07d6e4280cbf7d137f00042cdcef318259c6444f02e0640f9a4bf8e947665b0531a251c7aae50275aa36a9bb54f0cb117e7c30041bee41ab43597d856d1a7ed5036636b850e586418f56b6faa162ff27517b4a76ee1d25dd6f098871f845cd9d5b1a1678cb2cfc8745c8cf35f9a72cb5d5b11b44f454929c20479e41385bf7ec71adddc8afe942285acff91fb2492268f913692b3398011f830b3d83e3ca875e0cfd81130263897dbf0114265f216a9ee3b844fd0c2fbb8d2a6530b8388c9aef56cf853a160b65961889d6884341548c6cd24474af889522704cd50af417da701fa60c6f7c3a62cd0bdafaf1705eb64f3ba6f892876400899bb5f371704b229b2763554e6429f9fa0f54c37624ba521be5b8cc784107b1129b199e221badc596a96a46a16e9c52aebc51c46a0af3a1341bd4cd98cd83d9d1a83f7d34cfa9b48a69ed421752a0dc57452aab160e0d5e92f33417ee59e8f7bf172b6c9be4f5085c57c5b326a08d79715343a1a0879ca9829b3befaa1ef598db97db1648d9a7f849dab011f3c8cf557cc960f153c60ecf2b79265a889cfb1e2e18a5201fcf9f27ba9347cee71f8a8b6bde3543296299143a0c620ace9907fb7ff991782f2f36bcf858406f72582f4b7989776f1e75f43957517b85c6387f8f39fb61cf07865ce2d49b435104bf7a0f958468db1fba93b02aed41b61a101ef69a4ad2b40e81b1cc0281f4f92c689dd58dfe756684fc1d67d4a94b10374b54a954eabf11d7f700e70b1e168d0ae868ac9e2dff12ff21147197d7bdc526f3788f6c411bfb52b5735bc72feeb55bc01bea2b4bf9094fd29d9b67a61b37a92dbf8a23ec5ca6ca0dcd033979ce7c97dac1d49833aee4430ce952f59c97423e4248a40946f6799681581d015c904853a96c7ad5e96e8600136575d77c0ba55c2d65a5c58d6fca00eec27dc62178409672e22e76d9ad40472da95bd051f664b5c2e595bdc19e1160f76411b5d811410a83f5e720314d417978b3a2664c4dffae972037a19d40eec99b46f0ad46df79fc67b9a922393d4f302d27ad6e1e69c4a0241dc89260bc6afec722729889166345154e75be63abd4098b5a8b1b64ff484e2359b012aabfc75e32c06140df8bde5ab34f974e5e7f94ab56bddc119b1cb57fb95a0a497ea90990bbe0743705526db5b0e11ea1e63b23933891cfe035db1327b820127afa63ed7c22a23b215f3361750509570044b39b847ff3052bdee6c524aceb317c0705f3fbd191b775e5c0f6299186814f3443df8141d43f14c3925dca8f352a8de9b4553a509552075d1275152c84e5123ee8438798b44f41bc39b0ff9ea2d46d908a8f3325132ed2f1aa0fd342347630cef6dd13e00a996319496b8f9417ea4ece1d9755b79a11403089ddff46093b3e6dde546a3a0e0a6ed057e9f7ba9b305030b7330131188bc91ffbf7df75419072c001600209efdde701b39bb209515069443bc09152176f4feab2ec880ae066c33325fae59e9ce64173763777afb2f3121c6f56e9e1526d2a9a9f384664a770cfafd45439fffedfea68558c7e66a1b82e7ab2e61f9289255c44daa34ccdb0d25971cbf0a292d87e15745ce26bdbd3c16822ba193a14808528b1ecf4960f5d99a6edfcf70c48a30fb6bb2a5852cad4f0293629a762df92b9c880b558b6725bfe2e757417f98e56cb2013ad2d04ba2aedf709d14e8ce899cc98edfb0ba7f27d2eecc90431df11d78b0a1d362cad49949a5fef404870898bd6d266ccecc74af91786652c94d6516e5548a9960e5434860effbfa05606621005710d4994ebc71d28e00db53bb9e5b9d1db2e8ccfc524c6802444777b443c4311f36601cc36af41d46c8135de3bdf516c91afce53ab98caa2f8657c3e75a5dbf2a5a0080aa7811c0d6ce05978bb0cfaf5b7a3f7a5e17e51839fbe6b81260635ffd1f04acf614553f5d2351f732ef0b47d60881af0cc7477c750a8bfe72695c54a08f02b969109b9824c43b8d34d3115a4d91cc8571ad21cbb32cf499407a8cb7bc348f38d93a151117f9c69cda79c551869cadc3a1ede9a6892290a4af4ad90acdad94b67a1ad6cf55a3c8a60cdfa9848fcac7f1586d3728cc949f67790225e1cbb197488eff9e748f56fc7a813baeca69e60b0f128e6737182dfb849789b4e4c10f2c19aa91afe8277b4c61cd61f1653d0d88866c4831f3b3edf18ab5d68575d0a6d2cc484e0e8f4f35723fa72ebfd244578998aa221801deafa5812e383509caeb40fbdbf3d49e97b40818e32d6e898900c9809375b0315b2b81220c9e7ef7134995ced4b549c96d6d1a16ff00a5be2f21123036f1d9361c1947bcdc1699ed4ddc790024ae356f65a65059e2dc4604c62114ed72f317186108da2e6b29367969223b8fccbb352d686ac54258b4dd0afb519e878211010c11386175fd11548cab68c65bd890f061b08fb571ae97270186ec1112de23f8f1d909126e87649c07162e9f6c19fd2871a62258cf44fb57ca33e14630fd508c56aa2d2752387ee16cbba977d652b04695877da3b66624676e3a8b35107902924157b17936e182897c6770807cb6500793d1feeab4fed8ef0552137be9c535ce2d4c2cb318d4dace92b4cade1eb0f34357f471ed1cd1a443b2392a41ea0c823b2c0a644536a6ee2ee4ef02d97a3cd1b37f8b4bb348b2069d01278ed48af0d83daf436af73ed347e79d0454cc310e0a747c16945f9ad291678f330ab782ea6f87e469f2900634039aedad98b556303c5dcda761fc35b072c60237304ece7d467873e7830919c63e5ba1228d6cb4af0f51eb93b90794cb66f1c28d04907db70065a65c22e7952dfd59d099c62b549947f12a31cd6b41800453257bd4397f9aaefb5d6bd730dfe094a50f4c71b1062b8c2b1dafdb3e612c714876ea90850317c3a0b2b0a93c8d912066b52d02e67cf855e480c1e68a596ea49235aead74321ca7a0b65199d7f5f1de351554270b2e1d84a42a8b974cf8d4d3e7b2fdd3b1f288b4c053f6df011ce61a591119b14fee1a854bf2392f7890b386510a3e730f685b6b62d52d140cd75e71e1904e1b32ab93d76c102ceaac6c0b0448ee7521dd48b1b9b31492d893f53acdcd6af0fa365e8ad0c6ecbefbf95d05eff480527a222e80188df47bb625ef7f737dd3dc10c52c72565fd309534c71fa5fbbd8f29609d23b1530fe3dfa2a5573713f909230ff8550fa2040a43adc5fa50cc2e5aef420fabd1f45b482edeb996cf3d97bb70c6f988cc73985b2af948a51c4b72f2c2036f94f0b9a7c44803371a39f39557e55249a3cf1d4213566c3d7de11974c87575c63c776b84dc6e68ef1ec2ab6ebb256796514566645428f149bd779207c196778f892a6b73c25c342ae3362b666bd422f746388eb12d1d614f9fb7a8e2966416adfb20cc65cff3ac04f4919dc15feb2d3cf4842c6f44b13fd94a1018aea27da2e6151ff479164d706747eb59f0ae48d6e1079eac1a646dc323f8d115d52aafa1054b6806f1c74ede305a73da89ef7043ebebe10402c66ff383bbe507a4c48f5cccb1690e238f65609c3b763f86acd8a83e7efeccb5f2d98d6f375cab7fcd73907b9b38981930fbb368886ba397b02cb436ef083f7f81b878e338cbd8e6d62fa4a1525d00e6a4421386e572aa733424b245cc071ab78153fa2d6403e4adb0b6e94de8825c2d6fccdd7d905995bf3c1db89907efe98f039aa45817bcdab467a59c0e37c6e062c1a3affbe8e836dc142c93f96315ed7cb0c72af3f5d6a93cae7fea80c1480cf23851ac6df5999a2de02c090adfe2833db224ee6261300de01694a5ee26cac60cec6ca7cc2411468eaffdfa0f4e17fced954bbb753b10aebbc0484422e0eb901cd3e8e3e77f58f5c22eae6125a6882a4c5bbc9b1c4fd0bc32d62d0076cb9c8a9d9af65ede27d46c1c3e9650b7fc006a31ad8625914fe2d30c29c05794bec91e53a401ee747e35d351be61b4b68484c9ee626e20e73511113119c50edc3a793c3c211fdcf656cf9f5db8aded21b392aac17a6bd4b3ee407e4e2883839ace0de244efced3e7ae43e32ce0956b95a34c61239628cfc4d2992caae40255722fc049fb587d83a694914828dd7a088132e2a3f6060d08ae6b2d1e06747037d8ed0b7eaaf536a114ecaa7353fb2863a3a4c824ef4ee6fab3baf7f4364fea76ede63d0b5f72b3f822c727caf2e9a2d81709c2ad0473acc7efee0925f6d544e34a2c70351aba745a69ff60725d2e3b217f51fd75b6871c61710cdc3742fd1368c3a7322b7c2c9c5cf40d00ac04f6dd7eda41d2af1f92f72c6e4f14f7987b3c3229501504016a02f57dece7f910aae6eec09b36addab7f2268185632782a589d6084c23d9a05fa428a03856797be0421248a608a9fb342115eb3f19ebdd0152089ac7ac80f2b2f172d3ddb022ff192ec14b2800794cf8a9ab872153413706323383698a8a752062ab9bfb7222f4b2785081f82676ba10fcaf6a6c2f3be6a1146b791f1fe2542feba87d21a27da01699e4ffc857b7c14ac6104b47e1aa67a82f109c5e5c007277c959066065ae15c3addae897b811bdab7b20db84070f29e8b34a902bc60ee9470fd9459ecdf5d192ba501299d9c39bfcae0abbf6804b4394b51e80e463106b3245459016123d506eb8881268f575613e46fe19efb27b910c20ae83cae9c525d1e9c5bfdd5c660208e73b7222728bbc116386bc51caa75f0f66e35edc4acaa9dd35be85b28907f756e5bcd077894dbc335fa62682f9b28fa892a17d3532797dcfc868d812549de55e1ce6c12a8c38f0e7e6d68fd048931f647cc2d31a3a9744ebd6d699ae65dc3fe2eaf8e9237eea91ba88ed07bf93847e75ae5620007df45cbd16f1a2f74ce4edcffb9b1ec1577f4baf878bec609b99d1b6781d3ca72318e17316aa4e9501e29bb27572c40d5bf86ed631936153ac2d2cc3b19470ed7476fa7c26fd317e939f199ce47eb8e90eb928cfbe37d2532b3257f561d513958353e20ab5b6e8dd54ae0e8efe9e3ab743af33d9c6410616331f56b7e8a5ea7b6875c2116eff1a3b791322ff17d8dd4ead618726f1553c3dec3f59196328a8201f3185eecf2b05888d97d94aaf719b574d9fe937fb2113a5e457c44959206dab7bba9cbfe648cae5141de8e65f5f06d048344c9127014b041b6d542142fb89562d28b082e93ddf10f31a9ab4dbdb655351a552329da62189e22154124e414119bd7129cb0e0660344f52a814c496a07a39b228e91397be629a08fff0be7ba057ea01eb221ddbd9d69ab4dc3e2c6c59e951cb96a640a881c14c0afd608dd5e2678f2d07d835805da963639328c03bce4ad4d34126dd4600d84c89bc1ff5d821efc519ab575126c09deb4e88ce803f279a353defde13e6b25bbc426993ebc6cbd511d3326065cee8cc0e8a535e0e4c7e80f53d69339f0e50bdc80ec3d39fc4fc0956790ab9487f8c0bda7ebdc0ebbcbacb2634baa17ebeb69b7804659a2f5942ae79832d9cc850e19379050a2ff1d131c2a984a38c10555e52fbc2abe5c1f188ff6ebbdbb212b297b7427582bd2b683af988238ef118b2642fb5880d7f9126753a90704ea4ad7a71db98c31399065afd1c0910fd146791180cd7c43b09224724a13948fba8c4b2816be2e22e8b878680c938b54dff1c72b3c290011bef6651c7212f23820fe4b5fe42109fcccb26e89ce376179cb4c8692da662226f3c12aaa0bc5c5758390daab12c70db5307787d6a8114244438fabb1780d89edd4e78e6df44e9f1d9193e2bfa13161fa1cbd4f20cd235902bdfdd50c568a62e4e118d089fb4d4f9e01f55e03260f91a5fdb201abb49032b03bfe1427d55095070b193b7f03e2d3e05b3be5d61b450c586e7900673501af57c80995eac3401d7daf2066385ef4b9eea937063b4dcdf2937dc7e5344d7c3ea9aab76ac786834cfd97549920cf74626d575fbd26ce4aa394b615dec9895262159e0d401849259405c95bb1d333ee7fd451e4264d75f01012e10c2d238d6084468f67137c48413f7ad60e6462f8848022017a9f04cbac379ed05050a5222915f02c2dc48918a3bdd518c4d60b88d6ca9f8e59e47dd40c929ea98229627b3a515037c3cf7ccc60e61361c7785afccd9e1e063bc72e6d2edaa14e46bd1797a45cb74dbfa34fa66f95897f4ed697baf2289fe35a997b5c20b63ebf0d0c82fa7b4b60ed293f3c0b9438f49659a0f0b6f55cf3d4fd62ccad1a3e32614ac3563212acadf5864979a004525e1c641e957bf7d4f5c35012dd4e48a9a06b89b0c0aa132eb9e7015b602b7e526d61ebc4f40bbf837df377ec1695138e4215b867a0ef672e8005e2c9abeffe1c90424b7eecc666ced54fc1f14ac4b755f3c4825b807842dc8cfd9a106d006e74e7dc584ff1b7189905c67ccb6114215ff4e8a642ea19679247ab46cf604e9d87e6e92cbe273d7590f73840f47740a079b84c02ca58601a90b81b9d20a2ed8d553c25b5549a300d69427c4e4a625146b665bcbe2f04f75690fd5d954f9b389714c99c4121bc2f22a3529d0bff65ccc38b4af3239674c7532fa07850c69f91bb078c26c11cdfb275559333ea6f7ad19fa6b1146a8f835cd756e0bb92a7395b79d24e700d4202d65393e90bb0e14d733b9be6a9e1634bff4dfe90cfdf085cccc79cf09eeec3d4078cb91dd885192ff6e6a7f46c12b1c28b558d5713385be9860a6509e0be0ba2b5b091cc0847c2b8ec9a8a0afd64d81155fb89da04ebd9153669c19689603f91f15382157afb4ab1570268f29cf4ebee08e7af2bf311fa4358342c139c4923ca0ec70500f9d31c0b69aacda0b33d23103e8e57ddcdb05e8361ef39825b3292e7ba142b49ffd62ae63e0d8834cbca32d94d53a1485d25ef4ee16ef95814c6f5f706562e407f03ab772ea6ea2e4ea846efdc96ea832f4efb2d5d219472a48a3dd6bef86c18df9c9fd31cbd3366b472f45a41d3f4e14434c913a8991df4ff7b3d3894ba4bfb1e38a2095b9b55893c0f12af62c9a591a9c9f6c92af0cc19534984e6866653a0122ac277b8d06ecf4cb99adb82f11fe294f823b58605466e2035952f5e543d29c1af56e9018acb14fa9ae4475bc8ce4e4a2bd288745f4b33571959aa2baff5477afb9af6c7f83b29c25b3203a81e8b11cfe92f859709654357c25e5b27e7ff684148e8b8610e1d1bfd14607bcce7749f5c3481321e927edbe9d780c99dc1ed8c4a17836e9a304454dbf9273aad97dbb3618731f10f860a0ef7076d4fd156b8f83ef25f38cc75dd5925f413749f0ce11c8d423012c2aaf2b5d521b07fbe55c0fb5986a274963cceab89fa41745b19985a823a2feaf892f9b3e4add2f8f30071ce0e247f8d8c6965593ea93f4beec0e462f31ebd326c5e9c38555576d5f86d0473ce59e22e58771da288d0802af3beb96999066483737c18d7bf9a685d3473050cf4b2c9397d1ac7cb308a00912958c0d24851ddc2f6596bf0340ef732d123bf50b9dd2570de192885ee960b92a51a20854d5501a1d294fa7161d8a73c39fcd2c35a853b31d464522e976d98e3036e1a3bc3381943b459ebeb56965b1acefb84277d8ea19683f56bd942c1ad8984b83c10ff6f160d8ede53beca3cae313f5f14041229451bcf50b751e776ca92e2e8ae1f3d3e8c8336a78ef73b1ae16b5d8f21382787e07519f63f03be912361d215674229bb06c8c9c880f3e3e31107e137d4279015a397ed25a4deacd85756812b019e7a940dd3d81955100a5fe5fd14788cbae93b5870c0ab7f41a067872f22db2bdce0670436e59d343977873395730a8c65de8fe3d7030adebd0cdace083c6d813ee1abb4d246357bde4166aa346458e17200743d34f32f41a7b5d3951457c2105dcc2f3978ba7af7db7031657392a3eaabb2341db56a2b16383afd65815956f4e5b2ee01565cf2a2e584bdbfcbef1a6b15ac1bc19d002f89b3ec92d797b3b488fce625e5870802c0bb08370ede123b9dc2b8ed56f6056eee2c54ed6107c909c4856aa9918b2aa3c73c47b07fe80333038085e33399568fb2b03ac13f8f022235b2ebbdd6402bfc73964fd42ec7b89f618d8075bbc2777d872566336985996c586404b09e0a4d9dfff42538d4931ec67fe0afa9da24fb3de276d960eae6c5a305a3114a4cb6e92d67fcb583fbd3bca9990a58b0c0cf6ebf104c1462cd6815f16397ba9330af13b680019f2f56aaa002034784a55f180bc2aafd92ba092c17127b4489cd9228ddc31f64c52ae1a051130e417618005f1bf71c3149b00afeace5aa9e73fdbaab931e4c8db4b9775501aa64f870c7b883026062cc7588ca0c6c623be3b2d3b223b7384e6c1012d1ed9c54f5e5d0f6d39025c14883ad9be908356d264fe8af636542d42e7fcb7fafc8fc8200b4b72c2d46d062380dc42f00259bb1341e51a37858df994a458c8bfa63d357b164ff2ee596a99651635eeb074dae6da36722bd105ae2c23719e5fff721685ec75e1bc621274128de2ac59c70b185b7f4a96267fef351a4648296c676164e4b3828cfdba928263137da725da17efe086636095937ecb884278dafb76553812b44c08ef5b83bd7d97e5efaf124f505c47cc10ec4f97767dd452c189d776357ccd84d464a62098f0c0f1d33ef85c18e12de1a07090f61f6b25bad968edace2323d5f13b2116e645186a71b6b3629acd95caf5f0ba4f51a815aa997c24e3f55ddd5b95d0043ee4a9713c71e1586e27e5c70725c8d09e60a1c5eff5794a1c133fd6c17a00dadaec76df6aa9f2abec016e62675e0125242a0ce37997e42e9e0b8a95ed2428bf942e874a4c9ac2bdb1ec0f3b74b0fdc8d633cc3487ec2b7737ea1395009cea48ddaa3ce1c38e55a55cf5a57c0d9a1429677982a65a3e0f0ad79375ad6228f2e1d5374baaa3ec5dad73ff377386bc9f3804019b55f17eb180c9e96ce62c36feb68d5195ad5025c5b048bc957b080267644ecbf8599ee3686e77ce3fdba33b710cc6b229d65d93aa84f1f95a5bbb95d8654000a72b86e0661469fd7379b13c97fd87764d9e7fab04c82aef28827c4d7e592c53ef08f087044426c0f0109a22b0ea347a46abd5ee3d56a85823490e401f180ea478af8929af0e6f6e428e0360255bc32fbcf415286e491db38d55aef7281d2b756fa1af306ca430ea5a0762be974a2990c79f90204a9b868ab2244af63d3796958837058f68191ac51e191005ef6ab95484e44047b1f9af3e60499e1bd6cafc9e6caf57407096e014b31b802db3f8f0c904a795c705a2c50f6de00da59b65ed5328e2493dc388eed4f804a195eda846578818042828e0d022bf6ce8c06070bfa4a21ecb415f4f94c5fe808398efcfcc2b9e81cddcb084e44cae82729c6349f41db8e2c17a4b295fc408ea7ee0c252818732942bbc06dae232f6f664642ad1482c97c3f837031629ca1ae668ba8a8b1bf1bdf6d74bdacd05b3b136abdaeff9c182c9f49945e00c5617ea6a8734c8343972b7d7d832964614f49cf15c5e9149699c31faf4f1d1c02f49a31e7da3545ef05a8cb20eac46a890dbbe32cb2676699034cc50d5abc4870801a2d377449713d27ee09bd08b452ed28ef35a7eef4241bd18c3a6cf9e0530282a97b9fe6c74785b21db1ddc302b6479bfdefbd13bd399429b03d75708025f83e0a5be50cd58525b4535adcac9170fa9516d3f3a869e3e69cab611ef192f0dbd6a25759fa051841823af798dd3b29baca769d90b3d527bcd1215afee0cbefaa77f16252214fd495db4c7475f5d31c171eb1c648253d515be58cbebf53282260937edca71547b2889de8599a29282f683f92e42a82f7edf2f7316011b7675489b5ac5c6fcdefdd50dd0e7c61ad5887f4aec5003765dec91d4d8fb5e5b2424583a40cf78b0a25639c7b43ee9581a08cd5cdb37ba2272ce08449c98c7aa361bc0278bf8b91dc92e7b1ac3178ad20728218ed9d3e08b2b2740741eebb0b7d48df9fb223e01ec944e1d4b57357efa793cd5f91503c6055c98006a5bf6f153b997b2c7a41053a2f782a07535fe3d4588359403b7614580efc301a4eaad2c5534bf6cb10bdd367489b55547beec1de2767c0bcb76915807e431e604931d2ace0ff3df1b8942ab9be891c9c1896fc6de27f2122f5e9a7ca562b663f781e9cc59f1fff580fe7da8930650ad7fe5cc1ae9a8434a324b06901a98af168a49a9eee5d2d0d094a54857235791ab27eb5073c074ddb8903d45af15fad80aa18c2ec3cfe80bfd75a124c649481e30cab54df57062a57561184659409ef94ab407043912c6506604ae4f25c32ba9cdc9821c69e73d98fd683159fe416b8deb9816705baf80de3cfa744e7704339ef08368900502b62aa16ae715de31688035e61e645fa8638bc51ac6bbeca54d6f585dd32431a73b57cdce79b340540cd3900da85b314bc80b4b666eae327ccb7b7a927179c95d19902ad03bbe234a6491cc72aac402916fc0220dd6209d02e384e187d129a91e013845a7ca522b2e19f5a9641d7de7d9cf18479a8bc1460af5ab5bf7427db3670eb5726cbb421abff6a56a4663906957055e5799df85d0d429c7bb411576dae4a74665e8e942da3115ebf3503778b0cf67f060b0ee53942160e978006980527cf0ca44e9e06cb7675b7c76e545494b0161502de4e0116a82847263b2ac6a5a39dd748e5763f7f1b749f8a057db95816bafafb400d71b3347ab6cd520c483c006dead9d5c5ff65d4d38bc35ff2d4a37a27e9cdf54539afb7a163714b70d4f75fedade8cc3355bd3971fa9e6945afad75932a81df25b0d664f2c9be90e2479a2b5acaa99e2e0b0f30f51541a47aed0cbdf3ace086173c8aafb153ffd56e81bf257e31f39622a4db022fd088d9b5d4cf0ffe4a55afa1fbc2c37ed1d4a21e4c6fc44f8804af566667206e593526a5d18713c6d31942aea370acadd18050a35985f1c284e9b1b84488f29e9f552164620d2a9eaf7209d5497a8e40a2d542e1746549ca0ae50088c4ae8b54cc23aeb9cd69676906737c7c84d1f2c0a48bf8eee2e871d78e54d0bc66b4e1075a1cfe2167653524d1eaed3f067c9253788bbbc3c09bd757a40b2a6527f2d591dfc53629fd4fccddbe91bde6238b3f4f648c34cd13556d84199f90f320d6abc3f8e834038208678333a92383126a5cffd6ca174657833874e899d99e11b590da4c6281149da4dbbdfea6e59f910d781fe3ccf2b89799e305d071d37daef9aa74856abd881215eb6db4f9543d662ed661a5b2d38479a84ecde0d4a7024cd3f4c1e6ae4d029abdcdd10c167d6d2b3a84bc1e83e6506763a381f5128b31580e6fb195fedabb969530e6b64b7c5c5c6700b9e36fc4973273c3455e8cd2df74b5df6dfafed601f2856a28be838ecf8a1b68ed50132db1965d8f97c0c4cf1f8f45f5611810188d6e357fbb6d49c7b96dbe3210715f484a7199d493fd0ef52160cc43347d1554d3d9676cf3338405fc9b58445cf71901e0c4fe217affd1e98c755117f6121a003d02e7369cdcd2277bd88bc6c3cd9023ff40bc09b7c766f2ae3d7af2ac52bb0e345bb0eb15ac93c925e5d4e21ddba1564270086d61cfa6270c30320d9cc8559e10a920bb3f363bd725dda706b29acd785c608374ed1d872fc19f15689244511ec0bed6d4e0c833a4bdd552ca622470b493f24c52674d756ef327f739bd7fbabd8e9fa6116961565e6a466c892a2c26e687c2e00f8c22c1ea41c9d77dfcff3617f9e18082649e1c1f6b79e931939150c46ceae3e5d98632c08ef79caa82a9a2c7825f53b4374e68526b26e869041399e80cf5d752e68ff9ef67f554452679fa0c9c9cbb783d23eb1abe284959c036c8c8e9db94e80890f5dca318f599b0d615ff01688231d5ec431cdeb9718803962663edd761b30e4550c76fdf2a6c76eb2b873d7a11297cbde39985b1db32eda978274aa34382efd63101bddeec744cbe7a7583cd2cb7886a51a3c4bd99fcc0691d5b526bfb6a7f084ebe85869ad9637275f821071fb7bb8a0a6610a46be684b978dc53ac91b63896df47649a277e73eace122aa7896cfdf01f6d0206a46a8f7575b351fa22f1463d73665c4c6f9256b104eccd9a8781547378c4707df82487ff8f0d010db46439ccd48fe2b46f98c1abca387aa1bde6f0d44136eedd0beb49df2993ec43a490d3c0a029408e3ccac8c18db782e087df7c12598835cd0dee0f369e1c7ee00ce9f51d22a215cfb1f28b3e4577645e3a5c32c913646353414e5ab9ad508da576c35c92879d88d9b724ce3e01c7a96b5de079bd4e3540d76a6ec5eb850e9a6552f35254890bafa5fa36e1d13374c56dc66a9a8be5ed49bce9edbfefd8d010bfa380a0b62f66428449f96d3cea216b5f9b00c3ef4efc5eda118763d3adf353ff66a5d17c90bf8a97e516746fb32ba481a43b75f93c028adce33cbc498328013690d7123515d0b07fe810a660d68b7829b7cee04349274130d5bf8ff194afa765e2a956bc171d94608a624797e11b00d73701e70fc63f1c4f0098f3fb1a6d87b6e128ecbf85caec4a32e394f2441b74ec333bc70ab7ffefa93e97d6dc14fab22b627b47719b5b3c2a2aae26c7c0d1a9ed203bdbfb6b0efcb649688b9af57c2293dae1e41a91a2846167262941dbd1e27f2e200802cfe485c795d29bf4f96d6669208db859e494c9254f9906c0461af9e8754da94ccab415f6244eaa8a8f15964488b8ed035a75972c582c2809126d06d178c16692fc8070397ffb17e45d3544f2448eb833450558a8ed26df3847e5d9675aba24d72b8ea4404145d5694cb7818878a5972abe2b8e3b83c9f94b8fb565eb4d377f48aefd1931e467c32b33d75fb770757d7f5a66bccdf21d4584c074d5ddf1767a1689ba4b13a2cb645d279e8dd6e5fb109a7a6e0441b3c2fcc110594e2d2a5cd8e4de7655a86662860d63bf373beb872d97cbf23546bd8a79775e72aba9b919fabf1462adb482536da0acb419b9752437120b4ea16e32268a25178c55fd2b8134a486edd092149fde959d62645e1c2e5f3ddc23da89437bb74f0366308775e5ee5a05f84a7090400322d5edf011f58e71a7903c1c30a462485c274cc608fd5b367d146e20ecc9252c3e973e98e3ad1e57b94f2f8e4c52daf76fb5e435bc6c638304d776d2fef31e4cde9fb0e521495d0ad5b8dec2a62cfaf7688029b5aa7a6842be7ef06ea8fb4546a6ca5f5283f32decae9f9b36f278e104cb112715003c7e806e73cf3dd183df0efbeaf776b72171db516e83982e53c0eef597913748e91ed94a9c78be90bdd8cf0828999b6bf1277e30815bec9899980f483336c65a4677577791f77d2efde7a99113446c1e38454b74d8fcef1246dc443966477637de8ca81a04e327dca3d8f34e1814359f4ebda5682869f2cc758f6e210bf239ef4c05135627aae5c6927f86ee2b40fa92272f34e534d852c1334c77bba609623d4f667d4ecc6a7a161cd2f0e9c8de51511e5b2c9c97bcb7b11c896682333f93129a6cc747aa49b9728e311cc6df5cd6acfe80b72f8a7ac70432b6f887d80e70a6c8954f1ec6d3ae4fef19384b0af84f8efb449144fc4407e011939d9c029658fe4b9bfaad3ffd7f36b8c164167acadbd4aa6ec02de3588fa27535e0648d7622903ad89c2251b334cb4c66aa7c6cf3dac76194574f7ae91aa7cb6e4e955bcda1b050f497c01134aa7a4bc3c9b5d3c8550ff69139abb72d22a58210f26c3cfa378b480aa0d940faa46c5aff0dcd6c04dc93340289154d8099ddef9e261e1ebd0ca4a8ef3f2f91a028b502941738f33131eb89f587c53bf72dd7ec08b18fd2f99bff171adaa7e355ed4d0e4352721be132f0ac5bfda7e76a1ef51c21a863c5aaa1b1050c82d0ce3f371dab490cdeb39696d8eb559d26e01db8f46a3386814a8a4f7940e563ecd309be5f3e47d4ec0a6426b7edd2692a2e36bf2dd9854092c1f5467a5abf8af834df3becbe928dafeeae3f0f7debeb01c34f7fe7b7d8d651054d96e91d2f4192a80cdd16215f0de7613e5dbeb7e8820cccb87a9f7337854abe24c937d8aabff13d79062aa81cea72fd7984d0ef619d6e65aec8b7cad8bcedddaab4483a583936d9820811dc88f71f91b6eedb5b3cb9a2ff3ed6453d7a10f0fc3c041cb0c88e8e5ccce267f6204877b95fd558c872977e9c16c56b57581d4310bf5437ca49997e7b326b6289440f60bc6981f870572cb2cd8659f805127bbe3f8324ed221b2e11af9658a32cbabe3691c43d015d0f2ae4fd37e4869ce1d88169db1d95da88859e1ff7d336914d0e6ea4274015623c3e645de49d6d90f6b4538d81b869601422562d0eba671e46c0ab1adde1ec65aa9446283f7b8f6ce7329d0f1d303847879374c1ee6f3cd2834826d412597b280a02f9a8e343cc5313c0278818fbc3fa734c549be31412f6be8aca2d017882581418a848e64401049194dd267cceaef97bcb456e80351f286dcc77a7812d1771f555fba5617892b14a11e12be6297a29d0087e044dc6356f7b285bcb97b6a6208e2e19d4e073711d4dbb3aaa3dd9b603e94a2cb0773abfce56984c8698fd86b4d2c44810fdeeb688fe48d55b785d2baa2c4a4dd0fc183ee1290bec544e0e8b90e7dcea3e9cc5b13298af6505e4d34919046fbdd8683912a4ad46cea6c10b0836e3f29887719234d9222a305a95c90535fcf1c851a90471bec2c23ba2c71ceb8c7aa64415d807ebf4062d5af7496e9e84774d3129989082a94db6163d18aa69646e0177bc09bbae1256b6e4c0e0bc67d5a740fafb84013813f139882383a582ff8614a2491002e1ec8195fb188922b2120b7190bc4ea420eb276f5621e6b4d1d7595c2a46b09b0c7dca6d960eeadca9c97f7efd73176812a827dac6b6a27d7345810446ad9c7638f16a92f111dcd68d08dbc9d56ad40906ea75dd43320f0c5648979dc6497e6c5be1c9b82ef4180b5d616f41a9110e4f824ef69cd9ae601676457bf5ce651486b4a36c20bd22519218fd020ef3572adc8c338876b5986dee4187436e25a0f8962a14afad358996e323d824fdda02063f15fc1a0813c5a12cf7a20734cc9b057d9fd3c6d0dcac3a5b3495a9ceae537c2715df331b58ccbca319fed0a2cdec8cd9e7cea4b2b7193d764672d5959c7341d13af511377e49538e0990f9082608b41764c7fdb5e2bba0c13cd76e1e886b3c8e38b6af9a1655f7046abe41b410d76193f1a44fe3c7fc32e55d60b3e982488d18f7b0602eff007632ad8b0f6a93e8e0aeb1f0fa5521692a0aa3d27fcb95cad42312731701ddced9c9a44649a8621072e78402dd31f9adcb7df0cf3e83ed48b245d7e9d3e0b6ea7185c954bb482e29d4704a987bdbde0f63cf710ce88530e091bca0a59c3bf913b4f5b7a1cd2aa20e6153fe63e51f36ff4ee82cd49d5da433d977bdcb8de53d0732b8128fc697d6e3ed03c57b17c49c44fe667ed71601e23b202c22372d8ff7a2f8b983042208e26c456a348ce1a5b56e90cf73e138b071634c11867de2cd61bf896b7336520c86d14886065a2cd487a623e6596a609da52de7af77fd6af5a3723842239e44c1b23203537ecc10e2f1bca8ee6f7ca948b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
