<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"04912b915e178b9d974f91114c4546ce880774c3abde5c2da68c75c55723c5916e5d9121139ae61a03a7ed9bdc253ec114042837cdeaa49841bc1f98b7098708ab4cd797fa9cb827c84ebbae4734022341492c4e8259329fd5e2bfba6b53698b45904eea7de5adf769d0cb94b4023bc9f2088648d54b8c9dcbd93749980c0a3993b63a18f858e9bd2279f0b32123f35946893e71b71262ccff967cedfd465ccba54d66ef21ff9c46e3bef520157cc9e28f051ede04ef1d3e4aaf6a979ea61d5b811b76874de86d39456e0de7f057956f8c49f6ab5798fef41ca5b57bf4f5ffa29706a5b0551bc518ded49953010bec8c17aab9d700fe31b5d913839e08fd33a642c557b82698631ac463e68be3b4c5d78ce6fb2da2df3fb9fec7a32a027066fcf8f44e1e4964e2c67548b33152b57ee35016b52215a518f46dc2d4c6c2e9d7b6be0b54bea9bf2cc956dcff577022aa29d9acc200e5652a49ce76bdb77b51bc076cecbdcbe75cf85d83b6d3003b7c9ad0fcfad26b4a633e7033f172d36bfe89e7058e2391aa0c78660e8041bd543be2217786bf24b4aaa93c794b826c27861030469e8fbcb56d1aeef092032a42c49412c46cf7bea016ef991a9daabbfa4408e17ec0b8497052b44a07eafc3c28b11dfd0984fc5f7e4c463cb0a52476170feaa750e7cd18be9ae16f0be0225cb2e225708eef0fe5d64a51af6c6bc14ff06e8949e939aa10df56417f019aae71dd3575104caacc3c6e1edacfa78b3edc4f732c8d9c519f2a611eea4fc0d7eb52ada6e0ba9c6a4161e7b9efbc0011ed2e5ed2ac6734b6ed5a32cab0c6ae99c1d12d1e0bda7a77defde10ed12ecc4ff8a37b016feb08c6112181174e8a170dae3141e179ea1cfada4f82cd7b4ed183b2f0d114d7044a24b2bfff0664052b75e230755f6ba629cb115da99d5c59c0de5859b6ff97a151de7ce2dbd602a8c89f110baba804e75ea49fdb0efa4557842fc4a71d9fc3f91ab0083db82e8fbfb5a16a4d5766992616eca72ec59301e7036eaf4b688794f5c49a401365b3b85394ca5ffe7b48aed3cbb405399747b4d94ea193ce80cc46d7581ae6e4c342caf7fbe45ec6fda966cbe0cf463f7350a56dd5e8139a243e76730da535132964b0ba40bb9fab474cd4e4a9c3152893991f293f70e0c529b0f318014d97cb42b62a57fb684fb5e09bd864842ebda715284c6019308fe3f62e41a55b416bf71f58eee1a7dde6b9015b37e2c7af360581b54cb17bb70260fb9b532d09c2ff83cb593f987048857148bec416acc6ce94bdaa6303918569d54594578f9cbe786c3efa0635c719ebc27c7053445f24293a723e97c3842e1dc7b609b027a2c8e5656ca1ce2ce2040b62d82ce23b500f5a6634730479626569dd8475fbacf56c39f9d72e2f5b2a63e99acd0b028672b3f6632bb745a1f5d3bf7ae213a81bacc531ac7eb7dfc6a290ff9948d666a4502e8f64dc63c06da296e403ed0ea4a5e2a3544933d28cc9a79ea513b8d5d8a36263ea64f34fb6af84ce8f9889e959cf9b9bf5f569480307860242c40e778c30e1dfe4f364e9d2ce0b65a011711e5735a468ef863826106f5e5054d00e9c5090c9d8f3a7d1714a22397a73be8d6d0feb58455b2022fbee75222f1c45237e82fe25444cff40d3594c73da36ed21800ef7b72a0486d92bfba88d2adf4f4edde2dcd27db5eed53631816bff63371ac39547283866abc1a2ac80aa3b88196ac644b2d2eb5587aa1caac7a0ce91646be58102de79f51e4b6b1fce20a47f37a83a147c7ed1b29a227935a3523a10736373e8a73326f230e4ebee6dc67cb158c2216192f3fa4d0626538484c22681ca429f4dbffdae69d331af5f904ff984c38b2a8b5fcf22eb7bb5f0eafe62277768c683a88d4e8bbb23c6e4667ec0fb465d47a08dfc6f9f9f7b0cc612009b6781318bb1478bc3e2a39b2084239ce062412a02c6539a642dad32b8b4da908a67c88adc90515e0867123de8b7ddd0b9d2909218ce2bfb64ac691a8a855d9890e2fd78d5c86660b0200ea72f26c865c21d4437aa3fddeb7b7418eecf09a5c6b5d36fed683cd1e93ee8483a3283035eb2fa6119e3a45258a114e7823761fa5f316a7c50ef1b46963b835d7c327a32102feeb085b65b2723db2dab8d4980e945c3765f3b60a4b30405e71858f974041b37cea09073b038c9c7935aa22ed9cde82511e9c772b21c2b62a7484ee5d705b7be0e58d3c6ae3a5751cc7203d7b4983b9c948ce9e23145feda4db38b81f88ecf4386cc615eec73040159cc572e8b42755d3969e576ff0cedb35072f7d2246ed7e3a6dac53fefe1ee989b9ef366d32df743ffd9627ba7b0a8fdeb5f3da88b73d8a3a33024bc148751e69b1b010e3cea4a1c7567e44ad4d232361d307ee1db3bb7e4c8056ada02d5137281a84263dcd73e1f4c24da78d5b6fbfa823bfc3862ff19dba2ae8ba4eece1d248c0fa39150d68bc97940daf4b253b351db189773a56011a0b17103e3f0a089350d5eb61f36b5a64d7b1ba48b4d0da6057b80c58214d5495edd1650a576dae0d1957bb30eabd912122a005c755dddb89b680b02d302ad237ce68c5924540106219a6273f6fffe477258febfa286880296ff7387694a22c830ed8c49cc77fc082eb6e1b628986d8f220dbcc28708df5a7997a29f8a9b00d3b3a928bd365de80bd0db208f05040a478b6afbeccbf62c41ca4b55384a6f9629776f49628d8aa1d024e35b0cbc1edd963ba9f4a3ce4468f68be63ece8f21aa1483675e619d55dea000c5ee7af0c193ae95b7ce5efeda08be9264a9999d0790d4f06754cda0df3ecb9ac1ab5af1e432c6b78ec0832a003983fb1400de76b430df033f556a024d61d9165a6e623bcaa247c743ea67ddab32445337a32b929f900f7c586e15640d9b1bb286ebe65eef8ef8159c0ad3d5ae5424a2663a72395437497d4371fc41a1e9d586ee0e14ce62b12b6a8b1f6ffb6385e8d20701d1189d84fcba7de5188fa6aff8cea8b34a1dc494b3d3489685eafb689c236949d45a5c087d1ec7f35c2d9d981da69e84242db730430e702ecce2e8a27c05361fcb4f517763be6c99ea56d60a2a7ad93614c53718f35791dfb68066c884810a0d93cb442c3c20b7e07e7f386b47bb52fd90f5766afe65b6ef1842d3c95f37c5ce5b4565fd4400f2e803e804baf3e99e800759ea5a91446bbbbf0bb2e6de89621cd0179481039c5f0cbd1640386deef841209de0c8d6e1917e5e13b84da0469fd878ab5d459d372dffde74f31d885a75696e9beae0c5b876f28021b893ca95cd3fc87ac2bbe58f3656af3bec30503239f70ec1dfd9b3a7734d2f0579b9ee87fca20f51ca92b10a769e462d1d604d0a1c223e1aa3ac0b16514c2855f89b9e6a5c0297ce06b4a18fdf520c7c03113f071069a9143450f8db0dac922c8398b3515d3fbae5adefb5bfff8b013176f2b24ef865acdafbee4c78f5cde99116c0d97378d601cbd7517a84ecbf08b4a7035a5663c1d02a270f43f57e306eaecc2783af7abd46de70fa6fe9bfd5a179c2a2dfb0b267fa08f8e142ddfa2e1e17a0c848aae4f5b5a17e61d41b20a3583e829160889194c3f8647b54cddc0a741e2b518781b05a5331dcf0e688c2523f38f9b18bb693cc032cf15a2df22b3bcb668a675c2fcc15d241dea165117a4b75c7a6e322e4d48ab6f01533d549baaf690d6679c56a1a53ce1e76f6c215fdaea43b328dfa9a3f113948ba0b3d650db7caa4bc328fd9f1e3206097b76d3afe983dcd4a43b2bc1427b398c44c6c19a45d3abb0a2c7ba0d1dafe91236e0ac874ebdda3b259f270911cf62af4d020cc0597cddc77ce774adc5ce0adce1d1fbb21390584a07545279ba9c7738bcd11874856911a4e975808e6ef5dbee20b76085cc06dd7b87c2250aa04c11f0f0bec2919ac6f33dfa7b426ea098ca77781f71976b4d347f8065d3d71cf7691453a1228bf78b35eedcfcc44069c9a4ba331746928764fb830130011d1015545054d60b084e28fd574c039c856afeec960b5efab52e36cce2f9757d2d3bcef730e1c89ccebc2016161c57cffd920bd96f6ae564d236722328e7559272ecb2a3e6075049d2c68cac256c26571dc06d9e03826aba6c8e4ab5e84683b074c80e0410015a3d9866606b208f38d6c29cadfb665f17841081831dc391c211e347dc19130686812f806cb301094fa24f5d7ed717e14818a4d350535a739e0afc37dc26b4efe05436c571ae386df370fccfe0fbe7d75742f606c9a7e8590997e925ab5ba28b9a883f0e881026ff0efa1960c99b87c363bba24868bdc2ce02c38aa5c2e92f36fabc8c6db1b40fb1671c54c422f1d0858599ff251bb0e6add6c75aed7963b70ca2eec16b06b4d68495c214189c4e4c78abdb9587dfc7b247f8126605f70197de83c27eae1bd29124a8e837f3875e8cda4b2eeb91300da742d91e5204840d149e4941d73080e5fc009f931e4ac4621e12b0985307ea2a823137c7acdc195ce94bf4e92aa428321f1caee210c8edb58267cdd122b302d466a4e8839292da59fd1b959ea5165788e4380df3d477006efce3fb698e89ec2a8c90cddce656279e509120482a773784bd11302319151be3bc8c61094a3ac133d253371be73061c835860bb3bb3fd23ffa33c738ae1b6e19151e46f361d5ed9dc6ce8524e0c9ab0f1d329c7071dd26db21d6bfb4afc9788ccb1213db4129a53170ce2a25dfe96a6de321e8d8a121885dfddc545258394e698ce995bc97850249cacc9de43f8afb83cd5c55b2cf860a185ae35c6960f9803a58d44d58e318c5da27d121c1c7445c37241636a7fe9e6d9b97d36c9e56ac92c82cf7757cce7204143e32b779aab4cf7f382032656f0c4272e7d1616e71a50f20c3377c8b1ccad87b582c5cbe9c7f16529c91fad3cc21bfabef31b0db1bde6741aa5186fa22662f1418e3d33e79dcdc2d598166c4d031d7c5c68c831265021472949ceb96f88185b1f7450050263364d2609b1f5d3562635130fc52e5ddeb8621caafb8b6a375b81ff8efbcefc165e956a2e4a54536fc4bfec8e14a840204fd141f9e8b442820e2131fdecf58f80e323365cf5ff0b742d1454dd6ffefacbba38d78a11db58bbe6698cd8b77e2232536ccccdedd8cb3696a8f1bde1d26dea6caf43937ac88bf13453037f32ef14847d7aceede83c4b84bfc75c15d8b59fcc5b1187817ccf295d8e2166d91420fe84eb9568866640e29bed07678af6ec4340b5438671183476a17958da3753ce40c7ed47b1152fc9605fa6ce39c95fe42a2c74df9f5b86ef1fe9642e75a7c9ba0edeb379f84069664ecc4ed023103bd3d4bd50444b03a2ed3293c660df71909e7622cfb245485a3597c3fea805b0ba91d36ffe99f60c368ac9d1f23bb3252c3e00b60ca550fdb055f72e83688507285be8ac846a8a5f24b3fd5b8b1774c0eff45880bad5b15b46437c8155d08e1906d528dcac1f807a4674f7d9e9d69b2e23c5e0eea2f252992cfa6e4b26cae878f3e060ec80ee08b831719d54c131bf18cdc26d47ee585da043524c097bfc03d21dd79c2b82b5c7e3f165a816ede12e1a344939d186fa82142463f8b3725d7113e1bd51daaa6ace92e3dc0719d01a293f98bcafdf4232554066fa61b2a2809bba10058e50637e22b9ad189c0c4d0e7b9c2700193ff1bdcdca7ca37d1e3c94b8906f64fa9e95a18f65c1b124f5e05c4a08dd6c593798d32da189866be37756f224d2d2332d08a4ac3263413a5c8f0b167cb3f5f0c3f01a3172a6ef10f30779ea35f4ae753dd03eca3657610aa86d95d5a4a9a8b9f3f3d85f2162e2ecbfe7635c8d6b939d56ed97e9acfe19c90b3aaec4acdb0231a77532e302bc5e2bba9d84a7835242ff7c6899d4c1712874d4208aee0a95a6b8ceee61754edd4f9d986ba56626cf20b7b05c10363c66cbd535a915c86ac87137fe528961f65f857662c4ba0389b0fac84346cca2f9b8f87cc814671b42f2faced463aa5816963a15a1cd92f5d6da4fe813054b862ed6b083501ad4bc97df3f04b2bb4c1ee94940955c76bb847a256dc1bfd44167fbbcb089192156bc4ef584160d670ba59c35d8ad387745d41da83b829ac6eb39b4b4b333cd47830128fa3e81f5b3e2040ce4b6380de00ef984cadf689adf02c29b6bef4068a2d054a55532d47119c6cc3aeb54764c60c61271d67bd8ce28e20f2c33e1c4ca1436d8bf81c44510fd90a0bb8b8eca14430fae6bfceba1d2d3d5b3833fd5e41c945e7efd51010a06d79139f48e04bf5b4678e2deae4c71ae303d357b3e794b970e72816ae5fd4679be8b0675bf96a2ac7fc6b2720aa760c64ffbfee9ff0d657e6e2c1793a2ac159c666073a6001641c1800b81383aae329be0be65ed0488e2bc0f2146aafb23256945249f04a37385213c4390fc9247a0e4a6a1960d9d5d60e5fabce55883209425a332f6b27a3c329dca52979f5dbaf429453fa8dfc7cf1fe01e6ea0466308273c74d90de1a4dfc2c0bed5184e6013d57df51b2d5fd180f1c30cc53f479ca39d2ad88c0e7666846c711c4e03d101509a4b57495e2c47d82db9a3bcd3ac5bfaeaeba7fd926b660b7d6cf21de2c251fc8fec43f900980d55f0edc9a559612f6725ec073a1a60b9fe8f6767ac886d9eb3a55fc35160bab44ffbf74bfe9048244dcb88b69e1ac7ea62736b8c8102a87beee8e6da9d6018fd1dcd2b9628dbae1e7a4240e6e3e6e07ddbffbdcda76131a9436b8e1707081b2662be5a9759b6bd2b9b804d61c42d0a1dd0f9bbfa9e6e26463a4a57248c541d66eff2da88112aee3d0f522a5752b6fdccaa1deafab90af59f8b597ccc543ce275a45df6e9d759d813c4c19c0e5172515e4ef2ad2b0f8bc55333914e012fc20ed1b5a15e0e64605e4702fc160296ae9eb36cce278227ef45d95bfbdee12ac6fc902013f37bbe64237ae42d1aa5363d9b2f7bbdac78751e772c249e665ac77c3bfee2a7cad226c507cc270d68f3aa0d7a1ea8a6f89f19cb656652f8986179f83328f6f405cc61b2a5372f9c4d8aa7ed38ee9b88c4bfc327e8b469e42b45f916731271cf009ea7ceff3d080a30709a838b7be496381da78cd22b9c07e68f127637a8754c5ff43b00c2682c3f68879eb3d1bbdaaae4abdd4581b5972599a557958eea8abcb007371434e1cc4af320cf13fa65016f044c6fa4b45a3e79e79290b2242cf0b16312e7b6d5eb78cf2bad1d73512cfc4eff0614bf4126ac18d9c233f7d78a4cbf6f845bce606321f66f4cd4cd23766bddb746ae108ecaf83bee27b95a2b5f115304c4b09ad4ead00601801db7b56fabe91ba8dbb8c030ad6f363b4b3268fc9284c4b0a6fd3bc92923e0d5ff2195c7a52cab46628ccd7111c31f41def38c2655c3e3fc434e032b9ca77f64429dbbb3061c4f529d9797fd6a4421c85bd37be7cb5846d163d9aff1454a553185ead9fbf6029b46c1c5e3d97679d346d7c43643cc9346508b944f7bdb7f321c1dbd5f2ca7ccf306b89f49807d4bcae577dad1fb1cf5a99e88f05fd1a276750889fff52eaea58e77ec7b61b9500188bcdf78e483b85fc0fad2cd1e649a6ed9e4a491b470416d2d732a5dd7e3f84c5cbe7fb27aecda0331a030450549c07ab6e78251cee3527d3b529f06d45733d779b520fd19c6eb1368326859627626acb48715b7a6077934231ca166ddc3539aae5f29b9adb7ebbb7ca2ab7fdaffbf56f03fe0f142378e3f6408d396b7e02ea4e8b54dbc19a699526267db9d57ac3bbc5783c7509db87a45d61097e9b95320a688246e00f286cbac69031eb683103a4c1a9053c946c5374430209218b74a44d98d33115b9fa002a0caa44860c584da9b2df46ce7040054cc813a49c217d771b9536f250de352f7955ba762e0fe932bedcae9d0c04a3f99bf01effd64915bff0371cdfdeaf2ee18fddbb8ca18e35ae70fc3b35c50d335f7aee102b3bcec3d5102f765a069985d6d2bf205049c0f2487e70766301a7da0300811f87636a402a54f61866d80adc6b2fae49014bdf39b29faa43393d6dd14af238fd65e83cebaf79d75bf016d916005fe445f4f0a1ac92f6c927f55725480ee5920ca7ec56cec2b5773542b2506274dac1c51d5aed3d91bc4c1f2f6169779f9949e63dbd6c97cec60da281b1b49dd7ff508c79f2c9ea9b915a252fd4fa3db837066befc843255dfcc868bd1a54577f9a49ba7943a7cc948b1e24c5ba24be661096a184357e79e81ccf4300305fce32cf4d92d9989a3c612ef0c7febcdc04a682477e2c4a3c9cd6cd4cce635662c8f38aff2147ed9a2d371bdd2b8a2f6eda72a24666fb40f788eadf64e17e78c1d9dd6e6bdc0c9ed6d6a8529cb074d3dad4e269f402d31f85b2a9e7ded1ac731332df2f76e22a0e68cac389c1d11afab8214d1f8471e107e080950cf1422830ebd414f2b50b508232eebad3c1c224f23e90ec24fb7ef38f3c127c0391074f9c996797b4534e27c53e05adedb2f2dc867ede1200fbe987faadd52056c3242aa569cfc6d351129cb882ca7800df0644c2a66dc8a1072323a4923268a6502e6709649935fedb849cd10b3c945bea62a00303459da778c2c4eeceece3838ce3b479eca644d095f740845e23510ef22d6e0cd7678e6d8dd714de08ff221331d7e7b94ed644637ce5026fa85463d96cf9e6f9033309ebfed82e6fd19d72fc5852c196a01888d5ec0fd0ce95a763495138f8d8b3e36de6dae970f181ab42b29955b275bf24e8c2cc9cf02c587f34da94e9a13f0a566e3142ff142793244b46dc10a05018f30fa766fc0640a4fde40b66caa1c97101119321cfe4fe6d649f798fe87b62c8e343dee0a8db3d64f9b0612e6b16982057857bf30a9d86e82f75cba140cb4483664e12bbaf91351313646362c10225604a2c5919ecc72922864672c2e90267eb3e670647dde28a7c631bf382d77d4d3990cbe8d067df46aebe95e380d206ddc61bc98f392d9f336ad36bce99871973377a829cbacd4eb6e9de000aadc6c25f1ffae0f793d6d9a88b21af3e889f8cc8913f4673e37bf144110688dd1d105ed6ea14658044194ff9114c3f471e190f771838faec4f8c5b5952ffe3f2135a4c87d0d1b8092c64b1815700b2a63269a75fb7ff08df376e2c41ce47236d40d5c0468ffd9ebc6ea622ddf7c2e45cb7d0033923e3c921a163bb89a5a17df2c07b6ada0d4ca2f775986fa4d6e1b916311db320e59505247a1a43f53ee11ad86fb3f9394334a87a7cae161a7bdd0567e5125e066d7bad8edd580145cab6009c6ca35550f31de64dcafb05197ac1d764e97aace99f5be3ce44408734378938c9f4da7e93e5b0a51f49414f5abb03e50e51b82be129b0a3fad0b24033e8d3682b108f1d01aebf265a973e5e3bbba7b1710e2558393069bcdb27e545e0395278008531e6b3cb23f62e6acfeb32f6257bee2d933bfdc5bf722ff379f36ba5351e4c6778f2881888a644ae5eaf8c178abad272bc354a67ad14882454892d53f3c071ddf10aaf5bc0960d5be02f4323dbea750bfe44b3f14cdbc35f001a0c4fba85d635b9adcdb52af1b9c039aac4f21a4c48be0fad7c1c6dea582e120dfd38059c2f2831314d9938320f9b3da85e3566a99fa0b732c8a104d313a3b003ef00a8fdaced491f6ad7db6015013b87126387ab3bc19a2f1f95915e645cf2884cb82db127394e48f63de71739c2431ef90f62dcab9114f6b97d03bdb8cc214c946cfd1af11fd52c116967d3c698aeb4e2d3212b9fcf6905288c45d42b1ddc4a88d7753d1283a4b05e5308e85a994a1f69d92d12f024615c570f4b75bf92234e98cf807eac106765729febee9117503cdf64ec31401867c8db87722a436dbd936bed627f9c4f028767dea5c0a1a2502438931fa2f402449a71dfd7fa5ec3c5101c8450749fffdff4b29ab6fe9ace1045da4b8f9f319ddfd693abd0005c5ebb295808bd1a67d6888d0979d553a3ac1a595ee74da2f1db1069f9a0c0fea946356a3bec6f816f4ac83c188e261117afec3e1e41ef467455ea7ccd3f4b24e2645ef0a2411f288f42d762425c873915440f78a7d6a58c95053544df565fc2d0bec255ec600837a4b124c9b4a98d77910092c608a681f661e65ee7735ed38ac184549189a0366b72cd6721f03f36c31ad0761d5a222b0b92797c95569e7121868d9e4d24bf422306381c66925803ef8d8d8126732401658deb77d5ae83ed2887d9eb4771a2c2046b94da03849b817967c9bb5d492f1d06d6ce01822261aa491fb244721683ead807a6d9869c49e0c4bf97c9f87757dab874184c4e7556397b69442000e2920c3c80b3838f04dbbf9966bac24fd0d1993df422ab1a9d281f066f8c9df4512a8f6040144d8890a47915aae06e2ca202bf50bf62dc450b3092c92e6c090563f0535a78b319e94bfab57009f6b6742c36b5c7e10165fd09fa8399dc71332535421831ae5c97e07fb8374b8d9de83cf27dc24498236669d3a58b896b639c6454879abe02027b94ba8ef3150c23ed89d60fbeeb267dc7113c7918527adff17133fce105888db36afad9420e421d2ecaebd5e2ee130ee8ea109b1d7b5b07c320c1bb84da2bb066f3e2a677f5295de1e4e43909a766faa08f1134d4f965e0aebe4d77be05ee973a54d797a8f207e95c68740db28701adf1da0a0eb6e82e2c5bdef4308b3361cccdf3bc5f3b4aa458cb5641520346f27f9887b15faec51385d6e54b5de0fa04555e2df49eb7188b9e270ced3efc61620e62a4b0d99b66aeabae718bd7a6732c8ffa88c07fe3ce000424a7ed7c97f9ee7527f9abba4d564bdcf5f5f39601926c2b11ef156471a4f40b4dd31b1688f0eaf602c8c9bde3fd4affa8363b4178c75b22e210210fbea4b3899090bbaa96445bd4390a14e4a257f84a7573e6b7e235499003efa2704f7f148c0959bff05fad68081367adf6a9e0702d679d6cd05723b6abebbb70016f8d463877b16609526f9d6add6bcb3111a037ab0e11e64b0f60567fd552afda4b2ad21e411c1d4e651633c2439c626b2b8ec65c3d0264015e92e3848468c8346ccf8a4a9ae0fb3b8f5d26e54cd0e8ffac5a25296b3a5736c34d34ca5bad414618f12c52e88ee58330999c845007f1fb2d521be5f25456ddce60bbfecd37e0dafe3af2652478726176d31f2504620ab8480510194d5e7dc3d1543322c477a6d08b3a9d64f1ece2dcd7f602cb5521be1e2598986688f0aeeaa275d19a90813e460d194293b2027a3262d693aa189f54a52bfeb49c893076e48470e6d4f74b8d89a1220039ee4eede0581f020dc589fcaf3e70ce4cc2e0279e0c58c30dc7193702eba74809bacc520f6e316d8fda89478347c1fd337586a5b2d0431879fb3655ed38a79837e613504a50f3d02200f093abf07fae811e79ee2ec21a48c5f04d64a07745160abc6f6079e0bf6a730c05613605552cb8b0a46ee84505952edd6ad4e5fea4e53417a5b67fafa32f369abb979d5b99f0a481945ecbcc24148194b8e66a1f90da675c21277562146f6e6d2790add8d04d6374eb3adf6be30308839d92243947592152ac3d0b0bbea6afa2bd743ed58904764abe8f41af9398323c3e123cf9bce629637e05b2c9b6f128bfe5772a3376dcc8e7d545f12509f5dbed008eaf88bce41ee93a75d6e3373b8da0559c32b1f92d743914c2de52a01ebbe152754c53b31e6abed966e0ecad87108b595e4f1791156be4ed026277acd89c76a3101563eba0fe08f59f077fef3debb249236fa8227c6b665cabe65379bf75322c385bc72dec4029767df2ed208bcf3e34167bb78d36a40cc151809250b773bac0fcd6f2056d4fdec7f26917a60cc165a6edde21b8d45ee4e29d906eb059e4274e8dd7e249980a380da7af99cb0beeccb7649df4d4c4b789e643e05306575c680300dd8c5f8b4dbbb6e8a26807ec080289628140032656ddecf3bbb33b6cd00d19cb167c50dba31b148a90fab11404d9da553f413fc1ca42908c83ad30e299322961d344fbddd6a472f6a52f37731432020d3e391e2178043d120c290c8715719be820db47c33549e6f0ea803f24ff2d8fe11aeb1d89bad748c40a3cc070fc330078026f611f660423dc42ad584401053f7691c7773508e9e3367190080bb30d057fd9118655fbada81695b56d158935ed21e3cd75f761faddf946eb557e8efa216d56fca7748fc43c41e41a24bba1e06ae4443761544145eb1b401104d12de5426c4ba75045fef41bdc8652814aef3e7e5af45df53ac0003c40213de1de9c256240f68e12a2a5283bb05f4947c7940872013a8eacf877f2fd4a7fc43618fcebc9dfc76b83f855bf50322a9e5a1516a574d08498df9ca57537c27270d0a08a919783e1eb8fd1928100610377d43cc1a11e23465c478159a64174283f5c79cec3a07d751b4742662219b13c09628a49bd4848d628dd487c88d82e55e98eadd9051f3f07ad1650e96c7631e93aa2bae96471296a772aa66cec724dccc2a5f4379df3b5172aea9de0d2d6a478b5ce30ef2c2a41d43aac5acd0e70ada17a5ff0b16dae84e94d7f89eced1b31d1249018c039d61c150489d8beec09d77f21aa44233d0ca5fae5bc277560d8a320870122b0ac138ff83e1a65712f2cb524bab529722e38d5d02586cfce49edb2c89cf1d0d3e7bbb3ed06d4f7dc39cd1a40b71b552e928e6fc2e0e8eeec0823c4bf84d9556cf3b089eaaac7bb1201285d388f4e2b82b3abf919ba796ee8763bbf95d04066fc4d6eb2bdddd3074ee260c50d70ba8d9a3fd78a5801aa1cf4a7437aed7caaca2a0ffa4246de964df7c3bed4feab7a223c33008b3c4ed59b330e163905ab7413bd3d3c01dc396068d3f15f2f56f06f938f8931ea68832a2f5d8f40b12a4f4e60d3eb9c81f2afab5714beaa1de3fb03d23141438ed07c33ad1520685be157dae672ba773de3568e6eaeeaddbf6162ee5a9921fc5a2666e873797cad95bd707bf64e42bbf37a2e9e677aa96937a3be2a1b795e9458abe16fa0ca4c27937a9679bd8368cd677033a94903cc7df7b62ab1303f3ced76ecc6a635b0df68f60a65e44adddbd79243589904c46142058e38375f69019f94629d3e6bf62e93d81fa087d2355b197e5736380438d8466f71dbf1057eae21171fdde49cd936d1d44b90fa872c8d61a2982a89e2d7a44d91f42c3229993330ecd8d7539b910d36f440327db3d04c71dddc92f793394c44d8fe23dbad423385e07728dd59320fe27650bb1d132141847aac27ecbbd28efec0f8f536896228395fbb943be567acc71465ef36b575991bf4c091b98c71d8dbfb2649849caed1218029a00347efa6d4438eb88342b15738f5409fe107a5374afba7bdd678611b2d9d8a460b1bdf4292fed0892384d67f310eab875fc6723f558bfcf19fba2bce326095bc369671b3665ae0e11012d9fdafb928880e617878587891d0a2b1a3f62cf0417f566486db84521b4f6841bd4d5b11f2a529abdd64fdf13e60f0f276bcdc510e5c8339694a34ec5d4bd526f394cf1bd71dfcf8b4fe77db3c3d2fd124749242df722fdc2344f5faa825b3526fdd1b4067aa19fa736fd74493b924af67a3a2c7501ea67bd8ac9ba8612eacebe2d4636ca6b2dacd722187d7fb81e007f8838e78883567daf5f68ba13d174c31c966b439a902f82ec82f4d5feac65c5c7542f7005466ec6e9e3bb322f9ee781d47a3d75516e48f1464e72772b4a83e5514b5306d0841a136f0c9ee55f7fcfe6bd0f7e58ecb52a361e204eb1a71236647981e4a22bbd5f56506c085c980240522a4cb3d334193d27d63343d91bb0f0110de2f1fa62d2fd260467645781c36beee42e5e365c7888f394576778c8e0d21575b2aa77f8c6b04801cdaab550c7774a048117507db95e0bf12556dfb955d155f5bf7b4a62c6906114fa2b533f94d163114ba873f4284844c031869050db953c17ad58b10722804b2fea12ff6ec36ecea9bb9e810b6b9ba3c98ef6306cbe7b6bbb9954f4aa979c16a80d29070dff34cc0e2c14ae317f11239a10b6672ea91e3716c4caac6b76cd22bde328726d3434280e23e3bf221461c3f76617e45944968beda097ea722c94894a5d8c1c4aba181c9ddd28baff488bc80cff4c12e7d09aedc99ae5383992e97410907e0c67e648f9556c01598044e49be4e6bf7693f526b0ee403dd9c027e6fd2f99ce71a9e8379400090021e5e4a5f045366b7d40577c4d0236a917bc0539efb803548b21f3eec5b6ff19abe8be426ed9354cea76b43584164521547e7301f1203a7992101bd797a49402455cde2f3368df6d3f7771f7eb5c46286f07d58c368fef66380e7875c4f921f9037fbb145595570e5273e5bc1358288d01bdfce8f3fcfc2e1771cc627699f382c0ec65175577c3bd9fe1c0f4522313c56ab9343588f0f08683c39805be2a7cdeb37ed9fc0901275be1395b7b76f96101621741bd710c61e0561c26764953c5478c4e5a2fe58bcf5b830f306bd32cf0964646f6b1cce6a68f31aecaf24af20cc19af1b36cc6b0942cee034c80bdcb859f2a945bd97ad30eb55d56eac4b60f1df3a278983e9f48d07a02abc10508ae32dbbc7bd7e8a327bbd2e40254cf67334320d9ab03efe5e814de32e5a2c2dcf17fe931ec36a3e7ee168dd5524e27202e466dc8f09bc0d9c6e4143c290233c4a9650d71e7133714b13e1f1a441659a3fa5ea6281a30f51d0549f7ff9788cf43773a4aa827003e1525939115ab8fa67f21423e6f866d4256a272260a3aadca28918eae98e2d0e63b49894ffc4c1ef77e901f3efe50c722691b76aceeedb420ae4c0724b60e492423099afc9c25f7cadfa211d5a3ccd2214fcc785a1a668392dec655ad58a3a1efab9bae418610587b7442905b28c10617950bb0b38151eb9e969c3baecbc4ad288e909013a29d67afccd03d150eb1a4b328e6dc7215f16e6d32d0483c5a36acadaa591336aebf45e312b68f19a4b38d140d327a0301d2048e887d21f2383256663c89ff34533d3ab6987b05b0162332868eedd415cb02d415de97351ad41adffcb4b2e26a9dc5f8fd86b84dd1b7c1428a555d49a5cd9e3ec0feb16aa2cf78d80e66cdbd79b6102079fd3bd84e13dbbcd1e57d976795df2854232cb9cf4fee8584f2eb6dca438d87de2c970335b3862b29a48eb73ab05408f0eca9d1871760fba7b50463bced2758d7ce154c87e581bbd7e5ce235a6e40fff01138bcd98314df8add457f29b5ecab73616149b3d2f5d231e7d32ab37c6ea901a368e8448a0797cdc54458b43c03971bcda065c18bc9a85e21f3b205feda1ef3477e54e26882892ddbca673c46c21d520fc3e8b37f6b9080a44e645fcb021a475cb7ed7a2fc30bd6ee81e5f1e3a6001f1016eac3c906bea8b7ca9c6b8d8bcb1d5e8f63fbe03d48fd6f86aa7e3f3d0df84d32242df5e7a303a5b27cfe128760f33d3b31507c5f454b22f639cde3812de7122afed6160aa4cae254d7b7b87915713de1c17e1b69203972d957fcfc878ddf196dd86ad86597f1a47ea7da52a727e31dcaf35aa7e98ff204d22c55217b8482b236d41d76f11b58eb0988546d3a5962dd21997297aca9a441579e66ef3b312ecf96aaaeb056c9e57caaee351b620466206b239957c88e5e7764800fec3b560b2d4fc06a65dd88d98ae088b963faa18c6192c9973171310f3e16cf90abf9009b56f17246bfc050d076e8f0e0ded944eef429ce71e9de637a202d1cb1f3b86eb9016fd3d4472397ef00eec909e4e2dc60d76d3498935cdcde2a6dd280aedfc80be5669321d222b9b815089f5724d591e07062ef1d051b736fefea2d28890db5a576df4722bc0e509278e08c42b834b0681a9f74c8c9a00840056ce710af68040d162398514be26ed2608b5c834784bf3f23dc7348b00344dba1b6c61036c435c08c7db8ff0ab7d49d626becf252910896f31039a613ce38cf0c85ab5180673ebed5931939c4b4c3e87aafbc7892b6c314ef184005754fcde9e0649fdca79778280e4dce7c547e881fecc1dd51fec7910681540f3488c2b326abdee9609c43d8133f8d962e19eab1a8455e29c9519cb28609ec643fd0d1dd1f5048efeff55b1ec850781b1e93e0896ac239f9b35315e6b740215269daa7d97b6d98ac4e970cfd7d3bc5acb88ea9998d6b89dc116cae2bb6420054aa9b4575366258b7721c6509e569aa04d5608d51f57d9ad87012e3939c28c74e86a90a982886e7d633ab2dc00863ff589bb4bfa929b8cadc202ac1139e650cef97867f4c0acf5cff96ae54dd4ae942ab8bc1afe2ed7e663a64d939a785a0075189122f4d1f50d83b0c68f54310be5f27a5c441717aebc126a77c20e89e95f03ff7bbb2e16445736c56e951f4e668a593408f2b85b22d66693dbf821174a703d50dc77cd6a5a05bfcbd1d52a0bac7656ca38a08780eca116403d4fb02a9f2812e81330fd1667dcab69bbbb9e241607a8ff6448ee1d84c555e5c437a537eda1258e1d9d1794f1b37976cc518d99a18c2a0bc94b1b530816bd0a4cb4c46b07942d1d6eea361e8c6b72f068bd7907b47a78f67126c72e0436cc2d0a6e6a9404aee779c95d7e19e512f90fbf5993bde075972d0c0a0107324096672f3d635a9238a7e748a144f03d1d65ac0bb62b69571fc33706619e6f9766d4fd9261b1407d322f9db4231beab28ca2ce6be3bc87b8c5561cca3d6840258c0856e2cde70b42b79d9a1fc471efb3b879af38175f517a2bc834427d49983d015c9417c55fcb8b0aa786cf97551d1490f8e63da8657dd279d59574216354482527cab332365d9fb9c8a9dfb232cfb0cd5a254127b81b8440899eb94c7ffd8391508621342f0ee077ecb712f2926ecda7d97a0190a5d5343ba42ea7ae7f61d9706e42d6a35eb12e18e2ce0cfea61dfc62cd5d5863332cacbf7c5478fae38c8bea8c8684ee39d5e42c09b4686d3f77672f6a0426381d0d702c6d21568d46ec04bd92d6e70a42beb7e258fa2b20f867e85968753370c2e28eb1d56cb67daad8dc572648288ba748987d660518e522045b09017976bf549eddb02dc9230d6672473058c8afb2fd5140f78cca0008c564657519cb10b225ea8b70e8e7ae03c32b7fdb191c8b8e820e57ee34e0458da92dd9a8a14d2a9af5d594f9a5a09a0ae0904792e9019dec21bcbb9100f0a580181918133024e3aa2883ada24a54798e4f30f2c30faf1fe76bc1cde0b239af0735c79ac00634992814babe979fbd61557711e8afd3ba7a7bd04594dcc57dd9c84256ff0683d232d13d4b30b287584c1339c085f39b6d94c4d30de555a3cac30cbf98cd6b693caff79a9bbfc69f35977d5e7881ef8333fbf1655603cca0b345eaf12c61c5f639818c1687c95ab8293020b54f67436bd5007259328291904bf3ba76537f232b55881c97e970508d202b42f5a3e1e97286dbcee7009d020302d9c230435952a56a6af4835f23c536d7e175df57163341a9d314f2bfc3f122e46854937b367b1dba028f77ae51725bf0ec4c046114cd3ae2f89849481a38ef0be04434b77b18ec4caca66f5d8692391567c49043ed0ce95cfd7724aecf7af84761490c7c885eca870943dbd30f1c99b005527f0984ed50c5fecb928861c20a542d1f2b707f126882ffbd2fa4ddc5adfd0f6a09992befd6406314c7d76381443765de5adc9f786f4108fbf1098f3b5a7c9f2dce6418ecb4c85ef0395c74d4e8971ec7a504cd1d91c4252847ea753a06259fd494c6882fdc46c3ad7ea0a477bcb4b1fc12bd6f60eb438af49dc43a954fa29bcd8c8d4062b85462dee13eb3a7f28c752c52de5e051aa544eb6ee50f3cc4c5f1647bc82993a57762ab351a8521e4d5335e10bf067f9d6e4d3b20bbf49f733f8137c709d4b0c7c627e753cc7b3ac31812fea3c48b58b8d43cf95b1d4d8cc4855acbea8a8e565ac463e8323f10c339eee5c455ef3b0b9cb0acb300231101835b93378cc34f915710012f5a3ff1db9e3f185baf4efbe18a9cc4f4309a95e375bf07b20441e22f4e19dbe095b3d1e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
