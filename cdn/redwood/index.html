<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"3c37790b7e5a31e9958bd84a0c057a9ff53bb02f848edaeddac206980fd65d3b35ef99212d2b9fd175d871943f35383eb15de7bda2a7364bb7d37a4844a2432d6c9d4c2dd78f40ad9d5eeab45bc6d71c117914699836ca507510ac11feef5676e3626e5e557867d7682c279e767f036f458dd843842da5f40dbdf182dd2f83d0f8924317820d10172e48ce8c0fe7f6b7e047f7e560ae421e59edde4a72ddb5f4c41825b08e75b2d13ab5c289039636bac8b1d3deeb8e8c836c20c59e6f4f4d8a22fcf10a5e646d02834b1466ee7946d4efee4927af7ca1c43d1768c7ead716583ad64add7fc2a892c3db78d6b6bdd23a4c9317146ac1af1da9fba47f531dcfb25fb2c073528a76f9d6311996520636266a9329e892eb9d6c37da09dfb384736887283f678db5e51e7369a66530e4be2b4d0b8a59120b59ecfaf60741c58c7a73dda3cf417331c3080ac14397d6827bf360ea1050f4298fa7b943dbec500a6994a20e1b3e310ac8f98ca03368246773eb53ba799d780552abd4e775c577e7d387b1ff519f8bfd331b5077631939e465426ee864f423f3772b9668eb62167792cd9d290a6b84120daee121e8eea14ef0fdc2b0e7fa8b1fd7d1bc41b3d838267adaa9b1b3d2cac1e77f43799afc4a9d6771da3008b933032eb99564e2e13d3dfc71c656795ebf7a289b9cc637fdc6ed924705a57f8496647743b2f91744384a031de6a488c2ff5728a2d7f3be94ba121ba8523970bca2ddff29d1e9f11fa4b5a52963fd733010c9cae920dc3409af3ed5ad2781e7533deed5ccd08475b8ac342a969afe660a08eda066c0df7e3f705156bef4972b51e5a3693e519b80c67acfdacc6d913bc2ed9ea0a4bcc9cd980f6c80403525b36a83d9b2032a2109895e3f9a39e453b40bb9243d3a17cbef3438dd387a6bcdab1a042163df74f0637d3c4a85faaf4b0a1e82ff371ef56eea05d138439fc5a77c0ea22604caa051e4abfa19b1cbd4a5849d0d672a88470734d672c6f869ca52a5f1ab1f7ab08dc684b81f179b0d550376182f5cbfa74219ba797b6b5e29cf80e59078f13cea7288b7ad0d4d272ccb14b4aeee4d4880fbaddc74dcdee0818f2c753e65920c06c2ffc845b8ef5a0a83af5bd86f4157a25a6c817e4c9a40f90e8727d052b20b85ad412da38b716372e0ef5901e711df549765e80f45ee2902db28e47415e457142ddf54ee0f2d906e9bbf2df2f97626aa9febde99fc4005d6655ea1ba4071fc0e9cc7e3aa493c68d115ea578bd60a9f8410e1aa20c4313a56970b3230e9c894637a96cf2ef17ae7da65b3ce51f54c244d90ae1c391bf8b776bcc90e26a4de0a77ef5d33ecbfac126cd029a822b2217446c150dcc02c20006063ddecfc59ad342663da25e8e132440a7fdbd1db2c0fc1d94e062ec10675d9dc195616bb93c429555df02069692b8966e1c14fbd55670dbb28d6d658d977e4c24a750073ab1e32fd04db8de6fa5d7cd3c6a8ecf093aa763bad65624c486707ee3f8be29c82c07e25ca81b41e752351d3c395593d8fce2b932ead3ab6f0ef4970da3992c6cc7cf35fd50d580f93dc99f3da2a724be47681dc6adc5527bd23d23ab320b4d3bc5b1f97a61e1ef3cbda845edac8018bcefec8a6b24e658534aa9de5ff9347a827a729d013306aa5f0e0bd48e7bdf8624a7a4aa6b424e48a8f3ca5332490212c9f9433d9de324d49377fc7474a9b8b94eb6c9b09536b08a8194fe85f612138332cf8d6dfa7e53d8e9056ea48f71b07b307234ec2eaf08dcf81e644303522b4b4e028cb3b1415e6bf6de3065588de1381f7e0e757b64fa78c6f913a2d4a8bfbb731ba1eb1039efb788348e83494c917e9fbcd602847aa41a900f84481691b84f71a0f721293ac1231e4caee8206364052c9b337ee281439b079a1aee191f7200b6a4309b646477b0ebb9b308196004724b50d6d099aff32e8e73fba82376557a4bcf07c363bffcf6bbda19cc4332145b968222af5b1b038bb77af096985388e70405dbf2e8e9023411231db7e8a91d8fd7e84a73c1fe7e32f88ba853941a0f5aca30949bc25425bd93168e9dd45246bcb9485728e730c4dcb03f9c6b29661d01eb09fecb1a45f23f194322fb33504b7cecae116252f3644915383c1a6fa57948f8a070c51fc453ec27b6fb3087906b983f0d77ba5551cccc9f1a537d0e7c07abecd60c54596641fce6447d402f59497819e7024ea32c8e6a4baa6172f968e4564d5ec0ce53e18435607ee854a556c66b6dfcafda542cc73f315bf40917e7d3b58b33dbe8b87853d960fb4bf37ff8e29343f37e24e7bdbafe678acb6d79c299cb8091592025494ffb64e82942e1eb6666e01e2ee8851d0cf95d12f9498d6a697abd07a8011e8c718bb8bff9de63337ae4d839074f7fe603f439543d90c25767f8b397f648e11a05be6e3b2fa7ab196d8af67b62b8c287c40940dd0c5f843bb9be1b4516180dd56469f93b2aad190742620625d5db07d80e5a1a060565d1a8d400d78c8b91928f73a0631b640b4535fec8e4eccd4107f805f9889da260a33abb7ff12e1e605ba1a1ecff5369870c14ae5b127bfae688be9f454593fd7112bb68043b2895c05a56351dce89cc03556a8e9286a0a65aceaaa7884e055d734f0c83c191fb1b7301c04fcab71dc3113e31b1bbdce7edd73454848df42846319e34dcf7fddd4264e2ca71edf4669e9ca1d4f407caafa4072b5b1ede37af7ccab24fa72f46d826d9c7634d6c88293f90c4bb1cb240e0cf780d6b8528e58e4967d78f389f77ae6b57bcaefaa2d6c00116e8283ee4b62286b4409a2d3d9660a8425fc9620a2c0031369b3f5ad276fbba8b7d2dfe23f1ff7a4d851dd2d8dfe9e4741de418451cbf5d996ed7c17a9afbc85385ff3630f95928177f913aeeb245de8302af1062d791a024c6385f9ac1d6b0103116816a992c730ee0df5160c8cfa7dfa890ac793c3a8c660f90576a1a017deb98cf29430e79929a6e133a9f052876a37dab177805f955db102ed8c404c2008114a66f3eefc043457cd71ecaf66de6bb0754e69106bb27781482580c0641a99e815aecbfa913ddfb186d0456a551014dab4aa7571ca9b1d6dfdad3d3d0d07e3dd77f295249b10a7b2eddb21de5def0c7972974cda18dab243b7c14692907aca2e45be812fba415df902cfb5dd6750b26e02be3b192be5955c2b8531d875e7d1487e8f59d2d4a384d86e067885dac0f3b6151001a4f75705e007985f1a5cff471546b573164dc9fefbac007578a72b6826ad9e299ec64358395a4b3750de270f577debeda5bd82eca1e0e9d31c86ccbf834df5d5a55aad43affd56dffcf6cf70aa726e1bd2512ee0c1980ddd21c4cdd2c9edc1cd4bdf61e9fb97abb3cec161bfe8908116eda9b9afb84c235243d3d8a602dff12a006ebaa9c2826412d3ac7bb8c1f058e6f95cb9d6b2225ea6d52b470c816c11b0a3d1b70921c838bc9772f28321d945e1e1546b116ccfdeda7a33350418f580b3a6d584ed1d1a5d53f6789d1abe86cd2c03d71ddda46cb36678877b7f06def3133f2eeacb6874c338721e32c3df9a4faa6232db74fcbbf6792e2b4e5de46c83223e2b412bc5a9294a4e14b4c2a089a28df6b745576817a95666fb6b7c31e14cd479a38d5d6841bc7682a5d3e0fc8fd0ffaaf46eb963d4d0f86ec81936ede96e1ca4b05d2e5b0922c4f4989ac7bafae57a8c34e4e63a7f071cf25475a66a1c3d66d0ceb3f1051e15cafc049e13ba71792d2408b8a1699b392041b3a996cfd13d6fc9555a0591e31a3862272758f7cda9a1b221a1ee62b4bd0969b4a91a182a85f5c52cb7f8ab1de8619a3995f1ca10899df5ec020fe1041c544afce903c2be4a71f6eda660e33b65503a0d0a793c4998055f9f5cdfa4a953486dc7dd40649a221b17230eafe33ba3e07268f7101849d32ec7ab2ebd2bdb98759bbbc45bbedd98c0cd1ae1610084f40cd0aaec50bdbba1522d2ee14b9339462e32338de50047ac21b377e1ec4b8a48701354d299ffa7e046f36b2accf353fa32417d241651bfca2b6c75d3058e167aac0af8866b3176c474034a7e7a968c03025b68c3defd41f8d63d080fc48433d7183eece13ba11dce604f7eb16edcce900c34b0df73f65b6eb94999afee969073828d80c0879379f845b1152f2420036d4f80d78199dea2ac4f6b678289fd4fef43131dfeb973e01cb79434a1d5720eee651addc14a652ba8754556cc8d964948a17493a115dba7d209215611c0797e2030cd5fa4c27ea66e3ac14df0e5cc7e85ef44791f2f6bd6c7ba968a6973df2bf8db35fd31cf045003d437d65ffb838fccf72533352a40c976fabd4ddffe0fb615bfa75f235f7953c06e9ffce84eff777db24ea0239ab99276ff76d36ec02409eca9c3de983dc1a102bea627f92f8300a97e718f3dfd66f1d907b03c3f3499c3a1df326fe479d8c8d87ba13dc371407fdce6e2000ea409769b2ca672df0559375f43a2bea629934622e515f00515366c790b1a214ba45186709445660bbc4a0b80a21655064f31630fd3afbf7d8689723753378c6dbbc21208a500343f29a7c6f07074448e97f993a25ec85329e7816be2e0795d3f788c68c77a22a8e9dd2c339bdff30e13a02ce1ae5957557cd70efea70784cbe395cb5d630a69541aaae48db16d95d7cbbc5e251ff2503e734cede330cdf0583017b1a06dc1df61514cd5aa606c330fd195e1ac9da83c48e1c14e4cfb444cad3cb0467a4bd7f410ec30e470c783e564df65b7789e482c62e6ff3b3100c01322318d5a43e0c9ae01d4e8a4a1adc6d3ad46b1b29ed9477d6341434520e25f3013b19dd1e24f37df13af150fc53be437b46584f1f4d7fb76d5e22fb29536f7a9faa3a9c810705d8327530f2f272a62d15aac3d7cbaf9da74a5cdc44e1f06cfb2517008fbc4b8c4382aadffc12f58090f6c870460712a0cd036a9eb9f32cc23f65ba4f9df435d5909e1fdc80815b774699cde0e961cd3bedcf55905f7a1979baad80ddbb9c9fb61ed7fb78c70311f67e8c0f5f849be8b2855feceec27c646b3f4b3d66c799acfab345316aa5ead7b85726cf42d9b19384cc86e24fc3284cd4d04a66b0067a3928fd85aa37469d1fdaf1b00ead0d81d66823ffded5063dcbcd430195a42d92f8a66159cdfc785cdb4fb945d6b0ef9f1bd447c6b7aaa60dbabdfe85a46efdf5153c1c8520fe71d6c76892f95a77439ce9ad938dcc8aeb7790ca5ca3f6afa52794b9aa09ebd64d2a2a9206f8280b7f81226a056208670e0deb8c602bc5e154e054a9914e36527f37f315d14b68900cecf301613dd7ae5083ef304305fb7166385168cd41aa54ccc83b518d46a17505a540f96f1853389a77bfa4d7dfd9886d52fe8408302f625a3241aeb39b29d23224d49427dc86a921ef3b7526490e37d74c5ed3df446c63827699bc40097ee326c277891579f958043a04867371c25d3dc7437b8336d159c5f0d27d759d13ebbbeba955f4bc65e7b74073dcbcd024c122132530e5d5ce1590ef47d8e2615b504d70f9e9e5c151b230132667009558fe3ac6e143a64e3fbbfcba7337c9ce26e63784fd7c0cfd66c8e75b7937206a8c246a28ff471b6f407eeda9797eed89a3194b81bd2c3c8981f44783b7144d5fa12b87d639083dd4a47fa3a1455fd688252d0a0f17fea64185611cabf98368dfe26103cd3ca7cd3040060bd7027f04ccdcfd55355f6e5fde975a1226bcdc9f483df32645b827b18c9bb16993c113709325d5518336175ae7eeaabcf19cfb2db0499d403b5d5b049ff02a0cbb73c259eec68b2ab040348f24bb16641d87af7d023af19e01757b8c4b958cb56647cdcb29605ca34356028621516e8a58e725324f1da86a375e755ee90c3bfa9cd87699c2a766889dcb7f081837c031283f1676ab025e68d4482bdeda244fff88c3dc624c5fe543652cd6c942b61c6066f104613be95723e44c9322618a22225366569a6280edcecef610c0a9cdd1e3e474481584a7af8f29842eb58db4e062977229ff9266aed5beb45da8c89b2a2adda3177dc0f4bd7bd902a1c78d936fd62bf055c7d752faf0161f9493337649da371b1adce9d34acea3f601aceb4040f8578f3410e85fc4e3a2091ce426f04e9ae1f68ae151101b90622811df248ca268debd91a0a5349bdd860a32529dbfa973f0ad63db4c4f4f9ee6ced9cd2a3ddb98a1434bf0a2879b1c6ad21ba32457e118caf6221c36ad3094ce2a55ad50502f7ffde07ba582985416b5f305fa86672273b770f3884347903da0ca54734cd8cfda1c5fcd76a7e72019a549a5870e768d8f7a5dfb9722879561ceec840e62c027a9663dbaa96089b140fd6daa8369f884ebd36fb480dcfebf42e43305c7525c4d2a3b57c0addb27d0318dea3bda204064191ea8088b872ff5c8b17550ec3db372cc68ab4998a36ef0cef7ed268e2ccfbc0a1206a9ed23dd4f63d77d83517d93ed64ecde4ae88f4bfb73eae052a5249e3070b3fbcf19b1084df74cdee9a6174ad42e0434d9ad710ed91aef35e55d33dbc5889147c52c0fc6c9b7c572734ce614f296353bf918318ce1c6ce4badb2267daca0e533b336b79cf940adfadc6fdc4ac0bc235f07e7162286f610485536b991ede252dabcc6f3ca2be619c9a93eb56ca0d16d95f31dba712add3dfc943ec8316134bd828023700213b5d42c85804fc57d30263221b6eaea65842b11a019369aaa40cbd60b308f3947aa9b08538d361eb5e800b88b4a6a36f019d574f52d43e3b2ff42366fb76995a7c50e2d756218575fcb007f61a43dab4d80b3bd95935c07052fa9f750dc46f3784c35c902b2980e64913090d80c102c178e5f1b832f333bb1a50b74552d1884093161fed1c42817334e082bb847814bfe44ace33c884969bc62183238e3fa348be326497648b187085f274795bb9a09c6cfef09ed4afecfe311b9558b5fb08b43e96c96ec4f609436d23b975a02ad958f274152800de7b1b6dbf9838f18b3f3522b576005f0cb90bc0d3242b9a705017dfca5e2a5ba8d9ed7827145d2f693933230498a138a814e1a573c1f3cfa9488ffc0d7a8fa7fe3d7ef2679a314e5a878b1ab83e3ab6050a7a72688334a558ddf08d4a6fbdbc6750af0e45cf64397aff50c3f0a36ed622f405a68398d240849acf4808ca1fc0cdec5828ae44796f9aaec55a7173e4130adf9d89c813a8b60cd701e751b620c59fc4210ec21c229afb0a6da6ca184b62af1f8afc16bb32136f7e1cd3ee19ea7a99be64496d92935d43f993291cf38051aab129d50274b981cfd7008e1b2a0473e936fd5f7c5488518ed7611d9a3c45271e1511e1f8ba99ad18128fdb3f4e0da722eb4c909501665e789b8212e8a7794ca51e66c450825399b2911887882c595d585cf183ae928b24dec70adc9756984e849cb1545bf91398f6ea43dab60aed6d4e7b59cf1880896f18c70a9394483e272a510060e706fc7e509f1a6c8f6547406a1626423f6f042807fc042a2101ba3c66cdebbda2cbfe2b7319347eb539d354b5ab2710333970c05c240803d39b48f80f28dfbc0fd8968fc513c831c135aa7903e2fd923e48166b31f03b12018ec8c85bd8e8c540448380e98c71fac00489b7ae251736bc1dab719deb415431c997d18bc6e040875cd0e3f287d9d186bceaf891ca1cbdc0e781993b89aa23534633c2ff2be286630b1e54d90f335619e91a0dde7fce75c2a3a4d1d4c132f62dd03505cb41497b1c1030ebf6296ebb93f5469b9e61683a20c24f0e754ea581250f6a9fed6f333d66d23f73e6e32c571b5a810e59e447b002048dbe6045efd8ee29a197a9e36e7b735982f8cac24a824e210fb260ad1438708f2c1341699836132a7d949c217fd6861417fc4fd9e15f03f9ea93e935eeba088c959419dbfd930ad0bb27ff2a5da551f297fcf20c63f1dd43036e088c40d4c90e6c610b5cb9251f0b42393882a09239d5c868505b4fafb9d23d006a05f2277e72a222b6ee8bb133c2e4bdb6bb505ef535be2d2e2c2ad36d449c8d6178bb54f3857bf304ca57628d7486e8e3efe1e1ce2c5fdf6cf05cdbe9cb78bdf6bf2faae9d9679088e3495a530caf66a0b232b738ec9489f0302978d3f6891fc899966ade27cc6acc6f07eee5d517c477c06a8ae9fbe86a36596b1cd2c475a21ab2fc97c28eaaee5fbcc4fcd16fc451149e328f224a03a68d1f8ed8eb863bd4f66fdbe9331beacae9c4adba2185f0dafe2379191fc6dac3d3f10a7b3f8c30fef2e00ef88ec32c3f443d149da25f413a8db4f041dbe71d7b0bcb0c4e46bc0c3ac3f09cb97086c42b3e6432aec2b14aaf3a32b72a6e3fb7c466a0c5fb60cb8999e8f0c2c4905d87dbda8c4d9b6893af128946ceb9e52614100483ad23c69f2194e9c95454865752c6b0efe33eef5c40b1bdd7f3a4c3bd4eb83909d4906a04dba778d54f7ac456d3073a8b809f98b3fff62fee7ca33dcbaef9fda880f5ac12b2e51c61e030ddbf8eb28cee8efd205c390bd222810676de3a7860315a2e85d38974ae02dd12260f118ac7a296774c57f8a3a6b1db3d21b376bde3455d0d1291dd02ca59387bcb001740fb882e0462e52bc8c7d7be75ba5d1385d91d4df61de21a9cca39f7f6052b4444f9e3d736a52a6e470de8125dd30b0cb9464de5a0c1ad4b90db84bdabcff830ae9aaf3d44260a08c0196e1591642bfafac97e3ab0238c98fa11af27d5770f35ffdaabf4bb0550aab299c3ea47329c723d4b13a9d510ce25bdc505f06b445a9569b2aa12b57d4a514f04ceb1ea41ecb466c750ab1342f8f9cc86d37da37a7e2f76451084e9bf174f6914b09a1a6acee970d12306f0cf425d07a360ba9fe9052f8411034843f9a8fa07ba36a83825ee1aa24f4c13d5a5811039007fee52f5cf08296dc2e650a05ad464e88b2143bf784151e455cd74344ebaf40744e0fa66363d872b41fb56164f013c8ac18c0b6796018c26de0e8b8f59a882054ac24f8edebbacc1c979aac0f022802d3234792942f40a03015a84df7bdafeed51d75464692fd0bdf47302bb50d58a36ba426324b727618486537a39076f12cd1f7b05444e7d68d249afa7c79b3f3a18fc111d55136263e6e0ee6e6f741888f2bc1700e5317b0a64ad191d11b865429e3c867755f450a070227bfe285fcf509df5fad596eb88661c6f1eb589f52476f18dd87015e1abb82ef97efde6c13b3a4bc2096365fe40d9117cc2b7cc825bfccafaa9805f63df07b47710c757d1326b055be3342f4a246cb6428f53b26afd8b9396111a943151e182231dcff04abb17d2aab5000b57292341dd953c97e5c0930d5d0b16a0c2ca15a71e1f400414b14f72770115b82cbd9e71476aa2a2e97c43aec2a7730f194889296526fa3dff3d5fa9f51aaa625d831cbf01ef38b118c60904c95776ff448f6599e70c29322821a5e347a285a1dcd6bb25ef4b6b0cf7715eb8c0f2de4bf01e6ed21f7165ccfdc9059f1cb193e47331e3db30dc1d619f28ea27a7e1bfc089ea16bf81e62b0a66a0855de9b7b34c052b24d8d782afe321ee2a02a514eb28a77c34287f759198d8434e9d358562bcbdaedcabe3df900fde659dc8e6dd3655e57c0f671082508ad8b614dfd4facde8ed660b9dea567a97c6f394d56591433aaab66d69e6b84bc5442f6980a8f478ed270cef61d516a2f284824e6d66005fc967987c351613739c47796082f345a1658f629e4b2e92db50d1595a37cb7a3bd35c47b43be70d5bbb05f37e1e27eb6cca18fda07bcc2a3cc0714e4faddd093988cda8aab9e1b07fe790a9a65e0cf6716b41afec66240ea9872bfb70ffe1b86c867bdc4257e7a0733933e1ce23f4bc72f8caf3b294ddce8d1f0ad4b2edf777b66da2410219cc60a643f3ba6256ff0a98b7a69afd60130b8552ab15919d5f8e24416bcd0609f1dd10e55f1f04d3e7d99c5bee67778c0487b7d461a5f4b5f34e076da6cd98542ebf942f2bdc69e6e2d38f68e626f9ae374ff879c7c8df7383ba522749e3b256e2e760e358640c0cec3a13498afbf357e4f18b9ffade495d24570864e666af2a58f5651abee03ce163870be8629f5ad1957a3f8ac3dd3d5be27ddd9dde362eebac16445481f490ad1189944edf7b269a68978717fd933c5cf2fcfa45a2c4d363682d0da4c9d38849d16207a8d705812db9f43af51612abf8ea3b6e97181f9067b44e97be8017103fab92a41aca1fd88b177e78cc8ec86f3d80375d8f2a95cd5672a858261d19e6460d44822acfbf4c9c5ef3d623c94cb2bd62389e73468f61c85cddd1f830afae81c24b2e0b4f479025367a835caef0026ce5986f7c83b91a2c29a7aad4f0a20677ee3c00936de92eb83870e74d15826d27a8a206123ca0ea059a8e0be9c11eba7d224cef90da0f5fec6cd627cd627c81daac99a1046c55a32812552e8153adb62d6ac3d523b8d09b73dd7e06d628d7e346e779aa4ee60270dbedaaedbef20c7a009db516e2d56345cd64b69c0bd5857ce574473f36cf34f4950c902624e193ba66a7fd89e7a2344a303e61202524b4938aba42d0b670fe4199f42c98e4f7d47790fb5c37af78c14f621d816a5ff4ff55cb030c4304ca94b6d049756953a9d7beb56aac79be9fc3dbb7f987a60ba35280d12ebce7e622fe039c765cd794c0d0de017bc8448d1e8e49a37a0fd51d8eee310764a84270cd7b69dc54b04ef320badaa299bde1c59048012cf16b27b267f3255e6768a62d09fe783c208dbaa1b62460eab4887d10b66c671dda8bc13bbea6358df9383f53475269a3a1c34c1eca22c46759c9fd88818b1af237f98745fafb8fd61ce033d851af97716a5856c67241b0ca0930744e6183f10228a3a7a342b3eeb96ab11c601f862aaa71a7a7e979c2c4d3656cbc63565302b0aa76123a9399568dee578e339d13757a450d06e09958e9166194f335042b158668e4e8d0b1751d9b5daf993755a3fb3208b0173d563cd39993e47eb2af7394ae574ed611ed60f190bd157f3e489e8e7bc4ce00637427a04ff366b0fa60d00141f58fd38d56d157b1f0283c254bee852bcbcf0485f073cacfc04f31da484b829f2d08d013e618b3c401a1cd9c8f68a60787b094da01ad2aed50b92713cebebcbd47794a863499dfd83fcd8da8cff5825e38d2a716b9a69027975fe0f6d40250a8b07d687562a4bd4d43708a54db31c3703eb637b6e33607ee5619e16681d756b3aedafd0e095d79b0d8e72589d02417214b2dab08969000c656802baf8fcb95f8f7ca83192fc676a205eb1036659b8cb1017ae2740954894f7c42b9bdfecdfb8a99a9940e3951b0a1430155f3228e274ce03beaff117c5788ea1bbe8b6678059305baaa06dc732dd6c6e25387061eca3360bcf0190b533d1751fb89d94f87ef6fa3486d3f7bcf3e27a3c3b0c1184f7e350ee4c5b3fa24bfa9550eae3cbe386a8465642f3b5b50378ff6d533dd782d41df85ad6c445c8f8a309ee97c44182bd9e037fe36bbbd1fb210340c503e51ca04b3a1c91c532b912a8f53fed88bbea51e65840acb2e62796dc51f3b954ef7851face662e12726b49805987d792d300376f1889cee1b2fc40fef57ed7a18f99f7f1c161c30106c8c59c99b672d3fefde3311b8f9617e450a791e4e5ed305f544fd0eb30caaea83212760c491a2e32db2f4554177dda2744fba52c3d211b3851c2bbbb2ee1833035d93006c229585707fc115eebb1bda85b41f111654de45ed33bd0e2c07daf2170f4bf62878f5bb8fa455ca6f70c6369de3ae4df6ba212d2079118601b698c39e39a5cf25ff4d46f2d7381b3704fa61ca9458b3b0144e4bb4831230c32b5467505c30f4673be19c32c886e29fad2798bf2b6ce0d40ac4f28e7e11c99c46a159f134c261ab7f3a576d7da39a1e199c969a18a3cc6e78c19a8a56dc9f0ad3c65fb9f1f485686f1e215bf12cb799f65509e9ec23496f11f9427930161d60565b7f6cfed712b2b43a1becc96b5a7c85071f2154df1dfaeb64fe4199f9d8daa7575b5534ebf3c285e2a462b43db1e9ca893a11ce3afb70a7d7aad2878235f00581e6f9eb203bec1ab6ab3d9f96c9a6d28af8d3b7a3004f4695fa8055a0d59935698b3697bea0b4df3669392209fb24402b4c4b35b38967e72445f36395c028aafaa1459c1a271c5dd713ffe42bf32861b5fbc642b491d9242ff5583c743d18244d9c69e465f9965695a72245561ceb857784f10b4e0a1bd7885dacdf71439a7c26f0d9a9615801180f30d421e3d04393256f9415f87ee934585bb385213bef6aec04e7ab956997a224177423caf3028984e35a5079e8f3eef292ef8053178fc5067230fd821c1c6e734bc6982dfea2e2def57f123c650c0f07d10ae42f94140238c7147f950677af1c2d33a0c89545f487859a4bf3757ccaeeef919fd5c864e98ce06d1e56cb5f80554e75daec4b2b75066df672161bef244200852d50f787e0b82a608a329ce385c7de1e4e95816991019ddea1be67bbc5ee52760dc39c9106af46f42e9e3e1b3705311609ee98c85110beb6c1db89e47c0cd3508a76416dfbfc40127ad4e6d580c6abe34b088b6dc16f341b7275ad0c220c59d50512609f830f85068829b995b1e989489733fd62853c9e4207bf7e2424c4bffff3cf3ad223abd06bc7d24cabe2187ccaae618b33901b16edda7399cf57de5fd18c6d5a56189ba6f56b279f9c32db916ab2bb7b6e033528bd00bd282384e86114e3101ce7382acad26d95442e111a0e699fbdf4524dd158bacf4abe647e08cd9a9ffb3a33f45d6b992af5adaaecc584be1e87094a7f1891c2e8e1622219d4d3f22b3731056b346f01c38bdda5b11d310959a690439a36242fc9ca63217a65b7719a0321277565e708339581a884f20d34b8b87d192792645f5f8b7d0f0f79cccffaf07ce6310497172acac956c899a03ec15e5e0334f007d23eddc71f5649237fc7838f72e32034c190ca9b84c42787cfb20542279f20c9cb4f40f02adea878d1f97d1130df43a14976d54ea58e17a90f7a44f073eefd5830e49a8fe91629204284709a2067e94431c52166f6e6d568f5ef4d442afffc641ddc336179eaa7442ac0b766a62ae6c92afb271607234b63e916dbc9324ed67df13b362230b0ffb0b845482361d62d29e9479c9b38f60b1b95849d31c819131063ec707aa9da9dd5ad42295d9ec9382a3e390bd152d02663ff80d12fb7fb1c99fde53fd71f43cd1eb8a10ad4157d03ea0b107d28de0e33533f29675990d7bed06200af99e1b0198f768af962001eab5f4b62a49b12f9668d287d309f2dbb42f4f7963122b17225e8ea034143ce84a83c7dde58469ec9a593323d8df38edf6ddc058c21306b732dedd04c5e389b67aec31cd5069318058c5c012981877c296488722aa3c2a497b8a5f9e2c16d1c77bc570382d6970da17eab4d20d145e8eb4e97f4d2531249cff3f3b95a7d904a12d8e60bd9e898d17aa640f01e191b113adbd5996a2e9d5d03e503ae3784eb09d43f8eaac9cbd6cbdccaeb4c3b5297244139fe34fe62e7964411ece906698a5d2b35aa60f70b807ce1aa17ea7920ebd3626dfe9aa1b9b9d91da685686c6e866ae26cff0688a24dbff055c7d5abdb56867cc7e06c99b617955cf0497b9a736b256b41c7f001846c5222ac9be26ea20bccd6086634bd539f2d2b29f9e4373ca40369be7ffda3b8eb00c8790d5d5f0f15e843cbb9bf947c3fcc76199c1ebc7071cd465321df03374e6f8bd572f5b30c0932c3359bd3b0e85f08c4ee42a482d8bc4e68f1927fc7784fa36081d80ffc9c648b905450d64760ef8251596471460fbffb1ca5034c0292ac7acd5fec75deb5f1f6a18d18c99cfaf2ba4682d30addba42bb17c587fe5a69622488d9fd99e2015d33d3903d531cc876d1448250f26f8466506e7cd7b8a3879a5b627441899aad06875b18b8740d73c387a334d584e731f5cccfd21a74a7f7b5822afd3e36de3ba75c0a442db6364d34a3ce2ccaf35b37f764106d55eef0075a79e2e59480d26087c0ecaf9ea037cf8e74065a4c36247fe39518cfee3fb4af4a7af3edfd68b2014f9d064a5439608de295c4ca329c0b040aa1fae39304299936102607b398d46ea5303f34ce23276ea5d6e52dbc719d505a326012a1c9e031828c9c17680e599f25bbe7bd4c483c7e8fe5081cba6f796b89ca1abe018315641a6bb5989cf18e7862ece2a8eb60b44319fcc568e5f57cab0d504d23d434ce68e43323592de8513815f072dd6e6d79da9cf1cfb48b48e7271a30b04d93992a7977f82c2390701e6e7f9c1f5daa3a0d45254899d3184b7dfb1fe320e45fe2cc64b8a949449a87b2e4f3f7e76d121e3abe0935539b9c5ea725ca41ea61e46551e64bc768fe571b6cf0357f0c1c80c5fc7788d4e776edc585bad8f668608b212f0fa95923f87b6dfd5cd25e0b60d148910e83718d71de0b9eecd0b97349795fcb147d7e8e787a0a601d6c9e7809b528e46a0f6f269395275cd13de5fa083e00e8e186304a1a0accf0390ef1dfbab40f906acbf4dc7791e3ca480ef9c72f8c6b96ff49ebff1a515f33311e8b8e83a9ef8c89377cb8eee1bb6e67651322e19ef26e15a6d84b438baa66ef0dd4bdb92e8f8473446e1ffb1b80658852259962b67ede3f3512d9e01528b754a648efa835dfd222e9fc1a1d2dbdae6f6b557c03ec405fff18191a5fe572f5da2795e2f966f94172e3112eb0e33297704445e473e5b768fa420f56833ee8f318fb283fbe4eb8e40c86935802bab7776d199c807591de60c77a6c53f33766567cbf1221bc1a7aba3e7934caaf648bcb91a16c8ed83e9c6e016a172e33b992f0fdcef1f5e6281db7c2d366050d74cc51504874b7110a1460398d60f64d124d1cf42d04a9bc9730028061e820bd8abe441a4ea660ad072515c59fe00373b3c8335f2e66425dd504287ece3f15f7bbc2ba3e054666524b69cb2f2027325ff4d5cf71cdfdc553a0a9a437b47383eaebb89364dcde967785ff18909dc524f012f61ab119416af337a2a16bf7eb2d67172bded6a0081fb5f8f3390fd586377d9312e4a0ae382900f17819ad467ec8cf8bfd35e395d913d2f314ee2053c56267ccd9496528820229f2ddd0af342d711b9d7acaee26a12c5c8a0b0dd5b5ded302cb58f1e0db6affc6d3267a265e21f0b103d33c80c55dbb461c4852b008f92321252534e28b76bcfb1f0d68345787bdb95070e5a654e575f8b4676f452f73bc459109baa0641fc7a780d238154c74a5505f4d7d9a13ba6d14bf5923981bc1ad431f2a1f02bc3fd776f50a28f9767aa74802719fc70f99bfe5e04bb962bfa5af3086ec3fb15be56b9fa35c82022ecaa000ae4d18b3a514c126ac5fafd6a422895a11d025fee97cd09c4a0358eaac9ee820e20d2f402cb4aba47aef646f2e7b6b85318ba23f326d761df20f42beb38830a405927309310fc3a87f967d692de648dac9face6f01a775c3fd49eab36f041420552fcffa8f5ddfe0c8d28f9566ca943775519c953a3eaefef1109efb2ec5b2af215c8e38492c883541b59a86e12c99664786e5ce8aafdabb446d61680597d140fc7c8744ae618d9af438af7b8030ab7f37f791a37088165c28ee7b9d45cf1f2ae0f7fd2b6fb173d8b5463d3d115ad60f9d13684978bf7d6126aaf303dcc51a1dd3ebb614fab3b1d0e601a33a38de59c25307cf9ec48d3aa9ca763e7fe1cfb2cb76ead45d688c0c38c108cafb4b2fbf66b0a42e6ed383122fe19ee8b251e91b4c27bd2830c87e32a953fc97688db6a881915a80d3fe95684449d86854447745e9b80f17916e6bf175d9a610bf6bdd617e0d8fae0c1606de49e16599fe549450d5cce63067ab6e244b71f06262be7b5c70789ceb9ebeb36c494df05e2c90342e6d4430c4636a4e6b4b78903db25d90747b1429d53e0649cb8d8defd2edff8cb8e8f2c52242eee9dc58866c613e7b1464bb07fc9a5355799bd36fda058aaa0a352452a38d60c311e8c1c466b0d2d8a56d7260677fb873f90428a66228eba9beda3048585f85f58cb8cde1eb0e4ba57c8a54da9c51e305d0cc4e3406308e4557916fc43871836ef3661b970120ab4a5c70730ac5b4163d21ab4a99ae63dbfaf198fb673c6183c4f1426eeb771ed199c084e9d2b792e2d15627a7e77e778aef480c5450fe2f7e491da51f85fdaf2f6dd40f2168a9172231b9aeec18919c94a2c6230f8d4ed317f8bd1ed9307da2b765ec498208014706fbc8cd048a134687bbbbd5cd31ffc567483e199ac1f2fc757566ef8a27d5396b8093d4ea3f6553b710eec8cbe20c274ad9c94c5a327883704edabe8563b26d0f7b2031229fe63a990acd3a5260cc11b23cd71cb927ec1fe6f9cece5e7519daa0dc27f066223905b7d5fcf407b13ea52f69fe6d64911ca840d872e9dc9c5cf9d4f4e8e49ada31d22214ac12f19827984c6269a7005825c338f467aaa698890c872fd9e6c7405bcd4a20eb11665853ecaebbc701d50a328fbc9e6c1600a3697f7f079f404525c1e27644c665c2c3c24cec6136f2d04f0bc5e86eb8d1eec85ca5cb1022239920999f173bf75315684824dcb0559a57465557c9facf15840d9e3adcd0ff31de0c0d5be7307296f5a989a7bb88184dc4aa9e97a4093ee56dad004e4a86585d102ae1a835a237bfc81182550d2bd52e69eb99727e16051d50e7de8429142d5f9725081a79d7e179c148c69379368ceac3291aaa47c214e70b4492831626405162175ca7a2a71c39aad3ca70eea99b3eec1057e0316ef7353e47b8b1eb43b560e0a6d688ba6630b10479f3bd6473b2a37c80ae58ec4886e16a903b03b529d7a3cee31f3ed30fe8fc6db35cc6cb41e2cf7d8b2a0dac29b6701fc380cf087559b40c4567cbe4adbbca83d65ee433a6a546f2f8a27f26eef6ccc2cf4e460f4290abacfaeff7d376bfa55faae5cb23df2305abeb20b15cba68afd04ade95c47b3ce17172fee639c4b050a78f10663f069f541bd74cbb8708e5fb4f327753e1b38226805b6ff318f33aedafba7e2e48e6e0a4de2e498a3ef30952d9243727f1b1b8142068627624515654069b8d08ccf9a434f5afb7bc67a4cefab26c5a772fc712eb08113e28bb5b9d408079b0e60d1e26d0449d461416bba778615e89886bf28f4fab8832a80ab31213b6484c561034c421f6508c86fba2c1314d2dc49924d161b674ef87cbe9046a7c100406d95ac1051389df204d241802cdc71a93b4e0f3835946d8c04df3f762598f5df17a77e0db96177a28cfa3570ad78ed8aaa757a798a41a5c87ae40c8642477912f19b390ee696cb76b617a4f85f31c6517abf589e4e19759cb41953626f3e5ee5823eacf90b690cb839e557fc9f1a8c97e0ce2c338a7f5a10c5a12cbc6aab8c08003783833c13c470db0f37aa162b487e402c297b83738c8ee3d913b94e8a7e819991d3db82fe95121eff0979e4cb873a9e146e785dc90dd82744552b1a0022038f7f77790bad16f73555e049cdc5bd6a03953d98ebb30bc05fc308f01aec420267d02b04364d302121ef32417b3f79d96a7c8293e404d0fe3681e1d3d7c11e4af3b8f6ce1622ba5669915672afe795762e91f37d310fa1872fec34306464ce62202de2361ac825431a30e5521560b42d19bde5cea9da792e1fbe22bdaee7e651fe518912ab0596e79f4df55c27f5208f462344b94483bcfc9444ade49bb0576c7563bf429f58775593843698e0e20e5c5ff601337c25480af6942aaef16d7691f7eceaca7328602108db24718db4b6369c4d8bbddf31269ff883f47085b62b7224168d0d302a7948ac8d051f396e76f9731f2e0c2c67305745eb87e16bc968850b7fe5de91a238b2a5189ac6c5e8428a26a56e4579cd5af0da3b2c1820d6957bd18eae52bbf7faa807bb3ac6ea0c9d34d0a431d4956729b078785b3ac5968621bc4146c0dd59117e361ddad3a62189b00a9fcc6f6ee3910abdf5bffe677495dd3f976dd0aa64b492f984425d7fe33db7f755f5e1bbf9211","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
