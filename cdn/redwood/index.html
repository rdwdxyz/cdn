<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"fec338c9aeb57e529b3c74ca9783563069f5dc3e3a9605efd76a5a7e3818a60f413c2e597b831fb0132f5687d5a4fe4dd89370406a364bab4b332efc46b5edbf1c9d6a9097fd170f3a6c9502d0391c137f10617188d702a5288d74c5704c78882ced4ff2d612957eeea4819fe94d7f53d222f52cabf69543533817debbae64868561128097fae9b6ba62cc03c4601fe2b428d70a6685d656fc92f5f81753992eabd37454acb69c208edb3a381d5d832667386c99810b1fe07767da67388113d67aaf93e71ff268dfbb5970361fb2ff31396e47a6eda51cb13875dfdd85ebfe780411236a0c4b6e6504d6f99660988565f09f1e75b084f5b8f8349583936d9ad64e5476b86e567d9f41a0bae83aea68a263b6f39950bee9fe91150d1eadf5ad5d24d0a7c59c4d2268cabd8eb034aea5447ee630ae9dd0c23e4449574cee45c44228136fd94688ba121eb74609c37134d4b0412d2d5edf2b776f6bdc020fa00144858cebd511d9507f185fc50db0e2e1b6b2788acd75eb1bb336b7aa9a809c2b60b754d6b8b180a43f4b64f1a48cb46456137e57fcab5a2b33c8c69151eed4b38a112921fae6b9884f64d7d0f011a40ccb3bb9800c214edccad89d69028b582535ad9e0df629ad8cdbbbcc9abaf77f7eb21553a9fca9d60faf776d3aa185ccd1a06e7e4db9db67bd252189ebb5ff6e33c5a9c0eb20e147f7dc42e7602fd053f441f81ad1e3a6518ea7ad3b53b4c05dd01426b2e27a1f5b94372501d51687c10bdd83f19b45a30777cad235bd2f5ac045888a44e31b234cdeb8ed97275d07248568b4baa341b38aa42aa5951ac034f4431fe7239d52d863a727bfcf83a6e1ccbffb78f0806a72dec39b03cdfef08fd8a281b824a089e5c84b1e334ed2d94b8c8a15c9ccd3b1113ef4e3e94fc06954b8e90b1b7461d9e173bd6faa8d6fd995fc7d508bfb4ed21d47760e25b04fe49761a6615d193aeda04b4a7c533967770bd5c6db420da5528e63f113fe235ed3dce9cd4c77b3bfb1034d049ac673aaa1b6416a5ce9beaad8f682173b2dc6d1005da6488a618509618b1c3e92b902de6e27f0470a09abe28072b1b20bc3f57be2f951e4795f7e08d711bffa8b392b45d443130b7967c9c1b19b5acb35e92bb118bacf58e9dbb3db6f9777f833455a733fb10b6eea93cec65d8481e6727ffbb924afdda39d793c5399aea3dee9db5a22289309d21e6a5b9e5bf61a671876896388ac0212e21c131fea0c8094f799e399d08344cbbdf09455ef4eac241f02875345e595332edfbc7f277d67784e25b5de3270481c372e36a2bec3b044908e7fce86c30cfd583fc5a9f4552bca4bff0d0156a7fde1116b167d7a50aa94bf85625798a0507444d8a0f6f2d2ef20faa281c998acccfe74e0e72978a512ce064e6e204a6ac52e1f438adc4daac9c26fd0bf676368ccad1f072917c5c022fdff963a66719a13d891b48cc58a26fc45073c0ae9fb9d9f71296a52e304f1b635f8993281cec9a7408e664614babd5c37634bce1db60dbbac09060dc347fc12c5040be68f2fa28e1281d2fec3ac5007c7e585c8a84862877ff5f6d6dffa77d475bae078684a2a9354a42603aeee8e31ab9be02a3ef21d9871e6da53ef17164242d9304511396d3b198de6d6e6e915b47f8c6903ba1571c7d5bb4ec86cd04e8c38f8667dbfb3e9eba4d42e40ede3d373f4ab0dcb96f572c36d3daf35ea08a706f346a1238d8b5fd1c991ea930abf65017ccf2e1c9b9dc9acdc6f4d7e4df1b0f1a56e128e4ba327aa84ac8c2f9ae97fc4370350687a3f7f5e754d0de16af3839c92b1cba4090f3e3d39fd84e40dfe4bb87ba241b7ea6e301b3f9825accfd540ec5362b69351737d322b932911e667f3c085f9242b85bc3a2f9dd0296d42d920f8b16dc6844c3c36098a95fc2129edf60ebae56f044121c0b978fc2ea312ec0153daaf3a608a912c937dd05b19159a1e9ab57253f4d876b1443ef9b1669d368addad0cd0b5ab38675711fe41e70a5e1f263ef4897906172a217fe447f54efceacb0545da4de70cf52f2891f6c0bc2f4af5555b7cb5804adcdf88921aa66dcbe4822a286a2972c3af6cd1347c8841d2dac350293196eb2cac1dc2ff9aa4922e06a7919aacc75b3b3b8e3576d1c674bf898dc5f4c9d89e100a42bd4fa14bc4fdd04f43f4e5ba53207928b15c804a075d0925df6672c893ee2d797da516994e9183d221a4223dd33a2f4c161332f3b4ca688138b03f55306f670838c552fc42a10291e6901b5f5d9054a105c64fc9fa43854c1e6590676ba0ebbaa8fe11b2a8aaabbaf2f7212f312d30497022cf907ad9947aada4a2d74c125fbbeb0ddedf11504d25a677cfca8ea59b961c41997d5399eb2772982d1cbda51a8f50982d0165d6ea333de2eb5e3817ea0d7c05b4b817846ff0058557ef9d86da445ebcb080d973e01a212d7d241e7cca0d5010cd202608a73955aa01ef656d54af5270d30d0c8ade850262e8b946bc97136e33703adef77bba9d7f08e3520ab0efe3725228268010766c4d6dd5014c2c8fde02a48283c36091c4387e8770294e7f7d4e5d8057aceb5683d10250a068d7dbece1bc9eb9c523dd4ec7ba42e58a55c3c1c55de20cb7ed3c88674e828cc0fa8def1e08889b5b08f9fa5bbf0c7c333e773ce28a3105e6307f8f2a845d15807a5cf57a77cd7e7db73e9b45da106cc31fbb40e64567c41f41feda280910ac16d2045eac54d897967e777b2a035a91e5ca8214090545ea74148427eef05944910300e31aa3becc726ed92a5189833b01d064c9f0afcb52c8bfe1c80db7672acf8cdf292ccf63546a12c6f117506dd0e35dd86866453cd4f862971699b793ccb59f6790ec91177cd385f79de6d07d14afcb838b4a9b7d9b55102fe4f25ccd41d6f12578b0366bfd96e8bc8d007a718417c4eeb3acb6720379d9130e6c7afe411629a32560ae841669125b1ca1a4730e2257b220ef729012f5c07c48bab02bcdb953e1a5e143dbce3404fa6486b8ea15412dfc9835fcb40972b4fdf01aa69918482248c0b8cbb35674b266337d41072e00ab227a3ed26f62616de2931d4bc685500e322ce3453b72b68f611c24df1541a03d151a646596f0708f75e69923508391df3ed71f037f58c6618d8b850dc706df9b1c13b80d2f95948867f9990653cae62f303382fba788335858d5063ff8bace62215ec7e68fe5e044242255c4eb222df53b7f801d4dba01376b230147bec002145a5220f771fa7d5d36924b93fd50bf816b76f598771e11e79d655c20b9761cdacd1f300d445877b67e59ce318a777e64d69cb8fc13240bda655d7b21fc8316075056484c7191889e59a27dbb9365e5c8b6852353b42e8c30d3c5605e868118b4d0ab56ba973685e06fdbe28b9bdc4a9e62ef84852ae04e16efa899665bf16fd56774642009b4cea1462a35098ff25b41c7e25f2e22be135c40c4491139c4c85218706532f477fcd5d5c5e927d89ea4493655767e1a56cee28bbc835c2676e9a8719aa3546dc9407e065291dfc8f5aeca00c7f2caf6af77742fbed540be242956ab3cba5022774c6c2c2a232653131defaf12d3bc419169aee97054dab6afc3b38bc73d050c53f5c85c8e9f115b879f796a966bf0e47dd65729e25583204f81d945c49aa7c62f6370b2d8f9f1940fc9584632f918f24e14f13fdc4fd39570d2045840921050d4ff101b0a75f4e335e70e086af28843caf2938d6e94ff6008fe72a92f692c545d48898ebb9d4e5cf2f264b5fca2697bb470e19d6f55b358431232c96ad6e0ee81c0123f99336de94d07f1b264bd4eda1b7d8337c087debc8d5ab5fd002fcb013f93ed12a7e0990e0b227a964d6f5f323cc72859770f0f8bd98b2bf253e384ece81972a35e427c24fccc6519531caf9b897f192b60395279a2b5c7ca70e61054d37af0e833c80950f017cc7145d0b4f4f13b80789d562c6b8b07632b0a04b270d5f132d38bff3f518654e206624ef7811f3141428d78bc7106c30ebf9d8f4d0f797a4754b9ca6b543c141e181aee869b552939f366abb76430a4e8bbd3563f29823fc1a56e883de717518807e28a25b160d4afa81ca6e9eb26985521ffecbc099995c311633bc4c2c5164df66fd89b12f138be3d766aa4b03cb043d49581924e3c95a60afb167cad2f6de4db463af9862baadf8966434e7dabf1af67d49ffa7a2d894ba7ba72c0dd19f894410608c565791ffa5c512e721654fe39a8c9eeb38c6d6d82e974823c8a139a3cc9a72afece8ff27c643b860e13325102ff297deb2917edbc45d9d3f7911690fa291236bdf2a406abf15e0df0a5a1d39222b87027f9307e9bc45169faad87f3cdd5426253a59fda5e7cbc3a3c92b06e2ac65060bb30fe6d5604afdcf520f292e3831b8d2f2ac13ee00f19862448d1efbdf205e9104fbeb0f54558cef070f88cd63d2b07691e13959baacbdd65e4582d1c310b8979aeaa771d231b93cb9665dcc8f97df5487bc2a79782828ceb0d0f5492ba1dd47417039b0645b3e385484af48db4fd1b38b44060ec05a612cb227896dbe30333e21cda785391efe15694738ddd42f595a74738e94786e4db60d7b9131998450000093db67b17808fc4b5b9797aa15b2760305c8f61edf799ab61448f07e9564168588701c154ffd4a3be42db8a42c7290249cfc3099b66319be2b084db37ad15c1ffae0a5599c6766de7b85e4223464aacca7e4006928b1d9aad23d0032fb922a9c63b10f076e4cb6df5b30028ad826be796f79205002529c0c5e68568206f5e9330c1703de70391623f124c1f73e8cfc93f5e04ae954f0ab148edf983e5655b3096842ca030cb449cb95fc6555818b0c1a30b998a28b1ab1273c87c349cbd4f37b0695caa1d4f6b56c9244b32ae5f711f4b1e537825626a824eb4f1c9845faa49b30d27ae0372faf8f2e499690aadaae36cb58b9b2796b13064032d7a45b51c77718ab29dc14323e23dbd7710839758c844233260699640d9ee0e490cf6d4e2625c25608cdee4bd7311399c772304e02a88e85aa1124dc6e4542bc869176259288b5b0c8bf4c08ec609fa547b569281b8b1d0b0c45a0655c7f508d5c84ad929c9a7915ac5b3ca247b96239c7ba4fb79ec533080a1850fc03d283095adf75433e4d9ee9a814d46f27be8a0c4468f5171435a01a807fc02d347cb23f3a5b01760047f70dd906cc1b3d869ee15f7bc461bc1aa5d919253003bb0838d96de4c9e4b0d9454b787839ae7ef6d0f337c72e518799d8611943c2dae6ac12a856f5e70c8c89d417fc7a3a9a1228a46f5c744279bc5afd9e52d65a59ea04299733d1bd5e703790d8401bd985cbe83d2cd162494c45e57c4109e126888d02294d4345dd28d4b6bc4bde947a91b69df1578551f8f28d530ec8d58fc32624a2c311333a4478439307c7d33868f7292c20b5605f6ad713870855e7da82d83d6d343c6f3739883d56b4fcbd8997ea5f127f1963f8eb39be58f3458d1a82c423b0d8bf4efb6a6507be7e1e8907f697f2a78bd2b9541e6648db0b6113b7a4517c9fedea40a969dcb60744d8ba22b5092047019c4ebac0e6e4705af7077a7caf8d426a12431194be27cd4f4f55aa936da1ac1f67b1b4cc09b350b5f24d37025141df012972fa2a55985924c47a849ebd48bbb75a1f99139d529b48e4c10a5ca212213e0ae1fc779f368c49d3bd151db8d55150ef87a2284cf604ac4c76f58fee43d6836f1ae2a272f53beeb252c51a9b7e333859cdb2c130f9b422ebeca149178a5fc23b949d896da473c5a1f3370e7a14c4896435b73ebb05c4f4785144ac1d0cd04cf42de86c1598c0cb60e4e3ca352d3340efea241d47fec215a6f7e88bee8ef543e936ecf498ac3d9288db0e831fd34582a8a7c0410497471c0d73d52e162606dc00a639e41b00594151c70476d2f78db9e0eda9c08f03c56723a05014e6800f73a5af2193d284f156cbdbd0838d780dae43fd2106e0ab8c080c9d1acb49d5781291fa7358cff99f8825783a7e3d2a9367db42bbce5b0ccec7425c9d10e130d0af7c54426143944a80ddd9085b1c95c1ed5a973dc01df91154dfb2a5827be83d046387fb67dfbfb91bbb7293c724aa2fc2ee1cc01f19a26e8be8b9b85e20aead7bc489f04fc3cefdacc8d7ed843cf653040517d6db823706128904926dc9a5178b66d686d7b88f1fe9f1a12893f0e91353ad473b0550755de63c3d56c70c1894b89162ec30cdae6c2cc419ec9e25aa30f54ea512a5f6a3df01915d47299b64b19a20a60a755e04203cad0305305e02848d1a2e50c6981b521d8b1de5c13975d10a8705568fbb163901cfcf862ecace872ef3ef7399f13d26beb6cc76a638e2841fb9bda5b9156c4e1bd905db401f24bc6d707ef13c511ce8231c39deb0ea0534c9ac3edb481a4ae83de94769a61dc1da3343d7a78b0e51d07ea09b7b69214f8d4faad1b5579aea4ac325801948af5e26f2b5a45281788471dd0bac2c94c0e86eca839a4579a3e9fb0faadbd96640142e83980f189265c3805a5255f6b83583773aa08a4eff420c6c82c04a5f902d7325e1e20eeb43f2d4182ce43be0a2ea1ed86bd10f335437fb955780534483e016cef7c32be19e43465467498f7b3013411e2cd6e382594f44197ac67d9f6839e36c5ade3bfcfb4bded4d2d770a1ec925ec8b4047543528475539edc64709d48887e08b36b1a12714cb940cc97c73d6f105397ced612ade0719668713b90de75604b25ce56112f2448ef63284e35229d20b5c3bff17697311f007e89a630b079e416d2bd94e4bd7d30606a7ec47d091e350b39e64db8b1af860f0b419a09f2fd4e9acaca866e10e2077c1c5ca0acdbcfddc3d3d95aeb234274322c7d0afd48c000301a5b16e7b9b34b4a377140666eafda4b123155e754127c6c4c93d72f1f7b16d06d52ab146aedcffc74cf9307cd129406696b8b1717037434753e7e8bfff8f61205a6782d8de3c9a8aa9cc03e116712404fbf5e33c4124af09bb2e0b1955cc69c3f398846a98d6165a0e288e1ef267f0e235267f1c5ded91e9c2a2061f3211e6f17fef691e2bb8c8ffffc1c6a2e38f822ce2bfaa670b4e04cd742429417a229fc2a57a698a47642f587bc28f9fc9e94dcd678456424537eda0af09b627a706324ff0345c6562712490e762aeb16236ff5e490b9699b2253e57a686267a100b03f15cd995d026596354ead68fbc4fb41797a1859bbbac8dd8fe4c377dd0883758854c0cbeea6c8cfce296c8abd2cc2dd5441c9a81a6f834accadb089d613eef87870dd74056c1aa88681e83bc36bb3b5f3da50f1c4e8161498ec88796908f1c1d46b1423f92b6cb9d7e91a526693fde9e80876e2a49282c7b5b591a9bd71ee1acf87af8ec34e2f4b3d318e6182bfecd0149886033affbda6059c9293665a198010ae097b82af6240cb62863e5c56132d5636674ce391c9d7c8bd26e7ccdb8d7e8fe2e511c449411b9a56d1fd33173c68e216b755e2a42583f3206da90fbe4d75777a6f3ff7be65f2ec613f2548e6f630fc71f816453998f49c858e4684ad6156e2d6074fafeb1edea2450879a4ffb4d4d6024b3b8f19c72f8c18ffcd12e6cf769b061c90e3e5734e3eaccaa0af98a73cf8f17ccf83173781174d8df8575d5ad3ef9b2ec455718b2de667317798520ae69d1e0aa44e7e3a78521c3ef4160643afcf8bc2fc04ee3e41d0d098d7073db405d7e28f7d4c4c76c755f23af651050d63714895f91d1b49bf801d14e73616b808c80f780fd29c37e803288943c05a8ee77398f96a25e5428eecf01f029aa660c6c8c30cb94fc18b665c490ebf1a1b1b8b11aa93d5cbf37c7f770c693ddb7f7924121fe8438c055ecc1fedc3aeec04dff757e35e2565ceb261322d16c080e03260960aba7485383ff86a5031760e2aca299ed960f0ddf644bb5d59a657722d1667255dd8b22a8d57ee3195b61bc491e9e18384f15fe68a066eb8c16a2d3b602fe70c88b6e0efa83dfc04690018cb94a9289f1cca9406ed3274fb886dabd2fba003260187b4866fa5ed117ee23c361115942704517116fbbd9fe834e2e78cc5ae7fbc0379893af9423a36ae237ce42bcf71164a9d0ff133e264977aaf865749b50b9c06e771d24bfacf6101eae35e7ff38f7b7276d5d8b31c565a2a80130d0d00c6a80bd48062b9efdcdbf1aa82cd072caa01b0ab719b692dc2473dbe92284a243cc50d79890e333ff5bc65f1ac67a9a6d1e351305f426dde67fbd94a9245de19d1a51cf25c9792106564a6b7825f547d1440dbb7a73c368181281da1f432586d790a8273400c83a07dbf4ef10a66affdbb24d0733be5933851c62246a6a83bc2d00ce40bc21fe72ded735eb419cc12f44ad303fe8dc0e236d2b85e80a1cd30180e0bc05cc463704fa3854abb6c0786aef7865e640b7bef44c288c53f8328d88d07c5f9bc508c09629f0abaa86b7d7574d71ff3bae065406067c02f81d9395594d26e57be456ecc8649a208be61aed441fa4d06962fe606c0ddce4d6a321a734b340a8a219b05ce1dd59005e13ea47f22f5f7a2e6f628392b91988dbeca22613831ce65f1f7a0016af9d2677c8c83ccb69c7a1fe3d1969d6522fe58db6f4e8e3af66d22013199d6225062df6d2891b7c6acd0c7bdbc4a3a9050f786d86f67c60604f24fccbdd11bb1978b2d690592b97020817078f83b110f14e585c37dc22c7ff9896e12e51859d8750dea0ea1b4c679eb70725675522a962497b61ca43e55c55eeda5b6f464eff3756a7cf5504002c1c8795b45b52ce4ec19920b2209edd2b88ece2110e90aef1da03ae1887f5d04f8c5e325390568ff385808e20cdaf7dfa7805e09563269609935b4efaef4ad7e1754a1c016d10d4e0ba3bb97db469da08c5b76ba4e2e40f476d74aa7a800a4898bd92b77cf29a58989dd2017fc59e1f4813ad581b626e92a3f20593713de69e6ff5a6c73429ec3b09ea5c2cab0fe2b9ec2d21bfcfd46f09ffd5655c96fe212e9ab572ea41bdac4bedc8b943ab94bca95b609821fe23316acb9122afcc63360feaddf36721db80fd48d9c15a88cf8952d305c5db720747dc53e24265fb2f3996ed23215496cfd09462258b8d9a7b7bf808531f8ed056f8425f62c75e6f7aed3c4e242f2836efc6a40701a145ce0394ed474c7abd6424eefcef793ffffce448e78a279fdff074906c335de187c33587e143e74f7ba05da8fb88a8278f1d7280781829b81504eaefa34c09c1dc134b091e0634b6ae877aaee43405723911cc81c6ae0db02a9a89acb6fe2696d563bca0cabf40989c0440261cbbc74e69e5802166ac28e104d293653a197f126c3fbbaf6e7f0f023327a9d2216980b5d3030b0ce2e7b10b4f3a5b4bda92fb2632c3fb957ea16beb78bd5a29e6506db4c1130c744ff0801835ec0f24be91c363663eb87b54f2c6a0b79d044d35396d009051c7b856a3920c1a587bafc2dd89c44c86e4abfc95452ebc31f39a746867b7ee69ca61babc39a53f5bd2660210453687213f3326a1cb9932e071aa1c991c5fd2bffd4fd7e7f11521f382352723b427931a52fba8c79ce584077fed2c3b7c26ad444992902bf87057b5c6e1e720409ba40998cba690aa888b3986c7a654e0f41bdc740c2bdef6bd22e499345634c43d584b677fa81bbde19afcbafa3fd5783254b03a7235d5ac94150a11092c477080376007c502a9d53ec16b180b11ab89f2b211933a0f9b84723294243f423188fbf398fdb110b18035bef7d179422490d0235cef2380a4caef3ad839b8002863627880e8dbbd72ffdc3821f45bb73ff79e0b4163eccce747e2a418a5743a550febaaa207178bf4edcc6f72179705cc6c6993a0cb0e9fe74af6913cca55f8463445ce18aec5ced987a33a8cb58cc922188ecc82277e06975831df9ab4ac3e74ad279a1b2da5685dce29e50b4697cf08815e63b2c718a33d5bc0093b454f671cd8af0783f9062437607e29ce15c6a492ec37451c1464bf9fad7c96ad2021dd0c737bc94776f169dfe4be6afdc579f8563bba843ee5dc9baeefe3593f9f24c3cf2bd9721d6fb187887d5064df8cff1434ee421d0c63b8d4a888690fc6844eefeb31901fe4696ab79d286b08e41da51d3fa4f7e9d9e9dcf8b1375ced77cb01c68b7a578ca9a8201c47585cf87925ca142b7aa4ed16c8efeb141387c97646dddfd46c569642ba9ba7a50ccc42ce48c282e3cd9e0f2a20f222f459945d83b73daead05249728295de7afec667b59482d970824c702105d865b44d18877084894b716df7a9d4107a786a0cc3885a293c1b891dd46fe32b60ee767a19f368cdb3a3d6120db90ec4bb679e5266484e7a2bae97f40865190b0c4da67c24289a1fd47a2800f7f6ede724d0982f81a33e3588b217ff758356338e10a20bed010eed67133bd406db49a235c0cccd60d31e6b145e4f55afa3b4c1806f3cb7b7e7c368f0d61ddca9ca3617c96dd09ab60728c9e95a1c96e60e717b67976d09a53aaf05c82f4f1ac961b76c06f7eeeaa9d038ed24c654c16017845922755fe824c9264f9084f6cd011b4bff1385b11b908c2fb5f911536cee22821f955870c0fcd60b59bb95008e0c2f86c4851c23ec0a55f71a81ba910c41af9aa12d981d65eed539dec4d59bc6ebf55a7d14d64f52b544dce10f004de7fe1a43113bf63fcbedd4305d6defe8d073d6700720683796f42b7b9a336a0e03c37a7850da104b858433254b5deee87a97f8ad54558b391d46b4c15b6dd9ef4abf58cdab64c4a498a42ee8a376078b89b0ff33a2e71173476d99c5fbb4d7960ebc3f35f191868f21162750782e7c36a16f1fe78e9e05000c551821063eabad7906530d48ae18de205b7a5a909b172afd02cd852faaaa18dc29938e90230fbfbd8bf03e966dd7ffb535062f4f65b6d9c9ea1fab2ce75bd3f21243f3514b985633a089549e1acbfe9a900a7fcd425a29df4dd444b11759ad73a2bfeab01435b4f29ebffaf40e8132ea5384f89a598567dd6ff26c90373a5f81ecb7e109705bd59fa940df8162dafac774cc04f8e43775fcb8874adb5a52bcd54f9168c1e5df33d9ac9c520350c887899f386d39decfaa6d202b053dd77b13f117f14c4f5c3e20b637b44f9fcbf1e8b199cd90bad2ea097d3c353a160c972495d0a2dee8aa21eaaf0112ca0fe6eee10df76c450f1d3629dfaea394a24e9a393232f05316cfafe57b0bb1bd3c05f974dc177c8474fab6ffa1181323990e4968e0b4d449ded5b359a3da9c10d9c4eecac3366b41efd3454dbe9d289d1877bd8af024679a3b551730d821565defa5735eeb7b1836e93bed36308b8dc92739586064ec25b6f1b4bd2787e40509e2e6bbb13900eff859b8757d28da3810b8e1e2c2c888938848acd0e71fdafa09ff055f95c41446f0f9b811c93b6820138ce1727342adac1fd51be0caf0ddf504f4e0042db457dd0ed7aed5d1166471965074f45a7326ab2fba21913089296e946ae309a18774216c026d7c1fe5efccb59759860b152cbe2296f189f72c51773c66db25808945fe52bc9cab6a4e1bbe3291126bc13746b7da708773e2be67190b5fe5f158c1999cb1c5546f031d10811ffbd33fe0bfac67f285f4326e949c6666e48bf9b22e1c5e71f461c7475cc73b23eda058b223bce65f46df25adb03b9698bce6499a18131cb6b52b6fd283a83b7723576ff849b2472caecdd396864ba17d5554d3c42514fda85e94fb3d1e8a72117e1aa6389ed4b1c3be89a1bc2f619d41aa6ed2f702c8c125ecc27e019233663a02815e8a3fa6517334cd01334dd15af67d37e46bfe82210357aebd3b3e4cee7226dee730c6476346b124ccd3d85f66d741af0a854b063e5efd49d12d6704a80be71848a80ffeb452ca2068be2b0d2537fb15b3d5e0219d8eedeff01979ad82c7fdac831c3dd59fd092e3e7c51ec92d0244e46ba4f59ce9c86bc06528afe5a02555f270070ce2c35ad062cbb2591f83cc1f5c7879d4c95b1b9048b8a190c455deacae0571d2e3a511d7b714b8298320e7ec7fcf457d3a61685b71740e45c07ee177ecd50d766da936d95a2149f371a33c2c5af1123d7acec680c3be69fbc6a00a5a4503acbc11c5b7b55a46b440f2e1af9bea705709cd2ba38cf4230669f3de985c1ed921303c45fc764fbb3a9b01358ccaee19ac14ef04901e27cdc21b71bc1a432cb85fc76dae5c41aca3a5416ba2c5feb0f9a6bfcd8cce12d37212b16c00cfa245b42c2eea695e76102a1de323653bf40ace4bc659290b754e94e9f7b6a82d40eeb758d57c34f4d78720537c7675747901b32b674f9b009babbe992d523e09668705f6c68cdfd88e05fce1c298f5cc85ffd49947515ebcd10588329f094c78f1f525a51e092ba44e570813e9f31c639668535f242d1bf94feb4d62cf533cf1813456afb234321011bb3a010ec7222e8b9a7143b6130164af7de161cbaad795e2c06ace068b75083402e164ca2872230b6440fac9acf3fa0613e643faaaee95b529a691cf3a8f03fe87a08fca8292d97c96b93fffacd4c78e41a952fb1af4e98208ee1523e2a1baa6ec1f009c66080e16bbb634d716826c5ff360e352c1b2502320b87ea2038f9002f5f4378ae57738f7e4ed887c4a074c6a065b1ceb46ed37a805e17d9eaa5c9b5a1fcc1777808a178afa12595ff5e3f7fca21c54a3e40fd74db7f640cce0e8cbcebe0cd21042d63dff6a7a523e24f258c9162670368d489e02052ba3bc91c3c0d19233f906449b52887a75abbb7ac053bd8d7b74537c3d03da0ff78c1cb372b7d3fc948f1eecd02bcc3353925e0bda286d54ac4b7bcf0a35f5265e2e0272a1d7e646eab72f337362d450d4b2d21dda1dc674a5557ccde10bb8d472f9dd4d0d23e4887b1eab32fb163107f5e107e8a7fffb399d772220b4dec880b69ae7f778a2e95070ea068b90aad63c0eef31692a7845aa10d944d333399ebb20b0a7c1785a9c67793cad5e986167985016e6a2e8377fd81b1b9f6c196d0f3d1156d563265b61ea6cf6117fe67b0f4cd95013cc53eb84852a1d4bfb844305f4d8f668b1a0fc1590ef9d8ca2ca85eaff1cfb173c66de0a4d8d58477a11fcf898d2317187dbdebfd4b9d626931e75d6c91538c52d2bda10970f060988aa2f926c1ebf3c56f2318cc268f7f209855840d3810bf9a04e503159cb19ee7cc431a57860365b73d3ccb43de897dd5ef3ff4a783bbd67dc82c4b73e4969719aaf7dbba95ad2b51209383e03c076c78098454d46fb04a80e34acfb446885e8142e604429657fd65743901a0fdcee514fafe720ab39986bdafd3074ebc60d6fdc1ecded5c23b5ff5921059ad1de8a49a5a16e348b875b388408d2f3f210698ecde5cd846a4d3697417a4e377aabb27dc515bfbff17af04288d2581807fafa36467e9aa4c962fa7236e74c790bde270ab56b7f0c82ee2eb639356684e2fb2162817728473a1120504c1fdc5ba9875c1592ab964291b3e3e03c2a39aff686fddb1f3ed138dd474a4d1ae0c8f5501b19d7dd289fe21a5e86d85388ecc5e0bdc81ada505d9b163ebd223f2003c11c50ce4c0126cfaf1d1100f1e3217702fb37dc776263764ce066d9e8235805494dc9c16c7004374976b59bd014fd6a550afb81ae6080f3806e9def9a228b05c7bdbf280de02fa52557d7fef8aeed25818bdb4b717349ea25b684a5d939a7ed893ce2f3ea8082e2e040349b41b84c9598173fe252e06f50415c5eb8e5e3c7792fd0e469dac70ed59e2f1faafcee2a8332e4c056e8b8693246d1d1ede996adb60849ce8605a55317a2de7dd4f7d1b7b538bc5a1caa06ce21a5bf650fb45b2e1610ceede5b6e294bd18c06893fb4064ccfe46fc5cfd10b775ea49f3ebc677aff66176ce58cc7331b2c2bd618a319f61c0f400d0a37655d38f19fe3fd9ef623b311eb5e77bf59f880234710c5325eba6f4789bd028d32c4aef7798fbdcdd2f264f7b9acec57cb91a5188cb8bc30569fbf0341d05e0dfe409079f6108f479fa626b1a6941f6c5db0d0895a706a41f7e55a6683da40c8e29fdd67dcff7d724629fa2376aee78e594b875fb77d538a8bf09ac5f13f4170e27631f9a2e3d3644b52c46c2b56ad028314995a51f81c866a9a082bb9169f225bfc55f5f31395f6da996652e12f51497968d06b2a4b46d3086917c73ddc4ddbb50eed1ff3b05136269457419256c9bd875e1d20d380a325ae59e3f5e8a0ee19ac3918caba3edc279808fca0a685d74b82da9c7242f17db2ab734598d38f58964ea69de0fb766102825294b374330b2a63f1a0cede6380d5747ddb4b12cf01127e701fe550421b78e405c7988dba8dc7435dd6d685052633e75006e9a158aa6490729e85530eda9bfb61eabf6e71599aa1abc80e218eaf495b1e160585224b101875c0877ad7dab0dd20b9c9bb75b8bf1059cfea5a7948650c0c8237b5923356cce63f01d748d0248bfaff6c20b9193441547e400192c19dd5450ea14bc332fe621fe7e4f84e61b69893aa286193c5e423098a2e20b7b2716a0bd9a9bfed651911f071c984857d85cb177e4e0053fe6d55ad296a7cfcdb232d8cf1001d190e36c568ed9a0a094f810a555287201da52bbe85c97061083a4ad88f19c76dc9582bdcb730b4465ed2ba5300a18e5092e25e80678f8cf3a6b6b882e971d70d64ca0ddc6ee4f74235dea710fbee9791887957143d50559dae4895ba79cd0bca0014e6c8515bd9a7ec74ed98f2a1a3f1c2b04da15fab10839f5679a96544044737833a1dde0ca7b8e5a1e5cc1c209c63645c67c9fb8de38c605e560152642d99d2262e8871a62593c8dfa2e7f689bb27709a2102167d55f4d633867954ef74108afd42ab714a37a4cf83d3e9329de1dcc7f8f2e41a3341870921bf6e214408646101d993f2050073185e7ee5377a8c73f05976280197d1608dbd2a4980e4337461a78b3d127eb4052d8191d2981bbc95103f7b290a3756f854f4c6e831a3f9dbe0fbd18c254ed7042b6d60a696ffa7705b88698726db319f3f70a138a5427b2f84fddfc20a4af182d29a4049ab3acf319b814276895e7528b011cae127a123ad8b6650cb65460cd524911d54edb2536eff0df04a0112835ee37c324d35a7cbdfef83e86ea80d6fbc876fdf71fc330fb90c7e21156262248b3d4157f164ef9046dc03f01fb6d040674587dd8b3f7c99441c24cd9eafd6c28fd121a954495f74871a687d576f0eec0470179a28a3b0e0e8cd1901088b1df7cbc06ac05373af604b3ee04d1def85c0a1b4cfcf950ec148957a4a3fd1e220e0b6ea56ef8859b917ede261622fe572d937d94ba5fccd7676d7d93330069fef2a7d24f6f369e1deddf337abf250eefe1af660ce87b64b7bce9fcb8ed442b7bce2d5d4a3bc0030e9a0103fa01b1246dc1d2073eeacf45cadd08674ce85808a31dc3284dab327774270d19988aa9e9950eac831282c41c7ed97e7dd5f91123c85fd2c6707e6c22bd325c6835ec7abf473dc32c2c711183143c3c1e4dd0c3548d61700c7660bbc87d6b23fe81b428a73f824c5f9ac86980b14e99bfcea7ab69f1e34889b6739aeff5f9ad6ecc104c3af80517351f134ccf626949f4a979d7c5a7f8ccdd30af5b11b58ec33133cfb0a5e175b0e753213b4871aedab0208dbc842c900956d89e84aa03253704e8375b8f9670c28cd2ec7aba7de035adeef4534624c8335d950a70d42ef4197eb42dd4b78ba2ea408eef827c2851b16460e80a66716eddda49d7a718a8ad7fef291e819a16b7a72dcb8928a8edec1f99c1a2219d31169ccfd611163f274c0ef2dd5148f98171c290031d20832111ad7e8a5663453287d620f935add8d211eb4e271c03cd3160aaf29129c0d916e002cdf2ed28a42db4dc7a38d0f8759b6cda22bc5572a4665cdad99a3f323fb090fc3dc28fc09c436e44cede896aa80d7aa77f7ca0b3197edd0c2cc2de463446318bd71a670ac6cfb93f39ec7cc146b842866c518c4e23c52ca11c7c265ad1b4d9ab12b6a272f7cce5268b98507a2c20a0870a2e110998d941549854699bdc1582e5199d946a2e4311691a2e82313a93b5f84e7bf1f33bd3daad8043bf2c27f03033ae6f33894d3c524864965e5184388d7eea4ac617f8c2c62f1194ca1bdf365af236f02cf1abc59997d8519d0a6e9192ed5e409c52aaef470d2957a1723f12813c3cf511f3e22ee54ef49b355e84b29dcc16b30f7cfc18427a57640352c28c43390b3f0f39bfe471bff6e758007c492867613d7ca1907338d988aa89c37ed0f7c517bf24b6e9f3941598e553fff1588a601c4c7f8e5287c9e972adcb76ec6bf07c48bc9107fd8617a380df1ad6ecd5e4081ab9ea9d7d5ce6689b0c3bd76f6741beac0729758b226c874c41af5a22c823da91cafce020777fee9d449d5207d3873266ef6bc3fe17fa3a2d592a6b377f3f0f4a2bae0597da21e63ca77c07f73274487baf8e5a188884664a70fd4a6fd5aa2f4597191f97c785d60c67c1c2790f7fcbae4911492032e8f1c6dfe01d820fe459fd17ca9bb7a11ba5231e24e50f9ff85bb185263beb1b65950179a8429a5fbc1d7e637b1614660dd94e05b6221c6fdc9398b8bdfa9ec7c7dc3b3d13fffa4747fe64853614cdb51f16ca5550777d7b3b9dced1a30ca0a468e8feba3cb1de48fd824cdbfbf31a953f28062a011816d86e48e1fcade0a99313a39f2c8cf30f65f65ef874e1b2e4967011779502fb106f21c8d35a3334fcb540eacc53dbb3b027f1bdb8b04ed515f2b922b70af4725c75fdd565e4e3134577814d6c2e4b1e7dc97a376427ea273bc34bb9bd3e41e2a12e9d328f5ad71d6bccc6e651313dc0a2775524a3cb4405d99cf30a2ca3ea26b383d7350f3476350484714a803d3794e3fb7a7299e54367b620c1440b2031e9b43c1799078c085170922687c5e54889535053262b3b5b3d6463de702dc4b6116a9075e8063933303df621295eb5673f1519032895f9834e5470009d87e154bf6650e6aced5f652dfa6f610b92fe9674ddb51fc679395e3949a41de04a626b0f2b04078a35ccef1cba09bf46601a882da51ce2380598efd57622a859d0e9026fc4edfecfa156ac64227f5f741d075cc725b4679e034e9b6cb750deadac9ae15e4ef6f3c75d0d633e8fa79bc6f8ced6ee796cc0fb5d870713e69cfa8772af58fcfa1b856afe18665336fb0e9fc11a9095ba837cb2e7e8de765ec1a1672c4f6703c6c6872f6ac87b0870b07198fe7e79be07583143da997a7f48b70745d8b12203988abc1dc46af6b957df4680895752fade555ddc8cca88c2c1ebd38343584d33f75a43e66d832b08aedbdd93576cce3ea77b5721ec5bcdc5c5e04004ce96d038b2bf1a6d8254f4aa59ebf7f4fb8db560a26e653b2f05cf36f4415e560675ae9417c86c5d1d6013f47e147d0cec1021fc7b6bfbdeb30c1f50e9265c6ba32e06b626ad3459fac92897f08ed57179ec2750d90f4ece98fabe3b617aeea184702940b0082e2fbe2c0fd39e614b09791ab69b8252c3633615f61b427b78059c6d4f0085e37ca962c76dfe1c4d1c369b56344ffbc067db19fe6809f94727bc406549a7fb1298091a854539c34c85ee78968fed99fc9a001cbab137b9804f35dd266ab59b462cdd826edf744c82a9ac411d10e5e25e985d193d105ef8d0abd877d62e786636f1e396663a3e3aa7b851bff6e513fee2d0e4f51992b81dc6ccd1f4f4333b0a1951188d559c990e369cff981640cf7342fd69ddde5ff9cdecf50310ea533b7f6b5641013afeb285fcb28956f0efd30eb1761f67602e647b4db372b01c99c99c44896b1b956a9ea23259e5146ff16ba10a678c41b2691b2958b77ac9f32cb9786caa5f343bbc8dfde729fb9d33701491e63bd4285a8ddf9ca24b0f9cf92e19e29655a6872602bcefc2218c4bafce240ea837f1ec3b534263a6e29c31b4d103460fec23ae89f9ddf18b1a8dca62d9e517a90a4307961b987b81796eefe31c9b80e3d6ffe917d44ee","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
