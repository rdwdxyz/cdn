<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"3f9de615338e2fe5f9bbc82ee8de89097b732af66f13a577f92a7a4dd302d110683192ffdd6f5aae9ce76e5c8665e9d5109496dbf380fbcb4bc9ec80500b2499837c42c73185836bb92c2d3513a5258ff5929ae51b780116de6f6b85a61e387406a5cd40bac8fdbf0368d66d08dde63304fd237ff097ad939094cd705f5b5928062f7d025026746b230128324819d6bcb00379a896a10b51008c0b0b57840af0a18da281004a9c704e51ba7d5625c57001038123096d29c116d16e63106e5cc967a9b12931d3572e46497be1ce1f9bb347d1026f0148845431f854a7d3ef828b5ac162a315ae0418b2e2f2840ef3280f4202a2aa08d4b680be4a482c1042ad3aadb8a1118d6f5a7ad525459ee28625bb9b8e21700ec28ec0e1195be01b290f384270e8791f935da8bc524422f98b1787ddcf41262f1cdfd48476bbdfbf81b15bb6c1ccf4052fed2eeaa298f3ad19d0a2d60dc50d4491db5b17ed3db1988e1e3d6676338c8021a77708deb6b796cf7d5c85ee0ee23a1bb8a65a07c6b7e87929758999b878a543678e1808cc30eb42e151ae80ba2ce33efbc71640ff46caab4e5c0660e80bf7f7cacfe18788af92f5b8d634779481f2dc5aaa3093afd78953dfc4a58159c0ea3bf3f0cc79df072ff9f7d3965f77258b20fd19f451a3b8fd7703fea80dbf0b931305d513253773d58468d747a514b30638bf2b86c5d59d953861f7910c24557add6ce10b65c8adfe6a16529c019dab2d3472f1e0e3cb6ba8e7e85ea28385cc524b5efd3dd5b07beb9900e7d1b820972d3cc7d651edfc794c8410f31f761d3d19d267f39e9afaebd7d0991eaf3c17b28ce659b4243e1ce776bee8f035eccd789ce9d1aa5e1eb0882f0ccd87f09760d65fc2f3a30099741cfa022db13b18b2b0bb89a8ed2d67b30b21e93d658121ce3ebb3ee6bf59f224c9126200e993f84649f495873c22fa435b72f0fc1b9f8ca78fac3dc342d4ccf464fed96f912f163402266c54415b30a0810c058c64205bdb42845390ec88a89601332ca2f48740112e84df1916831051d0b577477566211bfb3660caca7fc13b2868b289837dc2d7db47b0b34db8d991d1ec7e9a40accae1adcb84017029131add4d712370752cc7c61bc9f81331fde2da637e0a31810fc08c10413db388bf1fc388b4f1ac41120b51ba5e6ba0b7239536387e486e187cea6e27df1e7d9d6972e1a98aeb80bc0c91aa6e41d5a8c3c7fef113a23bb37b3f72f892d2385319338de9f096391bf06108758f6ddd9c786b9e39a47edad1c9943d3171554074d49b8a2949878442db67b361ef9057e92501a6114b3e5a22342b05ee28fa662518100a48b8913c8781318facbdf15e56432c8c4d17f682a09d679a7526e498e95dd77ad450960350d02b2b292325c0fc645776c7a6a41a08e3961e9a0c0df89e102caf05e64800f530f5365c13e9026bf60d458c6459e67429a23e90bd64dd6d96637c175efb191d3c2bd83908ef296d44c6c653de5ddcc4c3b0dac90305cd26e397b40779ce1a392b2ba6bc43d272dd9b6654ee057eaaa2c5bf3e7e4d0a33bca0dd7c6f02741e17a6c97b8b381f9c7020565ccaa977834c5e852bd95da4e8bb0ed26512a380569adf75b78c60566927e9d262ee091436d28c8c5d86fde9cc1baacb1e224a6ca05f8e7122abb5ca9bf76996f03002e146cc71ec2b89738026f5e3884675a7f0cc474318cc0fb4772fbda685fa2ad703a5ac4a0e38b072c10a7cbeaf9d0d557cbed49e26908ad85f48527dbdf9533a6c26b53d73b05c74f691f2bc8159c65dc891e4496c1b9e9c8a31414d4b8a9d7ef2d19a79bb82cfe0b92d3cbfa8cb47dbdee7c53f49780a71786bf8cadc087a0913da49674338c93ca6f183ba032ef77d7d7aa4f1f30e71d7bc9a7a54294249401463849a779e9c6ea3dc3fb5225a67b39c9d06b8b121abcbd58acaaea5314751785316edb3848369be556e7cafce91f6648a76afad1f38a3c38d4c77c5a09be910fb2e2465760fe66e1e7aa670e01e5716c18e32b4a371c55aaff3b5b5e757d4940727a682428759d4ef247d000969db45b3d60975ef666dbf999830c902bb99cf07f595437c48226f284c6ec25f002e2ed4039a30189248d898ecb8da28018c740b6629ec5bc5d3cf28c9018acbeb2b691a98df6ea226b5a7f59c75c8acedf1972276fc66fc92622ec24a4b7f9b67f47cd60482219a220526c0495b53b7635b8e9f43e654cb4034f867f7a75720391a7a6df15e696e26ca2be1600bb77f09359d335d3ebc142f79def8afb22e8bf7ce59bf896ffc2bddffad1b17418b2db58a556e6ade8db99b08db0db1aaa95bd8c99a832ec96042d18fb4fe7297afd04355be4febb70e48a1c40aa7e17310e444c5f389120a46d62f804a2ae32101c34c390a15ed3bde3fb9ccda36508954619d7cfff0a08d8116acd8e898dd4ae98d05d630813ffdfdf89f450a5870a3947e274388ee6a2b6526c33a6020223aee0673e82fe025de362178a0d9b1706ac86fc719b36d9d455071b42643492b9b1d9c8aa54b11e9dcb11201bb931f7fdbae51a1a690b6261eccd1ff30197c7a991284fea9d89301d17a5416f0f9c33b1e65695f0250d8d3002da69b3e648ae5744e28049c7a7521ef179095b1fd1035e4000c21252b550b8b8f53051e59af66e1c0f98357ae1881743bb3891b33bf4d98d781c01f7e80c9b3b170e7970378a845392ccf2d352b745ccd894d8adc58fcb1cf270222535cddbd8cbdba5cbd0c5fbca7b57f8ca89fff1a68cd70b21b68e2a16773ce028d95dc2bfbceb4a821022e966f2fe3ea2d9853134820aa87c3b12143a02f7482e30bd5d8afbd48327c5cb41b173811f58b97f335cb80e1c21a6e8ae8f797d16021de48c3e73afb5a416cb51ba03d4e7b2120b36d465e09c90528475effc035da499927fdf325a770eef57101c0c939994839453d39afc154240d1b300e0dc6bf56cac51171c9328da65284257f1322fd2426904513d1627d90e0e6132272fab9fe812e5f48d0ffa926d07a870861009007a02850f3893aad64251e07d2931b07670fc7060b7fff09284917ca55b993b45bdc9f672a4ce6cdc2593b3694a1a3cb8c45b3452d4f72c7ce5e275e6cff7c63082235ead0a76f48030aaa4b0bbc9c2174ab5ac4ff5b31a09d21d00291b7edaa847370213caf6236e9fb3c18461ac0b0d8d490380bfd85f4c5d5300949036ae0bbb5e67449a1a1d9a230f519b1ef42ccd0112cf8eba2e52655cce013f5643398ac57718ec441f2a460ae2bda2c134bee541df05e176256591ad533a80b147249125d122e8c66997b1feb2affa0ec0b0dde6a5e7e4fea1bd740d2b4398c1b352828926c4884a0736b643bbbbae2e9b9fd7f66239374d742bbc00af2455c9b636992192cb8d30ef35375898ec130e00b83266b79f5737230e495cfb4b38d1b06a444be7a54d27bbf04153c72ca2d0418ca873fbcf80a847ea676ae4398d959a59529847bb0f107e599e1ec3c39e9c9467618ac146d2bc6e93a8013ef3c7512e20850fa21e42ca6078370ff4b1833d7c817ed6aa883fb95ce4a43d69fe9218edfd8f8a2a9ee42c2fbd5d23aae324145d28d7659dae0bf33d16e88fd9718ee6ef770c24e5a1c31e44475ba81049b105a1515e6bd35fded3d92ff3e2fb44c8ed6c8b3d7d54b7b55272ab7d9f090c6d44bc5c7aee91bceb872cd303ab3ba9e4da69a13db5ac2f26ea8c576e9135b6c891052b729ffda33c596f366e1c87ace481676d9895f9c512bd044b7c123885c6343d99e10971b56b4696bda944c90724524ac245299ff0d2cac34b020cb305ceab31180972f917fc02e17e6d8968f2d5ea54058e084c76c5c058221fa9a9cc225c9c3402b60486d889a908c47642583d6e4bff52b38f18d2106b35117aba635447326304b529241cf78b8dc784f0b51c0eacb3a4cb183dc8a233ffd5dacd552bd3ab4d92dab205f721bc0ee3485e8e2766bbb1f8c726e4336272c23064c84dad79190ab2bfa0b0d1170235c817cc380f1c8bc564b22e17f72636e954aa2ca1c5db746f347c4d9d6ff195c055c4a14563cd3efa79736f8ca93fdc40d52db861116d50ba2b50b52ccf4f479d0e77dbdfdc2605db8d16ba668163be58e79ba4ba52ee0c2a139060a88a7dbb2055f8d6e0d7091cd7d771483e3323b21568679d7a8d7514a81e1a3dfd9fa65d4b8ad59e83815da5b02c03ecfb3b991041aa8e7656220818318efc7a43e804b58db993c30c1e4e6ca8ddfbfde22b3598599ef0971323e5d83aa42d534236590bbba94137b4381daff42030e5eba60ed9af02c9bada452953506691891ac36f5f742753691b836bc4a247b347f9a96a97769f884966cf70ea9d2678644f40314b72d17ee72eab30cfbfa1a80704351922433bde3bc9b6595fdaf926a09bcbb620f6526d5ac29a944f7f49d1ecbe9d30682b374773e82a1142086f99b8e2f23a949286f70a5ff5d292d4f4f1b76400b85d11ce710f9b50e5e031ae745ccbd45b65b91604bdf8fd30a32d8c612e7c1e5d5558788654687c278fe204f5eef0170884ebc9afbcb3fe83f74a04d4d928765bdf24b92cf7d3e74b459f019320464165f0595688aea5c58b49be88ee0e1a1b1d660bcbe853674a74fa4e121b3a9f54cd87dc8ea9d6b1dc317edfe4e9fadd395c7977c302621fe90b17f1430a47e4d2a63c7f284b8af6e8d3c769fec90527876d144c084851f64a3b28aaac63953333a40b95bdb989e5a0a6a567f4f98ec8bb5e0e6dccbdb016bf097fcac8a2e22151f20d26cc14a75bacd7123846f3a5bc8f162880734eacd45ffb185861bd95255be244c393cfe2d1055d270e20f7f86320ff08bbf2b5f99ec7af4a0c7fff7e9b108603eab1e4e5e7934400baba980353840d40fa4a6f0578e738d85eef30717e065f2a0596b64c37e8836ca091493bc220d42222b4e5b79a7c3e961e2e9e66815a679e8f92e6213eea2d85328cb0a926c99c5878230aa96a32c26522736634de02bb359b6101754a6a6a3c98c5ae3bd664e9e0c88c1e0452dc6f1f35d75dcf4261a8f456e562c2549158a82d0305539a9f809cc4993e6868607f9626a0b58db81283f885e132c0aafac86dcbfab1852120ac5f0d7049a6a03bab1bcfc4cddf44a70ca963d87603b0995be38638b4b9cf3cc53af79c6d5994630c008d9caf562c55541d61785e4dbb4b2f2bcf438455f209034ebf8bce1c2fef8854d9f8520f0a1233b902b5cb563596d79532fff4e58e69f67af09a8b6caf679f656041ecbf4a0ce3913bf1d09f02947e1effb7e872ac24597b236b97d2a072b0480fd20ead3e5e6fd0eb17920593fcf61c8a3e5501e75b67ba02692349b8581e7f7b026c3d6f6234f152886e7e46a65c3ac7e5890772a815a3164fd7721041eb1bd014c03d1bd11429e44aa162a3b64a180831b53fe91e9261dddfdcff1da02f92a67336fd910d8e4ca60ad4b097ac2a4c385ec1993082823455fc5dbf6c736f3fa57191815fd65ddcc4025d1c9a4906571dc0edf36be50440a4320bf86a8e0a1ca03f1745758bb8980de123d3298b3fa03be4f4c26e3578609d9fe7b6bb1b3d4a8077db6cbaaec6415d2f106703137987dd8a344c3ce4a145cad5f9df6ed5bc377b771a4ba29c58829280d6cf1f08fd5eda1e408e3ed7a3553662b42bbb1914b74cde4170e22e640151d99f2abf7aa86018ba963314cf84ffc1eeee79570c27d422eaa2b1f25afef1ada0d52248aa42982e1bcbaa56e03476a11bc897398d88256e1f1b37dcc099f806bf0eb968aa80a292a6f81b634c1b4150ede79a6abf884e20bf6ea611a051fbbfbb559418fd56138749ef734f3d044f98697ec55eb681a0d7fe7ba4b121ca97b130ac6148ed8aa45558449f6ae51887d90673658b8e415571bc377f9de88869119c0a67c774cafd607d247a96b6770f862a1c4177cde9aed15601757504bc6e72016cfc2ec4c1535660606adf7c8eebd361adb32f62c1f2e241ac064d6f3021fe9fa048b3cfc7557e60a9a767ed19301f4a1bb52e23ecd26abebe5a694faef6b83494ff7fa8b0925f00394e270f2535bf6cc00573da44d9036c062c43c469b02f57c1103c74d06c1bdc36ae41dfca57326bd13b4eb5191fbeaa704adfb81a7c52531a0726bc041d7c4faf64020e8794b89664331377aab312041bbbb7828c334a96a7bf5f0b5a1f8211e379e1cf5d86164d4238b43e34c9e5e46b0f9c80c7a1c5df15692e49dc22f1bfce4958bca9318a33b459c8d5cd93e1b19acd9ed301773be9f2a42378abf8fd82bf77b4fe4826a67b2814446d46046739a79d325d94c7cb5088c866dd7cc07dfc3d7fa71f9aeeba7aa3725585cfd6793f0bbe05d553543a7e0007462edf2ee221d3f0abd0541dd423fa2579238ccba1e6d2c0d38e8246bdc5e55d6a0a249cb1dee499021776b41b765124b79853de722f8e08982df5e3c1ae777dbbaa4f5ad907c86d308d23891043a81c48232cf0147c582db302257b52f10f91bcf3d3cc039c79bf3dcaec4a40cb73eb23ccd018558ac1009087c9c3deff5e18cc014656e9a5920ffbc5663f6c5b7b149f9678976d7e46b84197b9e16457258f51fc15477af1399c6c488ab96a85f92310c58592ddbe84538226fd1576c954b050497691e7c94b4adfad130df77bd01e1eb6e7954bda17814a8d5df8eedecea3e2860c2a2e5099c9d1508a49f4ec8d1a6b53e65804c61be55cdce1bc4a74df882f836819c29e81096b49594d895a3cdfab851ae814ae57ab76f9e1900b3357ff511d0cee73e02c71800978c6b8090cb26d06c1892313cdf6b6c0abf077aaf6a4976355a58c3cf107799998e4832ca8424b2adc4777c55f50f72f97e63d27613a48cc871f2006ccfaf68dde1b2bf46138ffbc20f2316c6cd190a5520383c0ead46629391ea3dff6e0aefeff19639ef7b3edc84df605919ffa0a57fddecb434d9466d757778a6e59f2bac1bfd3ddec565b68a38e3f173853e093be56704d360f5958decf0ef8644f460a9f1e2a70bc6dec2dc69d431dffa14318a9c4e453554c4d0cfa38133675c594f05f6d78ba62e1e525c5edccb91d7e9c86262c392568936eb4120947afaf4f51268aafba23df4ada4130d1c3864be91333afad297aa5ab91321bc7e7caa65c08f49d302ed2ce9b3fc1d449aa2cc304e6fc4501127378909b016bf2e36df716bee3c010a5618eb5dd9288d5dd102bb81dab035476fd8a964aa69331d5b59cb69ff10e874d181c025c617b074cdb88b47e2c95dccfb3a64ce353c5b9a3c0256af8dd7afc0a0061cdfee30ba2fe0be545aabc4f2b6b42586713ebad0bddd44f0dc71f03ee671fb333cd07638fc03a2b6d90d20e38d39c734cd34c0bc3596d076f93823a28454c7b5e94e445503eb8f1d6b446a35d85ae98198d89fb4e22e0b6dc565199d43cdd6b36eccc9f36c4de40bb7e88805b8b71e88283ddbe7f57c9863c1d13c524d16957139a9e99db982d4d74eaa244f988c4482fafcf09f75656f2a0795ad584d89832d78a986a0e43df9e346be2de1f1f5edd6bede3660948f2954fa53a5f16582555091434dba2fadc44f04a4b2bf391b0d29083c1f8e3badde87b158846dba61e7ba906f68972cae1e4b03d133a0b00d1f50d3f17bb741f24279f3e37026109b951c367f79f4e9f21b0807c0733f63ef375ca4df7e37c57b3ff4c56235b05d4832dbdc1181374ec98f044d21a61753f06ab7bc34a02acd5085696a86f9b67ea68ca34e20f6124ee75ff5713d00875df8d04e0ca4ac3b4374ca49b749e635d10977c2b5ff0340e1c61b86b698cc74f99eb43c19aee2befa8c6bc971c919ecd4780ba5fc84e84f8e6d1d30d1fbf51228134d1ee137d0525f43f954a787ca1d87e13fa28d772d69f91c10a533d1153783c04c0f45f415bde570581165f96bd01eeb5ea8995f9e7ff1157404770361dc423f30a2be67cf7926068b332b66c75e024e2d160f42174b3d3d179d27ee627b50ca6da4460b4662a8a43ffbcb4fb534851d5bb258abc6d123afecc8ff0f4e0d9c3f87316c0881a189de0200198d6adeca5068a8b3fb0deb3707b809a1b7c640ad558edc7f705058ef577d5f11754f06a685e6ab7a298d7be3f8cedd608873887e9a57c58ad4ef8c710f0bdc6d2f1e949dde26fbc832ebea22789e439e8b06f41806d3ed440c972e2449c451812d0c9c3f557fbfe36df697155a87047b3a5c38da9c5df3227495221a3092bc922ac81627ebd6c2100c4261aa50eb27f4648c0537f78899d93c72e16cf84d5dc66ca57da3cc25ae2208f2b728341f0fe777684ebf97c2cf2b91ebc8b66a69da0b32c966900a16e4736be4d284e1247862a2d810e561b77bea5941c9e3bc6d18a09da84c326bbe18b4d28d09e3d21678b5ed82d173f1455a69453be0216e8b3feeb719c6d2988ec42979a3742cbee1acc4960dae2e42fcfc6433b1880e8cf0d1d497c1c6fa8d4dd7d3c28e916987d39bba21b734e807b186aaf163955ab577294d332b7686577077fa5d779e29f021f85e33f76e9625e38174d99cb3f9e78ef6389191e283ba4f715f52500cd2d2e41d0ff05cca39f83a5423438a8a82f0e8a9459cb5bcf65bf94931cb5b572c0a11523a5278b2dbb0ed70efddc6e66af379ff5219ccc0a14bc2aef8477198ea901db4664225be87f962ea0b5c52ddf001aa673a4baca8c2b02f38eb0b3dac3642c68eb041e6396db04f05e1a6ecda7ae6ff8910a950e59b4716a10e2383771add3cfb5abec591c5edd335be80610b99acf5316f629d85ce4603e337354c5d1fcac2263f99e6407f0cf1ac5f4d09b7a92f250c13d2392c795d8d45528cbda81b6ff20d311f9f49855d8e737216891a6ee25760d74d0747407e980c5d5a9ce499bd4a0f267db0665d47833713d6f1e30d0c9c31928ce226fb9dac37f927af12ff7adb8b3308be12cf911fced8fcd4e4e8322c73919a3c7a73cbc1453bd3922572c0bfd8e2e61140734685952dd47b6c663fc884200fc0ce5522aa4b4ebce7bdf8e507a3471ee1e674b1102cdfc5a0cce773385e53656802bade9263302fe315c8e4c617150f84550c8d19efee6ac347cb862962d272b174c2d7a3a6e0340f8209d5fa29e09a4554373dc48c889a15c7ff08449612b1f589e0b0395a2a1b87dab225e3b7a96355bcb76c28060d833fb8539b30a4d9bba72ccababc8aec7881b3cfdc7fa32d2ea17275b297e76e37e9c2420b0f4c36c9660780ff4b455bb416ab9a2797f149023149a94bfde1c3909a9bd86380bb7482fec674cba98aa21f91ef84a4d2f1a5076e3c8c9d23b62156b398816efb5cc38881ebe71e45090d11735e7b906efc97fd4f5be35ee2a89b078f241222d5d32bfbad47d29e43dd297aed360abecee550d0d41f4c7dbfc2e2eb0180a086a9a11d1eb75f525a773b4ad7563d762b9110b0ca910bd20470ac91550d7805f1a3e7e7c7742ef153c5ea58e25dd3e6ad2c1e0a84e47a383aa361bc394c70c4f30af9c1464a2ed59dd9c99eebc031d13f24b77ac3738f563cd6e970e5fcaf9facc0a2ad90fe75582d4526e1b75f578218e63abc051bd011c93eaab111eccb72112c95b61e6c6e3769b0f3b52c789aafd9c315b3e6940bb8fc494258c83f94bc99d765decbf6e8e8c646b4226cc07579823505446bcb2f55d919700360969a679c3afbccbf1f150b81379c2026d458e76f1aadb00cd895b82a4d10e1cd0c102321d2a49acf0d1725d45cd3c7eb34d4dbe248dc8e2bfef048e62bf84855b5e08a0e8d720f03d15e03cae7e2e2eff4d5b4842bec2111cbfc6199a028e60dc9306257d4af9914575ff02115e81a263bbc8b6065f8c9eadbd9ea86904d01e6839bfab6435fc7ed6f305337a21055f3d08973f45ef51c81709727bf895b819d3ce1aad832d0d26a4e6ae409e10ec0890a39d6f71066add0a19a8eb4fc7756a236e5e186d42288ebcdb766e00a5130e3c765759ad08fb81861db0e38724ecc47bcd6ac2399bd273268845089abf40cbef34b75f571585739d2c96e96a483d43258548ad83598b8b3226ec0856c0013dddc027803e8b8e3156696f3d1e3a5aa9c32d780c3ed0d8fff7464dbac1af5bfa0493e7fc10f6dbe4e2368a935e70d41b70f549ed9d3083011052aff55cfaa950c1a3da7144c9d14cfafb2143be2dd1823c376b057fbb7a197904f2be82e0763103216f8fc75ee757988b02575534c1cb0a98ed80c10589f5539cf5f74ee9e32ab25b584b455901f98e7140238824e4b44755ca5f0625ff8a2b70d681fe2717ab5d89b84d275b760fd51d8f8639693de814245c8f90f752a1a0a3202e765f9d500625f470d2a28be3e6256203c8c85f8df252474c0515f8351342d91b192298e9a53a7f9edaa030562aac157220a76b811f8b5a98a5ac776f15b5da40c1d8fbc078ca33226df3aba0c50229d6c0b3c427eda16ca581d3744a25777c6f4d5bd5365eff1d5a4115e947a05160a66448b3eaece57015eb81d5df4091b08339123e4e16c4ac9ec12ce5025c06e658db7f7eb26104d1135814a9320ead2e496128cf0e63dcb979601cf66f38096c0666d88059f17d250c1561e892509d1ca43eea184db1b3faad901c56ed9fd2640ef87de6758eaf8b5145ecac604cd461d2d59269f36d83753e61bcf281d928c4f9680a83f8d8bbb13d6e8e4a5effde22c1518341fed033380783a1792556549d5ecab64be9144d920c2ad42e36ee5a07d3aefe59e9fea693ee5c86b5b6e8d1ddcf91b6c35dddb5f93ec1ca67bc1343f66ffd4e7c696566331b9dd1abcc0c82bd0c651a2b51c5d080df0c82c6320a3049a7f559314d6098c5bfb9560349ab1980dbb0ce9ec176678edf99cdc363925c1ec247ff16584684bd38c2fa5bde4838db97b465efafd9f5309fa31127e6fc07071bf7ac2c6a461d6bdba5017088434eb1fb5fcdc737235bcee5b21006ae65501dbdf2c88e5f90ddeef65d8beb4503e727ca042a122463c62948a21b2c9201a302b45ce6bfaba0c8bfb555bb9b1f449c7bc491250d5b5a28c6015c7f46e6f6f557a88facf668c370b7a9d60368aab9f4ff859d870054fae124680c2c6474628c44f0352d64b97cdf983ce8643bfd53c52eaebc3fb3db50f176bdd37f5700d4a4354113a4f3eb162ca3cb2079f5c2341bd7da48d4fdad85bf0f1de8a564d9c74a2a6b0f547410e7883c24023e55c4de5dc31e577cae850412100b73eb5b605c671e94e78958c29de4155e01c19957ff37c4327b881318353d66127e53b08ab9a87e1830ae71976cc16a34d7f3d942e243c964b636420f7f7297ac8de565f313b61cc38bcc11815af8841db1b4a98d1a1aac0509800ceb5f689f3547d50ee5c8b659491f409e83beaa15a34693addf8593942e0a9ee6e5154edd7519e4effea1421e77f0e5434a80c24179fe32ee3b00a5ad5fdba01d7e9df7f468a246aed66df5776666525da6ebcf570b4ccb20c48eb954242de9928ae70b76bd848ab8d40a63ba3a96db683d281cf0cc62323d3aeb068102ec5497ec2b07467453e196bed05d0e50dae26187cd77d3c77f336e4df9f5288c598fb692d3b63e34d40e1c99ea858258fe9f7c9039e1125d69292c72c80838534c570167c3c975b02248612bf83f6ded9e795e2081210e5aa53ca2034be556946294f0367e1c8d8057e97b7ecb59aa88c29d98a9c2e6e191f0daa5bfb4295fd38323a7b3525772964bb79295bab7c5a570bcc6e070f95533a25b7ec3ec69a52fbe9b1ea850a10d7512c7e31906a519f5f1235209fac1db1111579c608e080655a0cf4bfb1cbf51209a663cf9eb34fcbd1b4fcaa8acfc23e319a480ff155dfed8dc47caa7a77fa5c4d2f50361019a288c677f4f6871c7e3a0b85389cf24aff061e2835a1aaf0bfc040548f6eda3a0f5a2d22e523b3d35950dc5f92483009c355cd94be65ef6d3f0a847259c70f8c122ad3100f36ea6dbe9aac603fe73dd05bfeb09f67e69c817f2cd2f173a191036074c1da81338b988f1ea37d2a25ae2b9afe6a2fbf0605dc50a7c0ad36add6a9987740180f4a18e2eddd96f7e9c9c722f7e0dc35a47111e073f8654beba2c90d8e5e05ee33b24ac8125eaf71f94a8e9818f62b55a2a5f339b50a825c5402fbb44a94b8f0d8aa5b0d717b00f79a0a35727e0b476fe82b27e0b0bd5b91a5775f829ea6604e2f0aec4f5d7adbef19aa8524d7e1389e8e8fcd443225968af2628b0c0c06267907ba58ca21fd4750e3d90c7abd018ce4493818e9a99fa8d9115b6950cac5742a9065cff70a8a35dff50e6f2e69ebffab24c514661ece7f6afb78228a913e5483e5202a06754583751cca303192287060a5024315431ee3067e0fe029f5882371de27cee98c8d9e2f28c71bf783e5f185ab165950174755b350979b0a39c63267f5100c6923fd262b44329ea864a657b460c1a246901d6f1c75f76652e6f60f3c10fef42bfb0812a61579df7cbe630811988dfc1cf89c73239ed5ba7a5f2b0311168981edf5ddf48a344b5285ad9a761e0d14b3996c73414a62a66222ede7380a7c3bfad61ab125baf669332780c3699ab0c81dcaa35d3d782726ace87e9d093a94899e39b0035ee2daea41b7346414a858988c3d206b6ceea893ab81fb6246b63c366083407e7b416c796aaac0040cc7216b7fd03e194852591bace237316ad578e2ab94f744173d1c335830041954c20a976ffa6a4a55c038b145097d1f31a0599f3ddf6eed8cc9164f967dbc4a10232e769e024b305f7b998bb6419f321e905ba35c552789be928e1abd05c63a9ffd34db81480b415924efd4cd078e42c95160990680f1b0d86e30892333a94641f67ec89ad8a032ae4bc0ee4dc0599f203f4dde2c19526b193d13cd224c7f2932de3e43a50757036aff6b3322b549f33388bc3cadcfd7541499eeef6eb4b939f53bc669388a87e630d3e44af4f2f12b6acddcf59d75e9c0fd36be5bcfedf08499e41351d2a3ffd927d9eb99ecf172523a41f0d785f79398a9edd76f882016e6eec3ae486aea8b103d6ec8596e854d2c895d3fb047d672b43aa3576b9ebe5a190a46715500566f6d88975319a6e66e80a3eb1d0fcd7b788b60d91abd8001c663887d8ca1afbc33aedff8c719eb74a9924359321278454c482869eb8ef9849e3f4bbe3848a554dca9a41ac40d2ebb231b872cb1f8d58eb5ce23a9c23de884f3c65a4860346efd72721594c96f44cf7fb87888015a9a1f13e17033a42204b37065739454a420686716a071ad02bd87ca2f48a2430fa283db5a453d58388ee71c1c4c44daf35666a41745104cb7de74420ce5360032253d36a15b04e93b2a9dc4e48482d3002292ee1de23e76b724cd17dca9a2244d4419aa7f031992cbeceed27c72b19399b312381e7551003008f05927ba7386181a3e45c3114e2a7194d7cf67633268a23f5400ef78d8fae230147c4dfb2c4c71bebc381b3134c9a26792729f9c8c0e315c28f3a129b8fe18d109f46321dd7f559b89e7ccd6688d81e22bbb62ed6662c113b719b7e117223a4a7430d30fd9b124a8edcc251f4159357913a9fbb5a5f99a58db4f749c7b00030390d0989da9e09c6774a6ad0a554c94f311f4f698a3d4b880bf5ff14e4b5bf8399ee70190c2202f0944b2ea65fcfd24beeff711609c3ca37d93f4a1b55250c1562eb408ada8701e42dd786a72a59f4058a5e122f612746452eddfe0b558e970208056d7b230a169ae8ce529a788904ce181fd6c56837e3c8fcbe8aec30e94be92d30675da3aa7756e52dc080606cc18ceb69a948d0da2448a0a1515e5f3440f27054f1eee612b4aaf481311bc18edb220605ada776ae286516a91013c2dc0038de0561f720acaed68b21b45356b36317123f482118980d41be5c6ffd51e3835b58c51e66eb0f2958a049880b8c845d5133b78fd2993f412b9c086025a12be5441cdeebed9c48eda0fcaef337272b716df20475db85ca5b3b73fc84a81ab059a350b9624c367a1db7c703cfb540edc745231ec2143e2dee876bdfd047181bacc42ecb84a058bcfc7a3a45a87cc7ed9d79083323d968efd3fbe915dfc51fce97a63fee0c31c51433d73e1a2c3fde9135f36297c48097308fb21d0f7d701264d1718fbe20e6f2c96f1efceb14a560d4b02d664609806ecb5ca99e48667a3afecb2b77543eb936ef561570b823365d08785e8f2879adeb6a8f3ca41160e315aa1560a790a165e35ba8ab95e7edcb2d8b9dfe4c072f5555590a2482cb2676791b1503d9d1cb6d6a817c2a6d6dd4e44ac1a7ca14f235c3031e4df25b77594595418f7d97f4c617bebda0e9498f30bf4ce8dbaa036f84cf4f2c99d006054319ea4095e6ae4ed377a9b2e5edfd9107ad9385933061e597be92fac0f4ed2a16e39f3d36e6fcc5fc746be6cb64943c31f3532f35e301641e1e26d78911ea5fe9bf7d87925cbbcd1aba3686703780b6872fb48357e08ee0a0dcbf3b80cd27423e794696f6fa488f8f8631b85d80ffe9c20364fee7c237766acfafb55a41c889c833294e57ba7a568183587c91beb7a273bb14c9a1898c8d4f5c12e6912adf4c8753f21c81fd49d9dd81049f2fd96dff64b6c84678bdd24f85bfd0e46ac3cfa3d3890bdcc9d84e5b43c54df7b403f442156e3e0a21092dc35a759bd7b24b6269a2c2277c9a0e364b42c9386880148a5e30fe763c3d5805ecce6067dbf15b6e4d8bd1f0fe026fe5c53ddf21095905632931626f6046178b743bb3aad188ad2d19620033223e7608d34ffbbdc91014e52fb98e31d2463625fdc15bb360a883fc18410bc1226db8393d808f89154dc7a201729c0ce68aac6e25a3192a4e1f80bb145ba46b71b5f54521da9c98a21b301219d6c41f127dcc0798a74110babd0dbddca1773abab91f16f64dccfcbcccef980532a29ba32f08f917db299a7c29d5bac05b7e580543a378b697f1ea67ba2591c0b0dda71371d3a722110aa10471a9cf03932f0ee13b2b97a13400f8b7eeb3995f9fdace18ce322f7e7a7157dd79d559f5434af8d6751c01e0847cbed392ac917feb1263bc0d4d6f6dd3dfeba37ed987dcc55c0e18291a6a8427affb816b4e555fb3220883dbde15457ad720662e95509fee47598c893b8af95152cc10b6a90e40565bc9e9230ae62ee549b06db4ac7d1db03158e97c447494d6b906bd75fe3514ae0ec15984cf8c9e4cdcb74493d4ba124bed0ddde8a7d8d31673afbeaf454d8b5c7810e1f5ee4dfbd650551bad0e2a8fb9d430e3c51b58cd15d81521f8b4a4a2a3f5a860359f3749773172d8a201ffaa66bd32a6af5f95f6b3a4bfaf34272e6f798cd69589f601c5f03ed553079545fefd54fdd872f9c0622f16f4514c2419d6a09c52631044885353c7de4383c3c5473e84ea880f5a9841729543188246effb87d659733b3cc0947004da639575da9f9728c62156a943ff1ebde630e798b321fca2709e6c96b074b2395760b9bf1e041bd5794fd71ad34c075e0c26bcfa1a4b21cade968c489ca188a114ef37ecb4b7142570a23491159df97925527144f2938ba5dd04820616b6c44e16483ea938c99adcf4ad825553dc3383d0df8fa97aa22f3b1a52b04e505efd3ad63c5e05350f262b5c956fae18360def7cb14873d5f342e4b06a74e536935a6a3179f1432b1de41a14f8f6d103d2b5571150d1a0c84d1441362865c67d0e0ada665808eca84520d408312c01e4d643f36db6dc77d2fe60c31ad322a20acb6e91b09e2f00fbda96edcd5168c32fa8179673ee2496505fb0a5b7f91ad6372f7d50c9d4a34e3abdb7c2ba1ceb032cca0495536c6362d1c5c7f7b0db8858afcd6c0af904f60aefc5c42c3895920ad61748b095ddad2106f2ab2694989782ddfae68f800490fe4edc2cfe70092f31ba31a337557afcc78af599e6e52df6005cba6c6ea5255685baaada30e72fdf12b341cac93bbaacfc2bc6a2cdd7dc983633b1a4840afaeaa1f01e6ffed32ee04d640b6a2f18df3233951b3d041f30f8478a039827237b7d708bcbcb3be2a5cffe40329fdac1f5a59a366207168d7151583ef26f85707c23c8bda648f5b5ccba36e675d76372c2d1ac13bfee1e13d76ba4d478d6ae91808701287c9df014a656847b49c8b0bb9a193334a63db2a40e91d6a51a47278227f7fd3bf628a5ddc6c533452fd39d5223efa63eaa5b1741545d995c0cb3da44a19dd60f4da5a4ae42115c28cd27646aa9bd5ed4f4a8fb846b2019b533ba9e73c7fdb64be4042913a06e0ca81b2937482f555b10ee949e94a3e8d5a1077acb01c859204560ca38ceac12ada504c039256298acc9d49d50eb85eab861d621663d65970842bc8b9938bae9b88ab64e406c7518c96c82b477b45e0a162cebb9ba9d6ef80b56f002fba92777eed00d024ab5b1d0473b2cba2b7d1afb25097ccc9a9bf0ab00032e53ddfd396983b5a237d116f4026cfe52aaa0aabf7b0d62e6323f29c0587d7ecf5a9f6375fdc878dce69d221bb82d1033f4cad9c99cd659cfc5ca698207111c3b87f2f6708b894fe8e02661c95497099143c99311b3bf46345002738081fec355a0458bcfd45311c85d20d1ba364d1d77b94502b09c4bd157e2442934ec682aa55f81269221923acc51bb13ca67b75e2d904d6260d71b03f4f303179634d87650642a5410ab29605b6b75313eaf71544194ea79345aae8c4daa842a4e2d6a30cae6311cec7808d5dabc90f0e58c0ec6d6ebcb22f150471655103e71fca98029c8d777bbf4f755f3e6b6a22c9e874909bc2f2c8894b257a1a7d230e0888ac910851abe6bf5cb55095942057512e8a5ff82f8caf74775842dff7b3fcaeabf27b25e300e9890dda83e7b3b1c81396c1fa2a6b663132082891a005abcaf6cb0db39099e706a22aeb3a2192d4165ceb50a790f8dc6105a71e00314aff41aa257a9d742b5c38b69757366fd0ec782a033cfe6a9523a812a8015d4e01453a70351449fd96d88e0d20127746048e33d7134252a576d3e8b632349088451ef797c807bfbddadc9dc10040740c55892b186a70ef74059b4702739f43e0c746fc84c33cb6905a8792c8a82cadb5d1b8b677373d4f408e1ccd08060ecc8dd1ae361365ab473a056b1f9991a3a7e270c3ea54cadfc628402d520e33beddb627f0f19c155833ba6d33104a9be6a036718cd93ebd4e7effb9c84b37b08eb35e417310dcb60d798ab87638accc30bed3d1785651f4630c4fe14ebc293b14d1e446fd476984ecb094d134066c09215b8d148b5044ac16aef2c15c12bbb6b055f8bb8096cd11a1bd597b369c63890a93ba5704c184b6102dca5fc62883cc8e3f812d319ae548b94db6e31f784608c1c6bd3135c4db3d247de51d4549a16a6faa7706cbbe54d0a49437d27baac91a59753bcc1a69084916b4382b31a1bba9a0f2aef5b82b751de6588153cf42ae4bfe5ec7cd43c1b2d73877dc54597ad83801fd5cd000ddac39f8412263b17c65903b7686c3601d1b864b338d3afbec08db458b0931abce5fc5b660c0b400311bab43057ff7c95fad75111f3cbbe551679cd63a90f6b1c4cd279aa4b0e4ac065b59964d8a68861bee712e14f55ab57dbca7dfa10aeccaed98689e75e9b4f48f40e590210c532f64f15b7b1fa5ecefe97a5e8469a019b2e7111c8a3188551778f5ff6bdd5a7399d12bf0e7ca920ea42290aa19eda8ef1483e84666bd58251052749dd4d7b5d8079eaefbf13d1894db8a505f4f941c383e0cf7d3d43a2c3c76b52103ebf2d7c9b37e6b3fc2144b329ad2f1b97aa563a7ec347750941d42d27546985fce5927611d362b543c83f273035fab23bf0a8a2e47e4b06c7d50005d9efff6deee22ee42e4dd720fa79f9fc14d5c32446a9c88135beec4cc69bbdebf0aaac516abddd97a114e9c04f65fd33838f78669da0ed5659a9403bdbde9a5ac554c838ccf17efee0254ca1ee9ac8a5c138c28b4d5af4e3c0396a39d378e115e0607fcbacfe58be3bcd60db5c9026da3d8dba75de9f4","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
