<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"506dbf01b09a3f1f45523c2dc00d79c722ac1c1e038dd1057230bdfda3d417295e1f4463f6d8379c358c1885e7b458751a0078f1c1d338f9df90de16b7a419c951f9f60f526b87b081a0855ce6ac419701da3ff61d84028912b536794b53236a56d5954fd6c61864c5df7b324e691d2517159650d112a4c90bfba0b8ad0d2fe172e60e4083fa3d52697c39cb7fbd849159736cc76be89a273225f94540270a59da24cff7b1a3ec743eda5de5d2af78f377c95e07a2365804ec20692469d4d6adcb642f5c8656d392490c119e8f34711020edc7d5ee19aa742675c30f325d637e9faf95a9bda27f1c7389fccbe5dde65cfb1d4952064bb34fa9f7656be9c80e8380d381215ec38bf18be88fbd6297d985267eb04e19878891860d8e1b897490325561c3192f2aa491a6d7084d161951c8f2fd017cda877e15435ca4d8d606ada70dc1fab9636d38a8d8205b9f2bcfb05d87179bdbf2a5abcec9a180d1806c29ac66222d533a8bebc0534acb9773c7f036937a1d63ba7aa7633fa76493db1a46a296c5e594e24076d2ede2f92495cf0292e8bde6d3ab8907e5a18ad34ee7a7dc315031e427d3bcf2bd616c8a7b9364f14b94ddbb30e6a00f47b5dd64c1f12ec4cd0be8f1aadab545f461351dc4c8ecff0eee25428637237c451eb4a983cbbbe869c081c1c0947160225e0dc3d2331d500de4dea11695d4020ac367302ba6c9451579603a8505858ea6affce4cce28d20d1168f9c668aa5edfa8f712dbd5b8df825df31ef581f6ea0322b0e206d4e6d96d9aa49c50b6851d67dfac1cbd39f335d9287976a9eead34fc301d4a710c665fd8f603e2a1b6255df61ea130f11241646a92c5b5412549257dfcdb8aa0455eb6a7d585cba5d66aee352fec7e82822090c0f2dbd4fba0b00a198de8d97e94c81469116a3aab1abcd8cf108813efcae9ce41bd954d003bf10a2ebf519f6791937629bc766fc8728a849c4395acdd6a9444de0d8f30df8d18b7a2417dd39c01b81c8996a6c342fc2680998b4c5997edcfbf88942a66206a7f34141b2a31ed287a194a5811aa1909db779d2dccf58a6aac5f649096534222e50687ad4f3601e1632abbc633f2a38e25801c123a3387a7c2ae3b9ddbafff08aa4b0edee99109a4961e9f6e961cad8ea656c91e7912990d4e98c6ed983a190c323c455d34a80429878feec2a76433e9f2a67519df77fbcbac00a6b158118b1aafec56464c1c4c7b4e3b9b35fabbfd93a2853a5689b73095b24f5bb63a55159b58d99e1a5c93874afa7e60c8fe3af594c6639a7ace08664440304b1a715eecb36dcb4c0e6c3a525367bbf9b9154e514a484641ac1a5e0719f2bb32bee7604b9ec3035bf6ddbe57ccaa751cf932495087e061525897070674202b5c8e244c478d48cde71c08549bfead1d4de9534d706206589adfa1d48317d41cd909565947c4865c44dcc7e13935cde278c79d10dbaec96e5833ee9c5627b1637f4ba40e5bce407d56b0ca4c19726729bb5f88a16b5f8f8dba89e6166c07c446aa7a08e788f3fce28cc296c23dfd06d13b66c25edd52152493d3c33d8937a498670fd7f8ca78816ce5b64e462e6fb718ce5fc8a80689c0bdb8d476c4b6f5fd33f017df795105dc873696d9d817a54113895f70fdcbba5b012fbebfe47ab93bb76824f8c68e4c68ec035ac88847b80d32b7a158d4c4f95963b918ba4ab11d615c908906aa61a66167cb17b200216f7274e48bb64e38a3c25278032acbe54657253c17ef95b0e99f236f1682245b30c305ada1ee6c031b1bc4e6e3a997dee5b4dd07503272abc1d58d0f451f3a07efe6eaa44f97a4df7f85f50b0224661e3d092cb07ace351fd5512fb7f3bc7a282b3ee9cbb7ca90647f7d392cf8ea40389475debdc1b623238d7bd1523426de47714ad4842f2cca92f2fb5d280b2dcf3ddc6b42eef0ef02d44b12d6937ce3ee421ae60cceaee9ce3608b905c4f004f68252a55f7cdfcce8864e213eb7b315626ee6f34edfb6e34239ced280da7f9ede7d35926a42df6330712081d64e0cfa68d203b71c6b2310369044f56047eaa5b48693ab19e6a6a3c8fc44d99de68a4215d3b5c991c159f6a9df86e34deaa6dac6c3e698741aeedebc01b6426423f1cfa1b534a741fbe8abb63567dfedc45c2493dd7009f2ca0ee2dc3a27f848926b88f16a7a0a11e904b7e9d291d760a6b49d995eddbf86f9d77e4a6db74b3e9bfedcc69e6446167a5019c2b27f3036687b2bd97f9d06430d5cebe533d55f9e8bd41db9b53388b6456f4ece17468df01bdd76da6ce18b7770d6bdea48ac7c6f4586663553aedc0fa974ea289bef84eef8d9159f50af4f6dd42a3791030c8ed84cee91afb370c67d29d923052c7a96e367e76d77acfc3bef072358ddd26d6725de9257604b9ceb75ae488ed69454b01265d73935fcacf7f59935140a756f68a932eea2ee2d1fea9147c5f387a1a74ab0239f40eaa6a603c515136a237f1df5b5690cdbc730a90e6f3e00733ef1615ac8c61c2eeac2b12721e0a04763dccf5a06b63406c05de75b38de90ea4d1146c28858765ff0472c88e1fb6f53c6aff1a0f13f83b2710dc52b5ca78d608eeb3edb08233e678fb4e1d37550611a2102b06d25c5f0e6488190a91ac65e27835ce3715e3e97a8fe18a803fd2a72b788af4371fd5ddf852d6a5f13808960a7bb68684f726696f27217c080a43a85b5b702af060f77a5ab05dda07629bac8508b3d745aa5bd7ec76e8b9a1d6a58826e58e9d7b4ebe2b1d545ffa12f7c74ba4bd47a529a9383248701a714cfd0c6f46454cc3dfc852ee96ae7bbdd73145f0434b2dbec6515b048ec81995368fec1f5ecd5b30a42d491fb0ff723de2ea16ac8270d3a2feed21d20853efde0254f1729b733a9d764ba75c7185c145314582f261a8527ecea030404df66494688d1eee670571f30bbb920a2973310e949d485f5aa8d3bae05a5d438c1d3937a54a8aad7dfa9bd857388e6de5157c03e20b59b7baf680f2ec9fdc2803f4357a15759afc1945f80f4ead8d59e3ae221640f9c7855222ac7c31522cdb768211934f5d9c665966e7713ed841c9cd1301f16c8f35371862377f442417bd3fb732acd51c7d725d0a81a146b2dee87e39ae53ca2b0eefc7dd029f48a8f9cd888ab86863fa52c8948f58f7cef3bc1b9d74b930a34395dc91f4f434152830dd01bbd9e18c61bf0cd029c176e9d819dbccb83a73d802b5b3918b0a1bf3de0cf9dd3372faae54db9759fa69d7b07487d46f04e4703f17a0f5d7cdc3651ef207a0e0c43d7579e15f97406495fc496cdfacb8973fa4102f8ca9ec4411d8ceec2357cc6ff553419e8d8a9fdb53ccda5988ba6a5d399ae8219cc5e74702d4aed73236e08b5917ced7b569ef45c92a87659fb2fc2fe92562e0cea285de73a77e6c217350b3d3f86996daf28c4f952664c32d9617d3abac00ac8e2cc14c86d91cbf85d2d95d138a8bce770cc5f77fafc5df67731a54cdd2c7e59fa0f41ff1ddfb36c6df6622016cd080367868e112cfb06c85a714ad2a17922a90009384becf013e7bbb2fb37ff81aaba0522eb51051e9638a0386b8d0d8080cbe67ac8cb56a106ba53525692dde586aa15ebae863c1a9e42bbdad1cb610fc9eaeb0f054728c3e2b4fa8892ef2a919dda92504de5620b3264219e5e371771c5ab63b6b8ffede764bc22faea4e702eb8bedcf5aff7fe2b82b487bf5f4b2f45fbb8814a43c96830fd4aa1a46d283921bc1aa49b1945547e41cc3f9cb9532ab863ad631a5cd5610bec8a921768ec0ae42b311d93f03ff3f455483512975fc7cfa188473b76a3df824718815a93690e91f5db797aa0579b85dd6de90bd37ba73156e5425ce83bb513a3c714a856c95900205fa0e1cd1db858b46647c411fffdeb4480874e5027248cb95d9dd687404ecc1cd7488c0d6da2140f7c6d7bbf377aa4632fbaa9a13d523e891bff6a4a723b78482c73af80bc48a0fd50243af3ed9ed20a8f36444134b6302f6f51083536b821c9aa30920221502104d98fb2c58ee64b0e0581536b06fb61d29bd699363427be3914b5c494ddf5b97fc7ced0ac5778b3ecef666f3e9a7c4f8b6b7635b640c36ab9a8cf14e642d8ff1e9f2eed974fdf2053d00dbd323af46ca5855990ebe3d6de1b7cc34986ed55c8497df1fd71fcf517576a76e3af791e4f550e8e333994e0413674fdd3909b52a08edc90c026505c0cbdaae9eb9e9b426d591e41e3942772106ddb31b9811dc5129e094b43917972dfc157d6ad25421e4c288dc7cb868b14f0f621e0aa0405da01c4313a443a47e0aa4a88561d9fe64920c3b15a143a6167e1e9fe8bbff8802ff02966d7d07ac954812061701c7228c15909e8c53634c8e84f2a59b33cf2daf1713526e72bd0050c2a10d1e2bcfca0b7ad737aab0a0b07bc341bb817d8e340efb9fa97a6a27084c187d6748ffaa9106aa1efa3632da30722d94a7d6b579f0784663580ab55172d7c439fd86d4214afe58e3cd69680965e253f516ec394ab0074a15f2badee2b46a5f757fe142524f76904688c7cefa87a901e028319b7491058876b21f07560e4f9da6f18c79135a075be837878207ac5434cda339115ed2ede741923bb56aeafea67bd9eddea1a4cfc6bba8e85ebe4eace1b66a1c7ca03bc12295daf91ce06c1038d00670b65a7effa0712e6c35227a9be856b9a0fd4c65a0c03de26186eb115f5bc7ef09aa2b12970741d2a5693121b42431018cfe5ab48b10eaafeb6b948522b4a0d2aab5177c60174860437127636862b18deb111da16edec91418ae2ae8dfff8e97b35503d5ccc31bcc8d509c6721d1b3463436c99e8b85baa5747791eaad793e7c4acbc007c94c2be7de2c06108f357c15109838b0aa143e00a365d8b490a74a38bbaa879f3eb047a4c18ff11aee22466a9c3eaa833f143cbb4b46f4fa09679f0f06cd16f5e358ea11306d13f7b05973eae41e5a4e24e4fbb0edcc19b5e8101e776ec103879bb9ed7c1499efbe6c5c9bb5bfbfa1531c69fad649558cb6da9e43a4f0b77babc846f61b42cdb6aa048b55a7582fb8d7ea51c8879054ffd764c5abec435dba726ea4919f39256f4b99dcea5d0fb02cfdaeb6ed3e7bc052b2f45ff12a28880479d10d8ae07f3a07763cc141f15d1400ea6ac0198de00e16b82738918ce4e45fe306997502e9721ceebda7d6b60408504fd86c8570c06d963d67fc7ad8d532e413fca8478242868cb28aee815d3294d01fa875a75522c17df442770418a4bd57463ba232b0c9a6c8a87385538be5b3688a3714a43404e013b3c172efc481c1a92003f7d413216cd2f83cd99fb2896e1e0994d5307fe16155d9c7e8058e5964f93e34d09fb1cf5c0157132cf982f7e2bba99026331631ebe8f524a814dcb2f9708204f51736cafeec54e1bb5b7613d47dbad37c71538e45f2b51d28d9dc43e68fb309f0bb10922cc9fade80b6a06118a0b32f0a9853a594937022cb5a0c7074e56d8b5ca671855499b4df51a634bd174ed46166c033d5704227a2e0cb46fe4a328bfb166b2f7aef9c648d656053a54e798564c03e488f7b1a0770f60591cb13a15be28cf2d394d365ed544f3dc4b643d52c6ed9e88572dc89b29efac404cf5efd0f98496040d03e79ae59ccc5a6d9dbaafcbd66f05d47943308351275e519471d60d33fc58ff9552936cc04869dd5ac594e6300055f2c09251527aeb6d0d642c8248d6d9e8161f3fd6c184fada340586eedc001e2779747fd1973f5d7337693d6daacabb7e7fd6c72d1b0e91785d042e356f1c2f901df9b8d11f9096460b72c5f95c971020033a84b9d005dc7486a0409a659246630de745d19c3c3ee7ef1fb843564ae6e9449c8e1e25c3f093c08dc6c2138013974a42337ec9c09d0aeff8da2d90ad1dbbd90741441eae519f727612ead391a4172ffa86d25089f4ffd8d5a231a0dec4072804c1d5a14f5b0b7b68975d4e80ac4daaaf8317379c51a4f958e7e5c8a54ec46f8f64284bc9f605fb3cb72cfafad709b6369f42d8e4567418d713fc60d230bd3be3cab1b96b827cffc7e4c557718f9cb099b6425bd0cbace8da776cbbcc2cf956bb226245c9fcf1fcdc2415b690a75d67b6b9109c18839078e082daed1ded64c765485598990cca4f64498a5067f0cff880d77a91b1f91f271627043bc3a8316340ae4b3ec90d2073f4f16f2a60991a78568b46e3b692374e2e24004853e837de74757b066d5ffdfa2cbacaa7b836f237ffb1543dac83b80c85cc270a2ddbc281db8c9f8110b726488c49bebfd54a8eb220c4138a604417d28f18ac2b3c50a0f8062b5494b61917b4c2adf6754994dc75ee2219dccfe1a12c5f814e6df738e759b8faddc290d6d36a03efbb481adef7a77efd5aba00bb8f004d156efed0766f8cfd126308af9059a620733092e18396e5a2902631dd57881cdd6168a9e9de034984692570440d2a9f5f47cf8c56d92572c7b27d24c1052dfaabf6c9c48bda56e36f0d4b9f300cf5e363b7d9227c5c6e4398967dd442fb504a0bad2cdf2018b92f993122ec1152e4cac9f9199be43d83e913918834148f9890808ae7d61257469e2883bd9dff5590a4bc3f77af139e8f182ff783b8bca630e9c9177be185a63f7a8c15f41ab4ac8a0f3ec577c38ed4257023f97c9a40235df39c98272910ff72c0709ebcbe6c33934f2a876f2e4e1cc24a1870d560e8b8080b2d09a26966de71b7608ab0748176b5e6dfdf30cd72aedfb9d890942b12aa805c7b79302a75327ea5a40d6b3f4a81571606d0236819606a3b3f776a50c7732b52a59cbbb6c24b3280e91e53e21c1ed2743bbd24ba5ee392b39639ce60005da0d60c7db0595977617e5f6df3b4d8d5504c291f93ed560f43faf1a7435df65c009396e22db5bde2ed04feab890ef86ae601f01d6c4f300f76316e2db837950d09b7f96735797e1d28a8f95b4b9143ae8b5b5e7c9c78c179842a46e2e5452767f560d46cac189f819cd7f78ef6fc2f5a87d2a04c4d6b3816be8a4aee57b49d421602ffbaea101d3bd6d354ab36f41c5b0c9bc8c00481d067f7c148be80cad66fef4b7c2b46835d5c1d1fe32e30acb312dc5b3cb3a29cc31a511a187683e78fc8219057f304087fbaecd3b5da9c9bbcb84ba949976251ed00fe2bf9c039723fa2512d3a61f9be3cde90c2f523229b9e282e0ace74a4aadde232c9d5a2787a45465d130c48b98f5deb13204cb11f4a3dccbc398cfd4b787695ee81b155b674c2fc5cc8a1e6bd8bc6cbe41e230e96bf1e57974b449cf31a5fb67522a64137ecb91cac17b2c40c43455e005442309060a54eb0cedeb57786d4ee9a5c5956309b2705dc3185e7c96029fc3505b4388dcf762e74ab9770982da009e5cf00640e3fe5f535387b96a52f6e0b3a2c6d95a799434e4d084f42735237f784217717e55d23b488ee6cd3f97e1a5cf6b4ad3cad291a0a1770ee4a82fb084374d6e04a2a3eb2fad603527c9c064bff408197fee0673963d7b65e5b1d1f6af12e6264132b7d6126a9995fd36d52094e1f6e3ca78a93cd2eb3970a4ab70f0883297446340db23e9a7957afe4a34489297dc486fd2e87c238d9a8ca7e473ef03c6e2a47a9cba6c13f02bafdd33caf83d447d126f3bf59b9d4f024593fe4f9ac8cdb72342b30a184b9aabdd55d13817fcbab4e98e32130cbc7e403e96d886c47388026bc57661112b6beffeb3d08078ee8ef4780c302a8e133d207597b3f823e9bc6f871157c4d4ea1f74973f09cd9c67efad12d12c613253b0700aef4e30cfdead74522a20168dbc8d9fb59305812831b8fb46fbe8cb648c72e8936ea067abefe0e913d6e2f591ea870d1dd6446663a366cb3b661f062fedb219400c476ca1a65381065ee49967e9cacd98333d8e75726ec40aac68077cff709fe17503f6c2d8cc2dda622127da7ea57d605510315ffbf231a7eb751e1465a6d803c127ba612209ec99a3812f0ba4b75d5c6d229e9c1ad663befee3e101a60a0113f3bfb34f67e436e0cac852b9a7faaccc8bfb34f24a84e90c903f6de006acc98baa9df7792f466c9a4bbb13c919f2c7e3ebbb2c79f058524f160bddc41bf388dfd2103418b8854d7458158be4789eebb75b86943b34f961700ed143118f8e3d21ccf8ae8b0f0dccbb3857aa3299eab38bc8f298b3b7959fd4c72cb3dacedecabdd7f48e0534376bc179ed8a721dcd7187f279ee21e2da2481f2782aa37f8e8b0b8c1528a9a3a86ca5bd08125943a9ea6183152fbed09531b2bd503b027670b32e3290af9d467918d917e48596b587758b4514abe24e1077252aa6992f14e2f3df06594dcc240ffdaaf97e3bf884fb0ac38b3acc1ae20d904a3eb26e4f025d7dc325274f67153e3d6a86ad051e0d02660e41d06a4ce3dad87d66a2d8a8398d52c16b201f7542172064274952f389ac83af0f4446c801e4e09d7c67738c01fe29e2c2fb2f72daf65a2cc5773b7e2503c7cdc752e051c32bf9e645fd029e94522c51cca0e8733cd867bfa877073018202f2e93c36bf05ecd0ad78418b6413a56c7552a6a9cdc9fe1e112c8f238794d001093722f8a6096aa746bbc89fd64166b0dbae16856837d11a40748ba12a94530c37d812b87d3be65260bc081d235ca547711f6f9b2816ba1a697db4ce3d87c2327a11151cc691a1ae3e0faae52f212b20c10ad498638ed7573715f8628c2a614150d8f9289006c0aabdc23a4115bb13f08a0c3eedda6d50e12a0e5e7613783148205dd4735c1d88c4f82c54618b88bb79a2a6c82c7e4f16883d1014bcb2f7c954b5e771d580f51335be818f53076a3ab297165b678821f6c03740ad6692cf835947e7feefd9cfd3137a01b1898209edc068e07f58a15691b6e9408a5fcc802f988378294f93f8c1bc5ea8713a3cf11aef6599b1cc6b13d370d10c46a1910226b6e25866c2e581b992bbe384e92a778ab442ac562c627365fa5ded75357befaada7217ffa5265f261b8a0a9f8d1706767e28110e0c19246726a6af707b6eaf92b19106a74fa1d56434479f04c2d2eddb938e954d8f1320f41045ad0d2a9a81d4597fac763ac17897442a98a1e885b36f9efde43309cc81a3a7950136369241afdfaaf25b363c13fecd5c4d5233d077f38700056367c3f2829e9a9dad4f3207892fd32bc3eea3d5a870d4778bf7a52b57cb8b14d26ffa549597e6766578e9b414c23f1961604eadb2b4620e5b42cb027fd4f4e0615c03eb54a779040d524949345dea41c3cbb660b3edb45df025b9fa652fd22f7daa71aaa5d3d13038a6c615ea58086da05a02b7c19b3e6a8e15c0cdaac47c4d34a6111eecc291972d073da67a5a61dfcb57a0079745d144d28bdb6fe573e2535e843a98adb3fb6cade02ad1d8557977a5152af1999fcd3df60dbdd0a9686e66a1102ab0682bdfc5b181dbc645fccaf57b14763731637d61a5f04e279b5f004d4bfe6f89f5eef9cf0f12e62c56bc1f75fce863da1111b3234358eb5390f196c37da6996acaf4abca99cc5eb8a27dce326f70bd7e4d57da063d7367dcdc3d22a17b177446243ad44bf81ea022c77b52c02d29de382b47c4388b0d00bb75544e3f72cc4030fcd579aea6b74ab8735ae78fa580980bef59dafec0d04ef33c7ef8ba7c4a4afe3623816e5aa9e53b4c2fa9974ca9b0650dcb37f290677b572a1ac8f3cce3b4e9fd4d36d4ee4dd791819c783fa205b7eeb953fe2bd86026bc655113d539ff2463a1c891a07d997efaf78794bdebb29599275d6b145b15f8a81b3d2c578f76922aa9873d0559555d53122966161e71efbac21c9c3583b2c3b3f855fef7be5f8fed2f3762c052fab612443b74b448de721c90886535c397884d250482956255b3ebcc22162a8d88d1ad1c07bba12a466f790ce9938135371b8edd796fe7f5bbace2eebd84115e721c2c210064eb0a658e5fb78878613dfd60972cc1fd120037e74b32a1f958f3176b54c401effd94a75ce542b9e4de687b622575fd944774af6de62a2b29b72d6ba0fed21c2bb424105034cc1a344ad304c642c8ab7e63af4856e84cda2cba90406593b3f9b50825ebd52ef75bc577223b397aa73dd58843ca4f81ac31def8f170b9320957e9023c1bbf19d5e4b528b4239a68a78ecca5eb2a3f21d6b81fcce4a4df50a4120ccdf91001dd4afeda6d1f39a06996995cdef4a232372158ed797107f48879ff2bebe2299ede058e18ff1571c4f99b9f73664784fb22b86e9f388b08281a62cbedf01da156631dfb80ce4718f0a79866aed0c40b982256ee03837da3af660e827305f82715012decb789b3b981ea412d3789ffa3ab1ee62f371b03129642ddd5c41bfbb297e9048911402d35c8d77e33d39a1bba6529c1c04118d1c0dd3237ccb3f481d63f315f0862d32791e9e9ce064046dcd994af701bc54f325ef6daace8472352e725780f11a6338551750df2cf8fc5fec431d9f0bebcf793c22eecf3efb60b0b8b94939edbf7327130217afad847bb8ac7ccf4beafa30768a4775f116ff6d76d2000c503ef8c5189ecbb733cd290fa49af414d41886f968009ce8225ce2c4b1198ba0c15e25d0593559e3f85933075f94a65d07f5024bf45ba02385fcd9e292d651b67629ab303cced6b8f28ce9c8415f54e70bf941167c433bef86020eee2b4fb02a2c584e84efca17f84204f02667eb506fccbc9a3d4f262d5b89c59bb7561b8cb90a224575706a4677e54e8d520b616ce1fc7780bd7d941f258897b375d2f3b54b8ddab805333bc591d851eb4bc620d72c1d6ab0ba20974c5b69d6d5e5a20018d0585c6fea99c9e32d1c342b25cba9ccf55127537833e00ebf8678ca810c6dfecfcb4633ecb8c4616d737cbafdfafa2287ff0409f226bdd34d42253b5c8247fffeb60b6d5d191ad4a6785873de2183c86b23fad79ec85c4cf6e554f14bf11c0053b95e86fb73953dd3dba893c93b9f3648e1ed44a7911b36fe504ba7f5cd024329a3672507959ff0f159f851ffe710a4f4a7bcd978e9fb5b4ad3fb964671859160ca3d1f80f2221c5cb2d720a31dc6ac74db7cd8cd03758cfcb9fa4345925561188b50121fd4e70ddc5071c6cf0a9183b65c36c05b4ef885cc8df29ee38f5657a3aaa7f4e52cb52f8a281accd6d11f953137cee97cce418305f233930ed7c92a014b21cc0dcc68ccdb14e2275347c5a5eed85f4112e7aed79ebc2ed273896b8924483fc9bbf1eef84f0187173a1116e03e72ac8d90301cb34dff73bcbe715f509119080ab3992a989ea55132ce723597b8dbeeb860a267003b4bd53534d3c25262fceabd13788ab031e1a2370df66b4ea2436c38728d8dee199d248335df34f17eb6499c2e607e43b5b900a889aef9946c2f89f41389f113aa911b8fac4a25bef2fedb20a6e866a7b2e533c45b1b64e01f08bf287b90f05f09daf90bb0e68174ceb1ff9bdf9ce93da3026e0a103304dae0452b4f6572338f97da1b6cad9d6605983e3efcdfdeca399325d0b4fb27d6e0ad5b566bae741414f21ab89bb9f04aadb89cdff0557dc5a6eec1ef0c97c77d5613f6a4e3628618eb8a5789ff9412211e5906e1a193873f8df73c4f82b61b302fba792bd537cf495f17563c8ffff542f93a3ae2c3b5f2f48e73afc5312d2c38c604e6e447d654233a4ded9be6ee768b1491d7d88242718c43c9abb5b6f4e0b829477406202822b709ecad2120a9206cf480f36eb6ce56a3a073ef5f1f4b1497b047cf7f4fab9fd4a0afa781b9bb58a721baa918097178cbd0ac04dd64a5c6744acebec815a4d5301556e9897e1aa4aa3297f414eb8a21da64daa307567c60e513656dacd70c8dacf59ec4a959f879cff4f30f62f04726cbdb9e97860b3380e7ae8650cbbc43a570dd0e943557ed0351ab147c690126c7aba634ec535ff5bd21775492143adbf969a5bdd33cee6469824e13ca57547c671df974b15f41ac09c4fd6ab740ce9f72c13c15827bd877ac93e66b145cf513f55af70e5d1937b2cd1b81fde45abb0da35ac3946a5954b558852dfd0d1c6af835e3bb53b10642a4e8fefed4bb84c8b78842fd45adadd42eaf25dcfe3e73b7a41cbc388378020e41ad220775f266dfffe38231c5a21c963842f09fdcec2e315238aec3f09dd7404cb37aaec80ed69320bb7fff12e250d2970c4d2d1dbc506f8cabdd483a1d4fd779361e974f9bf1637650b6375ed16ba4162c270b6cc62867ab6c0e6ec5059c9f000dfb77c047e51e711a8584d48217f2a8caf134596548ba21b8211efed5ad98914fa430be7887c5d10385d1d974cc7d11b0cc08397579e0d7f611c5e12701e530f62130aa20e370c6975b6e03011986eab5b25f4d9913fcefe45fa6fbf21758f81f45195f5747a0d327cf3f7be7d3e63476acd0ebe58ac9057588b720c89c482a7f6a8e07ed9ca46856f9b3a610b58a64593e56f0eb91bd329303ddeca1bd5b7d02103dcae216d69b3343ceff73eea4040946ca3a42a8218040edcb81e7696e2f7705d164e5bd91344395dcacde0cba899a94b95b5c27683c612957988dca30fc8feadaebe4a78700a3dee31ee7ffaa44d2e291d7d403faabdbf8b3c7534fe24fa40317bbc184a62d36565e85e453ec9f021427765676ab9c2feddb6ce277212ceca284648d83cec40752c50938faf3c207b998f8ae841e0248066bde4ecf3ed6d0bba4791b76b374b3d445bf9dc2678d217c2ed7cb12a9c79c317358e0b361360d12a765a29d853887a5fd21592acd7d3e83e4332d9eefd69656158b3fabcdf7ad79bef4ff1d54a9e4f4828e4e86f1e1496373b0f8085b990ac0f9b96cf39a779ba101c59d71b4cccee85eab755f0d6a9953ecb495509ae4e2d61210ad581bd5b50360e1f534f6948b8ec5c786c30b2b8a272d743c27b7724a1fc226ef5a02071d8975eb1b7b27c7e12ad11f25179b40117abb3823cff3ed6f095018cddd8e378c56e1898bf5d52fe79b9a675cead7ca93cd8ec92b44396287ed97c0ca30e787c676424c75c6f51abf76af9965e7065eb655cff904585906b6bdec04b45f9532e8adf88b97bbe4c11765a0ab9d57c0c1676eeaba6a06a5414f92aa8d8ccee013b233384b928a6414253f10f44c12d7834c2705b8b119d7fd74a04853876dbfb1b2a92018290f51b853e28bf86924d8d524a2007f4879c41a84b1c7879fd3d717f20d631997c83f8b8056f31d8e90a46735982ca760c5e005b85b5c1543696bd32576a0f9f882ed7f858f98cce28da004c13bc0311d0fa25d84c7be3ea16a89f3ae85a757c66398db804a292a870982f10d232fce3808f36bd7355d180f2823ca9291919a49b477f44006cf23f6c07d6f4b75be9e4d7605320d84a06d47fed1f6456a7f2431674e48191fda17d1e46d0c2c5e42f41c26aa895006dedccf55465c70fdddb38ef977f9d0ab8dcd4f102c8fe2503cc47eafb28830ad7f0c66d3e2f563ac12e27fbda814481674ef678b54bd64be74d2fa063c85cc8bb8152b80df0cee5c6ed7f093ba6aba1410b9b848259654ca66123f75491335b9d1104a3b80ff6a18f641f99f6d5478296cc620bcbaa1b82458923c55a9b66f0bca9e1426d8fae12dd6075defcba11c8ada5a37e9d888fdfe514aa6ac50b2b61bdeb6a00eaeb684fa8712626266cf3e243ea2e831e163984198304aba039881851a9492bfe81138718f9b474f8c79b98fe98f14addfd77bdd6919f55c728429ab5e80979d944fd5f3042702b0e75fd9037e3700c16dbdd36d27e7570f4f19b98fa5fe49478825f637410bda57983003f699bf30eff87d49f7d9754c85def561616c8147758e8e0777c8f1da3b3a0132df582ef58fb8ab0ecca18637eef15b1c26613d45398a3905e80b0a456413c80ee611a7c9ef54b2581e8362bf311cc84343350d5e9bd191914dc021d7cd0d6920903eb5f1f4cb026de30a4f0a1a8ff61f629cfff178cc0b9d083aa27d35854eef22090a6f943d8d793e2f4bc669f25722b3be730551aec062ca2a807bff2cbeb180d081409d258af025e8f0e5703cada1911df3914fb28c8957840110a535ca0cbf622ef41cf631fb60ef7bb7bcdbabc8901f72d3f039210f2f76e714c843792d4404669e6dbbadba1f3b3ae731acd7192351878797bb313def6955c517fdc191a51214bba98537ccb7a5617e487540f301b3c1902394229403ff5f5de0b5ccf7e888007e15985daa0e66add38f07a507acf40931483b5cd8fae75b9436f654d6140583f7a19e5a02e5a49c278abd81cc031c603de817ab30af64e229ddbd9357d7e2bb52dc51014a76a9dc734c83c5d30c9dd937661e1fc536d4d91f053c5e2d3742cb9a163fddbb61c13c59eaac4f745a7757de601d6fdaf2a025494c22cec75c5ae904eb1955fa6bc46ab9ab6e40d0b0822480d69bfd0a6c79c0b6bdd324684fd6810ca60d9a18073f92640188c3a13949503d4d6bb505939c0c7d1917aa735d054e0fb6ebde6fcdd1441af3f9987a1ccbbd7d2b9599956d3c30626d0f25ffe896d5b9f96f81ad5e8c463c79ac49740eb3bf54a90ba17b811cdbfe37517b3ee03373c2eff943dd43017a9b0ba157835fb63f72c88b25375ba810c5374cc9fa7170ff1f359ca1d3b2bfb91f0f93c4c3e455d9df64887966de670c33daaf8ffe73f314b17b2fe85c0a4cbb2f7a95a88a543a0d0e07f6f70626de3a08528de170a828ce1173a2d2b01d3c8631ec16cc7a63d7f63175e1bfef88205c407d125e6ae38f32dfa150f084463cc68da91ac32a7a5b7c1335eb301bbb1926d980afc903807b7264d3d85b686cc10bcf115569c2a9c755169aed8197ea764aa56a34e5388577f54d1ed8f45bc045df8888f1764a3d65174d8d98b0cf6de6cfbfa2d05612d53365347224d002f01e9d7c9d65c8f9f17330a574b5bd07c7e56884a94d21ffe35c81f7d4af1879a60d5a10e9051f3f69cfd2c2c43db9ac7b984db0d58fe9f25355aaecd60224cc2a45d8e9b223dafab5b94875a3f796d6de9a0d1680e31bdfdd3a7985da5c50a052e628f9fbbfaba1b1b25c84d9b11115b6dfdfd42789f2949e6bdf99f0c553c6b395255a19ec9cebef35aa35cc0fb492f5f135d912c973e9079ec9e6f588ce7ee1459b0c2b8e39c6d013b54af223344e04175b99a64367560e1a718697d80cfc87c3d89af3cf8b93d93a17a8454e63d3ae0de2f896b3006490024c0a407094742182c8ec5fcffbbf73fb5316bc59d6d12dab24d80c5cd401cf01e222dc391b676ecf091d1195cff96f7ec0d7f7bb4f346600ce4928c83f757ef41f9335972d55c7bfa519aa1996704cf55b2e00004c2221c406e5c83337213dcaa29956b3d4005d62b2b3397eeb20265f358111c8eabc8562bf5bd5ed3e54ea9bd50783783460e316a0b967e590aa7d772e2a957b0be3e9f8a0ed6e0370cd7d2b86409d75c0d600b7882f5ce4120be4ee65007a19d42d73b232da16603a342fc678fe85f39df33c0fac5bea80739469f5855247062d3d141724431efb7c97e93f22b8204290120f2c818ac565a114153b3b633b2cd8730f85829d7c968027ef643f5bf1fb758d10e16525bb1d1d38bc4faf2b1a1d7179c5474facfb9b9ffe10671e9cfe4d7c26676bc4d3a3d502902cea6604d257ec53e2af706ca9318b78d8db86fd5ba6ac8d9c8d7320298698b566da04e4e8a5c541fcc14d6749e6a9b391d7188ed094bce8d12e84646664255a99c8ba3c076a3f8b92e686fc9f19be15c9e07eaa438aaa84aa1c413bb90f62d9c1b54490a11648320990a6e02054559b3870b04db84577e6c583a994d101754542f472931c4545ea7f024086fa450fc2ec2fd8db65682d58fd52a3d23079e9fed0e62151204d72ff36076a394bcf11afc771948f6f10e855f2335c191ad76a964151d0cd6beefed3ff624ca1767159bd114038061cb3a2e4f5f735725f5198f41f044881f66424e1e2f1d456e95cfea897d33cc5fd2978fd28994dc19d06e80776baaa183ffe2b9e9b9c7fbdf24b72c01b7e001e40f0a40128dbb6712edae47aa60a4431a27bb9e7fc591ed5c15524fc4c8b5e5f6fa74d1c17f6a5a8b2340bb73927eadcfc4b9e0bf92778bbd2f4cb8cf47ef52556c218b3f0dc29e5bc8e91163eaf6cc5f978802873669ceadaec84518b0165c18b828f107593ce67d2a988540f2851fa1bc4a49ad1ea52dbb8eefd2c1d51dc3955187bcdfa8e7badbb8f7a6553e31c8ecedf8b71abb827488041566c8bbf4b2a10e206143335bc694f175006a42c4e5be19ffbb5e1e57497d0d5c9203a7f5a268c2563c1043fd513b666d0c64f103e3b213de16808f40410df8a90293398282e2b35ef6009450d578eeea2ac7877d20dada4480b55dbb62b093c6ad8639aa2ba1f2714f419660d979883a80c3d1875e8c2a3ea33ff00ce7e9c6f55480c3f47391ce44e8ebf8405822efa8b3f12ebaae314f4eb9952356f634323987c6ee91e35038b3ac440d5b9d25b9b60a77c98360840084164661f709ea5c0e2dabd2eabf7561f6786009bb5264de041b0ae95666e63ce79866427149b053f208a62f87616934ca37016e258f5298b6095665e60855c56c0e8ee1482a76e39de0d25dd363a0e4f2dae1513162dac04a7348adba982b9cd23d6e56d0f5f43dbde06e07276ff92da3c11e7f9571564f52420dbddd1796308503b68a8da6aae9765a5fa584ee19dc0bd6b00a2552d1a295f0a78cd6e9937a8939888d90b0c0ab4714ce5407f5375960e7666c69825076a3ec424a1fc86d2269f08a4b6a6e350ae210171a9bed8ac6c647be40e0b29f87d38833ab99fe6e0e1302b118bba001715b06c211818250e91fedde1a73921b9833ff8ac5c61d2494fb73116a3526e15dd186db86cb9b0728107ee8da229ad6596bc78afb832a9ceee0b8685614323eca6bd52bf19fd4a54c43b6646c1e0985a19a7c9ed5510c7ae5b5f20e51fd4db67fc823011b4b426500aabe4617f751f6f12122ab12e5ee7bdb772f7a7ec0eff56129b4463b6e772d6ab207a6a4e76419fc068ce9d0e092b4f677eeea5552a9b0f56bd2b0edc10ce6123f3d79acddb3758c56eda58dcd4e8cab1613edcc9c6e5c67a305fdfea41eb62fed8c61b9df072bf9e74fff0ade34d9087491190c18ed1897ab299f45c139f7aab9084913a7eeee97d549eb301e20619e45ed11f02b8e9a021288566673e28303497a4309a543f3c62ab84e9b947604e0528be533cf2e58401b602936b98f1c09193e0822fc557cb1f6fc7bd76413ff32db4cf8ea99525b27755e7d804e803aeddb14fc9bbce90217cb9247968d7826fdcb8b916d6d5143662572a143b5e830aaa3be36006c83719fdca040ce407a48c737ba8ee8146845d4e326bdfd7d23fb7cddc422e21a3b979fe9d5ce769b2bd785f28260dd6c62d14b14817af23be1c073d44fed01681bd75e3b2fc31edd601f6e8218683c8dd94c6ecdf65a6be8256677ab3b22110f93248eaf9e70d29989f997eefe0e2492ffa0ee0f76b5c1d95c4a67dbeb9108fa7c26b832f84c149b0efa25f7319f31d9d72b609717e914c5dbad728cc0325bf94cc324c4e04f2b23f2bcb2717df34fc14ff4b41b34e8c052e8052f72f044215ad895d38c9962887b66e5c387363374871b4e5e28bb2c3b5ad25a77a351efd9d946cded8a954af865745ab40ec310dce2890b4bd3ba6a28a787a568f144eaf2629e9dfa42529403c510f9e21e348342d264c7efa05550beb8ae6757509c17c96f661f0db7ea15c470e3d7790e38ba3fba936ab35bb920749e7ada63917917689ebb0cd99ea88dbbe00fe33189b4235629fc0670b33a246339d642316b09c403685bbadd9ba4ba1947899481a8ce0ad68f6bb5c99de5a9a215e48631b2c63570d8779e5c626af8850d658a25434b8fc38ec336e6737875805c5d9a4611a29f47590e701ba46a536e3c6690c41d85ee804ee4dd89aeb830e80b6033b871329282368aa6e8171b57594ebaee9feb7b40890e2ee31782ca03fe7d42a95102083b3b8f3806887b08ec6c9f71db0ed6a72","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
