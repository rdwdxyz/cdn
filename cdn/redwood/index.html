<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"3b9a0c4a7771c6a5638eefc48a4eed7d86d467bd7c4a06912d5784e3b100346eb477adbed1afcd175176160fe8a5e65f65b5b843700cc325e2889bb5b6269eb9d0ce7123604166e34e0fcde2865279b8bd978eaf335de2d363eaaa021aa87ebc7961e6e6c436cb1e260884f82f5de1ef5600daddd2361ca69a09489ac9779ea612c46648cb4f457dfed42e5357d6c5b765c69814a0b3c46dcf5573b23b1faef8a1f5ac0710dd959d58691aa0215b1687d6eebae3f2acc596c34b409f3f98b1bbd25eaf9f62a70a99f21d86ab944ef5a64a417a635d695b5d5127cc744b46dcd50d8cb1241f55265f506d0d070c055cbc39c0feca02908c1ca30a9ea467c38942557222912352285b96a4f9d737a5b0926130635349dd4a1d8c66f236d7d0189ba257527c956a7a3bc54e2907843ab085b003257a03ab155745a0f27c562afc75d9f338f2894834c93f77ec270541e9c3cf78194ee796d0b2bc9464da3cde950d665db5ebfde07db22a024e5c6a70eb22970c3b3ab52e655b13bd89cf330b8bd39a148c3574381cdf198461a172bdef9db92621a8d20bb10753a71eed5b5fd8f80ce1a274e1748ba119ead39071cb073b27df05286164237319980dcc23270b18d33e6293da0d1c545631eeab1b5733febb33a2da58406b47c60656e987709dbf7f48d488407109a544358ddaaa1ff90c16ed6a3b465e2888a4474b0d27761419e7e235eb0a46d2ae920108b9ee880288caa80cd25883d0698dc207c42fe567385d6e859b67064c07eeceae668a98f47763e5d4dfce7f3911b6ae49430337680569737c729852c01c54e9c779380d08018a0c33ecbd36c379233249824045b812be7c2a990210cdf2e400527d46659816b228105861e283630357147d2cfd5bbd639ebe7eb0cdc856aacc4104611e0038082d12da8316ddd77e0c753041fd048adf696aa3a4343c02df5ac0379c788ca4611643b7fe7366bc1e94e3ffabac190c7aab187bcc21ef7bf5af82cb13d3c5390889fe9783908bc39115486737a1c273b6e00ce4a206f60e023810e569ff8245777b76e327730821ac6c082fd6dc28029234f5776e4cdcdcebb1db6650f260c9b651e970b0ae4e9e7cd8663d0e174789f5784b9ecf3c91abc1b5d37483eef8b4ecc3c67925e44741ef39b1e9c87b099659651b8787399e955890158d022f2e606f4956a892211a0147742f0c78a7d09b0e71b904c8ae5b602f6b57f5a6e97ecf8f7dab2ac2d89e543634f6d22b9abf90b9af67cc29e42ccf3a5495ec85ff0da74e98a38ca23ad5bb3a64cfa3230dced5b5c54cadc7a5441d6978cab587537857a55803475b9f52193143798057b9c39defbf199cbd87fae97b04ae19c54866c7e445ec783d4bf820c64ee0d637e9f2e69c8aac1f9b3e448c5f12b8a84cb75a1518a579eeaf4c153b4681a6dc2640f64e8d1d3e699032f719dad1ca9a7e6de8bdb62adc12fde976be80635dc596eb0e44dea08f0fb4cfffa8f0e679c8f9caa4fa64b63e81c8bceb3242de33200226b525435acefe0e6756be4ef097e33af237810ff46686b4468d29ce7932b3a71b34a73deb6155e761b1de44453181b24a5a65e98898666128cb93f35872e475153b41a9cca33c47a0b79c02ad4e2967740a51f9bcce3e960572ac9b2b698531c512a83cc7face7a6c26ec378f8f78310fd62b8b1986b39cd59c5cfb3432a0f79dab1daf40cf08939f5f62c7871dab72f178f1323f2958b84ed843a9eb20253fc097e3f45118ba4c5b53f23e0a33988b62caae66250afcd352ac0a33592d684babc44d46cc3e2dca0f76c307a1f84c0295aa44abe65e64901ae049fd072dfec0ec1fb1d268ecf2af7af60b66beaf1d29b5287bd0a6b5ac21d0683fdeea12643880ce76da10e83bd9018fccd0f09d4d5fdf270a11fd5ec7455b1a9a8cd8ba32faf3848e3d7a13d9d1b41c14b9c01127f71b10395666a9cd27bf54cfee9add477727bc61652da793a52e8a3c292028e25fb47e2e1ee57a71803f7391b0c790611855155e32b8a854f4083df919e18fe3c6af713023397f5f1b8e9e12e34f5faeaa095f45113778f0e6846aa2f8b9362f352cf16ab7680d8ae435a3a168d9a9fc2a7f77edc2efee05425c933377cfc24ffcc3e20b897566493a9d56595ce65f2aa554ecb8aaa7a06b7b737ff3ba1fc09176bc9a1e756573b549201477a78f6c734a2cc2ec85c411b675843fc82ffd9540f29737412233cc89b06d07e54a21b45c71daeccf9805cc28004380a003df9df98c728fa6d32646bf9715f86b8a0bf880b74a152de70644a8ed9d6eabd257e99640c1db12620ba28258f502ef036cbffab625bdbcb540420a150917e44a53496aeebaee1030d5a007a38edbae9ff6504ab7eef4d00692ccb3ebf45bbd1440f718b6716dd8a146e44f6983aa1399ee37d0eea5f57390e574ccb155ce9c4c9af9ea4d363addabbd3cad6b1ded01cd486d24467db039b0d640c255859860ff1ce45a58a7e100f7d39ddf71349aed2d4accfb7b1f04a896ef77577bff290284d83d6a0aa1165ed4488872f82f76fb93ab5f9a302500997f9b63590fa57e9ead56728524eef5dd599bfb276ab821ec61886dd330dab241ccfe23ac5a39fb5cbb62d4e6f924ddc74c2e512113e56efb428bc2a94f8a04036a0e56954226ed579e727ece571f4752d22784e4dabdd9d5983de8cfeb3c04f6f1c3cdadcbddead87d2edc8bda05d41f08e130dad902c1c2084977fbb8e294ab2edccff226fa07c541f1319a1af17990e2665320620dc7cddb074d44856bf0950c0cd05359ed12b674c7da89e078c3acb7b403167fe56fa116d538b7fca4db7f69b8bbbcb2f8af6f200e77806c9459f4d8c11c69dea0fa106b912bb13a725e2a1f6978db03fbf73c8bf91b9a73c641e42d8f08077273cda020f2ee2e73d18cb819195cbb839156971ac745f71ef1858b74c591ccf72f91ea8a2df4109735da464c6d0bbb0277d2f55d9844acfb5227015b726837c1d710e529251bb85d76775488663648798034e3c55ebaa3b631dc52750b3893d72ff00c82b730207cbcd32e2371ce12993fd899e41e9ff8086647fc381edf20967f65106e1d853e37a570f72839068aa8cd2041084548fea83c63c842c7b44142c724b4801754d5db43033c661698e17fe333f984f55f3708d2efc7b8e57ea5ed59d1ff99b1aafdc05182c48146e71fa74621227d7b281525c3d196ef94b11c623003a05580ad5587fb7f724f4bb4281af8e4a81621154add5183d812441959ad765352cb2b99d7f41bc5ab1bcd6a276fd923d0f5fe8d6c14de193ffe0829a95702a269bc0018a0d096388c1348279c59971c6cfbfb31a521f18fb19733549fcc2001b307b015166af753972f5eb459e491103f3a59913310ff996e93100dd1c8b2102d54c6270b7d8f990c079010932a031649c5cc6266d67d6522b8562d926ebc926a50f62c4ddc1f59a0be0d2d8d49f0d20c7a4a105c15009c7dc4f3206d5f4b50f56e2c6a58ef891dbc8f0927ccf1f26b5ce7d3badf3446205298143118f2ad8e2cce79c2ed4567c89e28d681ddc096a9d3ae994a2071e2c6b69ffa7fabba7f15b12ee85fc2dc6b7ef861e7463c9abc0031ec8edf26a5016721619e2a8e8e6a1a14453aa823379f8a4e67721b75ffaf22a237ac16ed5d4d74571adafada97ba0347fc5c2feddaee9da5dfff3902045812e27b7aab501be608802b54414157ec1b701e7253c84f03889db52d6bb8f81fa941d24a2bc77305dda7f0d2a0a47c0668c8003b3543fc3f63c81ef0e8064f17e2c938941573a4c93edffda44804ffe79f264170b13c4553a0e1e6e86063b9afd685b04948c79c4b2e21526a6c472efa7621087924ffd85f3e217d8fc5fcbed3231e87fa381b158df92a0b0398e5fdd858629fb042ecbf6856f0b9cc7ff2bd2b0e9d163573125d35f81f229008dbbe87c0ed879b15dafac28758bae9bc8e348b54a75e0353d919fceb3132224ecc3bc6f92e4fafae8613366be4709d4caba7b942df99b35b91301d379222334f2f41d76d6db89ca2d096e3a48d86bce3e67f3ef972146ef0120df8dc981e3d72f9a3489c8ef363b968aabfbcf96691e9293c5bec86ef277fabe2157e8a04f14d84443669b978ca5a58f5d656ab170f9cea4dc745ecc3be5685041d20899c7c840eb88caef0a8d52db7841ad42999f95be3380ce2a0242241ca9abc230361b5647976d644e6d5ef1897256b6463179c8765cd16c08dd434f29fb4090af4101bf0cd5d32546d64ba4bb58ff00ebf88de64792f219a3f8c7c1d9b353d98e8e3a71de32ace4c6b224f0f236d7525e7d8848641559ef776a979d97a7f38a92085f14edded966f9565c2ff2eb1b25ecce65645526cb9f5155286699731f627850263ceaa3f898bb206d7b13028334162f22cfdb17b07dd4e3ae706082e1454ed7820541ba641eaa31bc7782e7d0d6e327f7dca5ca727ff92c5b25e80aadf1549c1c2f6f99c0d40fb0ca69ce32ceae76ed668c41ffd6bd245ac49ab99e374faf42bc42494483642d9fe8be81203aaf51c0177de82f1e59e12621bb0a7075f43d76e943e35480288858be29751dbbd960dfa0dbd13cb5389e8632256f256071a9ba37b2f9e1491d030386b974669939cb85c70c84b18af646effcf714f203c7d977a1e0140db5ca6bb31075804bf9c0a4f8fc40467e7bf79cb00b6643db4487be84f6e7c40adfb105e72ffa174cac4d1dde85e7005121ad7a7d52f4212e973c6bab0838dde0ba04604154cd7bf789496ca307b12eabd2ccd8ad60f8d6661035b458e2efd3dcbab1c8fdeae30117f61bb4dea35ff51b1e50501a85c2b9bf25c19f2b96f3978945c3be9e94b2aa6c5d923d737ed1026cbc36e74517bc6ffdc84bcc74d9010ebc2ffa88538a34d0d44326ae3db268dbe5001301243013ec4692b34a432f36a342c8696c3fa4c8fc1a5b0bc9111a1a19f71a49e6444eb1652129e8ddfed60c0003c2f575ab55a35e1814d9cfb0b3e020f4faf35cdfc5c7eebdfb57b6e8d3407b5473e7ef7681c6b8e7c0cc9c942382d5a0151eca6d3245be0e75cba46a282f38da8752506375d250b50ef78b3528087dc59363b65aca9ff53aa8179b1fbefd4ab00b5e287b4f8fd952e6bc658949913e77ba608522d5cc2b6aad2432a166470d1a080b33943783d0e94c3e78a44bd5eff2de8ecd0239be5757b86e7922fb32c7eb935789bc355ae7df45a9ccce6774c2972a1da8453ee721a56bd09a959e662eb45e9ad0699d21a367f98a0c5545d1db17a07dbd9a22f6cad226cf920dd7b7c9a153b8868b5fcbe74a04bc2bb032c446ca215c80d92a02a8a13d2a9f23ec06d36b59ef3105be5049ef1bc7cd276b3def77cd72edaccd27fd219ed4c12d9d63ce1d003f2c2b4e2335d2ca3d5f3d527efcd60c217edef87082419c49cfafef0227543434f5c32aee384657612e5f21abc8a3adda7b52c85f96f763ac2dee40cfa2b3e4668e4850e1081eac4605116a1a8a3496280bc76128cbd159325ecb8184ce3bbd2d54b78cce883dda166e2a665a5cc06d37d758e68e2b43876dd5bfc9140acbae9e2ab12cce2eddd195365611642fe5fa0787c8646594ce207067a3baa51ddc3bca5dcdd1a48c2cba112ed32ef5468ac1be8697f46baee6a0b2ec6e7dcf116239cf487c1fe4331b6f37b072ae3aaa73e3bd86c7fe697d1fdbc91adb8b0ffdf38748a66d961a56479d44d3c3e3ea18d69ffb57973e06a2b23cec97dfac19dd9b982beb5a80d7c6df6a19b1b2ee48ed0958d0762a05ed15911fab35f17f7117996a3976688a8cebb1ddf3ed9c7d19c1fcf4627555e38a44854957ba62c09adf49e882eca0203d83fbe1ffd98d6b070f87ad95a688ab382221eef7a526766e47200d0d46fc2353f1e6427a33c9a12f3e3a3a12d2f3b9187715472843eadd72ad006bfc0bd555b325470b885d8144d95fe42faff4b72dca0918161f1f1f988d0c8edf4f5ebfda2a90167e92482bd60cb3a8ceac9bbe735edb7271cc3e5a4304dd91915f00ceb6bb358cf351acc12e79304947ee1d7e99c91e54f3873d24c98244fea6d1525fdaa23e9e2803b691bd864a84fce8c96755b63d1f82a2324ffff73162bb7eb694f8a3b43266e75393874e294c3aee047fd01bd53d5b3949c42c12262b44dc4410b5f5635fa382efc46fef06d80b1dbe664832c486268ea4f187d51cb03e0ca1bcbfa26efdd589b6cbabfdabf10d9a97701fcd24b50eb758649e7a1b86e9b8fd5335e245aef2efbc3fb7b94ae8c0e20cf4a10c260c18090bb7415472e79b7fb6106d282d82b4e4676969465e7bec09375964f9f7174b9355fbe621e2225f810c9c31682a2ec79fb9cdb17d27c47eb46e2d8034f08073e925dbadd568845679db410c697b498ff9922895669f0af36c31a053d1375800d42dd287fa01b6142ee55d2f477be915f44f8077f96072cf3e08522c747db8c25845ae18e48a6ed74650653b8cefee5b366ff573a56e0089f8d1b0df0a860a0f735228aa81ad3cf2621b0d88823356b6247c62eb973154c70f8ac2552f99853d6049ace54cd1d9fb7fad803ed9759858480b5f7a3ce7972cbbdbfe2c8caa9e37fd6aa9949c76c0d1d227ab57ad2e52c03ab6acf1416dcb1c5bd18c761e5325f81d6d63c794f108ad7c0377f9af977081dd7cb80f2e5c44759348f56e1b506c16ea44830e8d7fc26d50824fa8919cc0dd855c8ed2535c0db954379bd3450b7f603464387515337a4f89c34b6d196e4df1db8d78aff58afc0c999960ff96064aa8b715e326824d565e6f5963a946c9d5196feda2fd5a856ed261d62a43d8d1241c85141975c195edd954e353c374458eff88304ca1ac1e75a413abec113020423b9d55886db6233ff7ee9785987ea7aca185ec23a8f02bf739a4ca866ef04c9da298086c7ac557b9a92997980979ebfa8eab44437542f9ecda0c79df0cb90ef5e15ef2486ab195550414172a461b9fc3bc12ed70264f0cbf053d38976ecafbbbfb3f395ed4af55ba7533ea6d9c28d48a46007ce447399a8a645f1fa2903fca42cb7c4446e9382bf133cf4b1c3ca00f01ba00dec9845fb509c70200a0c70b7bff81ddbcbbfcf1d43cdb307d4595dc7b2605b01c0cad7bb42da4dd5e2924cb2730d031ec336bf0ceb755fe7168374497b49e06edb2d3e4e8304b3822d9d0d5266d9e12bc64859c26158b8e40664998233091b55fe7a7f879cb1a99316a1636546284ab3231212ab45e87ed292d11e106f8c5d5052a768f5ce3200df3e4155acddc396dbbebae30465d2198f6a45bb51d45ed8083a6fd2984b168cdbcac95b9e68a0e336ae2dd39d86ed20eb12563e0e4faf371d52a4215206cf9a499184d34da6f31421339fbc7df9c42355efa801477a0ff03a56af5d64ad3099f7423cf570e443f9d5233565a0f235cdb6a2d540aa958869fcf71e37292a1c6c87bd06c628e12221b04ad8df1ceff12aa4ee89e830b4534f7765e9daec961b402b294167d8710b64f1bc00d6d82dcb59d33b603ed536299cf359341e70e4ed5b88f1548affffe38ba539b5db4e9c33dd84c84423be4b4160449e1d8fea04ea206787bff4afbd8cd4bde9dc4b184d13f0b43ca86022536cc06c1864061ac8b81ae6d74b3aeaef1e65c9ee03dd71c2f589c5f5e5fcf60da2c958bb27c8e080bff4a531237c7e615210cc5995bb8527f21d21b04f920b7b4c3844420295b5d50096222cbd85420a88fb31450369d729466475ee32e014a98691ae3da0bef97bad0888cd59d5915b056fcdc0e179d4ca40b9b23b34d9686cc4a6f8c396421cb115bd83ffcd0de14b0f9556aa88f8e0f9387e48860b3d02790305a0a627824ac88e6511914f65b5dd56d744364f6bddb68f5137fb61c5854df5057bb1b745cbe03b8c28a4d06cb4021715f309ab18413b562171351304a8a24a0d65d935f9e1ff3f6a56bd1938e175a4b21e973472e8b63d3f459e8764032a9978af79edae571511d4afd1ffcf86491a86d4a367ccbf184bc5c6adc4aa1439e878dbb0d1cff41c6d5ddfe8a37c4bc2b6ae0d659a1faf80714f5c6331f39ca89a3da68e764432249461669f392d45032e4ac9b5243bf9ad87d5a626050706161a6475211f3871e958f313a66d2a819306e712d5109067c3a561a3d56ab15212c287234364d28b02a03ad6ee175edba05eefada99fe97f96919fae05c9118cfc2e96e4aa113d7475c41955486e23d75a29bd191b4f9aafebefa1b21c4a111f8d40e902b532fbe8b925251d3c44cc2d6a103b0c45e4af24b5b194581c930fb4608ea7e288788200b3298bf8b7a205580e0b525d60bd1739acba1bb8bfaa447677baf4c20d60d4a134d4f15bff87a490acba2b429d19ac560464d8ea40485235b053e960f45848b09d79b61138f806a29b88bfa0d8a0705d7f09fd4968b0e497bf2141a81b16ccdcc7196fe84db9e8c12c3478e747d9130bff8f8ce86ce232af390eb67d6dca9f207646736b75d0e1a26462b07be593c8681e68953bcb84850aa0fe6676ea130d38daa1fc59d2dca08d7213674f36948187072eeefb805f154f2dc38d80ad150b97d951f896f0d971d0fc0d6967195bf51004afacc406431dbadf5b8cfd7eda5a612d82fac44b80de3a017d4e5958c7e4f08a25db7ac3b6c1b0ef2548b73db81272037c01692334e6c1d92dd662c5b2d8378dfdb5bd42872a2332f5f9e6cf42a66ecf2ed6839cb7bcc7898d4dc6e02ebaa990c13d236f4725fbf4d0ea16fa85353c77d0e2991adffe67a9c3fe4301703a6b170f6c69a9750b9e3728d8b55af463736bd6bb96eaa9cb60d2cca86fc6c4d710ac0e9f4b7b41cbb7b69f73f3be59f6f33a71bb21346ab2250bf6fa98efda2df89d2d4d5e87f7a596eff7409c02d23589cb091bd24a520af3c44f8ee1ab49f7878b2540f77ed77c2aba9193188958bca3176117513875ea3c86aee3e734231e4f232371a6c003a9c7d1ecaf0fd15076cabde63c4d09a8a0b0c45c6b1d885227d39374266a7b92ffc370e858b9a91f3e2d62345439111624fdc847db513b485bd73d77fc479e84a977f2b36e01c779a3857710a4221be5613b40296dc735710898192e27e04dfc20b6757cd74bc0934f8643cd27fc7440a41776d09ab1e8e24b41f878a36c6bfa999ccab07b32a9b72606a1cb106fc17df00d49a20017ce8c9bab57d25fd472c9cb759565c205b9f1b3562d727c4ff20e305321eb2d150717a499b8ba1befca47addf7ce1b9055149d2b423d3a0cf3a1c38a22e18c8ce2d6b01aa42c95030d97740f730b3b3fbb14b3427dee02b374ccfe4ed4c70c85e8220b27ef621f6ab894599790c7858fffc2ac4a4c82b6d57b16ea0692d7c43d1faffc1cc13df1b7c86fd976d572ad7fd4e5f0878bc1f727c81b3fad1fdef2d1030415c9ba9d23d669adeb8efcb511c63b97f497b21396d48b263d32d1c1536f90c50b4fe7a58f9bf931aecdf85a76298582b9bf460195b6c9bfeba80ac70a90ee42e8e18464789c064cffc9ff6e6e76d37a958b8ec74ecb2360f4a547fd286d36790cce5f612cbd52d0f9f5e1e0c68e9adb36fc1b927fe0e5ad1ee929db857fbb039941547ad28d070d3b1b789f3d2bb4aea7d197256e6c519cca25d9ae2bfe2400484ba69443a702d727dedbbef7865ae96acb06025036007b1959f49032d84b55f57bdd23bf539c126bb684284deed780350525b67c9f8859e34cacf43f1c26f9dcb85318022789ee17c33823539d51607cdfe722d9512f266392663c0a07b97a71c13b70cde67b5111826c5222fe79849dec270eb49cf739a8ca044c4681474358765c0ebdcfe4741e47521ebd71f26380cd00ed679f5bb4fbb24bf813dfbae1667d0696c794b1da65fa839f94ded0dbfd4f83f7078892cd431f9bf687c2f37251988044fc9658d8c24d44b6b81864d00c991071cbedaeca2ccd6c28d891e5163bf2923f81fe96712154967a4b12fb28835b3f8bd254b40ad285a490edc72c70934ee91adc05d2b299bb6a64e6c3575dd3535277ef2815a07f72f26fb4d26fa395085262f430d6a86690999eb701fa397086b6c0be657fa36a4d00153ff1c906892e0b464b8cbd39848bcabf869dc2658cfbc7c1cc47e2c16d3c94640f55adb7dca799fc6857bef43185cba367c58efac34fc08f134e65afe07f475a598fb81742dfb19c7c70fb54e45ba3b8925625520dc69f3734719ea5668da88dd06fc620fd4c07c047c1a18fc73118c9ee903139e2a8dadb6f975e359f16000a64abcb0648901618de832f3b43f8828e64279edecdbd334148db89181f496e0fc84bb430600ea3e1843a5a6f59109d1f521654acc2432d8238e91a043bd2199446bb7ee75ab0a57c3382e8683cb86322516a7c897d76f6a879f92fb60b359f8ec7b5fb01fb1a9f8ebcb13fd97420b44efb7ed2f27f02da99e9999a38f102cfdd3838fd5336869713fce1224fae347ea876ac47747d83e6f51bb297e4c3bdc48b2eeb5febe16fe72f1fc054a62a44702cb62e4e0f49e7f146c112102424d4d34e6bd741a293d6a969b0641eef03d4ba2d208ecf4546e9e5564a8f6f7ffbe7a91b6af83e47666b9cfa9d2048b7ee8d452b9f8cd8584225445671fd84cb4a21a34f29e8351f8b4091f2ac73f784c6eab2e561d0bf66882230c3381a123158079ae88d1a07e810ab0c3a378f1abdffe75f58ca7a56eec09ba2377e1efae53cc22db4bd3054fdf75c426b516dfe7480923c2c3ff3dcfe617cbcc529b6a5792d0b4d295b42b1347838bb48ab5066a09031d80121877a0c4de0953a51961fb868bab99e432e993598988aff6a37d4405bb2059cf90fd461afe8ec5c42ca089aa44fda066c122f2fbf3898e6799986894f7e578073881415a025ba278f57f66e464988eacbc0e5c7791add48c925d7d193847d769f52aaf2f66114f9b9f68014ee7380ea132931af96910b1f588776b90a3de98d91cb39027ae77cf7829b5218f38ee29f7bfe9f9bfbda1762406897125626e8fc878951e113019daab648e38069020a61b772863e485cba540e41d1fd0dc25522c7dd946915b807f824b88e1d67fdf5721dcada14d945655e717bcae0cab0f4496732425d40de6829da757d45f4242e361a3ec1e07c620ba1ccdcc4aa9adfdac3b381681329e35e2ec4564634676a069f60a24e9cc7958ed5b4b8358972cd68f0c848321678f85812f606489fe0ce2fded45826fc6a233d173f304fb527706d2dc560c411927b9c00225c4cca2bf4fb9dc8ec5af835d9c0e21d097e85181092032423a48a4d4fee6efe05222a24ed553a2f30f3b7da5df047e26a0f0d7b9c73efd35138b39e6c4c942cb30fa6240f7047f34297116d653bc271e576dbeb30b09d2c825358ad3d44dc700bf7a81ace6e843537ae2abf13fe820811c8115256d06c1b376d3fe3fbaef3e944b0c475cbb87564e74cc39bb750ad35d8cbfefa598da14b64600ac575584c813c73c894795114382d8c2b379b8e0d2ac85ea2a033cfcb81bcbe2a2f20fe02520f94f06e9d3289c4b17dfddb67616b8fbf37dbf47e20c0c1ff7cb9f59e7dafc39c17bdfbc7d26c87d63c9adb464f6bb547070c6fb33e0eec1c50eaa3b7ccfa48fd1fd42119126ac67377743f84902f9bca6cf107b8d63d212d12b53cb484f7464f5b21f4e0d620d43f8eca8ee8b49d6f4a44d196db33e1ed7ad172382cd3bf0fe353b299ce6f94bad4577ddcc2ba5d3c8a986a1106d10a637bf3401e1587ad2e0be6d0bc3def9834f4478f91d1c0d3e8d598f5984c54379c8f5fdc1973d223a41934a995be4db4ef2a85ac3700798a880d028937516dc4b041e1cfded3e04773bde5f92fd78a6ffe93e179ae52a61f8298ff199eb0a3030b4af933fa9b370a6dc4dce01580674286736cd3941c9a2484b5476de2d57f46813cdea7930093b1b2f199cec0c6f51fff5f6f78cbc3f221e676e938653f3b336d8df9378a00a744348fcbc4e9d10327bb8af1c74c6c709b7ab7938af9f8cffc53d7e1f16d638cea5572b109141611e8271a03b4aa216626c39d4c9d0976f975ff44dacdf632e854a89fd01bfa9d440a9e9400a885508cbab756dfcbb692cfe41c06f3eb8553df4faf4064a1a82e40cb40cb06ca45e81fb2b8aca3b458a77b4a793998d3cf2494bf45a4f486413237742ab10f9e867c6464738982c7f19fa597af888ec775d45b282508c2681571080a3e05cd04393e62d317cca0f297ed43a4c518e53dd102d73f100a291491359a6c94638bfbbb0459f8e9386505ef398de52c7bf7b017ca10ee62e8f0fceb67afe92d69b23eb4a8acbfa46000789a273b65ad0f8c05a6c557ed65e84ef01ad6da46715116956a316985f2ee080da0154c37e9e9750878b2b347e211cc83fffad67a784873ff666cc008567f858d184b273a0ab3433901db4003a535a5efb6e405af0d849ee3c80492e386fac7e0e8d58e963978a7f9be5d584083abc0ef7d83d93a481a5b4eae2eeeb606fd42e9404c7711580e336c98b95ed60f059124be9d577f00d35b864e50cc0879df11c2b5e2ad3d3d0687816000189643b1ee901bc1dd012ef740054e8851d45fb611eccee4c6a95a4d060cc564324567fe91b0218566d07fa65c27e286c188db26b1046aaa984185a434ea810982cbc575ef94e706ab0a4f78c36b14313d169b9c31ced603a40cf3efd5b94059c8502ffd972cc226f9be57396ae898f6d932bb8d422ad6e3a0d186a1cab7b8ce35e970880af022c169e33935bdb342add6a36a9bce630dc6d870029ce77076f25fd2c66e31fc406f606796a81b4676ae546d5ee67fb860e7bbbcfb15cb6853022d1022ffeb68996a87cfbaa7d4b1b17fa68da0a97dc91aa46a885cd5251c38dc14c1159ce631d8ac1d607cedd3002ffbb5bfd0737e4136e07965800829d2af6c5657908e7658ee29c50737437bcb3c186d19f64fb62b7d67a8a1cb3db83e2f943301993fd5897d81f6bd6766fd736fdcbc954901514a8c65a46e15e5b415f9aeede40e48b3f9ce08841eab6019bdf371ca178d065588dd2428474ac49094e11fbed849b004e0372dc99a82b226515a1c89fad16c8e43d81f6e3c97cc59bd0200a5be3609a08ecfa2abea5fe3b984714db1fc8ac19b7c74408ea8c7ffd8eaeeff2b415a5452a1c51f4965b15dacab6ab07819a2b409a4c674784ba056159c3830df0b84ded8e67e03571dafb891eb0c67614f5d038352590321e1d45a002c3b4fd76b33c4d839b61e77c18930c5c0ab2bb32df1645f62f20e5649e79fb75817f7c6243b93904b80d5cabb8b2d0bae6943bb3fd8a42188f43ca1841f2067702e831358eea43026a52b5e063f9c5b5fce230ab23305e4c5c4e8fc215903531925e47cc75a16008f472ab063b2ad4fc5dd0b5741b352c877d448df0afbbe84be28ee575619d18c800a280cf9c73412fb0b95b56141d3c972186b761c44044935a8a5b9edc8c7344bb483550848ebcf6862a5c2784749b512fb67b8395fee3bc26a4f4ca74c3e6b0b4707e00a702c386f64bc6ab6767da05d6b63374450b491ec22e7514914984ccf42301197ae8374637f7254ba4831bb6d5f7d659b65dd537a1e3479cf354cff1c5b50c008b49869c9f62e61374f0b8d33102493e2d4e1d632c7261cf9cf346434ad0db421fdada8b3014147f9dca0b325fcaf2dcf6a39c6ae9beaa94c5d7edb4511b8757320dcb3768a55c62deee83e16abda0ff19a146358765ef91a75d6537096170dbc7388d63a7ccdde56fb0ed025ed12fa99cb8025c699e0bf7e6b772492ac994f5b099b9427527b58d51bfaded0da6809a03b956a99de27dd57a6ecb54ba457d5b4768b74e5345dd2a057c8be08fc2e0e2055a03b98a32df8e36233284ad76850c6716511c5425feb8d2cf2595c29f00c307a61521e9f027623dbe1ee26da84d76914ca6af320be8681f1cac13fbb7ecb461c564e5c91205767aaa1c6a729cf04170b2c8d047ef1abc2cecbbb8d08af86b26de4f3ff4ecaf03c1746441d4d0e3754680d4554c7a6ec76f1532ae473cb9df5365cbbd69b8b25664801f39c1fa071b5cee8b152b5e6737cd37cc4f383bf2b14fe8fc3932074bb855c0dc1d4d3d95742bb764070aa7a4e28c8081651cad40d7735783bda156f032eda75597e544c5849d6de5f9f4b35e1b3d563687c71290e7a61d79554b5111b1f88d3212d20c06e763ad3adff48f9a1892fc85b0543c216f46580d73e926b37f1dba9b1341acc3abac2a9ed0ddda933c5b35017a4d630e4cb7d6bda1eadef1ac02c9acd67c0f583ddb0a8297103dd349c3c76bf59045489cffae568a9697a6ba3a21d028e4f579ba28a7f57ae0d07420585c06008391ec4ee83ee4990bb7d9fa4f7870161caeb1d9771969bbd15ef12e65e5210473c842d80d44d21371911bdbc35bbb2c7100fceaa76178a93e8a1bb8c00933cc8d0f325e5c02b3ffe2d5bb46477fb65fe25b292055f8b3247c1867331c7a2694d3f26cdcb7b36116e9547f384b8aaed3869e3bb9b3a257bef4b59df223b22fd866184280e08ad1d245bd4e514f648fc533d675163d5ef5da733802320c6c6a10affc3dbbc0e4cfbf9c7f3ff97ac481744e7661935c3ae0d87028e36d62df07f81701c69f07a39952ab9ddd78b2997608bd39345cdfb65f3ce8562a3ff7570d49795539599413edad338ecd43e56e122e089c4a9fe5b817541586b5c75f33436d85f1704ebf9804e3db5ab8b90b08a158b8aeb043bed83df015691508c2282a7e84fad4b309cc8b3dacbbe1e59a3fe953c43ae45f73269a768807cf662606ea938c31a65887ea513526dcf3988f4da14a66df94d2b2296d12ec865cab7b07e0ebbffa8d9a5c15d8873e963c2869bfb7503cf4a333e52257b77afa7a1750485291d761ea678a73465d2a6d945ccbf4a13f85c925a43c2b385a5a5e8535626945d6651be8227a634bab764c02befce385a32f23796500b5de3de578a8ec27bfe30b8ecce25a9384d83b977b643d584e6aafab4f7b6933a9913193782c0dc0a12cc1e2e70d0800c89772d1f5b871c41f8427ad0ef2a8807a75379d5ffdca1e90bfddcbd264ed7a4f18529d7aeb4615bbb66aaf8eaf96d9c16aa930da00ae20ab00ba5f3bad895284a8929a672c760ab0d7a41c36e6cfac7cf00fdf1e3a6ff893497f919475533429e4d1c90e02ecb937a409a045b8984f6e656c16b1d8cc829bf94d237ace6d6ce3427e2ac733588854c779e7dbfd0263fce35b062a3223acb252963dfca4cbbbbb1d50544e26567424d05b6ca6d3736f3e3bf7fc82a3e5d806098fff6ad5940056cc0abb56fe7e2f705234395a1e8bf338b7d1d9b2d687dad36b1a3a67ad38cda4707a7a64ad61f72bb01b9076a174356e998b4514b58c5b37a3b682957017548f735c550084175dc68031706eb0fadf0d54218943d3862e157069349fa958562348ed8088d509e58f0db8bb2e8dda96d9d6b2ee55a95783e1cc27ac361d0a4f6eeeaf256f9398985772fed443c0e4d86d6eaa8376d7260bb84936014ab6fd44983dd120e911a99a9109e4b5d2559c12179e2a5f65d7d20f19147f4c436b96a8b1c12b54c2bdd9463dffb319f5ffd16dd7365bde3365f16001fb87dac19b472814aff8c13ebe266c4b42f5e44082ae8f57985c0bba556e0a721768d0eec3ef255047283dad8ba87903da23d331f5facdd59a707f8455c9749d913555b350d39820f4910b99e1ec266e1297012647efbedd2503886888c9097da556f1838c57675d3346aea779169afc8092b01ddafaade9b7a58455b7b3f76d9ef83faee5e102f6c36a0b5ad3034ac5bad11696cf7d22dff97e61592872600ed6f8e00545ea21412c160c1f20553042f73d0662871d8e997225a8d9b2845b92b9ed082ff5007e7b6fd1513ee63c57ecc35c5240d9279e8c26891131ec44773d47514221acde4f581bfc8fdacdffcba39f6903438b0d649f34229732bfa35eff8f6794cfffd208f67cd60495c2c462f7d0ecda72179aa256813185262fde84c1f6290d7ca9c71b981d71f18690a1f19ee494114548937a9483be1bb3c95c2215aedaf0015437c804353c9c49f37f1de2600e8a4bdb1e01feb577dbfc013c126849f7c4dea300b54b5b34f275070cd219733fa67ac2ed7a1c6466de46f0fddb8a68ba6e48d49ef8cac053f1317275c08150b23dd978c946e5b5a0d096e8485d4b3a03591ced288b3b99fc754f348e2bf695e63c781911c3368c3aa5ffcf8a7962a259c87226b2b0bcd45e1b3a2d51bb4cd445316ed193625a55f5a92cac5975764379cf032cba7e983c462cef0a7203261e10d16a8b8d122c3e64a2af54c968b1562d334d6963e034eb1914e492634ebf165008a956bba896b1644c64fcec5b42e048565c16a32b74fd32f3f9eb2e6750369b00095598bb8740fc93f475e4cc2ee5a1e8cc846a8e53cb11e6e47edfc31ceb7c507303e8274a28378d977dfd4eec32c07be4e12102b37469397adb1b54099a3195f469e8e91d6fe41d10b8f6809eaebf7196c8f2b555ab08d468697ad6606ac4caf5fdb4c909c0a71160f956bca135430e35059f59e3f222929abb497e8cb0d01670d92b1fe486a2189e80aed7625de68a44f7c252c260712c586ff76027db4cbd4098eef639d92e353c0b03b58cb9a6f7e4ff26afebdcf11f294531dbc849e37728efb32f6f8a76f1357667acf0bcfebb0bb9c5e49f22b33297ed9ec8a94948bf69c49c2cdf6d6870f1a0b33b1001f022f90861c0ea3fe0d4d2b36e31c8c30e4d381ad46245a2b19726a7eceb6d7d59e6c0f633322e8ca2498677e60f43432d2a4d7410673e7dee7799fa1ed1ceebe029e4b41060e7db591cc4c74c50e49c28e0e1bc8a52c70cfbc0ed708b97b179471b940dfd8b94ac22eaa632c0558ee06373a2062050ba7c0264058e91c777303adecfa636cffcaa217d6cda5a5e9aed49338d39eb2f8be0db57f38da35435c019214f1330b9ef8db711cb9d8e55a568226adda698123c5784e7661f0596204161ac8bcdfcb23db66a59ab32d9147b8ec0ba4968453a1e5e34275f7c82f61173f1d851b0232b7f10a47ab003fb757f06a80851f8b24a5ba6fd1d3998efb95726d8a7e76323253055da71ffdb270aa8ad988d08f0e86e38853aca1d35b72de9b56010461dec91be895a99d35bef7a8c524db39e3cee229c20677b1bb1c4dbcd34f832716dc6a08ef199a90e5dae7a195e606c243dbda7d78b186ce3080ab0f39020f6b50bf2f61db893900357b1635bdf4956faaa2432707ae8b04f38b40d7790aa8db8e4d315ce5e2eb2ca2a15024f7416e173d9c3d38a88b86ec5d6f4b4eaec328e320b805c7ecc9377a7048f469d4dccc8e7e469e94562e71864895572dfb82ae2166c213264ab47afbe3932a216163f3e95f34c79109e6979df06ae47628c3534b7c7c22564d5af108360446e7f6b8d7e7f12b2228c9baaf9e813463c53811020a2dc80feb887a9e4674bd2d16fa6d6e9325f50b1caf0878aff1725b1c7fae8ff30bd86718ed7c1b9e17be2efb30314bb03ea3b8d8fef85e37ec7f09541b8a7cf9d9e88e454c73a58811752bff9c836f8defa7ce3f0aa2ae1bb4a40e004052fc67c17b17c8f98ccec9becaa3e2d8ade0df81831d12898276a32fbc30eecc09dac860a598ad50fd206764e094027fc2fca6e3e7b1a7ad783f9cce9690ace6150f252de70cd21475b24f61d763c2dda36a8531a83dff2916d413b1a903b2cd7e06f12ca8afcc92de0fad1c6516ea8f60046a826b2573ade199db1c921006c019187409f07992796087563fb2470c459a9e8cef67375af33c6bd06790fed688b6c97040358ea057ed0c6657b788a376d055ab6fa8a73256f92de56997f74d9bfdefe31f5b15416e0cdc7fe2e58d60bb19272c4c8f0f008ee5db492482d6c99282c647b46dfd56bec3c559510dbc51f483134a72c342f2c0568385a99e736ad616ae5c8dacc0e96d6ef","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
