<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5bffb538ccf2e3bd082ba3254b2567688d3ed580ad3b02b767893dbf5d7b789001ec7f659fb79003944d694af22c3919e33fdf6cc3862cb64d786aca1ce9b3a00fe72acd8a67856063226ecf7fc9a50761b6566bbb39d36f71bedce1fd3a1855429fe29412bda06ec6b75a01df1a757248c4ca51ce419e0021db222f79379aeaf6a6cdbd5157141311f7f8fc57506808285642cf96a08b796709ca80b401c476f8a2ed82d9ba4f9528867777b5187f05a23ed0d8772889cc58b6b215da971a7960e1e3d93adac4828d618d02e5ca749c5b27960e73a5e15d2843e81e0f8d9c85efcde947453700e036d45c33e68b3bf4610573f92eab77a88102618204d67899565df6f1bed274284e1b3bdccef24332b324b5be629646cf1fca76f878e3963da225caf45993d3dd1514b77c1b139719255a1cf132bcfe448722b1888c61316d72b5c227efb0238195c713a9371e0c26b10d9058a878cccb9468668c94f67c6eebea4bf0b3c865a171e5e7e6e1dfd135fb47ffec74abf766ce58a7631e254c0b4d58e89b8e8a6b121aff9acf368b20197faf937fb30dcdbd7a6bf48494bc09b3b08d96b42d621389edc36760ac8d9cc41768c2e1539ed5b60ca071e0caf7195523b0af5dd73d1a45f0f265f584fba41c0d83669f6daee5aea4e358382dac0dd242cd3989618ee3262f406655ae6f193a9578ef4ccbfb9794141edb66992dde432aeb9988a0c874263c585215e3132c5c32ba690ef0357c1497251b9c8eb14e1c4785acf66ea6040f768d5bbe3b614449802242987b7eb5bfbc8ba1f29c5380035ee9f1d64ac681f95b9ebf33638f190de478b281ade6a19b3953df4cec5c426155a8f2b3a1d40a25d4ce2a390bf845c1f4454a785aba82c5ecd4c6eba4fce1697a92a046ae1990d00cc374f4352433df6a599aa110d7272c89f8f64a861a3d0ea4cd523a4e4dcc7d9fcf12ecda4708b3efed6b436b6622359b83dcaa7169929ffd44186c546a88a37ea878569d450e2d4c3fbaf03cca4fc4861a556d005c3e3ffcf414fa5b0dafc1a6732bc22f12c0f309886c6843e1dc2fb0f44044945dfaf09af0a2e9af01d068f76903913526ad96f197cfa71f1acde0a4f3338473dc70a9e5851688939a008d7dbe375b2efa6be6ba7847a858ce74c3dea09fa1af1a43299fbb58aafd3abf4ceb70a7f29adcfab2276c972cbe6373c53f844d726a9b79ada55f992cadeb4ce557d34e111a43b8141f400d0a0b043369dae482735bc8fc25b799b11ddab8ec9b3f7e0843f8a25dd3706686498308217d31e74fec311cf573c272215937e51cb84b60276528e7d8687136004b1ef7c6d4d7ec2fcbfc720ee6ea7a8b502a9d536b603691881ecaeb255105252f6e83d8c919ae419026a0a134c85a3ccad98b10d1424c98449ae11af274a405713ec9b83a2912e01791a3219ed38ad5086f5958307dffb1b51d2fa4be941abb167b78b7fbad883587d55371e5beea857f21d8888b2fededa565040f4940d232aef451a7fed9aaacf2ac7a10efe6c149a8eee8f234018a43ff43a076527bec977c2d565eb34fe5eeb1b287a808f72af29917019a5505cd4859e69941727735410e05c0476d991ca6f7437c38d043c0b99266c4d901454b076773e85507cbaa78cf0c0de985d71569510deee948b12f0a4abd7ffa5300beb03af0f44065c2d97e3a491a8b77023e2ee209c551b44df81236e3621e5db57a727869a69349ee99108f6ec683ba3a466c09b1bddd4d18e696548f3dc8fa79ba2e962fd56132528cbccf208c6cc8e1973310db6cc0901abcecc86d7c2995b57b6aa95300c3d9125a11daccc0da80ca8a3b34a7ec15791ce503a132d4e41583695545d71a30cfab33e8f1add39bf70a6465a6cfeea3b4c849aebd8385455d99d2c0cae0049c4f6f3b94a7f1ca419ce79ceec19f405ce33b7d954c01f383ba40d949e823f8f70016547c4788415e660dd6c85ab48ec875a2d747d5d678358fd2c78e0200100187fb2e2c810c3f08a355550b508ce7c249c927c001192de7aa22c46c54abe7172d7e40d0093e8b4755c8a47083715379f4382a817eb36ba57e5df0332e4008320f45ed02e4b43c4327e5a451d0263abdc5db77644b0d8ce4f8b7a98bd661640da91152ac8103b2e98129f23e8fc03138d3ee915a446eda9ba19084bcd9a8279d0e0342cfdae44fdc44e008199f6a25e1e6c97e065f643730d0db16b49daa6832258c35c67a45d52730b4b079f618582b3750efad3c4d127cee894db9ff89a7063bd00b91a8c5b3c4ef56b9cc601b465e33c31501c8bdc19b588fa4910885a490b2780968dde2a705e0ef7615e91a64fb76e9f54062ba4ea88ab0c1b2bc46d42e9afa9b3a94827cc5c88880baf075ba6ad37fa4d34e7e61873035b17026dc7cc7ff4e5b88b0a6370750aa565b0cecfed4992e8119a2c2b289490cbbfaa5e51c8238c6d78ad9066c136ff8400e76695b56a2866178cdf70aabc65473abca3fe22b0289798d7a3c266bc74224a9249bf82db8c4de1be17ddf5256ce0f13648d71ce58e8248631c3f63a144d7b777ac0d2c0ef493760fd3319d46a33c3e42a2f9f97bb3659dbda47acefb17f51e7dc7256298b16e0706ca522c9ebacb200d43d080d36058e289d0fa706246ae9fe98cae07279d0a774c4645977db9b81124981ce0f3f436da4354b5247c420569af54e2ca80343ae670bacf779a4ada596100f2abfd6f11da9fdcbef323dbcc38f23bc87c138224b96f05bbb62cb5db78efce76396ddb8670dee0c978a9c519ba9db0283288820f60d5c2fd89e2eeaf75ace9361a09f2a2e6cb12241701a236b499ae4b2ead8ec7cde4213bf9bd3866a8cd580453b83b6a1052d6cdb40f12546c11a31c5a72e60fbbd0a9d003a4ad48df1c045bd9131e95bf083c6b29832658132b12a659a5ee43dd458de90bfec70249e98a792945b91d11f91c6eb1007ac487109bd77b9fc77227a12f0dfd5fa77297f7c17ada59c13e2e34b52a899ffddc030145417fed44e136802f2a287f214c4df8ffef6c66b82958889e10b7f13607e16e90c388ef5d6e28c79bb6d3ccfda8f60303a708ead3c0c4e7802e2c48da6f15469751460ce419417aa7f4e23bff5fbfce7887780dfaa89ce8849c6df174ff9272b6e98ee84c02d5f95e467542db50cd1ad51fecd8c68b25e77abfb73f7521ab0791e754b756b38742b8bea19bacc625255c4848de496e2843c80d84520d79268b0cf747d230dc7fdbec8ef63e2b4c670e56edc001daf3db9cd1767d846915286ad9ee64ebab4ce2338d5c0086189e19ec85a0d00a995746441dfa3bf475249528a2cabccb87aa659181c1a5f1ceca0d1b7e1dbc85a05f174b815f7d4612d3d4b6234cce533c86eb06a4e4ac2e209a2d9f20bd72a69de90b16911a917afcf65bac4422deb8a8b0cc093b2859ecbf955e48c951013d7eaa220715b7de2efb59cbb998617033f80d27f63c463877e350fb66111b42290a2e216c0da04de5758c39c613732e0ee084834835daac2048837429cf6e38f02fbdd334246412df40153ea846bc87d5a8e03fbb9497ec7e579f32ddff16249caa4734c9d2a6e9aede4244e9b571199bbd9268b2bf6bd8f309bf01cd2974240e570ee3de70839e204444b769becbb121bf99abd35cf7804886ba61e0aa48a4de5518eb02a0901c390fb1f638c6e8a5f82986a668e043eaa6023f906259a34024a7b1f3c10054606b5301c989f29548ee1a4390aa0618422c850e3a3db46512fee43d62c02cdad2e4ccf4c6ecf42afe259f9e5986f6c24dfe371dcc3f03e099cbd57406cd3aaff492e06b66e25d5b102907291c547e6d68e932592f6824cfe631f70f17b0a47af9ef34867eebee7532a0498e1b16963b67c8aa7fca439ff7e7eaeed51364a002f441bf5e2dbf1af0a82a0e95afeddbdc329ff551ec75e6d56e2b57e2afccfdc83ba3d9233478a533969cbf29e4fe2c6ff9aa7332bffe117e4976c38b3434b2821b1023ba416fdebeba9b1557a70e4a0357bf3de9011e218f53926efdf8531e07c0c1ace24b690e51c670aa7444fccd5564ee6d04e208efd81cd88d2e87d5d7b3872d7600b44a7ad8dfa0f3a96a1508556bce415bae003996fa024e3fd2c8020a85e238ca5bf5d17765ac04c08c6127d8f4e835f3b179860af07cdfe3d27e2b16a7768d80e9c1f3c6f5a40cd0cf41e7ba97e462c2147bd55d040fd9444197b9d0405e277866fa3e071ff37d497674d2bd23b56dba5d3beb2e538e008e82edcd5f4f5c52f24dae38d91431c84d77dd6274e13ecafefe6a95443e0e6957e30213c59bd5d31fd37712abcbb2de05fdbc83f2f40ce1ee4a70cdfccdc346096125a23e5cdbeaaf0140eb95fb4b8eaf875f0b33f31a0d275de0a1036feb607834b6952ae4adee81023def51fc6b68b6c5a8b50cf7dbd3a2388a38f2f0634630311ed161e7e4cdcda57d755952bca7d18eef61365268a10b9a6faa5f09460f96be3309be2cfe7948749dd5745ae78fa632550546b83bb5eef391dfde49fc9dc1c0acbf801ca5ae7090d5e7ee84db0e421f2ded3d3996d969bded4832a602ed29a278daecf4446269b4afae9ede0c6dd15cd20e0eeb515d37638452426ea44587f02bdb9c67586c5c728f2f36df052b0c407cf0b6d1505c27930a8a5edb9f0e3ae0c65190e85e6b9ab0e3267e39395da6fef2fc56debfd129d1f44f09a126e206a550e2ed4d0dc79896987e3c65f0883c50d82d577024b85361810fdf7daf246cdb6948adf9a13cc820f1b0a65287b6c069ee7cfc8dfd3e3709138b6417b84ed84765e07528f572c14dd2aa0afa639abb765b96ff1c079959a84d53f102a55eafd04f0de2aeccb9f54a5598e8b39bed84e016f4393b9cdf098cc4fcf793acf6e666268aea3683ed1e8be971c64bef357264be4940b0828c7fff5b299fddbeea3d7f1ff6fa9c67d53ab7a7c2deafc71b9165de0d2f74bd0182101a1499564383c81376780059d71d9f08e2af7eb66d67dffda2d512e86d28dbb2035d610e0c6f7b1ed82ed770bb281d161487f9f3c928ed05499b7027e21ab0dad0436b84452d52d2596a034277958bf123f3d0186591e5b2fb9b6cfd9b15e7b12b39ff00b45926c38513be3be4dca40f0a3ea676f7d5182c219b8ac5643967058c48c2187de456ddd412061e217ae5b101691532322a508b5d6aea492f6d53301e382eb1415842b2aedac72e00567cb19078ffba27b9db751b46f0d2614e58a0193ceb0138539c56d3c89460cf1e41937443c37642cfc5c9e727b0c38c0c7c8b6816cca5dc6cec660d55696d7ed72d50417588b2257441cf6bab28d1e49b72a2155b52b68c0c82f234a456158e095079a0ca6aed1ee90c6e07042a18fe649d30d0043405e7ac814285e547f9b701ed96f30a2366d90d94d76c642f2e698784df4d3be8c4d97716da00756eb6ea5e5d4ef15451291c4c4b3f0069b7a8dfc4684feb792c9db80a977f71b2c7822c8d915b424002328cab8ce0fd863c81af3ccaf11c38ad010cd87b6d04903ebd28aa1620946e880cf48ffa8dc601edafc34ba6e977502ced4819774cf53016825ebb9576a46fac55568e32187f8d10e69e2f6d52805f655de4938ca545ac06ccea9f26db2a7982995e3dee2c1f35d87e12a53bf367410b3e60b793d2dd9525eecf0b8f8a6eb679a8c346f7de69ea1d8e29b7c99dd6146c5463b71e36ad544134302202a0515c722abe4f5142b84602962d87c60f3f57b6509832ff5243fe05c54f42c4defc5a23c01940a186af352dcfa0438c14b15bfe0158995b56f1a5e9b651621a64fef65342e8df5c9648ecb5acedd18becda0134663ecacef6f0a9c3050a88ab8057a939062701cdeb755d6d6d89d8d7ea7d710244552fad5767ba5d2ace4699324964d0707b6c5ad6d80b31c009524cd45a4e20bfa9837fd93080da0a550ebe682fbb9e0f5581ce5fcf4520acc38a032bda8502f2c179cbd7a890237f27efed233f21f21bd99688604777797660871db46ecc2f85452fe97c83bf13cc574a18b93e26c7366ee7599c939b63db295f22b4266e1bdd47dcdbc2f8193d761daa31b6c3413879d1a67543ec57b9113fef3c879c2126bf867b8f75461ae97cab70d874ffae09323e3306a50a1fa6250048d80c06740f64e9ada1120129a651f00deb04b54d9b5ffd59371353e30b591fd5f4e8c96dd74c2d68c7cba416c45d940d5885d3c325f038803f3e1ab187074873a501fe54f8101fb4bd88eb3ff9ece156d8cf2ec7c4b2551c21bb58ce324de5ef32e0d3019cf7002585f8a6ce5f8f6ff1d82408bbac1800953a8849a1d6d9f592b358f9abf03e53db5db3b33a9dcd0cdc78f662abce73270abd4533ef5561be0bb84f4cad1f35fb4d34c4d2d3b8e98d74b14aebfcbb96283267a2a5c200dacf6bd6081c2c0e5a5fd62c915529f90330a65b37dea581088ff71828c0138e9f9def00af622c95f36dc078018bd2b9b3bb472b5656129b7e74f0950f3af6d409560849a91bb613253d96d598e21887bb9ef1985e0c1176eabbf0a25686783a890208bb452caf42a5eb4944b1baa7718d6ed4670a6525ce932136ce6a1bdd7b1fd55ab92fcf5eb211b720ddcfa1d3000aad22bfe6d6a9ba2dff1e48d2e3fbbae876488a983efaceb63aaf76fa97a1aa9b1f8bbeec8cb8007a8f5647d0f6546829a67ea0bdf3e3f01de0bf2128a19da263d08f4ab4583f5726ecede4a4faf8601c352d0e14dbb91221388408aa50cc4c3e4e9ad48eb1f98e510560d31d11b256e8934888b889e480af7be5d4144a09d2cf03b1c5bf6106b9733ece69fe4f7ef9ad9c9a7d7add75ee6a00ac36dd7100550208e14806b4ccfe49862b8c89e06f64a9b6a3f0f49c827f5c772418cd106947f7e2bd1eb6d53d8417424a2009c8e971e9eee3595568e4864cc6b236801458030256ae80fbb5c2cf5794a8dd1d06c3b458a1fdc8cd455952d64769c101cff9afb2d818aa4235fe45206a7bd71c76388b17c4c2bca1a5215aeb3685d5ff800fde11a03392e0da9df4ed839d5130918cdb42334ea7319b888c83d91fc1752ecd31cc1000b1dc7347e5f8dfcc71c3f34cc2b2e5de20ade62bb272932e2910271fcbb566417a830e145f71b0cc08128a03e9fa9b84f97083615f2daf46109c8c6d9add3b4b0f0a4c0749f1ffee24b148c1f5e1c5a06cd991cb09b89ef550aab04e2cbdeef621f30309b983772ddcdecc56cc135bde3c1f4f5b765ebf8e471abd7df8eeda3a5451f383ead1815775be196eefecf7f0f7884ac4623bb844c3755d38ed7744e31b81d10d04a2aefc40559782cacef19701a0f917d0fa48a09779b8f9e284bc01279334e0bad47570e5b94f2d718a3a366d8f8b3403902bd8fbb256094d5e71fd2ad7b96e001e0ee62052a035814529cbda744e8aa9fa883a00fa4f6ed301ac61ff261b685f98e225646ef7ec1b314806517015b320747d56d73cfd9dbcf8c954df99fad63608cef8a1d21095784a6d23e15852931c2f8767ab93696465bb2e5e04e5d92d93ca0e5e9415686f391ab1b22a2baed481f326eb7991c7a0aaa8fea7306f289d8e1e1f27de94de09c5a6412782221025760bc29ff57c6fd0dd5e25e3d221ff906e73e1cbfddaa026858f4ee07840f8112d70016d82b96249acb978c64ba77620245a9a2a728c7350b8d1a06d022d9d10a9290b7c77de4abcfdc3cbed415c11b9462f106db55608f9e8d731310b7bfca58b0ac74ab42070906b6266a39962b5f07c516f3bb3d3eda5f460c9623f70608c163840ff1ff17c30e2aa92c96ee1eb8ebc57a69eaf0e8cb4fa524e2398384685a3da48d60cc8159fcc5842b400fa48f0c0dd77f8125505f36d01f503b376eea8f9727a021046a4e28a114d624f95a49cd6202508023bd07c3bf84b5c3b756fb26afc79c320bd7283f51c5a34a321fffce82b68241cd48ae148c1a0a94b434da489dc0f5daa04aba39de3f79ab28b2deab7f3de340b9e11af44197f25f480c5570e34108f9990930ed2298cf9b02dbb6a4c5bc7c2575dbeea5b10498b9ff5432ef07bf86da1706b2e73fc0380863f04d8534eb528307d63122188eecf69582e4cf7d1a5ee8a0efe9781ba755d7c047b32101d45d33015128285720f3a4fc32171d8ec56e8b8a43392d0cad4e9d0c722366372383f50b08ac273e23be11f3552897f81173b611a1ed62ef5b8934a8d15638e19519b7b1c0bad632440d9410a95c4cd86436d4ee3fc9b1129aff607217314f6b1d78ab3b8394c4c43f8e01ed7516ac70b879efe3d201fb5173dcfe3d43a38f940a7fdd379aa9d3585f593374c6a1d87748e1779e49fd18133dadfcd0bdbb2cfae0a6c4dfd1e6313ef49e2034021d4099411535e7758f44e960d33d0916f4226423107984e8184d66ca2a2ad62dfc2253dbc161e166b390030ec695d2d201c619726103bf6f50d8d9809f4937f91cdfee06cf1f19e863113641128f0735af7086b9ec7f500781a0a5ca18f3906aacbeba8ad2c1dc38aab9c8f87db3e587d2f3d53d04b71be5a7514a168c9ef775f1d239b91a6ccb810ddf5e0679f1aff20aa4ebb0cc34e416ccc076c50432d2172f101e18bf9b97db39fa07c51a5c39084d55e13705b2056e60f9c78df2f3658f8c9c41ee28a09bd0a65fba5b5c3828b803a99823e241f104b01e8b08d1d3bd0b515c99e981d1619f0010ab5ff33afe317801c861d627f4df8e1a0bb00c1c05fb4892297712fc4cb720a803f54cef2f519b9ac5439df10c855b236034ea82d0e12163c8221c773b63eeb28caf4b4e5b88c768925c7c7b90b1cc8d0e358888d6de0ccba37881727c3b8396a49b6e97181be3955352ba51c0801c48cfe4928c04c101ab925fbea2ceb6b85ca3c904e0dca736972e2b86e2c30aacff9574417b91e2b98d73c72ec13248cb0f06907e894be7129750fbcbf56f20ec4e9318af7a5211c9d232f277a71de2f1f32473e0095371958ade01b2c79f17812ab55a369d17454f8fa336224d9c59bb25dcedeef536a82c633de74738cf70c46fe1f9d9882da730c4d93ba978ffae0380b7ecf6ae6e032142a4cf2c3852708aa52abff351cc8b0fabda41e692f479185676541fdd8b2a507dc0ed22913bd06c5c9ee6cd2668ec71ee99508cf4db84319f00799aee65c54658ab935b8a79abaab8ec791fab9c7c8d44fc0d6c106a17985865261dfb683eeb5db8096173a278745ef8df6d53870e9c2cc3d6698dc3a39fd788ac0d95869c88a34290da96f416190929ce3158241cbfd0549929a61018766dc36459abab5390c03f63878e2d231f8fb6402c75a3796a1ffef37e5d5c9765bfe1bb53df50f5508b634b75f602905c43effe6e164b7ae2cc51ca3ba390cc7c38617a20cb13f2c792dca68a691ca69f55d4cf03402efa853f54c3836995459d59169098c25f686e470cc497b06f2364a8b2fd0dce87bbd3accc3113f0add587312e7b7907524ba1a3c390967c24a74588ecb90e24a9e149a8c3e981c4ff843280efd5f7c670f572c1b4e08b103a6e6c843230e0dd899aafb39d87e3408792b2e3826bdfa1a060a4b6249c82c09038ba22ce6c6e883950b178546aedd65248931006d3afdf2c20b2bc509a1ef2d69bf55a29cf87f9d5a7e9443154ecb717a9c2bcee578c4aa5082f88c2a414a61af8ba8d7e5165dd784587e5224ad32bf2127e86472f2785023ddaa96e150abeb6c70bdde9679ecbb6d48f59f428e8818394ba9295971299b15df6222c7f9c8bd5289f05fff25d1ca2e2d9f1f11e0de079195ff6de601dde0d12b477a263e5a978ba10a03c3bb40c0003e4302e3c0cdb47f5a97d83931727515765f5f9db57a3e690b230f03de6ecb06de400ccf47c4adc47fbffea7556910a3869e1f8d3b52d409dac2cb8406b0ecf7a9fdec4f1822b396fcc0ea2e08858aaab80b9d95a6f1ea345d3fb1d472f25da80131c8b49a6cb79e514398ef21ac2f6515195f063683a9c5ea97fb3efee1cc4512c41ec82b5f08afcddf2386948b16c1492bea8909a0a9775af193399843d0a154b1876986b673fcec42d28e34b4486417279a4e902492d79f229d46f46e10733fbd6a616ae2ce9a84d2e05aa559542abc4cb991f63bbf43a97650e56bf8f98a4a21c973db2ac71643d040e42e18b4d0b2d2d3cc0da9a8d3b7e78babfcdd71463f9016b537906341554c22aa4521e84e22106bae2a2c865013677a5a39a8a61c2249ff9e751f17c418b0e1ecf34afad4323ba968157c0ee6b139a3af21388156465b8262bd5b1103f948be1b53e9fed5bc59780d387fecf8be0972e934937979682d6a24699018afca063933f448c730d011a9cabd4f62e5ef56a337212c201f7f4cb78ef9cbaac69f0dcd114a814b50fca4a8b5a261f97a19dccda9f9c245fda56aaeebd5027845908f98569101aeb7b665b1c1fd097ab41a91ef0f777807823b7746f6c411d77eae400f087229cf80afd5ea6af32124ddc5b6c2f769d78c164c98be36e53632a715657f7754186538f531973e1e92a5b314a4648863da878b89430ce62a93ce232e4f2018876255282c7dc6442fc1720bcbf7d623e1c9335b1f82519bdd1a632f426a0b4d8b6c1694305c9ba0f423e7479840f589d23346759508bb9ba66f38fbb7e7c62024bcb4b6866f83440c813d574302c2015fc419ecad451ecf9dc90405cc05004d04f47de120b2c43f2faa72805021f73a6094e338bfcd5baa93db0464812b7ade68b1781e666b461c2a26f4eabf7777c5079b882389590aa07eae29e5ce5b234e4cb2ca2ae69014947ab870550dfd978c0673be66f5278736b78e23d2ac9b7082b5f0162fe66e83ec58dc0b18d95677f8b58b39143c5b6875f5677cfa2e5478553e59d5bbb93d3dcb96c5cabd3ea9c532f54b0a3dc04bec6bafaf5a28ffb5d6c1b853b02d155374ea46c8f1e36d7ab5a18467afa4286493afbfee586f37330d78edbb6eea819bd192d99f8b31e64f6d56a21a70fb2f55d26b114f8940088d5726c855efd8a252e94fa41851ff0f0955d2ec71f3579f7300ce91a5606829b244e81f93e2deb27e213e3ddfd3c37f9e2a3fbd9f053cb6b299ed13fccc240e4b9d8f83714d40a29694fd2a8dfabc52e99e68cbaf7f2d7479e1f5e4b51a3c8fba51e261feaeef2d73c6276f06a09be77364646da7263fc53fe54047b64ba7b5a247b93108174a93eabbc422351176afd8c61ccdd4c7fea51742dd7916abd780331000bb9a64e8dc762101fc12636f12220966682752c01459962bcc5359c36b1430be2d3681f3a0f86a8217415a7db88a3b46eee3cad883a828bb5b2f9636731e633bdff949e9951ed76a72aef897cef5fb0f27dbb5b93c7ae306fe7ef639e711019fa5dc0e61df728720e88f6986a4afc261a285d75e37d8b043da2c264502344f53ec53ea2ffe791e61e82e1a84958bfbc5ac24e43edec9956e592402ea79bf2ea3c98c3c6c6299427d46bb0ac995bf195fcfed6413b29406bfc3b94360a1ef3859cce5d5a34534df4350a2a6cf9c29465b36b183e7363579cb40a42e3d6880670f135349daf61764c5acaa77639999de968febadd01716a87ec42e85a6b1bcb8834b597f388c18f472abb5444cd7a972dc0d990c38fd51e4dfa84553d69ed72954c4998b12ed00a9b4f32f127c79aa26594f0cdf94876a869135d395f2fdc8f907e8dbf8e9ea5651cc02539ebe688b29adb88715d8a470bc5fac6e4ce196f9af095b4d60d7f2c7e959dfbf3ba67bc27317088885306c4cf82c0feaa84a7cc4c64b220e8039db0a81fbcef6ea43625b2724b4814d79698ce5cfdee51ef6188a841ccf301a46eec9f5c378c4f4a8761f33a008a8502530e9128373e0ac944df817388ef037f394b6d9f678a5550c8f4f40e0108b25763ac02d6469764b4954aef8f9d5ac4bb18d34b492bc2bdc4a9a67bdc7c773e2f34956ee00b3f40f291a1bbedaa8559ad0c595110906442c38c5a61c9b9a67ddea093010a3461e2586a3eab223718766a798a54688804e3ec4067665760781470c0d94dd67a11d291ba11da0ff13a117687f2a090c2593c6c2fb875a76164da94f2cd26013c8263584e6aeac24d712cd4129dc0d3d094e464591591357ec2745ad6b39dc36228f1c474fb7931e54c0b3085d233058974007a8af0cf51045a57785125143217a23cfb354b8db78696545ea1772a95a9a2b8858f6e118ac7cea75bbfc8886bdc7149478dcaf6b7b9435c76a9533317b42412b8cde1aab01f7f5ff869704bff1cc372f761d8097233351030df80f65bbf1d779dd09312c1ba0091390754d1fe461423e1ca9af2b6a021e00a9579e23a6f94a50c14322cf3a140d0ce6a57cc948f8d7046d9a134efdf62a3ed9f61cdad74869f73caf9bff65603d2a8f59359b17dac944efde4356dbe11e330667fa246a9173ae4850c4b1d362a76207db5ff9b1d44712717f309aa8084d391d3268e2e15580da31497f4194192b1c9b99d5b0dad7d68d722b9ece290994bcd6a46a8592625ce8ad84f1fc50ecff5fdf4d9c610cf41477a5ffc30fb229dbf74184d1ae8769974b713d880e00dff4195fd29af6e52b8a9261abc0164fd32277913bdac0f528d18ed8ca226901687c5caad1e9f8640734e1a4cecfac0ecda655a0de1b43609fa7b1d93cd390c2838176fadc14d33ae7106e95b79ba1d13ee8c9445ac8700c7f36cb8bd192571f5bfb6e7a38bfef7df9a218c2202431974c4fc3a2d2504803bfa4fdf73f8904018be2ea81487fb76bd9c9d902b4ea041f25133f21b7cf81cfb8f23595c1ef2831aec1c038a5ebbd450f6a3304ca2cce7d00320c885e5fd4859591aef59210dbd3ceca54ecee7f75a914cf649a66067fcf6867b99587e6dc7b7fbed8e1b1947c463ce971babe74ed5e6112c9c5603c3b0327fadb6c895c0facaac2bf72c58934446797665e6f26c72aedddf313f5ece7d55b4c08fcdb3b19ba237f35fc02d31000d1d9bf17a9b6a39b1bb0297df1f2b391486707f1292cbdfeb45f72ea2c89ceabebf24639665d2a0420d857069294fc97cf24a63b45fd7d32febb68b85bcf48b355a70af94e32633ea48a353c95103e9d4b2f2791c1cd6cb89a122ed1b48ac8454eb9aa012fa71e1ab0b649eef59a6a7a521aaa2d02a57e5717bb6cfe26d9623e7c8d34e4d051d54b82741c2305c916fa362d4b98fc678eb5f8378b751868812b90883939919d5904b8f5e57e83dea1d95e4c3d6aab0546c3face21c4e3f2e29a3d4884c7d5fcdecc085a8e302b1c1cc375f22b44f2c90aa3a5e9a07a6e666752f6d25f61bd38ad362b7e75818122b1b04536ad5b45e5806a9b92d830449f6fce6849beda13fa098b8c9fe9e2f465eb227fba18e043c682115d2808602866849dc6e5e95e53497561f221925482c0073cf260bb387b5e247531977d994886802d7b260991e79b3c479121c015f940a8dbc326c2db9b8056b745a2cc498a2ce8280dfac37956e438f2f35f0f904ed64ecd541eea74856489f885b5a6ee75f9e7d519a707f1dd8011d6eaebdcb19fa477009f76cc29c9043b62a91aa5f04751fb83d750a2dfbe0bd016e2fc54290c24def93cc992ad03701a91f7830dc1258ade2dada4888ce6cb05c60d9fb585ad99030e2cd74d7f11b238aba54cb6cc20e6b6fbf2faeaad23638b06a53f5a81c1972eb2ebe5e4256edf1f5118dd4b7fa713debaedefccffd636e5ffee1ecd2ab5e3dc2c2d6c20926a6c13208d772bb3d28807b842ce17791722d8ee1ba585f843ace6ef2a738cdfe555e586e58a5810fa4baa717a75cba924692519b5af9bec81b0b471763a54111611341364f0804fd36cf831e9e3e351153799cedf0c9eddfe96979eee58d7f8732ce3a950fa8956f983a44db71cf52758544b98ccde3b05d1fade2b35c10d31c99e66d985f11f59503c991c13c1d4aa3a7e4a23150f2cfe48697751864b117f94f2514151ff382e8e373c3649f519e70d29aba6800c5aa284149d9a720a7786e7a5875e69f96614a74aa3f0805b0b18f3dcec94a2a36b3072541ec5c6d12b409c8416b48c5ded702284441b31ecc4b886603dab27089c0e27d1bae7e37d631e4c929952b9a9996a2bba2d62dc8a8b3c3cfc148334b4e598ad4bd1e4d2e66b0170edbcd69a01ff47fd7d81b49d5dbccfc811cd7a342412532128ef9a5fee32e899c994be136a4b283c1c4e0aaa708330a1f3bf2e84e362cc7470998557c5c8a7f39f4fab9e7140d29af678844a28915003c0b7030d8312f3526fd8eaff1f51adbe006b91d250faaba64e269f2447b43441a859bba0d31fa8f73fa6626160fc58174ecd496841086af747107b44307f75d42a31904da66440a16e559b4a9f045c585dbd71163618fdf23a7b7dbd7e946171cba5b620f011c50c90741fb741c07cb31db3d834f421f315c65ec16f58888fcc9e8eb01bbc028c791b30ca415dafc346894701da39ad884668b117d9976cbe14de99340e892e3a6cc44a0ce0e242632ba4e12f12fee9a949cb98e67edf4b85c7e616b9ddd2109961e352bd637604ab2c458cba50b2eb09b1bfed1c94dbae238020cca7174994bc0b20b52259f7af183b39205c3884add01da8fdbb30aeef98559c45017a40e43df72f77519edddf7fc7450336d3f9b9c95f0aff6bf178b54367c1c7608a75cf948e0d920706216a174b90266de10bdf7e85585c66674e723e622863a378d167d0da6b99a7c720204eb8aba16904bd3eec491948c667b209575de1f8fd5f84ebd40c579c34d99a2932bcc47fda68c962ef8e0b786fe2d007ba9878bc1547ab44fe18ec7dc8ad3393df49c7450db34c34deadd7e9d92aaffc9090130d61bb5768e95cb4fe0c2624503243d0d5cd4ad1958e744193de9fc4dcc97f7a81148c0ea709440091d9f69c7b5fac196a3f4c9e7b5a239bc6412985d55c776e4ae2ac216845a85c8a22cfcae6c9fd1faf21dfc824a738017fac9e8fbcc305512172783eba27aeb30b5ac1db39524a109b100381880569565e58a311974239471ec7e7f4a355b4cf4e3f7019c2a08fb92043b87807cb95791ec19ccc43b8650fb08fe1e790101c21219d7275b4c5399fe08044ea4c8e45bb225409cefd1b2a134e2630c3802c64ecde9a8518937ae883a811cf1edafbba69d85ca6043317ad826682352d1dac8cd69aece599f4b872726fa0341c9acaed28569bc934ad4dd0d66b17ce07865d03b2de74a9efe25664104d43413c7f97370de1c12f1e836481b456812effc0090c7fceabd68f2672cce6caf2626e98cee28d4646e0215531c9f49659c3499e8b51d3927002df49242c54a266bdfc639f6feabff1f4040e0edc1808e68d2ecea8ae14a50d43d6ca2e36c5dcd8af22e70904ab94651d89ec2c5036315d50e0ed5b7c3c0db2a79603302340e68b6cd930ce9839d870c2ad270c26ecbca2e7a8d4a25d078175aa80f61953285dd77faa3e00012b913d982d5c88ed4f6b3374277cdedd8471ae7996b17dd9fd9891ffd5b933c4ce2aa901d1031c3d393a0ab73e21e00fc53574602fa9f83948eb1f9a3ca3b5adba3456035a27d6fee1d2a4c8c49e17a930bfeb4b75fc064aa1f731569aad1f3d27fc5070ee26438c24ebd0b4c917807304682ef0d853e1874eb35f1ea75c4506ff56321b335c55df229a7a5cc47a2191bb9df4642792d18415b42d23dcadd0a6fe29f1a9a6911dfd59e774a0b1f2b0b861166563c1abfeeacb8c2b0861f7400acbc63168726b93e3d2015fce4b8d212b557e263372e77edeb51afd3629d8f674bfc86a71729ed665126c21d4ee83e9c768e479604e4cf91446da17cc6614de51fb9f2eca2ab00fb29a8a519250955606f8b147daf16e2f6a4823e8460a43f98abfb94189a8c045e3846206fb38d7879393259fd033456b4932ed85219088a69293fa765a010ddba8e8e3dc3c9b608de4a2d6cd2ac4b5436e20804f33e62f6d07cff55273cf684f445f34950a9c39ac8bc8c96260bf45fe9ef68ccc3f3ed3cd5fec1e2f6970124d7e974227169c135a2814f95ef5de1f1eea3fc7db731a8d0dd2a0fdba6eb102091b46f225f8de5d2a24bc21df803ff36205841c6e01b08729b32c028470c00f9e31e16a36458cb3e0bc280e11faf9ac9e2310d293b4d4682540d04baf3d4565c628a137c6b09147b1538c1dd3752e87a789841064c90157a0c41b19ca888a1d41d5e91e26d4683f1c9092f8e1e73f01c00f462e4f99c9dd487f6094190b8639da68e5a0131a1cea23c02a555a7c6861c272252b60c582445801f6a8229ead022de51e10656b46b363b6b83d07fd316253a6c37274c4031d998117c12361098071a6d960d302de0c425c0cfb6fbca119fd57a7d72e794708ded808ca769a8a9550cf9b271b47556c4d5bf34a808f482675cd85519c858dd6f608043cade43617d0272d4d6ba1c66ab3fea3c365256577d90f1612b9dc7954b23c30531ba6b1545124fb1282fae0777bc6e67c6313633551182338d73d61edeeca8851728e781c9956d684f5569c8960489e1497a95f894ea6e24dfbb87ddbadca32e6b71a38886b1724118a1ce436fd6f53a5fb5ef2d99d5567bc0bf5511e75a9f9d82ee6990dfd7171aa60e253bf2528380f8b02480094d4a8cb688cdf62836b90c298be83dc5b3a8da33548865518d80024df18bcf5b132e969d8907c2fe431869fc3165eed6b03cc0a5fafcfdb11deddd8ebf54bd8dde056eabe3e901c077ed5e8824e00dc50da2204f183fe3603676f1ef7e5b03887000d4042ddfd0858ccf4b7ad30de0689612ed189abb7909aa4109585580830990ab548354dbd27107ec562827220f02aa4b13d6d0d9cd79b8a5a5e71afb63a99606c172962b5a7c094aaa7de37fca7576b3908795eb56fbfae4818a0ceb21035438f7499c28c41b1f3d4fadf6e092a77e45dd38c9ebae73f877385dac318a86e5b783ac0d9816894b64b1869d358afb0e7785fe4b93257287fd154756aa72acc2964b0a6265a4581350c0e05e5eb333d87101749777ea40130cf5879686a1171bede3ff63ed530b9562c9dad6e4735df30eba21a31bfb10eef55456a4f9d40ebcfa573f49793b5b9e1409d068580240698251954530ef2ae7727df59c7087b440fa5c6197bc3105b12c5fd3ff284de8ef20cb42c2369a98eab7838ca98be0499628941ee1374e1b5b502cdac323f909fdaed94f5c2bab0330f69aab84fb37daece7523bd77c621c7f207c064c634e45f9c824e6513a4f89f87f0705fd42783c7aba9edbac3450fee9ffa78419cf12b252254403bb3e6a95a9bac3141a4763bda84fa88202e454ed66bbb12990bf01df99e0b2f706b1370f77e219f990a6db689acf672a1cb632fc7248a96fba04bc34c7c8a708b3fd14b525185e429cfbbf3d2878c0d8039933253f66efee7b1451146c1965989c78873e3ee18e7bf00929b3c03e7708a6cdc0dee6674ced5ce7c32c44e7da0918b6339e5d9d876ad45c55990951adf763ba08a6f720807201c4cdeda19ebfcc1961c22f940a74f80d10d5560c95f14c338c80253c5eb38a7de808bc2c2b14b9865845a6c682d6acecd8be01f3852ab85fb87206064e28e6f3d33bb44a34a4ee41eacd8bc2e7f699ff00c6d6bf6fe4e89f40a0e34ae8d4b03cb36119795646fc54a5f5746912d0f07c37d099eff2375b8b32edc9fbdfbf3848763de21e417d5897a35ce4409269bcaeb4f1edde3a50122890f4217d5f78f895e79d77cd64a3de80109e3754442e6b8975464f40fa2c9fa9d854d27e735f6a8f60afd1c2d34a577e58c647994ff055c03ec361483445643ae8d62a5ef7f39064aa6885f333f1990379761522e9f73435bcb04c3db2f78d034c2c9118199d310656bf7940f8a26dfae5037ceb163285dd49d81a19d3f5998e875b7d5c399c62a7cecbfd8788ff5eed539689acbed856d3d19967341aeaa0724fdc9f72be91368208d577fa814f2f839d6209f4d54d672fd4206aba1b870e1360","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
