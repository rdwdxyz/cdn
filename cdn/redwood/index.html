<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b4e9a13926f09b41b93ff75f97025def38feba3c5c98580aa1546e55cebd7c556fd6afa15b7447ea817d167f18a6ad41fd1e29ac4509202bdb9b7d1176e5d11be1495f81d4d0e069750e2acf82e06fd755c38f4c447bddcb3710396b0e28dbe688ebef49c95b21d6e58d3209b6892423b55d8c2b0ab6d241c70b03bfd0a9e8fd73836ea94d6acd1590703ca35ff5c6f82d2c7ea28cb481e01e9e8631b1e07aade2137873dfd42c386b4619ca3977b944ea90cdb6cd71500b2605f6c7f209306d7a4cfadf9134b646d5acf6e12ecdc199468a47732052db2a0b397dc465d99d3abfc5f02392c861c5d1de0d501ae372b1dc0202ecf60d327aa5fe119f0859a36aec5b6f268c7d6c4a8e21c1f0480b9fb6a706b4f31495cc0ff0c39dd94f1892d3e155507dc353687e76e579231964547d36d3bfdb1f9cb69b8c4bc201bdbf0dc976c26799892835409f05630dbd01d4f25726067c8a0f00d899e8e3564b29ec0085d22f0550d81c4640c322c27daae822829ada0403f6596495e0336d9b511a2db93b0b669e1dea5a357bc0ef92ca1651deca309f788142fb38d5860a2f7241a5a81f952476a09f8eac9cc97292df496726064719656f36db92297b6752189fafe835046a99d3b1535c2e8db92fdad75f8649755ae9b2363595669de08d007b31b3b2e5c9c44cd8114ea786f5cc70a9e92bf41aae2ce16753b57a29280d799398197e9b43608dcd47262232b23fa355462f281de4eab15bf8ae38ef7a03010d69e55df61b5947f25e3e952d58700c28869c09b71f5dfaa914c9102c2a584c6b8ce77ea7bc5d224e998d794e358f10cbb818f44c83c3151d136c3e02cfe80d8d51b8f78f6756550c380974b969427574f60d7b7b606accf81530ff2e15a1ab2f06f1ab9710f28ea6b5987ee18707019cd9dbd53ade14a1b0a4e864a21e78338ef52f8869725cb90376614aabea586ed0acd3b0d742f6985394649e83b153fee87ebfae433bf8226f384da4ec85bc1bfa7990cacb6e47dafadf00d36266dd7d90c09a05f0e4662a25a2fa548296dfcd9c9cc8e38b24708764ad8bc961f7c5fb46b30233bbc9827cc46875b0c9fcb4ecad5fed3f5c4f96ac533f9175f13993830a9dabccd465eb34285c9522e01d15b980933b8838ef56eef49be9950dc8cb8a819d5e7ee247f37ca50a78c4bccd55a378889ca93b894b1d93a1c091f7cf199279c45da0437c1806545eeb4f01ba2ddeac28607d6c030a8f0fdc008f09aa0fba47a0b006db8d07968d0482459cbfeeb99b42bcf7df787415f1b79f86abd7e9c605c6a2eb9b4eeba79161434bcf1018fc77944fbbe5f5dfbdb0795a1f507e101cec1d7f50e6f8a330b66192d01c5556109c79850b5313a3606899975d65b4ef8a2c10ef647d913fc03035575f1ebb3984336a0e0d04279c74f88af248a60e30e1eb41f5b0e973f142686a3cbf40f41c3be208b46914e8f4a0b350d66d6cb24404157ee7dc59f345dc3d0d03fedff8989c8d66748eed23605be9dabfb57001a98e8885d2e7f5552eadcd019c2a3bc1c08257217b9ab008ec79f1c60f005348f8807fa121117df6fb1f5cc3b8dfca98a90baf005c419fa1d92853126069dd5edabf173b17c6051c6f9dc7f74fede4463140e13b33667284005e35d32deb5676eb456b296aac3780b8313d1eb938ce4e0acdf09cd3a042f97c45ef379e0d1945c075d672656c29158e21f4376d1f970428098f340218a16d23f128ccaadf5220447dfa8be7981372e7cac0316bd06ae4ec5f855f64ca90ad8984953919c2390dfab9c51cdf3b8faa50bc519909fa4c91cbcd42166a11b5d1d903060e1dbd75c4c5cf5e20908f56ed370582a58661e965fdce8ffe9375ff18a667be699fa67e7fe82ca4c652d400d27b5f209df18638dc2227e3b82b41a5aae1fd3b781496f9c2334864f16229b891be24732f18f49df26b0adce2c035266bd34cad2044ae568c254134786a7484f2b7d0d5fc87abe440d87e40ca9dbf786e19e11a7a95f5ac19380af17119ef365f091449336be099faa1e7649bd2d41547e9ceab2809f26f1c77b02055d7025a9ea8fdf9324b1e0a5ada4b8d0f44329eacfaff68b1ad0eea72bcc0371fab9f1501a6395a1bc8cba159f17ca8f5253e496a4e522bb66f9871f34bd89d30ec527bf99cc1de284c909cea55d43ff5f9c435448eadc2ec9356b72e8878e329ef3e133c837a5211564d251ea9256d10743adf2294905054be417c0f2e1090cf04206ad26eced9abae4b6148e113b6989b953a8122424e7b06e93a5c67a153a715db0b4439ee04b8b6adc732419ac97913654719f5e9d25a512629e7c5de00b50059a475dbb2392cd350038fedd538439dec325b5dc170ca25abc3222d90afdd281cd3e3206bcaaa4023a531a885be11f2e5809b69bdd0c65cc0f02c8f8e5ffbe78d2caf816d87be4d4275095f7005efe94ecfc998bf7e203ea1b700b5e664ab04e62cc7acf723366d201a130433e156a102e3004ca1feacacdfff0c746218e00131d46ff0104dbb8dda63c8e4d0752769d2a898ef017010a3b3781222d9e7fcf9dfe668b9d639f969c48a86b6bc1909dac2464006955340d675e306dbc6611ce2bb42884690727cd6eacf7ac4b8b33a1cfdddcf480292b3312e785accf5cea9ed9cfbfe26cf02569034c0c80712e2e2a96d83d02d9856559889d0f58a24338935e030124a0ce4caf9225d46c5b73fd8356e34165db33bc5a72a348c484d5c0aab92c644cd2f7d5f5dd77e35a2bc6d2f2ea4f8df3d749115fb5ab97e9af16876bf909d5ec65a8784df71612688c5e942e7cc1d730ef2fbdf414d94997fed1162efe4af6f742df4616d09ee34efc41a7ee8e17697b4d98a55490f5051281d2f84151d4f58bb00e9d850aecdef647beda09c7fe63958e517ce60957ab4abec163b8ba166985697a74491858c8da69c47db0c9341be25314ca772ad10bb5c1e13b271ce886a8823ff346a7db0b55640550b59e9bcb8ec6ff054e2a62291c54c93b80337517151f189391b771251bb0eb08bf444191a018b6185a2af40a9388f32441fd7525ea140313c4d51f060e7db1f97f34892dc33d1413b4a54a6733dde3b38f46b74d615db5291871725c58e370db02d49490774e72549721f105047f6897a5fed720a358b8a18e95112a8ed1c4ac2e07e3e81112eac2f05bac17b6536a523539c37a54efd0191721a5e11109cb4f0da1208fd9fb12a28cb7b039e0ba49f7aad3069f105e1950979a147c31f9e451c46da58e76f0472ee77f209ee90b3df4b585d2f7f3db7282a97ab4425660d46b97cda404c4f20702ec7b16f5c5d8add10c538d77e4d77721e12eda5b88904d017407f9f29c16804e369356a28b2b873f958f590ef745831a138c2e4902ac053027c6fb86bd13c659ee7a95dc4c1481182cc9a548dd4d643ef556a6504e64d22b97cd5eec679adfaac1905e4d9f53bdd99b971f442323a80d4891f32ec06cb754923879db6fc0ed3a9ea6190808e2804162fa67aebceafcffbcf48dcacff6b71373c8bef89d4979d8d27b2a7551f1cf391327158b780446e97ab62a4eeb0ce436478b389ad9a0c48bbbbc4885cf9d20edbc760aa2df21aa4d43aa0008a8e8145f7e311d4609e78925008937cd71b3485088d973838b1311a5d5b2813a00e158b4be927ae691f03aba5d8c3d08e4f1db0c9c5f0dd0ef3c50a2e102956e636bffdfc36c267255c8d6f807e6a47f11446c9d0792fb3437568d33b306ce0a306edb89afc2db885ef7e4880e1df46da57c94309c8fb505d438de9658cd04107336c2bbd103ff122e5adef71a433fabb3c942e40d9703241a71ce791557a3a71ff9548cd44f5e74c1632eb0055e2838564ca0ef7d666288b5691d1e5d76eec8d7afb9258b82cfb8ab85fd9ac4aa7917b2c8889541f3b8e6742dae35951bb2db96936fd99fd8b80a99bb1e0fef9900a0d67ec71dc379e5a79fabc9ae4407eb25fad3bf3fd593cf42f1fc98e617148e41d5ea09c4b5f37483f2bbf6f9f68324cb12874758769ed41509104b5749a9e5f1c35280a0513cbab0e51bb560a6e382c8b0a8b81ac2febc35925a5ef70ff565c7f67e52b9de9b70cffa4aab79c656fae41143b11e04ced783129aa4fed49e8e58621fed04dcef3c3f156f9da58413a52a3c0d8fac97e222ca2a03ded6858ceb9e918b8059337817a97541ffe023725ff7ddf307451750410fe1b9812c72568bc9259b4d0c18384d95f7797f03c5c2455f7de2263139bf911bd4d8d3169182b5dd57df39ca34877f93eff749b517fefb6ce71948f9baade6e66587ff8f65ae60b5ac824e00fc697189c38d35c585efc6df28079467538f66d66bba88221ac7a942793120a357a25b0208ca08b71c84bf1980122ba691e401b89620bd949bd7de639cf38c314f14879d9abce478ad9d57c77a41f9bfbd2253f54ff2d877dcb052c3ec733a86c5e7ea6a89800063c305ea17574331000d9c8f5d428b551008ca159b1600c11acc7059cf07bcb4781aa111e834dcadace5aa0a482e4eb0bd028cdd7fb575996ca23bede1d9a4d7c7e21caefa0a23cf368fe8b00293650930680713ee9f2a9e0a136d16633f0bace99151129b52c92d54577659e2ac5efe1a8d655faca0f1faccb6534356a4e985b294260e3f55113d0a19ef5d5a141d7d9a90b04925077594cd3f2f9e3fde3f3b5c98d2f135b9cb4f236195393fc4ccbed7474908918226c10f322ab75239aa109a31b947587d8746590b88d0cc8a44c5169c80a0319196247539e00db025f431c7ccf3cbb60a3e550a97f0d0fd87d05e1a5202dc72d55aa408d9ac6ba9219c81d02ff9b09783601f45cb28db1788a1b310dea0902900de96e02f9571961bfee342a67a7ecc16c2d8da289bb155bf85ea96df989f791b0116bf65be74e794968e08ef21c497ce972363d51b0fa0fe120edf91a1094311b799a7a69f7e9ab0e3ba086c17d89d89be9513b02c5106bc6759d673510a13c72dd6b10ec069f49e62293286ebde0805d9e056e2d11ba85d9b196526f4d8ddb5f1cb0a9177fc76bc8d4419ca81afdd9bb65810ce7df8f386bff2d82f40b8c48212d2c859d40428c6975168c44212a89f15c39ab2ec14c06cec303f0a525e1868069d80384df862f66800684cb8088cd5cde7f4b165700ad02e63c210d840e56d24e6f9b3d32f2eb966f78002c8591012f905befef4f32964c82fcb1958b2d5a3a99d2188a523378e72b145577968f7abab339123d336a9186d7ee2afdd40b3da48bd77320970adc13251bc32df8c49639379ed99a0b0ecb60145bfb3e7730253fcc823c5b6153998322913f838ce61889a980cc716a59ce7cab3a1720ca94df9b353e6038209ef7f035bdab798ee7e37778ce732743a797349df867ccce0852d432cfe199f20b336361fca62f9e0630885e2fc3d94d216a49db15232677382a077aec38c769f93388d08dcc04c25cd0429486fa10294780699407ea60b1230647ca8cc94295477443c31b72a6e1cb8f014406d53c57d233b6b5376adccca1aa0c5be1f05849a99eaebb569ca9c11344a6e8f5f6a0654ccf15f3e088394f6e66e93f461d7f77ae09a65eea2601603524be9dcb3fe310213d43f85d064f7bdf1fba4743e337b396611c1df6b2a3764c340147f4809a96f712b66612a76b6a4eda233380960f3895a8b330b92d5403b88e84c1b0adac02e321cfe7505f2fd045c1bc9f07afa5419812320016462e2edb5ff15aa583a118068b72a3998fc488226c29050063adcf0e5a322376780c5b59eb9bd316997d3901ca8427feea89c276470357980b6f953f8cd291ec423a81c2c5799a3769068c26b76150cb635ef846375e13f85621a2e028fc395da70063ec19e88aa58420d029d6e9e1458438cec70acb159a720e8c0d53cf5022f7a7387affbd4854b1c683ce1951e544805723619dc79d51d2bb4087e6fbc59d7b5855ce51e5c604e058ec18bb564837643d40ba879bbae6e45f065badf17cd096bf03e38baba97737d9d63d82d010be34ae49c312796e34f31568161ebc54982c184a723c40cdd0caf95a75c662e35f3a66f8ecb95cc1a535fcadb1e9a1aef9a21993667f72b8a77631bb56feb86e8fa15d90182acc0e1a7324555072ba01cea71d8183edff91472aafac23740afb92e058f38a0bd2e260479926d7d34ebad949ce7c59a9f05b908743de0b180df402fb2da5562b666ebd8ea7913c00861e1f52546de2948eb43d177a68527887be6abc96f7ca41ebf0c80b60877dc4ffed97e0589f8b326e9b2d9ea5a26203e86e9ac98e52f864cb37cb13595ab7d3984b063e22e9a2966d84285aa4f6a907312047e192f4da795b0f5586545e43ff7a3990d78e69b7875058aca2b12a121cd9895af5756280d8c822b094515f52035706e752f0c2f01e50af02dcf9ec4dcd4cc3f17cafd32e369bc5e5af9da088b4a68e7f78443a73794e8d30b9ff369e8d4b66ed1dca3c6e499aee5f5e734b3d4897cb26c1cb1b4b54d8aa36ffe42751dd97490bccca682f6cacfe6578d4ba90c08cb18125773ae5cc78179c9953b8b4d1e87a1faa580fb31c0dec2380ad31422f7b7c9ac15816b4d9d12198814edb5cda6c6a9183b304df83f73bd3cd6162ce088681f901db8a06b5e954283ced712ad3c953eb2191a048db51f51159f331e7f7a324092e4cee78ecf23db9e792ae6ae9f1c719027606b4b133383e380c3b2fb9db908e13e17cffee2033b2489801ad75f97f5770fd45f032295ac8dc0a297452af70d8f7fb877fe9f09dc8d1de01c1c729306d6cb6c0615998c36c32966b50d5f7789bcf0ceaaa6ae6f55358ed40aced2a61d2bc933165003440dd23609aad1e1fd665f03610a4db9f99fb40f926fe40c8067dc08b5a45790fc29bf9fc1c4a8e5869156031055378dc23822d78161b1cdc1b8944d8ebf43468a0263d61ee54f666e2632ab09d1b5763a87c53c41b92f7cb2622e939d00ad69cc9f65106c1659d79344db7a220ab1fd2ae91f933fddb27c0ab720b476af341905afcf19f609edbbd52cb27dc82a129f15770186e988c00fe0c2ad752cea8d7802c2a95fa6cc63b7526c8ba305aee79e62f86fdffd9c572f53cbf661474cb0297f6eeca5793452677c7c67b5af1dbb91fa277dd3acd3679872e98b88c2f6dd456db530f1646a14f95c7fe3a8d3fcd5e9a9d66826af070491636f0d0f9d6c485a5adaa5215f8e36eef7b2d96d23f7b329e94aff163d48090fc76ac9ca56f06eca2f5862b5c7a8013abdcf36c923095fbc27a485047d6b07248f611fa238e5cc306e7b0078f91ac271e35e9e198cd1d7bcf872817cb431585606c5a1ed70f0f8410bfe58c4378205db05307cad69ff3c08d8457cfc339f57d429b8977ec6269becf9dc9598a00f39dd750f5140253bf2fd9649c1af348c0aa3d31ae38e4713f162d43e90869a9ead240b3222bc64df7d3cdeb7fcb5eac4139b03cd0a3d79c0867487347ad03a0baaa6de3c73147404957f7c6cb51430a4e719fb5e9d4fc1fddf28c638a6af204e9f362d56c666b093f1443408d93b96dd00b1909ac72624cdb864020dfaac23c92ea987ce98397387953c4d377e4b91501cf5ae4572dbbd9114d4ee1266942bc9c42c20f7618649421b06766da1edbc1429a05e3ea7a3e6993a12506423466f03760969012da4a49962b9f873e8ef8ac1655b816464e386e0f497936408e07383bd2c418126cc123bb730d54793b680fb19075e2f4af81b8e890acbcd0ba1aeb8ff2e37668e2dfe0ff2ecbd9ec182c6ef8982ff62ecbd46e2c6a57d5d905f43c12d897ebf9a6a011c0ea4edbe4a99b5b0bc14720da8b8d0659046691df6ed5015ca831936d21dac2a87148bbb78fb5d67ba8ed42caf49bec0e13bfde3a1911fc367f8b66d25ed3c05341834371c89815f456f357643eb0e27d007cd214396fead6e3103df490c9a4aaecc977acc42fea00ec1a9743f3132330ad111a6797dd8124d66f960bd861056ad4b3072d64e9dea146b2c7bdd196213f39a6414ebf91e737fd76c135942c26381a3d5965c95e55b322af74466cab7f047e2a8d28352a9692000f6bdccc8d0203c54f040b55d5215aad622495ad90692371fbe648ea56e518c72255a71c6fbf4a94144add2cfb6bd2fb22b3dfada6872a8bb0d167b2a1cff46b1c0d52207be2043af107fd9dd064ebabbd3cec8950797f2373f847569b8687a6f47ad6ad0c23c1aa67befc60de4912e57125c68121d752f0c5ab792ce25197a557bf1e474481cbb4258321548642b5f5a86164a4e473e9e549d4d0dad6953a2069fbd368e098c92bcb9fc09f9805768d3f3d9bf74e1c0cca3386e5812bfb2315c53f909eb1529fdf12026998de5bb8d8442222dc60c4096c150f0149260408d5b94677626659aa881d973e76ba249ac46f99f14e7dfe79bd8b3deb6d9771476ce3250e9ce68f4a5da805c8c692a54d2ca736a87c975c29999f2b93fddc9dfb9d2b606ca24842a857cf8b15a1319a928300400bbee3dd1571662f28064826a8ad7e0146c5585d4b726f8944b94037014fbdf057431156d6ec7bbc0e5e51d2692b5fef9507076077832c240653c0a7e6211d09b85fcae3644ca673eded47a3d317b4fa5cbfbcb7e4ac0de9c5cee0edbd048a9f08ed82cfe9de5e3e80502e792da27d5dd72ecfae437b4cc25b37124683235091bd899ca3a5cdea3ef759478c57a289533579e4b70c604e21ccf82f2473b6f47dd3fc4a8b853e25a37652459fa08d1741bd492ea8bdcc79bf6a1d9180b26ea9ceb4f65a12820e9b6fb44925cd65a8c0d7a0cd303140d778206556a0cf949bffc359344059cedbe6afec11451eba0ce72f663c5c8a9a9b7c24454eb6805e00b54a6f5326a662d5f7117b4ee49aad21c1cc79ebb942537d6ca39615a898970150d5a08f72e811b8a268b69be0b62b827d22edbee7d95c4aa7b7771a7ff8ef429f6bcd97b4cf3c80f0ac113599054a59c274642d4f86eec86d64e368c0f22974ca9fef7cca8cce4ac188480eee9d8a90567981b141874cdf525eede294bd0c02bc6020d84d980e8043fd2112a393c7f75e247dbfe9620a28d4284742020a46638019f62c06d23e9e83efb1b5a0b294ed267dafecdbd11b3845e1ac7a9cde218775809e9f99f0724e630a0f094e2083fee1d02b59df003a0ac33ee8bc20b9d6822a8a00b287b5c9a0bb59990d9837727af2af122d4ec9ad5101c025dd6f49bf2826ad0dcb170764f414f95d288fca08a911b25716f9f5cec7d0f4214b0f04a7ba233f07aecbd9d0c07da12aa00457b842305a488a38d9261fa139d7546d440bea947b4d2daa96c0c46675feddfacc6551a86e90f4e8a8a7c9b10ebefd64bbf9f43795e4aa04a0d456ac01bc77beee4220465c387e982da139ee436e00178c606039830f03d4b49397762cdc1b804bd09bb7562993cee15637a5ebb5f1961e6ad9288e3e99d4fa852c3938c606c1dc5b216056abe7f8930d751f7293fc524a8efcd3825b68fd8c5d00a6316905670c86c49faac3310520add1b1b64e321ff2f4a48a189b2670d15e45f62ae79d91547539412a7126713fc0fe795e382798370febf9eb2d88f57926e9b7971d8f2df195e955344d0a425419fa47be285ef7f468696fcb0ddb9582b8d7ed7764bf3784e145c75e000113dd1dca4331fd7849568c52a0e110a6a9795761023325fb5ae1a2a57518c5d0bfff4e6c313ce8148a23788673986461b14d1293972c65c9ed0da9cd206fc27ab0b1f8b6cc34f028ecdd05278421b955812e1e6d97998a71c1f973b66f523a73a207f8c822d52700c8f1b46371ce8a42872926de93a4c46e6fd8f6a92587595f623a97e34230563d515738fc7c943252ecc7e0488e41ba78959735319310fd0eb322be44489fc62cc1eb4f0ac12597d418b53651e91574ce0759dbba354a432c4907cd24d4124c41974f3d357b09706b3c098b46d0ed2173af52549d1040083c6d3e19737181653b448c031e6b5c4d7352afb5cb1cbd62a2644dbec9c6b9731e55bc42f192c5dba9631748a49df2b89eb741f93730158c534ec1f49fe28cd289fcbe2480b3ab92a81ae71b75d697b393eab834e42b2628828741f9efc7b763121712776b121d6780eb7698ca021713856c1f8d781e761108bdad6d58867b4cfe7a7d3615816c518e429afa7fcaed97d5d59daf3b6393a1963bd6755889a37b440661c35c90ce2e95c4256f16957707b94ef77461182c4a5c4c5c95a140de5f8f442698db8466a3275433355b899b5da18fd79e745f857de1ca1e0f49cdf956be25469121caa861bc132ef965866b309cdb23cb705be284edd6ca4c565aaa4169772c7904a027a50439fde8a88ec3f853667a3c3b7546af4f56275e8c1d07fccd6d27be2a0c2acdce9541215ce59ee5f9598a5ebc5bab4636e985d8fcb33c35789ccdc552300d14e41b933137d79d568a87ca280b84ef993801250b7d0e36e4474f41a783a9094779f9d69b51af27f962dfd8b532b1996a203443deb795ca8a88674c7b477de169d41f12500f5417f67511f859c6322bada2f74165eaf3aedb319c63e5471fb69d8712c4fe625935bc0da4073bd2129e11cc87390042f6b464e48275e76d9718bfc129b2f5b2791461d9d82b67f1e402bdcec3edf9e8f740db8502a551d1b07b5557a00035cbe8771c01ce6adbf43332163563369a999e87b127ed78f63d49df648e93f8a94b9e559d2d59dbe86b3c32810aa407ee8ad3aa4380df0a283485a0a0e8358d568d8e75d25e71af73f0e92169d69ebbec03aa3c79a54b39d3268ae090e3bbeca8d26cc3cc1bb78ad47eb01410d881d095ce75d8baf62b2dc4d66adb1b4b89dc5b21d18161585f5ee26b43b4ddc38343a6c32adc570aa98ab1e3f5af33f08e56fbb7f4e31f72c4f509677c6e228b4ba4df13e54b4b473b6f809a2c76d7400cca33f1be2eafb7953c5bd9ef93547243894a10aa187d2221bf64aa86de8be1cef4aa104189acf09bfb3f96cda12c571dbfd296f65fb3474cd3ca3361fe16bad56286bb4a5f72f86c4574393f0c0ca56ecf1a871aa36244d43f2e6f9301e8f967c87fd6aaafac50cbbc9e79a55e3d1d226d3b02b315b50f0ab2c8f34d38f621377cb240509a53b938ea8d22f41d7ee74d1bb7c4ff1b1794da39840c1cab7000e1d987c07a712813d43cc5fc9d12aece0878fd366160e03958c113128569b540c11b7d65857dee786900ab4a820db1258bd18ac9184cf72a6b6fdd5e962594a35ed5f0d8f1d757fb42c8608436000a487542236a441de1e7b959aa1fa65aee31a61bf2af84621b8f7a4c9afed48d9fa3fb5f255fea30093232dcaf6577e3456ab94b06888c4db95f0393694097ea43874d70d1344bf240545b518a64dc094a8cc806cb442be6da8491996aeee1bbb8931bb40259f48637903aad7533a1e0790cf741f38d8112aee7bf5aa8026dbfb7b8ab308a3356255ba72f6061c066114bd5e667fa133e52da304c35a4a7765b88278c3ffa1e6e5bd2bec2efa4bbf4e772a2c62963ff93a495aa32ff6795619da2dea1a0ebd2ecd53117bac727d83e938ac6d581efbf1d124edf29e6adaf9331f952b2d154cf4cc3e1f0437a08cba898058cc7c878a801f3670f4b651cbce68d1ab0d745dda383c5f0d3faa60fb6a01fa2183e90c14b1fd0ad5d17676a04f2d3ddc6e933b1ae219ab58b27da4739d1180acc195b4fce4e9f41318aefe14dad4c5dbb9f03cd936be94b7c6f5d43731821427893155d907a49f51deac3f1be295d3bbfa8b710d94b24606f77f5c8586bdc492b969f073e1080ac496a04d3d0273055115cf17ea75a3cf413f5441770f6400823a4871984f6ff0d83805aa1c9ee6c9a706e7a7d1b2cc6da29e068cc0848219954d8476c5e445a1c5fc417c38c66d4747403923ac6264403992903b9a3ce403378128882932c575f87f5dae4ea2926a787e4b85f988a773edb7dea0b558e4e755c50131ee4abc9dabf983f173bea1030327496223e6e099642faa57c937dcb1e322bbecf2114998cf87fcd525c5b2ba99e2b6461910c8ed768455d935ff18b0b531811c2f600d8f7dfb200b8b32a6bfcd546d844d180b1e47b67cf02e9acc6985ea0c31fc5cbceaecd23e21286d2d31aade7c081924cb864fa29efbf013837ef7886fda1e098ba1ccb8e63fda77dd0971caae13a6acd367f1dd06e4111f1ca4ee49231ab514169e4936eec5ac56898113788f73a2919442f95dfdf662dea8465266d73e53c7d3ebfeea58bef1fc3479e0216de301318c6875a6f9014e1d0898e910a6599e4a01fe9e2ad3e06e8bd99c77441a922c3e0cbe2848145f91e42fa6473c9876456319fca7a74a6ce074ea3e971f21a5632a3381ca3e7d497313367a994d5a0cecf0bfdc0cb3f90328c9e5ea2bf5f316c209e1b1b32a6b23c0633728762f726c7ff598d03ff0cffaa6e49e248f957920aa9933b6555e56ed8dd65f4e6c56cdabf4b8ac80df74b0c678cd9db072798c18dd0a3397c98790efdc333653da80d95c255d86b43150720f50fc3aa25b8876dd2753f68558304dc1f15178510ae5aff8ea862159a296ec674bc8b66659218a1e8ea92a306b4b1a8a80043c1bbe34a2cc48c1e252569ffc4614e78c66ec7b49856fcd5d81a9f19dbfd0e0fde6c916b2e405a2eb57f6d1a8ebaf7c172e310ecd947e06868a0128db62445e56fa13e521befa7effa1e81948e9888d4eec86c1b2bf0488223cabba06d31e0a065943725bf3f87f009ba41bf8ab0e637577109f4afd904319953568205912dbed514b764820daf798007292c6dc5848552c017ff8fcbf54cda53821d512f9777666afa6c0a00f7a390df79d52fc1176a36e777aac896ad1f193a5cc092ea20deb88775a4c09fb31515867bd1eb18b254d2c360a75eaeb58d421622c7d61f817c556df6cf2f2cb40f82083b2db841b2728d0fc86a09ea3232bbccb7946675a88cdc1938822db0605aeec81c6898e9f996cad3996270dc4cfec0d224cd836fdd42a29137cd160329c91ddb86d6aa94b88daa3474bcfe5dc416140609d81c18b5b1b291a4ff2abfb7ab00de39b60e8a6e76d2eb4202f4062f3b93efe8e0f74326ca1e11adb936f12f32533ab03a70c3b55db3493a3f94b637ae0b2691c33553f0a958d2272224ae7c1e07271c059fc94e4de2e702cd8ab5d96149a2e3e622138009e6f0a16881a59cafd7f5453d66ca70929ab9e8b16e2dd33381c11c844888e48d25dfd4016b16fab6dec82bd219498f8817c8547a6c00c9eedf4ca3e01ddae221ef7683ae3898c90571666ee8eea31c1b2e25d729d480661f321fffaf21593afdf788dcbd306dd78847c5d06f0bd1c4c5a0ca5cf500e38251b4df5ea796c404aaf9f64caa2e556f5841fb00fc825d01be93bf7c9e9e6cf39cf348a8e56d0c301a54135e65ee6b3413c95a7a06c3abd1eff39ef9bcff55fd170ccafa30fe12427126e4856e9d789d2fa33d74d508d154f432849a047f25f18298cd889939efd4d7dedfa5c2093c080476626caa831ebe37ceb7259c217ebeda91226c7c4a661753b584f0f75fc9ccedec8122a259b26aff77632d4c2160e7fdc71a458347bfe6a8a232a69bce2af67916fafa5e22de7f98de981d3fb8ce97236a2ecb311a65bf1edfb2f66d159abad10e36337d742ca932ba44a37913039089294eacde9955e5700a66b98f6ba5897234441837d0f7530b0b5d5aadc377d19c54aec5f13d5c1830cb67f2f0881502bb09ed24a4689b42ac3c75fe4ceddea85330eef4ca06dd5814ef897d9fb200e7a69be6ee16a932db6b226588ffaf4d0f333a1a80ec16f10eaceaf396c450c7291a64f2a0d9df25b45e3d6fb6ca8e25bd8cad9b53cb69f35393350f6e65dec9e405f9f91700cffd5671d0246476413074041c4a8e0b3e4dbf4833df0f2de52d6e203d7b2d99cd4c2bd569d4ff89e146dbe635cb9aab2c7baa9e8014b9eac86084874c18d08f6b6fc580334178a42ba01dc4dc91ce6b7a0a058d545283925a46d611d13f34b4efc4fc50e924e2d09cc344672e1da44f3f87aba67074c12d94052592243e518e8ec493c27db6ecd9ce8a00b5c9cde84271a9c8b034b9d60e801144a1fd52a2afda4cadf1746a5b2381dcb0d45b286809e3429e1ac59369b0eec3a644f5143087f91621081f19e897fdb23f36b9494c450e16828aeeb63a29b559a3a431b4f07c0c83567fb987123c7eaf82812c5f6296599bb0b7a52fa539d87b0186f3d70864942ddd4224fa2b76c9854507e798fc7b578d93b16f3a80b6edf3a14e051a19a3b56ec3ff2d72aa17718fed0728422c9dbcc1b8463e4def189bbb262bb9c62cd05df6218e67b2c71c7fcbf85e2b1bb9c3cde44f68504d0ff3201f5fe0cc5922169e2a46714e40d35033c54c67df852e1c10336048115237c5b3fb80cdc85094f4ee497f601d781da88b81bd10e01be9731cfc43caf5fc9aa252aecbd4eea5e734d6350d3ae12c9f71d236fbb1777f357fb6773a3271da6c5ae9cae666bc2858674b24f5268876b0dc132e444b317dcc1cbcb218f30d31896c55de3519715504ff30e00ac0c1a42c3dd5666b37c6d1a4e783233151d12fce0f8cec9fb6e8158b70be45bb2465c44e4d846ab970e47f7808edfa99f70c28aa6b39ae2f274cad8513e5b4b79154d9f7be4cb7f28bf322a563598c68a884e06cc96436be755336a34c4b1db9ff637b0630ea64e7c90893bc45e426874e4078aaa293fb7ac3deb55d0187050094b9748cd6bc9ea49df7c50f4e0512eb925c305da1dfc72997c37703e8f1c384f3e7fa31bf20973c6f6cea36e6279896134974037db4b5eb65d4e27de0dd1a024a1c8207f5bb004c91aba987e34feaf1cd996340c6475d36cc13af1ce2d7189aaa005d22529534c09c118cc898cbc401b299937eb31fb9337bc284d0baecec297713bef071f3e84e6e7c6e55d3134e10801f53b79972beaa8fbadd83e41956457c8257d8939a458d941389cf5766b06ebf4005cc13e51ea2c0f088c796b73e0978a7924bda4934aa317eebde9e1c51dd166b132462916c1c3d2e59e271ec5328042add0533c06685e81d21970bc2485155a2f8761bf60b603c3cb365f9d16ff0a98b129e480e5a55c7c93c289a76dc945e7b3f2afaef0a65462cefaa7690572066d1b95fa213fcec25a5e4cf9ebce1482224b5ac83ce5ec970737a7717a5fcea9e3f95f1f652c8e34875066d32b9cc9724e5194e10f82a83f704a693ac78317cfbde2125fdec937558f4ae073c1a1ed99f83b0517d443b25c65bac951ab99c666ad3910aabc15b8b013755e572f229660342acdb635c77e720d990e5419946cc6aae324954f65c3f64c2bd4e80ab2c991556121d5e5965c2852965bd34815534a7fce692ad97a0751a4bcff77a018bc9a0bdc543dd5a0518667b0e8360c5220002baf4ea5ed537a1b7e01ed5a2ac00407a690aea52fee296d4c0fd4ef825e5bce2dd1f6056b2f4c4ad364073a0394f5ab11afe8f1998424d4d151e681c9e3abbda17b5744d7997d82d166f6f0e7d4b8316e695acc5fcd7c15c5ad9b7681452ffeb9f2e2d9e77999bad8de6f6aba365b87c979118ad0d1aa91e14cb8e43eccb84467892711ebac024a3e2b66a4f6f6d22188b33bb0d30a92a23cd9dc146757ee2e1cdc7cedb43953a10eeb69dcc4b3e49628d0b9ba4e84171f1e364cd13d6a3bf889866a456662797a67e2f838bc9373a3d95ee03e0775cd63bb37062bafd20e3e79ab319925f6d6aa6c87d3bc337f31093b8afa07864aca2f3cc174d24bed8bf57fc50032a51b0a690e0759f50c142aa00956dd5edbdcdea7f0a743a14e37932542b613abc141c79ab1275374bec3f74f7860a87f4178a4c6668fba818122d0476371382b60289d14fc29986f11ee34b5270a56d9eb788362f98f5da68a2703303a7edb71a6e52af498621a8a87f7a8c2d600d431d3bcafeaff2d5c439979f0e1e44b2b8b6ef1fa520cfa838cc2ea689a20d1ac5a765426a724b604705801ddf06b6f86bde9525c1deb8c5163a229a321a08fe955fe5e1ddcd63ac636dc2f969f112ba499e3486ebfb4067cee7c8b475ae36e90990787c5412b85b5a0b28d2630a25086f9095541130e18844361437e891295c452cbcf7c4ec41fe9eaece9089a0afab86c2f8732d7cf56474f3690cf66c960efdec707c7244f4b4922ce5f19fbe3b2e36d8b7d186f5b436876310ac1f0e6cbd170d5cd515ae1517dd7606cf6b9659a57564ad1025b101591e3d41a0debd9e701a3c854fdd813a4172005a56b37ac54646c93901bf141669896ea24c9e4c7634578270a10bbeaa27f9dd9d4080f13ea2d1513d78a606606f37b9d5f11f3bcf7f8b57040ea8179b0abeb50dc86b3034f17e3bcacf937ee612758e1edd6538a6c20297ae0f65246934d698827f7b7d0340ceab2ebe9cc72a790f47957c6fc5d5ec19918b6940fe260e0cf731a4f46fd26091c9c7b9669ba328ddf3bce9a60332624ae83c9826b588785d0b325caa538c0e5e1c7a27b7600360b3439df0b4c9e42ae40b574558b84c18cd79fef896e0326bf05d2c88ccf94fdce3969e8b570edbd04ce955090d7c57a0ebc49e3599d4bad6d117ec9df470c2922504acc60bb6335cfec5c1cf8158ba40a7ece03529eb8f04efc1b6b9d20b5f0413ca09ec1f54c3d4c43069062f005570eff307220c9f054302240b3dda8988332536dc96ae69bb9cd9652bd4405527ae473c19b13ea7e6aa0df52b0eafb60cb664d400a65c2bee1c7e92fdf032fb261145efb06bfda598a74e2172bf136478d893543a6307e4954ef0ff9f4542ccdcdf2e5c882b1946d3143dbdd0635667358147c2f99b96c2fa1547616d4fba4fd460a1510fc72e011c7e13bf53c773795cae5a86102fd8c94585f292a18437320366ad1cbcd20aca2a03c048094c74b2e3fa1f9185e9196cba1f305ef0f15477d59258bf9c71e40215fd069f67be6066b50b23b3f59b2819df8b5c3879d4f2cc2caa187cf50ef39ddef0cf6aecc3c02b60083a89cf0cb84483ada606e4395ab0281715d6e084096c71d33a227966720ab3e25a566dd4bc358b18c575dcfc4f8e3000adbfdf0a56a5cddf4a2f63864648a7237b26e10f1e520e4f0e9c67743dcadb0bfef8714fc2e9c109e4e8a115e163a1413921d3fa694badc5bb48efa542b28d909a4927b4e286cfb362702f60f683cc30d192216b3f4a72abf6648edf0ff5faaed84ea15cb57176c26bf07abc5c628e1f69a48b665cb67df5b77a14a24cd29173af2bfb4aaf4af79c408d4614fc087d9b997d17b8c69e37a293364c445be446e4407c676404aea2606eee1f60c675178fcd059027be67f1747e9ec2fac3f4ad86d0bcc7408b558752e73f50ffb1d889fa1e6c5a4bf3de252b9f7553bee05f2e90904a49bf85911d78ffaebb3a5876b84cfc4a96e7f9d229868484c3e1a04a3aa46daa1ca09ced8ca411e4e07d0d3c0eb47091dfa7199c4ae6c35c64f821df7c4f0ff95cd2e7b10d340023037289306fd9179a20458e57448540418b8c41bddd67d45d792af6883aa9c04ad2b8cbfec0e73bb99eade831909b3f93d554575d46e91b555a7150ee928bc1adb57617355c9342671fb5bb4240d348aa713c92529836d019343da126f68a4774ff3285c7d6a6611c494d0a06903eb41e0ced4c4d3691891d752b77d26682cd9265c2c6b59b13e8bc8a1277d72556a4b24c629b7d074f1d6c1a223f6d895d84b7a90573f0b510d0516e148356f31c32a2ee617ddb6c80d0d864fdf0c350d8916b5604b7c7396bb867d76cbbfea0bc80e11d4dec0819d0baa007935fa08ccaa1e74dec4a7cdc9fa5e722b5ce43e6c2cf755c24e2bb7b50a12c38b0c0964400ae0d68068f2823fcfb61cbf7c088b83fdb72c6a0c815ac0738aca91c5e6d69e75c15ce22415a3f4361c152c6dd1dac039acf6c6fd27b6747e272dfee0c75150971","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
