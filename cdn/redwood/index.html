<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"acd7ae94afe98b97c0a743d1693335c07455250bf4befed1da08cd1965ea22bbed0a538dc02e78ba9a063b579b1f72cf6d2d887d513a58fb05031021750eaadac133e60bf974463d867b50586fa476eb79be4cee9718e8f33fe3237c5caa12a6ba1afd2f1a9f55f958b931d31e3e7277277abd6b104374af8c083d0cf263adb8bdd9301fe221fe6d2d81d9777aa747386df9fe0dbe8274c97a54274db7ecfc6831582867b243ec74cc21627956003c3c47398d6e4818d8d2abb778b76d485767c00fb7da500c4ac5a83d4c8306ccf9b48f6a906958d58fa969bee3735fd042309fa0f2d3e402844c9ec27c2b37b5c483fbb704ec32b0d284d9d19094a19f4505953809a3ccbc0d00ce3360ea1a2176eb4712607169cd39db067a8bc468cdc33e6a64134f83d7f853319b790c5b79d3ea62b8e4bec35c1dbe071742b3ced34ff4604da0dbf90a16083477631ff26e24efa456d439857cef21288c1df6cd8938013a05f7baca6bcaac6bbfd95a32765ec5f84cedd80e24d05f26ba262a4e0d3dc5ec2b8d0855b9a51cfc2e009dd562a868696dd2ead36c907e223d497b5aeca5bfeb1a72c7c3829e7eaa5bc59ae06ffe0f4b81a0e4c052993bca73fe00c2dc10c86c7d40dc5480304c766c9f51f9b4ed31338d15ee88502847b0fceb6e496eb0be6b90a600be3e07ca397c9dba02ec727dcf66482cc5db45ef7ccd93afa00cd00e9df4521183004a78776ec168ae54a47c4f3d06bfb43c41b0f3e69bfa20c2ccca87623f4697bfeaaa84b749ca2053e9d6ab01a14976c686bf51d400d095482fd3f17bbb87fd4c80dfad652d2cbe57ed5798ab21e8f0995575c28469e92feac0b517ce052c96de10be5bf342031d104f6845317a0a671d3a5b74d07ea21702fc08afe9b986d3b0263e0fac215bac416044810d4adabebdd6244431ef6c86295b7d1939dbcf83af5c1a61d5660b8d90fb0a20efb5f296e5381bfc6df8f44ac29fcb3ca05a1eb3468196aa78c3ed0c574380bac18ade0172b1ce0ffbd086c12074ab4d522de7013f6aca3ae17f5622e94a44320a1e236fa59f6e955a9e99ceb6a8913b7e9a2ab35de07f6cd6623664cce66dbead0a01dfa9a30fcadcf851a7bb7b2dee62ae28db76bdcbf98b7e5edc0ed929d013602a0723061bcabe31b5a43306aeb3ebe5e958b229331832f6072bd08e71c8189ee0e4a521ede0f05d7499a0359b902e4b35b6527589a852c2900ce7e89e6753d75b06058feacb689bc53899b2cbd27a47351f7f7e5024a56a31496e74b109205d4d96edcc55ed0206995a132ab3e81d9c9305aad6cb5265e89fde4c7a1630e97a98639cc798f88169612b92eee79b5ba46d80b74265212b71fc1f165c1856380d6ed866ee0145f601b9764a7b12a62c129688ae15f16294da951e7f49dba5fd2febcf6165727314f3c7177ca925d89541878d8f8f89ef5f97cb7c551100f101f65a5abca1e6cc38e77b7fa2481a34ececce2952e6abd7ca30efb74bbcdce3787ce9c1cc9a735c05cf64523528b1719759c5bceef070cf31b70cdf212f5577fcace741d8c136a4d299be1e407b668cca96f7622f7a8517664f36dd2d8d5101913837f5e3236c2c1d7ded3d44232c388775cce55887592723a145c72c33a0b01284bc433e8d223194ced45c3ee36c01588bcfb86fee57fd31a57296c858b119e147954842511ab3b27903cfdc61d0bc064b55061950c3f38673b71b1d22e5b7cd7175177e3ac610391c05e59a131bc5d24e7197666676347dff50322aca0528fd5949d1ef10624e1bc5fe327135af0b86f4b53c5dca4ef8b5f6104626c582e4fe1cc6a8df3dd208484bb4d834a135895b21c04b9e0183c38ca1ec62c247ec0ad75b8438438a3a5843dd56329e4992876800d02f75064c91361cf9b0c8e17e19f56a08756bfb0a9f71774291c86aed36cd8449d47daf30d4589e4dc851ce2c0970a5c74043e5718cbccd5a7cd01b946cbcea3d3289e5b8be4bfd5d48113838ac120f73ec56e48bbd048f6f08763d16af07b9f8a1db5c8f4ea5682c102fe7c90208839c02666d9e16323b8c02d6d934cb1775862cbf8941f207d49a1f82a0e89bab41c929fa879fd606e209112db795f22ea6d573006e359bd1551e42fd6b6a78596ce1f6fff2222c7868a62a9d782d8b40869ee771efe41f05502262a5e1b88c00d85698763b6475cc6741fadc52058b6539f2dccb484a64cd1d2a0387d1790602c07cd8da797a9819bb9c604d34ad830ad0b11f5428f20a4ec1d937123ce578a705ce9d0fc8b6869063f241ccee2fec8c035b26631a35b7035659d195c651ef0a5b88226cc90fc59ab3256c168fb86994ecc4b4d6667839ba0472af4855885a31e1a20734c8a0d025865936c7dc06d03454b01f4114335f4ae47b8cfb5f4448386b9e7c10bd93c75cac62014992f32d9b55a3a129ebd36a4e99f9749d2784bcf969155151facf33d70910728095e481cc8e181d6f016a128816d1fc46bd4d7c971d08c8e718584d6ec74d34e1a146abe0638c97f25013ee88645961eb5abe8fdbd829a151b958fcea23256440ea91d8adb59e7055cb8e73b27a720bd18d0a77facc38e653ab87e1b74a5915a140202199f043ee2747b4295cb0c2bf6fe468e6c5a7bfd34a9db72653f75748775d1b5f63aa5d8fc0d080a00fa1fa1236d3355b7206b4c17a2a9eb15abe85edc89576d6af42e6329ba827e4fc775fa45b94fe8e659d8299b5a54b4a6c5b67c4831cc498eda8d7ff9d9c796275bde99ba10ed363ca4b3fb87383d26b09e3eed4cdfd8a0a21a38eed381dd3b9a63e28eaff8e3870f40af164024b33f4c8abcfd7c86bbb5abd5127f35c33d07ae8b232ce3c89b92146cda5863153851f42c4fae707d9b80c179ed5344569d8d453125f8374c91ba04b6173c066ca74725dcd45cf69ec1d725e65298410ba2534dc414faf30f038f03de2bdc556e9594784cb3290b49423c7f80dca1fb17226f6f1e96918702fb0c94d41e1e248b64ba699d8f24814eca2e7006be0fe8f5a207c03e3632ea2ec87bea18466873b14be2b9874f2a0b62560f71cef20f7264a6d695f9336469b34e9122fb5bed5e57af3209429740ade68a99cf67382442a24d9db5e9055bd62d2e87ef2a23f2b1f2365abbd34d7b5034f63478fe16e6d9768500991b818f73e273a613b6ee33dda18831d4bc9a8f985eebf2262638be63fd2e4ca398385b2ce69d1d3714fc2f868a5b7cdb947985224787f7f45344d43e8be779624362eadfae5a8833f7ecb43692ef103563b89fe3e32d12520d8a95652e8805505ff4567e29cf92e17fa7836c9c13317b89cbcebc88cc94e9876fb674310a271a8b3feb32b9f1bc4d6efa4836c60bbf872a1e8251d2e2adc381043e3771e78530aad4fd29a3169b554b7218d2bcc08f016602161410f1ef5ace09042f9b407956cab8b167437e19cc2c23130ad8eed3f447786260be1894b511b18d460321ffcd0b1abbec0d8940fb6722598aa46c7faaeedb7a75f17a2af7c4356dce6a55fb4d163fd1ae0f9ebf4a75d28c965561290c89b4d92a9e57e8a28cd95a69ef98a11f039d4e5c962eded8df2c94c1e744edd48d6bcbd6e1f8ba8a50427f06e4ae89865412eda1cb89264f370e373df31990635b8b8ac3907adec5482e647411955b07c80dd872407a4d6553dd25b76ea75bba48c4de9ed175f505970d3c9b088c059e31b6993487ec970618d605e173988c3a1de7ec5197b232a6cd9da7a1857badb26e8b702ad548ff889128ee68cea4af4bd33b2ab03c28bf2a51e50e32212cf01a4c03498c401540b10e1a88f9ae6e57821e7640f73e91d9f7fc2d5dd33193d6c18102974ae9d99f55e3fe3403986f2d94fffa54443aea593d0130454c005b178325d66c91765581ef6b55db531f856f3b082c0a23eb1eb4f39c12165a027fe5c03027fc0c6760cde4c43766eaef08ee8c8a1a4d029d20bdffbed4d838dccb1f59a2f0dd7db67396c8160de05e2add705feacd6b9ca5e4a231692b9527beb6be01b3db0e7955698275c815416ed775fdd26032765e9f22ecd3336abeb434128af84a1ded85799d080c53e0d679b8f0b47e8b3bace2af789a1eeefe677854a604e2951e91e0a39e4925975224aab2220b0894c07428f43e7524726fcfe77f4d1695a262e792a52de9819f8e5eb4052cfa7d6928df690a5082de51f54f269d72906e36c7442867ff2b4644873523b1f4a97fe7413cd4dc381b4bdc39f07e81843086e02b2c7b51ad90ea2c5808a907fed7dd5a1f3d358508a0b825d26c6060741de25da65204e8cfaf6df7568300372bcba0791f279026086964d8f712da6a2d3a693090c8b130a77d1a8e5bac611c8024cdc31bb7eeaacc91023bc93fa9ee4305abf67848cc0d93f96b1cf4968cb42cb20307f228755f12e6a0f9cc4b5a14e22f32d2d928397ad4bbea23a261deed2138377145230db19f7f9bcf535a017e5c636c26dedbda05a14f8de1075b4f1eddf9844b45ed85601987dcfbac3b0aea998f3aa0f9192ccca201ea75364a0775e22be06364a2f866e003a91640c860ecdc0d74248e33e0338c893c71f52cb409cf96a2f5db4056bd4782a112bf13c9c41d872faf23f194a0799106648989f8fce4b25e66fe0ae2071e82a86aa5ad38253d7d9336f0891f22bfac577c3e64c06ea3474517dbf2413fa5227614fbd6bb88cbfadd47bc4e86c46bc3e22df29c4e6bf3b9bdbe3ec15b862a538b44d87328842c09cede776211324aba6124db2d04eeec8c5ce79e1948b524809874fbcf13daa8a8bce6b88a7185fd6a3f4a6af43bd3f94f61c260330cd28f3561ec5b6a57f673f96e1f4afb213068561cbd57ec05d028a3e41e6b80260845db2d9e6784658c0e51f2bd65d32042413f4c3a39f3b2b743eab6e8c86f699838a9b8dbbe966367d7b781faf50b66636065bdbef4c940be0a1022bff31ab8b04afb6e9ac6f6406b6777e8dcf605ae311d956b74653a3100d09816d27f8387345310878466a1f8dfc8ad4c72d6d0606d6955fc6a4bca810b7df4de47c60267b2ae04dd3e258ef45530fa92a24962d7a8df32d2d9fc4c6c9b88496bfe78412ce26cd4d51cc2e7f551cf80fee9ab90c98733441c27cee31c3b1daa931b67ba8214975d8626428038b5b322198fb1f4197c92195e551be82e2806a081e27c85a48b09be32b2c0c93a4073828f5580face4cadff1962cbbc16c9f6096e2142ce9b0835e76beef675544ac6050f3d8d6bfce51b1d93bfd08f9561f2aa54e6c3ceaec14121b4810d1ba4d54187476f75bc90df338b4618673283ab06f3c57a44f652cffb711b86473f2c1a0b4c59a4cd9201e16fbff478cc8ec04f912c048b467eb6cb2eb4bb5f3935eb8851968e1d0412f8ba560900e77f3786fa193c132a00bbcccf8f220b4add7c50b2c2629c2cee5576b200967f47fa78e75be570500672ed3a6ed00ab8e9cd0522e89e8cf841236ac918273fbab3e48baf6238280c78f05288dd05b6980d62a7ff1510c27b9556e4dc3ff7c321570b8ef3c010dcbd7a875e82864308e3a295786390f14c3676441de69ed0446dad0aeaaff503528c8e6b54870fb59177856397e782e2423794b976b22c5cb1eb84d052e70db5e198c9df1be0736c49631c16be3f8e98e2b4485309e3aa6a6c30419ae769778e9dc50bc485797b6f2b92e4178cfa81039e82faa2458b957fbf7f46de50a1afd20ff0c86391bb541dc3875e088034b740f8af66a9e4b580fa931535726bd5b69c6dca0ca8ebf6ddc71d51e62deecf357c0c50412558e210308a1d94222e2988f869dea319e7eaf6b662eb3f368834d3cde7d10d9d7ad588984b56682a448cd4c842ef486bd4563fb85bdf5763061dc968a1358e5fae6a9f882122ace6e295e6106eb7d2ad0fe27036cfb6e710e301e2c1f781679c5ad5ec0434fd1f3de12a629cfafd70c77df4f4f44834b3e3a92ec50701c9b2fef82e6599561575e257a9bd94c9e9666b67001d18819757d5b55321cc78dfe5824c62a8337ce2fbd1c348218dcabb2fcf4dbc05b36ee9da319101334cc7a052f91d96277af0aed65faa60c145946db9b558142015b81c3a94ea6fddbc45e529cef23e3d4daa2e44c61ae12a1841daa2e58495710b4ed493c403d610d77002c7f1be839f29092aaaf07d1d4cd71dc957f5a9005fb00e638ec320911cc58d4869c582b4567afcff99735cf7697de2230cdac468d7919daad52e901787b8b6b4ac91b88e4168b3b23a627408d0c816704498e49acd16cff9647e6f7e8b240e0db3134d7a35d40c03811d1390001149501ddd3aa15974ca79f981849783bb011779a6091de2ae645cec38252f258962527aa0cf0be076ac1573ffbaf03404bd07cb8a81c460e48c27988af57388b11dde56eef3afea52abbd399f897a8e1b663311da8ae757095702e960c1a3913654e11db12e82fbd14cdc653047410f16e6ad1f5cc025db8390ae38e8be4da57c0e301183b8808e7a7ee93cf9ece67d3873223199b4c666bd9a2802b53dcec325f981bb70d452e5a485c0757c04413190ed08de26c09e2b3b534e649389291b2951e465330be684d1a53a692090116542687bea1920b197b00c3d96b21d5dce0856020fcb7ba471360ab50747188e9a0af210e82ea417c318a9054f765e85369bd9e39d0ddebd568e3f4de0e4085c0948e701956c57382124e20bdc5b565f8c49e118da25b0647db7f050125b2aa2fecb22184e01e4565e64297e5a3afabc3dcd9c700a526dca05914478f27fc128470556aa409e30555bd029a99950b057f45a88933cc58f030ccb16438b223f5fee1b3777bd184f31cb4f7894e80f4442063af688958bbf10f097790bb9681e6f100b7c2aaac032425639dd419b34c3ab297ed84bff4cd7eb3121421a176b49aff4b169dbba489a9e7b37e99562ffb9d60be55fc07cb0b73eba59b46e8b8358e007c3aca855e2f44de7ebe261f91832e3555f06b9fb6be569f377acda684de9913dc9d7990b0d68365a2a37740ce7973b013ccc42dbfe133182db644c1827bfb1ffef741106b5035298a7e13ee1751d6d18da336aa99b1213edaa114d4d98d77f8d92e3c672f87139e09c897d2a273eaf0d007d2d04a2b5c496bdcc2182bb235398f107f45d7f8529792f45dca9d619928d72511ad5b224c8d1a307cb3ec5ae7837745f0b8418461a4216e7584f8d992b21c2ea9ff0a5522a72e5d5218523dffe1d363c39c366c8056aa0a10922d73a36d1251852b71a263081a4b5a6780c6035d90c0456d8c983626076d3df086af64ae11aee9844f7cb36ea7ff81b567b405acdb68d8d34c17555c34431bf3afa53ef6cabb54dcd42be0932fba3404f299755d798213cfcb11839e0f9332ed09e49078bda0d45162fb1bf2399e5a780f65e587aca5e83e11056312d61ca29cc07053ae06f98923a6c7b5844462aa5c22fa8147c83a022df3989a831907d35cb1ce7bb383a5a5ef35bb922c0eecbbece3025d9495c7a96a2f9f9d530d18a14f9bef04cc070580188cb0015e8be430f1d937031b275e60bca0136ceb3367cdc3237b68a0224ad193d3b8c7f7d37a8f607db27c9dc5e3a3705e91de1526c933ab20efc1b59b71c6580cecc7acc1d8850b827ddbb10a05cf59f25ebf74978bec5e60eb5177c438723279ef75aef21a28c644fa9b1f08d133f99659003f8e329951bad00ec6f33e42d2aaecb328411bb89029a022b924866dde290308bb2507b1ba5ea4fef4ff4ed1367ffffd2c5b20b3c28c333686fba30d802ea4ac7a1c37dcb9dd4168b08d60f09b48efd3d33f6e1e2f92ba9fd10002c1701f812553483849686e67fbaf1092cb447258495e4e7efa72d400823ab9fcea708d5dc65d85470486b8209dd5e446a882b8921732268aa7f55dfd5856746d810e6c7f11e47f3e8b7c7703a7a187d54a6429af10290e2d9c197b8d8011078f771871071de93e80aa25f62fa6f70683078dd6e6d1202aeaa6faa186cc8b228d7ef8d739522b2ee910171d3d28932f59c520ac9389264cad354c9da916f95f67f04abc6432f8f7174ccd9a2a7a2e868d29d7cdb737588929ca4369232af9d42454d5f28f55cc6d8577262e4c9da4a9d0374aaf268a32ae515ccfc4e2e4c308dafab7607cfa39dcc8cc7d44a92240efd7d872c90452ed5813dac7c4dfacfed979be1d71269cc361b0b9cf4a2992b6eeb4f3c8fbc36e78515189d6d976e3e27067833b5cde88f71de1fd635d63bc5e620037a69d28040fd966d997400ddd5888714c56c429ca4ea508b3899aeba6506edb29e19d54b6c10aca69a1ed1ceced2e32b6f292cd24054e5edb907bee8c545cb3fdf425e7a18c9611594eb5dd2c0521b6e762d8fa6cc4b9f93c24a71985094e53f32b0998c6a6c18e4f21cf0469b72e1653610eb469e12ec5b5d7c6ed88e1caf64d8f4058433f205815509c78ec6dc2af37bc6a5c441a5097d62f93a3ca82e4ff2e89f568e05d6006cfb257a00dbe7537b28f14c1be78e41e8ae4d30628c50bb13c436d0e48170a0db622b2890812b56100558a82077f1b380b1036f24a701a4092185872260ca0dd2f5626a7bd4c993b34671e9ddff8f2d7f333643e748d45e965d3ebf7c5eafe3c0c7b6b4e2dd8db4e38ecb207499eb69ac65d1f4c823fa253483aa395d583c90fc5bcdfdf7e792a770cf09ce5f450e3adf3192a1c1b19ce9f5f82ddd9c69d0f7d83a86cb64015c702c8979d8def3f97b79d8fb520b0d3383de32272bf38cd16e902ac8da7e6d48949b36c8928c440b2e16f68e14f7417d1936b52a16df80ef479a19d610da7a4cc2023e68a1fd8c8760805feca7f65944a5eb92a407de973592bd61aa4fb83e231e0513deb6a3b81899b953806f3863040c4b88312d229fbb20c69bd07297bb7dddb3b6b45268b2dba0f55050c10bfcddcf339884e565cac822d8ef87040417214a8ffb55e9ee3a29a9f0f6e334f288ecac700672f0095d94a7dc9e070481cdb08ddbf8dbd304479618f603837ab850262522fefe1560d1496870fde3d5d914787123fe31deca853c912e8da04cd8d76a07067ddcb95966f8f2a6b4c694aef0924432ca97a13c84cfd4e5c432aa3f862953ee03da960edb9402ffa95c43cd98258934f03fff322eec896576e3ed61cd0f8494b699d3e915ef2992cbba55cdb99aaf9ef62ec7b716dc193c220356262474074aee279869773e0cda9ff8e1da3c1acca10f6650a4c1fe60eb3c383898add13c6ebf7f8cbec6d20e912b61ec5a12fa41ad0b5b77b331da1aaedb53b7304ea6aabf87144278f0edd3a5b09a0e1b13766ed9c2e12fa767307a413c0d1893154cb3cc0c06a16975c7dc336c733f11f748736d54cdf36463326d8170c5c8cf32ebfbdf8f600a67aa6fc69808673bcfdf4061e1a0e1a0dc6f9ba456d26fb2eebc9942da8d45969e697c88cc0d7e48c991f3bf53f1baf2d1c3ea3369be4171ae8773fca9bd1130fdc8118b7cefc448ea1a51763692ce7f61139db5bca27dc05588a58ef7203e621489a678dbb94562cc60c2a2120153a19767879228fbf574cd9c253e4a2815eec954e164d3005796dbbb6930b7e9b41b9cc8c1985cd94f9728c5e25d0254e08d9897323095bec799e8f73583500eeb4c53964b6ee08a095db86ab5a58af3f6234b86570a8f40b21f0a2485dfac697e4fb7cbaf95a7b6596f4808bcc950f5d359cea3b4f22dc3d41be87ed8e5936eeefe5532646900c48d61e38928fe6ef2fb32de8597e0730a8d907ac4c976af924be1989617e4a7e649aaa1b9ed1a6b3303accebdd74b4b09cf5674590fadad27d68935c9864572eaccf47f53151b9522ab6f8eb76df900fc3917b9a6211550a55b1ca6232fd1f4f9f6cacfc0a71bae3cf753d4bc63984403c30ef46f9e99f819e864bad7517756fe668cd7f1704d0ef571943c361b04a5570b8d24a0f7f11f7b7cf2230817edff5fae823752bbae56f0cc8409f78cc2b08e258955927538ff83a72bf3e5089d7eb414339e0408e5fdf0a140c47c3de83bfc6202dc6259ede7cbae5829d0bbe0bc94496bfee2d335e0bded58b0fd2e5a034c9e57cfc2ae46f5e0e814b359ac5eb2f6cba66e23c5c0e826f8468701bf3f309045b42864d2a360181e45e93fd3480eee154a88e834d06a52507b467a94e144bd099fe0631e55f410f069ae3f508084025981bef00c803384230ac6f3fa5b2bbaee4c77cb61e6d307af66227d23d20dc3b170e1d89215a44f82cd829ccc2b08e7ade6f5526c60d981600488d8f94f81e3446dcbb87d880c8a1cb24fc3f4e6f48b37455d7e442041d70663cf8329ba41917b3c7db73a1cc454098fbea6932bded3e1f55e9cfc5458fe5ee77d512dd475237e8eba7ebbb216e8f952c7286f08a79e9d8e9ffd0a659ff7758d53d0c0f109e443dfe9c2a97d866bc70be002984256498308450b20fdb7a69a0bfd4faf95817ccaee0e5009576627bee5b80a72f2189da4e1a987af8b7363ea1a6b4a8993b5fef9c8cba454ed62b60483f09888403f895b5c9d6ba550a0538567223487520244d194ddac336049b54fae8f7b4ed76294ee2b8c89d78d2d8786f270bb0629d514f1982b27f9b134d0c756947830f37491d3dc47866cc49963dfd22daf2d7f29fac78690487080f448179dab1f8aed7dc2e575091fa8b663cad78b43a7881615c8ae087b46d1bc9bbda64c84d153eb384d1cb8bb94c953b83cf5e6394a607ef92ac96c3bf7de9264afc0965d0bcec4287359f2d8710af48d8b89e5c41176266d4059720207c7f29241f0148cf18c6d12ef1e73a843f0fc851fc9619af649e3c15db8229b478d20fb610be53fc4105e5a16da2aea8a2fcf78c9fead2171a0df83b8c6be3d3b3cdba359075205ebff8df6e5966fb4ebaef23a75d1ecc1a968b9616b8ba39eb43b3b3dcd9878867475ca895984709e6fe0c3e54b4938cec07567f71f22c9d645ce11f6329384512313e102ee476d9138ae4c9ca9ce551cbe8bda5115433a720d9754410930da4690e35bd00030fbbbfdf0c8f03c11b7a057a64aa717ea6cfebc8360885e599e36df031b20d476d92ca1667b58fc309fbfea362f35ebc66736414b38e1480487bf5eb73375e13aacb027570f1b849d47bd6b19473fbb01f14c4757b2d1d8a4b1d73baabeccf9a68541038c89c3c3fcf32011b3d6a1a5e6832da6b0c956b5070cdb5a35106cbd937eaa11f50cd354f4ce404435d5932b980047a3776e3a9db38b0804d1e6acd6445b3c93b56fae66fe7d7425b9f641ec57570db97d6c02fc8c8773764b4cec096d0318f5be4e57e23ecd22d93ed7a3ccac7336ceaa79452adb27e497b84a1665af0f4bbb08b5899659187bd559970c565e6176cc06679c509941b416e19f6902743aadf5d4f8b1d42aa98d4ce79277b33297fef4ea250f53f47edb0104c72335a760304047b8405195fcff64a83f2cc0d87c93e738e2ffb74738f616e69a25be037e92411e09bf9c7f690fe407503c86f0f7154c637a44917a8d738cfb804cef806c276cdf24b81b8f7833e839955b0315c264b39588ec6061680316ca73e1345d631144b352350069fa9dc31809dbe457cd2a7deaffacb98a1c5a226af4cef9d96050a64e53025c8a22f20a5a82df08dd0ffa82795410b114b35552641119cfc9b803e92086cc258e7b69606b990966e59d7bf42cb1075794cc136c4ad9cedbb84f579e59f7950911048c0254d40a53c3289461631f1c477ae6366b1f1ee301d6370fc1922cafd81fb28bef8a5b18f318fe66dd64c745a8cb25761c9d8c3977ef997f1b50b6d9a9f3af5738b8c215d7906417f79ca9b34af2d7c2ca0eaa2bd1102db2b6662ac7425fd2b53596082eefe4448a98d058cab6f8e40acb2147d33ebcf8f239ba5941985843a43134ba12d156eeed738a38e5ade73b21dd8436177346ccd3a54ffb8fc8ae15dc58cf92c65912de496151e9ffd769e61373e5b0679c03ba55db47efd22e8728e5da9f6a2eb1a3f597b4fe835e7d4c13d6556807b0696d0700efca435eebf6c87a22c6ec2811a769c54160b0bd7f1e3339810a061b94137e909618066b1df49236f5edcfb5eb1f5c4a55178e1756edb468be526b268db4ec5c3dcccc1ecf8737e4a50527f60df1a4f1c7d05cb2573c7accc9bc107d0ad6947710d28bc060532672a3d949d3d522ac3bf5eda088e4ba703a35966273a88465882ed8af776408db570e817c27c903e2e85c1342f2306810aedbddc93c606359f92e6c3408d5dd95f6cc03163a2cc9406cb6737b08a4506549640f74ff287b7c41d9d69182e2abb7d8736ee89961d23fb2c3b9ad3f52907e83cca3d24bc531bfbd8480ca05a64372ed8b35ba5877e8f9463c1d61ad98e0af4ff70bc24e5cb0533387605633fc39b61c3cefb63e8117fbd97a5a04591cd773f0af1218ce007b4f502a43aa5c3333cf8acede6a6703afbf282d3eb1cdd136e056293a026ef6046ea85eb8ef80a9bcaa1e1969ab3e5e6027dc9be278e20030818fe945ad03e4ba6f8459f3c46489f55fa6fe96d33e4cf0df629db3ed8a4d812f50c28e37091b36044233662f1ddae1b0e2d9e6190ff25d903806ef32a9aee6a3bc506dbd318c9c0549ff09a288ca7ed492908038d1ecb63f1da2fe1e4e3467951da4b9e63eebb97cc6f8e2911ec2df5e05b6713a7c7c80827a991909337869a6cbf7ef38abade248d8b3560c5f1675eb0ba52a0494b0dc17ec6cb5c7bbee6cd746e05126dfe01a948c1ee405f30b13adbc9b95b84a38f48d61bba2e05e981a7f18a4ba4aa90de74644605facd04e5a0b0788d490599caedeccce09545890abaf53c8e8574823ff7cae035f89eba5fbf3fc8851a1a32c7432c6f354e1019a4272c7a8c6443aaadfe662f655d1e6f44dc9212cad28479cc02bb44c4c0b1967e392d1a59d8fe9a9f1737ba5d04788d6868c9f35718621eaa8c2ad20d1e284e979c4e64fa8d7078a5a5eb549020cf47a8318fb9c5bf31597347d4d6b8dcfb951c7e0949ae6a5b80e1e84aa84cd199ff6e67188f55f958581f5f4ccc3afc91e8e29cd0de38e894fa6acbe5487366c3c60f1acf57710096f07f31b8bb788732d23e9e7e09c5b5e4f862af992925bb61ff66dd2c5be2e935e0741396ea7fdfbf6cc437c6a254d2afedea824b85b4bc93cc5ced77d47b93419105ef884ab9b8f2cd1f1235ec9c77bea7b6590b1b317efa83bfc1d7796e39815ca8fc182bea194a0817fade648bade4a9cd27f60b69b208428dad4e5ae618bf5b1003af4b4643bc613b90995e32d28f147746fa5084f8584f3783e18c5be500ff837d6746ff0264c427e4d6d3eb74d5624086ad2138b81031a295e4dce0dcff7bd24bb3ea6e09eb8d3b076533f63c047f00c77ac2ea3b3b1d918aca567e768e50a16c9b2ed56836aa8046e691de4bacc04cea43dcc56dd2ac6f541d211b3e9b3492cd57dde878e9a39adae265f79f6938569f6cbf9343f48f6a34b60db7f7e3a4b56da251b7d5454b74c9178b770596fabf4e5e9850a1a86a27fc7af021767da383ba302a7fac6329bc28052e543f8f01b6381e6a908a2f9d51260758015c810fdee6afac1cb6ee77dbc26322770c0aaf706841b96ee6f7f9bac906884dd0a13ffc846e4fdf4c82bcbfde39d19c9eabb3b903df63ce4c33100404326cf0ded1d1568b2e35ff2a910eacc046c13bede9f20f5eeb95d9ae39e907c99406f9894ad9181eac595694af54a98492c3bbd7376ac287bf6fde957e51440eb90d27bfc348e589fabe21e8daa038d302d904212c52472c11325c30884223c9506972dcb6c808e5640684f403374d0c5f75e37fea05174aa5c303ea23c07668ce61da8d2a564b2a501a5e543f64d00298b696cd4e43f05d7ad516fa143346edaba12fcbe48941d23aecd88fa8623735343d29f045397f480124c76085b83a2cb446aba82f6b59ae8417e84f15315c3438decc1d9ceafefcaeff0fe327b55c3f95b6e8d8e42690e83854d86cb095b1c42ed3bb2b5215c151d8b02eb5c867405efeefc143ce62e7ec6ec4965938d0aa42fb0f752b0d0ff310579216f5171e4db2e8e18a4f7d89a126d1dc7fb394e223069f2d954e2ec885918e47543b9db218b2ce1e0f0f7a67aea4580bd55e737af10bac5cc6ec54134abfaf5862b4b56e503db6b8cc2877e54cf386076b85e1325b41c7033475d03268f258c9d6da969c7d41b688dc714d29304d306e824ba9ccd614c5a28cc493846612a5967026ebecbbc9b137acf882ad1bc46653f865a69c334bccf07d8326e3208c6626cdce0dd7fb81b85b1b60f39ace43f0d52240dfd34f3f3a620a2bbb9eddbfa825cf9cdad15b61238a66b7c977da79e9ba0e0cc0639eaef3cd03fd0743c448c38548cecd1ab50c84c8f7c0411d85a646509add8c342c558955bc779a31e8ff8e7beca337964d39ba9dec564e573fd19f87a999d345562f2d057f775b0d1215becdbf39e5bb2525b0f876346ac76af54ca45a47233c84a2f5aedacd197dc2ac19b6c5762634d87676bb999f42ccc339a75df62df941d4b4ad3fa513ffa0c6dc8507478a83bd984e1bb97c4cb9a4798d6c26d602eb4c7bf8c5fd06a629e0ceba87b4024521db1767301f13a37c813e1886d55e1a7d3a2f6c1567d5d57cf177d3f5b1248a04a5560c99e540b5d28f48c2ea709ef43dc38297432b69ee3da3bbe46e9c2d0f5aca3aa0c0fbb8c227174e62088720d88892911f1c64f0f97e2855116ad4bdf67613f69fcc9de38182493c44ab9001bee3856c2f72bdc27a19d3c0b4a1dc0b88ba48232a88570b9fe5502824f74b94c322826df5b11990826cdef8db0b40f6aec2906796c7831b4d5f531694b6f2629edb9cc009cca31dd440173ee7e28be75a4323655ecf250bece66719b3242d469279495f8728ce1e92cc3573270367051d3bb41c6ec7927bb69c4ac1c9cdaabda8e5448a9adae6bbfa9fe31f20cb3dc20cea9f40ef8128e6e934dd93e37744b5e22578e7c9d931f86601900a662b64e45bd3c27ac348050bf36557eb1013feb44a6659a5821504c42a396be040f8e4e813695ba192143e2f83fb820062694599a48e9ce25d5f1dc690c96288828e3846f5106aeb832d403b80ee0d2d6e26e026a3707ca1a3f6b74a282d6f1cf3e8274c9340adc3453c28f03c88ba62c3e30ff2dac10190ebc00f1a3c86345cb829febb850c9949c1b0d7840c598d07bd5ee7b3d5bea9b76b0b6c92a43060d8fb10d889e76b3450c3d6952f738568db47f99e34edb6c9cb89e797f50a9f94696cc457988c03f7285ea43cd246b7a60cfc8628644865faa3bbda2a2305f5a669f81ff5fa3caea608bba7e64dbe1ab6f6303631703da979cbce8f21b3f7654c9fd2c3f798e57fa9e3df8979015e237bba237c3cfc25c2ea2ea3f5a06f640ffe39919d5a796c863579ad9485365ca1d18781d77bcbed3a34bf6153f6cb6419a27822bed020a78a1b2388628d7263ab3b9333b1da865b557f1903edf6bfc5d0411f8c4c04ace18ac52e60ae575e91e3e29051f0fb4f67ebd2e4a15d6661ca7371b8d7d72fa2cc1d8e6c0a2c12a6175557f1b2065dd1113f8127b2873e71f3e0dd46a4f37af79f2489b5951b1c3e5a3446884768c7e2cd4e2133ccb7ea4e31c06bcc9f721d378046e4e8dc93c53bafd58fbd227e5bb9234deb6d9e4d44f9b08af0e0c99e7faa238dfee3406a12e18b5193c3acfe4367b82f2c9850151fdf18ec6d28775fa3aa56e72b00908ba463b869a2a55be43e1fb0d02063cc0476a08def6d85506189d81451cae7568bcae398efa76e321fbd0dbd13074ae0e7b8ee7e3748edf0c8e74b37c9eea2d546401f63549a65b7076a3964da32f609d5641729c3a8d9442e3b5309de4110dc5ec2c8f5d97b5259d862703cac68c0abad0b2ccea4641dee83cb4acf398d5630b2461583e46b178c54399f8df70214f229f3832f5f06a8628ca762b14194d32e436ca6e3315994501641def8a7af532ade3395291328ab5c0279b2792152970e8eb4afa11fc123c65a24e48bc0bfa890fba5cc4727477cecc502bd9dd56a2af9ce488b5bc564a39b4c23970d0cc92a7473bf2ad0ef5075af7a782b61c4bc43771bc99bd482c3533713e6ac1ecf05d9fdce9ece9612211452629a5686e53f9b7db1aae8e96b91f791be3f6f4c46767d4635ed5770b08d1a0f8f976851d08bb23fe55ad5c7f43b192abda8474a39b9b3296c191073a220aba432e19589c8f761ae89ca6dffb3922439c610731a4ab44875e26b2c0bcda4d7a386eebdb6201ccd6d7212e5c30bfe56a57f847597d62310bbb89c9d6c00ed68a7cf8556fb9b5814c6892914ec2172ef237efeaae9bd626c44489c5e8dc86eeca0683eb4dc15b18ddc541a3bd9ea331bd03f25ed5db247be19cb519e9890a69b2d3a1af8bad6e04ce4a062e84db3ee0deda1d7be17c7a9f04edc4fdad789e4589cb265f6e24c0da773d5c99507d144cdcb251b339b87ab9faf3bf25de1ad49fd509c7dfebf1923f461542269c9fe9e1d74d237e6e041093e644d153daa52a66f615b23e15b20ed335d92f0102d70bc3a7aac0302788eb4047918eac209df1579b153f2de96fc8a0b1315a9cf913585f3b44df7a4449a1eadaa453604b87ac50ffd8f60de18537f9cd63889fdb0d14ad6224b2181c43eeb49a02922223f60d94ced56c5a8503678b86d93488c063a4f9bc12d4d1345cf04127adf93a901ccd930cc65706611c000987af37b998cc002a3e3a0c2d337100a43bb9169498168a07ebca90a9224633a89331ca0848bca01525642a23fd386baf4be14cafd376a6a88303b928e813c5889819994440c9f8c283fe5a3d3c3eb96eb32ee1d5771f347ee633eeb80e47478836b5a94178102b6fb3514698b59d2ecd68f9433ab9e08b9af22dc148751d45ae060c5d5d70ac73d64124782d420dfabab98f3012e9355d4eb77a6050b4ff89b2bed54c63bbd028fec6d3e0e08978f0a85812ee1aae02d89c441352fc26cdae4aed29e18336a107aee6ceea6d71e0ef79fcbc2c2b9ff9adce998f891cc094af83c5463b1cac3d2141463b4f2824fbfd02db20afd987905e4747957ca6abc7f2c76fd5c7cd67d16c5477503d5d9c6e211ecccce6f0a55f496b98d29889ee7b26fed553d04e2a61707cd039727708e3a9bc1f92a5485f8c00c21ed656ee69d2b74470b94341f5ef54edc437436a7d6c26761ff46907d4ba855e03029152c783c8185cef095f1998e1f8c5709b5025a5672c9468e6a0caf1ec3f2e353f55c979d259e38a43b10d868811b677497888cd756f541476feace5667f5132237fe728aa6d4e95c6d6f0fe2b21ee77e8abea05cf12672bb19af2c766d3fbc44bccd769691c6b70b94a9e1513a6add0531483464adbc0c0d725756422e8a44429f6d2ba5889aff4485342f0edc2f4ff315f8e6cec27dca30a5856003fcee198516355e98e1138c5d9400eb16f1d2edfbf447bb0b9793f422423ef3c7d8dcbeb9c7ebfb793f7b6350e569ee565b1c7cf831ed5cf629b6ae397b8caee33edf9b658564e3ca6f0c09382137f932778e697d42f223abbed92ebdecc3fa6eba58ceec93d46a6c4c04f36b59f233e6499531075b566402eb76d6a6315b5251e52218d9dee3101859171d38f8dd3290956237c24cd3886615aaade6e1ecae38a280f5cb3eea66e75c63bf629bded63ab98bfa07ba524bde77e599a1b6242c0e1c195163d6cf6c6091cf2d16fb0676a3f6b8cf4915a4b4fa3cc7e8c0d5e07e7d998b513a4fce85e1fbffc46edd3ce61e3b79f9ef1b63831431b7ebd82d873f9c4fba5dbe2f30c8a6108e33fd9b9ae78c4dca112a702693c8f0ff7d355552168fdd63a60e28b1c7160a799a6acdf4cf8850a60a67c0b7276c6900e988b557884e6551c8bcc25690f2706eb34ce42922179dc915e50f504f7582cebcd089ec2b3cd5d5154b29e6cf578e22d6e3b50a11a4051c83a8f903073a3cb7b1df9ca1b51e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
