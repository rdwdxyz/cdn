<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7bd96a5d06cd015d987bd19dac0e29da44e86d9cc9395cb2060f58449dec82f1c9934efa74c5fa2625a72d1fd8150d8c288ddba63feb2c1579f5a819c84be1be19fb5cc7d0b5a23f6693e132109a3582b65bef31096e3fab822b8197d4c59dac46661aa8c1a0c5808313bd945e86af95408e670d18d0d7a432d8e32671db3d68d938c95d7ab713d2820b58ea813c8ea061946508f25fd7e4cef74ba4071e55cbc18ef883773fc8550db9883873b72e4da9b936cb9b5e87fcbd4b7fd487fad9389c4bc154f2f202fae03915e706f34301bb1f3dd2dc48e6d52416eaebeb905258ded3c0ac2edadf8c6131c56cdbcc505c1cc5a6f66a1b679061e49348d9dbbb436961f19a71311eabd7f62b9fc60c41f5c7b7c56fd9c4657738a56ae90b7ff8d3ae8e27c6412ff8d2ad2ed5a5d2a858473013aeada86fc776c7921989ea2bdeb21a614b5915ea033d63069e25600ca9621ec7889b9e6c889cda0014a3fa9b28289adcd1d0022c23b20ffe23d4ca21f7bb61e28a7f6136fe757dbf3067b5486c3347bc1d1b2dcb9c0339085160238ab6e5d7abd75cdb14af68693fed18469181b980a13be2daab8fe2183bdb288e35f09deb30eafe1675807aeb8c1a8270aa66c6bf3c219d91738b643705c61e29930db7fb387bbf38c0b3b0e9dc12835a30492ba920ddfa1eef562bcc6ca03e0832e5454be3e7bc04557fd1582ec2b1a85fcc1dda1b7976ff017408faa913f8bdcdd232ad71acba9776578b767290e3f1d04e9d0fe51c635f76c19398367cbf22361f8daff180eeda91e662975918fc4baade2b32965b1b2d40401f5a53e5169000f7ce467c4ea03b2a052c9fc6a25bf28ef29767cdba4ce7c3d2b0da6bd538494188262c8c6e00159900cb92b0dc10a14592e17395ff7a579d290731d868394ebb5fc3530342173adb7894dab58c4e8e96678a07e79f0daf4b9a82605105573a1b7947a65f82a0e0b22e555b3b622a5ca7ee553c7df5130ab91a60fc2b263310e15dfcfd9a271de62c118e0afdbef8a9813ae8d6571adaad88e81b4e5cf5b2b2ea4c185589b896561be44582540d1ea9bf099c1242664d1bfcdd265c64dcbcbb678d0c45ef644c308c45e3eafc46c998fdb2e0d9c409ca690394a0c6606a3763fdc19e3a24834994f6332b323830d998e3b3d149fb2708dea16c2c21c1e2c33400f80824c78b6a82ecaba6aae5c9fd8f94251c66bdf74fe91c4a0e3636775816190073a2b4d2f795baf295393a6debec8f2f00eb44781f5a7079c6ba5a35c7724778660dc861bb557d7444538724842f480675f2a636a1bd0b47a5bc235d08ba326b17a2770dc6eb5a836a2c1b4b12a97085b1d1ab06c2291095919ea92d5edf4755bcbf901c80cd06925c46492477e7214c89fe95b6847db73a77f96043d465247f6ecd989e389af735b2be8588aa131fba27da85ddc786f235540828550dc434b7b37d2f5da185c486df3c5adafb7e64e4a35f5f6040b60440dc52976635019c4a17f2c5a211a957355dbcb2178bc5bd10b5e87699c66e2cbac458517b0584a22df76c0f048f01a936ff060cc417df25adf013bce5d6ef84c1c084794382f84a5f4cb59af0dc130de68875ee01616a4fd96f555db5b46c87f51153f2ad32c7c88d52a9be309d4fc3d58084b5d7f3413c91cd747f83f9b6a777ef3470ec595970f0507a5439c291327ecf2d5d2ae2231bf6fc852bc3561d1de067b02158787d4ad0e4b538114415739302b9347d0bd2f42ec73fa523e71b35d851b9157c0b16d2ac88f06c564acb4f63074ee721aa65d9fa1a688a44859a06dd1a2e7a01b367236b39a3cb74b6317757adc446afdd2ddfe95472eed32b417fb300447060dd664734430cb6090a43b313162e0a1ca25334464cf48ec7ac3fb803e7e2030275b27efff5086c71a61b62d74f7269f62eba8cc7442b6da41cc3a46e7c0d697c98b7c2cb9b2d7fd6e04be64dd584db9bb9d2f66273e84cbb4969d492f4f6115ce7166f66d27057e6503a94aa879890f01e52b744e28cda16656555268e739403ade7b55b6f916bc29640c4a465bcacc649bbdbd9bcf9acda9e85c3a75462e6d2c7eafbaa469e895d330bbadd5e4eaaadfff68ed5a21f92d0ec3c13c98c24c24e2f2e491a1edee5f14bbd91f6a1dc6ebc64b7d851628208900a64671414358c1b9dc0d07ff8476ce19b62a6923088f3d5b1e5e31bbf6ed902919775608f9836fae27d83df505f986faceaf4a31f3aaac7ef1ec3d33dbf6f7ffb94faaa4e844460d3b57779f12730005f97a1dadb4ddaa9441647e44482d0acc1104106cd0e7581ae428792d59e43c29b823c307fbc9f6c3ec2b0b4851f4e728743be32d09d9a31df22658fb4d4d1e87fd3cf8465ab646c91b44a4d62b90e3dde299fcf254a1f53b383db07a9e20f86f35c9fdd71d198e75d748982c7410de3ae739f8ba77edf6301ad8580bbad21ef18da4dfa331e4a6d192d55a0983433800f62c6f0bec454a74aebcc22d1ea453db33ba545ef8ed922b7054aca62036521f002d13d1f9b02b1c9b1741b57b8e7b1ba0f25943df8767fce4cb557c9bcdb207ffacd0b2161ac206bccc5dfe05e230d7866479feef4e7b947694e795b1d24c16197bbf5bcfac4ab7571385aa85ac0f642636ed7ac46ffc4237dd8819ca5cc52e40be96260849a0dcd40bd9e89d07c80ad26e7f3ba89fe38e8d1d1ce2ca6bcbbd6e36cc1ec007b75ca33d57ee7b5462634c91c2a5b0b8e787b003f4381b2bbaa9c9af8051125737906f09f32136b5943d53ff7f78298c10d6f47b25023e64bb0aedd97f0daf58fc78cd7dea865a9fd7bbbd277737c7e2017af708e3bc7c1fd850101dd100ef63f07e0147b7cae99fafa971c2e9e2a6704ef76e196237d6da1158aa50c1f0b76a82155979cb85cdab0c2569116f81502f1e01efa2dc8effee7d45aab8a21c37c6b65511e2aa8fa0259b0f2f5ad685e14e00fe14bd08a99f62b2d06dab80735fa94529115df07b61792dee2e3d13db1274ee4bfdcf8680fc1b6272cd25084b93e7d6d138b69fd58701042a1c1e34f52965e79833c8db6a48f7049e483553b95134908b47ba4af6904da8f97d2fc816dd39e23272ec32422d4878cf2c81dbb6e7062332eafe9cc408719b6310dfb7ca059b486b6e4d3e99740f57e1a163d0fa02558382ad6aa2620868ad50ebe1c1d0914f45659c074de7a18f68b15dce7dd60ae4601be40880c24668cd83af1e9adddb9fba532e7614bfedae129296ce0116b6b4b9a507c74c6c352a06cf62aeebc1b70d51fc87d49a0879aa32617df9813b6190a55ad5a1fc22102276ceda7b18e752d644f684ace979d2df8a0a904dcdaf8d35c8fde5d544e579c15756c29e9420da5a5af8c0544aef8e8179e37db4b9fee2887804549fd40f12e2fd39bf943acc0f3b1324afc7e89b66b605b533aee3d7fcb23b267886ce9388456799cc735b98a4224343d1a62a11500a26e3cf0e37458a37211e60a22a7559f07f2f4ca13e40c01caec93e4c749bc579eff0c7a1c4491ba08223231015b89014c82c18bf0c7706455d4d3be764bcbadc373b0e8aaa4fa520b9f532a6fe76fcf0f7466c774cc2a61eecb3f8ba031be0620b89a5c5163bd2a13b0ec07b1a236832eb6c244757fcba32d5b08c2ae71209d52437aefa97c7e1871627f7b77c95f5a265c171e27e65d2396d29182dbeca275506fb6dc5a9bcf037e10a626727e3f536a6aac9789b9126555acfed58bdfcc160d5ffa6fa66dc3d4b0208142fe38af3bfd094bc65858a3d2c90954d95c7b4e673c94889662e7cea43086eaf3f82cd2a75d11167724deb5c010955431e295b8ebfd2f667090c189793a0c4e554d822f8886aba0ac9c75f7bf7138348602c607f9c2a7b88c01e7194096b0d303c42f56bff5140b84deacb362a7c868b46f073068c7eeee13712048682d0156f7a63ef4514ec9bc24562f7bc8753ad30cb9f956ae979d091fadf973f0c90c4893cdfa0bad85c189fd518bf9f2b074364cddbd36356257cb493016e78c9af4743d7a31e9836c16e312f21cdd09d266a817e4c3341fa4861f19de1632d0b153dd51695cec4995e16a1d5978b981ca7d0fe36fcce33233fa4439e1de2f7baf3e923b13388f6832b23ba81b4bcac7346b31bfbbae741b6457ee7a2048b494cd05c6887d7be5cdd3de3c850030f4a4dbefcae5bacadd4a8c95b88964524b73a9d1984dc7926da44fa2f6414e50b615ba58f06ed19c5122f4a770182c1028a681c58acdda09f1884f99104ae06f2ae6fb40bbb4c400f920c2c6724e30f32df0464181bec38ae91b429c4c9274989a1c398598a71b1f90e8660c8d257aec1818fb24af8b7adea21ca696f07a56089a30f560f603503d2613585dc29358eb4c83125a519e5e835b2b3432ecf3d69258f70324c591600e7410d11696b5d662e54f490908531e3dd597d63065f2bc7a51d6e551348261d7fe4579f798a5085f6c9be3593bcb67ac1d0362fc0e72f43527e61e91efa099712f1d3b98f1a5b7b251bfa8c0cb2d8bc519effc239fab55bac2a765d7f221da1a93086fba5b136eb2b77ddb7be7f7287cf6838193fa0fabda6ee62faaab95a3f5b092c718d793c32731634447636bea5a4e2c54dded71286c02770e52c973246476ccfadda35aa93dee077bd1aa8d76aef0740566199f5aca484efca52198d18b207a0b232a0b473fc638f4d5d8df90912d95d5a2ac34b3f8ad9b0834d5bca715221e468d39e4da77b8e6d0cab57b9750d3efa8a321a50b218ff8a3d071eeeeb72e21f9484d9850dd7b8b908fa665264645b4efd43f876aee248eb61b9c954e00272702f32e2d61544779598b85e8fa59c66a065bd9196976551882703c431b698dc3ded44b1b58b0d61d9798e6c6dac602238f19e23712c5f5dd0b7c688287727fe23d09db235c97ba7e5ea20ebc854fbf8c098f7758dfb96cc357ada4026fc894fc6ab426cec7aae7bb2bc05464e0b01143a3accbbcdeafd744b300c62a37ba1ce09de0af75280dfc33d49222816c55970692fded2a51433543caa0b47332709ee3d9e6e81ad7a303b761a95ece13f45c9225e34ee229ea80e4cded65d29676539bb8dd6d80e7b96f1ee954b984686c36f4b6d202dd085ef6f4296126e17bbdd36508bab9f3fda3c83bcc6bce7df02598f29f5b0b589f058af5ab7cd13f17c253dcb604844d85dc0ba5eb0e352e0636ccd5e80fb1a7a8833bed97856aaa04ac69ce5222b4917002835776e895df5028b7af92b2678a13472707dd950e6b9e56eba7669ae29e86b7bf1cbc8421261cc9dd7fed59553c29aebce7934a24289c7daf5ad4a8e5221412826d290344975bd31f8b32bee45b3f372d09c915a8449c67d8f3ce1ece34d2a865002bebb7e76eb3380ebd0047bd2da164a1687b7fc094dc6808f9b21cf17f56b4800d1c2f941adf8689619d0ae2a0ab02fd9e8f2a0655517d1a239a9b63eee2c3f9188c8768e1a261eafac8ff09da9b2cdd6ca55fb83c5858ca1773623180c1baa59daee45cda1fb8531b549dde47c80c28f14fb5d729dabdb8400e4c9bb2c0ff586b952ec38d43b389f1fd825475bf07ff526d220e5f2d7b5294692fad7fe5d9fadea1335a07a2a3053e52a9f0ac25fbae2dd5a365aef145132a5e6cbe1e1edc04ccce6d297c7de7e876ba38d49abc09f526ac43416217a630d38ccc2ced509b10b30020f21d1edb9da65bd9ff8377815331032c44d079b361cf75b426e6e31ca24773d957e1e2139ab1c38f5a3349bb333c4a3f8a9ca989c3a604e1ff53d6fba1a10773c16c73f25619deeb9af9ddbc60f2ad34aae7429920534cc1e22898dcb45931b601868cc4a5b737fa279b403e17024b657f6305114ca9505e705372b24e905a9d866e6fcc3aed5ad82985ad3ae6c249617b5054d0b808b3fcf7e182fd8b631e9cf7df73cc3181a615b5cd9b2caa8d98a6d444c5728a38a8abe959047afd04ff738786e8e386ac204086f99be03d33e2bba1b1d0812021ddff8cb5f3a7c244feac6174c071125e98795966ef3670bcb16576a253b7f819a469e22a40d8a43a6a9d7de5218661da88083a9cf622d586aea421526ece392bb6b9500d5533923ef956f2b0dfb6629bdc081d40aac099d33b82b4b209ac10e0f00acb6d43bf699fc6bc9819169329ac985d472139f16e24e05ee1f59fe17e56b1e991595fb677d23e5fda9bef4368a9ebc1db37510bb31b0aabf4d43e715ff3e69f384b4dd554fc51700f126c76c2cbc5458c57aa42a18f756c442b5623644663527b04f34e0c13370a4ea7bf21e58a86119d7500417ef85e884e2b65f0860fa4f1a88268842d781f1199bcd27f28f52eaba86e11191c352cef147d7b5ee29d36cb9b87afeb59fc2db6a8a426997a0592305421a4013740206f4941f5a676a70ee5802f3a263f53e2a9a39773c98a37cdeb3263ce2eec15fcbe09a373151fa0c863be710416381e36b377d029461b65c1efb1426dc71e7056c5a6701b84f0d8fbf525a76939a2dbdc327e81fa5d84cdde15bbc2ad852c12fa4a6fd4c155f0ab9572188c5de4e908df97ef01174320db235d971fb241d9a7bb257b7d2f0451f455f2916b55ef77534bd6db1a77c9003f4f81095340841359323e06af15008fe67518815c5b76a9f850d1b883313ac974e343d6af5ef09e68cbab36c0d924fcf9745fbd24643a73f7d90c13b7b975dd7792d57c361f63222d613e6888eee96b2bc6f6ab7903790cad25a5499ca6930c4a98b571cecf7e46fd12ad9deebbd8933b24923d6535f6bc240bc7fda7241645173940fdc74b98fd0ee18a1120e500a644a6a0c987968192c4423cd784bee43c7ba892537f4a274a3bf78fa6c96f58cbe9d048c96c0f1637a19b3517da93d8bdc1997585ac3d55c5c41b8935cabedde8bc378f530786e8508b31e4b3577231be3b81daedecafe45b43d67f83188279b0e367b2a539e1c46443fdd8592d232d09b8b7bcac767a76f144efe1a27f7e5132a0513de8e677bcd5054ba3f59044c15e5241a0a13daf7572837f70f61fd6ebd230d207d31563f989d5b548963dbff5b86e2296fab64811bab7134c554f6da0be36491178c2a313bad017175301ad98a6fb887758e8c7ac5d86d8f001c1f96a08702c519945fed68c5cf21d3dd9641cb9258318a894771a54cea258ff7d0756e1adfbfb4015dd20d0a0e40313f07de15a61e0e42d42d42be2cb9b7c477c471303861d1007ff1c107c6230a145bd93e0367dc3d4446905a05b5d130b144090e815a7ac4c0294f5ecf91a1827804903f0b2dc58c6eafc6085e280706d9418fec95f046ac66ad77b54e3df44b8f1e417f6a27b4811ef6c469fbebceb74bc6f8156714652b351dccf84a3d18883985a3580952abd6d4555aa63f21c06391ff6244a1420d6f3a33dc51b9800c3617880198d00f7d7e27c5fcc6840355be79b726b6df3f8dd5ad402b559d8f3f3c8a58112ada5037d3b4596e64339ecd49e576f44abce4d42d8f1930b2f89e1d615d985f3fd79e1d01ee2e6114ccb71921e35e9e783acfc6d2e40561e0e09d0ac0ad897172e733a91b4017cf781e22ca17089232ecfb0c6c095d002ae719afacb8220395f270f2f546d284e7dc39b7d5499fea490cadfc68cdaaa9c7b4714f925b2597340ff1d1539914b1b799f91a33ec5389d240c773d5dc3f676068933d696ba40d2a5044f533b508ba4a6371bfea7658f388d07bac567e57525f26de76fc3835306c43afb5847234b5cc6c717664832e04273d5a65bbca1ca2b1b40eda4e17df950746acf4fecc936cfd814c871e1104504689efa84d36fc7cfbefc6c2b9397c667b419f413f104dca47c96f18c68092b87b13d7063ef9ad2f5e55f709b83b84d222d158bf757e432ad042763e210db0a276f8b33d959e9f8ba617dd4da5927113d09b97d82e1bfc981c73325f037094ec77a9b30d6fe0ca9f7f9b1bdec2442fec7aad41fbdfa0a0aafc39d0e9cc78703197e932a93effe985912f1e44655037a4c534aee032cccd1e9a89ea4cfd4e1eeff13a755a16fe3ed8d475155e097c5781d6cc419951f088577b7f167203883b25fcb2f691303403c3bc0fbde99046292156b4f4530a779d72d1a31c333ca85c0db47e34b6197d4090c6ba5e1ad45a74de7e17511d7dbd8277ef35d08f1b94a04baef93693c2f0b6bae927496f39bb57b0deea1d27c27524a0d24ac4c4a273e8b2acec8e21dd59c1261eb6e5032876b38a68d8f051098fdcdf5f4082f363eb99c372ada935dddfa8da254d18fd5ac9a934bd96eb483724f8d561f591304d14fe80aa5f82d5a6d06330bb0de966da9a63dfd8f14d4c673fd6337f38777bab8773f55825db71aad1299366f5dc15eee89a8809f038ddb2a0461e6b94614e838d9130712901f01b32373db220e0357edf5d8defd5bdd439dc97ef446f45f9dd326ed220283332adde69b364c79fcee7190f1c674a9f8518e9434602e69fe3a649a3425a6f1c5d6d9c5a38702c222bd44ed2030701a1489169f1210158e6b74d0f89e6c3a64dc0abb1260911d57f0440987c340e31ba11072de93b5d69f12c652d9b7ab80d9a7bf2cb1a297bb6456a9b3ee8ff97452e28c9a8468fba0281fc765c00c6507d6efb31710044870c3cd9da7fc912678c075dad10c09bbe853f046aca2d50ae3bf5a16fe7a7eeafd6a04bea4b05c43f3477d4db0a161e49921d304c42f9e515b83bd16205591ebbd0841a4616278a542dd3effb48ce285bb4884d11ad0c3294df0a807fb6f4723b0c195ee96c6917fa9f1a294cf11570d01a66b0f36cd53f45a6b51bebde1c39848d60091c7f4c71b4359c28ed3545a281c7d5c2beb51619cd730429152d72cbd11fe28b0731a4f6dbe293c3896acf2a75e099518baf397cfe4ca0c5b3f704b5f7d04584eda56dc4e6ee74799c2350a8db3f2f5c1ecc325f7efa23dc5187af390581371add8b678f78908eaf76c4ce045293cc4667e28086f873b82923f4775d0a2a3cbbd43458e45caabfa80c17bac34088da28189888d3c1a7a9333c536fef1f4ef9ff6d6da434942dc4fbc7895c0fa1e1cf9750844d900b303ea5746478595c421062811e1932c52e3a3ffdeb8b15b916f6bfb57f6e7a7ea74b9e8edc4abdbe34db6cfc68012dc7117b941ebc192745c47361a98dd3c23f4aa0e09d46af607e87736cbcab8b869679f0f2f3952b4d18abb0071de894eae2979fed8f084b2a6c8f8264694289099435f6bf44730c2a7307f1c118bbb33ac5bde38dc446619e8148740a71b258ba246328c9e5b11dee6a396e35ebf1081173cc63798f0d8b38207d07edccb8e8aed8dd47c141a300793ae0db2386c58b8d5f317eefbcc43638afe1c2f1622e22b3d0f677b878a59706202dd508d003b0c663686adda97280bbe703a5518f54fc5cc785113c598764e41787655401d60498cff8088bf9e52389fd5c5c0e55befad71ab74c14b9d9e53604150c7146db7d52e0d1ceb1d72a834e6af5ac206e577731fae634833a69a118f57ea997d35105010bb4a1d5a12b8bb654c2ff34358e0f1540945beb8f45a3e6be8b8d2da12b95778b9b03e951c57cd4ec7a2635f365edbde1a0bb629dc5be3adeaab7bbfa4222ba9ef3ed0d7844e7fead035ecf8a628ed9bcbb0aac99cff1e0ea589b000a28e3e1f0c21d513c9bec6b72cebca9f07c2615fd810badbb04ce585380eb1e13a9c918fdf6a5da02f950328043c023d389d7769f1b2caeafc401909023901d1b95e066c92e4706f2f8833c576754074dcba13c8c4cab643ee4006c9fd0e52829c8ee4cee240e9266478acb7c9412552f91bea80f4f3b79e6775069d7202330b8a398c202e3cffff2669a35b915ccb97b28d87b101f880b2cb14a30ac3784517de5ffa5b2b27930f88189dc3b0482a6db0ba23aa93a82d8a0e1610e9ba1020cc71359fdb3329207cefb434d1b10d67e3304869fa6763972df277c5cdc906397ab0646b532e14e287fc941206cb86a894fc74d535c5af1b4569333d6eb74ffc62965984152e464952aa2ce39085de1188e64726459339bc7d42da34a04a059729a504e38bb729e5d838d70c049185e8f435c309f07d60a07fe1d0c4a32783d37be8b29fa6ae5775ce9ad431db8d74becb1477f6f02a39423eea09f49c9b8d47c869734e417a3580b77dab53e99a6971fca1eca14828bc6ca04cc9b65d06e21e80f35ad08a5a94fde4a089c3bcf57e9f4dec64a63f5d6de3181836c96532b929255a7fd5638a64d91b2e5008c558018d58d8e99b460c2bc7d535c9b1b1bd3f9ac81f5e6b122b1c058879e17ab5aa542795e29a32c1f12a82a76c088e775d2495ecc9688fbefeef6d102bed36eeb902c87df1f8173db6e46285a428d8fbadb4724b83475d58b7fd7745e133ff099435363f32879238a96439be5f3cf8fe911d2bbcc59d4e8d7750cac1ed0cdee3c5cb8a0c675ac63ff78897c0675af0cf47a09a2db9fd782647091c5235702410bfb3341abcde6018695f7ecbd4dceecee0fe6ce36cfdc294bf9714cd90940decb63f967a89b1b72ec111d4774f6e9362de55d14043a88721ee023784c0ef1a66a233294ba571b5919e2ed1f081ba4e4c2e8fc13413d46b326c6b3d266ad407c20565f2b539d11cffc7d1d0655353892195eec5d827367b7df2f5bc6020b9167f39d12606801e2a9f394409a712f80c1fff1d2122c93e48315a167f65eb3094c24becbb24deba37d48c7c170c6fc59e8a7676700192342b2861a2409d319bbfcc4bc748be096859dc92d77b617e619df8fe49351f1cbe531b283238f7599f25840011ac9f1ea2c282bb136a3d59ea0af2c5505d829f35c638f5360fe3d0fdc2370f36ce76c178f785ccba0ead7b252eb41a66464361711dcbb46c3f3cb0afd11f2f4f8df2f3811bed5c951157458df322e15e540296cfa69068ec28f2024f7316687406a421c2df617a0d9715d28dbe3de7a0718b4d058b7c8d044141c483722bd1db5ff293333192423f4c530fb7740c7ff96034d439752cc60b77ade9c306994fe98bebe6e051bd13405bca86763f962f31189656b76af35309b132308118ebba52e8942a2dcee49742f56af5e7d9cec0ea5155a0f3b8117b804d7310817767d0135a340a48db77c0df1c19e77ee38a3edb9fe639618b9be1f10226b4b604a9740cd84ad6b4afe245a460bd0a0213a39c887a6b7f408a96d22d49173c03d546ecc165bb765785bbaf2d704c37a77c459b3b9e52acd696f1f5f113fb46bf1d97cf5676d7cb527366ba8592f919433ff512d10634368a0735de90746f4a456f2f9b6763cb1b1a7a300251ababe7490b8a2fb184e76d914e0f8056f7cc3f4a04d98e6bbba2876355c8005ae50f624bf7e055e423d1ef2471ea76acaa017be29b1a64e06fe69911e42c60e788379814899a1e20d03950338c39198dcfadbe55e282333615f239a9745adba4252859337fc119d1ffd6edc19ac4f083dc665eb19527027ec3e7ae96d9453d5737c3248b801b5b2a995aa916c415d0c8c6de1efe7a1e8be0786ee477c2fb580ae1156d9d62d1eacc0e76aeac0ba77bc6ef28b17100848ae1560b00463d178c74e2de11d564e5cb568cc23a7ff52a222a992e9eabf4249ced7d4bf4c1dccbd963b45b82ab7ccb7fea914db6dead360f77ea5805ba3d9b031efe67a0795be733bb86719eccba38a18f9e41799143e0d792607e4fb5e35ca0c563967a55ff6c9a505e77ab8f57fd640c74ac88a702dd45713309e20630d712ffe8946dcebea12a1a55ddbf7e2844ca8523d1b1e7d3075c1832cc3b7efacf43acf5bef922cf008b89be119bb8c71ff21b069d96e67e674877071fc4ef287e3a65125a6b2a81b83bdab281f2074bc73fc3cfa5aa69ba7e26313c0c7b18c4449b73b2144fa3fbea767dd48b0582b58bf9f21a9e4c85215ffa3a14923ade1b9834fb87876ac32c0694d51b8f0f68d263509d19b46e1df9371005ad8a4306a83dc654f89d3f198e85f5becae8ded78dbb66705d7d952f89c72bb6a5dc6fd76a3dd7a80966d004828bfdd29c39faf0b981546340b215dcd30e485fa733f34b98fc823c9585732bdcc006685221387323168d6c498549984ec2e2007770bb74a83cf89a728d6f2703969babe4726d021ae14d25849f209b4a810ec30217ab8f1c8f3a9d2b2af65716b20d79ba56a2d06b368ec7ce2aa2a1900ff0a9e2a150d9a1505bdc61abc34184df377a632ac030c55d3050e389b9e35598a4f7cb27771d88cdab2d28004b1648ae246c4485db4aa9bbb96e5c784b0a0df6a0786201fd07c17b1118739ae55938e4f1acccaf46b0718c27332f8b2323305723732a7ad39bfcbfb43d1ba2245326203815926ee81f1176020f5bc77629392737022af5e445f76126f1f79cae6e52f7097c8d954802fa914b24f98b03ed4bb47eb0ac1814a1182d008c0018c9e749ad9eee8d7e934447bac63f8115b4c2dc9450267bc9035678f83db18dc3caffe95135b78ed12df55929e6b37c4e9f6888a14cde2fbb91540411385a1c60a8a81f32f5f081bacdbbd912089e76b4b8caf32c15c153fbd4a552bab7ae2ea68d4829c2f0c9d2bfe9e21e34388f067efd9a8880d0a9c99e1c507f4dc4b38e8f28083da0efa9531621d0cacb24825ef3f96939747023d9c6ab14fa3c5a72dcdb42b3d24cd9cd932825fb65ac39df0200d452998e5513a322ffec628c8288a987b49355054758b2dac31eefe87deecf449d83debbfae643dfbdb4e6cea610b1fcff111ccb7201d6970991946d7782eeedc2eb74d17279ccc03fcc77e525e846017aae9a1290af609baf57b859a5ecb47dfdec05861668b2ef9bf692c04d1b7fd1be8b63cac7e57d9a643b6354cc5a2ae83e6c7f7f35ab44340fceb8ebb3badef9fb3de8847c347a8029254bf4fddbbb253711c89935859fd7ca8ba467c91898f9fa8a63da01e2d8baac07c68fc641079e24c889b16a650571223cb32fc522ea8d3ad19471bd6fac0b4aea6308fabe2fc5e06b3e011deb8c7e5384a55ed65fe3851c1cd0905e4ec7e0ef1771c79391a15b56decdd3235e1803725c1157e5859ecb8d58a891d40ca8f88764d420fc8533ff1ca6d7fa946b70f2cd75661a325931c8039112c5d2e5f9ff494b4f733163cf94bd359b96d3132156dc7e759af8e64c93fa71660d9935ea794b6eb39ac63286437b6849ea30d86a048636ddcb098743de09e8842294d5997aa73f8d5c7fe478f6ec7f3b1c25e62c46d00c273f0e566abe1fcfb8e358aeffbcfd752d3825f5d0d8ad553c2f91078bcd82aaeb8a9abb8caa291bcb435af2984efdeef5ecf070f4cefcfc7894787ee2abd118de75e3bcf47eda4139e4e07a68ff24bd30916dd63f27383d8e15ff42aba4886ea46f7a9c1dcdc5d325a608dfd210b0ed6b01d5803c3e3e1db24f6507f5db38e6f3e6c88b03f9e161cfc825d2987abbe6f7f616b992530d67dc4f9ec1a13fc360b8bdd1b4a3d4f61dc8d8c4908b9440eaef7a031114ae54dc7959e3df773c59e94ffbe9305543402ec088048e6bb6a678abc5c9f185509703c0811f3b5fc83c4a9ac6ea2ff6c5416878309c65553ca9a260faba9a45ac6812066a6b036b8d74c4145caaa0ff399a81c0fb5dea9b9abeadc17ab5da115825aac8ef7046bc93d6b0e542cfcbf77a3924608fe9936f182f13122334f574856bbfc44960e5c7a322b0f9a6e0a7c9a97e32c6a2ed56b69844b65f454157d9c20ffd3b66ffe2a444413c0ac7bb1d4fba04da7da4b0089fd710fd1b151e2c6e766dc0c669d877040ec4e65df9990e413c7f90df4a07c8469ae1f5647cf01abd2c1a15a8ecea51e5e43a190c0889d2381fe56d17c7ee8a67f1d7196e6cd38f22daf445ec43d171f516ecf168fc0909c85872e2c21b44cfe26e637c6e7c1bf2b29cf274039137ebba3d324e7bb0e68b535da99a632cdd69a967df6349f2d6f78e138fdbef95ea43a0137df127a0a1f0a9410daacbacd4455dc0e23af4fec3374013ec5aa4e75b3a3562d0ceb1cc4f5e9f66b355580eeee95048b57a3eb1b4566905d79b2d50eab91418ffbe544380c89fdd842961d3b6be65c68c353c48602cf46488b4c5b39eb40eb77441c1e33c71ffa60e5e61ad720a51c8c586b1f2662572df463311269ee14c6cc5ab9dccd0f410eb92c13002f577cf21ac4564d94fa4eaeb3500703e61b34defea637e390fb939a0bad55d88b41cf3806c90a3e607fa416a00899c256fa2f10cfdcebe1e5f1f165997f698d250da68a7a58b02d94c233ffa26d7795b2434a487eacd7ae3de02f2dc1279013e8edb136515a3459ee02bd8231c9c0807bdb6def018a8be6639a1d45272f448113d8758c86ed6690ca40f8e90caa561b5bbd03994688f81bfa4466b0c1acc45e27b5c5d81b044be0e599bf35526d524ebab3ea95dddb8ed52b0d55db9b74763f966831ca233e9b52f40556244d2ddd5945568fa730a18d737dec9238a547cbe349ec2da8b22ab0a096214d6ba460367cb38c82733a5cdd842dc187c066753ca4a9ec0c4dfebafe8978337e85383abd37a04fa46cafa1aec1ce5ecf23df8dc58cc53d5883697bca375a02e128f1d72c26bde3694f8150d6a6ffe33898281d0b0545f243c5efed8cd9a16a66f88b39ff4116210494aeac7b1d681c4bcb8fd9b03acaa9dbac3cac7cb9ac1fd1b7d6c6fde02ee8d4c22dcf8e0f2de2e98260f8714346601cbc4752d8f32b9b8dc931143adb2ca01915e88e581b713259f6b592982164244a9b5b250bd2f67ef1e831abe0cff5d5a2a1407d474c6959ec99dbbb04002a36bb82eebab54e14831186863b88176399a1ae2efc6034be2db909bae2376e190ab44029ed1f735d5b3ce39a0f6bd6dbd299b6094ac800e7cea71726f3e2f8ee051188ceef6c01217c99b276271beb3b282da83974a09fba217ded9e1b7e2917e326fb25fca3bfefc64a71c228084cbd90f70c90d44c13172bfc7b69b6eede1c043b97ce86cb2bd83072127ae8d6ff341320af8d1e4ce7f85c6ec3ad0c43c3ad84711ab4f9126a7423652def98c93a3345ad8d28791c0d390f3027cf22bacc0aa3faf0a8524c95da1098b772da15af3c2a2a6722204cbbd138c9e91e7beb8f74835892df37199163408367dc6d12898fa6313d474b057c9ea8e991e20bc7efab714ca565c50b5e6e667b9eaca4f77cd63f71e31c0e7f50bc34db56e644ea10207b3f3435882058be80fbbd5d3ba4d6be44f51d88a1002abf05bb0eea7ff2652e08fddc8151497bf5f2677ab5856df2974e3b08d8b2326ae053db13b237222c8d1f27bcd599f22a18b924ae871582ba139e02b36d0ba990ac725452e9d79da0535e1f69f8e9ee1062c5dcab546c8e16496b0914d7fe9bbd07f1efad48a7eb0116ca5923a2829cc9a91d4f37e27bb8b89211e14eaf06db883959cfffcd3e5de2abc51c6a30cedc590a430640ec5ed2ce4103399e06f52cebdf439c66deea0e08a62dfa9689bfa27c606fccd48a963200062cf19ccd508d783f759ce2d0d2ff159952bf82c5b7f661dc5fba974d469a6e3bba0b5b9b9c0bc3940fbbd6de5d1016b368d552fa29fc9d81348fc70170c3f831cd97aeb020394507e2d816cf4aa80563a39a299adcd2e7519db13fd380830221d0624890fd8fcf1642c5cab4cf1c51e612463923101ae5fabd11995f54c723c151c89d5a94681d2affa9035ee59f7784cd1ddc1d46f8d484b3662734a16c7d93451a8e0af02248ee56435c330ba33f70de13b9d53b5994ff7d7bd04e91d59c8dc555762185b77dacaeff0b33b91db9c528a6c0aa8b982e4fa5662cae29a1b418ddf2dbf790e73caecbaeb8bd2b6f1fbc5c358ef905dc24dc8ba7c2fe7adf7e8ad73003a08ab2a98129364e6022c4105bb636916857763b5039ad436d4372d1bd22bab81f3c7ed722d068647730666335f13519a8da4f682391ffd6cfc0a1fd4d534ec4325b1f629bee62ac8d49a46f40ba0b3dd1a9bf79ceaa77f20ae148560e231b4a98db51ff71ccbda691e7a2a39bfe36550d1600c366cd75cb1f4c0cf2160179e55b823b51a87b6ac337f6c23bf94cc8a8508e6f55a4e437bd17fc9759146d2f99e0ee030f0ba7f438b8daeb2bcceff74e1b506840bafa905de16a0de7725ef7e834e6e0961e5b23e9cb908555e20230fa4a708d996b7598b43626f411cf3fd9f715d696417a0cdc5990e830cc1d22022c474f0f85c7f6d1324f4d66b22586dfd6d340a9d3fdb9f53ff03c1d446228b50e71f936df95b777dc186fa6d84f00ed6d5572da24f8f09b35d66a8077d023c6c71d3d489a21e208395fc36215881d8716bc545af9091783847868932a9dcdb8d91835f487a2b8788463fbf50abbf73285bb28a29124607f246020c522aedbf94b98e778d15cc6654aea4336a434abccaf57a948f469085df3453b08e8a46bed93764804ceb0cd4aaf7f048af48a721c21402827f8c4bea1bd481e8ef16e0efebbe05f0084134ff4f07c2051b31fc5798ca7d0eaae0fec71b20b65decb59517045462397cd2747a25f8565dc92dcd0cecc3aa78908b466ea8cad518bb952b88b7523e3ad4d99d6b9cfdc5b13f26f7f02903b3a6213960475d607bc1aa453481453b2699268b441c9f7067361b813d9bd92bbe21601747165d9bc762a1b4817abf6cd25216368d27b16741ebebba522e036f408ca34063d71d59d685706d538ba06343e9638b91dfddc980ac2e0df30810fb5f2c2ad28d0cfdd27d6d52a2a5898606c9ad19103bec4f6ddb4d0921542cf2d4218817eb1ec9ff7f455ba1c6dc5a6e5bb2ef4e0ecb970589ba250dd46a305a1b96268d6ec5ec6262d4c17ba059ed9c4f609f7f47c1070715e416f7a384248777026206fed53bfc843e19bc3fc2e29979ad2251ea449b41f930af336810954567b470238eed485c3652414d3be7b9375d6b2f635ac390bbba6169fa088aa933a20a0a19823c116deb07c4f7cbff01e85a04e1af0ee4d46211a6f9a5a8113a3a0eb5fca317a37f456e272f413b0f179e0cb817a86cf6a4082d93c1bfa066d75f3361a7e579c8aee07fd6bdbbc58513d95f8c8f4755049bc36174befbd18fc50b4c39d486c6d71866f023d119b03033896261eb254d2da92a6f25202341eacbe37e694d08e692973cbb10d0d6cc2ccac4ccb66ce707def2b5e544c0cdc16aa107a1011e99a99b277854e7b78a12983421d6353fd5db54dec0930cf5210bd7750c91a049a73d2d8bf3916c9490ce3aa3aa3eacbfa85f43238b1ab3561a3c710fdba4e6d90e92b4c828b994365decd1c0d1a650a3c0513b7cd280babce0d8f4e02fa6d47a9ee99f352578071b514e01eaaf9b5ad8de8b17cf1926591bfb84c23a220636cb39ce25aa44b5e2a17b9dfb2ed82b09ff302eca6fa049f084030792457a244df18d0211e29b139aa6945964cfeb9d6b8c8b36be6efa459c16be431a69174f277f96b754f57f471916a848265ad9e71e244b1c8f758db747a2d358cc81446ae41f697b5b2166fb4a3fb0755501866d4c4fa9ffbc2ce8ea1d386401c8d54538e9eda5c6cb93fb9ba0a103b83f0b0c9523dedd3a9b38933c0584fdabfcff52e97e90ba8e470091d30afcc21cda9dcef157c38b453b6e6167f5494d453f286241a68f52460e50e31a1b1a8d7cac976e9e67bccfe772c56aaa1c9022f57fa0a1b7f5a5f6c03545579ac9b6a409bcfdfcf0e9de07855d6670f50e5b164adf5ae3967e2d61295b73d4386c8988a681aa557b0822f3035a43f9ce3dd7a1bfadea6818c5751d3879ed99ab26e0838a3550d76b3cfa3e891a231f49786871086c0145b31b7aa50c43d26e9e1310400b2165b86936859a6e052c827de39101dc38d3671e289cf89ddccf25c63d4c1bab8f7219f03ab11bb32bdf2b45402d05d3d1fa7245cf6235c61938b4a5d408d58a1f1c806fb0f0072ecfa314e374bfc1fb549b7ba2c3b4304b4d59c408118b4632804d3a4c0e1b3cedb516ee13319cacffb92e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
